{
    "name": "https://react.dev",
    "url": "https://https://react.dev",
    "pages": [
        {
            "url": "https://react.dev",
            "title": "React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "React"
                },
                {
                    "type": "p",
                    "text": "The library for web and native user interfaces"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Create user interfaces from components"
                },
                {
                    "type": "p",
                    "text": "React lets you build user interfaces out of individual pieces called components. Create your own React components likeThumbnail,LikeButton, andVideo. Then combine them into entire screens, pages, and apps."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Video.js"
                },
                {
                    "type": "code",
                    "code": "functionVideo({video}){return(<div><Thumbnailvideo={video}/><ahref={video.url}><h3>{video.title}</h3><p>{video.description}</p></a><LikeButtonvideo={video}/></div>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My video"
                },
                {
                    "type": "p",
                    "text": "Video description"
                },
                {
                    "type": "p",
                    "text": "Whether you work on your own or with thousands of other developers, using React feels the same. It is designed to let you seamlessly combine components written by independent people, teams, and organizations."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Write components with code and markup"
                },
                {
                    "type": "p",
                    "text": "React components are JavaScript functions. Want to show some content conditionally? Use anifstatement. Displaying a list? Try arraymap(). Learning React is learning programming."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "VideoList.js"
                },
                {
                    "type": "code",
                    "code": "functionVideoList({videos,emptyHeading}){constcount=videos.length;letheading=emptyHeading;if(count>0){constnoun=count>1?'Videos':'Video';heading=count+' '+noun;}return(<section><h2>{heading}</h2>{videos.map(video=><Videokey={video.id}video={video}/>)}</section>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "3 Videos"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "First video"
                },
                {
                    "type": "p",
                    "text": "Video description"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Second video"
                },
                {
                    "type": "p",
                    "text": "Video description"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Third video"
                },
                {
                    "type": "p",
                    "text": "Video description"
                },
                {
                    "type": "p",
                    "text": "This markup syntax is called JSX. It is a JavaScript syntax extension popularized by React. Putting JSX markup close to related rendering logic makes React components easy to create, maintain, and delete."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Add interactivity wherever you need it"
                },
                {
                    "type": "p",
                    "text": "React components receive data and return what should appear on the screen. You can pass them new data in response to an interaction, like when the user types into an input. React will then update the screen to match the new data."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "SearchableVideoList.js"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';functionSearchableVideoList({videos}){const[searchText,setSearchText]=useState('');constfoundVideos=filterVideos(videos,searchText);return(<><SearchInputvalue={searchText}onChange={newText=>setSearchText(newText)}/><VideoListvideos={foundVideos}emptyHeading={`No matches for “${searchText}”`}/></>);}"
                },
                {
                    "type": "header",
                    "level": 1,
                    "text": "React Videos"
                },
                {
                    "type": "p",
                    "text": "A brief history of React"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "5 Videos"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "React: The Documentary"
                },
                {
                    "type": "p",
                    "text": "The origin story of React"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rethinking Best Practices"
                },
                {
                    "type": "p",
                    "text": "Pete Hunt (2013)"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Introducing React Native"
                },
                {
                    "type": "p",
                    "text": "Tom Occhino (2015)"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Introducing React Hooks"
                },
                {
                    "type": "p",
                    "text": "Sophie Alpert and Dan Abramov (2018)"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Introducing Server Components"
                },
                {
                    "type": "p",
                    "text": "Dan Abramov and Lauren Tan (2020)"
                },
                {
                    "type": "p",
                    "text": "You don’t have to build your whole page in React. Add React to your existing HTML page, and render interactive React components anywhere on it."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Go full-stackwith a framework"
                },
                {
                    "type": "p",
                    "text": "React is a library. It lets you put components together, but it doesn’t prescribe how to do routing and data fetching. To build an entire app with React, we recommend a full-stack React framework likeNext.jsorRemix."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "confs/[slug].js"
                },
                {
                    "type": "code",
                    "code": "import{db}from'./database.js';import{Suspense}from'react';asyncfunctionConferencePage({slug}){constconf=awaitdb.Confs.find({slug});return(<ConferenceLayoutconf={conf}><Suspensefallback={<TalksLoading/>}><TalksconfId={conf.id}/></Suspense></ConferenceLayout>);}asyncfunctionTalks({confId}){consttalks=awaitdb.Talks.findAll({confId});constvideos=talks.map(talk=>talk.video);return<SearchableVideoListvideos={videos}/>;}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "19 Videos"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "React 18 Keynote"
                },
                {
                    "type": "p",
                    "text": "The React Team"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "React 18 for App Developers"
                },
                {
                    "type": "p",
                    "text": "Shruti Kapoor"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Streaming Server Rendering with Suspense"
                },
                {
                    "type": "p",
                    "text": "Shaundai Person"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "The First React Working Group"
                },
                {
                    "type": "p",
                    "text": "Aakansha Doshi"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "React Developer Tooling"
                },
                {
                    "type": "p",
                    "text": "Brian Vaughn"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "React without memo"
                },
                {
                    "type": "p",
                    "text": "Xuan Huang (黄玄)"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "React Docs Keynote"
                },
                {
                    "type": "p",
                    "text": "Rachel Nabors"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Things I Learnt from the New React Docs"
                },
                {
                    "type": "p",
                    "text": "Debbie O'Brien"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Learning in the Browser"
                },
                {
                    "type": "p",
                    "text": "Sarah Rainsberger"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "The ROI of Designing with React"
                },
                {
                    "type": "p",
                    "text": "Linton Ye"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Interactive Playgrounds with React"
                },
                {
                    "type": "p",
                    "text": "Delba de Oliveira"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Re-introducing Relay"
                },
                {
                    "type": "p",
                    "text": "Robert Balicki"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "React Native Desktop"
                },
                {
                    "type": "p",
                    "text": "Eric Rozell and Steven Moyes"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "On-device Machine Learning for React Native"
                },
                {
                    "type": "p",
                    "text": "Roman Rädle"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "React 18 for External Store Libraries"
                },
                {
                    "type": "p",
                    "text": "Daishi Kato"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Building Accessible Components with React 18"
                },
                {
                    "type": "p",
                    "text": "Diego Haz"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Accessible Japanese Form Components with React"
                },
                {
                    "type": "p",
                    "text": "Tafu Nakazaki"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "UI Tools for Artists"
                },
                {
                    "type": "p",
                    "text": "Lyle Troxell"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Hydrogen + React 18"
                },
                {
                    "type": "p",
                    "text": "Helen Lin"
                },
                {
                    "type": "p",
                    "text": "React is also an architecture. Frameworks that implement it let you fetch data in asynchronous components that run on the server or even during the build. Read data from a file or a database, and pass it down to your interactive components."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Use the best from every platform"
                },
                {
                    "type": "p",
                    "text": "People love web and native apps for different reasons. React lets you build both web apps and native apps using the same skills. It leans upon each platform’s unique strengths to let your interfaces feel just right on every platform."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Stay true to the web"
                },
                {
                    "type": "p",
                    "text": "People expect web app pages to load fast. On the server, React lets you start streaming HTML while you’re still fetching data, progressively filling in the remaining content before any JavaScript code loads. On the client, React can use standard web APIs to keep your UI responsive even in the middle of rendering."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Go truly native"
                },
                {
                    "type": "p",
                    "text": "People expect native apps to look and feel like their platform.React NativeandExpolet you build apps in React for Android, iOS, and more. They look and feel native because their UIsaretruly native. It’s not a web view—your React components render real Android and iOS views provided by the platform."
                },
                {
                    "type": "p",
                    "text": "With React, you can be a webanda native developer. Your team can ship to many platforms without sacrificing the user experience. Your organization can bridge the platform silos, and form teams that own entire features end-to-end."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Upgrade when the future is ready"
                },
                {
                    "type": "p",
                    "text": "React approaches changes with care. Every React commit is tested on business-critical surfaces with over a billion users. Over 100,000 React components at Meta help validate every migration strategy."
                },
                {
                    "type": "p",
                    "text": "The React team is always researching how to improve React. Some research takes years to pay off. React has a high bar for taking a research idea into production. Only proven approaches become a part of React."
                },
                {
                    "type": "p",
                    "text": "Latest React News"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "React Conf 2024 Recap"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "React 19 RC"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "React 19 RC Upgrade Guide"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "React Labs: February 2024"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Join a communityof millions"
                },
                {
                    "type": "p",
                    "text": "You’re not alone. Two million developers from all over the world visit the React docs every month. React is something that people and teams can agree on."
                },
                {
                    "type": "p",
                    "text": "This is why React is more than a library, an architecture, or even an ecosystem. React is a community. It’s a place where you can ask for help, find opportunities, and meet new friends. You will meet both developers and designers, beginners and experts, researchers and artists, teachers and students. Our backgrounds may be very different, but React lets us all create user interfaces together."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Welcome to theReact community"
                }
            ]
        },
        {
            "url": "https://react.dev/learn",
            "title": "Quick Start – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Quick Start"
                },
                {
                    "type": "p",
                    "text": "Welcome to the React documentation! This page will give you an introduction to the 80% of React concepts that you will use on a daily basis."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "How to create and nest components",
                        "How to add markup and styles",
                        "How to display data",
                        "How to render conditions and lists",
                        "How to respond to events and update the screen",
                        "How to share data between components"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Creating and nesting components"
                },
                {
                    "type": "p",
                    "text": "React apps are made out ofcomponents. A component is a piece of the UI (user interface) that has its own logic and appearance. A component can be as small as a button, or as large as an entire page."
                },
                {
                    "type": "p",
                    "text": "React components are JavaScript functions that return markup:"
                },
                {
                    "type": "code",
                    "code": "functionMyButton(){return(<button>I'm a button</button>);}"
                },
                {
                    "type": "p",
                    "text": "Now that you’ve declaredMyButton, you can nest it into another component:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionMyApp(){return(<div><h1>Welcome to my app</h1><MyButton/></div>);}"
                },
                {
                    "type": "p",
                    "text": "Notice that<MyButton />starts with a capital letter. That’s how you know it’s a React component. React component names must always start with a capital letter, while HTML tags must be lowercase."
                },
                {
                    "type": "p",
                    "text": "Have a look at the result:"
                },
                {
                    "type": "code",
                    "code": "functionMyButton(){return(<button>I'm a button</button>);}exportdefaultfunctionMyApp(){return(<div><h1>Welcome to my app</h1><MyButton/></div>);}"
                },
                {
                    "type": "p",
                    "text": "Theexport defaultkeywords specify the main component in the file. If you’re not familiar with some piece of JavaScript syntax,MDNandjavascript.infohave great references."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Writing markup with JSX"
                },
                {
                    "type": "p",
                    "text": "The markup syntax you’ve seen above is calledJSX. It is optional, but most React projects use JSX for its convenience. All of thetools we recommend for local developmentsupport JSX out of the box."
                },
                {
                    "type": "p",
                    "text": "JSX is stricter than HTML. You have to close tags like<br />. Your component also can’t return multiple JSX tags. You have to wrap them into a shared parent, like a<div>...</div>or an empty<>...</>wrapper:"
                },
                {
                    "type": "code",
                    "code": "functionAboutPage(){return(<><h1>About</h1><p>Hello there.<br/>How do you do?</p></>);}"
                },
                {
                    "type": "p",
                    "text": "If you have a lot of HTML to port to JSX, you can use anonline converter."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Adding styles"
                },
                {
                    "type": "p",
                    "text": "In React, you specify a CSS class withclassName. It works the same way as the HTMLclassattribute:"
                },
                {
                    "type": "code",
                    "code": "<imgclassName=\"avatar\"/>"
                },
                {
                    "type": "p",
                    "text": "Then you write the CSS rules for it in a separate CSS file:"
                },
                {
                    "type": "code",
                    "code": "/* In your CSS */.avatar{border-radius:50%;}"
                },
                {
                    "type": "p",
                    "text": "React does not prescribe how you add CSS files. In the simplest case, you’ll add a<link>tag to your HTML. If you use a build tool or a framework, consult its documentation to learn how to add a CSS file to your project."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Displaying data"
                },
                {
                    "type": "p",
                    "text": "JSX lets you put markup into JavaScript. Curly braces let you “escape back” into JavaScript so that you can embed some variable from your code and display it to the user. For example, this will displayuser.name:"
                },
                {
                    "type": "code",
                    "code": "return(<h1>{user.name}</h1>);"
                },
                {
                    "type": "p",
                    "text": "You can also “escape into JavaScript” from JSX attributes, but you have to use curly bracesinstead ofquotes. For example,className=\"avatar\"passes the\"avatar\"string as the CSS class, butsrc={user.imageUrl}reads the JavaScriptuser.imageUrlvariable value, and then passes that value as thesrcattribute:"
                },
                {
                    "type": "code",
                    "code": "return(<imgclassName=\"avatar\"src={user.imageUrl}/>);"
                },
                {
                    "type": "p",
                    "text": "You can put more complex expressions inside the JSX curly braces too, for example,string concatenation:"
                },
                {
                    "type": "code",
                    "code": "constuser={name:'Hedy Lamarr',imageUrl:'https://i.imgur.com/yXOvdOSs.jpg',imageSize:90,};exportdefaultfunctionProfile(){return(<><h1>{user.name}</h1><imgclassName=\"avatar\"src={user.imageUrl}alt={'Photo of '+user.name}style={{width:user.imageSize,height:user.imageSize}}/></>);}"
                },
                {
                    "type": "p",
                    "text": "In the above example,style={{}}is not a special syntax, but a regular{}object inside thestyle={ }JSX curly braces. You can use thestyleattribute when your styles depend on JavaScript variables."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Conditional rendering"
                },
                {
                    "type": "p",
                    "text": "In React, there is no special syntax for writing conditions. Instead, you’ll use the same techniques as you use when writing regular JavaScript code. For example, you can use anifstatement to conditionally include JSX:"
                },
                {
                    "type": "code",
                    "code": "letcontent;if(isLoggedIn){content=<AdminPanel/>;}else{content=<LoginForm/>;}return(<div>{content}</div>);"
                },
                {
                    "type": "p",
                    "text": "If you prefer more compact code, you can use theconditional?operator.Unlikeif, it works inside JSX:"
                },
                {
                    "type": "code",
                    "code": "<div>{isLoggedIn?(<AdminPanel/>):(<LoginForm/>)}</div>"
                },
                {
                    "type": "p",
                    "text": "When you don’t need theelsebranch, you can also use a shorterlogical&&syntax:"
                },
                {
                    "type": "code",
                    "code": "<div>{isLoggedIn&&<AdminPanel/>}</div>"
                },
                {
                    "type": "p",
                    "text": "All of these approaches also work for conditionally specifying attributes. If you’re unfamiliar with some of this JavaScript syntax, you can start by always usingif...else."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Rendering lists"
                },
                {
                    "type": "p",
                    "text": "You will rely on JavaScript features likeforloopand thearraymap()functionto render lists of components."
                },
                {
                    "type": "p",
                    "text": "For example, let’s say you have an array of products:"
                },
                {
                    "type": "code",
                    "code": "constproducts=[{title:'Cabbage',id:1},{title:'Garlic',id:2},{title:'Apple',id:3},];"
                },
                {
                    "type": "p",
                    "text": "Inside your component, use themap()function to transform an array of products into an array of<li>items:"
                },
                {
                    "type": "code",
                    "code": "constlistItems=products.map(product=><likey={product.id}>{product.title}</li>);return(<ul>{listItems}</ul>);"
                },
                {
                    "type": "p",
                    "text": "Notice how<li>has akeyattribute. For each item in a list, you should pass a string or a number that uniquely identifies that item among its siblings. Usually, a key should be coming from your data, such as a database ID. React uses your keys to know what happened if you later insert, delete, or reorder the items."
                },
                {
                    "type": "code",
                    "code": "constproducts=[{title:'Cabbage',isFruit:false,id:1},{title:'Garlic',isFruit:false,id:2},{title:'Apple',isFruit:true,id:3},];exportdefaultfunctionShoppingList(){constlistItems=products.map(product=><likey={product.id}style={{color:product.isFruit?'magenta':'darkgreen'}}>{product.title}</li>);return(<ul>{listItems}</ul>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Responding to events"
                },
                {
                    "type": "p",
                    "text": "You can respond to events by declaringevent handlerfunctions inside your components:"
                },
                {
                    "type": "code",
                    "code": "functionMyButton(){functionhandleClick(){alert('You clicked me!');}return(<buttononClick={handleClick}>Click me</button>);}"
                },
                {
                    "type": "p",
                    "text": "Notice howonClick={handleClick}has no parentheses at the end! Do notcallthe event handler function: you only need topass it down. React will call your event handler when the user clicks the button."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Updating the screen"
                },
                {
                    "type": "p",
                    "text": "Often, you’ll want your component to “remember” some information and display it. For example, maybe you want to count the number of times a button is clicked. To do this, addstateto your component."
                },
                {
                    "type": "p",
                    "text": "First, importuseStatefrom React:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';"
                },
                {
                    "type": "p",
                    "text": "Now you can declare astate variableinside your component:"
                },
                {
                    "type": "code",
                    "code": "functionMyButton(){const[count,setCount]=useState(0);// ..."
                },
                {
                    "type": "p",
                    "text": "You’ll get two things fromuseState: the current state (count), and the function that lets you update it (setCount). You can give them any names, but the convention is to write[something, setSomething]."
                },
                {
                    "type": "p",
                    "text": "The first time the button is displayed,countwill be0because you passed0touseState(). When you want to change state, callsetCount()and pass the new value to it. Clicking this button will increment the counter:"
                },
                {
                    "type": "code",
                    "code": "functionMyButton(){const[count,setCount]=useState(0);functionhandleClick(){setCount(count+1);}return(<buttononClick={handleClick}>Clicked{count}times</button>);}"
                },
                {
                    "type": "p",
                    "text": "React will call your component function again. This time,countwill be1. Then it will be2. And so on."
                },
                {
                    "type": "p",
                    "text": "If you render the same component multiple times, each will get its own state. Click each button separately:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionMyApp(){return(<div><h1>Counters that update separately</h1><MyButton/><MyButton/></div>);}functionMyButton(){const[count,setCount]=useState(0);functionhandleClick(){setCount(count+1);}return(<buttononClick={handleClick}>Clicked{count}times</button>);}"
                },
                {
                    "type": "p",
                    "text": "Notice how each button “remembers” its owncountstate and doesn’t affect other buttons."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Using Hooks"
                },
                {
                    "type": "p",
                    "text": "Functions starting withuseare calledHooks.useStateis a built-in Hook provided by React. You can find other built-in Hooks in theAPI reference.You can also write your own Hooks by combining the existing ones."
                },
                {
                    "type": "p",
                    "text": "Hooks are more restrictive than other functions. You can only call Hooksat the topof your components (or other Hooks). If you want to useuseStatein a condition or a loop, extract a new component and put it there."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Sharing data between components"
                },
                {
                    "type": "p",
                    "text": "In the previous example, eachMyButtonhad its own independentcount, and when each button was clicked, only thecountfor the button clicked changed:"
                },
                {
                    "type": "p",
                    "text": "Initially, eachMyButton’scountstate is0"
                },
                {
                    "type": "p",
                    "text": "The firstMyButtonupdates itscountto1"
                },
                {
                    "type": "p",
                    "text": "However, often you’ll need components toshare data and always update together."
                },
                {
                    "type": "p",
                    "text": "To make bothMyButtoncomponents display the samecountand update together, you need to move the state from the individual buttons “upwards” to the closest component containing all of them."
                },
                {
                    "type": "p",
                    "text": "In this example, it isMyApp:"
                },
                {
                    "type": "p",
                    "text": "Initially,MyApp’scountstate is0and is passed down to both children"
                },
                {
                    "type": "p",
                    "text": "On click,MyAppupdates itscountstate to1and passes it down to both children"
                },
                {
                    "type": "p",
                    "text": "Now when you click either button, thecountinMyAppwill change, which will change both of the counts inMyButton. Here’s how you can express this in code."
                },
                {
                    "type": "p",
                    "text": "First,move the state upfromMyButtonintoMyApp:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionMyApp(){const[count,setCount]=useState(0);functionhandleClick(){setCount(count+1);}return(<div><h1>Counters that update separately</h1><MyButton/><MyButton/></div>);}functionMyButton(){// ... we're moving code from here ...}"
                },
                {
                    "type": "p",
                    "text": "Then,pass the state downfromMyAppto eachMyButton, together with the shared click handler. You can pass information toMyButtonusing the JSX curly braces, just like you previously did with built-in tags like<img>:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionMyApp(){const[count,setCount]=useState(0);functionhandleClick(){setCount(count+1);}return(<div><h1>Counters that update together</h1><MyButtoncount={count}onClick={handleClick}/><MyButtoncount={count}onClick={handleClick}/></div>);}"
                },
                {
                    "type": "p",
                    "text": "The information you pass down like this is calledprops. Now theMyAppcomponent contains thecountstate and thehandleClickevent handler, andpasses both of them down as propsto each of the buttons."
                },
                {
                    "type": "p",
                    "text": "Finally, changeMyButtontoreadthe props you have passed from its parent component:"
                },
                {
                    "type": "code",
                    "code": "functionMyButton({count,onClick}){return(<buttononClick={onClick}>Clicked{count}times</button>);}"
                },
                {
                    "type": "p",
                    "text": "When you click the button, theonClickhandler fires. Each button’sonClickprop was set to thehandleClickfunction insideMyApp, so the code inside of it runs. That code callssetCount(count + 1), incrementing thecountstate variable. The newcountvalue is passed as a prop to each button, so they all show the new value. This is called “lifting state up”. By moving state up, you’ve shared it between components."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionMyApp(){const[count,setCount]=useState(0);functionhandleClick(){setCount(count+1);}return(<div><h1>Counters that update together</h1><MyButtoncount={count}onClick={handleClick}/><MyButtoncount={count}onClick={handleClick}/></div>);}functionMyButton({count,onClick}){return(<buttononClick={onClick}>Clicked{count}times</button>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Next Steps"
                },
                {
                    "type": "p",
                    "text": "By now, you know the basics of how to write React code!"
                },
                {
                    "type": "p",
                    "text": "Check out theTutorialto put them into practice and build your first mini-app with React."
                }
            ]
        },
        {
            "url": "https://react.dev/learn/add-react-to-an-existing-project",
            "title": "Add React to an Existing Project – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Add React to an Existing Project"
                },
                {
                    "type": "p",
                    "text": "If you want to add some interactivity to your existing project, you don’t have to rewrite it in React. Add React to your existing stack, and render interactive React components anywhere."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "You need to installNode.jsfor local development.Although you cantry Reactonline or with a simple HTML page, realistically most JavaScript tooling you’ll want to use for development requires Node.js."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Using React for an entire subroute of your existing website"
                },
                {
                    "type": "p",
                    "text": "Let’s say you have an existing web app atexample.combuilt with another server technology (like Rails), and you want to implement all routes starting withexample.com/some-app/fully with React."
                },
                {
                    "type": "p",
                    "text": "Here’s how we recommend to set it up:"
                },
                {
                    "type": "list",
                    "items": [
                        "Build the React part of your appusing one of theReact-based frameworks.",
                        "Specify/some-appas thebase pathin your framework’s configuration (here’s how:Next.js,Gatsby).",
                        "Configure your server or a proxyso that all requests under/some-app/are handled by your React app."
                    ]
                },
                {
                    "type": "p",
                    "text": "This ensures the React part of your app canbenefit from the best practicesbaked into those frameworks."
                },
                {
                    "type": "p",
                    "text": "Many React-based frameworks are full-stack and let your React app take advantage of the server. However, you can use the same approach even if you can’t or don’t want to run JavaScript on the server. In that case, serve the HTML/CSS/JS export (next exportoutputfor Next.js, default for Gatsby) at/some-app/instead."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Using React for a part of your existing page"
                },
                {
                    "type": "p",
                    "text": "Let’s say you have an existing page built with another technology (either a server one like Rails, or a client one like Backbone), and you want to render interactive React components somewhere on that page. That’s a common way to integrate React—in fact, it’s how most React usage looked at Meta for many years!"
                },
                {
                    "type": "p",
                    "text": "You can do this in two steps:"
                },
                {
                    "type": "list",
                    "items": [
                        "Set up a JavaScript environmentthat lets you use theJSX syntax, split your code into modules with theimport/exportsyntax, and use packages (for example, React) from thenpmpackage registry.",
                        "Render your React componentswhere you want to see them on the page."
                    ]
                },
                {
                    "type": "p",
                    "text": "The exact approach depends on your existing page setup, so let’s walk through some details."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 1: Set up a modular JavaScript environment"
                },
                {
                    "type": "p",
                    "text": "A modular JavaScript environment lets you write your React components in individual files, as opposed to writing all of your code in a single file. It also lets you use all the wonderful packages published by other developers on thenpmregistry—including React itself! How you do this depends on your existing setup:"
                },
                {
                    "type": "list",
                    "items": [
                        "If your app is already split into files that useimportstatements,try to use the setup you already have. Check whether writing<div />in your JS code causes a syntax error. If it causes a syntax error, you might need totransform your JavaScript code with Babel, and enable theBabel React presetto use JSX.",
                        "If your app doesn’t have an existing setup for compiling JavaScript modules,set it up withVite. The Vite community maintainsmany integrations with backend frameworks, including Rails, Django, and Laravel. If your backend framework is not listed,follow this guideto manually integrate Vite builds with your backend."
                    ]
                },
                {
                    "type": "p",
                    "text": "If your app is already split into files that useimportstatements,try to use the setup you already have. Check whether writing<div />in your JS code causes a syntax error. If it causes a syntax error, you might need totransform your JavaScript code with Babel, and enable theBabel React presetto use JSX."
                },
                {
                    "type": "p",
                    "text": "If your app doesn’t have an existing setup for compiling JavaScript modules,set it up withVite. The Vite community maintainsmany integrations with backend frameworks, including Rails, Django, and Laravel. If your backend framework is not listed,follow this guideto manually integrate Vite builds with your backend."
                },
                {
                    "type": "p",
                    "text": "To check whether your setup works, run this command in your project folder:"
                },
                {
                    "type": "p",
                    "text": "Then add these lines of code at the top of your main JavaScript file (it might be calledindex.jsormain.js):"
                },
                {
                    "type": "code",
                    "code": "import{createRoot}from'react-dom/client';// Clear the existing HTML contentdocument.body.innerHTML='<div id=\"app\"></div>';// Render your React component insteadconstroot=createRoot(document.getElementById('app'));root.render(<h1>Hello, world</h1>);"
                },
                {
                    "type": "p",
                    "text": "If the entire content of your page was replaced by a “Hello, world!”, everything worked! Keep reading."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Integrating a modular JavaScript environment into an existing project for the first time can feel intimidating, but it’s worth it! If you get stuck, try ourcommunity resourcesor theVite Chat."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 2: Render React components anywhere on the page"
                },
                {
                    "type": "p",
                    "text": "In the previous step, you put this code at the top of your main file:"
                },
                {
                    "type": "code",
                    "code": "import{createRoot}from'react-dom/client';// Clear the existing HTML contentdocument.body.innerHTML='<div id=\"app\"></div>';// Render your React component insteadconstroot=createRoot(document.getElementById('app'));root.render(<h1>Hello, world</h1>);"
                },
                {
                    "type": "p",
                    "text": "Of course, you don’t actually want to clear the existing HTML content!"
                },
                {
                    "type": "p",
                    "text": "Delete this code."
                },
                {
                    "type": "p",
                    "text": "Instead, you probably want to render your React components in specific places in your HTML. Open your HTML page (or the server templates that generate it) and add a uniqueidattribute to any tag, for example:"
                },
                {
                    "type": "code",
                    "code": "<!-- ... somewhere in your html ... --><navid=\"navigation\"></nav><!-- ... more html ... -->"
                },
                {
                    "type": "p",
                    "text": "This lets you find that HTML element withdocument.getElementByIdand pass it tocreateRootso that you can render your own React component inside:"
                },
                {
                    "type": "code",
                    "code": "import{createRoot}from'react-dom/client';functionNavigationBar(){// TODO: Actually implement a navigation barreturn<h1>Hello from React!</h1>;}constdomNode=document.getElementById('navigation');constroot=createRoot(domNode);root.render(<NavigationBar/>);"
                },
                {
                    "type": "p",
                    "text": "Notice how the original HTML content fromindex.htmlis preserved, but your ownNavigationBarReact component now appears inside the<nav id=\"navigation\">from your HTML. Read thecreateRootusage documentationto learn more about rendering React components inside an existing HTML page."
                },
                {
                    "type": "p",
                    "text": "When you adopt React in an existing project, it’s common to start with small interactive components (like buttons), and then gradually keep “moving upwards” until eventually your entire page is built with React. If you ever reach that point, we recommend migrating toa React frameworkright after to get the most out of React."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Using React Native in an existing native mobile app"
                },
                {
                    "type": "p",
                    "text": "React Nativecan also be integrated into existing native apps incrementally. If you have an existing native app for Android (Java or Kotlin) or iOS (Objective-C or Swift),follow this guideto add a React Native screen to it."
                }
            ]
        },
        {
            "url": "https://react.dev/learn/adding-interactivity",
            "title": "Adding Interactivity – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Adding Interactivity"
                },
                {
                    "type": "p",
                    "text": "Some things on the screen update in response to user input. For example, clicking an image gallery switches the active image. In React, data that changes over time is calledstate.You can add state to any component, and update it as needed. In this chapter, you’ll learn how to write components that handle interactions, update their state, and display different output over time."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "In this chapter"
                },
                {
                    "type": "list",
                    "items": [
                        "How to handle user-initiated events",
                        "How to make components “remember” information with state",
                        "How React updates the UI in two phases",
                        "Why state doesn’t update right after you change it",
                        "How to queue multiple state updates",
                        "How to update an object in state",
                        "How to update an array in state"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Responding to events"
                },
                {
                    "type": "p",
                    "text": "React lets you addevent handlersto your JSX. Event handlers are your own functions that will be triggered in response to user interactions like clicking, hovering, focusing on form inputs, and so on."
                },
                {
                    "type": "p",
                    "text": "Built-in components like<button>only support built-in browser events likeonClick. However, you can also create your own components, and give their event handler props any application-specific names that you like."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionApp(){return(<ToolbaronPlayMovie={()=>alert('Playing!')}onUploadImage={()=>alert('Uploading!')}/>);}functionToolbar({onPlayMovie,onUploadImage}){return(<div><ButtononClick={onPlayMovie}>Play Movie</Button><ButtononClick={onUploadImage}>Upload Image</Button></div>);}functionButton({onClick,children}){return(<buttononClick={onClick}>{children}</button>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadResponding to Eventsto learn how to add event handlers."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "State: a component’s memory"
                },
                {
                    "type": "p",
                    "text": "Components often need to change what’s on the screen as a result of an interaction. Typing into the form should update the input field, clicking “next” on an image carousel should change which image is displayed, clicking “buy” puts a product in the shopping cart. Components need to “remember” things: the current input value, the current image, the shopping cart. In React, this kind of component-specific memory is calledstate."
                },
                {
                    "type": "p",
                    "text": "You can add state to a component with auseStateHook.Hooksare special functions that let your components use React features (state is one of those features). TheuseStateHook lets you declare a state variable. It takes the initial state and returns a pair of values: the current state, and a state setter function that lets you update it."
                },
                {
                    "type": "code",
                    "code": "const[index,setIndex]=useState(0);const[showMore,setShowMore]=useState(false);"
                },
                {
                    "type": "p",
                    "text": "Here is how an image gallery uses and updates state on click:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';import{sculptureList}from'./data.js';exportdefaultfunctionGallery(){const[index,setIndex]=useState(0);const[showMore,setShowMore]=useState(false);consthasNext=index<sculptureList.length-1;functionhandleNextClick(){if(hasNext){setIndex(index+1);}else{setIndex(0);}}functionhandleMoreClick(){setShowMore(!showMore);}letsculpture=sculptureList[index];return(<><buttononClick={handleNextClick}>Next</button><h2><i>{sculpture.name}</i>by{sculpture.artist}</h2><h3>({index+1}of{sculptureList.length})</h3><buttononClick={handleMoreClick}>{showMore?'Hide':'Show'}details</button>{showMore&&<p>{sculpture.description}</p>}<imgsrc={sculpture.url}alt={sculpture.alt}/></>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadState: A Component’s Memoryto learn how to remember a value and update it on interaction."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Render and commit"
                },
                {
                    "type": "p",
                    "text": "Before your components are displayed on the screen, they must be rendered by React. Understanding the steps in this process will help you think about how your code executes and explain its behavior."
                },
                {
                    "type": "p",
                    "text": "Imagine that your components are cooks in the kitchen, assembling tasty dishes from ingredients. In this scenario, React is the waiter who puts in requests from customers and brings them their orders. This process of requesting and serving UI has three steps:"
                },
                {
                    "type": "list",
                    "items": [
                        "Triggeringa render (delivering the diner’s order to the kitchen)",
                        "Renderingthe component (preparing the order in the kitchen)",
                        "Committingto the DOM (placing the order on the table)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Trigger",
                        "Render",
                        "Commit"
                    ]
                },
                {
                    "type": "p",
                    "text": "Illustrated byRachel Lee Nabors"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadRender and Committo learn the lifecycle of a UI update."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "State as a snapshot"
                },
                {
                    "type": "p",
                    "text": "Unlike regular JavaScript variables, React state behaves more like a snapshot. Setting it does not change the state variable you already have, but instead triggers a re-render. This can be surprising at first!"
                },
                {
                    "type": "code",
                    "code": "console.log(count);// 0setCount(count+1);// Request a re-render with 1console.log(count);// Still 0!"
                },
                {
                    "type": "p",
                    "text": "This behavior helps you avoid subtle bugs. Here is a little chat app. Try to guess what happens if you press “Send” first andthenchange the recipient to Bob. Whose name will appear in thealertfive seconds later?"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionForm(){const[to,setTo]=useState('Alice');const[message,setMessage]=useState('Hello');functionhandleSubmit(e){e.preventDefault();setTimeout(()=>{alert(`You said${message}to${to}`);},5000);}return(<formonSubmit={handleSubmit}><label>To:{' '}<selectvalue={to}onChange={e=>setTo(e.target.value)}><optionvalue=\"Alice\">Alice</option><optionvalue=\"Bob\">Bob</option></select></label><textareaplaceholder=\"Message\"value={message}onChange={e=>setMessage(e.target.value)}/><buttontype=\"submit\">Send</button></form>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadState as a Snapshotto learn why state appears “fixed” and unchanging inside the event handlers."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Queueing a series of state updates"
                },
                {
                    "type": "p",
                    "text": "This component is buggy: clicking “+3” increments the score only once."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionCounter(){const[score,setScore]=useState(0);functionincrement(){setScore(score+1);}return(<><buttononClick={()=>increment()}>+1</button><buttononClick={()=>{increment();increment();increment();}}>+3</button><h1>Score:{score}</h1></>)}"
                },
                {
                    "type": "p",
                    "text": "State as a Snapshotexplains why this is happening. Setting state requests a new re-render, but does not change it in the already running code. Soscorecontinues to be0right after you callsetScore(score + 1)."
                },
                {
                    "type": "code",
                    "code": "console.log(score);// 0setScore(score+1);// setScore(0 + 1);console.log(score);// 0setScore(score+1);// setScore(0 + 1);console.log(score);// 0setScore(score+1);// setScore(0 + 1);console.log(score);// 0"
                },
                {
                    "type": "p",
                    "text": "You can fix this by passing anupdater functionwhen setting state. Notice how replacingsetScore(score + 1)withsetScore(s => s + 1)fixes the “+3” button. This lets you queue multiple state updates."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionCounter(){const[score,setScore]=useState(0);functionincrement(){setScore(s=>s+1);}return(<><buttononClick={()=>increment()}>+1</button><buttononClick={()=>{increment();increment();increment();}}>+3</button><h1>Score:{score}</h1></>)}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadQueueing a Series of State Updatesto learn how to queue a sequence of state updates."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Updating objects in state"
                },
                {
                    "type": "p",
                    "text": "State can hold any kind of JavaScript value, including objects. But you shouldn’t change objects and arrays that you hold in the React state directly. Instead, when you want to update an object and array, you need to create a new one (or make a copy of an existing one), and then update the state to use that copy."
                },
                {
                    "type": "p",
                    "text": "Usually, you will use the...spread syntax to copy objects and arrays that you want to change. For example, updating a nested object could look like this:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionForm(){const[person,setPerson]=useState({name:'Niki de Saint Phalle',artwork:{title:'Blue Nana',city:'Hamburg',image:'https://i.imgur.com/Sd1AgUOm.jpg',}});functionhandleNameChange(e){setPerson({...person,name:e.target.value});}functionhandleTitleChange(e){setPerson({...person,artwork:{...person.artwork,title:e.target.value}});}functionhandleCityChange(e){setPerson({...person,artwork:{...person.artwork,city:e.target.value}});}functionhandleImageChange(e){setPerson({...person,artwork:{...person.artwork,image:e.target.value}});}return(<><label>Name:<inputvalue={person.name}onChange={handleNameChange}/></label><label>Title:<inputvalue={person.artwork.title}onChange={handleTitleChange}/></label><label>City:<inputvalue={person.artwork.city}onChange={handleCityChange}/></label><label>Image:<inputvalue={person.artwork.image}onChange={handleImageChange}/></label><p><i>{person.artwork.title}</i>{' by '}{person.name}<br/>(located in{person.artwork.city})</p><imgsrc={person.artwork.image}alt={person.artwork.title}/></>);}"
                },
                {
                    "type": "p",
                    "text": "If copying objects in code gets tedious, you can use a library likeImmerto reduce repetitive code:"
                },
                {
                    "type": "code",
                    "code": "{\"dependencies\":{\"immer\":\"1.7.3\",\"react\":\"latest\",\"react-dom\":\"latest\",\"react-scripts\":\"latest\",\"use-immer\":\"0.5.1\"},\"scripts\":{\"start\":\"react-scripts start\",\"build\":\"react-scripts build\",\"test\":\"react-scripts test --env=jsdom\",\"eject\":\"react-scripts eject\"},\"devDependencies\":{}}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadUpdating Objects in Stateto learn how to update objects correctly."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Updating arrays in state"
                },
                {
                    "type": "p",
                    "text": "Arrays are another type of mutable JavaScript objects you can store in state and should treat as read-only. Just like with objects, when you want to update an array stored in state, you need to create a new one (or make a copy of an existing one), and then set state to use the new array:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';constinitialList=[{id:0,title:'Big Bellies',seen:false},{id:1,title:'Lunar Landscape',seen:false},{id:2,title:'Terracotta Army',seen:true},];exportdefaultfunctionBucketList(){const[list,setList]=useState(initialList);functionhandleToggle(artworkId,nextSeen){setList(list.map(artwork=>{if(artwork.id===artworkId){return{...artwork,seen:nextSeen};}else{returnartwork;}}));}return(<><h1>Art Bucket List</h1><h2>My list of art to see:</h2><ItemListartworks={list}onToggle={handleToggle}/></>);}functionItemList({artworks,onToggle}){return(<ul>{artworks.map(artwork=>(<likey={artwork.id}><label><inputtype=\"checkbox\"checked={artwork.seen}onChange={e=>{onToggle(artwork.id,e.target.checked);}}/>{artwork.title}</label></li>))}</ul>);}"
                },
                {
                    "type": "p",
                    "text": "If copying arrays in code gets tedious, you can use a library likeImmerto reduce repetitive code:"
                },
                {
                    "type": "code",
                    "code": "{\"dependencies\":{\"immer\":\"1.7.3\",\"react\":\"latest\",\"react-dom\":\"latest\",\"react-scripts\":\"latest\",\"use-immer\":\"0.5.1\"},\"scripts\":{\"start\":\"react-scripts start\",\"build\":\"react-scripts build\",\"test\":\"react-scripts test --env=jsdom\",\"eject\":\"react-scripts eject\"},\"devDependencies\":{}}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadUpdating Arrays in Stateto learn how to update arrays correctly."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "What’s next?"
                },
                {
                    "type": "p",
                    "text": "Head over toResponding to Eventsto start reading this chapter page by page!"
                },
                {
                    "type": "p",
                    "text": "Or, if you’re already familiar with these topics, why not read aboutManaging State?"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/choosing-the-state-structure",
            "title": "Choosing the State Structure – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Choosing the State Structure"
                },
                {
                    "type": "p",
                    "text": "Structuring state well can make a difference between a component that is pleasant to modify and debug, and one that is a constant source of bugs. Here are some tips you should consider when structuring state."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "When to use a single vs multiple state variables",
                        "What to avoid when organizing state",
                        "How to fix common issues with the state structure"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Principles for structuring state"
                },
                {
                    "type": "p",
                    "text": "When you write a component that holds some state, you’ll have to make choices about how many state variables to use and what the shape of their data should be. While it’s possible to write correct programs even with a suboptimal state structure, there are a few principles that can guide you to make better choices:"
                },
                {
                    "type": "list",
                    "items": [
                        "Group related state.If you always update two or more state variables at the same time, consider merging them into a single state variable.",
                        "Avoid contradictions in state.When the state is structured in a way that several pieces of state may contradict and “disagree” with each other, you leave room for mistakes. Try to avoid this.",
                        "Avoid redundant state.If you can calculate some information from the component’s props or its existing state variables during rendering, you should not put that information into that component’s state.",
                        "Avoid duplication in state.When the same data is duplicated between multiple state variables, or within nested objects, it is difficult to keep them in sync. Reduce duplication when you can.",
                        "Avoid deeply nested state.Deeply hierarchical state is not very convenient to update. When possible, prefer to structure state in a flat way."
                    ]
                },
                {
                    "type": "p",
                    "text": "The goal behind these principles is tomake state easy to update without introducing mistakes. Removing redundant and duplicate data from state helps ensure that all its pieces stay in sync. This is similar to how a database engineer might want to“normalize” the database structureto reduce the chance of bugs. To paraphrase Albert Einstein,“Make your state as simple as it can be—but no simpler.”"
                },
                {
                    "type": "p",
                    "text": "Now let’s see how these principles apply in action."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Group related state"
                },
                {
                    "type": "p",
                    "text": "You might sometimes be unsure between using a single or multiple state variables."
                },
                {
                    "type": "p",
                    "text": "Should you do this?"
                },
                {
                    "type": "code",
                    "code": "const[x,setX]=useState(0);const[y,setY]=useState(0);"
                },
                {
                    "type": "p",
                    "text": "Or this?"
                },
                {
                    "type": "code",
                    "code": "const[position,setPosition]=useState({x:0,y:0});"
                },
                {
                    "type": "p",
                    "text": "Technically, you can use either of these approaches. Butif some two state variables always change together, it might be a good idea to unify them into a single state variable.Then you won’t forget to always keep them in sync, like in this example where moving the cursor updates both coordinates of the red dot:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionMovingDot(){const[position,setPosition]=useState({x:0,y:0});return(<divonPointerMove={e=>{setPosition({x:e.clientX,y:e.clientY});}}style={{position:'relative',width:'100vw',height:'100vh',}}><divstyle={{position:'absolute',backgroundColor:'red',borderRadius:'50%',transform:`translate(${position.x}px,${position.y}px)`,left:-10,top:-10,width:20,height:20,}}/></div>)}"
                },
                {
                    "type": "p",
                    "text": "Another case where you’ll group data into an object or an array is when you don’t know how many pieces of state you’ll need. For example, it’s helpful when you have a form where the user can add custom fields."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "If your state variable is an object, remember thatyou can’t update only one field in itwithout explicitly copying the other fields. For example, you can’t dosetPosition({ x: 100 })in the above example because it would not have theyproperty at all! Instead, if you wanted to setxalone, you would either dosetPosition({ ...position, x: 100 }), or split them into two state variables and dosetX(100)."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Avoid contradictions in state"
                },
                {
                    "type": "p",
                    "text": "Here is a hotel feedback form withisSendingandisSentstate variables:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionFeedbackForm(){const[text,setText]=useState('');const[isSending,setIsSending]=useState(false);const[isSent,setIsSent]=useState(false);asyncfunctionhandleSubmit(e){e.preventDefault();setIsSending(true);awaitsendMessage(text);setIsSending(false);setIsSent(true);}if(isSent){return<h1>Thanks for feedback!</h1>}return(<formonSubmit={handleSubmit}><p>How was your stay at The Prancing Pony?</p><textareadisabled={isSending}value={text}onChange={e=>setText(e.target.value)}/><br/><buttondisabled={isSending}type=\"submit\">Send</button>{isSending&&<p>Sending...</p>}</form>);}// Pretend to send a message.functionsendMessage(text){returnnewPromise(resolve=>{setTimeout(resolve,2000);});}"
                },
                {
                    "type": "p",
                    "text": "While this code works, it leaves the door open for “impossible” states. For example, if you forget to callsetIsSentandsetIsSendingtogether, you may end up in a situation where bothisSendingandisSentaretrueat the same time. The more complex your component is, the harder it is to understand what happened."
                },
                {
                    "type": "p",
                    "text": "SinceisSendingandisSentshould never betrueat the same time, it is better to replace them with onestatusstate variable that may take one ofthreevalid states:'typing'(initial),'sending', and'sent':"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionFeedbackForm(){const[text,setText]=useState('');const[status,setStatus]=useState('typing');asyncfunctionhandleSubmit(e){e.preventDefault();setStatus('sending');awaitsendMessage(text);setStatus('sent');}constisSending=status==='sending';constisSent=status==='sent';if(isSent){return<h1>Thanks for feedback!</h1>}return(<formonSubmit={handleSubmit}><p>How was your stay at The Prancing Pony?</p><textareadisabled={isSending}value={text}onChange={e=>setText(e.target.value)}/><br/><buttondisabled={isSending}type=\"submit\">Send</button>{isSending&&<p>Sending...</p>}</form>);}// Pretend to send a message.functionsendMessage(text){returnnewPromise(resolve=>{setTimeout(resolve,2000);});}"
                },
                {
                    "type": "p",
                    "text": "You can still declare some constants for readability:"
                },
                {
                    "type": "code",
                    "code": "constisSending=status==='sending';constisSent=status==='sent';"
                },
                {
                    "type": "p",
                    "text": "But they’re not state variables, so you don’t need to worry about them getting out of sync with each other."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Avoid redundant state"
                },
                {
                    "type": "p",
                    "text": "If you can calculate some information from the component’s props or its existing state variables during rendering, youshould notput that information into that component’s state."
                },
                {
                    "type": "p",
                    "text": "For example, take this form. It works, but can you find any redundant state in it?"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionForm(){const[firstName,setFirstName]=useState('');const[lastName,setLastName]=useState('');const[fullName,setFullName]=useState('');functionhandleFirstNameChange(e){setFirstName(e.target.value);setFullName(e.target.value+' '+lastName);}functionhandleLastNameChange(e){setLastName(e.target.value);setFullName(firstName+' '+e.target.value);}return(<><h2>Let’s check you in</h2><label>First name:{' '}<inputvalue={firstName}onChange={handleFirstNameChange}/></label><label>Last name:{' '}<inputvalue={lastName}onChange={handleLastNameChange}/></label><p>Your ticket will be issued to:<b>{fullName}</b></p></>);}"
                },
                {
                    "type": "p",
                    "text": "This form has three state variables:firstName,lastName, andfullName. However,fullNameis redundant.You can always calculatefullNamefromfirstNameandlastNameduring render, so remove it from state."
                },
                {
                    "type": "p",
                    "text": "This is how you can do it:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionForm(){const[firstName,setFirstName]=useState('');const[lastName,setLastName]=useState('');constfullName=firstName+' '+lastName;functionhandleFirstNameChange(e){setFirstName(e.target.value);}functionhandleLastNameChange(e){setLastName(e.target.value);}return(<><h2>Let’s check you in</h2><label>First name:{' '}<inputvalue={firstName}onChange={handleFirstNameChange}/></label><label>Last name:{' '}<inputvalue={lastName}onChange={handleLastNameChange}/></label><p>Your ticket will be issued to:<b>{fullName}</b></p></>);}"
                },
                {
                    "type": "p",
                    "text": "Here,fullNameisnota state variable. Instead, it’s calculated during render:"
                },
                {
                    "type": "code",
                    "code": "constfullName=firstName+' '+lastName;"
                },
                {
                    "type": "p",
                    "text": "As a result, the change handlers don’t need to do anything special to update it. When you callsetFirstNameorsetLastName, you trigger a re-render, and then the nextfullNamewill be calculated from the fresh data."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Don’t mirror props in state"
                },
                {
                    "type": "p",
                    "text": "A common example of redundant state is code like this:"
                },
                {
                    "type": "code",
                    "code": "functionMessage({messageColor}){const[color,setColor]=useState(messageColor);"
                },
                {
                    "type": "p",
                    "text": "Here, acolorstate variable is initialized to themessageColorprop. The problem is thatif the parent component passes a different value ofmessageColorlater (for example,'red'instead of'blue'), thecolorstate variablewould not be updated!The state is only initialized during the first render."
                },
                {
                    "type": "p",
                    "text": "This is why “mirroring” some prop in a state variable can lead to confusion. Instead, use themessageColorprop directly in your code. If you want to give it a shorter name, use a constant:"
                },
                {
                    "type": "code",
                    "code": "functionMessage({messageColor}){constcolor=messageColor;"
                },
                {
                    "type": "p",
                    "text": "This way it won’t get out of sync with the prop passed from the parent component."
                },
                {
                    "type": "p",
                    "text": "”Mirroring” props into state only makes sense when youwantto ignore all updates for a specific prop. By convention, start the prop name withinitialordefaultto clarify that its new values are ignored:"
                },
                {
                    "type": "code",
                    "code": "functionMessage({initialColor}){// The `color` state variable holds the *first* value of `initialColor`.// Further changes to the `initialColor` prop are ignored.const[color,setColor]=useState(initialColor);"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Avoid duplication in state"
                },
                {
                    "type": "p",
                    "text": "This menu list component lets you choose a single travel snack out of several:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';constinitialItems=[{title:'pretzels',id:0},{title:'crispy seaweed',id:1},{title:'granola bar',id:2},];exportdefaultfunctionMenu(){const[items,setItems]=useState(initialItems);const[selectedItem,setSelectedItem]=useState(items[0]);return(<><h2>What's your travel snack?</h2><ul>{items.map(item=>(<likey={item.id}>{item.title}{' '}<buttononClick={()=>{setSelectedItem(item);}}>Choose</button></li>))}</ul><p>You picked{selectedItem.title}.</p></>);}"
                },
                {
                    "type": "p",
                    "text": "Currently, it stores the selected item as an object in theselectedItemstate variable. However, this is not great:the contents of theselectedItemis the same object as one of the items inside theitemslist.This means that the information about the item itself is duplicated in two places."
                },
                {
                    "type": "p",
                    "text": "Why is this a problem? Let’s make each item editable:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';constinitialItems=[{title:'pretzels',id:0},{title:'crispy seaweed',id:1},{title:'granola bar',id:2},];exportdefaultfunctionMenu(){const[items,setItems]=useState(initialItems);const[selectedItem,setSelectedItem]=useState(items[0]);functionhandleItemChange(id,e){setItems(items.map(item=>{if(item.id===id){return{...item,title:e.target.value,};}else{returnitem;}}));}return(<><h2>What's your travel snack?</h2><ul>{items.map((item,index)=>(<likey={item.id}><inputvalue={item.title}onChange={e=>{handleItemChange(item.id,e)}}/>{' '}<buttononClick={()=>{setSelectedItem(item);}}>Choose</button></li>))}</ul><p>You picked{selectedItem.title}.</p></>);}"
                },
                {
                    "type": "p",
                    "text": "Notice how if you first click “Choose” on an item andthenedit it,the input updates but the label at the bottom does not reflect the edits.This is because you have duplicated state, and you forgot to updateselectedItem."
                },
                {
                    "type": "p",
                    "text": "Although you could updateselectedItemtoo, an easier fix is to remove duplication. In this example, instead of aselectedItemobject (which creates a duplication with objects insideitems), you hold theselectedIdin state, andthenget theselectedItemby searching theitemsarray for an item with that ID:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';constinitialItems=[{title:'pretzels',id:0},{title:'crispy seaweed',id:1},{title:'granola bar',id:2},];exportdefaultfunctionMenu(){const[items,setItems]=useState(initialItems);const[selectedId,setSelectedId]=useState(0);constselectedItem=items.find(item=>item.id===selectedId);functionhandleItemChange(id,e){setItems(items.map(item=>{if(item.id===id){return{...item,title:e.target.value,};}else{returnitem;}}));}return(<><h2>What's your travel snack?</h2><ul>{items.map((item,index)=>(<likey={item.id}><inputvalue={item.title}onChange={e=>{handleItemChange(item.id,e)}}/>{' '}<buttononClick={()=>{setSelectedId(item.id);}}>Choose</button></li>))}</ul><p>You picked{selectedItem.title}.</p></>);}"
                },
                {
                    "type": "p",
                    "text": "The state used to be duplicated like this:"
                },
                {
                    "type": "list",
                    "items": [
                        "items = [{ id: 0, title: 'pretzels'}, ...]",
                        "selectedItem = {id: 0, title: 'pretzels'}"
                    ]
                },
                {
                    "type": "p",
                    "text": "But after the change it’s like this:"
                },
                {
                    "type": "list",
                    "items": [
                        "items = [{ id: 0, title: 'pretzels'}, ...]",
                        "selectedId = 0"
                    ]
                },
                {
                    "type": "p",
                    "text": "The duplication is gone, and you only keep the essential state!"
                },
                {
                    "type": "p",
                    "text": "Now if you edit theselecteditem, the message below will update immediately. This is becausesetItemstriggers a re-render, anditems.find(...)would find the item with the updated title. You didn’t need to holdthe selected itemin state, because only theselected IDis essential. The rest could be calculated during render."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Avoid deeply nested state"
                },
                {
                    "type": "p",
                    "text": "Imagine a travel plan consisting of planets, continents, and countries. You might be tempted to structure its state using nested objects and arrays, like in this example:"
                },
                {
                    "type": "code",
                    "code": "exportconstinitialTravelPlan={id:0,title:'(Root)',childPlaces:[{id:1,title:'Earth',childPlaces:[{id:2,title:'Africa',childPlaces:[{id:3,title:'Botswana',childPlaces:[]},{id:4,title:'Egypt',childPlaces:[]},{id:5,title:'Kenya',childPlaces:[]},{id:6,title:'Madagascar',childPlaces:[]},{id:7,title:'Morocco',childPlaces:[]},{id:8,title:'Nigeria',childPlaces:[]},{id:9,title:'South Africa',childPlaces:[]}]},{id:10,title:'Americas',childPlaces:[{id:11,title:'Argentina',childPlaces:[]},{id:12,title:'Brazil',childPlaces:[]},{id:13,title:'Barbados',childPlaces:[]},{id:14,title:'Canada',childPlaces:[]},{id:15,title:'Jamaica',childPlaces:[]},{id:16,title:'Mexico',childPlaces:[]},{id:17,title:'Trinidad and Tobago',childPlaces:[]},{id:18,title:'Venezuela',childPlaces:[]}]},{id:19,title:'Asia',childPlaces:[{id:20,title:'China',childPlaces:[]},{id:21,title:'India',childPlaces:[]},{id:22,title:'Singapore',childPlaces:[]},{id:23,title:'South Korea',childPlaces:[]},{id:24,title:'Thailand',childPlaces:[]},{id:25,title:'Vietnam',childPlaces:[]}]},{id:26,title:'Europe',childPlaces:[{id:27,title:'Croatia',childPlaces:[],},{id:28,title:'France',childPlaces:[],},{id:29,title:'Germany',childPlaces:[],},{id:30,title:'Italy',childPlaces:[],},{id:31,title:'Portugal',childPlaces:[],},{id:32,title:'Spain',childPlaces:[],},{id:33,title:'Turkey',childPlaces:[],}]},{id:34,title:'Oceania',childPlaces:[{id:35,title:'Australia',childPlaces:[],},{id:36,title:'Bora Bora (French Polynesia)',childPlaces:[],},{id:37,title:'Easter Island (Chile)',childPlaces:[],},{id:38,title:'Fiji',childPlaces:[],},{id:39,title:'Hawaii (the USA)',childPlaces:[],},{id:40,title:'New Zealand',childPlaces:[],},{id:41,title:'Vanuatu',childPlaces:[],}]}]},{id:42,title:'Moon',childPlaces:[{id:43,title:'Rheita',childPlaces:[]},{id:44,title:'Piccolomini',childPlaces:[]},{id:45,title:'Tycho',childPlaces:[]}]},{id:46,title:'Mars',childPlaces:[{id:47,title:'Corn Town',childPlaces:[]},{id:48,title:'Green Hill',childPlaces:[]}]}]};"
                },
                {
                    "type": "p",
                    "text": "Now let’s say you want to add a button to delete a place you’ve already visited. How would you go about it?Updating nested stateinvolves making copies of objects all the way up from the part that changed. Deleting a deeply nested place would involve copying its entire parent place chain. Such code can be very verbose."
                },
                {
                    "type": "p",
                    "text": "If the state is too nested to update easily, consider making it “flat”.Here is one way you can restructure this data. Instead of a tree-like structure where eachplacehas an array ofits child places, you can have each place hold an array ofits child place IDs. Then store a mapping from each place ID to the corresponding place."
                },
                {
                    "type": "p",
                    "text": "This data restructuring might remind you of seeing a database table:"
                },
                {
                    "type": "code",
                    "code": "exportconstinitialTravelPlan={0:{id:0,title:'(Root)',childIds:[1,42,46],},1:{id:1,title:'Earth',childIds:[2,10,19,26,34]},2:{id:2,title:'Africa',childIds:[3,4,5,6,7,8,9]},3:{id:3,title:'Botswana',childIds:[]},4:{id:4,title:'Egypt',childIds:[]},5:{id:5,title:'Kenya',childIds:[]},6:{id:6,title:'Madagascar',childIds:[]},7:{id:7,title:'Morocco',childIds:[]},8:{id:8,title:'Nigeria',childIds:[]},9:{id:9,title:'South Africa',childIds:[]},10:{id:10,title:'Americas',childIds:[11,12,13,14,15,16,17,18],},11:{id:11,title:'Argentina',childIds:[]},12:{id:12,title:'Brazil',childIds:[]},13:{id:13,title:'Barbados',childIds:[]},14:{id:14,title:'Canada',childIds:[]},15:{id:15,title:'Jamaica',childIds:[]},16:{id:16,title:'Mexico',childIds:[]},17:{id:17,title:'Trinidad and Tobago',childIds:[]},18:{id:18,title:'Venezuela',childIds:[]},19:{id:19,title:'Asia',childIds:[20,21,22,23,24,25],},20:{id:20,title:'China',childIds:[]},21:{id:21,title:'India',childIds:[]},22:{id:22,title:'Singapore',childIds:[]},23:{id:23,title:'South Korea',childIds:[]},24:{id:24,title:'Thailand',childIds:[]},25:{id:25,title:'Vietnam',childIds:[]},26:{id:26,title:'Europe',childIds:[27,28,29,30,31,32,33],},27:{id:27,title:'Croatia',childIds:[]},28:{id:28,title:'France',childIds:[]},29:{id:29,title:'Germany',childIds:[]},30:{id:30,title:'Italy',childIds:[]},31:{id:31,title:'Portugal',childIds:[]},32:{id:32,title:'Spain',childIds:[]},33:{id:33,title:'Turkey',childIds:[]},34:{id:34,title:'Oceania',childIds:[35,36,37,38,39,40,41],},35:{id:35,title:'Australia',childIds:[]},36:{id:36,title:'Bora Bora (French Polynesia)',childIds:[]},37:{id:37,title:'Easter Island (Chile)',childIds:[]},38:{id:38,title:'Fiji',childIds:[]},39:{id:40,title:'Hawaii (the USA)',childIds:[]},40:{id:40,title:'New Zealand',childIds:[]},41:{id:41,title:'Vanuatu',childIds:[]},42:{id:42,title:'Moon',childIds:[43,44,45]},43:{id:43,title:'Rheita',childIds:[]},44:{id:44,title:'Piccolomini',childIds:[]},45:{id:45,title:'Tycho',childIds:[]},46:{id:46,title:'Mars',childIds:[47,48]},47:{id:47,title:'Corn Town',childIds:[]},48:{id:48,title:'Green Hill',childIds:[]}};"
                },
                {
                    "type": "p",
                    "text": "Now that the state is “flat” (also known as “normalized”), updating nested items becomes easier."
                },
                {
                    "type": "p",
                    "text": "In order to remove a place now, you only need to update two levels of state:"
                },
                {
                    "type": "list",
                    "items": [
                        "The updated version of itsparentplace should exclude the removed ID from itschildIdsarray.",
                        "The updated version of the root “table” object should include the updated version of the parent place."
                    ]
                },
                {
                    "type": "p",
                    "text": "Here is an example of how you could go about it:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';import{initialTravelPlan}from'./places.js';exportdefaultfunctionTravelPlan(){const[plan,setPlan]=useState(initialTravelPlan);functionhandleComplete(parentId,childId){constparent=plan[parentId];// Create a new version of the parent place// that doesn't include this child ID.constnextParent={...parent,childIds:parent.childIds.filter(id=>id!==childId)};// Update the root state object...setPlan({...plan,// ...so that it has the updated parent.[parentId]:nextParent});}constroot=plan[0];constplanetIds=root.childIds;return(<><h2>Places to visit</h2><ol>{planetIds.map(id=>(<PlaceTreekey={id}id={id}parentId={0}placesById={plan}onComplete={handleComplete}/>))}</ol></>);}functionPlaceTree({id,parentId,placesById,onComplete}){constplace=placesById[id];constchildIds=place.childIds;return(<li>{place.title}<buttononClick={()=>{onComplete(parentId,id);}}>Complete</button>{childIds.length>0&&<ol>{childIds.map(childId=>(<PlaceTreekey={childId}id={childId}parentId={id}placesById={placesById}onComplete={onComplete}/>))}</ol>}</li>);}"
                },
                {
                    "type": "p",
                    "text": "You can nest state as much as you like, but making it “flat” can solve numerous problems. It makes state easier to update, and it helps ensure you don’t have duplication in different parts of a nested object."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Improving memory usage"
                },
                {
                    "type": "p",
                    "text": "Ideally, you would also remove the deleted items (and their children!) from the “table” object to improve memory usage. This version does that. It alsouses Immerto make the update logic more concise."
                },
                {
                    "type": "code",
                    "code": "{\"dependencies\":{\"immer\":\"1.7.3\",\"react\":\"latest\",\"react-dom\":\"latest\",\"react-scripts\":\"latest\",\"use-immer\":\"0.5.1\"},\"scripts\":{\"start\":\"react-scripts start\",\"build\":\"react-scripts build\",\"test\":\"react-scripts test --env=jsdom\",\"eject\":\"react-scripts eject\"},\"devDependencies\":{}}"
                },
                {
                    "type": "p",
                    "text": "Sometimes, you can also reduce state nesting by moving some of the nested state into the child components. This works well for ephemeral UI state that doesn’t need to be stored, like whether an item is hovered."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "If two state variables always update together, consider merging them into one.",
                        "Choose your state variables carefully to avoid creating “impossible” states.",
                        "Structure your state in a way that reduces the chances that you’ll make a mistake updating it.",
                        "Avoid redundant and duplicate state so that you don’t need to keep it in sync.",
                        "Don’t put propsintostate unless you specifically want to prevent updates.",
                        "For UI patterns like selection, keep ID or index in state instead of the object itself.",
                        "If updating deeply nested state is complicated, try flattening it."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of4:Fix a component that’s not updating"
                },
                {
                    "type": "p",
                    "text": "ThisClockcomponent receives two props:colorandtime. When you select a different color in the select box, theClockcomponent receives a differentcolorprop from its parent component. However, for some reason, the displayed color doesn’t update. Why? Fix the problem."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionClock(props){const[color,setColor]=useState(props.color);return(<h1style={{color:color}}>{props.time}</h1>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/conditional-rendering",
            "title": "Conditional Rendering – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Conditional Rendering"
                },
                {
                    "type": "p",
                    "text": "Your components will often need to display different things depending on different conditions. In React, you can conditionally render JSX using JavaScript syntax likeifstatements,&&, and? :operators."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "How to return different JSX depending on a condition",
                        "How to conditionally include or exclude a piece of JSX",
                        "Common conditional syntax shortcuts you’ll encounter in React codebases"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Conditionally returning JSX"
                },
                {
                    "type": "p",
                    "text": "Let’s say you have aPackingListcomponent rendering severalItems, which can be marked as packed or not:"
                },
                {
                    "type": "code",
                    "code": "functionItem({name,isPacked}){return<liclassName=\"item\">{name}</li>;}exportdefaultfunctionPackingList(){return(<section><h1>Sally Ride's Packing List</h1><ul><ItemisPacked={true}name=\"Space suit\"/><ItemisPacked={true}name=\"Helmet with a golden leaf\"/><ItemisPacked={false}name=\"Photo of Tam\"/></ul></section>);}"
                },
                {
                    "type": "p",
                    "text": "Notice that some of theItemcomponents have theirisPackedprop set totrueinstead offalse. You want to add a checkmark (✅) to packed items ifisPacked={true}."
                },
                {
                    "type": "p",
                    "text": "You can write this as anif/elsestatementlike so:"
                },
                {
                    "type": "code",
                    "code": "if(isPacked){return<liclassName=\"item\">{name}✅</li>;}return<liclassName=\"item\">{name}</li>;"
                },
                {
                    "type": "p",
                    "text": "If theisPackedprop istrue, this codereturns a different JSX tree.With this change, some of the items get a checkmark at the end:"
                },
                {
                    "type": "code",
                    "code": "functionItem({name,isPacked}){if(isPacked){return<liclassName=\"item\">{name}✅</li>;}return<liclassName=\"item\">{name}</li>;}exportdefaultfunctionPackingList(){return(<section><h1>Sally Ride's Packing List</h1><ul><ItemisPacked={true}name=\"Space suit\"/><ItemisPacked={true}name=\"Helmet with a golden leaf\"/><ItemisPacked={false}name=\"Photo of Tam\"/></ul></section>);}"
                },
                {
                    "type": "p",
                    "text": "Try editing what gets returned in either case, and see how the result changes!"
                },
                {
                    "type": "p",
                    "text": "Notice how you’re creating branching logic with JavaScript’sifandreturnstatements. In React, control flow (like conditions) is handled by JavaScript."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Conditionally returning nothing withnull"
                },
                {
                    "type": "p",
                    "text": "In some situations, you won’t want to render anything at all. For example, say you don’t want to show packed items at all. A component must return something. In this case, you can returnnull:"
                },
                {
                    "type": "code",
                    "code": "if(isPacked){returnnull;}return<liclassName=\"item\">{name}</li>;"
                },
                {
                    "type": "p",
                    "text": "IfisPackedis true, the component will return nothing,null. Otherwise, it will return JSX to render."
                },
                {
                    "type": "code",
                    "code": "functionItem({name,isPacked}){if(isPacked){returnnull;}return<liclassName=\"item\">{name}</li>;}exportdefaultfunctionPackingList(){return(<section><h1>Sally Ride's Packing List</h1><ul><ItemisPacked={true}name=\"Space suit\"/><ItemisPacked={true}name=\"Helmet with a golden leaf\"/><ItemisPacked={false}name=\"Photo of Tam\"/></ul></section>);}"
                },
                {
                    "type": "p",
                    "text": "In practice, returningnullfrom a component isn’t common because it might surprise a developer trying to render it. More often, you would conditionally include or exclude the component in the parent component’s JSX. Here’s how to do that!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Conditionally including JSX"
                },
                {
                    "type": "p",
                    "text": "In the previous example, you controlled which (if any!) JSX tree would be returned by the component. You may already have noticed some duplication in the render output:"
                },
                {
                    "type": "code",
                    "code": "<liclassName=\"item\">{name}✅</li>"
                },
                {
                    "type": "p",
                    "text": "is very similar to"
                },
                {
                    "type": "code",
                    "code": "<liclassName=\"item\">{name}</li>"
                },
                {
                    "type": "p",
                    "text": "Both of the conditional branches return<li className=\"item\">...</li>:"
                },
                {
                    "type": "code",
                    "code": "if(isPacked){return<liclassName=\"item\">{name}✅</li>;}return<liclassName=\"item\">{name}</li>;"
                },
                {
                    "type": "p",
                    "text": "While this duplication isn’t harmful, it could make your code harder to maintain. What if you want to change theclassName? You’d have to do it in two places in your code! In such a situation, you could conditionally include a little JSX to make your code moreDRY."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Conditional (ternary) operator (? :)"
                },
                {
                    "type": "p",
                    "text": "JavaScript has a compact syntax for writing a conditional expression — theconditional operatoror “ternary operator”."
                },
                {
                    "type": "p",
                    "text": "Instead of this:"
                },
                {
                    "type": "code",
                    "code": "if(isPacked){return<liclassName=\"item\">{name}✅</li>;}return<liclassName=\"item\">{name}</li>;"
                },
                {
                    "type": "p",
                    "text": "You can write this:"
                },
                {
                    "type": "code",
                    "code": "return(<liclassName=\"item\">{isPacked?name+' ✅':name}</li>);"
                },
                {
                    "type": "p",
                    "text": "You can read it as“ifisPackedis true, then (?) rendername + ' ✅', otherwise (:) rendername”."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Are these two examples fully equivalent?"
                },
                {
                    "type": "p",
                    "text": "If you’re coming from an object-oriented programming background, you might assume that the two examples above are subtly different because one of them may create two different “instances” of<li>. But JSX elements aren’t “instances” because they don’t hold any internal state and aren’t real DOM nodes. They’re lightweight descriptions, like blueprints. So these two examples, in fact,arecompletely equivalent.Preserving and Resetting Stategoes into detail about how this works."
                },
                {
                    "type": "p",
                    "text": "Now let’s say you want to wrap the completed item’s text into another HTML tag, like<del>to strike it out. You can add even more newlines and parentheses so that it’s easier to nest more JSX in each of the cases:"
                },
                {
                    "type": "code",
                    "code": "functionItem({name,isPacked}){return(<liclassName=\"item\">{isPacked?(<del>{name+' ✅'}</del>):(name)}</li>);}exportdefaultfunctionPackingList(){return(<section><h1>Sally Ride's Packing List</h1><ul><ItemisPacked={true}name=\"Space suit\"/><ItemisPacked={true}name=\"Helmet with a golden leaf\"/><ItemisPacked={false}name=\"Photo of Tam\"/></ul></section>);}"
                },
                {
                    "type": "p",
                    "text": "This style works well for simple conditions, but use it in moderation. If your components get messy with too much nested conditional markup, consider extracting child components to clean things up. In React, markup is a part of your code, so you can use tools like variables and functions to tidy up complex expressions."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Logical AND operator (&&)"
                },
                {
                    "type": "p",
                    "text": "Another common shortcut you’ll encounter is theJavaScript logical AND (&&) operator.Inside React components, it often comes up when you want to render some JSX when the condition is true,or render nothing otherwise.With&&, you could conditionally render the checkmark only ifisPackedistrue:"
                },
                {
                    "type": "code",
                    "code": "return(<liclassName=\"item\">{name}{isPacked&&'✅'}</li>);"
                },
                {
                    "type": "p",
                    "text": "You can read this as“ifisPacked, then (&&) render the checkmark, otherwise, render nothing”."
                },
                {
                    "type": "p",
                    "text": "Here it is in action:"
                },
                {
                    "type": "code",
                    "code": "functionItem({name,isPacked}){return(<liclassName=\"item\">{name}{isPacked&&'✅'}</li>);}exportdefaultfunctionPackingList(){return(<section><h1>Sally Ride's Packing List</h1><ul><ItemisPacked={true}name=\"Space suit\"/><ItemisPacked={true}name=\"Helmet with a golden leaf\"/><ItemisPacked={false}name=\"Photo of Tam\"/></ul></section>);}"
                },
                {
                    "type": "p",
                    "text": "AJavaScript && expressionreturns the value of its right side (in our case, the checkmark) if the left side (our condition) istrue. But if the condition isfalse, the whole expression becomesfalse. React considersfalseas a “hole” in the JSX tree, just likenullorundefined, and doesn’t render anything in its place."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Don’t put numbers on the left side of&&."
                },
                {
                    "type": "p",
                    "text": "To test the condition, JavaScript converts the left side to a boolean automatically. However, if the left side is0, then the whole expression gets that value (0), and React will happily render0rather than nothing."
                },
                {
                    "type": "p",
                    "text": "For example, a common mistake is to write code likemessageCount && <p>New messages</p>. It’s easy to assume that it renders nothing whenmessageCountis0, but it really renders the0itself!"
                },
                {
                    "type": "p",
                    "text": "To fix it, make the left side a boolean:messageCount > 0 && <p>New messages</p>."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Conditionally assigning JSX to a variable"
                },
                {
                    "type": "p",
                    "text": "When the shortcuts get in the way of writing plain code, try using anifstatement and a variable. You can reassign variables defined withlet, so start by providing the default content you want to display, the name:"
                },
                {
                    "type": "code",
                    "code": "letitemContent=name;"
                },
                {
                    "type": "p",
                    "text": "Use anifstatement to reassign a JSX expression toitemContentifisPackedistrue:"
                },
                {
                    "type": "code",
                    "code": "if(isPacked){itemContent=name+\" ✅\";}"
                },
                {
                    "type": "p",
                    "text": "Curly braces open the “window into JavaScript”.Embed the variable with curly braces in the returned JSX tree, nesting the previously calculated expression inside of JSX:"
                },
                {
                    "type": "code",
                    "code": "<liclassName=\"item\">{itemContent}</li>"
                },
                {
                    "type": "p",
                    "text": "This style is the most verbose, but it’s also the most flexible. Here it is in action:"
                },
                {
                    "type": "code",
                    "code": "functionItem({name,isPacked}){letitemContent=name;if(isPacked){itemContent=name+\" ✅\";}return(<liclassName=\"item\">{itemContent}</li>);}exportdefaultfunctionPackingList(){return(<section><h1>Sally Ride's Packing List</h1><ul><ItemisPacked={true}name=\"Space suit\"/><ItemisPacked={true}name=\"Helmet with a golden leaf\"/><ItemisPacked={false}name=\"Photo of Tam\"/></ul></section>);}"
                },
                {
                    "type": "p",
                    "text": "Like before, this works not only for text, but for arbitrary JSX too:"
                },
                {
                    "type": "code",
                    "code": "functionItem({name,isPacked}){letitemContent=name;if(isPacked){itemContent=(<del>{name+\" ✅\"}</del>);}return(<liclassName=\"item\">{itemContent}</li>);}exportdefaultfunctionPackingList(){return(<section><h1>Sally Ride's Packing List</h1><ul><ItemisPacked={true}name=\"Space suit\"/><ItemisPacked={true}name=\"Helmet with a golden leaf\"/><ItemisPacked={false}name=\"Photo of Tam\"/></ul></section>);}"
                },
                {
                    "type": "p",
                    "text": "If you’re not familiar with JavaScript, this variety of styles might seem overwhelming at first. However, learning them will help you read and write any JavaScript code — and not just React components! Pick the one you prefer for a start, and then consult this reference again if you forget how the other ones work."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "In React, you control branching logic with JavaScript.",
                        "You can return a JSX expression conditionally with anifstatement.",
                        "You can conditionally save some JSX to a variable and then include it inside other JSX by using the curly braces.",
                        "In JSX,{cond ? <A /> : <B />}means“ifcond, render<A />, otherwise<B />”.",
                        "In JSX,{cond && <A />}means“ifcond, render<A />, otherwise nothing”.",
                        "The shortcuts are common, but you don’t have to use them if you prefer plainif."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of3:Show an icon for incomplete items with? :"
                },
                {
                    "type": "p",
                    "text": "Use the conditional operator (cond ? a : b) to render a ❌ ifisPackedisn’ttrue."
                },
                {
                    "type": "code",
                    "code": "functionItem({name,isPacked}){return(<liclassName=\"item\">{name}{isPacked&&'✅'}</li>);}exportdefaultfunctionPackingList(){return(<section><h1>Sally Ride's Packing List</h1><ul><ItemisPacked={true}name=\"Space suit\"/><ItemisPacked={true}name=\"Helmet with a golden leaf\"/><ItemisPacked={false}name=\"Photo of Tam\"/></ul></section>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/describing-the-ui",
            "title": "Describing the UI – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Describing the UI"
                },
                {
                    "type": "p",
                    "text": "React is a JavaScript library for rendering user interfaces (UI). UI is built from small units like buttons, text, and images. React lets you combine them into reusable, nestablecomponents.From web sites to phone apps, everything on the screen can be broken down into components. In this chapter, you’ll learn to create, customize, and conditionally display React components."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "In this chapter"
                },
                {
                    "type": "list",
                    "items": [
                        "How to write your first React component",
                        "When and how to create multi-component files",
                        "How to add markup to JavaScript with JSX",
                        "How to use curly braces with JSX to access JavaScript functionality from your components",
                        "How to configure components with props",
                        "How to conditionally render components",
                        "How to render multiple components at a time",
                        "How to avoid confusing bugs by keeping components pure",
                        "Why understanding your UI as trees is useful"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Your first component"
                },
                {
                    "type": "p",
                    "text": "React applications are built from isolated pieces of UI calledcomponents. A React component is a JavaScript function that you can sprinkle with markup. Components can be as small as a button, or as large as an entire page. Here is aGallerycomponent rendering threeProfilecomponents:"
                },
                {
                    "type": "code",
                    "code": "functionProfile(){return(<imgsrc=\"https://i.imgur.com/MK3eW3As.jpg\"alt=\"Katherine Johnson\"/>);}exportdefaultfunctionGallery(){return(<section><h1>Amazing scientists</h1><Profile/><Profile/><Profile/></section>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadYour First Componentto learn how to declare and use React components."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Importing and exporting components"
                },
                {
                    "type": "p",
                    "text": "You can declare many components in one file, but large files can get difficult to navigate. To solve this, you canexporta component into its own file, and thenimportthat component from another file:"
                },
                {
                    "type": "code",
                    "code": "importProfilefrom'./Profile.js';exportdefaultfunctionGallery(){return(<section><h1>Amazing scientists</h1><Profile/><Profile/><Profile/></section>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadImporting and Exporting Componentsto learn how to split components into their own files."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Writing markup with JSX"
                },
                {
                    "type": "p",
                    "text": "Each React component is a JavaScript function that may contain some markup that React renders into the browser. React components use a syntax extension called JSX to represent that markup. JSX looks a lot like HTML, but it is a bit stricter and can display dynamic information."
                },
                {
                    "type": "p",
                    "text": "If we paste existing HTML markup into a React component, it won’t always work:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionTodoList(){return(// This doesn't quite work!<h1>Hedy Lamarr's Todos</h1><imgsrc=\"https://i.imgur.com/yXOvdOSs.jpg\"alt=\"Hedy Lamarr\"class=\"photo\"><ul><li>Invent new traffic lights<li>Rehearse a movie scene<li>Improve spectrum technology</ul>"
                },
                {
                    "type": "p",
                    "text": "If you have existing HTML like this, you can fix it using aconverter:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionTodoList(){return(<><h1>Hedy Lamarr's Todos</h1><imgsrc=\"https://i.imgur.com/yXOvdOSs.jpg\"alt=\"Hedy Lamarr\"className=\"photo\"/><ul><li>Invent new traffic lights</li><li>Rehearse a movie scene</li><li>Improve spectrum technology</li></ul></>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadWriting Markup with JSXto learn how to write valid JSX."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "JavaScript in JSX with curly braces"
                },
                {
                    "type": "p",
                    "text": "JSX lets you write HTML-like markup inside a JavaScript file, keeping rendering logic and content in the same place. Sometimes you will want to add a little JavaScript logic or reference a dynamic property inside that markup. In this situation, you can use curly braces in your JSX to “open a window” to JavaScript:"
                },
                {
                    "type": "code",
                    "code": "constperson={name:'Gregorio Y. Zara',theme:{backgroundColor:'black',color:'pink'}};exportdefaultfunctionTodoList(){return(<divstyle={person.theme}><h1>{person.name}'s Todos</h1><imgclassName=\"avatar\"src=\"https://i.imgur.com/7vQD0fPs.jpg\"alt=\"Gregorio Y. Zara\"/><ul><li>Improve the videophone</li><li>Prepare aeronautics lectures</li><li>Work on the alcohol-fuelled engine</li></ul></div>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadJavaScript in JSX with Curly Bracesto learn how to access JavaScript data from JSX."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Passing props to a component"
                },
                {
                    "type": "p",
                    "text": "React components usepropsto communicate with each other. Every parent component can pass some information to its child components by giving them props. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, functions, and even JSX!"
                },
                {
                    "type": "code",
                    "code": "import{getImageUrl}from'./utils.js'exportdefaultfunctionProfile(){return(<Card><Avatarsize={100}person={{name:'Katsuko Saruhashi',imageId:'YfeOqp2'}}/></Card>);}functionAvatar({person,size}){return(<imgclassName=\"avatar\"src={getImageUrl(person)}alt={person.name}width={size}height={size}/>);}functionCard({children}){return(<divclassName=\"card\">{children}</div>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadPassing Props to a Componentto learn how to pass and read props."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Conditional rendering"
                },
                {
                    "type": "p",
                    "text": "Your components will often need to display different things depending on different conditions. In React, you can conditionally render JSX using JavaScript syntax likeifstatements,&&, and? :operators."
                },
                {
                    "type": "p",
                    "text": "In this example, the JavaScript&&operator is used to conditionally render a checkmark:"
                },
                {
                    "type": "code",
                    "code": "functionItem({name,isPacked}){return(<liclassName=\"item\">{name}{isPacked&&'✅'}</li>);}exportdefaultfunctionPackingList(){return(<section><h1>Sally Ride's Packing List</h1><ul><ItemisPacked={true}name=\"Space suit\"/><ItemisPacked={true}name=\"Helmet with a golden leaf\"/><ItemisPacked={false}name=\"Photo of Tam\"/></ul></section>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadConditional Renderingto learn the different ways to render content conditionally."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Rendering lists"
                },
                {
                    "type": "p",
                    "text": "You will often want to display multiple similar components from a collection of data. You can use JavaScript’sfilter()andmap()with React to filter and transform your array of data into an array of components."
                },
                {
                    "type": "p",
                    "text": "For each array item, you will need to specify akey. Usually, you will want to use an ID from the database as akey. Keys let React keep track of each item’s place in the list even if the list changes."
                },
                {
                    "type": "code",
                    "code": "import{people}from'./data.js';import{getImageUrl}from'./utils.js';exportdefaultfunctionList(){constlistItems=people.map(person=><likey={person.id}><imgsrc={getImageUrl(person)}alt={person.name}/><p><b>{person.name}:</b>{' '+person.profession+' '}known for{person.accomplishment}</p></li>);return(<article><h1>Scientists</h1><ul>{listItems}</ul></article>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadRendering Liststo learn how to render a list of components, and how to choose a key."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Keeping components pure"
                },
                {
                    "type": "p",
                    "text": "Some JavaScript functions arepure.A pure function:"
                },
                {
                    "type": "list",
                    "items": [
                        "Minds its own business.It does not change any objects or variables that existed before it was called.",
                        "Same inputs, same output.Given the same inputs, a pure function should always return the same result."
                    ]
                },
                {
                    "type": "p",
                    "text": "By strictly only writing your components as pure functions, you can avoid an entire class of baffling bugs and unpredictable behavior as your codebase grows. Here is an example of an impure component:"
                },
                {
                    "type": "code",
                    "code": "letguest=0;functionCup(){// Bad: changing a preexisting variable!guest=guest+1;return<h2>Tea cup for guest #{guest}</h2>;}exportdefaultfunctionTeaSet(){return(<><Cup/><Cup/><Cup/></>);}"
                },
                {
                    "type": "p",
                    "text": "You can make this component pure by passing a prop instead of modifying a preexisting variable:"
                },
                {
                    "type": "code",
                    "code": "functionCup({guest}){return<h2>Tea cup for guest #{guest}</h2>;}exportdefaultfunctionTeaSet(){return(<><Cupguest={1}/><Cupguest={2}/><Cupguest={3}/></>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadKeeping Components Pureto learn how to write components as pure, predictable functions."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Your UI as a tree"
                },
                {
                    "type": "p",
                    "text": "React uses trees to model the relationships between components and modules."
                },
                {
                    "type": "p",
                    "text": "A React render tree is a representation of the parent and child relationship between components."
                },
                {
                    "type": "p",
                    "text": "An example React render tree."
                },
                {
                    "type": "p",
                    "text": "Components near the top of the tree, near the root component, are considered top-level components. Components with no child components are leaf components. This categorization of components is useful for understanding data flow and rendering performance."
                },
                {
                    "type": "p",
                    "text": "Modelling the relationship between JavaScript modules is another useful way to understand your app. We refer to it as a module dependency tree."
                },
                {
                    "type": "p",
                    "text": "An example module dependency tree."
                },
                {
                    "type": "p",
                    "text": "A dependency tree is often used by build tools to bundle all the relevant JavaScript code for the client to download and render. A large bundle size regresses user experience for React apps. Understanding the module dependency tree is helpful to debug such issues."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadYour UI as a Treeto learn how to create a render and module dependency trees for a React app and how they’re useful mental models for improving user experience and performance."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "What’s next?"
                },
                {
                    "type": "p",
                    "text": "Head over toYour First Componentto start reading this chapter page by page!"
                },
                {
                    "type": "p",
                    "text": "Or, if you’re already familiar with these topics, why not read aboutAdding Interactivity?"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/editor-setup",
            "title": "Editor Setup – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Editor Setup"
                },
                {
                    "type": "p",
                    "text": "A properly configured editor can make code clearer to read and faster to write. It can even help you catch bugs as you write them! If this is your first time setting up an editor or you’re looking to tune up your current editor, we have a few recommendations."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "What the most popular editors are",
                        "How to format your code automatically"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Your editor"
                },
                {
                    "type": "p",
                    "text": "VS Codeis one of the most popular editors in use today. It has a large marketplace of extensions and integrates well with popular services like GitHub. Most of the features listed below can be added to VS Code as extensions as well, making it highly configurable!"
                },
                {
                    "type": "p",
                    "text": "Other popular text editors used in the React community include:"
                },
                {
                    "type": "list",
                    "items": [
                        "WebStormis an integrated development environment designed specifically for JavaScript.",
                        "Sublime Texthas support for JSX and TypeScript,syntax highlightingand autocomplete built in.",
                        "Vimis a highly configurable text editor built to make creating and changing any kind of text very efficient. It is included as “vi” with most UNIX systems and with Apple OS X."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recommended text editor features"
                },
                {
                    "type": "p",
                    "text": "Some editors come with these features built in, but others might require adding an extension. Check to see what support your editor of choice provides to be sure!"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Linting"
                },
                {
                    "type": "p",
                    "text": "Code linters find problems in your code as you write, helping you fix them early.ESLintis a popular, open source linter for JavaScript."
                },
                {
                    "type": "list",
                    "items": [
                        "Install ESLint with the recommended configuration for React(be sure you haveNode installed!)",
                        "Integrate ESLint in VSCode with the official extension"
                    ]
                },
                {
                    "type": "p",
                    "text": "Make sure that you’ve enabled all theeslint-plugin-react-hooksrules for your project.They are essential and catch the most severe bugs early. The recommendedeslint-config-react-apppreset already includes them."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Formatting"
                },
                {
                    "type": "p",
                    "text": "The last thing you want to do when sharing your code with another contributor is get into a discussion abouttabs vs spaces! Fortunately,Prettierwill clean up your code by reformatting it to conform to preset, configurable rules. Run Prettier, and all your tabs will be converted to spaces—and your indentation, quotes, etc will also all be changed to conform to the configuration. In the ideal setup, Prettier will run when you save your file, quickly making these edits for you."
                },
                {
                    "type": "p",
                    "text": "You can install thePrettier extension in VSCodeby following these steps:"
                },
                {
                    "type": "list",
                    "items": [
                        "Launch VS Code",
                        "Use Quick Open (press Ctrl/Cmd+P)",
                        "Paste inext install esbenp.prettier-vscode",
                        "Press Enter"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Formatting on save"
                },
                {
                    "type": "p",
                    "text": "Ideally, you should format your code on every save. VS Code has settings for this!"
                },
                {
                    "type": "list",
                    "items": [
                        "In VS Code, pressCTRL/CMD + SHIFT + P.",
                        "Type “settings”",
                        "Hit Enter",
                        "In the search bar, type “format on save”",
                        "Be sure the “format on save” option is ticked!"
                    ]
                },
                {
                    "type": "p",
                    "text": "If your ESLint preset has formatting rules, they may conflict with Prettier. We recommend disabling all formatting rules in your ESLint preset usingeslint-config-prettierso that ESLint isonlyused for catching logical mistakes. If you want to enforce that files are formatted before a pull request is merged, useprettier --checkfor your continuous integration."
                }
            ]
        },
        {
            "url": "https://react.dev/learn/escape-hatches",
            "title": "Escape Hatches – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Escape Hatches"
                },
                {
                    "type": "p",
                    "text": "Some of your components may need to control and synchronize with systems outside of React. For example, you might need to focus an input using the browser API, play and pause a video player implemented without React, or connect and listen to messages from a remote server. In this chapter, you’ll learn the escape hatches that let you “step outside” React and connect to external systems. Most of your application logic and data flow should not rely on these features."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "In this chapter"
                },
                {
                    "type": "list",
                    "items": [
                        "How to “remember” information without re-rendering",
                        "How to access DOM elements managed by React",
                        "How to synchronize components with external systems",
                        "How to remove unnecessary Effects from your components",
                        "How an Effect’s lifecycle is different from a component’s",
                        "How to prevent some values from re-triggering Effects",
                        "How to make your Effect re-run less often",
                        "How to share logic between components"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Referencing values with refs"
                },
                {
                    "type": "p",
                    "text": "When you want a component to “remember” some information, but you don’t want that information totrigger new renders, you can use aref:"
                },
                {
                    "type": "code",
                    "code": "constref=useRef(0);"
                },
                {
                    "type": "p",
                    "text": "Like state, refs are retained by React between re-renders. However, setting state re-renders a component. Changing a ref does not! You can access the current value of that ref through theref.currentproperty."
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';exportdefaultfunctionCounter(){letref=useRef(0);functionhandleClick(){ref.current=ref.current+1;alert('You clicked '+ref.current+' times!');}return(<buttononClick={handleClick}>Click me!</button>);}"
                },
                {
                    "type": "p",
                    "text": "A ref is like a secret pocket of your component that React doesn’t track. For example, you can use refs to storetimeout IDs,DOM elements, and other objects that don’t impact the component’s rendering output."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadReferencing Values with Refsto learn how to use refs to remember information."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Manipulating the DOM with refs"
                },
                {
                    "type": "p",
                    "text": "React automatically updates the DOM to match your render output, so your components won’t often need to manipulate it. However, sometimes you might need access to the DOM elements managed by React—for example, to focus a node, scroll to it, or measure its size and position. There is no built-in way to do those things in React, so you will need a ref to the DOM node. For example, clicking the button will focus the input using a ref:"
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';exportdefaultfunctionForm(){constinputRef=useRef(null);functionhandleClick(){inputRef.current.focus();}return(<><inputref={inputRef}/><buttononClick={handleClick}>Focus the input</button></>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadManipulating the DOM with Refsto learn how to access DOM elements managed by React."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Synchronizing with Effects"
                },
                {
                    "type": "p",
                    "text": "Some components need to synchronize with external systems. For example, you might want to control a non-React component based on the React state, set up a server connection, or send an analytics log when a component appears on the screen. Unlike event handlers, which let you handle particular events,Effectslet you run some code after rendering. Use them to synchronize your component with a system outside of React."
                },
                {
                    "type": "p",
                    "text": "Press Play/Pause a few times and see how the video player stays synchronized to theisPlayingprop value:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useRef,useEffect}from'react';functionVideoPlayer({src,isPlaying}){constref=useRef(null);useEffect(()=>{if(isPlaying){ref.current.play();}else{ref.current.pause();}},[isPlaying]);return<videoref={ref}src={src}loopplaysInline/>;}exportdefaultfunctionApp(){const[isPlaying,setIsPlaying]=useState(false);return(<><buttononClick={()=>setIsPlaying(!isPlaying)}>{isPlaying?'Pause':'Play'}</button><VideoPlayerisPlaying={isPlaying}src=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"/></>);}"
                },
                {
                    "type": "p",
                    "text": "Many Effects also “clean up” after themselves. For example, an Effect that sets up a connection to a chat server should return acleanup functionthat tells React how to disconnect your component from that server:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection}from'./chat.js';exportdefaultfunctionChatRoom(){useEffect(()=>{constconnection=createConnection();connection.connect();return()=>connection.disconnect();},[]);return<h1>Welcome to the chat!</h1>;}"
                },
                {
                    "type": "p",
                    "text": "In development, React will immediately run and clean up your Effect one extra time. This is why you see\"✅ Connecting...\"printed twice. This ensures that you don’t forget to implement the cleanup function."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadSynchronizing with Effectsto learn how to synchronize components with external systems."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "You Might Not Need An Effect"
                },
                {
                    "type": "p",
                    "text": "Effects are an escape hatch from the React paradigm. They let you “step outside” of React and synchronize your components with some external system. If there is no external system involved (for example, if you want to update a component’s state when some props or state change), you shouldn’t need an Effect. Removing unnecessary Effects will make your code easier to follow, faster to run, and less error-prone."
                },
                {
                    "type": "p",
                    "text": "There are two common cases in which you don’t need Effects:"
                },
                {
                    "type": "list",
                    "items": [
                        "You don’t need Effects to transform data for rendering.",
                        "You don’t need Effects to handle user events."
                    ]
                },
                {
                    "type": "p",
                    "text": "For example, you don’t need an Effect to adjust some state based on other state:"
                },
                {
                    "type": "code",
                    "code": "functionForm(){const[firstName,setFirstName]=useState('Taylor');const[lastName,setLastName]=useState('Swift');// 🔴 Avoid: redundant state and unnecessary Effectconst[fullName,setFullName]=useState('');useEffect(()=>{setFullName(firstName+' '+lastName);},[firstName,lastName]);// ...}"
                },
                {
                    "type": "p",
                    "text": "Instead, calculate as much as you can while rendering:"
                },
                {
                    "type": "code",
                    "code": "functionForm(){const[firstName,setFirstName]=useState('Taylor');const[lastName,setLastName]=useState('Swift');// ✅ Good: calculated during renderingconstfullName=firstName+' '+lastName;// ...}"
                },
                {
                    "type": "p",
                    "text": "However, youdoneed Effects to synchronize with external systems."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadYou Might Not Need an Effectto learn how to remove unnecessary Effects."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Lifecycle of reactive effects"
                },
                {
                    "type": "p",
                    "text": "Effects have a different lifecycle from components. Components may mount, update, or unmount. An Effect can only do two things: to start synchronizing something, and later to stop synchronizing it. This cycle can happen multiple times if your Effect depends on props and state that change over time."
                },
                {
                    "type": "p",
                    "text": "This Effect depends on the value of theroomIdprop. Props arereactive values,which means they can change on a re-render. Notice that the Effectre-synchronizes(and re-connects to the server) ifroomIdchanges:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection}from'./chat.js';constserverUrl='https://localhost:1234';functionChatRoom({roomId}){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>connection.disconnect();},[roomId]);return<h1>Welcome to the{roomId}room!</h1>;}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><hr/><ChatRoomroomId={roomId}/></>);}"
                },
                {
                    "type": "p",
                    "text": "React provides a linter rule to check that you’ve specified your Effect’s dependencies correctly. If you forget to specifyroomIdin the list of dependencies in the above example, the linter will find that bug automatically."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadLifecycle of Reactive Eventsto learn how an Effect’s lifecycle is different from a component’s."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Separating events from Effects"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Under Construction"
                },
                {
                    "type": "p",
                    "text": "This section describes anexperimental API that has not yet been releasedin a stable version of React."
                },
                {
                    "type": "p",
                    "text": "Event handlers only re-run when you perform the same interaction again. Unlike event handlers, Effects re-synchronize if any of the values they read, like props or state, are different than during last render. Sometimes, you want a mix of both behaviors: an Effect that re-runs in response to some values but not others."
                },
                {
                    "type": "p",
                    "text": "All code inside Effects isreactive.It will run again if some reactive value it reads has changed due to a re-render. For example, this Effect will re-connect to the chat if eitherroomIdorthemehave changed:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection,sendMessage}from'./chat.js';import{showNotification}from'./notifications.js';constserverUrl='https://localhost:1234';functionChatRoom({roomId,theme}){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.on('connected',()=>{showNotification('Connected!',theme);});connection.connect();return()=>connection.disconnect();},[roomId,theme]);return<h1>Welcome to the{roomId}room!</h1>}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');const[isDark,setIsDark]=useState(false);return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><label><inputtype=\"checkbox\"checked={isDark}onChange={e=>setIsDark(e.target.checked)}/>Use dark theme</label><hr/><ChatRoomroomId={roomId}theme={isDark?'dark':'light'}/></>);}"
                },
                {
                    "type": "p",
                    "text": "This is not ideal. You want to re-connect to the chat only if theroomIdhas changed. Switching thethemeshouldn’t re-connect to the chat! Move the code readingthemeout of your Effect into anEffect Event:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{experimental_useEffectEventasuseEffectEvent}from'react';import{createConnection,sendMessage}from'./chat.js';import{showNotification}from'./notifications.js';constserverUrl='https://localhost:1234';functionChatRoom({roomId,theme}){constonConnected=useEffectEvent(()=>{showNotification('Connected!',theme);});useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.on('connected',()=>{onConnected();});connection.connect();return()=>connection.disconnect();},[roomId]);return<h1>Welcome to the{roomId}room!</h1>}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');const[isDark,setIsDark]=useState(false);return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><label><inputtype=\"checkbox\"checked={isDark}onChange={e=>setIsDark(e.target.checked)}/>Use dark theme</label><hr/><ChatRoomroomId={roomId}theme={isDark?'dark':'light'}/></>);}"
                },
                {
                    "type": "p",
                    "text": "Code inside Effect Events isn’t reactive, so changing thethemeno longer makes your Effect re-connect."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadSeparating Events from Effectsto learn how to prevent some values from re-triggering Effects."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Removing Effect dependencies"
                },
                {
                    "type": "p",
                    "text": "When you write an Effect, the linter will verify that you’ve included every reactive value (like props and state) that the Effect reads in the list of your Effect’s dependencies. This ensures that your Effect remains synchronized with the latest props and state of your component. Unnecessary dependencies may cause your Effect to run too often, or even create an infinite loop. The way you remove them depends on the case."
                },
                {
                    "type": "p",
                    "text": "For example, this Effect depends on theoptionsobject which gets re-created every time you edit the input:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection}from'./chat.js';constserverUrl='https://localhost:1234';functionChatRoom({roomId}){const[message,setMessage]=useState('');constoptions={serverUrl:serverUrl,roomId:roomId};useEffect(()=>{constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[options]);return(<><h1>Welcome to the{roomId}room!</h1><inputvalue={message}onChange={e=>setMessage(e.target.value)}/></>);}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><hr/><ChatRoomroomId={roomId}/></>);}"
                },
                {
                    "type": "p",
                    "text": "You don’t want the chat to re-connect every time you start typing a message in that chat. To fix this problem, move creation of theoptionsobject inside the Effect so that the Effect only depends on theroomIdstring:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection}from'./chat.js';constserverUrl='https://localhost:1234';functionChatRoom({roomId}){const[message,setMessage]=useState('');useEffect(()=>{constoptions={serverUrl:serverUrl,roomId:roomId};constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[roomId]);return(<><h1>Welcome to the{roomId}room!</h1><inputvalue={message}onChange={e=>setMessage(e.target.value)}/></>);}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><hr/><ChatRoomroomId={roomId}/></>);}"
                },
                {
                    "type": "p",
                    "text": "Notice that you didn’t start by editing the dependency list to remove theoptionsdependency. That would be wrong. Instead, you changed the surrounding code so that the dependency becameunnecessary.Think of the dependency list as a list of all the reactive values used by your Effect’s code. You don’t intentionally choose what to put on that list. The list describes your code. To change the dependency list, change the code."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadRemoving Effect Dependenciesto learn how to make your Effect re-run less often."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reusing logic with custom Hooks"
                },
                {
                    "type": "p",
                    "text": "React comes with built-in Hooks likeuseState,useContext, anduseEffect. Sometimes, you’ll wish that there was a Hook for some more specific purpose: for example, to fetch data, to keep track of whether the user is online, or to connect to a chat room. To do this, you can create your own Hooks for your application’s needs."
                },
                {
                    "type": "p",
                    "text": "In this example, theusePointerPositioncustom Hook tracks the cursor position, whileuseDelayedValuecustom Hook returns a value that’s “lagging behind” the value you passed by a certain number of milliseconds. Move the cursor over the sandbox preview area to see a moving trail of dots following the cursor:"
                },
                {
                    "type": "code",
                    "code": "import{usePointerPosition}from'./usePointerPosition.js';import{useDelayedValue}from'./useDelayedValue.js';exportdefaultfunctionCanvas(){constpos1=usePointerPosition();constpos2=useDelayedValue(pos1,100);constpos3=useDelayedValue(pos2,200);constpos4=useDelayedValue(pos3,100);constpos5=useDelayedValue(pos4,50);return(<><Dotposition={pos1}opacity={1}/><Dotposition={pos2}opacity={0.8}/><Dotposition={pos3}opacity={0.6}/><Dotposition={pos4}opacity={0.4}/><Dotposition={pos5}opacity={0.2}/></>);}functionDot({position,opacity}){return(<divstyle={{position:'absolute',backgroundColor:'pink',borderRadius:'50%',opacity,transform:`translate(${position.x}px,${position.y}px)`,pointerEvents:'none',left:-20,top:-20,width:40,height:40,}}/>);}"
                },
                {
                    "type": "p",
                    "text": "You can create custom Hooks, compose them together, pass data between them, and reuse them between components. As your app grows, you will write fewer Effects by hand because you’ll be able to reuse custom Hooks you already wrote. There are also many excellent custom Hooks maintained by the React community."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadReusing Logic with Custom Hooksto learn how to share logic between components."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "What’s next?"
                },
                {
                    "type": "p",
                    "text": "Head over toReferencing Values with Refsto start reading this chapter page by page!"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/extracting-state-logic-into-a-reducer",
            "title": "Extracting State Logic into a Reducer – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Extracting State Logic into a Reducer"
                },
                {
                    "type": "p",
                    "text": "Components with many state updates spread across many event handlers can get overwhelming. For these cases, you can consolidate all the state update logic outside your component in a single function, called areducer."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "What a reducer function is",
                        "How to refactoruseStatetouseReducer",
                        "When to use a reducer",
                        "How to write one well"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Consolidate state logic with a reducer"
                },
                {
                    "type": "p",
                    "text": "As your components grow in complexity, it can get harder to see at a glance all the different ways in which a component’s state gets updated. For example, theTaskAppcomponent below holds an array oftasksin state and uses three different event handlers to add, remove, and edit tasks:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';importAddTaskfrom'./AddTask.js';importTaskListfrom'./TaskList.js';exportdefaultfunctionTaskApp(){const[tasks,setTasks]=useState(initialTasks);functionhandleAddTask(text){setTasks([...tasks,{id:nextId++,text:text,done:false,},]);}functionhandleChangeTask(task){setTasks(tasks.map((t)=>{if(t.id===task.id){returntask;}else{returnt;}}));}functionhandleDeleteTask(taskId){setTasks(tasks.filter((t)=>t.id!==taskId));}return(<><h1>Prague itinerary</h1><AddTaskonAddTask={handleAddTask}/><TaskListtasks={tasks}onChangeTask={handleChangeTask}onDeleteTask={handleDeleteTask}/></>);}letnextId=3;constinitialTasks=[{id:0,text:'Visit Kafka Museum',done:true},{id:1,text:'Watch a puppet show',done:false},{id:2,text:'Lennon Wall pic',done:false},];"
                },
                {
                    "type": "p",
                    "text": "Each of its event handlers callssetTasksin order to update the state. As this component grows, so does the amount of state logic sprinkled throughout it. To reduce this complexity and keep all your logic in one easy-to-access place, you can move that state logic into a single function outside your component,called a “reducer”."
                },
                {
                    "type": "p",
                    "text": "Reducers are a different way to handle state. You can migrate fromuseStatetouseReducerin three steps:"
                },
                {
                    "type": "list",
                    "items": [
                        "Movefrom setting state to dispatching actions.",
                        "Writea reducer function.",
                        "Usethe reducer from your component."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 1: Move from setting state to dispatching actions"
                },
                {
                    "type": "p",
                    "text": "Your event handlers currently specifywhat to doby setting state:"
                },
                {
                    "type": "code",
                    "code": "functionhandleAddTask(text){setTasks([...tasks,{id:nextId++,text:text,done:false,},]);}functionhandleChangeTask(task){setTasks(tasks.map((t)=>{if(t.id===task.id){returntask;}else{returnt;}}));}functionhandleDeleteTask(taskId){setTasks(tasks.filter((t)=>t.id!==taskId));}"
                },
                {
                    "type": "p",
                    "text": "Remove all the state setting logic. What you are left with are three event handlers:"
                },
                {
                    "type": "list",
                    "items": [
                        "handleAddTask(text)is called when the user presses “Add”.",
                        "handleChangeTask(task)is called when the user toggles a task or presses “Save”.",
                        "handleDeleteTask(taskId)is called when the user presses “Delete”."
                    ]
                },
                {
                    "type": "p",
                    "text": "Managing state with reducers is slightly different from directly setting state. Instead of telling React “what to do” by setting state, you specify “what the user just did” by dispatching “actions” from your event handlers. (The state update logic will live elsewhere!) So instead of “settingtasks” via an event handler, you’re dispatching an “added/changed/deleted a task” action. This is more descriptive of the user’s intent."
                },
                {
                    "type": "code",
                    "code": "functionhandleAddTask(text){dispatch({type:'added',id:nextId++,text:text,});}functionhandleChangeTask(task){dispatch({type:'changed',task:task,});}functionhandleDeleteTask(taskId){dispatch({type:'deleted',id:taskId,});}"
                },
                {
                    "type": "p",
                    "text": "The object you pass todispatchis called an “action”:"
                },
                {
                    "type": "code",
                    "code": "functionhandleDeleteTask(taskId){dispatch(// \"action\" object:{type:'deleted',id:taskId,});}"
                },
                {
                    "type": "p",
                    "text": "It is a regular JavaScript object. You decide what to put in it, but generally it should contain the minimal information aboutwhat happened. (You will add thedispatchfunction itself in a later step.)"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "An action object can have any shape."
                },
                {
                    "type": "p",
                    "text": "By convention, it is common to give it a stringtypethat describes what happened, and pass any additional information in other fields. Thetypeis specific to a component, so in this example either'added'or'added_task'would be fine. Choose a name that says what happened!"
                },
                {
                    "type": "code",
                    "code": "dispatch({// specific to componenttype:'what_happened',// other fields go here});"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 2: Write a reducer function"
                },
                {
                    "type": "p",
                    "text": "A reducer function is where you will put your state logic. It takes two arguments, the current state and the action object, and it returns the next state:"
                },
                {
                    "type": "code",
                    "code": "functionyourReducer(state,action){// return next state for React to set}"
                },
                {
                    "type": "p",
                    "text": "React will set the state to what you return from the reducer."
                },
                {
                    "type": "p",
                    "text": "To move your state setting logic from your event handlers to a reducer function in this example, you will:"
                },
                {
                    "type": "list",
                    "items": [
                        "Declare the current state (tasks) as the first argument.",
                        "Declare theactionobject as the second argument.",
                        "Return thenextstate from the reducer (which React will set the state to)."
                    ]
                },
                {
                    "type": "p",
                    "text": "Here is all the state setting logic migrated to a reducer function:"
                },
                {
                    "type": "code",
                    "code": "functiontasksReducer(tasks,action){if(action.type==='added'){return[...tasks,{id:action.id,text:action.text,done:false,},];}elseif(action.type==='changed'){returntasks.map((t)=>{if(t.id===action.task.id){returnaction.task;}else{returnt;}});}elseif(action.type==='deleted'){returntasks.filter((t)=>t.id!==action.id);}else{throwError('Unknown action: '+action.type);}}"
                },
                {
                    "type": "p",
                    "text": "Because the reducer function takes state (tasks) as an argument, you candeclare it outside of your component.This decreases the indentation level and can make your code easier to read."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "The code above uses if/else statements, but it’s a convention to useswitch statementsinside reducers. The result is the same, but it can be easier to read switch statements at a glance."
                },
                {
                    "type": "p",
                    "text": "We’ll be using them throughout the rest of this documentation like so:"
                },
                {
                    "type": "code",
                    "code": "functiontasksReducer(tasks,action){switch(action.type){case'added':{return[...tasks,{id:action.id,text:action.text,done:false,},];}case'changed':{returntasks.map((t)=>{if(t.id===action.task.id){returnaction.task;}else{returnt;}});}case'deleted':{returntasks.filter((t)=>t.id!==action.id);}default:{throwError('Unknown action: '+action.type);}}}"
                },
                {
                    "type": "p",
                    "text": "We recommend wrapping eachcaseblock into the{and}curly braces so that variables declared inside of differentcases don’t clash with each other. Also, acaseshould usually end with areturn. If you forget toreturn, the code will “fall through” to the nextcase, which can lead to mistakes!"
                },
                {
                    "type": "p",
                    "text": "If you’re not yet comfortable with switch statements, using if/else is completely fine."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Why are reducers called this way?"
                },
                {
                    "type": "p",
                    "text": "Although reducers can “reduce” the amount of code inside your component, they are actually named after thereduce()operation that you can perform on arrays."
                },
                {
                    "type": "p",
                    "text": "Thereduce()operation lets you take an array and “accumulate” a single value out of many:"
                },
                {
                    "type": "code",
                    "code": "constarr=[1,2,3,4,5];constsum=arr.reduce((result,number)=>result+number);// 1 + 2 + 3 + 4 + 5"
                },
                {
                    "type": "p",
                    "text": "The function you pass toreduceis known as a “reducer”. It takes theresult so farand thecurrent item,then it returns thenext result.React reducers are an example of the same idea: they take thestate so farand theaction, and return thenext state.In this way, they accumulate actions over time into state."
                },
                {
                    "type": "p",
                    "text": "You could even use thereduce()method with aninitialStateand an array ofactionsto calculate the final state by passing your reducer function to it:"
                },
                {
                    "type": "code",
                    "code": "importtasksReducerfrom'./tasksReducer.js';letinitialState=[];letactions=[{type:'added',id:1,text:'Visit Kafka Museum'},{type:'added',id:2,text:'Watch a puppet show'},{type:'deleted',id:1},{type:'added',id:3,text:'Lennon Wall pic'},];letfinalState=actions.reduce(tasksReducer,initialState);constoutput=document.getElementById('output');output.textContent=JSON.stringify(finalState,null,2);"
                },
                {
                    "type": "p",
                    "text": "You probably won’t need to do this yourself, but this is similar to what React does!"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 3: Use the reducer from your component"
                },
                {
                    "type": "p",
                    "text": "Finally, you need to hook up thetasksReducerto your component. Import theuseReducerHook from React:"
                },
                {
                    "type": "code",
                    "code": "import{useReducer}from'react';"
                },
                {
                    "type": "p",
                    "text": "Then you can replaceuseState:"
                },
                {
                    "type": "code",
                    "code": "const[tasks,setTasks]=useState(initialTasks);"
                },
                {
                    "type": "p",
                    "text": "withuseReducerlike so:"
                },
                {
                    "type": "code",
                    "code": "const[tasks,dispatch]=useReducer(tasksReducer,initialTasks);"
                },
                {
                    "type": "p",
                    "text": "TheuseReducerHook is similar touseState—you must pass it an initial state and it returns a stateful value and a way to set state (in this case, the dispatch function). But it’s a little different."
                },
                {
                    "type": "p",
                    "text": "TheuseReducerHook takes two arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "A reducer function",
                        "An initial state"
                    ]
                },
                {
                    "type": "p",
                    "text": "And it returns:"
                },
                {
                    "type": "list",
                    "items": [
                        "A stateful value",
                        "A dispatch function (to “dispatch” user actions to the reducer)"
                    ]
                },
                {
                    "type": "p",
                    "text": "Now it’s fully wired up! Here, the reducer is declared at the bottom of the component file:"
                },
                {
                    "type": "code",
                    "code": "import{useReducer}from'react';importAddTaskfrom'./AddTask.js';importTaskListfrom'./TaskList.js';exportdefaultfunctionTaskApp(){const[tasks,dispatch]=useReducer(tasksReducer,initialTasks);functionhandleAddTask(text){dispatch({type:'added',id:nextId++,text:text,});}functionhandleChangeTask(task){dispatch({type:'changed',task:task,});}functionhandleDeleteTask(taskId){dispatch({type:'deleted',id:taskId,});}return(<><h1>Prague itinerary</h1><AddTaskonAddTask={handleAddTask}/><TaskListtasks={tasks}onChangeTask={handleChangeTask}onDeleteTask={handleDeleteTask}/></>);}functiontasksReducer(tasks,action){switch(action.type){case'added':{return[...tasks,{id:action.id,text:action.text,done:false,},];}case'changed':{returntasks.map((t)=>{if(t.id===action.task.id){returnaction.task;}else{returnt;}});}case'deleted':{returntasks.filter((t)=>t.id!==action.id);}default:{throwError('Unknown action: '+action.type);}}}letnextId=3;constinitialTasks=[{id:0,text:'Visit Kafka Museum',done:true},{id:1,text:'Watch a puppet show',done:false},{id:2,text:'Lennon Wall pic',done:false},];"
                },
                {
                    "type": "p",
                    "text": "If you want, you can even move the reducer to a different file:"
                },
                {
                    "type": "code",
                    "code": "import{useReducer}from'react';importAddTaskfrom'./AddTask.js';importTaskListfrom'./TaskList.js';importtasksReducerfrom'./tasksReducer.js';exportdefaultfunctionTaskApp(){const[tasks,dispatch]=useReducer(tasksReducer,initialTasks);functionhandleAddTask(text){dispatch({type:'added',id:nextId++,text:text,});}functionhandleChangeTask(task){dispatch({type:'changed',task:task,});}functionhandleDeleteTask(taskId){dispatch({type:'deleted',id:taskId,});}return(<><h1>Prague itinerary</h1><AddTaskonAddTask={handleAddTask}/><TaskListtasks={tasks}onChangeTask={handleChangeTask}onDeleteTask={handleDeleteTask}/></>);}letnextId=3;constinitialTasks=[{id:0,text:'Visit Kafka Museum',done:true},{id:1,text:'Watch a puppet show',done:false},{id:2,text:'Lennon Wall pic',done:false},];"
                },
                {
                    "type": "p",
                    "text": "Component logic can be easier to read when you separate concerns like this. Now the event handlers only specifywhat happenedby dispatching actions, and the reducer function determineshow the state updatesin response to them."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "ComparinguseStateanduseReducer"
                },
                {
                    "type": "p",
                    "text": "Reducers are not without downsides! Here’s a few ways you can compare them:"
                },
                {
                    "type": "list",
                    "items": [
                        "Code size:Generally, withuseStateyou have to write less code upfront. WithuseReducer, you have to write both a reducer functionanddispatch actions. However,useReducercan help cut down on the code if many event handlers modify state in a similar way.",
                        "Readability:useStateis very easy to read when the state updates are simple. When they get more complex, they can bloat your component’s code and make it difficult to scan. In this case,useReducerlets you cleanly separate thehowof update logic from thewhat happenedof event handlers.",
                        "Debugging:When you have a bug withuseState, it can be difficult to tellwherethe state was set incorrectly, andwhy. WithuseReducer, you can add a console log into your reducer to see every state update, andwhyit happened (due to whichaction). If eachactionis correct, you’ll know that the mistake is in the reducer logic itself. However, you have to step through more code than withuseState.",
                        "Testing:A reducer is a pure function that doesn’t depend on your component. This means that you can export and test it separately in isolation. While generally it’s best to test components in a more realistic environment, for complex state update logic it can be useful to assert that your reducer returns a particular state for a particular initial state and action.",
                        "Personal preference:Some people like reducers, others don’t. That’s okay. It’s a matter of preference. You can always convert betweenuseStateanduseReducerback and forth: they are equivalent!"
                    ]
                },
                {
                    "type": "p",
                    "text": "We recommend using a reducer if you often encounter bugs due to incorrect state updates in some component, and want to introduce more structure to its code. You don’t have to use reducers for everything: feel free to mix and match! You can evenuseStateanduseReducerin the same component."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Writing reducers well"
                },
                {
                    "type": "p",
                    "text": "Keep these two tips in mind when writing reducers:"
                },
                {
                    "type": "list",
                    "items": [
                        "Reducers must be pure.Similar tostate updater functions, reducers run during rendering! (Actions are queued until the next render.) This means that reducersmust be pure—same inputs always result in the same output. They should not send requests, schedule timeouts, or perform any side effects (operations that impact things outside the component). They should updateobjectsandarrayswithout mutations.",
                        "Each action describes a single user interaction, even if that leads to multiple changes in the data.For example, if a user presses “Reset” on a form with five fields managed by a reducer, it makes more sense to dispatch onereset_formaction rather than five separateset_fieldactions. If you log every action in a reducer, that log should be clear enough for you to reconstruct what interactions or responses happened in what order. This helps with debugging!"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Writing concise reducers with Immer"
                },
                {
                    "type": "p",
                    "text": "Just like withupdating objectsandarraysin regular state, you can use the Immer library to make reducers more concise. Here,useImmerReducerlets you mutate the state withpushorarr[i] =assignment:"
                },
                {
                    "type": "code",
                    "code": "{\"dependencies\":{\"immer\":\"1.7.3\",\"react\":\"latest\",\"react-dom\":\"latest\",\"react-scripts\":\"latest\",\"use-immer\":\"0.5.1\"},\"scripts\":{\"start\":\"react-scripts start\",\"build\":\"react-scripts build\",\"test\":\"react-scripts test --env=jsdom\",\"eject\":\"react-scripts eject\"},\"devDependencies\":{}}"
                },
                {
                    "type": "p",
                    "text": "Reducers must be pure, so they shouldn’t mutate state. But Immer provides you with a specialdraftobject which is safe to mutate. Under the hood, Immer will create a copy of your state with the changes you made to thedraft. This is why reducers managed byuseImmerReducercan mutate their first argument and don’t need to return state."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "To convert fromuseStatetouseReducer:Dispatch actions from event handlers.Write a reducer function that returns the next state for a given state and action.ReplaceuseStatewithuseReducer.",
                        "Dispatch actions from event handlers.",
                        "Write a reducer function that returns the next state for a given state and action.",
                        "ReplaceuseStatewithuseReducer.",
                        "Reducers require you to write a bit more code, but they help with debugging and testing.",
                        "Reducers must be pure.",
                        "Each action describes a single user interaction.",
                        "Use Immer if you want to write reducers in a mutating style."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Dispatch actions from event handlers.",
                        "Write a reducer function that returns the next state for a given state and action.",
                        "ReplaceuseStatewithuseReducer."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of4:Dispatch actions from event handlers"
                },
                {
                    "type": "p",
                    "text": "Currently, the event handlers inContactList.jsandChat.jshave// TODOcomments. This is why typing into the input doesn’t work, and clicking on the buttons doesn’t change the selected recipient."
                },
                {
                    "type": "p",
                    "text": "Replace these two// TODOs with the code todispatchthe corresponding actions. To see the expected shape and the type of the actions, check the reducer inmessengerReducer.js. The reducer is already written so you won’t need to change it. You only need to dispatch the actions inContactList.jsandChat.js."
                },
                {
                    "type": "code",
                    "code": "import{useReducer}from'react';importChatfrom'./Chat.js';importContactListfrom'./ContactList.js';import{initialState,messengerReducer}from'./messengerReducer';exportdefaultfunctionMessenger(){const[state,dispatch]=useReducer(messengerReducer,initialState);constmessage=state.message;constcontact=contacts.find((c)=>c.id===state.selectedId);return(<div><ContactListcontacts={contacts}selectedId={state.selectedId}dispatch={dispatch}/><Chatkey={contact.id}message={message}contact={contact}dispatch={dispatch}/></div>);}constcontacts=[{id:0,name:'Taylor',email:'taylor@mail.com'},{id:1,name:'Alice',email:'alice@mail.com'},{id:2,name:'Bob',email:'bob@mail.com'},];"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/importing-and-exporting-components",
            "title": "Importing and Exporting Components – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Importing and Exporting Components"
                },
                {
                    "type": "p",
                    "text": "The magic of components lies in their reusability: you can create components that are composed of other components. But as you nest more and more components, it often makes sense to start splitting them into different files. This lets you keep your files easy to scan and reuse components in more places."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "What a root component file is",
                        "How to import and export a component",
                        "When to use default and named imports and exports",
                        "How to import and export multiple components from one file",
                        "How to split components into multiple files"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "The root component file"
                },
                {
                    "type": "p",
                    "text": "InYour First Component, you made aProfilecomponent and aGallerycomponent that renders it:"
                },
                {
                    "type": "code",
                    "code": "functionProfile(){return(<imgsrc=\"https://i.imgur.com/MK3eW3As.jpg\"alt=\"Katherine Johnson\"/>);}exportdefaultfunctionGallery(){return(<section><h1>Amazing scientists</h1><Profile/><Profile/><Profile/></section>);}"
                },
                {
                    "type": "p",
                    "text": "These currently live in aroot component file,namedApp.jsin this example. Depending on your setup, your root component could be in another file, though. If you use a framework with file-based routing, such as Next.js, your root component will be different for every page."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Exporting and importing a component"
                },
                {
                    "type": "p",
                    "text": "What if you want to change the landing screen in the future and put a list of science books there? Or place all the profiles somewhere else? It makes sense to moveGalleryandProfileout of the root component file. This will make them more modular and reusable in other files. You can move a component in three steps:"
                },
                {
                    "type": "list",
                    "items": [
                        "Makea new JS file to put the components in.",
                        "Exportyour function component from that file (using eitherdefaultornamedexports).",
                        "Importit in the file where you’ll use the component (using the corresponding technique for importingdefaultornamedexports)."
                    ]
                },
                {
                    "type": "p",
                    "text": "Here bothProfileandGalleryhave been moved out ofApp.jsinto a new file calledGallery.js. Now you can changeApp.jsto importGalleryfromGallery.js:"
                },
                {
                    "type": "code",
                    "code": "importGalleryfrom'./Gallery.js';exportdefaultfunctionApp(){return(<Gallery/>);}"
                },
                {
                    "type": "p",
                    "text": "Notice how this example is broken down into two component files now:"
                },
                {
                    "type": "list",
                    "items": [
                        "Gallery.js:Defines theProfilecomponent which is only used within the same file and is not exported.Exports theGallerycomponent as adefault export.",
                        "Defines theProfilecomponent which is only used within the same file and is not exported.",
                        "Exports theGallerycomponent as adefault export.",
                        "App.js:ImportsGalleryas adefault importfromGallery.js.Exports the rootAppcomponent as adefault export.",
                        "ImportsGalleryas adefault importfromGallery.js.",
                        "Exports the rootAppcomponent as adefault export."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Defines theProfilecomponent which is only used within the same file and is not exported.",
                        "Exports theGallerycomponent as adefault export."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "ImportsGalleryas adefault importfromGallery.js.",
                        "Exports the rootAppcomponent as adefault export."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "You may encounter files that leave off the.jsfile extension like so:"
                },
                {
                    "type": "code",
                    "code": "importGalleryfrom'./Gallery';"
                },
                {
                    "type": "p",
                    "text": "Either'./Gallery.js'or'./Gallery'will work with React, though the former is closer to hownative ES Moduleswork."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Default vs named exports"
                },
                {
                    "type": "p",
                    "text": "There are two primary ways to export values with JavaScript: default exports and named exports. So far, our examples have only used default exports. But you can use one or both of them in the same file.A file can have no more than onedefaultexport, but it can have as manynamedexports as you like."
                },
                {
                    "type": "p",
                    "text": "How you export your component dictates how you must import it. You will get an error if you try to import a default export the same way you would a named export! This chart can help you keep track:"
                },
                {
                    "type": "p",
                    "text": "When you write adefaultimport, you can put any name you want afterimport. For example, you could writeimport Banana from './Button.js'instead and it would still provide you with the same default export. In contrast, with named imports, the name has to match on both sides. That’s why they are callednamedimports!"
                },
                {
                    "type": "p",
                    "text": "People often use default exports if the file exports only one component, and use named exports if it exports multiple components and values.Regardless of which coding style you prefer, always give meaningful names to your component functions and the files that contain them. Components without names, likeexport default () => {}, are discouraged because they make debugging harder."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Exporting and importing multiple components from the same file"
                },
                {
                    "type": "p",
                    "text": "What if you want to show just oneProfileinstead of a gallery? You can export theProfilecomponent, too. ButGallery.jsalready has adefaultexport, and you can’t havetwodefault exports. You could create a new file with a default export, or you could add anamedexport forProfile.A file can only have one default export, but it can have numerous named exports!"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "To reduce the potential confusion between default and named exports, some teams choose to only stick to one style (default or named), or avoid mixing them in a single file. Do what works best for you!"
                },
                {
                    "type": "p",
                    "text": "First,exportProfilefromGallery.jsusing a named export (nodefaultkeyword):"
                },
                {
                    "type": "code",
                    "code": "exportfunctionProfile(){// ...}"
                },
                {
                    "type": "p",
                    "text": "Then,importProfilefromGallery.jstoApp.jsusing a named import (with the curly braces):"
                },
                {
                    "type": "code",
                    "code": "import{Profile}from'./Gallery.js';"
                },
                {
                    "type": "p",
                    "text": "Finally,render<Profile />from theAppcomponent:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionApp(){return<Profile/>;}"
                },
                {
                    "type": "p",
                    "text": "NowGallery.jscontains two exports: a defaultGalleryexport, and a namedProfileexport.App.jsimports both of them. Try editing<Profile />to<Gallery />and back in this example:"
                },
                {
                    "type": "code",
                    "code": "importGalleryfrom'./Gallery.js';import{Profile}from'./Gallery.js';exportdefaultfunctionApp(){return(<Profile/>);}"
                },
                {
                    "type": "p",
                    "text": "Now you’re using a mix of default and named exports:"
                },
                {
                    "type": "list",
                    "items": [
                        "Gallery.js:Exports theProfilecomponent as anamed export calledProfile.Exports theGallerycomponent as adefault export.",
                        "Exports theProfilecomponent as anamed export calledProfile.",
                        "Exports theGallerycomponent as adefault export.",
                        "App.js:ImportsProfileas anamed import calledProfilefromGallery.js.ImportsGalleryas adefault importfromGallery.js.Exports the rootAppcomponent as adefault export.",
                        "ImportsProfileas anamed import calledProfilefromGallery.js.",
                        "ImportsGalleryas adefault importfromGallery.js.",
                        "Exports the rootAppcomponent as adefault export."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Exports theProfilecomponent as anamed export calledProfile.",
                        "Exports theGallerycomponent as adefault export."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "ImportsProfileas anamed import calledProfilefromGallery.js.",
                        "ImportsGalleryas adefault importfromGallery.js.",
                        "Exports the rootAppcomponent as adefault export."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "p",
                    "text": "On this page you learned:"
                },
                {
                    "type": "list",
                    "items": [
                        "What a root component file is",
                        "How to import and export a component",
                        "When and how to use default and named imports and exports",
                        "How to export multiple components from the same file"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of1:Split the components further"
                },
                {
                    "type": "p",
                    "text": "Currently,Gallery.jsexports bothProfileandGallery, which is a bit confusing."
                },
                {
                    "type": "p",
                    "text": "Move theProfilecomponent to its ownProfile.js, and then change theAppcomponent to render both<Profile />and<Gallery />one after another."
                },
                {
                    "type": "p",
                    "text": "You may use either a default or a named export forProfile, but make sure that you use the corresponding import syntax in bothApp.jsandGallery.js! You can refer to the table from the deep dive above:"
                },
                {
                    "type": "code",
                    "code": "// Move me to Profile.js!exportfunctionProfile(){return(<imgsrc=\"https://i.imgur.com/QIrZWGIs.jpg\"alt=\"Alan L. Hart\"/>);}exportdefaultfunctionGallery(){return(<section><h1>Amazing scientists</h1><Profile/><Profile/><Profile/></section>);}"
                },
                {
                    "type": "p",
                    "text": "After you get it working with one kind of exports, make it work with the other kind."
                }
            ]
        },
        {
            "url": "https://react.dev/learn/installation",
            "title": "Installation – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Installation"
                },
                {
                    "type": "p",
                    "text": "React has been designed from the start for gradual adoption. You can use as little or as much React as you need. Whether you want to get a taste of React, add some interactivity to an HTML page, or start a complex React-powered app, this section will help you get started."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "In this chapter"
                },
                {
                    "type": "list",
                    "items": [
                        "How to start a new React project",
                        "How to add React to an existing project",
                        "How to set up your editor",
                        "How to install React Developer Tools"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try React"
                },
                {
                    "type": "p",
                    "text": "You don’t need to install anything to play with React. Try editing this sandbox!"
                },
                {
                    "type": "code",
                    "code": "functionGreeting({name}){return<h1>Hello,{name}</h1>;}exportdefaultfunctionApp(){return<Greetingname=\"world\"/>}"
                },
                {
                    "type": "p",
                    "text": "You can edit it directly or open it in a new tab by pressing the “Fork” button in the upper right corner."
                },
                {
                    "type": "p",
                    "text": "Most pages in the React documentation contain sandboxes like this. Outside of the React documentation, there are many online sandboxes that support React: for example,CodeSandbox,StackBlitz, orCodePen."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Try React locally"
                },
                {
                    "type": "p",
                    "text": "To try React locally on your computer,download this HTML page.Open it in your editor and in your browser!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Start a new React project"
                },
                {
                    "type": "p",
                    "text": "If you want to build an app or a website fully with React,start a new React project."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Add React to an existing project"
                },
                {
                    "type": "p",
                    "text": "If want to try using React in your existing app or a website,add React to an existing project."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Next steps"
                },
                {
                    "type": "p",
                    "text": "Head to theQuick Startguide for a tour of the most important React concepts you will encounter every day."
                }
            ]
        },
        {
            "url": "https://react.dev/learn/javascript-in-jsx-with-curly-braces",
            "title": "JavaScript in JSX with Curly Braces – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "JavaScript in JSX with Curly Braces"
                },
                {
                    "type": "p",
                    "text": "JSX lets you write HTML-like markup inside a JavaScript file, keeping rendering logic and content in the same place. Sometimes you will want to add a little JavaScript logic or reference a dynamic property inside that markup. In this situation, you can use curly braces in your JSX to open a window to JavaScript."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "How to pass strings with quotes",
                        "How to reference a JavaScript variable inside JSX with curly braces",
                        "How to call a JavaScript function inside JSX with curly braces",
                        "How to use a JavaScript object inside JSX with curly braces"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Passing strings with quotes"
                },
                {
                    "type": "p",
                    "text": "When you want to pass a string attribute to JSX, you put it in single or double quotes:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionAvatar(){return(<imgclassName=\"avatar\"src=\"https://i.imgur.com/7vQD0fPs.jpg\"alt=\"Gregorio Y. Zara\"/>);}"
                },
                {
                    "type": "p",
                    "text": "Here,\"https://i.imgur.com/7vQD0fPs.jpg\"and\"Gregorio Y. Zara\"are being passed as strings."
                },
                {
                    "type": "p",
                    "text": "But what if you want to dynamically specify thesrcoralttext? You coulduse a value from JavaScript by replacing\"and\"with{and}:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionAvatar(){constavatar='https://i.imgur.com/7vQD0fPs.jpg';constdescription='Gregorio Y. Zara';return(<imgclassName=\"avatar\"src={avatar}alt={description}/>);}"
                },
                {
                    "type": "p",
                    "text": "Notice the difference betweenclassName=\"avatar\", which specifies an\"avatar\"CSS class name that makes the image round, andsrc={avatar}that reads the value of the JavaScript variable calledavatar. That’s because curly braces let you work with JavaScript right there in your markup!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Using curly braces: A window into the JavaScript world"
                },
                {
                    "type": "p",
                    "text": "JSX is a special way of writing JavaScript. That means it’s possible to use JavaScript inside it—with curly braces{ }. The example below first declares a name for the scientist,name, then embeds it with curly braces inside the<h1>:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionTodoList(){constname='Gregorio Y. Zara';return(<h1>{name}'s To Do List</h1>);}"
                },
                {
                    "type": "p",
                    "text": "Try changing thename’s value from'Gregorio Y. Zara'to'Hedy Lamarr'. See how the list title changes?"
                },
                {
                    "type": "p",
                    "text": "Any JavaScript expression will work between curly braces, including function calls likeformatDate():"
                },
                {
                    "type": "code",
                    "code": "consttoday=newDate();functionformatDate(date){returnnewIntl.DateTimeFormat('en-US',{weekday:'long'}).format(date);}exportdefaultfunctionTodoList(){return(<h1>To Do List for{formatDate(today)}</h1>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Where to use curly braces"
                },
                {
                    "type": "p",
                    "text": "You can only use curly braces in two ways inside JSX:"
                },
                {
                    "type": "list",
                    "items": [
                        "As textdirectly inside a JSX tag:<h1>{name}'s To Do List</h1>works, but<{tag}>Gregorio Y. Zara's To Do List</{tag}>will not.",
                        "As attributesimmediately following the=sign:src={avatar}will read theavatarvariable, butsrc=\"{avatar}\"will pass the string\"{avatar}\"."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Using “double curlies”: CSS and other objects in JSX"
                },
                {
                    "type": "p",
                    "text": "In addition to strings, numbers, and other JavaScript expressions, you can even pass objects in JSX. Objects are also denoted with curly braces, like{ name: \"Hedy Lamarr\", inventions: 5 }. Therefore, to pass a JS object in JSX, you must wrap the object in another pair of curly braces:person={{ name: \"Hedy Lamarr\", inventions: 5 }}."
                },
                {
                    "type": "p",
                    "text": "You may see this with inline CSS styles in JSX. React does not require you to use inline styles (CSS classes work great for most cases). But when you need an inline style, you pass an object to thestyleattribute:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionTodoList(){return(<ulstyle={{backgroundColor:'black',color:'pink'}}><li>Improve the videophone</li><li>Prepare aeronautics lectures</li><li>Work on the alcohol-fuelled engine</li></ul>);}"
                },
                {
                    "type": "p",
                    "text": "Try changing the values ofbackgroundColorandcolor."
                },
                {
                    "type": "p",
                    "text": "You can really see the JavaScript object inside the curly braces when you write it like this:"
                },
                {
                    "type": "code",
                    "code": "<ulstyle={{backgroundColor:'black',color:'pink'}}>"
                },
                {
                    "type": "p",
                    "text": "The next time you see{{and}}in JSX, know that it’s nothing more than an object inside the JSX curlies!"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Inlinestyleproperties are written in camelCase. For example, HTML<ul style=\"background-color: black\">would be written as<ul style={{ backgroundColor: 'black' }}>in your component."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "More fun with JavaScript objects and curly braces"
                },
                {
                    "type": "p",
                    "text": "You can move several expressions into one object, and reference them in your JSX inside curly braces:"
                },
                {
                    "type": "code",
                    "code": "constperson={name:'Gregorio Y. Zara',theme:{backgroundColor:'black',color:'pink'}};exportdefaultfunctionTodoList(){return(<divstyle={person.theme}><h1>{person.name}'s Todos</h1><imgclassName=\"avatar\"src=\"https://i.imgur.com/7vQD0fPs.jpg\"alt=\"Gregorio Y. Zara\"/><ul><li>Improve the videophone</li><li>Prepare aeronautics lectures</li><li>Work on the alcohol-fuelled engine</li></ul></div>);}"
                },
                {
                    "type": "p",
                    "text": "In this example, thepersonJavaScript object contains anamestring and athemeobject:"
                },
                {
                    "type": "code",
                    "code": "constperson={name:'Gregorio Y. Zara',theme:{backgroundColor:'black',color:'pink'}};"
                },
                {
                    "type": "p",
                    "text": "The component can use these values frompersonlike so:"
                },
                {
                    "type": "code",
                    "code": "<divstyle={person.theme}><h1>{person.name}'s Todos</h1>"
                },
                {
                    "type": "p",
                    "text": "JSX is very minimal as a templating language because it lets you organize data and logic using JavaScript."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "p",
                    "text": "Now you know almost everything about JSX:"
                },
                {
                    "type": "list",
                    "items": [
                        "JSX attributes inside quotes are passed as strings.",
                        "Curly braces let you bring JavaScript logic and variables into your markup.",
                        "They work inside the JSX tag content or immediately after=in attributes.",
                        "{{and}}is not special syntax: it’s a JavaScript object tucked inside JSX curly braces."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of3:Fix the mistake"
                },
                {
                    "type": "p",
                    "text": "This code crashes with an error sayingObjects are not valid as a React child:"
                },
                {
                    "type": "code",
                    "code": "constperson={name:'Gregorio Y. Zara',theme:{backgroundColor:'black',color:'pink'}};exportdefaultfunctionTodoList(){return(<divstyle={person.theme}><h1>{person}'s Todos</h1><imgclassName=\"avatar\"src=\"https://i.imgur.com/7vQD0fPs.jpg\"alt=\"Gregorio Y. Zara\"/><ul><li>Improve the videophone</li><li>Prepare aeronautics lectures</li><li>Work on the alcohol-fuelled engine</li></ul></div>);}"
                },
                {
                    "type": "p",
                    "text": "Can you find the problem?"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/keeping-components-pure",
            "title": "Keeping Components Pure – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Keeping Components Pure"
                },
                {
                    "type": "p",
                    "text": "Some JavaScript functions arepure.Pure functions only perform a calculation and nothing more. By strictly only writing your components as pure functions, you can avoid an entire class of baffling bugs and unpredictable behavior as your codebase grows. To get these benefits, though, there are a few rules you must follow."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "What purity is and how it helps you avoid bugs",
                        "How to keep components pure by keeping changes out of the render phase",
                        "How to use Strict Mode to find mistakes in your components"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Purity: Components as formulas"
                },
                {
                    "type": "p",
                    "text": "In computer science (and especially the world of functional programming),a pure functionis a function with the following characteristics:"
                },
                {
                    "type": "list",
                    "items": [
                        "It minds its own business.It does not change any objects or variables that existed before it was called.",
                        "Same inputs, same output.Given the same inputs, a pure function should always return the same result."
                    ]
                },
                {
                    "type": "p",
                    "text": "You might already be familiar with one example of pure functions: formulas in math."
                },
                {
                    "type": "p",
                    "text": "Consider this math formula:y= 2x."
                },
                {
                    "type": "p",
                    "text": "Ifx= 2theny= 4. Always."
                },
                {
                    "type": "p",
                    "text": "Ifx= 3theny= 6. Always."
                },
                {
                    "type": "p",
                    "text": "Ifx= 3,ywon’t sometimes be9or–1or2.5depending on the time of day or the state of the stock market."
                },
                {
                    "type": "p",
                    "text": "Ify= 2xandx= 3,ywillalwaysbe6."
                },
                {
                    "type": "p",
                    "text": "If we made this into a JavaScript function, it would look like this:"
                },
                {
                    "type": "code",
                    "code": "functiondouble(number){return2*number;}"
                },
                {
                    "type": "p",
                    "text": "In the above example,doubleis apure function.If you pass it3, it will return6. Always."
                },
                {
                    "type": "p",
                    "text": "React is designed around this concept.React assumes that every component you write is a pure function.This means that React components you write must always return the same JSX given the same inputs:"
                },
                {
                    "type": "code",
                    "code": "functionRecipe({drinkers}){return(<ol><li>Boil{drinkers}cups of water.</li><li>Add{drinkers}spoons of tea and{0.5*drinkers}spoons of spice.</li><li>Add{0.5*drinkers}cups of milk to boil and sugar to taste.</li></ol>);}exportdefaultfunctionApp(){return(<section><h1>Spiced Chai Recipe</h1><h2>For two</h2><Recipedrinkers={2}/><h2>For a gathering</h2><Recipedrinkers={4}/></section>);}"
                },
                {
                    "type": "p",
                    "text": "When you passdrinkers={2}toRecipe, it will return JSX containing2 cups of water. Always."
                },
                {
                    "type": "p",
                    "text": "If you passdrinkers={4}, it will return JSX containing4 cups of water. Always."
                },
                {
                    "type": "p",
                    "text": "Just like a math formula."
                },
                {
                    "type": "p",
                    "text": "You could think of your components as recipes: if you follow them and don’t introduce new ingredients during the cooking process, you will get the same dish every time. That “dish” is the JSX that the component serves to React torender."
                },
                {
                    "type": "p",
                    "text": "Illustrated byRachel Lee Nabors"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Side Effects: (un)intended consequences"
                },
                {
                    "type": "p",
                    "text": "React’s rendering process must always be pure. Components should onlyreturntheir JSX, and notchangeany objects or variables that existed before rendering—that would make them impure!"
                },
                {
                    "type": "p",
                    "text": "Here is a component that breaks this rule:"
                },
                {
                    "type": "code",
                    "code": "letguest=0;functionCup(){// Bad: changing a preexisting variable!guest=guest+1;return<h2>Tea cup for guest #{guest}</h2>;}exportdefaultfunctionTeaSet(){return(<><Cup/><Cup/><Cup/></>);}"
                },
                {
                    "type": "p",
                    "text": "This component is reading and writing aguestvariable declared outside of it. This means thatcalling this component multiple times will produce different JSX!And what’s more, ifothercomponents readguest, they will produce different JSX, too, depending on when they were rendered! That’s not predictable."
                },
                {
                    "type": "p",
                    "text": "Going back to our formulay= 2x, now even ifx= 2, we cannot trust thaty= 4. Our tests could fail, our users would be baffled, planes would fall out of the sky—you can see how this would lead to confusing bugs!"
                },
                {
                    "type": "p",
                    "text": "You can fix this component bypassingguestas a prop instead:"
                },
                {
                    "type": "code",
                    "code": "functionCup({guest}){return<h2>Tea cup for guest #{guest}</h2>;}exportdefaultfunctionTeaSet(){return(<><Cupguest={1}/><Cupguest={2}/><Cupguest={3}/></>);}"
                },
                {
                    "type": "p",
                    "text": "Now your component is pure, as the JSX it returns only depends on theguestprop."
                },
                {
                    "type": "p",
                    "text": "In general, you should not expect your components to be rendered in any particular order. It doesn’t matter if you cally= 2xbefore or aftery= 5x: both formulas will resolve independently of each other. In the same way, each component should only “think for itself”, and not attempt to coordinate with or depend upon others during rendering. Rendering is like a school exam: each component should calculate JSX on their own!"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Detecting impure calculations with StrictMode"
                },
                {
                    "type": "p",
                    "text": "Although you might not have used them all yet, in React there are three kinds of inputs that you can read while rendering:props,state, andcontext.You should always treat these inputs as read-only."
                },
                {
                    "type": "p",
                    "text": "When you want tochangesomething in response to user input, you shouldset stateinstead of writing to a variable. You should never change preexisting variables or objects while your component is rendering."
                },
                {
                    "type": "p",
                    "text": "React offers a “Strict Mode” in which it calls each component’s function twice during development.By calling the component functions twice, Strict Mode helps find components that break these rules."
                },
                {
                    "type": "p",
                    "text": "Notice how the original example displayed “Guest #2”, “Guest #4”, and “Guest #6” instead of “Guest #1”, “Guest #2”, and “Guest #3”. The original function was impure, so calling it twice broke it. But the fixed pure version works even if the function is called twice every time.Pure functions only calculate, so calling them twice won’t change anything—just like callingdouble(2)twice doesn’t change what’s returned, and solvingy= 2xtwice doesn’t change whatyis. Same inputs, same outputs. Always."
                },
                {
                    "type": "p",
                    "text": "Strict Mode has no effect in production, so it won’t slow down the app for your users. To opt into Strict Mode, you can wrap your root component into<React.StrictMode>. Some frameworks do this by default."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Local mutation: Your component’s little secret"
                },
                {
                    "type": "p",
                    "text": "In the above example, the problem was that the component changed apreexistingvariable while rendering. This is often called a“mutation”to make it sound a bit scarier. Pure functions don’t mutate variables outside of the function’s scope or objects that were created before the call—that makes them impure!"
                },
                {
                    "type": "p",
                    "text": "However,it’s completely fine to change variables and objects that you’vejustcreated while rendering.In this example, you create an[]array, assign it to acupsvariable, and thenpusha dozen cups into it:"
                },
                {
                    "type": "code",
                    "code": "functionCup({guest}){return<h2>Tea cup for guest #{guest}</h2>;}exportdefaultfunctionTeaGathering(){letcups=[];for(leti=1;i<=12;i++){cups.push(<Cupkey={i}guest={i}/>);}returncups;}"
                },
                {
                    "type": "p",
                    "text": "If thecupsvariable or the[]array were created outside theTeaGatheringfunction, this would be a huge problem! You would be changing apreexistingobject by pushing items into that array."
                },
                {
                    "type": "p",
                    "text": "However, it’s fine because you’ve created themduring the same render, insideTeaGathering. No code outside ofTeaGatheringwill ever know that this happened. This is called“local mutation”—it’s like your component’s little secret."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Where youcancause side effects"
                },
                {
                    "type": "p",
                    "text": "While functional programming relies heavily on purity, at some point, somewhere,somethinghas to change. That’s kind of the point of programming! These changes—updating the screen, starting an animation, changing the data—are calledside effects.They’re things that happen“on the side”, not during rendering."
                },
                {
                    "type": "p",
                    "text": "In React,side effects usually belong insideevent handlers.Event handlers are functions that React runs when you perform some action—for example, when you click a button. Even though event handlers are definedinsideyour component, they don’t runduringrendering!So event handlers don’t need to be pure."
                },
                {
                    "type": "p",
                    "text": "If you’ve exhausted all other options and can’t find the right event handler for your side effect, you can still attach it to your returned JSX with auseEffectcall in your component. This tells React to execute it later, after rendering, when side effects are allowed.However, this approach should be your last resort."
                },
                {
                    "type": "p",
                    "text": "When possible, try to express your logic with rendering alone. You’ll be surprised how far this can take you!"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Why does React care about purity?"
                },
                {
                    "type": "p",
                    "text": "Writing pure functions takes some habit and discipline. But it also unlocks marvelous opportunities:"
                },
                {
                    "type": "list",
                    "items": [
                        "Your components could run in a different environment—for example, on the server! Since they return the same result for the same inputs, one component can serve many user requests.",
                        "You can improve performance byskipping renderingcomponents whose inputs have not changed. This is safe because pure functions always return the same results, so they are safe to cache.",
                        "If some data changes in the middle of rendering a deep component tree, React can restart rendering without wasting time to finish the outdated render. Purity makes it safe to stop calculating at any time."
                    ]
                },
                {
                    "type": "p",
                    "text": "Every new React feature we’re building takes advantage of purity. From data fetching to animations to performance, keeping components pure unlocks the power of the React paradigm."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "A component must be pure, meaning:It minds its own business.It should not change any objects or variables that existed before rendering.Same inputs, same output.Given the same inputs, a component should always return the same JSX.",
                        "It minds its own business.It should not change any objects or variables that existed before rendering.",
                        "Same inputs, same output.Given the same inputs, a component should always return the same JSX.",
                        "Rendering can happen at any time, so components should not depend on each others’ rendering sequence.",
                        "You should not mutate any of the inputs that your components use for rendering. That includes props, state, and context. To update the screen,“set” stateinstead of mutating preexisting objects.",
                        "Strive to express your component’s logic in the JSX you return. When you need to “change things”, you’ll usually want to do it in an event handler. As a last resort, you canuseEffect.",
                        "Writing pure functions takes a bit of practice, but it unlocks the power of React’s paradigm."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "It minds its own business.It should not change any objects or variables that existed before rendering.",
                        "Same inputs, same output.Given the same inputs, a component should always return the same JSX."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of3:Fix a broken clock"
                },
                {
                    "type": "p",
                    "text": "This component tries to set the<h1>’s CSS class to\"night\"during the time from midnight to six hours in the morning, and\"day\"at all other times. However, it doesn’t work. Can you fix this component?"
                },
                {
                    "type": "p",
                    "text": "You can verify whether your solution works by temporarily changing the computer’s timezone. When the current time is between midnight and six in the morning, the clock should have inverted colors!"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionClock({time}){lethours=time.getHours();if(hours>=0&&hours<=6){document.getElementById('time').className='night';}else{document.getElementById('time').className='day';}return(<h1id=\"time\">{time.toLocaleTimeString()}</h1>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/lifecycle-of-reactive-effects",
            "title": "Lifecycle of Reactive Effects – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Lifecycle of Reactive Effects"
                },
                {
                    "type": "p",
                    "text": "Effects have a different lifecycle from components. Components may mount, update, or unmount. An Effect can only do two things: to start synchronizing something, and later to stop synchronizing it. This cycle can happen multiple times if your Effect depends on props and state that change over time. React provides a linter rule to check that you’ve specified your Effect’s dependencies correctly. This keeps your Effect synchronized to the latest props and state."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "How an Effect’s lifecycle is different from a component’s lifecycle",
                        "How to think about each individual Effect in isolation",
                        "When your Effect needs to re-synchronize, and why",
                        "How your Effect’s dependencies are determined",
                        "What it means for a value to be reactive",
                        "What an empty dependency array means",
                        "How React verifies your dependencies are correct with a linter",
                        "What to do when you disagree with the linter"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "The lifecycle of an Effect"
                },
                {
                    "type": "p",
                    "text": "Every React component goes through the same lifecycle:"
                },
                {
                    "type": "list",
                    "items": [
                        "A componentmountswhen it’s added to the screen.",
                        "A componentupdateswhen it receives new props or state, usually in response to an interaction.",
                        "A componentunmountswhen it’s removed from the screen."
                    ]
                },
                {
                    "type": "p",
                    "text": "It’s a good way to think about components, butnotabout Effects.Instead, try to think about each Effect independently from your component’s lifecycle. An Effect describes how tosynchronize an external systemto the current props and state. As your code changes, synchronization will need to happen more or less often."
                },
                {
                    "type": "p",
                    "text": "To illustrate this point, consider this Effect connecting your component to a chat server:"
                },
                {
                    "type": "code",
                    "code": "constserverUrl='https://localhost:1234';functionChatRoom({roomId}){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{connection.disconnect();};},[roomId]);// ...}"
                },
                {
                    "type": "p",
                    "text": "Your Effect’s body specifies how tostart synchronizing:"
                },
                {
                    "type": "code",
                    "code": "// ...constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{connection.disconnect();};// ..."
                },
                {
                    "type": "p",
                    "text": "The cleanup function returned by your Effect specifies how tostop synchronizing:"
                },
                {
                    "type": "code",
                    "code": "// ...constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{connection.disconnect();};// ..."
                },
                {
                    "type": "p",
                    "text": "Intuitively, you might think that React wouldstart synchronizingwhen your component mounts andstop synchronizingwhen your component unmounts. However, this is not the end of the story! Sometimes, it may also be necessary tostart and stop synchronizing multiple timeswhile the component remains mounted."
                },
                {
                    "type": "p",
                    "text": "Let’s look atwhythis is necessary,whenit happens, andhowyou can control this behavior."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Some Effects don’t return a cleanup function at all.More often than not,you’ll want to return one—but if you don’t, React will behave as if you returned an empty cleanup function."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Why synchronization may need to happen more than once"
                },
                {
                    "type": "p",
                    "text": "Imagine thisChatRoomcomponent receives aroomIdprop that the user picks in a dropdown. Let’s say that initially the user picks the\"general\"room as theroomId. Your app displays the\"general\"chat room:"
                },
                {
                    "type": "code",
                    "code": "constserverUrl='https://localhost:1234';functionChatRoom({roomId/* \"general\" */}){// ...return<h1>Welcome to the{roomId}room!</h1>;}"
                },
                {
                    "type": "p",
                    "text": "After the UI is displayed, React will run your Effect tostart synchronizing.It connects to the\"general\"room:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId/* \"general\" */}){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);// Connects to the \"general\" roomconnection.connect();return()=>{connection.disconnect();// Disconnects from the \"general\" room};},[roomId]);// ..."
                },
                {
                    "type": "p",
                    "text": "So far, so good."
                },
                {
                    "type": "p",
                    "text": "Later, the user picks a different room in the dropdown (for example,\"travel\"). First, React will update the UI:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId/* \"travel\" */}){// ...return<h1>Welcome to the{roomId}room!</h1>;}"
                },
                {
                    "type": "p",
                    "text": "Think about what should happen next. The user sees that\"travel\"is the selected chat room in the UI. However, the Effect that ran the last time is still connected to the\"general\"room.TheroomIdprop has changed, so what your Effect did back then (connecting to the\"general\"room) no longer matches the UI."
                },
                {
                    "type": "p",
                    "text": "At this point, you want React to do two things:"
                },
                {
                    "type": "list",
                    "items": [
                        "Stop synchronizing with the oldroomId(disconnect from the\"general\"room)",
                        "Start synchronizing with the newroomId(connect to the\"travel\"room)"
                    ]
                },
                {
                    "type": "p",
                    "text": "Luckily, you’ve already taught React how to do both of these things!Your Effect’s body specifies how to start synchronizing, and your cleanup function specifies how to stop synchronizing. All that React needs to do now is to call them in the correct order and with the correct props and state. Let’s see how exactly that happens."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "How React re-synchronizes your Effect"
                },
                {
                    "type": "p",
                    "text": "Recall that yourChatRoomcomponent has received a new value for itsroomIdprop. It used to be\"general\", and now it is\"travel\". React needs to re-synchronize your Effect to re-connect you to a different room."
                },
                {
                    "type": "p",
                    "text": "Tostop synchronizing,React will call the cleanup function that your Effect returned after connecting to the\"general\"room. SinceroomIdwas\"general\", the cleanup function disconnects from the\"general\"room:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId/* \"general\" */}){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);// Connects to the \"general\" roomconnection.connect();return()=>{connection.disconnect();// Disconnects from the \"general\" room};// ..."
                },
                {
                    "type": "p",
                    "text": "Then React will run the Effect that you’ve provided during this render. This time,roomIdis\"travel\"so it willstart synchronizingto the\"travel\"chat room (until its cleanup function is eventually called too):"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId/* \"travel\" */}){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);// Connects to the \"travel\" roomconnection.connect();// ..."
                },
                {
                    "type": "p",
                    "text": "Thanks to this, you’re now connected to the same room that the user chose in the UI. Disaster averted!"
                },
                {
                    "type": "p",
                    "text": "Every time after your component re-renders with a differentroomId, your Effect will re-synchronize. For example, let’s say the user changesroomIdfrom\"travel\"to\"music\". React will againstop synchronizingyour Effect by calling its cleanup function (disconnecting you from the\"travel\"room). Then it willstart synchronizingagain by running its body with the newroomIdprop (connecting you to the\"music\"room)."
                },
                {
                    "type": "p",
                    "text": "Finally, when the user goes to a different screen,ChatRoomunmounts. Now there is no need to stay connected at all. React willstop synchronizingyour Effect one last time and disconnect you from the\"music\"chat room."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Thinking from the Effect’s perspective"
                },
                {
                    "type": "p",
                    "text": "Let’s recap everything that’s happened from theChatRoomcomponent’s perspective:"
                },
                {
                    "type": "list",
                    "items": [
                        "ChatRoommounted withroomIdset to\"general\"",
                        "ChatRoomupdated withroomIdset to\"travel\"",
                        "ChatRoomupdated withroomIdset to\"music\"",
                        "ChatRoomunmounted"
                    ]
                },
                {
                    "type": "p",
                    "text": "During each of these points in the component’s lifecycle, your Effect did different things:"
                },
                {
                    "type": "list",
                    "items": [
                        "Your Effect connected to the\"general\"room",
                        "Your Effect disconnected from the\"general\"room and connected to the\"travel\"room",
                        "Your Effect disconnected from the\"travel\"room and connected to the\"music\"room",
                        "Your Effect disconnected from the\"music\"room"
                    ]
                },
                {
                    "type": "p",
                    "text": "Now let’s think about what happened from the perspective of the Effect itself:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{// Your Effect connected to the room specified with roomId...constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{// ...until it disconnectedconnection.disconnect();};},[roomId]);"
                },
                {
                    "type": "p",
                    "text": "This code’s structure might inspire you to see what happened as a sequence of non-overlapping time periods:"
                },
                {
                    "type": "list",
                    "items": [
                        "Your Effect connected to the\"general\"room (until it disconnected)",
                        "Your Effect connected to the\"travel\"room (until it disconnected)",
                        "Your Effect connected to the\"music\"room (until it disconnected)"
                    ]
                },
                {
                    "type": "p",
                    "text": "Previously, you were thinking from the component’s perspective. When you looked from the component’s perspective, it was tempting to think of Effects as “callbacks” or “lifecycle events” that fire at a specific time like “after a render” or “before unmount”. This way of thinking gets complicated very fast, so it’s best to avoid."
                },
                {
                    "type": "p",
                    "text": "Instead, always focus on a single start/stop cycle at a time. It shouldn’t matter whether a component is mounting, updating, or unmounting. All you need to do is to describe how to start synchronization and how to stop it. If you do it well, your Effect will be resilient to being started and stopped as many times as it’s needed."
                },
                {
                    "type": "p",
                    "text": "This might remind you how you don’t think whether a component is mounting or updating when you write the rendering logic that creates JSX. You describe what should be on the screen, and Reactfigures out the rest."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "How React verifies that your Effect can re-synchronize"
                },
                {
                    "type": "p",
                    "text": "Here is a live example that you can play with. Press “Open chat” to mount theChatRoomcomponent:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection}from'./chat.js';constserverUrl='https://localhost:1234';functionChatRoom({roomId}){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>connection.disconnect();},[roomId]);return<h1>Welcome to the{roomId}room!</h1>;}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');const[show,setShow]=useState(false);return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><buttononClick={()=>setShow(!show)}>{show?'Close chat':'Open chat'}</button>{show&&<hr/>}{show&&<ChatRoomroomId={roomId}/>}</>);}"
                },
                {
                    "type": "p",
                    "text": "Notice that when the component mounts for the first time, you see three logs:"
                },
                {
                    "type": "list",
                    "items": [
                        "✅ Connecting to \"general\" room at https://localhost:1234...(development-only)",
                        "❌ Disconnected from \"general\" room at https://localhost:1234.(development-only)",
                        "✅ Connecting to \"general\" room at https://localhost:1234..."
                    ]
                },
                {
                    "type": "p",
                    "text": "The first two logs are development-only. In development, React always remounts each component once."
                },
                {
                    "type": "p",
                    "text": "React verifies that your Effect can re-synchronize by forcing it to do that immediately in development.This might remind you of opening a door and closing it an extra time to check if the door lock works. React starts and stops your Effect one extra time in development to checkyou’ve implemented its cleanup well."
                },
                {
                    "type": "p",
                    "text": "The main reason your Effect will re-synchronize in practice is if some data it uses has changed. In the sandbox above, change the selected chat room. Notice how, when theroomIdchanges, your Effect re-synchronizes."
                },
                {
                    "type": "p",
                    "text": "However, there are also more unusual cases in which re-synchronization is necessary. For example, try editing theserverUrlin the sandbox above while the chat is open. Notice how the Effect re-synchronizes in response to your edits to the code. In the future, React may add more features that rely on re-synchronization."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "How React knows that it needs to re-synchronize the Effect"
                },
                {
                    "type": "p",
                    "text": "You might be wondering how React knew that your Effect needed to re-synchronize afterroomIdchanges. It’s becauseyou told Reactthat its code depends onroomIdby including it in thelist of dependencies:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){// The roomId prop may change over timeuseEffect(()=>{constconnection=createConnection(serverUrl,roomId);// This Effect reads roomIdconnection.connect();return()=>{connection.disconnect();};},[roomId]);// So you tell React that this Effect \"depends on\" roomId// ..."
                },
                {
                    "type": "p",
                    "text": "Here’s how this works:"
                },
                {
                    "type": "list",
                    "items": [
                        "You knewroomIdis a prop, which means it can change over time.",
                        "You knew that your Effect readsroomId(so its logic depends on a value that may change later).",
                        "This is why you specified it as your Effect’s dependency (so that it re-synchronizes whenroomIdchanges)."
                    ]
                },
                {
                    "type": "p",
                    "text": "Every time after your component re-renders, React will look at the array of dependencies that you have passed. If any of the values in the array is different from the value at the same spot that you passed during the previous render, React will re-synchronize your Effect."
                },
                {
                    "type": "p",
                    "text": "For example, if you passed[\"general\"]during the initial render, and later you passed[\"travel\"]during the next render, React will compare\"general\"and\"travel\". These are different values (compared withObject.is), so React will re-synchronize your Effect. On the other hand, if your component re-renders butroomIdhas not changed, your Effect will remain connected to the same room."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Each Effect represents a separate synchronization process"
                },
                {
                    "type": "p",
                    "text": "Resist adding unrelated logic to your Effect only because this logic needs to run at the same time as an Effect you already wrote. For example, let’s say you want to send an analytics event when the user visits the room. You already have an Effect that depends onroomId, so you might feel tempted to add the analytics call there:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){useEffect(()=>{logVisit(roomId);constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{connection.disconnect();};},[roomId]);// ...}"
                },
                {
                    "type": "p",
                    "text": "But imagine you later add another dependency to this Effect that needs to re-establish the connection. If this Effect re-synchronizes, it will also calllogVisit(roomId)for the same room, which you did not intend. Logging the visitis a separate processfrom connecting. Write them as two separate Effects:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){useEffect(()=>{logVisit(roomId);},[roomId]);useEffect(()=>{constconnection=createConnection(serverUrl,roomId);// ...},[roomId]);// ...}"
                },
                {
                    "type": "p",
                    "text": "Each Effect in your code should represent a separate and independent synchronization process."
                },
                {
                    "type": "p",
                    "text": "In the above example, deleting one Effect wouldn’t break the other Effect’s logic. This is a good indication that they synchronize different things, and so it made sense to split them up. On the other hand, if you split up a cohesive piece of logic into separate Effects, the code may look “cleaner” but will bemore difficult to maintain.This is why you should think whether the processes are same or separate, not whether the code looks cleaner."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Effects “react” to reactive values"
                },
                {
                    "type": "p",
                    "text": "Your Effect reads two variables (serverUrlandroomId), but you only specifiedroomIdas a dependency:"
                },
                {
                    "type": "code",
                    "code": "constserverUrl='https://localhost:1234';functionChatRoom({roomId}){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{connection.disconnect();};},[roomId]);// ...}"
                },
                {
                    "type": "p",
                    "text": "Why doesn’tserverUrlneed to be a dependency?"
                },
                {
                    "type": "p",
                    "text": "This is because theserverUrlnever changes due to a re-render. It’s always the same no matter how many times the component re-renders and why. SinceserverUrlnever changes, it wouldn’t make sense to specify it as a dependency. After all, dependencies only do something when they change over time!"
                },
                {
                    "type": "p",
                    "text": "On the other hand,roomIdmay be different on a re-render.Props, state, and other values declared inside the component arereactivebecause they’re calculated during rendering and participate in the React data flow."
                },
                {
                    "type": "p",
                    "text": "IfserverUrlwas a state variable, it would be reactive. Reactive values must be included in dependencies:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){// Props change over timeconst[serverUrl,setServerUrl]=useState('https://localhost:1234');// State may change over timeuseEffect(()=>{constconnection=createConnection(serverUrl,roomId);// Your Effect reads props and stateconnection.connect();return()=>{connection.disconnect();};},[roomId,serverUrl]);// So you tell React that this Effect \"depends on\" on props and state// ...}"
                },
                {
                    "type": "p",
                    "text": "By includingserverUrlas a dependency, you ensure that the Effect re-synchronizes after it changes."
                },
                {
                    "type": "p",
                    "text": "Try changing the selected chat room or edit the server URL in this sandbox:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection}from'./chat.js';functionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>connection.disconnect();},[roomId,serverUrl]);return(<><label>Server URL:{' '}<inputvalue={serverUrl}onChange={e=>setServerUrl(e.target.value)}/></label><h1>Welcome to the{roomId}room!</h1></>);}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><hr/><ChatRoomroomId={roomId}/></>);}"
                },
                {
                    "type": "p",
                    "text": "Whenever you change a reactive value likeroomIdorserverUrl, the Effect re-connects to the chat server."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "What an Effect with empty dependencies means"
                },
                {
                    "type": "p",
                    "text": "What happens if you move bothserverUrlandroomIdoutside the component?"
                },
                {
                    "type": "code",
                    "code": "constserverUrl='https://localhost:1234';constroomId='general';functionChatRoom(){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{connection.disconnect();};},[]);// ✅ All dependencies declared// ...}"
                },
                {
                    "type": "p",
                    "text": "Now your Effect’s code does not useanyreactive values, so its dependencies can be empty ([])."
                },
                {
                    "type": "p",
                    "text": "Thinking from the component’s perspective, the empty[]dependency array means this Effect connects to the chat room only when the component mounts, and disconnects only when the component unmounts. (Keep in mind that React would stillre-synchronize it an extra timein development to stress-test your logic.)"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection}from'./chat.js';constserverUrl='https://localhost:1234';constroomId='general';functionChatRoom(){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>connection.disconnect();},[]);return<h1>Welcome to the{roomId}room!</h1>;}exportdefaultfunctionApp(){const[show,setShow]=useState(false);return(<><buttononClick={()=>setShow(!show)}>{show?'Close chat':'Open chat'}</button>{show&&<hr/>}{show&&<ChatRoom/>}</>);}"
                },
                {
                    "type": "p",
                    "text": "However, if youthink from the Effect’s perspective,you don’t need to think about mounting and unmounting at all. What’s important is you’ve specified what your Effect does to start and stop synchronizing. Today, it has no reactive dependencies. But if you ever want the user to changeroomIdorserverUrlover time (and they would become reactive), your Effect’s code won’t change. You will only need to add them to the dependencies."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "All variables declared in the component body are reactive"
                },
                {
                    "type": "p",
                    "text": "Props and state aren’t the only reactive values. Values that you calculate from them are also reactive. If the props or state change, your component will re-render, and the values calculated from them will also change. This is why all variables from the component body used by the Effect should be in the Effect dependency list."
                },
                {
                    "type": "p",
                    "text": "Let’s say that the user can pick a chat server in the dropdown, but they can also configure a default server in settings. Suppose you’ve already put the settings state in acontextso you read thesettingsfrom that context. Now you calculate theserverUrlbased on the selected server from props and the default server:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId,selectedServerUrl}){// roomId is reactiveconstsettings=useContext(SettingsContext);// settings is reactiveconstserverUrl=selectedServerUrl??settings.defaultServerUrl;// serverUrl is reactiveuseEffect(()=>{constconnection=createConnection(serverUrl,roomId);// Your Effect reads roomId and serverUrlconnection.connect();return()=>{connection.disconnect();};},[roomId,serverUrl]);// So it needs to re-synchronize when either of them changes!// ...}"
                },
                {
                    "type": "p",
                    "text": "In this example,serverUrlis not a prop or a state variable. It’s a regular variable that you calculate during rendering. But it’s calculated during rendering, so it can change due to a re-render. This is why it’s reactive."
                },
                {
                    "type": "p",
                    "text": "All values inside the component (including props, state, and variables in your component’s body) are reactive. Any reactive value can change on a re-render, so you need to include reactive values as Effect’s dependencies."
                },
                {
                    "type": "p",
                    "text": "In other words, Effects “react” to all values from the component body."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Can global or mutable values be dependencies?"
                },
                {
                    "type": "p",
                    "text": "Mutable values (including global variables) aren’t reactive."
                },
                {
                    "type": "p",
                    "text": "A mutable value likelocation.pathnamecan’t be a dependency.It’s mutable, so it can change at any time completely outside of the React rendering data flow. Changing it wouldn’t trigger a re-render of your component. Therefore, even if you specified it in the dependencies, Reactwouldn’t knowto re-synchronize the Effect when it changes. This also breaks the rules of React because reading mutable data during rendering (which is when you calculate the dependencies) breakspurity of rendering.Instead, you should read and subscribe to an external mutable value withuseSyncExternalStore."
                },
                {
                    "type": "p",
                    "text": "A mutable value likeref.currentor things you read from it also can’t be a dependency.The ref object returned byuseRefitself can be a dependency, but itscurrentproperty is intentionally mutable. It lets youkeep track of something without triggering a re-render.But since changing it doesn’t trigger a re-render, it’s not a reactive value, and React won’t know to re-run your Effect when it changes."
                },
                {
                    "type": "p",
                    "text": "As you’ll learn below on this page, a linter will check for these issues automatically."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "React verifies that you specified every reactive value as a dependency"
                },
                {
                    "type": "p",
                    "text": "If your linter isconfigured for React,it will check that every reactive value used by your Effect’s code is declared as its dependency. For example, this is a lint error because bothroomIdandserverUrlare reactive:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection}from'./chat.js';functionChatRoom({roomId}){// roomId is reactiveconst[serverUrl,setServerUrl]=useState('https://localhost:1234');// serverUrl is reactiveuseEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>connection.disconnect();},[]);// <-- Something's wrong here!return(<><label>Server URL:{' '}<inputvalue={serverUrl}onChange={e=>setServerUrl(e.target.value)}/></label><h1>Welcome to the{roomId}room!</h1></>);}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><hr/><ChatRoomroomId={roomId}/></>);}"
                },
                {
                    "type": "p",
                    "text": "This may look like a React error, but really React is pointing out a bug in your code. BothroomIdandserverUrlmay change over time, but you’re forgetting to re-synchronize your Effect when they change. You will remain connected to the initialroomIdandserverUrleven after the user picks different values in the UI."
                },
                {
                    "type": "p",
                    "text": "To fix the bug, follow the linter’s suggestion to specifyroomIdandserverUrlas dependencies of your Effect:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){// roomId is reactiveconst[serverUrl,setServerUrl]=useState('https://localhost:1234');// serverUrl is reactiveuseEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{connection.disconnect();};},[serverUrl,roomId]);// ✅ All dependencies declared// ...}"
                },
                {
                    "type": "p",
                    "text": "Try this fix in the sandbox above. Verify that the linter error is gone, and the chat re-connects when needed."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "In some cases, Reactknowsthat a value never changes even though it’s declared inside the component. For example, thesetfunctionreturned fromuseStateand the ref object returned byuseRefarestable—they are guaranteed to not change on a re-render. Stable values aren’t reactive, so you may omit them from the list. Including them is allowed: they won’t change, so it doesn’t matter."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "What to do when you don’t want to re-synchronize"
                },
                {
                    "type": "p",
                    "text": "In the previous example, you’ve fixed the lint error by listingroomIdandserverUrlas dependencies."
                },
                {
                    "type": "p",
                    "text": "However, you could instead “prove” to the linter that these values aren’t reactive values,i.e. that theycan’tchange as a result of a re-render. For example, ifserverUrlandroomIddon’t depend on rendering and always have the same values, you can move them outside the component. Now they don’t need to be dependencies:"
                },
                {
                    "type": "code",
                    "code": "constserverUrl='https://localhost:1234';// serverUrl is not reactiveconstroomId='general';// roomId is not reactivefunctionChatRoom(){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{connection.disconnect();};},[]);// ✅ All dependencies declared// ...}"
                },
                {
                    "type": "p",
                    "text": "You can also move theminside the Effect.They aren’t calculated during rendering, so they’re not reactive:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom(){useEffect(()=>{constserverUrl='https://localhost:1234';// serverUrl is not reactiveconstroomId='general';// roomId is not reactiveconstconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{connection.disconnect();};},[]);// ✅ All dependencies declared// ...}"
                },
                {
                    "type": "p",
                    "text": "Effects are reactive blocks of code.They re-synchronize when the values you read inside of them change. Unlike event handlers, which only run once per interaction, Effects run whenever synchronization is necessary."
                },
                {
                    "type": "p",
                    "text": "You can’t “choose” your dependencies.Your dependencies must include everyreactive valueyou read in the Effect. The linter enforces this. Sometimes this may lead to problems like infinite loops and to your Effect re-synchronizing too often. Don’t fix these problems by suppressing the linter! Here’s what to try instead:"
                },
                {
                    "type": "list",
                    "items": [
                        "Check that your Effect represents an independent synchronization process.If your Effect doesn’t synchronize anything,it might be unnecessary.If it synchronizes several independent things,split it up.",
                        "If you want to read the latest value of props or state without “reacting” to it and re-synchronizing the Effect,you can split your Effect into a reactive part (which you’ll keep in the Effect) and a non-reactive part (which you’ll extract into something called anEffect Event).Read about separating Events from Effects.",
                        "Avoid relying on objects and functions as dependencies.If you create objects and functions during rendering and then read them from an Effect, they will be different on every render. This will cause your Effect to re-synchronize every time.Read more about removing unnecessary dependencies from Effects."
                    ]
                },
                {
                    "type": "p",
                    "text": "Check that your Effect represents an independent synchronization process.If your Effect doesn’t synchronize anything,it might be unnecessary.If it synchronizes several independent things,split it up."
                },
                {
                    "type": "p",
                    "text": "If you want to read the latest value of props or state without “reacting” to it and re-synchronizing the Effect,you can split your Effect into a reactive part (which you’ll keep in the Effect) and a non-reactive part (which you’ll extract into something called anEffect Event).Read about separating Events from Effects."
                },
                {
                    "type": "p",
                    "text": "Avoid relying on objects and functions as dependencies.If you create objects and functions during rendering and then read them from an Effect, they will be different on every render. This will cause your Effect to re-synchronize every time.Read more about removing unnecessary dependencies from Effects."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "The linter is your friend, but its powers are limited. The linter only knows when the dependencies arewrong. It doesn’t knowthe bestway to solve each case. If the linter suggests a dependency, but adding it causes a loop, it doesn’t mean the linter should be ignored. You need to change the code inside (or outside) the Effect so that that value isn’t reactive and doesn’tneedto be a dependency."
                },
                {
                    "type": "p",
                    "text": "If you have an existing codebase, you might have some Effects that suppress the linter like this:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{// ...// 🔴 Avoid suppressing the linter like this:// eslint-ignore-next-line react-hooks/exhaustive-deps},[]);"
                },
                {
                    "type": "p",
                    "text": "On thenextpages, you’ll learn how to fix this code without breaking the rules. It’s always worth fixing!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "Components can mount, update, and unmount.",
                        "Each Effect has a separate lifecycle from the surrounding component.",
                        "Each Effect describes a separate synchronization process that canstartandstop.",
                        "When you write and read Effects, think from each individual Effect’s perspective (how to start and stop synchronization) rather than from the component’s perspective (how it mounts, updates, or unmounts).",
                        "Values declared inside the component body are “reactive”.",
                        "Reactive values should re-synchronize the Effect because they can change over time.",
                        "The linter verifies that all reactive values used inside the Effect are specified as dependencies.",
                        "All errors flagged by the linter are legitimate. There’s always a way to fix the code to not break the rules."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of5:Fix reconnecting on every keystroke"
                },
                {
                    "type": "p",
                    "text": "In this example, theChatRoomcomponent connects to the chat room when the component mounts, disconnects when it unmounts, and reconnects when you select a different chat room. This behavior is correct, so you need to keep it working."
                },
                {
                    "type": "p",
                    "text": "However, there is a problem. Whenever you type into the message box input at the bottom,ChatRoomalsoreconnects to the chat. (You can notice this by clearing the console and typing into the input.) Fix the issue so that this doesn’t happen."
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection}from'./chat.js';constserverUrl='https://localhost:1234';functionChatRoom({roomId}){const[message,setMessage]=useState('');useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>connection.disconnect();});return(<><h1>Welcome to the{roomId}room!</h1><inputvalue={message}onChange={e=>setMessage(e.target.value)}/></>);}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><hr/><ChatRoomroomId={roomId}/></>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/managing-state",
            "title": "Managing State – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Managing State"
                },
                {
                    "type": "p",
                    "text": "As your application grows, it helps to be more intentional about how your state is organized and how the data flows between your components. Redundant or duplicate state is a common source of bugs. In this chapter, you’ll learn how to structure your state well, how to keep your state update logic maintainable, and how to share state between distant components."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "In this chapter"
                },
                {
                    "type": "list",
                    "items": [
                        "How to think about UI changes as state changes",
                        "How to structure state well",
                        "How to “lift state up” to share it between components",
                        "How to control whether the state gets preserved or reset",
                        "How to consolidate complex state logic in a function",
                        "How to pass information without “prop drilling”",
                        "How to scale state management as your app grows"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reacting to input with state"
                },
                {
                    "type": "p",
                    "text": "With React, you won’t modify the UI from code directly. For example, you won’t write commands like “disable the button”, “enable the button”, “show the success message”, etc. Instead, you will describe the UI you want to see for the different visual states of your component (“initial state”, “typing state”, “success state”), and then trigger the state changes in response to user input. This is similar to how designers think about UI."
                },
                {
                    "type": "p",
                    "text": "Here is a quiz form built using React. Note how it uses thestatusstate variable to determine whether to enable or disable the submit button, and whether to show the success message instead."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionForm(){const[answer,setAnswer]=useState('');const[error,setError]=useState(null);const[status,setStatus]=useState('typing');if(status==='success'){return<h1>That's right!</h1>}asyncfunctionhandleSubmit(e){e.preventDefault();setStatus('submitting');try{awaitsubmitForm(answer);setStatus('success');}catch(err){setStatus('typing');setError(err);}}functionhandleTextareaChange(e){setAnswer(e.target.value);}return(<><h2>City quiz</h2><p>In which city is there a billboard that turns air into drinkable water?</p><formonSubmit={handleSubmit}><textareavalue={answer}onChange={handleTextareaChange}disabled={status==='submitting'}/><br/><buttondisabled={answer.length===0||status==='submitting'}>Submit</button>{error!==null&&<pclassName=\"Error\">{error.message}</p>}</form></>);}functionsubmitForm(answer){// Pretend it's hitting the network.returnnewPromise((resolve,reject)=>{setTimeout(()=>{letshouldError=answer.toLowerCase()!=='lima'if(shouldError){reject(newError('Good guess but a wrong answer. Try again!'));}else{resolve();}},1500);});}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadReacting to Input with Stateto learn how to approach interactions with a state-driven mindset."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Choosing the state structure"
                },
                {
                    "type": "p",
                    "text": "Structuring state well can make a difference between a component that is pleasant to modify and debug, and one that is a constant source of bugs. The most important principle is that state shouldn’t contain redundant or duplicated information. If there’s unnecessary state, it’s easy to forget to update it, and introduce bugs!"
                },
                {
                    "type": "p",
                    "text": "For example, this form has aredundantfullNamestate variable:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionForm(){const[firstName,setFirstName]=useState('');const[lastName,setLastName]=useState('');const[fullName,setFullName]=useState('');functionhandleFirstNameChange(e){setFirstName(e.target.value);setFullName(e.target.value+' '+lastName);}functionhandleLastNameChange(e){setLastName(e.target.value);setFullName(firstName+' '+e.target.value);}return(<><h2>Let’s check you in</h2><label>First name:{' '}<inputvalue={firstName}onChange={handleFirstNameChange}/></label><label>Last name:{' '}<inputvalue={lastName}onChange={handleLastNameChange}/></label><p>Your ticket will be issued to:<b>{fullName}</b></p></>);}"
                },
                {
                    "type": "p",
                    "text": "You can remove it and simplify the code by calculatingfullNamewhile the component is rendering:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionForm(){const[firstName,setFirstName]=useState('');const[lastName,setLastName]=useState('');constfullName=firstName+' '+lastName;functionhandleFirstNameChange(e){setFirstName(e.target.value);}functionhandleLastNameChange(e){setLastName(e.target.value);}return(<><h2>Let’s check you in</h2><label>First name:{' '}<inputvalue={firstName}onChange={handleFirstNameChange}/></label><label>Last name:{' '}<inputvalue={lastName}onChange={handleLastNameChange}/></label><p>Your ticket will be issued to:<b>{fullName}</b></p></>);}"
                },
                {
                    "type": "p",
                    "text": "This might seem like a small change, but many bugs in React apps are fixed this way."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadChoosing the State Structureto learn how to design the state shape to avoid bugs."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Sharing state between components"
                },
                {
                    "type": "p",
                    "text": "Sometimes, you want the state of two components to always change together. To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. This is known as “lifting state up”, and it’s one of the most common things you will do writing React code."
                },
                {
                    "type": "p",
                    "text": "In this example, only one panel should be active at a time. To achieve this, instead of keeping the active state inside each individual panel, the parent component holds the state and specifies the props for its children."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionAccordion(){const[activeIndex,setActiveIndex]=useState(0);return(<><h2>Almaty, Kazakhstan</h2><Paneltitle=\"About\"isActive={activeIndex===0}onShow={()=>setActiveIndex(0)}>With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city.</Panel><Paneltitle=\"Etymology\"isActive={activeIndex===1}onShow={()=>setActiveIndex(1)}>The name comes from<spanlang=\"kk-KZ\">алма</span>, the Kazakh word for \"apple\" and is often translated as \"full of apples\". In fact, the region surrounding Almaty is thought to be the ancestral home of the apple, and the wild<ilang=\"la\">Malus sieversii</i>is considered a likely candidate for the ancestor of the modern domestic apple.</Panel></>);}functionPanel({title,children,isActive,onShow}){return(<sectionclassName=\"panel\"><h3>{title}</h3>{isActive?(<p>{children}</p>):(<buttononClick={onShow}>Show</button>)}</section>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadSharing State Between Componentsto learn how to lift state up and keep components in sync."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Preserving and resetting state"
                },
                {
                    "type": "p",
                    "text": "When you re-render a component, React needs to decide which parts of the tree to keep (and update), and which parts to discard or re-create from scratch. In most cases, React’s automatic behavior works well enough. By default, React preserves the parts of the tree that “match up” with the previously rendered component tree."
                },
                {
                    "type": "p",
                    "text": "However, sometimes this is not what you want. In this chat app, typing a message and then switching the recipient does not reset the input. This can make the user accidentally send a message to the wrong person:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';importChatfrom'./Chat.js';importContactListfrom'./ContactList.js';exportdefaultfunctionMessenger(){const[to,setTo]=useState(contacts[0]);return(<div><ContactListcontacts={contacts}selectedContact={to}onSelect={contact=>setTo(contact)}/><Chatcontact={to}/></div>)}constcontacts=[{name:'Taylor',email:'taylor@mail.com'},{name:'Alice',email:'alice@mail.com'},{name:'Bob',email:'bob@mail.com'}];"
                },
                {
                    "type": "p",
                    "text": "React lets you override the default behavior, andforcea component to reset its state by passing it a differentkey, like<Chat key={email} />. This tells React that if the recipient is different, it should be considered adifferentChatcomponent that needs to be re-created from scratch with the new data (and UI like inputs). Now switching between the recipients resets the input field—even though you render the same component."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';importChatfrom'./Chat.js';importContactListfrom'./ContactList.js';exportdefaultfunctionMessenger(){const[to,setTo]=useState(contacts[0]);return(<div><ContactListcontacts={contacts}selectedContact={to}onSelect={contact=>setTo(contact)}/><Chatkey={to.email}contact={to}/></div>)}constcontacts=[{name:'Taylor',email:'taylor@mail.com'},{name:'Alice',email:'alice@mail.com'},{name:'Bob',email:'bob@mail.com'}];"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadPreserving and Resetting Stateto learn the lifetime of state and how to control it."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Extracting state logic into a reducer"
                },
                {
                    "type": "p",
                    "text": "Components with many state updates spread across many event handlers can get overwhelming. For these cases, you can consolidate all the state update logic outside your component in a single function, called “reducer”. Your event handlers become concise because they only specify the user “actions”. At the bottom of the file, the reducer function specifies how the state should update in response to each action!"
                },
                {
                    "type": "code",
                    "code": "import{useReducer}from'react';importAddTaskfrom'./AddTask.js';importTaskListfrom'./TaskList.js';exportdefaultfunctionTaskApp(){const[tasks,dispatch]=useReducer(tasksReducer,initialTasks);functionhandleAddTask(text){dispatch({type:'added',id:nextId++,text:text,});}functionhandleChangeTask(task){dispatch({type:'changed',task:task});}functionhandleDeleteTask(taskId){dispatch({type:'deleted',id:taskId});}return(<><h1>Prague itinerary</h1><AddTaskonAddTask={handleAddTask}/><TaskListtasks={tasks}onChangeTask={handleChangeTask}onDeleteTask={handleDeleteTask}/></>);}functiontasksReducer(tasks,action){switch(action.type){case'added':{return[...tasks,{id:action.id,text:action.text,done:false}];}case'changed':{returntasks.map(t=>{if(t.id===action.task.id){returnaction.task;}else{returnt;}});}case'deleted':{returntasks.filter(t=>t.id!==action.id);}default:{throwError('Unknown action: '+action.type);}}}letnextId=3;constinitialTasks=[{id:0,text:'Visit Kafka Museum',done:true},{id:1,text:'Watch a puppet show',done:false},{id:2,text:'Lennon Wall pic',done:false}];"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadExtracting State Logic into a Reducerto learn how to consolidate logic in the reducer function."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Passing data deeply with context"
                },
                {
                    "type": "p",
                    "text": "Usually, you will pass information from a parent component to a child component via props. But passing props can become inconvenient if you need to pass some prop through many components, or if many components need the same information. Context lets the parent component make some information available to any component in the tree below it—no matter how deep it is—without passing it explicitly through props."
                },
                {
                    "type": "p",
                    "text": "Here, theHeadingcomponent determines its heading level by “asking” the closestSectionfor its level. EachSectiontracks its own level by asking the parentSectionand adding one to it. EverySectionprovides information to all components below it without passing props—it does that through context."
                },
                {
                    "type": "code",
                    "code": "importHeadingfrom'./Heading.js';importSectionfrom'./Section.js';exportdefaultfunctionPage(){return(<Section><Heading>Title</Heading><Section><Heading>Heading</Heading><Heading>Heading</Heading><Heading>Heading</Heading><Section><Heading>Sub-heading</Heading><Heading>Sub-heading</Heading><Heading>Sub-heading</Heading><Section><Heading>Sub-sub-heading</Heading><Heading>Sub-sub-heading</Heading><Heading>Sub-sub-heading</Heading></Section></Section></Section></Section>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadPassing Data Deeply with Contextto learn about using context as an alternative to passing props."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Scaling up with reducer and context"
                },
                {
                    "type": "p",
                    "text": "Reducers let you consolidate a component’s state update logic. Context lets you pass information deep down to other components. You can combine reducers and context together to manage state of a complex screen."
                },
                {
                    "type": "p",
                    "text": "With this approach, a parent component with complex state manages it with a reducer. Other components anywhere deep in the tree can read its state via context. They can also dispatch actions to update that state."
                },
                {
                    "type": "code",
                    "code": "importAddTaskfrom'./AddTask.js';importTaskListfrom'./TaskList.js';import{TasksProvider}from'./TasksContext.js';exportdefaultfunctionTaskApp(){return(<TasksProvider><h1>Day off in Kyoto</h1><AddTask/><TaskList/></TasksProvider>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ready to learn this topic?"
                },
                {
                    "type": "p",
                    "text": "ReadScaling Up with Reducer and Contextto learn how state management scales in a growing app."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "What’s next?"
                },
                {
                    "type": "p",
                    "text": "Head over toReacting to Input with Stateto start reading this chapter page by page!"
                },
                {
                    "type": "p",
                    "text": "Or, if you’re already familiar with these topics, why not read aboutEscape Hatches?"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/manipulating-the-dom-with-refs",
            "title": "Manipulating the DOM with Refs – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Manipulating the DOM with Refs"
                },
                {
                    "type": "p",
                    "text": "React automatically updates theDOMto match your render output, so your components won’t often need to manipulate it. However, sometimes you might need access to the DOM elements managed by React—for example, to focus a node, scroll to it, or measure its size and position. There is no built-in way to do those things in React, so you will need arefto the DOM node."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "How to access a DOM node managed by React with therefattribute",
                        "How therefJSX attribute relates to theuseRefHook",
                        "How to access another component’s DOM node",
                        "In which cases it’s safe to modify the DOM managed by React"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Getting a ref to the node"
                },
                {
                    "type": "p",
                    "text": "To access a DOM node managed by React, first, import theuseRefHook:"
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';"
                },
                {
                    "type": "p",
                    "text": "Then, use it to declare a ref inside your component:"
                },
                {
                    "type": "code",
                    "code": "constmyRef=useRef(null);"
                },
                {
                    "type": "p",
                    "text": "Finally, pass your ref as therefattribute to the JSX tag for which you want to get the DOM node:"
                },
                {
                    "type": "code",
                    "code": "<divref={myRef}>"
                },
                {
                    "type": "p",
                    "text": "TheuseRefHook returns an object with a single property calledcurrent. Initially,myRef.currentwill benull. When React creates a DOM node for this<div>, React will put a reference to this node intomyRef.current. You can then access this DOM node from yourevent handlersand use the built-inbrowser APIsdefined on it."
                },
                {
                    "type": "code",
                    "code": "// You can use any browser APIs, for example:myRef.current.scrollIntoView();"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Example: Focusing a text input"
                },
                {
                    "type": "p",
                    "text": "In this example, clicking the button will focus the input:"
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';exportdefaultfunctionForm(){constinputRef=useRef(null);functionhandleClick(){inputRef.current.focus();}return(<><inputref={inputRef}/><buttononClick={handleClick}>Focus the input</button></>);}"
                },
                {
                    "type": "p",
                    "text": "To implement this:"
                },
                {
                    "type": "list",
                    "items": [
                        "DeclareinputRefwith theuseRefHook.",
                        "Pass it as<input ref={inputRef}>. This tells React toput this<input>’s DOM node intoinputRef.current.",
                        "In thehandleClickfunction, read the input DOM node frominputRef.currentand callfocus()on it withinputRef.current.focus().",
                        "Pass thehandleClickevent handler to<button>withonClick."
                    ]
                },
                {
                    "type": "p",
                    "text": "While DOM manipulation is the most common use case for refs, theuseRefHook can be used for storing other things outside React, like timer IDs. Similarly to state, refs remain between renders. Refs are like state variables that don’t trigger re-renders when you set them. Read about refs inReferencing Values with Refs."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Example: Scrolling to an element"
                },
                {
                    "type": "p",
                    "text": "You can have more than a single ref in a component. In this example, there is a carousel of three images. Each button centers an image by calling the browserscrollIntoView()method on the corresponding DOM node:"
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';exportdefaultfunctionCatFriends(){constfirstCatRef=useRef(null);constsecondCatRef=useRef(null);constthirdCatRef=useRef(null);functionhandleScrollToFirstCat(){firstCatRef.current.scrollIntoView({behavior:'smooth',block:'nearest',inline:'center'});}functionhandleScrollToSecondCat(){secondCatRef.current.scrollIntoView({behavior:'smooth',block:'nearest',inline:'center'});}functionhandleScrollToThirdCat(){thirdCatRef.current.scrollIntoView({behavior:'smooth',block:'nearest',inline:'center'});}return(<><nav><buttononClick={handleScrollToFirstCat}>Neo</button><buttononClick={handleScrollToSecondCat}>Millie</button><buttononClick={handleScrollToThirdCat}>Bella</button></nav><div><ul><li><imgsrc=\"https://placecats.com/neo/300/200\"alt=\"Neo\"ref={firstCatRef}/></li><li><imgsrc=\"https://placecats.com/millie/200/200\"alt=\"Millie\"ref={secondCatRef}/></li><li><imgsrc=\"https://placecats.com/bella/199/200\"alt=\"Bella\"ref={thirdCatRef}/></li></ul></div></>);}"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "How to manage a list of refs using a ref callback"
                },
                {
                    "type": "p",
                    "text": "In the above examples, there is a predefined number of refs. However, sometimes you might need a ref to each item in the list, and you don’t know how many you will have. Something like thiswouldn’t work:"
                },
                {
                    "type": "code",
                    "code": "<ul>{items.map((item)=>{// Doesn't work!constref=useRef(null);return<liref={ref}/>;})}</ul>"
                },
                {
                    "type": "p",
                    "text": "This is becauseHooks must only be called at the top-level of your component.You can’t calluseRefin a loop, in a condition, or inside amap()call."
                },
                {
                    "type": "p",
                    "text": "One possible way around this is to get a single ref to their parent element, and then use DOM manipulation methods likequerySelectorAllto “find” the individual child nodes from it. However, this is brittle and can break if your DOM structure changes."
                },
                {
                    "type": "p",
                    "text": "Another solution is topass a function to therefattribute.This is called arefcallback.React will call your ref callback with the DOM node when it’s time to set the ref, and withnullwhen it’s time to clear it. This lets you maintain your own array or aMap, and access any ref by its index or some kind of ID."
                },
                {
                    "type": "p",
                    "text": "This example shows how you can use this approach to scroll to an arbitrary node in a long list:"
                },
                {
                    "type": "code",
                    "code": "import{useRef,useState}from\"react\";exportdefaultfunctionCatFriends(){constitemsRef=useRef(null);const[catList,setCatList]=useState(setupCatList);functionscrollToCat(cat){constmap=getMap();constnode=map.get(cat);node.scrollIntoView({behavior:\"smooth\",block:\"nearest\",inline:\"center\",});}functiongetMap(){if(!itemsRef.current){// Initialize the Map on first usage.itemsRef.current=newMap();}returnitemsRef.current;}return(<><nav><buttononClick={()=>scrollToCat(catList[0])}>Neo</button><buttononClick={()=>scrollToCat(catList[5])}>Millie</button><buttononClick={()=>scrollToCat(catList[9])}>Bella</button></nav><div><ul>{catList.map((cat)=>(<likey={cat}ref={(node)=>{constmap=getMap();if(node){map.set(cat,node);}else{map.delete(cat);}}}><imgsrc={cat}/></li>))}</ul></div></>);}functionsetupCatList(){constcatList=[];for(leti=0;i<10;i++){catList.push(\"https://loremflickr.com/320/240/cat?lock=\"+i);}returncatList;}"
                },
                {
                    "type": "p",
                    "text": "In this example,itemsRefdoesn’t hold a single DOM node. Instead, it holds aMapfrom item ID to a DOM node. (Refs can hold any values!) Therefcallbackon every list item takes care to update the Map:"
                },
                {
                    "type": "code",
                    "code": "<likey={cat.id}ref={node=>{constmap=getMap();if(node){// Add to the Mapmap.set(cat,node);}else{// Remove from the Mapmap.delete(cat);}}}>"
                },
                {
                    "type": "p",
                    "text": "This lets you read individual DOM nodes from the Map later."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "This example shows another approach for managing the Map with arefcallback cleanup function."
                },
                {
                    "type": "code",
                    "code": "<likey={cat.id}ref={node=>{constmap=getMap();// Add to the Mapmap.set(cat,node);return()=>{// Remove from the Mapmap.delete(cat);};}}>"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Accessing another component’s DOM nodes"
                },
                {
                    "type": "p",
                    "text": "When you put a ref on a built-in component that outputs a browser element like<input />, React will set that ref’scurrentproperty to the corresponding DOM node (such as the actual<input />in the browser)."
                },
                {
                    "type": "p",
                    "text": "However, if you try to put a ref onyour owncomponent, like<MyInput />, by default you will getnull. Here is an example demonstrating it. Notice how clicking the buttondoes notfocus the input:"
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';functionMyInput(props){return<input{...props}/>;}exportdefaultfunctionMyForm(){constinputRef=useRef(null);functionhandleClick(){inputRef.current.focus();}return(<><MyInputref={inputRef}/><buttononClick={handleClick}>Focus the input</button></>);}"
                },
                {
                    "type": "p",
                    "text": "To help you notice the issue, React also prints an error to the console:"
                },
                {
                    "type": "p",
                    "text": "This happens because by default React does not let a component access the DOM nodes of other components. Not even for its own children! This is intentional. Refs are an escape hatch that should be used sparingly. Manually manipulatinganothercomponent’s DOM nodes makes your code even more fragile."
                },
                {
                    "type": "p",
                    "text": "Instead, components thatwantto expose their DOM nodes have toopt into that behavior. A component can specify that it “forwards” its ref to one of its children. Here’s howMyInputcan use theforwardRefAPI:"
                },
                {
                    "type": "code",
                    "code": "constMyInput=forwardRef((props,ref)=>{return<input{...props}ref={ref}/>;});"
                },
                {
                    "type": "p",
                    "text": "This is how it works:"
                },
                {
                    "type": "list",
                    "items": [
                        "<MyInput ref={inputRef} />tells React to put the corresponding DOM node intoinputRef.current. However, it’s up to theMyInputcomponent to opt into that—by default, it doesn’t.",
                        "TheMyInputcomponent is declared usingforwardRef.This opts it into receiving theinputReffrom above as the secondrefargumentwhich is declared afterprops.",
                        "MyInputitself passes therefit received to the<input>inside of it."
                    ]
                },
                {
                    "type": "p",
                    "text": "Now clicking the button to focus the input works:"
                },
                {
                    "type": "code",
                    "code": "import{forwardRef,useRef}from'react';constMyInput=forwardRef((props,ref)=>{return<input{...props}ref={ref}/>;});exportdefaultfunctionForm(){constinputRef=useRef(null);functionhandleClick(){inputRef.current.focus();}return(<><MyInputref={inputRef}/><buttononClick={handleClick}>Focus the input</button></>);}"
                },
                {
                    "type": "p",
                    "text": "In design systems, it is a common pattern for low-level components like buttons, inputs, and so on, to forward their refs to their DOM nodes. On the other hand, high-level components like forms, lists, or page sections usually won’t expose their DOM nodes to avoid accidental dependencies on the DOM structure."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Exposing a subset of the API with an imperative handle"
                },
                {
                    "type": "p",
                    "text": "In the above example,MyInputexposes the original DOM input element. This lets the parent component callfocus()on it. However, this also lets the parent component do something else—for example, change its CSS styles. In uncommon cases, you may want to restrict the exposed functionality. You can do that withuseImperativeHandle:"
                },
                {
                    "type": "code",
                    "code": "import{forwardRef,useRef,useImperativeHandle}from'react';constMyInput=forwardRef((props,ref)=>{constrealInputRef=useRef(null);useImperativeHandle(ref,()=>({// Only expose focus and nothing elsefocus(){realInputRef.current.focus();},}));return<input{...props}ref={realInputRef}/>;});exportdefaultfunctionForm(){constinputRef=useRef(null);functionhandleClick(){inputRef.current.focus();}return(<><MyInputref={inputRef}/><buttononClick={handleClick}>Focus the input</button></>);}"
                },
                {
                    "type": "p",
                    "text": "Here,realInputRefinsideMyInputholds the actual input DOM node. However,useImperativeHandleinstructs React to provide your own special object as the value of a ref to the parent component. SoinputRef.currentinside theFormcomponent will only have thefocusmethod. In this case, the ref “handle” is not the DOM node, but the custom object you create insideuseImperativeHandlecall."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "When React attaches the refs"
                },
                {
                    "type": "p",
                    "text": "In React, every update is split intwo phases:"
                },
                {
                    "type": "list",
                    "items": [
                        "Duringrender,React calls your components to figure out what should be on the screen.",
                        "Duringcommit,React applies changes to the DOM."
                    ]
                },
                {
                    "type": "p",
                    "text": "In general, youdon’t wantto access refs during rendering. That goes for refs holding DOM nodes as well. During the first render, the DOM nodes have not yet been created, soref.currentwill benull. And during the rendering of updates, the DOM nodes haven’t been updated yet. So it’s too early to read them."
                },
                {
                    "type": "p",
                    "text": "React setsref.currentduring the commit. Before updating the DOM, React sets the affectedref.currentvalues tonull. After updating the DOM, React immediately sets them to the corresponding DOM nodes."
                },
                {
                    "type": "p",
                    "text": "Usually, you will access refs from event handlers.If you want to do something with a ref, but there is no particular event to do it in, you might need an Effect. We will discuss Effects on the next pages."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Flushing state updates synchronously with flushSync"
                },
                {
                    "type": "p",
                    "text": "Consider code like this, which adds a new todo and scrolls the screen down to the last child of the list. Notice how, for some reason, it always scrolls to the todo that wasjust beforethe last added one:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useRef}from'react';exportdefaultfunctionTodoList(){constlistRef=useRef(null);const[text,setText]=useState('');const[todos,setTodos]=useState(initialTodos);functionhandleAdd(){constnewTodo={id:nextId++,text:text};setText('');setTodos([...todos,newTodo]);listRef.current.lastChild.scrollIntoView({behavior:'smooth',block:'nearest'});}return(<><buttononClick={handleAdd}>Add</button><inputvalue={text}onChange={e=>setText(e.target.value)}/><ulref={listRef}>{todos.map(todo=>(<likey={todo.id}>{todo.text}</li>))}</ul></>);}letnextId=0;letinitialTodos=[];for(leti=0;i<20;i++){initialTodos.push({id:nextId++,text:'Todo #'+(i+1)});}"
                },
                {
                    "type": "p",
                    "text": "The issue is with these two lines:"
                },
                {
                    "type": "code",
                    "code": "setTodos([...todos,newTodo]);listRef.current.lastChild.scrollIntoView();"
                },
                {
                    "type": "p",
                    "text": "In React,state updates are queued.Usually, this is what you want. However, here it causes a problem becausesetTodosdoes not immediately update the DOM. So the time you scroll the list to its last element, the todo has not yet been added. This is why scrolling always “lags behind” by one item."
                },
                {
                    "type": "p",
                    "text": "To fix this issue, you can force React to update (“flush”) the DOM synchronously. To do this, importflushSyncfromreact-domandwrap the state updateinto aflushSynccall:"
                },
                {
                    "type": "code",
                    "code": "flushSync(()=>{setTodos([...todos,newTodo]);});listRef.current.lastChild.scrollIntoView();"
                },
                {
                    "type": "p",
                    "text": "This will instruct React to update the DOM synchronously right after the code wrapped influshSyncexecutes. As a result, the last todo will already be in the DOM by the time you try to scroll to it:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useRef}from'react';import{flushSync}from'react-dom';exportdefaultfunctionTodoList(){constlistRef=useRef(null);const[text,setText]=useState('');const[todos,setTodos]=useState(initialTodos);functionhandleAdd(){constnewTodo={id:nextId++,text:text};flushSync(()=>{setText('');setTodos([...todos,newTodo]);});listRef.current.lastChild.scrollIntoView({behavior:'smooth',block:'nearest'});}return(<><buttononClick={handleAdd}>Add</button><inputvalue={text}onChange={e=>setText(e.target.value)}/><ulref={listRef}>{todos.map(todo=>(<likey={todo.id}>{todo.text}</li>))}</ul></>);}letnextId=0;letinitialTodos=[];for(leti=0;i<20;i++){initialTodos.push({id:nextId++,text:'Todo #'+(i+1)});}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Best practices for DOM manipulation with refs"
                },
                {
                    "type": "p",
                    "text": "Refs are an escape hatch. You should only use them when you have to “step outside React”. Common examples of this include managing focus, scroll position, or calling browser APIs that React does not expose."
                },
                {
                    "type": "p",
                    "text": "If you stick to non-destructive actions like focusing and scrolling, you shouldn’t encounter any problems. However, if you try tomodifythe DOM manually, you can risk conflicting with the changes React is making."
                },
                {
                    "type": "p",
                    "text": "To illustrate this problem, this example includes a welcome message and two buttons. The first button toggles its presence usingconditional renderingandstate, as you would usually do in React. The second button uses theremove()DOM APIto forcefully remove it from the DOM outside of React’s control."
                },
                {
                    "type": "p",
                    "text": "Try pressing “Toggle with setState” a few times. The message should disappear and appear again. Then press “Remove from the DOM”. This will forcefully remove it. Finally, press “Toggle with setState”:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useRef}from'react';exportdefaultfunctionCounter(){const[show,setShow]=useState(true);constref=useRef(null);return(<div><buttononClick={()=>{setShow(!show);}}>Toggle with setState</button><buttononClick={()=>{ref.current.remove();}}>Remove from the DOM</button>{show&&<pref={ref}>Hello world</p>}</div>);}"
                },
                {
                    "type": "p",
                    "text": "After you’ve manually removed the DOM element, trying to usesetStateto show it again will lead to a crash. This is because you’ve changed the DOM, and React doesn’t know how to continue managing it correctly."
                },
                {
                    "type": "p",
                    "text": "Avoid changing DOM nodes managed by React.Modifying, adding children to, or removing children from elements that are managed by React can lead to inconsistent visual results or crashes like above."
                },
                {
                    "type": "p",
                    "text": "However, this doesn’t mean that you can’t do it at all. It requires caution.You can safely modify parts of the DOM that React hasno reasonto update.For example, if some<div>is always empty in the JSX, React won’t have a reason to touch its children list. Therefore, it is safe to manually add or remove elements there."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "Refs are a generic concept, but most often you’ll use them to hold DOM elements.",
                        "You instruct React to put a DOM node intomyRef.currentby passing<div ref={myRef}>.",
                        "Usually, you will use refs for non-destructive actions like focusing, scrolling, or measuring DOM elements.",
                        "A component doesn’t expose its DOM nodes by default. You can opt into exposing a DOM node by usingforwardRefand passing the secondrefargument down to a specific node.",
                        "Avoid changing DOM nodes managed by React.",
                        "If you do modify DOM nodes managed by React, modify parts that React has no reason to update."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of4:Play and pause the video"
                },
                {
                    "type": "p",
                    "text": "In this example, the button toggles a state variable to switch between a playing and a paused state. However, in order to actually play or pause the video, toggling state is not enough. You also need to callplay()andpause()on the DOM element for the<video>. Add a ref to it, and make the button work."
                },
                {
                    "type": "code",
                    "code": "import{useState,useRef}from'react';exportdefaultfunctionVideoPlayer(){const[isPlaying,setIsPlaying]=useState(false);functionhandleClick(){constnextIsPlaying= !isPlaying;setIsPlaying(nextIsPlaying);}return(<><buttononClick={handleClick}>{isPlaying?'Pause':'Play'}</button><videowidth=\"250\"><sourcesrc=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"type=\"video/mp4\"/></video></>)}"
                },
                {
                    "type": "p",
                    "text": "For an extra challenge, keep the “Play” button in sync with whether the video is playing even if the user right-clicks the video and plays it using the built-in browser media controls. You might want to listen toonPlayandonPauseon the video to do that."
                }
            ]
        },
        {
            "url": "https://react.dev/learn/passing-data-deeply-with-context",
            "title": "Passing Data Deeply with Context – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Passing Data Deeply with Context"
                },
                {
                    "type": "p",
                    "text": "Usually, you will pass information from a parent component to a child component via props. But passing props can become verbose and inconvenient if you have to pass them through many components in the middle, or if many components in your app need the same information.Contextlets the parent component make some information available to any component in the tree below it—no matter how deep—without passing it explicitly through props."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "What “prop drilling” is",
                        "How to replace repetitive prop passing with context",
                        "Common use cases for context",
                        "Common alternatives to context"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "The problem with passing props"
                },
                {
                    "type": "p",
                    "text": "Passing propsis a great way to explicitly pipe data through your UI tree to the components that use it."
                },
                {
                    "type": "p",
                    "text": "But passing props can become verbose and inconvenient when you need to pass some prop deeply through the tree, or if many components need the same prop. The nearest common ancestor could be far removed from the components that need data, andlifting state upthat high can lead to a situation called “prop drilling”."
                },
                {
                    "type": "p",
                    "text": "Lifting state up"
                },
                {
                    "type": "p",
                    "text": "Prop drilling"
                },
                {
                    "type": "p",
                    "text": "Wouldn’t it be great if there were a way to “teleport” data to the components in the tree that need it without passing props? With React’s context feature, there is!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Context: an alternative to passing props"
                },
                {
                    "type": "p",
                    "text": "Context lets a parent component provide data to the entire tree below it. There are many uses for context. Here is one example. Consider thisHeadingcomponent that accepts alevelfor its size:"
                },
                {
                    "type": "code",
                    "code": "importHeadingfrom'./Heading.js';importSectionfrom'./Section.js';exportdefaultfunctionPage(){return(<Section><Headinglevel={1}>Title</Heading><Headinglevel={2}>Heading</Heading><Headinglevel={3}>Sub-heading</Heading><Headinglevel={4}>Sub-sub-heading</Heading><Headinglevel={5}>Sub-sub-sub-heading</Heading><Headinglevel={6}>Sub-sub-sub-sub-heading</Heading></Section>);}"
                },
                {
                    "type": "p",
                    "text": "Let’s say you want multiple headings within the sameSectionto always have the same size:"
                },
                {
                    "type": "code",
                    "code": "importHeadingfrom'./Heading.js';importSectionfrom'./Section.js';exportdefaultfunctionPage(){return(<Section><Headinglevel={1}>Title</Heading><Section><Headinglevel={2}>Heading</Heading><Headinglevel={2}>Heading</Heading><Headinglevel={2}>Heading</Heading><Section><Headinglevel={3}>Sub-heading</Heading><Headinglevel={3}>Sub-heading</Heading><Headinglevel={3}>Sub-heading</Heading><Section><Headinglevel={4}>Sub-sub-heading</Heading><Headinglevel={4}>Sub-sub-heading</Heading><Headinglevel={4}>Sub-sub-heading</Heading></Section></Section></Section></Section>);}"
                },
                {
                    "type": "p",
                    "text": "Currently, you pass thelevelprop to each<Heading>separately:"
                },
                {
                    "type": "code",
                    "code": "<Section><Headinglevel={3}>About</Heading><Headinglevel={3}>Photos</Heading><Headinglevel={3}>Videos</Heading></Section>"
                },
                {
                    "type": "p",
                    "text": "It would be nice if you could pass thelevelprop to the<Section>component instead and remove it from the<Heading>. This way you could enforce that all headings in the same section have the same size:"
                },
                {
                    "type": "code",
                    "code": "<Sectionlevel={3}><Heading>About</Heading><Heading>Photos</Heading><Heading>Videos</Heading></Section>"
                },
                {
                    "type": "p",
                    "text": "But how can the<Heading>component know the level of its closest<Section>?That would require some way for a child to “ask” for data from somewhere above in the tree."
                },
                {
                    "type": "p",
                    "text": "You can’t do it with props alone. This is where context comes into play. You will do it in three steps:"
                },
                {
                    "type": "list",
                    "items": [
                        "Createa context. (You can call itLevelContext, since it’s for the heading level.)",
                        "Usethat context from the component that needs the data. (Headingwill useLevelContext.)",
                        "Providethat context from the component that specifies the data. (Sectionwill provideLevelContext.)"
                    ]
                },
                {
                    "type": "p",
                    "text": "Context lets a parent—even a distant one!—provide some data to the entire tree inside of it."
                },
                {
                    "type": "p",
                    "text": "Using context in close children"
                },
                {
                    "type": "p",
                    "text": "Using context in distant children"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 1: Create the context"
                },
                {
                    "type": "p",
                    "text": "First, you need to create the context. You’ll need toexport it from a fileso that your components can use it:"
                },
                {
                    "type": "code",
                    "code": "import{createContext}from'react';exportconstLevelContext=createContext(1);"
                },
                {
                    "type": "p",
                    "text": "The only argument tocreateContextis thedefaultvalue. Here,1refers to the biggest heading level, but you could pass any kind of value (even an object). You will see the significance of the default value in the next step."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 2: Use the context"
                },
                {
                    "type": "p",
                    "text": "Import theuseContextHook from React and your context:"
                },
                {
                    "type": "code",
                    "code": "import{useContext}from'react';import{LevelContext}from'./LevelContext.js';"
                },
                {
                    "type": "p",
                    "text": "Currently, theHeadingcomponent readslevelfrom props:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionHeading({level,children}){// ...}"
                },
                {
                    "type": "p",
                    "text": "Instead, remove thelevelprop and read the value from the context you just imported,LevelContext:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionHeading({children}){constlevel=useContext(LevelContext);// ...}"
                },
                {
                    "type": "p",
                    "text": "useContextis a Hook. Just likeuseStateanduseReducer, you can only call a Hook immediately inside a React component (not inside loops or conditions).useContexttells React that theHeadingcomponent wants to read theLevelContext."
                },
                {
                    "type": "p",
                    "text": "Now that theHeadingcomponent doesn’t have alevelprop, you don’t need to pass the level prop toHeadingin your JSX like this anymore:"
                },
                {
                    "type": "code",
                    "code": "<Section><Headinglevel={4}>Sub-sub-heading</Heading><Headinglevel={4}>Sub-sub-heading</Heading><Headinglevel={4}>Sub-sub-heading</Heading></Section>"
                },
                {
                    "type": "p",
                    "text": "Update the JSX so that it’s theSectionthat receives it instead:"
                },
                {
                    "type": "code",
                    "code": "<Sectionlevel={4}><Heading>Sub-sub-heading</Heading><Heading>Sub-sub-heading</Heading><Heading>Sub-sub-heading</Heading></Section>"
                },
                {
                    "type": "p",
                    "text": "As a reminder, this is the markup that you were trying to get working:"
                },
                {
                    "type": "code",
                    "code": "importHeadingfrom'./Heading.js';importSectionfrom'./Section.js';exportdefaultfunctionPage(){return(<Sectionlevel={1}><Heading>Title</Heading><Sectionlevel={2}><Heading>Heading</Heading><Heading>Heading</Heading><Heading>Heading</Heading><Sectionlevel={3}><Heading>Sub-heading</Heading><Heading>Sub-heading</Heading><Heading>Sub-heading</Heading><Sectionlevel={4}><Heading>Sub-sub-heading</Heading><Heading>Sub-sub-heading</Heading><Heading>Sub-sub-heading</Heading></Section></Section></Section></Section>);}"
                },
                {
                    "type": "p",
                    "text": "Notice this example doesn’t quite work, yet! All the headings have the same size becauseeven though you’reusingthe context, you have notprovidedit yet.React doesn’t know where to get it!"
                },
                {
                    "type": "p",
                    "text": "If you don’t provide the context, React will use the default value you’ve specified in the previous step. In this example, you specified1as the argument tocreateContext, souseContext(LevelContext)returns1, setting all those headings to<h1>. Let’s fix this problem by having eachSectionprovide its own context."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 3: Provide the context"
                },
                {
                    "type": "p",
                    "text": "TheSectioncomponent currently renders its children:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionSection({children}){return(<sectionclassName=\"section\">{children}</section>);}"
                },
                {
                    "type": "p",
                    "text": "Wrap them with a context providerto provide theLevelContextto them:"
                },
                {
                    "type": "code",
                    "code": "import{LevelContext}from'./LevelContext.js';exportdefaultfunctionSection({level,children}){return(<sectionclassName=\"section\"><LevelContext.Providervalue={level}>{children}</LevelContext.Provider></section>);}"
                },
                {
                    "type": "p",
                    "text": "This tells React: “if any component inside this<Section>asks forLevelContext, give them thislevel.” The component will use the value of the nearest<LevelContext.Provider>in the UI tree above it."
                },
                {
                    "type": "code",
                    "code": "importHeadingfrom'./Heading.js';importSectionfrom'./Section.js';exportdefaultfunctionPage(){return(<Sectionlevel={1}><Heading>Title</Heading><Sectionlevel={2}><Heading>Heading</Heading><Heading>Heading</Heading><Heading>Heading</Heading><Sectionlevel={3}><Heading>Sub-heading</Heading><Heading>Sub-heading</Heading><Heading>Sub-heading</Heading><Sectionlevel={4}><Heading>Sub-sub-heading</Heading><Heading>Sub-sub-heading</Heading><Heading>Sub-sub-heading</Heading></Section></Section></Section></Section>);}"
                },
                {
                    "type": "p",
                    "text": "It’s the same result as the original code, but you did not need to pass thelevelprop to eachHeadingcomponent! Instead, it “figures out” its heading level by asking the closestSectionabove:"
                },
                {
                    "type": "list",
                    "items": [
                        "You pass alevelprop to the<Section>.",
                        "Sectionwraps its children into<LevelContext.Provider value={level}>.",
                        "Headingasks the closest value ofLevelContextabove withuseContext(LevelContext)."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Using and providing context from the same component"
                },
                {
                    "type": "p",
                    "text": "Currently, you still have to specify each section’slevelmanually:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionPage(){return(<Sectionlevel={1}>...<Sectionlevel={2}>...<Sectionlevel={3}>..."
                },
                {
                    "type": "p",
                    "text": "Since context lets you read information from a component above, eachSectioncould read thelevelfrom theSectionabove, and passlevel + 1down automatically. Here is how you could do it:"
                },
                {
                    "type": "code",
                    "code": "import{useContext}from'react';import{LevelContext}from'./LevelContext.js';exportdefaultfunctionSection({children}){constlevel=useContext(LevelContext);return(<sectionclassName=\"section\"><LevelContext.Providervalue={level+1}>{children}</LevelContext.Provider></section>);}"
                },
                {
                    "type": "p",
                    "text": "With this change, you don’t need to pass thelevelpropeitherto the<Section>or to the<Heading>:"
                },
                {
                    "type": "code",
                    "code": "importHeadingfrom'./Heading.js';importSectionfrom'./Section.js';exportdefaultfunctionPage(){return(<Section><Heading>Title</Heading><Section><Heading>Heading</Heading><Heading>Heading</Heading><Heading>Heading</Heading><Section><Heading>Sub-heading</Heading><Heading>Sub-heading</Heading><Heading>Sub-heading</Heading><Section><Heading>Sub-sub-heading</Heading><Heading>Sub-sub-heading</Heading><Heading>Sub-sub-heading</Heading></Section></Section></Section></Section>);}"
                },
                {
                    "type": "p",
                    "text": "Now bothHeadingandSectionread theLevelContextto figure out how “deep” they are. And theSectionwraps its children into theLevelContextto specify that anything inside of it is at a “deeper” level."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "This example uses heading levels because they show visually how nested components can override context. But context is useful for many other use cases too. You can pass down any information needed by the entire subtree: the current color theme, the currently logged in user, and so on."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Context passes through intermediate components"
                },
                {
                    "type": "p",
                    "text": "You can insert as many components as you like between the component that provides context and the one that uses it. This includes both built-in components like<div>and components you might build yourself."
                },
                {
                    "type": "p",
                    "text": "In this example, the samePostcomponent (with a dashed border) is rendered at two different nesting levels. Notice that the<Heading>inside of it gets its level automatically from the closest<Section>:"
                },
                {
                    "type": "code",
                    "code": "importHeadingfrom'./Heading.js';importSectionfrom'./Section.js';exportdefaultfunctionProfilePage(){return(<Section><Heading>My Profile</Heading><Posttitle=\"Hello traveller!\"body=\"Read about my adventures.\"/><AllPosts/></Section>);}functionAllPosts(){return(<Section><Heading>Posts</Heading><RecentPosts/></Section>);}functionRecentPosts(){return(<Section><Heading>Recent Posts</Heading><Posttitle=\"Flavors of Lisbon\"body=\"...those pastéis de nata!\"/><Posttitle=\"Buenos Aires in the rhythm of tango\"body=\"I loved it!\"/></Section>);}functionPost({title,body}){return(<SectionisFancy={true}><Heading>{title}</Heading><p><i>{body}</i></p></Section>);}"
                },
                {
                    "type": "p",
                    "text": "You didn’t do anything special for this to work. ASectionspecifies the context for the tree inside it, so you can insert a<Heading>anywhere, and it will have the correct size. Try it in the sandbox above!"
                },
                {
                    "type": "p",
                    "text": "Context lets you write components that “adapt to their surroundings” and display themselves differently depending onwhere(or, in other words,in which context) they are being rendered."
                },
                {
                    "type": "p",
                    "text": "How context works might remind you ofCSS property inheritance.In CSS, you can specifycolor: bluefor a<div>, and any DOM node inside of it, no matter how deep, will inherit that color unless some other DOM node in the middle overrides it withcolor: green. Similarly, in React, the only way to override some context coming from above is to wrap children into a context provider with a different value."
                },
                {
                    "type": "p",
                    "text": "In CSS, different properties likecolorandbackground-colordon’t override each other. You can set all<div>’scolorto red without impactingbackground-color. Similarly,different React contexts don’t override each other.Each context that you make withcreateContext()is completely separate from other ones, and ties together components using and providingthat particularcontext. One component may use or provide many different contexts without a problem."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Before you use context"
                },
                {
                    "type": "p",
                    "text": "Context is very tempting to use! However, this also means it’s too easy to overuse it.Just because you need to pass some props several levels deep doesn’t mean you should put that information into context."
                },
                {
                    "type": "p",
                    "text": "Here’s a few alternatives you should consider before using context:"
                },
                {
                    "type": "list",
                    "items": [
                        "Start bypassing props.If your components are not trivial, it’s not unusual to pass a dozen props down through a dozen components. It may feel like a slog, but it makes it very clear which components use which data! The person maintaining your code will be glad you’ve made the data flow explicit with props.",
                        "Extract components andpass JSX aschildrento them.If you pass some data through many layers of intermediate components that don’t use that data (and only pass it further down), this often means that you forgot to extract some components along the way. For example, maybe you pass data props likepoststo visual components that don’t use them directly, like<Layout posts={posts} />. Instead, makeLayouttakechildrenas a prop, and render<Layout><Posts posts={posts} /></Layout>. This reduces the number of layers between the component specifying the data and the one that needs it."
                    ]
                },
                {
                    "type": "p",
                    "text": "If neither of these approaches works well for you, consider context."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Use cases for context"
                },
                {
                    "type": "list",
                    "items": [
                        "Theming:If your app lets the user change its appearance (e.g. dark mode), you can put a context provider at the top of your app, and use that context in components that need to adjust their visual look.",
                        "Current account:Many components might need to know the currently logged in user. Putting it in context makes it convenient to read it anywhere in the tree. Some apps also let you operate multiple accounts at the same time (e.g. to leave a comment as a different user). In those cases, it can be convenient to wrap a part of the UI into a nested provider with a different current account value.",
                        "Routing:Most routing solutions use context internally to hold the current route. This is how every link “knows” whether it’s active or not. If you build your own router, you might want to do it too.",
                        "Managing state:As your app grows, you might end up with a lot of state closer to the top of your app. Many distant components below may want to change it. It is common touse a reducer together with contextto manage complex state and pass it down to distant components without too much hassle."
                    ]
                },
                {
                    "type": "p",
                    "text": "Context is not limited to static values. If you pass a different value on the next render, React will update all the components reading it below! This is why context is often used in combination with state."
                },
                {
                    "type": "p",
                    "text": "In general, if some information is needed by distant components in different parts of the tree, it’s a good indication that context will help you."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "Context lets a component provide some information to the entire tree below it.",
                        "To pass context:Create and export it withexport const MyContext = createContext(defaultValue).Pass it to theuseContext(MyContext)Hook to read it in any child component, no matter how deep.Wrap children into<MyContext.Provider value={...}>to provide it from a parent.",
                        "Create and export it withexport const MyContext = createContext(defaultValue).",
                        "Pass it to theuseContext(MyContext)Hook to read it in any child component, no matter how deep.",
                        "Wrap children into<MyContext.Provider value={...}>to provide it from a parent.",
                        "Context passes through any components in the middle.",
                        "Context lets you write components that “adapt to their surroundings”.",
                        "Before you use context, try passing props or passing JSX aschildren."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Create and export it withexport const MyContext = createContext(defaultValue).",
                        "Pass it to theuseContext(MyContext)Hook to read it in any child component, no matter how deep.",
                        "Wrap children into<MyContext.Provider value={...}>to provide it from a parent."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of1:Replace prop drilling with context"
                },
                {
                    "type": "p",
                    "text": "In this example, toggling the checkbox changes theimageSizeprop passed to each<PlaceImage>. The checkbox state is held in the top-levelAppcomponent, but each<PlaceImage>needs to be aware of it."
                },
                {
                    "type": "p",
                    "text": "Currently,ApppassesimageSizetoList, which passes it to eachPlace, which passes it to thePlaceImage. Remove theimageSizeprop, and instead pass it from theAppcomponent directly toPlaceImage."
                },
                {
                    "type": "p",
                    "text": "You can declare context inContext.js."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';import{places}from'./data.js';import{getImageUrl}from'./utils.js';exportdefaultfunctionApp(){const[isLarge,setIsLarge]=useState(false);constimageSize=isLarge?150:100;return(<><label><inputtype=\"checkbox\"checked={isLarge}onChange={e=>{setIsLarge(e.target.checked);}}/>Use large images</label><hr/><ListimageSize={imageSize}/></>)}functionList({imageSize}){constlistItems=places.map(place=><likey={place.id}><Placeplace={place}imageSize={imageSize}/></li>);return<ul>{listItems}</ul>;}functionPlace({place,imageSize}){return(<><PlaceImageplace={place}imageSize={imageSize}/><p><b>{place.name}</b>{': '+place.description}</p></>);}functionPlaceImage({place,imageSize}){return(<imgsrc={getImageUrl(place)}alt={place.name}width={imageSize}height={imageSize}/>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/passing-props-to-a-component",
            "title": "Passing Props to a Component – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Passing Props to a Component"
                },
                {
                    "type": "p",
                    "text": "React components usepropsto communicate with each other. Every parent component can pass some information to its child components by giving them props. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, and functions."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "How to pass props to a component",
                        "How to read props from a component",
                        "How to specify default values for props",
                        "How to pass some JSX to a component",
                        "How props change over time"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Familiar props"
                },
                {
                    "type": "p",
                    "text": "Props are the information that you pass to a JSX tag. For example,className,src,alt,width, andheightare some of the props you can pass to an<img>:"
                },
                {
                    "type": "code",
                    "code": "functionAvatar(){return(<imgclassName=\"avatar\"src=\"https://i.imgur.com/1bX5QH6.jpg\"alt=\"Lin Lanying\"width={100}height={100}/>);}exportdefaultfunctionProfile(){return(<Avatar/>);}"
                },
                {
                    "type": "p",
                    "text": "The props you can pass to an<img>tag are predefined (ReactDOM conforms tothe HTML standard). But you can pass any props toyour owncomponents, such as<Avatar>, to customize them. Here’s how!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Passing props to a component"
                },
                {
                    "type": "p",
                    "text": "In this code, theProfilecomponent isn’t passing any props to its child component,Avatar:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionProfile(){return(<Avatar/>);}"
                },
                {
                    "type": "p",
                    "text": "You can giveAvatarsome props in two steps."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 1: Pass props to the child component"
                },
                {
                    "type": "p",
                    "text": "First, pass some props toAvatar. For example, let’s pass two props:person(an object), andsize(a number):"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionProfile(){return(<Avatarperson={{name:'Lin Lanying',imageId:'1bX5QH6'}}size={100}/>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "If double curly braces afterperson=confuse you, recallthey’re merely an objectinside the JSX curlies."
                },
                {
                    "type": "p",
                    "text": "Now you can read these props inside theAvatarcomponent."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 2: Read props inside the child component"
                },
                {
                    "type": "p",
                    "text": "You can read these props by listing their namesperson, sizeseparated by the commas inside({and})directly afterfunction Avatar. This lets you use them inside theAvatarcode, like you would with a variable."
                },
                {
                    "type": "code",
                    "code": "functionAvatar({person,size}){// person and size are available here}"
                },
                {
                    "type": "p",
                    "text": "Add some logic toAvatarthat uses thepersonandsizeprops for rendering, and you’re done."
                },
                {
                    "type": "p",
                    "text": "Now you can configureAvatarto render in many different ways with different props. Try tweaking the values!"
                },
                {
                    "type": "code",
                    "code": "import{getImageUrl}from'./utils.js';functionAvatar({person,size}){return(<imgclassName=\"avatar\"src={getImageUrl(person)}alt={person.name}width={size}height={size}/>);}exportdefaultfunctionProfile(){return(<div><Avatarsize={100}person={{name:'Katsuko Saruhashi',imageId:'YfeOqp2'}}/><Avatarsize={80}person={{name:'Aklilu Lemma',imageId:'OKS67lh'}}/><Avatarsize={50}person={{name:'Lin Lanying',imageId:'1bX5QH6'}}/></div>);}"
                },
                {
                    "type": "p",
                    "text": "Props let you think about parent and child components independently. For example, you can change thepersonor thesizeprops insideProfilewithout having to think about howAvataruses them. Similarly, you can change how theAvataruses these props, without looking at theProfile."
                },
                {
                    "type": "p",
                    "text": "You can think of props like “knobs” that you can adjust. They serve the same role as arguments serve for functions—in fact, propsarethe only argument to your component! React component functions accept a single argument, apropsobject:"
                },
                {
                    "type": "code",
                    "code": "functionAvatar(props){letperson=props.person;letsize=props.size;// ...}"
                },
                {
                    "type": "p",
                    "text": "Usually you don’t need the wholepropsobject itself, so you destructure it into individual props."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Don’t miss the pair of{and}curliesinside of(and)when declaring props:"
                },
                {
                    "type": "code",
                    "code": "functionAvatar({person,size}){// ...}"
                },
                {
                    "type": "p",
                    "text": "This syntax is called“destructuring”and is equivalent to reading properties from a function parameter:"
                },
                {
                    "type": "code",
                    "code": "functionAvatar(props){letperson=props.person;letsize=props.size;// ...}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Specifying a default value for a prop"
                },
                {
                    "type": "p",
                    "text": "If you want to give a prop a default value to fall back on when no value is specified, you can do it with the destructuring by putting=and the default value right after the parameter:"
                },
                {
                    "type": "code",
                    "code": "functionAvatar({person,size=100}){// ...}"
                },
                {
                    "type": "p",
                    "text": "Now, if<Avatar person={...} />is rendered with nosizeprop, thesizewill be set to100."
                },
                {
                    "type": "p",
                    "text": "The default value is only used if thesizeprop is missing or if you passsize={undefined}. But if you passsize={null}orsize={0}, the default value willnotbe used."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Forwarding props with the JSX spread syntax"
                },
                {
                    "type": "p",
                    "text": "Sometimes, passing props gets very repetitive:"
                },
                {
                    "type": "code",
                    "code": "functionProfile({person,size,isSepia,thickBorder}){return(<divclassName=\"card\"><Avatarperson={person}size={size}isSepia={isSepia}thickBorder={thickBorder}/></div>);}"
                },
                {
                    "type": "p",
                    "text": "There’s nothing wrong with repetitive code—it can be more legible. But at times you may value conciseness. Some components forward all of their props to their children, like how thisProfiledoes withAvatar. Because they don’t use any of their props directly, it can make sense to use a more concise “spread” syntax:"
                },
                {
                    "type": "code",
                    "code": "functionProfile(props){return(<divclassName=\"card\"><Avatar{...props}/></div>);}"
                },
                {
                    "type": "p",
                    "text": "This forwards all ofProfile’s props to theAvatarwithout listing each of their names."
                },
                {
                    "type": "p",
                    "text": "Use spread syntax with restraint.If you’re using it in every other component, something is wrong. Often, it indicates that you should split your components and pass children as JSX. More on that next!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Passing JSX as children"
                },
                {
                    "type": "p",
                    "text": "It is common to nest built-in browser tags:"
                },
                {
                    "type": "code",
                    "code": "<div><img/></div>"
                },
                {
                    "type": "p",
                    "text": "Sometimes you’ll want to nest your own components the same way:"
                },
                {
                    "type": "code",
                    "code": "<Card><Avatar/></Card>"
                },
                {
                    "type": "p",
                    "text": "When you nest content inside a JSX tag, the parent component will receive that content in a prop calledchildren. For example, theCardcomponent below will receive achildrenprop set to<Avatar />and render it in a wrapper div:"
                },
                {
                    "type": "code",
                    "code": "importAvatarfrom'./Avatar.js';functionCard({children}){return(<divclassName=\"card\">{children}</div>);}exportdefaultfunctionProfile(){return(<Card><Avatarsize={100}person={{name:'Katsuko Saruhashi',imageId:'YfeOqp2'}}/></Card>);}"
                },
                {
                    "type": "p",
                    "text": "Try replacing the<Avatar>inside<Card>with some text to see how theCardcomponent can wrap any nested content. It doesn’t need to “know” what’s being rendered inside of it. You will see this flexible pattern in many places."
                },
                {
                    "type": "p",
                    "text": "You can think of a component with achildrenprop as having a “hole” that can be “filled in” by its parent components with arbitrary JSX. You will often use thechildrenprop for visual wrappers: panels, grids, etc."
                },
                {
                    "type": "p",
                    "text": "Illustrated byRachel Lee Nabors"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "How props change over time"
                },
                {
                    "type": "p",
                    "text": "TheClockcomponent below receives two props from its parent component:colorandtime. (The parent component’s code is omitted because it usesstate, which we won’t dive into just yet.)"
                },
                {
                    "type": "p",
                    "text": "Try changing the color in the select box below:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionClock({color,time}){return(<h1style={{color:color}}>{time}</h1>);}"
                },
                {
                    "type": "p",
                    "text": "This example illustrates thata component may receive different props over time.Props are not always static! Here, thetimeprop changes every second, and thecolorprop changes when you select another color. Props reflect a component’s data at any point in time, rather than only in the beginning."
                },
                {
                    "type": "p",
                    "text": "However, props areimmutable—a term from computer science meaning “unchangeable”. When a component needs to change its props (for example, in response to a user interaction or new data), it will have to “ask” its parent component to pass itdifferent props—a new object! Its old props will then be cast aside, and eventually the JavaScript engine will reclaim the memory taken by them."
                },
                {
                    "type": "p",
                    "text": "Don’t try to “change props”.When you need to respond to the user input (like changing the selected color), you will need to “set state”, which you can learn about inState: A Component’s Memory."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "To pass props, add them to the JSX, just like you would with HTML attributes.",
                        "To read props, use thefunction Avatar({ person, size })destructuring syntax.",
                        "You can specify a default value likesize = 100, which is used for missing andundefinedprops.",
                        "You can forward all props with<Avatar {...props} />JSX spread syntax, but don’t overuse it!",
                        "Nested JSX like<Card><Avatar /></Card>will appear asCardcomponent’schildrenprop.",
                        "Props are read-only snapshots in time: every render receives a new version of props.",
                        "You can’t change props. When you need interactivity, you’ll need to set state."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of3:Extract a component"
                },
                {
                    "type": "p",
                    "text": "ThisGallerycomponent contains some very similar markup for two profiles. Extract aProfilecomponent out of it to reduce the duplication. You’ll need to choose what props to pass to it."
                },
                {
                    "type": "code",
                    "code": "import{getImageUrl}from'./utils.js';exportdefaultfunctionGallery(){return(<div><h1>Notable Scientists</h1><sectionclassName=\"profile\"><h2>Maria Skłodowska-Curie</h2><imgclassName=\"avatar\"src={getImageUrl('szV5sdG')}alt=\"Maria Skłodowska-Curie\"width={70}height={70}/><ul><li><b>Profession:</b>physicist and chemist</li><li><b>Awards: 4</b>(Nobel Prize in Physics, Nobel Prize in Chemistry, Davy Medal, Matteucci Medal)</li><li><b>Discovered:</b>polonium (chemical element)</li></ul></section><sectionclassName=\"profile\"><h2>Katsuko Saruhashi</h2><imgclassName=\"avatar\"src={getImageUrl('YfeOqp2')}alt=\"Katsuko Saruhashi\"width={70}height={70}/><ul><li><b>Profession:</b>geochemist</li><li><b>Awards: 2</b>(Miyake Prize for geochemistry, Tanaka Prize)</li><li><b>Discovered:</b>a method for measuring carbon dioxide in seawater</li></ul></section></div>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/preserving-and-resetting-state",
            "title": "Preserving and Resetting State – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Preserving and Resetting State"
                },
                {
                    "type": "p",
                    "text": "State is isolated between components. React keeps track of which state belongs to which component based on their place in the UI tree. You can control when to preserve state and when to reset it between re-renders."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "When React chooses to preserve or reset the state",
                        "How to force React to reset component’s state",
                        "How keys and types affect whether the state is preserved"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "State is tied to a position in the render tree"
                },
                {
                    "type": "p",
                    "text": "React buildsrender treesfor the component structure in your UI."
                },
                {
                    "type": "p",
                    "text": "When you give a component state, you might think the state “lives” inside the component. But the state is actually held inside React. React associates each piece of state it’s holding with the correct component by where that component sits in the render tree."
                },
                {
                    "type": "p",
                    "text": "Here, there is only one<Counter />JSX tag, but it’s rendered at two different positions:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionApp(){constcounter=<Counter/>;return(<div>{counter}{counter}</div>);}functionCounter(){const[score,setScore]=useState(0);const[hover,setHover]=useState(false);letclassName='counter';if(hover){className+=' hover';}return(<divclassName={className}onPointerEnter={()=>setHover(true)}onPointerLeave={()=>setHover(false)}><h1>{score}</h1><buttononClick={()=>setScore(score+1)}>Add one</button></div>);}"
                },
                {
                    "type": "p",
                    "text": "Here’s how these look as a tree:"
                },
                {
                    "type": "p",
                    "text": "React tree"
                },
                {
                    "type": "p",
                    "text": "These are two separate counters because each is rendered at its own position in the tree.You don’t usually have to think about these positions to use React, but it can be useful to understand how it works."
                },
                {
                    "type": "p",
                    "text": "In React, each component on the screen has fully isolated state. For example, if you render twoCountercomponents side by side, each of them will get its own, independent,scoreandhoverstates."
                },
                {
                    "type": "p",
                    "text": "Try clicking both counters and notice they don’t affect each other:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionApp(){return(<div><Counter/><Counter/></div>);}functionCounter(){const[score,setScore]=useState(0);const[hover,setHover]=useState(false);letclassName='counter';if(hover){className+=' hover';}return(<divclassName={className}onPointerEnter={()=>setHover(true)}onPointerLeave={()=>setHover(false)}><h1>{score}</h1><buttononClick={()=>setScore(score+1)}>Add one</button></div>);}"
                },
                {
                    "type": "p",
                    "text": "As you can see, when one counter is updated, only the state for that component is updated:"
                },
                {
                    "type": "p",
                    "text": "Updating state"
                },
                {
                    "type": "p",
                    "text": "React will keep the state around for as long as you render the same component at the same position in the tree. To see this, increment both counters, then remove the second component by unchecking “Render the second counter” checkbox, and then add it back by ticking it again:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionApp(){const[showB,setShowB]=useState(true);return(<div><Counter/>{showB&&<Counter/>}<label><inputtype=\"checkbox\"checked={showB}onChange={e=>{setShowB(e.target.checked)}}/>Render the second counter</label></div>);}functionCounter(){const[score,setScore]=useState(0);const[hover,setHover]=useState(false);letclassName='counter';if(hover){className+=' hover';}return(<divclassName={className}onPointerEnter={()=>setHover(true)}onPointerLeave={()=>setHover(false)}><h1>{score}</h1><buttononClick={()=>setScore(score+1)}>Add one</button></div>);}"
                },
                {
                    "type": "p",
                    "text": "Notice how the moment you stop rendering the second counter, its state disappears completely. That’s because when React removes a component, it destroys its state."
                },
                {
                    "type": "p",
                    "text": "Deleting a component"
                },
                {
                    "type": "p",
                    "text": "When you tick “Render the second counter”, a secondCounterand its state are initialized from scratch (score = 0) and added to the DOM."
                },
                {
                    "type": "p",
                    "text": "Adding a component"
                },
                {
                    "type": "p",
                    "text": "React preserves a component’s state for as long as it’s being rendered at its position in the UI tree.If it gets removed, or a different component gets rendered at the same position, React discards its state."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Same component at the same position preserves state"
                },
                {
                    "type": "p",
                    "text": "In this example, there are two different<Counter />tags:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionApp(){const[isFancy,setIsFancy]=useState(false);return(<div>{isFancy?(<CounterisFancy={true}/>):(<CounterisFancy={false}/>)}<label><inputtype=\"checkbox\"checked={isFancy}onChange={e=>{setIsFancy(e.target.checked)}}/>Use fancy styling</label></div>);}functionCounter({isFancy}){const[score,setScore]=useState(0);const[hover,setHover]=useState(false);letclassName='counter';if(hover){className+=' hover';}if(isFancy){className+=' fancy';}return(<divclassName={className}onPointerEnter={()=>setHover(true)}onPointerLeave={()=>setHover(false)}><h1>{score}</h1><buttononClick={()=>setScore(score+1)}>Add one</button></div>);}"
                },
                {
                    "type": "p",
                    "text": "When you tick or clear the checkbox, the counter state does not get reset. WhetherisFancyistrueorfalse, you always have a<Counter />as the first child of thedivreturned from the rootAppcomponent:"
                },
                {
                    "type": "p",
                    "text": "Updating theAppstate does not reset theCounterbecauseCounterstays in the same position"
                },
                {
                    "type": "p",
                    "text": "It’s the same component at the same position, so from React’s perspective, it’s the same counter."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Remember thatit’s the position in the UI tree—not in the JSX markup—that matters to React!This component has tworeturnclauses with different<Counter />JSX tags inside and outside theif:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionApp(){const[isFancy,setIsFancy]=useState(false);if(isFancy){return(<div><CounterisFancy={true}/><label><inputtype=\"checkbox\"checked={isFancy}onChange={e=>{setIsFancy(e.target.checked)}}/>Use fancy styling</label></div>);}return(<div><CounterisFancy={false}/><label><inputtype=\"checkbox\"checked={isFancy}onChange={e=>{setIsFancy(e.target.checked)}}/>Use fancy styling</label></div>);}functionCounter({isFancy}){const[score,setScore]=useState(0);const[hover,setHover]=useState(false);letclassName='counter';if(hover){className+=' hover';}if(isFancy){className+=' fancy';}return(<divclassName={className}onPointerEnter={()=>setHover(true)}onPointerLeave={()=>setHover(false)}><h1>{score}</h1><buttononClick={()=>setScore(score+1)}>Add one</button></div>);}"
                },
                {
                    "type": "p",
                    "text": "You might expect the state to reset when you tick checkbox, but it doesn’t! This is becauseboth of these<Counter />tags are rendered at the same position.React doesn’t know where you place the conditions in your function. All it “sees” is the tree you return."
                },
                {
                    "type": "p",
                    "text": "In both cases, theAppcomponent returns a<div>with<Counter />as a first child. To React, these two counters have the same “address”: the first child of the first child of the root. This is how React matches them up between the previous and next renders, regardless of how you structure your logic."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Different components at the same position reset state"
                },
                {
                    "type": "p",
                    "text": "In this example, ticking the checkbox will replace<Counter>with a<p>:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionApp(){const[isPaused,setIsPaused]=useState(false);return(<div>{isPaused?(<p>See you later!</p>):(<Counter/>)}<label><inputtype=\"checkbox\"checked={isPaused}onChange={e=>{setIsPaused(e.target.checked)}}/>Take a break</label></div>);}functionCounter(){const[score,setScore]=useState(0);const[hover,setHover]=useState(false);letclassName='counter';if(hover){className+=' hover';}return(<divclassName={className}onPointerEnter={()=>setHover(true)}onPointerLeave={()=>setHover(false)}><h1>{score}</h1><buttononClick={()=>setScore(score+1)}>Add one</button></div>);}"
                },
                {
                    "type": "p",
                    "text": "Here, you switch betweendifferentcomponent types at the same position. Initially, the first child of the<div>contained aCounter. But when you swapped in ap, React removed theCounterfrom the UI tree and destroyed its state."
                },
                {
                    "type": "p",
                    "text": "WhenCounterchanges top, theCounteris deleted and thepis added"
                },
                {
                    "type": "p",
                    "text": "When switching back, thepis deleted and theCounteris added"
                },
                {
                    "type": "p",
                    "text": "Also,when you render a different component in the same position, it resets the state of its entire subtree.To see how this works, increment the counter and then tick the checkbox:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionApp(){const[isFancy,setIsFancy]=useState(false);return(<div>{isFancy?(<div><CounterisFancy={true}/></div>):(<section><CounterisFancy={false}/></section>)}<label><inputtype=\"checkbox\"checked={isFancy}onChange={e=>{setIsFancy(e.target.checked)}}/>Use fancy styling</label></div>);}functionCounter({isFancy}){const[score,setScore]=useState(0);const[hover,setHover]=useState(false);letclassName='counter';if(hover){className+=' hover';}if(isFancy){className+=' fancy';}return(<divclassName={className}onPointerEnter={()=>setHover(true)}onPointerLeave={()=>setHover(false)}><h1>{score}</h1><buttononClick={()=>setScore(score+1)}>Add one</button></div>);}"
                },
                {
                    "type": "p",
                    "text": "The counter state gets reset when you click the checkbox. Although you render aCounter, the first child of thedivchanges from adivto asection. When the childdivwas removed from the DOM, the whole tree below it (including theCounterand its state) was destroyed as well."
                },
                {
                    "type": "p",
                    "text": "Whensectionchanges todiv, thesectionis deleted and the newdivis added"
                },
                {
                    "type": "p",
                    "text": "When switching back, thedivis deleted and the newsectionis added"
                },
                {
                    "type": "p",
                    "text": "As a rule of thumb,if you want to preserve the state between re-renders, the structure of your tree needs to “match up”from one render to another. If the structure is different, the state gets destroyed because React destroys state when it removes a component from the tree."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "This is why you should not nest component function definitions."
                },
                {
                    "type": "p",
                    "text": "Here, theMyTextFieldcomponent function is definedinsideMyComponent:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionMyComponent(){const[counter,setCounter]=useState(0);functionMyTextField(){const[text,setText]=useState('');return(<inputvalue={text}onChange={e=>setText(e.target.value)}/>);}return(<><MyTextField/><buttononClick={()=>{setCounter(counter+1)}}>Clicked{counter}times</button></>);}"
                },
                {
                    "type": "p",
                    "text": "Every time you click the button, the input state disappears! This is because adifferentMyTextFieldfunction is created for every render ofMyComponent. You’re rendering adifferentcomponent in the same position, so React resets all state below. This leads to bugs and performance problems. To avoid this problem,always declare component functions at the top level, and don’t nest their definitions."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Resetting state at the same position"
                },
                {
                    "type": "p",
                    "text": "By default, React preserves state of a component while it stays at the same position. Usually, this is exactly what you want, so it makes sense as the default behavior. But sometimes, you may want to reset a component’s state. Consider this app that lets two players keep track of their scores during each turn:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionScoreboard(){const[isPlayerA,setIsPlayerA]=useState(true);return(<div>{isPlayerA?(<Counterperson=\"Taylor\"/>):(<Counterperson=\"Sarah\"/>)}<buttononClick={()=>{setIsPlayerA(!isPlayerA);}}>Next player!</button></div>);}functionCounter({person}){const[score,setScore]=useState(0);const[hover,setHover]=useState(false);letclassName='counter';if(hover){className+=' hover';}return(<divclassName={className}onPointerEnter={()=>setHover(true)}onPointerLeave={()=>setHover(false)}><h1>{person}'s score:{score}</h1><buttononClick={()=>setScore(score+1)}>Add one</button></div>);}"
                },
                {
                    "type": "p",
                    "text": "Currently, when you change the player, the score is preserved. The twoCounters appear in the same position, so React sees them asthe sameCounterwhosepersonprop has changed."
                },
                {
                    "type": "p",
                    "text": "But conceptually, in this app they should be two separate counters. They might appear in the same place in the UI, but one is a counter for Taylor, and another is a counter for Sarah."
                },
                {
                    "type": "p",
                    "text": "There are two ways to reset state when switching between them:"
                },
                {
                    "type": "list",
                    "items": [
                        "Render components in different positions",
                        "Give each component an explicit identity withkey"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Option 1: Rendering a component in different positions"
                },
                {
                    "type": "p",
                    "text": "If you want these twoCounters to be independent, you can render them in two different positions:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionScoreboard(){const[isPlayerA,setIsPlayerA]=useState(true);return(<div>{isPlayerA&&<Counterperson=\"Taylor\"/>}{!isPlayerA&&<Counterperson=\"Sarah\"/>}<buttononClick={()=>{setIsPlayerA(!isPlayerA);}}>Next player!</button></div>);}functionCounter({person}){const[score,setScore]=useState(0);const[hover,setHover]=useState(false);letclassName='counter';if(hover){className+=' hover';}return(<divclassName={className}onPointerEnter={()=>setHover(true)}onPointerLeave={()=>setHover(false)}><h1>{person}'s score:{score}</h1><buttononClick={()=>setScore(score+1)}>Add one</button></div>);}"
                },
                {
                    "type": "list",
                    "items": [
                        "Initially,isPlayerAistrue. So the first position containsCounterstate, and the second one is empty.",
                        "When you click the “Next player” button the first position clears but the second one now contains aCounter."
                    ]
                },
                {
                    "type": "p",
                    "text": "Initial state"
                },
                {
                    "type": "p",
                    "text": "Clicking “next”"
                },
                {
                    "type": "p",
                    "text": "Clicking “next” again"
                },
                {
                    "type": "p",
                    "text": "EachCounter’s state gets destroyed each time it’s removed from the DOM. This is why they reset every time you click the button."
                },
                {
                    "type": "p",
                    "text": "This solution is convenient when you only have a few independent components rendered in the same place. In this example, you only have two, so it’s not a hassle to render both separately in the JSX."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Option 2: Resetting state with a key"
                },
                {
                    "type": "p",
                    "text": "There is also another, more generic, way to reset a component’s state."
                },
                {
                    "type": "p",
                    "text": "You might have seenkeys whenrendering lists.Keys aren’t just for lists! You can use keys to make React distinguish between any components. By default, React uses order within the parent (“first counter”, “second counter”) to discern between components. But keys let you tell React that this is not just afirstcounter, or asecondcounter, but a specific counter—for example,Taylor’scounter. This way, React will knowTaylor’scounter wherever it appears in the tree!"
                },
                {
                    "type": "p",
                    "text": "In this example, the two<Counter />s don’t share state even though they appear in the same place in JSX:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionScoreboard(){const[isPlayerA,setIsPlayerA]=useState(true);return(<div>{isPlayerA?(<Counterkey=\"Taylor\"person=\"Taylor\"/>):(<Counterkey=\"Sarah\"person=\"Sarah\"/>)}<buttononClick={()=>{setIsPlayerA(!isPlayerA);}}>Next player!</button></div>);}functionCounter({person}){const[score,setScore]=useState(0);const[hover,setHover]=useState(false);letclassName='counter';if(hover){className+=' hover';}return(<divclassName={className}onPointerEnter={()=>setHover(true)}onPointerLeave={()=>setHover(false)}><h1>{person}'s score:{score}</h1><buttononClick={()=>setScore(score+1)}>Add one</button></div>);}"
                },
                {
                    "type": "p",
                    "text": "Switching between Taylor and Sarah does not preserve the state. This is becauseyou gave them differentkeys:"
                },
                {
                    "type": "code",
                    "code": "{isPlayerA?(<Counterkey=\"Taylor\"person=\"Taylor\"/>):(<Counterkey=\"Sarah\"person=\"Sarah\"/>)}"
                },
                {
                    "type": "p",
                    "text": "Specifying akeytells React to use thekeyitself as part of the position, instead of their order within the parent. This is why, even though you render them in the same place in JSX, React sees them as two different counters, and so they will never share state. Every time a counter appears on the screen, its state is created. Every time it is removed, its state is destroyed. Toggling between them resets their state over and over."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Remember that keys are not globally unique. They only specify the positionwithin the parent."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Resetting a form with a key"
                },
                {
                    "type": "p",
                    "text": "Resetting state with a key is particularly useful when dealing with forms."
                },
                {
                    "type": "p",
                    "text": "In this chat app, the<Chat>component contains the text input state:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';importChatfrom'./Chat.js';importContactListfrom'./ContactList.js';exportdefaultfunctionMessenger(){const[to,setTo]=useState(contacts[0]);return(<div><ContactListcontacts={contacts}selectedContact={to}onSelect={contact=>setTo(contact)}/><Chatcontact={to}/></div>)}constcontacts=[{id:0,name:'Taylor',email:'taylor@mail.com'},{id:1,name:'Alice',email:'alice@mail.com'},{id:2,name:'Bob',email:'bob@mail.com'}];"
                },
                {
                    "type": "p",
                    "text": "Try entering something into the input, and then press “Alice” or “Bob” to choose a different recipient. You will notice that the input state is preserved because the<Chat>is rendered at the same position in the tree."
                },
                {
                    "type": "p",
                    "text": "In many apps, this may be the desired behavior, but not in a chat app!You don’t want to let the user send a message they already typed to a wrong person due to an accidental click. To fix it, add akey:"
                },
                {
                    "type": "code",
                    "code": "<Chatkey={to.id}contact={to}/>"
                },
                {
                    "type": "p",
                    "text": "This ensures that when you select a different recipient, theChatcomponent will be recreated from scratch, including any state in the tree below it. React will also re-create the DOM elements instead of reusing them."
                },
                {
                    "type": "p",
                    "text": "Now switching the recipient always clears the text field:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';importChatfrom'./Chat.js';importContactListfrom'./ContactList.js';exportdefaultfunctionMessenger(){const[to,setTo]=useState(contacts[0]);return(<div><ContactListcontacts={contacts}selectedContact={to}onSelect={contact=>setTo(contact)}/><Chatkey={to.id}contact={to}/></div>)}constcontacts=[{id:0,name:'Taylor',email:'taylor@mail.com'},{id:1,name:'Alice',email:'alice@mail.com'},{id:2,name:'Bob',email:'bob@mail.com'}];"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Preserving state for removed components"
                },
                {
                    "type": "p",
                    "text": "In a real chat app, you’d probably want to recover the input state when the user selects the previous recipient again. There are a few ways to keep the state “alive” for a component that’s no longer visible:"
                },
                {
                    "type": "list",
                    "items": [
                        "You could renderallchats instead of just the current one, but hide all the others with CSS. The chats would not get removed from the tree, so their local state would be preserved. This solution works great for simple UIs. But it can get very slow if the hidden trees are large and contain a lot of DOM nodes.",
                        "You couldlift the state upand hold the pending message for each recipient in the parent component. This way, when the child components get removed, it doesn’t matter, because it’s the parent that keeps the important information. This is the most common solution.",
                        "You might also use a different source in addition to React state. For example, you probably want a message draft to persist even if the user accidentally closes the page. To implement this, you could have theChatcomponent initialize its state by reading from thelocalStorage, and save the drafts there too."
                    ]
                },
                {
                    "type": "p",
                    "text": "No matter which strategy you pick, a chatwith Aliceis conceptually distinct from a chatwith Bob, so it makes sense to give akeyto the<Chat>tree based on the current recipient."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "React keeps state for as long as the same component is rendered at the same position.",
                        "State is not kept in JSX tags. It’s associated with the tree position in which you put that JSX.",
                        "You can force a subtree to reset its state by giving it a different key.",
                        "Don’t nest component definitions, or you’ll reset state by accident."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of5:Fix disappearing input text"
                },
                {
                    "type": "p",
                    "text": "This example shows a message when you press the button. However, pressing the button also accidentally resets the input. Why does this happen? Fix it so that pressing the button does not reset the input text."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionApp(){const[showHint,setShowHint]=useState(false);if(showHint){return(<div><p><i>Hint: Your favorite city?</i></p><Form/><buttononClick={()=>{setShowHint(false);}}>Hide hint</button></div>);}return(<div><Form/><buttononClick={()=>{setShowHint(true);}}>Show hint</button></div>);}functionForm(){const[text,setText]=useState('');return(<textareavalue={text}onChange={e=>setText(e.target.value)}/>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/queueing-a-series-of-state-updates",
            "title": "Queueing a Series of State Updates – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Queueing a Series of State Updates"
                },
                {
                    "type": "p",
                    "text": "Setting a state variable will queue another render. But sometimes you might want to perform multiple operations on the value before queueing the next render. To do this, it helps to understand how React batches state updates."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "What “batching” is and how React uses it to process multiple state updates",
                        "How to apply several updates to the same state variable in a row"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "React batches state updates"
                },
                {
                    "type": "p",
                    "text": "You might expect that clicking the “+3” button will increment the counter three times because it callssetNumber(number + 1)three times:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionCounter(){const[number,setNumber]=useState(0);return(<><h1>{number}</h1><buttononClick={()=>{setNumber(number+1);setNumber(number+1);setNumber(number+1);}}>+3</button></>)}"
                },
                {
                    "type": "p",
                    "text": "However, as you might recall from the previous section,each render’s state values are fixed, so the value ofnumberinside the first render’s event handler is always0, no matter how many times you callsetNumber(1):"
                },
                {
                    "type": "code",
                    "code": "setNumber(0+1);setNumber(0+1);setNumber(0+1);"
                },
                {
                    "type": "p",
                    "text": "But there is one other factor at play here.React waits untilallcode in the event handlers has run before processing your state updates.This is why the re-render only happensafterall thesesetNumber()calls."
                },
                {
                    "type": "p",
                    "text": "This might remind you of a waiter taking an order at the restaurant. A waiter doesn’t run to the kitchen at the mention of your first dish! Instead, they let you finish your order, let you make changes to it, and even take orders from other people at the table."
                },
                {
                    "type": "p",
                    "text": "Illustrated byRachel Lee Nabors"
                },
                {
                    "type": "p",
                    "text": "This lets you update multiple state variables—even from multiple components—without triggering too manyre-renders.But this also means that the UI won’t be updated untilafteryour event handler, and any code in it, completes. This behavior, also known asbatching,makes your React app run much faster. It also avoids dealing with confusing “half-finished” renders where only some of the variables have been updated."
                },
                {
                    "type": "p",
                    "text": "React does not batch acrossmultipleintentional events like clicks—each click is handled separately. Rest assured that React only does batching when it’s generally safe to do. This ensures that, for example, if the first button click disables a form, the second click would not submit it again."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Updating the same state multiple times before the next render"
                },
                {
                    "type": "p",
                    "text": "It is an uncommon use case, but if you would like to update the same state variable multiple times before the next render, instead of passing thenext state valuelikesetNumber(number + 1), you can pass afunctionthat calculates the next state based on the previous one in the queue, likesetNumber(n => n + 1). It is a way to tell React to “do something with the state value” instead of just replacing it."
                },
                {
                    "type": "p",
                    "text": "Try incrementing the counter now:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionCounter(){const[number,setNumber]=useState(0);return(<><h1>{number}</h1><buttononClick={()=>{setNumber(n=>n+1);setNumber(n=>n+1);setNumber(n=>n+1);}}>+3</button></>)}"
                },
                {
                    "type": "p",
                    "text": "Here,n => n + 1is called anupdater function.When you pass it to a state setter:"
                },
                {
                    "type": "list",
                    "items": [
                        "React queues this function to be processed after all the other code in the event handler has run.",
                        "During the next render, React goes through the queue and gives you the final updated state."
                    ]
                },
                {
                    "type": "code",
                    "code": "setNumber(n=>n+1);setNumber(n=>n+1);setNumber(n=>n+1);"
                },
                {
                    "type": "p",
                    "text": "Here’s how React works through these lines of code while executing the event handler:"
                },
                {
                    "type": "list",
                    "items": [
                        "setNumber(n => n + 1):n => n + 1is a function. React adds it to a queue.",
                        "setNumber(n => n + 1):n => n + 1is a function. React adds it to a queue.",
                        "setNumber(n => n + 1):n => n + 1is a function. React adds it to a queue."
                    ]
                },
                {
                    "type": "p",
                    "text": "When you calluseStateduring the next render, React goes through the queue. The previousnumberstate was0, so that’s what React passes to the first updater function as thenargument. Then React takes the return value of your previous updater function and passes it to the next updater asn, and so on:"
                },
                {
                    "type": "p",
                    "text": "React stores3as the final result and returns it fromuseState."
                },
                {
                    "type": "p",
                    "text": "This is why clicking “+3” in the above example correctly increments the value by 3."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "What happens if you update state after replacing it"
                },
                {
                    "type": "p",
                    "text": "What about this event handler? What do you thinknumberwill be in the next render?"
                },
                {
                    "type": "code",
                    "code": "<buttononClick={()=>{setNumber(number+5);setNumber(n=>n+1);}}>"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionCounter(){const[number,setNumber]=useState(0);return(<><h1>{number}</h1><buttononClick={()=>{setNumber(number+5);setNumber(n=>n+1);}}>Increase the number</button></>)}"
                },
                {
                    "type": "p",
                    "text": "Here’s what this event handler tells React to do:"
                },
                {
                    "type": "list",
                    "items": [
                        "setNumber(number + 5):numberis0, sosetNumber(0 + 5). React adds“replace with5”to its queue.",
                        "setNumber(n => n + 1):n => n + 1is an updater function. React addsthat functionto its queue."
                    ]
                },
                {
                    "type": "p",
                    "text": "During the next render, React goes through the state queue:"
                },
                {
                    "type": "p",
                    "text": "React stores6as the final result and returns it fromuseState."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "You may have noticed thatsetState(5)actually works likesetState(n => 5), butnis unused!"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "What happens if you replace state after updating it"
                },
                {
                    "type": "p",
                    "text": "Let’s try one more example. What do you thinknumberwill be in the next render?"
                },
                {
                    "type": "code",
                    "code": "<buttononClick={()=>{setNumber(number+5);setNumber(n=>n+1);setNumber(42);}}>"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionCounter(){const[number,setNumber]=useState(0);return(<><h1>{number}</h1><buttononClick={()=>{setNumber(number+5);setNumber(n=>n+1);setNumber(42);}}>Increase the number</button></>)}"
                },
                {
                    "type": "p",
                    "text": "Here’s how React works through these lines of code while executing this event handler:"
                },
                {
                    "type": "list",
                    "items": [
                        "setNumber(number + 5):numberis0, sosetNumber(0 + 5). React adds“replace with5”to its queue.",
                        "setNumber(n => n + 1):n => n + 1is an updater function. React addsthat functionto its queue.",
                        "setNumber(42): React adds“replace with42”to its queue."
                    ]
                },
                {
                    "type": "p",
                    "text": "During the next render, React goes through the state queue:"
                },
                {
                    "type": "p",
                    "text": "Then React stores42as the final result and returns it fromuseState."
                },
                {
                    "type": "p",
                    "text": "To summarize, here’s how you can think of what you’re passing to thesetNumberstate setter:"
                },
                {
                    "type": "list",
                    "items": [
                        "An updater function(e.g.n => n + 1) gets added to the queue.",
                        "Any other value(e.g. number5) adds “replace with5” to the queue, ignoring what’s already queued."
                    ]
                },
                {
                    "type": "p",
                    "text": "After the event handler completes, React will trigger a re-render. During the re-render, React will process the queue. Updater functions run during rendering, soupdater functions must bepureand onlyreturnthe result. Don’t try to set state from inside of them or run other side effects. In Strict Mode, React will run each updater function twice (but discard the second result) to help you find mistakes."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Naming conventions"
                },
                {
                    "type": "p",
                    "text": "It’s common to name the updater function argument by the first letters of the corresponding state variable:"
                },
                {
                    "type": "code",
                    "code": "setEnabled(e=>!e);setLastName(ln=>ln.reverse());setFriendCount(fc=>fc*2);"
                },
                {
                    "type": "p",
                    "text": "If you prefer more verbose code, another common convention is to repeat the full state variable name, likesetEnabled(enabled => !enabled), or to use a prefix likesetEnabled(prevEnabled => !prevEnabled)."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "Setting state does not change the variable in the existing render, but it requests a new render.",
                        "React processes state updates after event handlers have finished running. This is called batching.",
                        "To update some state multiple times in one event, you can usesetNumber(n => n + 1)updater function."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of2:Fix a request counter"
                },
                {
                    "type": "p",
                    "text": "You’re working on an art marketplace app that lets the user submit multiple orders for an art item at the same time. Each time the user presses the “Buy” button, the “Pending” counter should increase by one. After three seconds, the “Pending” counter should decrease, and the “Completed” counter should increase."
                },
                {
                    "type": "p",
                    "text": "However, the “Pending” counter does not behave as intended. When you press “Buy”, it decreases to-1(which should not be possible!). And if you click fast twice, both counters seem to behave unpredictably."
                },
                {
                    "type": "p",
                    "text": "Why does this happen? Fix both counters."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionRequestTracker(){const[pending,setPending]=useState(0);const[completed,setCompleted]=useState(0);asyncfunctionhandleClick(){setPending(pending+1);awaitdelay(3000);setPending(pending-1);setCompleted(completed+1);}return(<><h3>Pending:{pending}</h3><h3>Completed:{completed}</h3><buttononClick={handleClick}>Buy</button></>);}functiondelay(ms){returnnewPromise(resolve=>{setTimeout(resolve,ms);});}"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/react-compiler",
            "title": "React Compiler – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "React Compiler"
                },
                {
                    "type": "p",
                    "text": "This page will give you an introduction to React Compiler and how to try it out successfully."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Under Construction"
                },
                {
                    "type": "p",
                    "text": "These docs are still a work in progress. More documentation is available in theReact Compiler Working Group repo, and will be upstreamed into these docs when they are more stable."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "Getting started with the compiler",
                        "Installing the compiler and eslint plugin",
                        "Troubleshooting"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "React Compiler is a new compiler currently in Beta, that we’ve open sourced to get early feedback from the community. While it has been used in production at companies like Meta, rolling out the compiler to production for your app will depend on the health of your codebase and how well you’ve followed theRules of React."
                },
                {
                    "type": "p",
                    "text": "The latest Beta release can be found with the@betatag, and daily experimental releases with@experimental."
                },
                {
                    "type": "p",
                    "text": "React Compiler is a new compiler that we’ve open sourced to get early feedback from the community. It is a build-time only tool that automatically optimizes your React app. It works with plain JavaScript, and understands theRules of React, so you don’t need to rewrite any code to use it."
                },
                {
                    "type": "p",
                    "text": "The compiler also includes aneslint pluginthat surfaces the analysis from the compiler right in your editor.We strongly recommend everyone use the linter today.The linter does not require that you have the compiler installed, so you can use it even if you are not ready to try out the compiler."
                },
                {
                    "type": "p",
                    "text": "The compiler is currently released asbeta, and is available to try out on React 17+ apps and libraries. To install the Beta:"
                },
                {
                    "type": "p",
                    "text": "Or, if you’re using Yarn:"
                },
                {
                    "type": "p",
                    "text": "If you are not using React 19 yet, please seethe section belowfor further instructions."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "What does the compiler do?"
                },
                {
                    "type": "p",
                    "text": "In order to optimize applications, React Compiler automatically memoizes your code. You may be familiar today with memoization through APIs such asuseMemo,useCallback, andReact.memo. With these APIs you can tell React that certain parts of your application don’t need to recompute if their inputs haven’t changed, reducing work on updates. While powerful, it’s easy to forget to apply memoization or apply them incorrectly. This can lead to inefficient updates as React has to check parts of your UI that don’t have anymeaningfulchanges."
                },
                {
                    "type": "p",
                    "text": "The compiler uses its knowledge of JavaScript and React’s rules to automatically memoize values or groups of values within your components and hooks. If it detects breakages of the rules, it will automatically skip over just those components or hooks, and continue safely compiling other code."
                },
                {
                    "type": "p",
                    "text": "If your codebase is already very well-memoized, you might not expect to see major performance improvements with the compiler. However, in practice memoizing the correct dependencies that cause performance issues is tricky to get right by hand."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "What kind of memoization does React Compiler add?"
                },
                {
                    "type": "p",
                    "text": "The initial release of React Compiler is primarily focused onimproving update performance(re-rendering existing components), so it focuses on these two use cases:"
                },
                {
                    "type": "list",
                    "items": [
                        "Skipping cascading re-rendering of componentsRe-rendering<Parent />causes many components in its component tree to re-render, even though only<Parent />has changed",
                        "Re-rendering<Parent />causes many components in its component tree to re-render, even though only<Parent />has changed",
                        "Skipping expensive calculations from outside of ReactFor example, callingexpensivelyProcessAReallyLargeArrayOfObjects()inside of your component or hook that needs that data",
                        "For example, callingexpensivelyProcessAReallyLargeArrayOfObjects()inside of your component or hook that needs that data"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Re-rendering<Parent />causes many components in its component tree to re-render, even though only<Parent />has changed"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "For example, callingexpensivelyProcessAReallyLargeArrayOfObjects()inside of your component or hook that needs that data"
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Optimizing Re-renders"
                },
                {
                    "type": "p",
                    "text": "React lets you express your UI as a function of their current state (more concretely: their props, state, and context). In its current implementation, when a component’s state changes, React will re-render that componentand all of its children— unless you have applied some form of manual memoization withuseMemo(),useCallback(), orReact.memo(). For example, in the following example,<MessageButton>will re-render whenever<FriendList>’s state changes:"
                },
                {
                    "type": "code",
                    "code": "functionFriendList({friends}){constonlineCount=useFriendOnlineCount();if(friends.length===0){return<NoFriends/>;}return(<div><span>{onlineCount}online</span>{friends.map((friend)=>(<FriendListCardkey={friend.id}friend={friend}/>))}<MessageButton/></div>);}"
                },
                {
                    "type": "p",
                    "text": "See this example in the React Compiler Playground"
                },
                {
                    "type": "p",
                    "text": "React Compiler automatically applies the equivalent of manual memoization, ensuring that only the relevant parts of an app re-render as state changes, which is sometimes referred to as “fine-grained reactivity”. In the above example, React Compiler determines that the return value of<FriendListCard />can be reused even asfriendschanges, and can avoid recreating this JSXandavoid re-rendering<MessageButton>as the count changes."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Expensive calculations also get memoized"
                },
                {
                    "type": "p",
                    "text": "The compiler can also automatically memoize for expensive calculations used during rendering:"
                },
                {
                    "type": "code",
                    "code": "// **Not** memoized by React Compiler, since this is not a component or hookfunctionexpensivelyProcessAReallyLargeArrayOfObjects(){/* ... */}// Memoized by React Compiler since this is a componentfunctionTableContainer({items}){// This function call would be memoized:constdata=expensivelyProcessAReallyLargeArrayOfObjects(items);// ...}"
                },
                {
                    "type": "p",
                    "text": "See this example in the React Compiler Playground"
                },
                {
                    "type": "p",
                    "text": "However, ifexpensivelyProcessAReallyLargeArrayOfObjectsis truly an expensive function, you may want to consider implementing its own memoization outside of React, because:"
                },
                {
                    "type": "list",
                    "items": [
                        "React Compiler only memoizes React components and hooks, not every function",
                        "React Compiler’s memoization is not shared across multiple components or hooks"
                    ]
                },
                {
                    "type": "p",
                    "text": "So ifexpensivelyProcessAReallyLargeArrayOfObjectswas used in many different components, even if the same exact items were passed down, that expensive calculation would be run repeatedly. We recommendprofilingfirst to see if it really is that expensive before making code more complicated."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Should I try out the compiler?"
                },
                {
                    "type": "p",
                    "text": "Please note that the compiler is still in Beta and has many rough edges. While it has been used in production at companies like Meta, rolling out the compiler to production for your app will depend on the health of your codebase and how well you’ve followed theRules of React."
                },
                {
                    "type": "p",
                    "text": "You don’t have to rush into using the compiler now. It’s okay to wait until it reaches a stable release before adopting it.However, we do appreciate trying it out in small experiments in your apps so that you canprovide feedbackto us to help make the compiler better."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Getting Started"
                },
                {
                    "type": "p",
                    "text": "In addition to these docs, we recommend checking theReact Compiler Working Groupfor additional information and discussion about the compiler."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Checking compatibility"
                },
                {
                    "type": "p",
                    "text": "Prior to installing the compiler, you can first check to see if your codebase is compatible:"
                },
                {
                    "type": "p",
                    "text": "This script will:"
                },
                {
                    "type": "list",
                    "items": [
                        "Check how many components can be successfully optimized: higher is better",
                        "Check for<StrictMode>usage: having this enabled and followed means a higher chance that theRules of Reactare followed",
                        "Check for incompatible library usage: known libraries that are incompatible with the compiler"
                    ]
                },
                {
                    "type": "p",
                    "text": "As an example:"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Installing eslint-plugin-react-compiler"
                },
                {
                    "type": "p",
                    "text": "React Compiler also powers an eslint plugin. The eslint plugin can be usedindependentlyof the compiler, meaning you can use the eslint plugin even if you don’t use the compiler."
                },
                {
                    "type": "p",
                    "text": "Then, add it to your eslint config:"
                },
                {
                    "type": "code",
                    "code": "module.exports={plugins:['eslint-plugin-react-compiler',],rules:{'react-compiler/react-compiler':\"error\",},}"
                },
                {
                    "type": "p",
                    "text": "The eslint plugin will display any violations of the rules of React in your editor. When it does this, it means that the compiler has skipped over optimizing that component or hook. This is perfectly okay, and the compiler can recover and continue optimizing other components in your codebase."
                },
                {
                    "type": "p",
                    "text": "You don’t have to fix all eslint violations straight away.You can address them at your own pace to increase the amount of components and hooks being optimized, but it is not required to fix everything before you can use the compiler."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rolling out the compiler to your codebase"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Existing projects"
                },
                {
                    "type": "p",
                    "text": "The compiler is designed to compile functional components and hooks that follow theRules of React. It can also handle code that breaks those rules by bailing out (skipping over) those components or hooks. However, due to the flexible nature of JavaScript, the compiler cannot catch every possible violation and may compile with false negatives: that is, the compiler may accidentally compile a component/hook that breaks the Rules of React which can lead to undefined behavior."
                },
                {
                    "type": "p",
                    "text": "For this reason, to adopt the compiler successfully on existing projects, we recommend running it on a small directory in your product code first. You can do this by configuring the compiler to only run on a specific set of directories:"
                },
                {
                    "type": "code",
                    "code": "constReactCompilerConfig={sources:(filename)=>{returnfilename.indexOf('src/path/to/dir')!== -1;},};"
                },
                {
                    "type": "p",
                    "text": "When you have more confidence with rolling out the compiler, you can expand coverage to other directories as well and slowly roll it out to your whole app."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "New projects"
                },
                {
                    "type": "p",
                    "text": "If you’re starting a new project, you can enable the compiler on your entire codebase, which is the default behavior."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Using React Compiler with React 17 or 18"
                },
                {
                    "type": "p",
                    "text": "React Compiler works best with React 19 RC. If you are unable to upgrade, you can install the extrareact-compiler-runtimepackage which will allow the compiled code to run on versions prior to 19. However, note that the minimum supported version is 17."
                },
                {
                    "type": "p",
                    "text": "You should also add the correcttargetto your compiler config, wheretargetis the major version of React you are targeting:"
                },
                {
                    "type": "code",
                    "code": "// babel.config.jsconstReactCompilerConfig={target:'18'// '17' | '18' | '19'};module.exports=function(){return{plugins:[['babel-plugin-react-compiler',ReactCompilerConfig],],};};"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Using the compiler on libraries"
                },
                {
                    "type": "p",
                    "text": "React Compiler can also be used to compile libraries. Because React Compiler needs to run on the original source code prior to any code transformations, it is not possible for an application’s build pipeline to compile the libraries they use. Hence, our recommendation is for library maintainers to independently compile and test their libraries with the compiler, and ship compiled code to npm."
                },
                {
                    "type": "p",
                    "text": "Because your code is pre-compiled, users of your library will not need to have the compiler enabled in order to benefit from the automatic memoization applied to your library. If your library targets apps not yet on React 19, specify a minimumtargetand addreact-compiler-runtimeas a direct dependency. The runtime package will use the correct implementation of APIs depending on the application’s version, and polyfill the missing APIs if necessary."
                },
                {
                    "type": "p",
                    "text": "Library code can often require more complex patterns and usage of escape hatches. For this reason, we recommend ensuring that you have sufficient testing in order to identify any issues that might arise from using the compiler on your library. If you identify any issues, you can always opt-out the specific components or hooks with the'use no memo'directive."
                },
                {
                    "type": "p",
                    "text": "Similarly to apps, it is not necessary to fully compile 100% of your components or hooks to see benefits in your library. A good starting point might be to identify the most performance sensitive parts of your library and ensuring that they don’t break theRules of React, which you can useeslint-plugin-react-compilerto identify."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Babel"
                },
                {
                    "type": "p",
                    "text": "The compiler includes a Babel plugin which you can use in your build pipeline to run the compiler."
                },
                {
                    "type": "p",
                    "text": "After installing, add it to your Babel config. Please note that it’s critical that the compiler runfirstin the pipeline:"
                },
                {
                    "type": "code",
                    "code": "// babel.config.jsconstReactCompilerConfig={/* ... */};module.exports=function(){return{plugins:[['babel-plugin-react-compiler',ReactCompilerConfig],// must run first!// ...],};};"
                },
                {
                    "type": "p",
                    "text": "babel-plugin-react-compilershould run first before other Babel plugins as the compiler requires the input source information for sound analysis."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Vite"
                },
                {
                    "type": "p",
                    "text": "If you use Vite, you can add the plugin to vite-plugin-react:"
                },
                {
                    "type": "code",
                    "code": "// vite.config.jsconstReactCompilerConfig={/* ... */};exportdefaultdefineConfig(()=>{return{plugins:[react({babel:{plugins:[[\"babel-plugin-react-compiler\",ReactCompilerConfig],],},}),],// ...};});"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Next.js"
                },
                {
                    "type": "p",
                    "text": "Please refer to theNext.js docsfor more information."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Remix"
                },
                {
                    "type": "p",
                    "text": "Installvite-plugin-babel, and add the compiler’s Babel plugin to it:"
                },
                {
                    "type": "code",
                    "code": "// vite.config.jsimportbabelfrom\"vite-plugin-babel\";constReactCompilerConfig={/* ... */};exportdefaultdefineConfig({plugins:[remix({/* ... */}),babel({filter:/\\.[jt]sx?$/,babelConfig:{presets:[\"@babel/preset-typescript\"],// if you use TypeScriptplugins:[[\"babel-plugin-react-compiler\",ReactCompilerConfig],],},}),],});"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Webpack"
                },
                {
                    "type": "p",
                    "text": "A community Webpack loader isnow available here."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Expo"
                },
                {
                    "type": "p",
                    "text": "Please refer toExpo’s docsto enable and use the React Compiler in Expo apps."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Metro (React Native)"
                },
                {
                    "type": "p",
                    "text": "React Native uses Babel via Metro, so refer to theUsage with Babelsection for installation instructions."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rspack"
                },
                {
                    "type": "p",
                    "text": "Please refer toRspack’s docsto enable and use the React Compiler in Rspack apps."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rsbuild"
                },
                {
                    "type": "p",
                    "text": "Please refer toRsbuild’s docsto enable and use the React Compiler in Rsbuild apps."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "p",
                    "text": "To report issues, please first create a minimal repro on theReact Compiler Playgroundand include it in your bug report. You can open issues in thefacebook/reactrepo."
                },
                {
                    "type": "p",
                    "text": "You can also provide feedback in the React Compiler Working Group by applying to be a member. Please seethe README for more details on joining."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "What does the compiler assume?"
                },
                {
                    "type": "p",
                    "text": "React Compiler assumes that your code:"
                },
                {
                    "type": "list",
                    "items": [
                        "Is valid, semantic JavaScript.",
                        "Tests that nullable/optional values and properties are defined before accessing them (for example, by enablingstrictNullChecksif using TypeScript), i.e.,if (object.nullableProperty) { object.nullableProperty.foo }or with optional-chainingobject.nullableProperty?.foo.",
                        "Follows theRules of React."
                    ]
                },
                {
                    "type": "p",
                    "text": "React Compiler can verify many of the Rules of React statically, and will safely skip compilation when it detects an error. To see the errors we recommend also installingeslint-plugin-react-compiler."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "How do I know my components have been optimized?"
                },
                {
                    "type": "p",
                    "text": "React Devtools(v5.0+) has built-in support for React Compiler and will display a “Memo ✨” badge next to components that have been optimized by the compiler."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Something is not working after compilation"
                },
                {
                    "type": "p",
                    "text": "If you have eslint-plugin-react-compiler installed, the compiler will display any violations of the rules of React in your editor. When it does this, it means that the compiler has skipped over optimizing that component or hook. This is perfectly okay, and the compiler can recover and continue optimizing other components in your codebase.You don’t have to fix all eslint violations straight away.You can address them at your own pace to increase the amount of components and hooks being optimized."
                },
                {
                    "type": "p",
                    "text": "Due to the flexible and dynamic nature of JavaScript however, it’s not possible to comprehensively detect all cases. Bugs and undefined behavior such as infinite loops may occur in those cases."
                },
                {
                    "type": "p",
                    "text": "If your app doesn’t work properly after compilation and you aren’t seeing any eslint errors, the compiler may be incorrectly compiling your code. To confirm this, try to make the issue go away by aggressively opting out any component or hook you think might be related via the\"use no memo\"directive."
                },
                {
                    "type": "code",
                    "code": "functionSuspiciousComponent(){\"use no memo\";// opts out this component from being compiled by React Compiler// ...}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "\"use no memo\""
                },
                {
                    "type": "p",
                    "text": "\"use no memo\"is atemporaryescape hatch that lets you opt-out components and hooks from being compiled by the React Compiler. This directive is not meant to be long lived the same way as eg\"use client\"is."
                },
                {
                    "type": "p",
                    "text": "It is not recommended to reach for this directive unless it’s strictly necessary. Once you opt-out a component or hook, it is opted-out forever until the directive is removed. This means that even if you fix the code, the compiler will still skip over compiling it unless you remove the directive."
                },
                {
                    "type": "p",
                    "text": "When you make the error go away, confirm that removing the opt out directive makes the issue come back. Then share a bug report with us (you can try to reduce it to a small repro, or if it’s open source code you can also just paste the entire source) using theReact Compiler Playgroundso we can identify and help fix the issue."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Other issues"
                },
                {
                    "type": "p",
                    "text": "Please seehttps://github.com/reactwg/react-compiler/discussions/7."
                }
            ]
        },
        {
            "url": "https://react.dev/learn/react-developer-tools",
            "title": "React Developer Tools – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "React Developer Tools"
                },
                {
                    "type": "p",
                    "text": "Use React Developer Tools to inspect Reactcomponents, editpropsandstate, and identify performance problems."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "How to install React Developer Tools"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Browser extension"
                },
                {
                    "type": "p",
                    "text": "The easiest way to debug websites built with React is to install the React Developer Tools browser extension. It is available for several popular browsers:"
                },
                {
                    "type": "list",
                    "items": [
                        "Install forChrome",
                        "Install forFirefox",
                        "Install forEdge"
                    ]
                },
                {
                    "type": "p",
                    "text": "Now, if you visit a websitebuilt with React,you will see theComponentsandProfilerpanels."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Safari and other browsers"
                },
                {
                    "type": "p",
                    "text": "For other browsers (for example, Safari), install thereact-devtoolsnpm package:"
                },
                {
                    "type": "code",
                    "code": "#Yarnyarnglobaladdreact-devtools#Npmnpminstall-greact-devtools"
                },
                {
                    "type": "p",
                    "text": "Next open the developer tools from the terminal:"
                },
                {
                    "type": "code",
                    "code": "react-devtools"
                },
                {
                    "type": "p",
                    "text": "Then connect your website by adding the following<script>tag to the beginning of your website’s<head>:"
                },
                {
                    "type": "code",
                    "code": "<html><head><scriptsrc=\"http://localhost:8097\"></script>"
                },
                {
                    "type": "p",
                    "text": "Reload your website in the browser now to view it in developer tools."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Mobile (React Native)"
                },
                {
                    "type": "p",
                    "text": "React Developer Tools can be used to inspect apps built withReact Nativeas well."
                },
                {
                    "type": "p",
                    "text": "The easiest way to use React Developer Tools is to install it globally:"
                },
                {
                    "type": "code",
                    "code": "#Yarnyarnglobaladdreact-devtools#Npmnpminstall-greact-devtools"
                },
                {
                    "type": "p",
                    "text": "Next open the developer tools from the terminal."
                },
                {
                    "type": "code",
                    "code": "react-devtools"
                },
                {
                    "type": "p",
                    "text": "It should connect to any local React Native app that’s running."
                },
                {
                    "type": "p",
                    "text": "Try reloading the app if developer tools doesn’t connect after a few seconds."
                },
                {
                    "type": "p",
                    "text": "Learn more about debugging React Native."
                }
            ]
        },
        {
            "url": "https://react.dev/learn/reacting-to-input-with-state",
            "title": "Reacting to Input with State – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Reacting to Input with State"
                },
                {
                    "type": "p",
                    "text": "React provides a declarative way to manipulate the UI. Instead of manipulating individual pieces of the UI directly, you describe the different states that your component can be in, and switch between them in response to the user input. This is similar to how designers think about the UI."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "How declarative UI programming differs from imperative UI programming",
                        "How to enumerate the different visual states your component can be in",
                        "How to trigger the changes between the different visual states from code"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "How declarative UI compares to imperative"
                },
                {
                    "type": "p",
                    "text": "When you design UI interactions, you probably think about how the UIchangesin response to user actions. Consider a form that lets the user submit an answer:"
                },
                {
                    "type": "list",
                    "items": [
                        "When you type something into the form, the “Submit” buttonbecomes enabled.",
                        "When you press “Submit”, both the form and the buttonbecome disabled,and a spinnerappears.",
                        "If the network request succeeds, the formgets hidden,and the “Thank you” messageappears.",
                        "If the network request fails, an error messageappears,and the formbecomes enabledagain."
                    ]
                },
                {
                    "type": "p",
                    "text": "Inimperative programming,the above corresponds directly to how you implement interaction. You have to write the exact instructions to manipulate the UI depending on what just happened. Here’s another way to think about this: imagine riding next to someone in a car and telling them turn by turn where to go."
                },
                {
                    "type": "p",
                    "text": "Illustrated byRachel Lee Nabors"
                },
                {
                    "type": "p",
                    "text": "They don’t know where you want to go, they just follow your commands. (And if you get the directions wrong, you end up in the wrong place!) It’s calledimperativebecause you have to “command” each element, from the spinner to the button, telling the computerhowto update the UI."
                },
                {
                    "type": "p",
                    "text": "In this example of imperative UI programming, the form is builtwithoutReact. It only uses the browserDOM:"
                },
                {
                    "type": "code",
                    "code": "asyncfunctionhandleFormSubmit(e){e.preventDefault();disable(textarea);disable(button);show(loadingMessage);hide(errorMessage);try{awaitsubmitForm(textarea.value);show(successMessage);hide(form);}catch(err){show(errorMessage);errorMessage.textContent=err.message;}finally{hide(loadingMessage);enable(textarea);enable(button);}}functionhandleTextareaChange(){if(textarea.value.length===0){disable(button);}else{enable(button);}}functionhide(el){el.style.display='none';}functionshow(el){el.style.display='';}functionenable(el){el.disabled=false;}functiondisable(el){el.disabled=true;}functionsubmitForm(answer){// Pretend it's hitting the network.returnnewPromise((resolve,reject)=>{setTimeout(()=>{if(answer.toLowerCase()==='istanbul'){resolve();}else{reject(newError('Good guess but a wrong answer. Try again!'));}},1500);});}letform=document.getElementById('form');lettextarea=document.getElementById('textarea');letbutton=document.getElementById('button');letloadingMessage=document.getElementById('loading');leterrorMessage=document.getElementById('error');letsuccessMessage=document.getElementById('success');form.onsubmit=handleFormSubmit;textarea.oninput=handleTextareaChange;"
                },
                {
                    "type": "p",
                    "text": "Manipulating the UI imperatively works well enough for isolated examples, but it gets exponentially more difficult to manage in more complex systems. Imagine updating a page full of different forms like this one. Adding a new UI element or a new interaction would require carefully checking all existing code to make sure you haven’t introduced a bug (for example, forgetting to show or hide something)."
                },
                {
                    "type": "p",
                    "text": "React was built to solve this problem."
                },
                {
                    "type": "p",
                    "text": "In React, you don’t directly manipulate the UI—meaning you don’t enable, disable, show, or hide components directly. Instead, youdeclare what you want to show,and React figures out how to update the UI. Think of getting into a taxi and telling the driver where you want to go instead of telling them exactly where to turn. It’s the driver’s job to get you there, and they might even know some shortcuts you haven’t considered!"
                },
                {
                    "type": "p",
                    "text": "Illustrated byRachel Lee Nabors"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Thinking about UI declaratively"
                },
                {
                    "type": "p",
                    "text": "You’ve seen how to implement a form imperatively above. To better understand how to think in React, you’ll walk through reimplementing this UI in React below:"
                },
                {
                    "type": "list",
                    "items": [
                        "Identifyyour component’s different visual states",
                        "Determinewhat triggers those state changes",
                        "Representthe state in memory usinguseState",
                        "Removeany non-essential state variables",
                        "Connectthe event handlers to set the state"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 1: Identify your component’s different visual states"
                },
                {
                    "type": "p",
                    "text": "In computer science, you may hear about a“state machine”being in one of several “states”. If you work with a designer, you may have seen mockups for different “visual states”. React stands at the intersection of design and computer science, so both of these ideas are sources of inspiration."
                },
                {
                    "type": "p",
                    "text": "First, you need to visualize all the different “states” of the UI the user might see:"
                },
                {
                    "type": "list",
                    "items": [
                        "Empty: Form has a disabled “Submit” button.",
                        "Typing: Form has an enabled “Submit” button.",
                        "Submitting: Form is completely disabled. Spinner is shown.",
                        "Success: “Thank you” message is shown instead of a form.",
                        "Error: Same as Typing state, but with an extra error message."
                    ]
                },
                {
                    "type": "p",
                    "text": "Just like a designer, you’ll want to “mock up” or create “mocks” for the different states before you add logic. For example, here is a mock for just the visual part of the form. This mock is controlled by a prop calledstatuswith a default value of'empty':"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionForm({status='empty'}){if(status==='success'){return<h1>That's right!</h1>}return(<><h2>City quiz</h2><p>In which city is there a billboard that turns air into drinkable water?</p><form><textarea/><br/><button>Submit</button></form></>)}"
                },
                {
                    "type": "p",
                    "text": "You could call that prop anything you like, the naming is not important. Try editingstatus = 'empty'tostatus = 'success'to see the success message appear. Mocking lets you quickly iterate on the UI before you wire up any logic. Here is a more fleshed out prototype of the same component, still “controlled” by thestatusprop:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionForm({// Try 'submitting', 'error', 'success':status='empty'}){if(status==='success'){return<h1>That's right!</h1>}return(<><h2>City quiz</h2><p>In which city is there a billboard that turns air into drinkable water?</p><form><textareadisabled={status==='submitting'}/><br/><buttondisabled={status==='empty'||status==='submitting'}>Submit</button>{status==='error'&&<pclassName=\"Error\">Good guess but a wrong answer. Try again!</p>}</form></>);}"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Displaying many visual states at once"
                },
                {
                    "type": "p",
                    "text": "If a component has a lot of visual states, it can be convenient to show them all on one page:"
                },
                {
                    "type": "code",
                    "code": "importFormfrom'./Form.js';letstatuses=['empty','typing','submitting','success','error',];exportdefaultfunctionApp(){return(<>{statuses.map(status=>(<sectionkey={status}><h4>Form ({status}):</h4><Formstatus={status}/></section>))}</>);}"
                },
                {
                    "type": "p",
                    "text": "Pages like this are often called “living styleguides” or “storybooks”."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 2: Determine what triggers those state changes"
                },
                {
                    "type": "p",
                    "text": "You can trigger state updates in response to two kinds of inputs:"
                },
                {
                    "type": "list",
                    "items": [
                        "Human inputs,like clicking a button, typing in a field, navigating a link.",
                        "Computer inputs,like a network response arriving, a timeout completing, an image loading."
                    ]
                },
                {
                    "type": "p",
                    "text": "Illustrated byRachel Lee Nabors"
                },
                {
                    "type": "p",
                    "text": "In both cases,you must setstate variablesto update the UI.For the form you’re developing, you will need to change state in response to a few different inputs:"
                },
                {
                    "type": "list",
                    "items": [
                        "Changing the text input(human) should switch it from theEmptystate to theTypingstate or back, depending on whether the text box is empty or not.",
                        "Clicking the Submit button(human) should switch it to theSubmittingstate.",
                        "Successful network response(computer) should switch it to theSuccessstate.",
                        "Failed network response(computer) should switch it to theErrorstate with the matching error message."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Notice that human inputs often requireevent handlers!"
                },
                {
                    "type": "p",
                    "text": "To help visualize this flow, try drawing each state on paper as a labeled circle, and each change between two states as an arrow. You can sketch out many flows this way and sort out bugs long before implementation."
                },
                {
                    "type": "p",
                    "text": "Form states"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 3: Represent the state in memory withuseState"
                },
                {
                    "type": "p",
                    "text": "Next you’ll need to represent the visual states of your component in memory withuseState.Simplicity is key: each piece of state is a “moving piece”, andyou want as few “moving pieces” as possible.More complexity leads to more bugs!"
                },
                {
                    "type": "p",
                    "text": "Start with the state thatabsolutely mustbe there. For example, you’ll need to store theanswerfor the input, and theerror(if it exists) to store the last error:"
                },
                {
                    "type": "code",
                    "code": "const[answer,setAnswer]=useState('');const[error,setError]=useState(null);"
                },
                {
                    "type": "p",
                    "text": "Then, you’ll need a state variable representing which one of the visual states that you want to display. There’s usually more than a single way to represent that in memory, so you’ll need to experiment with it."
                },
                {
                    "type": "p",
                    "text": "If you struggle to think of the best way immediately, start by adding enough state that you’redefinitelysure that all the possible visual states are covered:"
                },
                {
                    "type": "code",
                    "code": "const[isEmpty,setIsEmpty]=useState(true);const[isTyping,setIsTyping]=useState(false);const[isSubmitting,setIsSubmitting]=useState(false);const[isSuccess,setIsSuccess]=useState(false);const[isError,setIsError]=useState(false);"
                },
                {
                    "type": "p",
                    "text": "Your first idea likely won’t be the best, but that’s ok—refactoring state is a part of the process!"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 4: Remove any non-essential state variables"
                },
                {
                    "type": "p",
                    "text": "You want to avoid duplication in the state content so you’re only tracking what is essential. Spending a little time on refactoring your state structure will make your components easier to understand, reduce duplication, and avoid unintended meanings. Your goal is toprevent the cases where the state in memory doesn’t represent any valid UI that you’d want a user to see.(For example, you never want to show an error message and disable the input at the same time, or the user won’t be able to correct the error!)"
                },
                {
                    "type": "p",
                    "text": "Here are some questions you can ask about your state variables:"
                },
                {
                    "type": "list",
                    "items": [
                        "Does this state cause a paradox?For example,isTypingandisSubmittingcan’t both betrue. A paradox usually means that the state is not constrained enough. There are four possible combinations of two booleans, but only three correspond to valid states. To remove the “impossible” state, you can combine these into astatusthat must be one of three values:'typing','submitting', or'success'.",
                        "Is the same information available in another state variable already?Another paradox:isEmptyandisTypingcan’t betrueat the same time. By making them separate state variables, you risk them going out of sync and causing bugs. Fortunately, you can removeisEmptyand instead checkanswer.length === 0.",
                        "Can you get the same information from the inverse of another state variable?isErroris not needed because you can checkerror !== nullinstead."
                    ]
                },
                {
                    "type": "p",
                    "text": "After this clean-up, you’re left with 3 (down from 7!)essentialstate variables:"
                },
                {
                    "type": "code",
                    "code": "const[answer,setAnswer]=useState('');const[error,setError]=useState(null);const[status,setStatus]=useState('typing');// 'typing', 'submitting', or 'success'"
                },
                {
                    "type": "p",
                    "text": "You know they are essential, because you can’t remove any of them without breaking the functionality."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Eliminating “impossible” states with a reducer"
                },
                {
                    "type": "p",
                    "text": "These three variables are a good enough representation of this form’s state. However, there are still some intermediate states that don’t fully make sense. For example, a non-nullerrordoesn’t make sense whenstatusis'success'. To model the state more precisely, you canextract it into a reducer.Reducers let you unify multiple state variables into a single object and consolidate all the related logic!"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 5: Connect the event handlers to set state"
                },
                {
                    "type": "p",
                    "text": "Lastly, create event handlers that update the state. Below is the final form, with all event handlers wired up:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionForm(){const[answer,setAnswer]=useState('');const[error,setError]=useState(null);const[status,setStatus]=useState('typing');if(status==='success'){return<h1>That's right!</h1>}asyncfunctionhandleSubmit(e){e.preventDefault();setStatus('submitting');try{awaitsubmitForm(answer);setStatus('success');}catch(err){setStatus('typing');setError(err);}}functionhandleTextareaChange(e){setAnswer(e.target.value);}return(<><h2>City quiz</h2><p>In which city is there a billboard that turns air into drinkable water?</p><formonSubmit={handleSubmit}><textareavalue={answer}onChange={handleTextareaChange}disabled={status==='submitting'}/><br/><buttondisabled={answer.length===0||status==='submitting'}>Submit</button>{error!==null&&<pclassName=\"Error\">{error.message}</p>}</form></>);}functionsubmitForm(answer){// Pretend it's hitting the network.returnnewPromise((resolve,reject)=>{setTimeout(()=>{letshouldError=answer.toLowerCase()!=='lima'if(shouldError){reject(newError('Good guess but a wrong answer. Try again!'));}else{resolve();}},1500);});}"
                },
                {
                    "type": "p",
                    "text": "Although this code is longer than the original imperative example, it is much less fragile. Expressing all interactions as state changes lets you later introduce new visual states without breaking existing ones. It also lets you change what should be displayed in each state without changing the logic of the interaction itself."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "Declarative programming means describing the UI for each visual state rather than micromanaging the UI (imperative).",
                        "When developing a component:Identify all its visual states.Determine the human and computer triggers for state changes.Model the state withuseState.Remove non-essential state to avoid bugs and paradoxes.Connect the event handlers to set state.",
                        "Identify all its visual states.",
                        "Determine the human and computer triggers for state changes.",
                        "Model the state withuseState.",
                        "Remove non-essential state to avoid bugs and paradoxes.",
                        "Connect the event handlers to set state."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Identify all its visual states.",
                        "Determine the human and computer triggers for state changes.",
                        "Model the state withuseState.",
                        "Remove non-essential state to avoid bugs and paradoxes.",
                        "Connect the event handlers to set state."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of3:Add and remove a CSS class"
                },
                {
                    "type": "p",
                    "text": "Make it so that clicking on the pictureremovesthebackground--activeCSS class from the outer<div>, butaddsthepicture--activeclass to the<img>. Clicking the background again should restore the original CSS classes."
                },
                {
                    "type": "p",
                    "text": "Visually, you should expect that clicking on the picture removes the purple background and highlights the picture border. Clicking outside the picture highlights the background, but removes the picture border highlight."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionPicture(){return(<divclassName=\"background background--active\"><imgclassName=\"picture\"alt=\"Rainbow houses in Kampung Pelangi, Indonesia\"src=\"https://i.imgur.com/5qwVYb1.jpeg\"/></div>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/referencing-values-with-refs",
            "title": "Referencing Values with Refs – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Referencing Values with Refs"
                },
                {
                    "type": "p",
                    "text": "When you want a component to “remember” some information, but you don’t want that information totrigger new renders, you can use aref."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "How to add a ref to your component",
                        "How to update a ref’s value",
                        "How refs are different from state",
                        "How to use refs safely"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Adding a ref to your component"
                },
                {
                    "type": "p",
                    "text": "You can add a ref to your component by importing theuseRefHook from React:"
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';"
                },
                {
                    "type": "p",
                    "text": "Inside your component, call theuseRefHook and pass the initial value that you want to reference as the only argument. For example, here is a ref to the value0:"
                },
                {
                    "type": "code",
                    "code": "constref=useRef(0);"
                },
                {
                    "type": "p",
                    "text": "useRefreturns an object like this:"
                },
                {
                    "type": "code",
                    "code": "{current:0// The value you passed to useRef}"
                },
                {
                    "type": "p",
                    "text": "Illustrated byRachel Lee Nabors"
                },
                {
                    "type": "p",
                    "text": "You can access the current value of that ref through theref.currentproperty. This value is intentionally mutable, meaning you can both read and write to it. It’s like a secret pocket of your component that React doesn’t track. (This is what makes it an “escape hatch” from React’s one-way data flow—more on that below!)"
                },
                {
                    "type": "p",
                    "text": "Here, a button will incrementref.currenton every click:"
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';exportdefaultfunctionCounter(){letref=useRef(0);functionhandleClick(){ref.current=ref.current+1;alert('You clicked '+ref.current+' times!');}return(<buttononClick={handleClick}>Click me!</button>);}"
                },
                {
                    "type": "p",
                    "text": "The ref points to a number, but, likestate, you could point to anything: a string, an object, or even a function. Unlike state, ref is a plain JavaScript object with thecurrentproperty that you can read and modify."
                },
                {
                    "type": "p",
                    "text": "Note thatthe component doesn’t re-render with every increment.Like state, refs are retained by React between re-renders. However, setting state re-renders a component. Changing a ref does not!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Example: building a stopwatch"
                },
                {
                    "type": "p",
                    "text": "You can combine refs and state in a single component. For example, let’s make a stopwatch that the user can start or stop by pressing a button. In order to display how much time has passed since the user pressed “Start”, you will need to keep track of when the Start button was pressed and what the current time is.This information is used for rendering, so you’ll keep it in state:"
                },
                {
                    "type": "code",
                    "code": "const[startTime,setStartTime]=useState(null);const[now,setNow]=useState(null);"
                },
                {
                    "type": "p",
                    "text": "When the user presses “Start”, you’ll usesetIntervalin order to update the time every 10 milliseconds:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionStopwatch(){const[startTime,setStartTime]=useState(null);const[now,setNow]=useState(null);functionhandleStart(){// Start counting.setStartTime(Date.now());setNow(Date.now());setInterval(()=>{// Update the current time every 10ms.setNow(Date.now());},10);}letsecondsPassed=0;if(startTime!=null&&now!=null){secondsPassed=(now-startTime)/1000;}return(<><h1>Time passed:{secondsPassed.toFixed(3)}</h1><buttononClick={handleStart}>Start</button></>);}"
                },
                {
                    "type": "p",
                    "text": "When the “Stop” button is pressed, you need to cancel the existing interval so that it stops updating thenowstate variable. You can do this by callingclearInterval, but you need to give it the interval ID that was previously returned by thesetIntervalcall when the user pressed Start. You need to keep the interval ID somewhere.Since the interval ID is not used for rendering, you can keep it in a ref:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useRef}from'react';exportdefaultfunctionStopwatch(){const[startTime,setStartTime]=useState(null);const[now,setNow]=useState(null);constintervalRef=useRef(null);functionhandleStart(){setStartTime(Date.now());setNow(Date.now());clearInterval(intervalRef.current);intervalRef.current=setInterval(()=>{setNow(Date.now());},10);}functionhandleStop(){clearInterval(intervalRef.current);}letsecondsPassed=0;if(startTime!=null&&now!=null){secondsPassed=(now-startTime)/1000;}return(<><h1>Time passed:{secondsPassed.toFixed(3)}</h1><buttononClick={handleStart}>Start</button><buttononClick={handleStop}>Stop</button></>);}"
                },
                {
                    "type": "p",
                    "text": "When a piece of information is used for rendering, keep it in state. When a piece of information is only needed by event handlers and changing it doesn’t require a re-render, using a ref may be more efficient."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Differences between refs and state"
                },
                {
                    "type": "p",
                    "text": "Perhaps you’re thinking refs seem less “strict” than state—you can mutate them instead of always having to use a state setting function, for instance. But in most cases, you’ll want to use state. Refs are an “escape hatch” you won’t need often. Here’s how state and refs compare:"
                },
                {
                    "type": "p",
                    "text": "Here is a counter button that’s implemented with state:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionCounter(){const[count,setCount]=useState(0);functionhandleClick(){setCount(count+1);}return(<buttononClick={handleClick}>You clicked{count}times</button>);}"
                },
                {
                    "type": "p",
                    "text": "Because thecountvalue is displayed, it makes sense to use a state value for it. When the counter’s value is set withsetCount(), React re-renders the component and the screen updates to reflect the new count."
                },
                {
                    "type": "p",
                    "text": "If you tried to implement this with a ref, React would never re-render the component, so you’d never see the count change! See how clicking this buttondoes not update its text:"
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';exportdefaultfunctionCounter(){letcountRef=useRef(0);functionhandleClick(){// This doesn't re-render the component!countRef.current=countRef.current+1;}return(<buttononClick={handleClick}>You clicked{countRef.current}times</button>);}"
                },
                {
                    "type": "p",
                    "text": "This is why readingref.currentduring render leads to unreliable code. If you need that, use state instead."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "How does useRef work inside?"
                },
                {
                    "type": "p",
                    "text": "Although bothuseStateanduseRefare provided by React, in principleuseRefcould be implementedon top ofuseState. You can imagine that inside of React,useRefis implemented like this:"
                },
                {
                    "type": "code",
                    "code": "// Inside of ReactfunctionuseRef(initialValue){const[ref,unused]=useState({current:initialValue});returnref;}"
                },
                {
                    "type": "p",
                    "text": "During the first render,useRefreturns{ current: initialValue }. This object is stored by React, so during the next render the same object will be returned. Note how the state setter is unused in this example. It is unnecessary becauseuseRefalways needs to return the same object!"
                },
                {
                    "type": "p",
                    "text": "React provides a built-in version ofuseRefbecause it is common enough in practice. But you can think of it as a regular state variable without a setter. If you’re familiar with object-oriented programming, refs might remind you of instance fields—but instead ofthis.somethingyou writesomethingRef.current."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "When to use refs"
                },
                {
                    "type": "p",
                    "text": "Typically, you will use a ref when your component needs to “step outside” React and communicate with external APIs—often a browser API that won’t impact the appearance of the component. Here are a few of these rare situations:"
                },
                {
                    "type": "list",
                    "items": [
                        "Storingtimeout IDs",
                        "Storing and manipulatingDOM elements, which we cover onthe next page",
                        "Storing other objects that aren’t necessary to calculate the JSX."
                    ]
                },
                {
                    "type": "p",
                    "text": "If your component needs to store some value, but it doesn’t impact the rendering logic, choose refs."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Best practices for refs"
                },
                {
                    "type": "p",
                    "text": "Following these principles will make your components more predictable:"
                },
                {
                    "type": "list",
                    "items": [
                        "Treat refs as an escape hatch.Refs are useful when you work with external systems or browser APIs. If much of your application logic and data flow relies on refs, you might want to rethink your approach.",
                        "Don’t read or writeref.currentduring rendering.If some information is needed during rendering, usestateinstead. Since React doesn’t know whenref.currentchanges, even reading it while rendering makes your component’s behavior difficult to predict. (The only exception to this is code likeif (!ref.current) ref.current = new Thing()which only sets the ref once during the first render.)"
                    ]
                },
                {
                    "type": "p",
                    "text": "Limitations of React state don’t apply to refs. For example, state acts like asnapshot for every renderanddoesn’t update synchronously.But when you mutate the current value of a ref, it changes immediately:"
                },
                {
                    "type": "code",
                    "code": "ref.current=5;console.log(ref.current);// 5"
                },
                {
                    "type": "p",
                    "text": "This is becausethe ref itself is a regular JavaScript object,and so it behaves like one."
                },
                {
                    "type": "p",
                    "text": "You also don’t need to worry aboutavoiding mutationwhen you work with a ref. As long as the object you’re mutating isn’t used for rendering, React doesn’t care what you do with the ref or its contents."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Refs and the DOM"
                },
                {
                    "type": "p",
                    "text": "You can point a ref to any value. However, the most common use case for a ref is to access a DOM element. For example, this is handy if you want to focus an input programmatically. When you pass a ref to arefattribute in JSX, like<div ref={myRef}>, React will put the corresponding DOM element intomyRef.current. Once the element is removed from the DOM, React will updatemyRef.currentto benull. You can read more about this inManipulating the DOM with Refs."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "Refs are an escape hatch to hold onto values that aren’t used for rendering. You won’t need them often.",
                        "A ref is a plain JavaScript object with a single property calledcurrent, which you can read or set.",
                        "You can ask React to give you a ref by calling theuseRefHook.",
                        "Like state, refs let you retain information between re-renders of a component.",
                        "Unlike state, setting the ref’scurrentvalue does not trigger a re-render.",
                        "Don’t read or writeref.currentduring rendering. This makes your component hard to predict."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of4:Fix a broken chat input"
                },
                {
                    "type": "p",
                    "text": "Type a message and click “Send”. You will notice there is a three second delay before you see the “Sent!” alert. During this delay, you can see an “Undo” button. Click it. This “Undo” button is supposed to stop the “Sent!” message from appearing. It does this by callingclearTimeoutfor the timeout ID saved duringhandleSend. However, even after “Undo” is clicked, the “Sent!” message still appears. Find why it doesn’t work, and fix it."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionChat(){const[text,setText]=useState('');const[isSending,setIsSending]=useState(false);lettimeoutID=null;functionhandleSend(){setIsSending(true);timeoutID=setTimeout(()=>{alert('Sent!');setIsSending(false);},3000);}functionhandleUndo(){setIsSending(false);clearTimeout(timeoutID);}return(<><inputdisabled={isSending}value={text}onChange={e=>setText(e.target.value)}/><buttondisabled={isSending}onClick={handleSend}>{isSending?'Sending...':'Send'}</button>{isSending&&<buttononClick={handleUndo}>Undo</button>}</>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/removing-effect-dependencies",
            "title": "Removing Effect Dependencies – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Removing Effect Dependencies"
                },
                {
                    "type": "p",
                    "text": "When you write an Effect, the linter will verify that you’ve included every reactive value (like props and state) that the Effect reads in the list of your Effect’s dependencies. This ensures that your Effect remains synchronized with the latest props and state of your component. Unnecessary dependencies may cause your Effect to run too often, or even create an infinite loop. Follow this guide to review and remove unnecessary dependencies from your Effects."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "How to fix infinite Effect dependency loops",
                        "What to do when you want to remove a dependency",
                        "How to read a value from your Effect without “reacting” to it",
                        "How and why to avoid object and function dependencies",
                        "Why suppressing the dependency linter is dangerous, and what to do instead"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Dependencies should match the code"
                },
                {
                    "type": "p",
                    "text": "When you write an Effect, you first specify how tostart and stopwhatever you want your Effect to be doing:"
                },
                {
                    "type": "code",
                    "code": "constserverUrl='https://localhost:1234';functionChatRoom({roomId}){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>connection.disconnect();// ...}"
                },
                {
                    "type": "p",
                    "text": "Then, if you leave the Effect dependencies empty ([]), the linter will suggest the correct dependencies:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection}from'./chat.js';constserverUrl='https://localhost:1234';functionChatRoom({roomId}){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>connection.disconnect();},[]);// <-- Fix the mistake here!return<h1>Welcome to the{roomId}room!</h1>;}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><hr/><ChatRoomroomId={roomId}/></>);}"
                },
                {
                    "type": "p",
                    "text": "Fill them in according to what the linter says:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>connection.disconnect();},[roomId]);// ✅ All dependencies declared// ...}"
                },
                {
                    "type": "p",
                    "text": "Effects “react” to reactive values.SinceroomIdis a reactive value (it can change due to a re-render), the linter verifies that you’ve specified it as a dependency. IfroomIdreceives a different value, React will re-synchronize your Effect. This ensures that the chat stays connected to the selected room and “reacts” to the dropdown:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection}from'./chat.js';constserverUrl='https://localhost:1234';functionChatRoom({roomId}){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>connection.disconnect();},[roomId]);return<h1>Welcome to the{roomId}room!</h1>;}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><hr/><ChatRoomroomId={roomId}/></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "To remove a dependency, prove that it’s not a dependency"
                },
                {
                    "type": "p",
                    "text": "Notice that you can’t “choose” the dependencies of your Effect. Everyreactive valueused by your Effect’s code must be declared in your dependency list. The dependency list is determined by the surrounding code:"
                },
                {
                    "type": "code",
                    "code": "constserverUrl='https://localhost:1234';functionChatRoom({roomId}){// This is a reactive valueuseEffect(()=>{constconnection=createConnection(serverUrl,roomId);// This Effect reads that reactive valueconnection.connect();return()=>connection.disconnect();},[roomId]);// ✅ So you must specify that reactive value as a dependency of your Effect// ...}"
                },
                {
                    "type": "p",
                    "text": "Reactive valuesinclude props and all variables and functions declared directly inside of your component. SinceroomIdis a reactive value, you can’t remove it from the dependency list. The linter wouldn’t allow it:"
                },
                {
                    "type": "code",
                    "code": "constserverUrl='https://localhost:1234';functionChatRoom({roomId}){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>connection.disconnect();},[]);// 🔴 React Hook useEffect has a missing dependency: 'roomId'// ...}"
                },
                {
                    "type": "p",
                    "text": "And the linter would be right! SinceroomIdmay change over time, this would introduce a bug in your code."
                },
                {
                    "type": "p",
                    "text": "To remove a dependency, “prove” to the linter that itdoesn’t needto be a dependency.For example, you can moveroomIdout of your component to prove that it’s not reactive and won’t change on re-renders:"
                },
                {
                    "type": "code",
                    "code": "constserverUrl='https://localhost:1234';constroomId='music';// Not a reactive value anymorefunctionChatRoom(){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>connection.disconnect();},[]);// ✅ All dependencies declared// ...}"
                },
                {
                    "type": "p",
                    "text": "Now thatroomIdis not a reactive value (and can’t change on a re-render), it doesn’t need to be a dependency:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection}from'./chat.js';constserverUrl='https://localhost:1234';constroomId='music';exportdefaultfunctionChatRoom(){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>connection.disconnect();},[]);return<h1>Welcome to the{roomId}room!</h1>;}"
                },
                {
                    "type": "p",
                    "text": "This is why you could now specify anempty ([]) dependency list.Your Effectreally doesn’tdepend on any reactive value anymore, so itreally doesn’tneed to re-run when any of the component’s props or state change."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "To change the dependencies, change the code"
                },
                {
                    "type": "p",
                    "text": "You might have noticed a pattern in your workflow:"
                },
                {
                    "type": "list",
                    "items": [
                        "First, youchange the codeof your Effect or how your reactive values are declared.",
                        "Then, you follow the linter and adjust the dependencies tomatch the code you have changed.",
                        "If you’re not happy with the list of dependencies, yougo back to the first step(and change the code again)."
                    ]
                },
                {
                    "type": "p",
                    "text": "The last part is important.If you want to change the dependencies, change the surrounding code first.You can think of the dependency list asa list of all the reactive values used by your Effect’s code.You don’tchoosewhat to put on that list. The listdescribesyour code. To change the dependency list, change the code."
                },
                {
                    "type": "p",
                    "text": "This might feel like solving an equation. You might start with a goal (for example, to remove a dependency), and you need to “find” the code matching that goal. Not everyone finds solving equations fun, and the same thing could be said about writing Effects! Luckily, there is a list of common recipes that you can try below."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "If you have an existing codebase, you might have some Effects that suppress the linter like this:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{// ...// 🔴 Avoid suppressing the linter like this:// eslint-ignore-next-line react-hooks/exhaustive-deps},[]);"
                },
                {
                    "type": "p",
                    "text": "When dependencies don’t match the code, there is a very high risk of introducing bugs.By suppressing the linter, you “lie” to React about the values your Effect depends on."
                },
                {
                    "type": "p",
                    "text": "Instead, use the techniques below."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Why is suppressing the dependency linter so dangerous?"
                },
                {
                    "type": "p",
                    "text": "Suppressing the linter leads to very unintuitive bugs that are hard to find and fix. Here’s one example:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';exportdefaultfunctionTimer(){const[count,setCount]=useState(0);const[increment,setIncrement]=useState(1);functiononTick(){setCount(count+increment);}useEffect(()=>{constid=setInterval(onTick,1000);return()=>clearInterval(id);// eslint-disable-next-line react-hooks/exhaustive-deps},[]);return(<><h1>Counter:{count}<buttononClick={()=>setCount(0)}>Reset</button></h1><hr/><p>Every second, increment by:<buttondisabled={increment===0}onClick={()=>{setIncrement(i=>i-1);}}>–</button><b>{increment}</b><buttononClick={()=>{setIncrement(i=>i+1);}}>+</button></p></>);}"
                },
                {
                    "type": "p",
                    "text": "Let’s say that you wanted to run the Effect “only on mount”. You’ve read thatempty ([]) dependenciesdo that, so you’ve decided to ignore the linter, and forcefully specified[]as the dependencies."
                },
                {
                    "type": "p",
                    "text": "This counter was supposed to increment every second by the amount configurable with the two buttons. However, since you “lied” to React that this Effect doesn’t depend on anything, React forever keeps using theonTickfunction from the initial render.During that render,countwas0andincrementwas1. This is whyonTickfrom that render always callssetCount(0 + 1)every second, and you always see1. Bugs like this are harder to fix when they’re spread across multiple components."
                },
                {
                    "type": "p",
                    "text": "There’s always a better solution than ignoring the linter! To fix this code, you need to addonTickto the dependency list. (To ensure the interval is only setup once,makeonTickan Effect Event.)"
                },
                {
                    "type": "p",
                    "text": "We recommend treating the dependency lint error as a compilation error. If you don’t suppress it, you will never see bugs like this.The rest of this page documents the alternatives for this and other cases."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Removing unnecessary dependencies"
                },
                {
                    "type": "p",
                    "text": "Every time you adjust the Effect’s dependencies to reflect the code, look at the dependency list. Does it make sense for the Effect to re-run when any of these dependencies change? Sometimes, the answer is “no”:"
                },
                {
                    "type": "list",
                    "items": [
                        "You might want to re-executedifferent partsof your Effect under different conditions.",
                        "You might want to only read thelatest valueof some dependency instead of “reacting” to its changes.",
                        "A dependency may change too oftenunintentionallybecause it’s an object or a function."
                    ]
                },
                {
                    "type": "p",
                    "text": "To find the right solution, you’ll need to answer a few questions about your Effect. Let’s walk through them."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Should this code move to an event handler?"
                },
                {
                    "type": "p",
                    "text": "The first thing you should think about is whether this code should be an Effect at all."
                },
                {
                    "type": "p",
                    "text": "Imagine a form. On submit, you set thesubmittedstate variable totrue. You need to send a POST request and show a notification. You’ve put this logic inside an Effect that “reacts” tosubmittedbeingtrue:"
                },
                {
                    "type": "code",
                    "code": "functionForm(){const[submitted,setSubmitted]=useState(false);useEffect(()=>{if(submitted){// 🔴 Avoid: Event-specific logic inside an Effectpost('/api/register');showNotification('Successfully registered!');}},[submitted]);functionhandleSubmit(){setSubmitted(true);}// ...}"
                },
                {
                    "type": "p",
                    "text": "Later, you want to style the notification message according to the current theme, so you read the current theme. Sincethemeis declared in the component body, it is a reactive value, so you add it as a dependency:"
                },
                {
                    "type": "code",
                    "code": "functionForm(){const[submitted,setSubmitted]=useState(false);consttheme=useContext(ThemeContext);useEffect(()=>{if(submitted){// 🔴 Avoid: Event-specific logic inside an Effectpost('/api/register');showNotification('Successfully registered!',theme);}},[submitted,theme]);// ✅ All dependencies declaredfunctionhandleSubmit(){setSubmitted(true);}// ...}"
                },
                {
                    "type": "p",
                    "text": "By doing this, you’ve introduced a bug. Imagine you submit the form first and then switch between Dark and Light themes. Thethemewill change, the Effect will re-run, and so it will display the same notification again!"
                },
                {
                    "type": "p",
                    "text": "The problem here is that this shouldn’t be an Effect in the first place.You want to send this POST request and show the notification in response tosubmitting the form,which is a particular interaction. To run some code in response to particular interaction, put that logic directly into the corresponding event handler:"
                },
                {
                    "type": "code",
                    "code": "functionForm(){consttheme=useContext(ThemeContext);functionhandleSubmit(){// ✅ Good: Event-specific logic is called from event handlerspost('/api/register');showNotification('Successfully registered!',theme);}// ...}"
                },
                {
                    "type": "p",
                    "text": "Now that the code is in an event handler, it’s not reactive—so it will only run when the user submits the form. Read more aboutchoosing between event handlers and Effectsandhow to delete unnecessary Effects."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Is your Effect doing several unrelated things?"
                },
                {
                    "type": "p",
                    "text": "The next question you should ask yourself is whether your Effect is doing several unrelated things."
                },
                {
                    "type": "p",
                    "text": "Imagine you’re creating a shipping form where the user needs to choose their city and area. You fetch the list ofcitiesfrom the server according to the selectedcountryto show them in a dropdown:"
                },
                {
                    "type": "code",
                    "code": "functionShippingForm({country}){const[cities,setCities]=useState(null);const[city,setCity]=useState(null);useEffect(()=>{letignore=false;fetch(`/api/cities?country=${country}`).then(response=>response.json()).then(json=>{if(!ignore){setCities(json);}});return()=>{ignore=true;};},[country]);// ✅ All dependencies declared// ..."
                },
                {
                    "type": "p",
                    "text": "This is a good example offetching data in an Effect.You are synchronizing thecitiesstate with the network according to thecountryprop. You can’t do this in an event handler because you need to fetch as soon asShippingFormis displayed and whenever thecountrychanges (no matter which interaction causes it)."
                },
                {
                    "type": "p",
                    "text": "Now let’s say you’re adding a second select box for city areas, which should fetch theareasfor the currently selectedcity. You might start by adding a secondfetchcall for the list of areas inside the same Effect:"
                },
                {
                    "type": "code",
                    "code": "functionShippingForm({country}){const[cities,setCities]=useState(null);const[city,setCity]=useState(null);const[areas,setAreas]=useState(null);useEffect(()=>{letignore=false;fetch(`/api/cities?country=${country}`).then(response=>response.json()).then(json=>{if(!ignore){setCities(json);}});// 🔴 Avoid: A single Effect synchronizes two independent processesif(city){fetch(`/api/areas?city=${city}`).then(response=>response.json()).then(json=>{if(!ignore){setAreas(json);}});}return()=>{ignore=true;};},[country,city]);// ✅ All dependencies declared// ..."
                },
                {
                    "type": "p",
                    "text": "However, since the Effect now uses thecitystate variable, you’ve had to addcityto the list of dependencies. That, in turn, introduced a problem: when the user selects a different city, the Effect will re-run and callfetchCities(country). As a result, you will be unnecessarily refetching the list of cities many times."
                },
                {
                    "type": "p",
                    "text": "The problem with this code is that you’re synchronizing two different unrelated things:"
                },
                {
                    "type": "list",
                    "items": [
                        "You want to synchronize thecitiesstate to the network based on thecountryprop.",
                        "You want to synchronize theareasstate to the network based on thecitystate."
                    ]
                },
                {
                    "type": "p",
                    "text": "Split the logic into two Effects, each of which reacts to the prop that it needs to synchronize with:"
                },
                {
                    "type": "code",
                    "code": "functionShippingForm({country}){const[cities,setCities]=useState(null);useEffect(()=>{letignore=false;fetch(`/api/cities?country=${country}`).then(response=>response.json()).then(json=>{if(!ignore){setCities(json);}});return()=>{ignore=true;};},[country]);// ✅ All dependencies declaredconst[city,setCity]=useState(null);const[areas,setAreas]=useState(null);useEffect(()=>{if(city){letignore=false;fetch(`/api/areas?city=${city}`).then(response=>response.json()).then(json=>{if(!ignore){setAreas(json);}});return()=>{ignore=true;};}},[city]);// ✅ All dependencies declared// ..."
                },
                {
                    "type": "p",
                    "text": "Now the first Effect only re-runs if thecountrychanges, while the second Effect re-runs when thecitychanges. You’ve separated them by purpose: two different things are synchronized by two separate Effects. Two separate Effects have two separate dependency lists, so they won’t trigger each other unintentionally."
                },
                {
                    "type": "p",
                    "text": "The final code is longer than the original, but splitting these Effects is still correct.Each Effect should represent an independent synchronization process.In this example, deleting one Effect doesn’t break the other Effect’s logic. This means theysynchronize different things,and it’s good to split them up. If you’re concerned about duplication, you can improve this code byextracting repetitive logic into a custom Hook."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Are you reading some state to calculate the next state?"
                },
                {
                    "type": "p",
                    "text": "This Effect updates themessagesstate variable with a newly created array every time a new message arrives:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){const[messages,setMessages]=useState([]);useEffect(()=>{constconnection=createConnection();connection.connect();connection.on('message',(receivedMessage)=>{setMessages([...messages,receivedMessage]);});// ..."
                },
                {
                    "type": "p",
                    "text": "It uses themessagesvariable tocreate a new arraystarting with all the existing messages and adds the new message at the end. However, sincemessagesis a reactive value read by an Effect, it must be a dependency:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){const[messages,setMessages]=useState([]);useEffect(()=>{constconnection=createConnection();connection.connect();connection.on('message',(receivedMessage)=>{setMessages([...messages,receivedMessage]);});return()=>connection.disconnect();},[roomId,messages]);// ✅ All dependencies declared// ..."
                },
                {
                    "type": "p",
                    "text": "And makingmessagesa dependency introduces a problem."
                },
                {
                    "type": "p",
                    "text": "Every time you receive a message,setMessages()causes the component to re-render with a newmessagesarray that includes the received message. However, since this Effect now depends onmessages, this willalsore-synchronize the Effect. So every new message will make the chat re-connect. The user would not like that!"
                },
                {
                    "type": "p",
                    "text": "To fix the issue, don’t readmessagesinside the Effect. Instead, pass anupdater functiontosetMessages:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){const[messages,setMessages]=useState([]);useEffect(()=>{constconnection=createConnection();connection.connect();connection.on('message',(receivedMessage)=>{setMessages(msgs=>[...msgs,receivedMessage]);});return()=>connection.disconnect();},[roomId]);// ✅ All dependencies declared// ..."
                },
                {
                    "type": "p",
                    "text": "Notice how your Effect does not read themessagesvariable at all now.You only need to pass an updater function likemsgs => [...msgs, receivedMessage]. Reactputs your updater function in a queueand will provide themsgsargument to it during the next render. This is why the Effect itself doesn’t need to depend onmessagesanymore. As a result of this fix, receiving a chat message will no longer make the chat re-connect."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Do you want to read a value without “reacting” to its changes?"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Under Construction"
                },
                {
                    "type": "p",
                    "text": "This section describes anexperimental API that has not yet been releasedin a stable version of React."
                },
                {
                    "type": "p",
                    "text": "Suppose that you want to play a sound when the user receives a new message unlessisMutedistrue:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){const[messages,setMessages]=useState([]);const[isMuted,setIsMuted]=useState(false);useEffect(()=>{constconnection=createConnection();connection.connect();connection.on('message',(receivedMessage)=>{setMessages(msgs=>[...msgs,receivedMessage]);if(!isMuted){playSound();}});// ..."
                },
                {
                    "type": "p",
                    "text": "Since your Effect now usesisMutedin its code, you have to add it to the dependencies:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){const[messages,setMessages]=useState([]);const[isMuted,setIsMuted]=useState(false);useEffect(()=>{constconnection=createConnection();connection.connect();connection.on('message',(receivedMessage)=>{setMessages(msgs=>[...msgs,receivedMessage]);if(!isMuted){playSound();}});return()=>connection.disconnect();},[roomId,isMuted]);// ✅ All dependencies declared// ..."
                },
                {
                    "type": "p",
                    "text": "The problem is that every timeisMutedchanges (for example, when the user presses the “Muted” toggle), the Effect will re-synchronize, and reconnect to the chat. This is not the desired user experience! (In this example, even disabling the linter would not work—if you do that,isMutedwould get “stuck” with its old value.)"
                },
                {
                    "type": "p",
                    "text": "To solve this problem, you need to extract the logic that shouldn’t be reactive out of the Effect. You don’t want this Effect to “react” to the changes inisMuted.Move this non-reactive piece of logic into an Effect Event:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect,useEffectEvent}from'react';functionChatRoom({roomId}){const[messages,setMessages]=useState([]);const[isMuted,setIsMuted]=useState(false);constonMessage=useEffectEvent(receivedMessage=>{setMessages(msgs=>[...msgs,receivedMessage]);if(!isMuted){playSound();}});useEffect(()=>{constconnection=createConnection();connection.connect();connection.on('message',(receivedMessage)=>{onMessage(receivedMessage);});return()=>connection.disconnect();},[roomId]);// ✅ All dependencies declared// ..."
                },
                {
                    "type": "p",
                    "text": "Effect Events let you split an Effect into reactive parts (which should “react” to reactive values likeroomIdand their changes) and non-reactive parts (which only read their latest values, likeonMessagereadsisMuted).Now that you readisMutedinside an Effect Event, it doesn’t need to be a dependency of your Effect.As a result, the chat won’t re-connect when you toggle the “Muted” setting on and off, solving the original issue!"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Wrapping an event handler from the props"
                },
                {
                    "type": "p",
                    "text": "You might run into a similar problem when your component receives an event handler as a prop:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId,onReceiveMessage}){const[messages,setMessages]=useState([]);useEffect(()=>{constconnection=createConnection();connection.connect();connection.on('message',(receivedMessage)=>{onReceiveMessage(receivedMessage);});return()=>connection.disconnect();},[roomId,onReceiveMessage]);// ✅ All dependencies declared// ..."
                },
                {
                    "type": "p",
                    "text": "Suppose that the parent component passes adifferentonReceiveMessagefunction on every render:"
                },
                {
                    "type": "code",
                    "code": "<ChatRoomroomId={roomId}onReceiveMessage={receivedMessage=>{// ...}}/>"
                },
                {
                    "type": "p",
                    "text": "SinceonReceiveMessageis a dependency, it would cause the Effect to re-synchronize after every parent re-render. This would make it re-connect to the chat. To solve this, wrap the call in an Effect Event:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId,onReceiveMessage}){const[messages,setMessages]=useState([]);constonMessage=useEffectEvent(receivedMessage=>{onReceiveMessage(receivedMessage);});useEffect(()=>{constconnection=createConnection();connection.connect();connection.on('message',(receivedMessage)=>{onMessage(receivedMessage);});return()=>connection.disconnect();},[roomId]);// ✅ All dependencies declared// ..."
                },
                {
                    "type": "p",
                    "text": "Effect Events aren’t reactive, so you don’t need to specify them as dependencies. As a result, the chat will no longer re-connect even if the parent component passes a function that’s different on every re-render."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Separating reactive and non-reactive code"
                },
                {
                    "type": "p",
                    "text": "In this example, you want to log a visit every timeroomIdchanges. You want to include the currentnotificationCountwith every log, but youdon’twant a change tonotificationCountto trigger a log event."
                },
                {
                    "type": "p",
                    "text": "The solution is again to split out the non-reactive code into an Effect Event:"
                },
                {
                    "type": "code",
                    "code": "functionChat({roomId,notificationCount}){constonVisit=useEffectEvent(visitedRoomId=>{logVisit(visitedRoomId,notificationCount);});useEffect(()=>{onVisit(roomId);},[roomId]);// ✅ All dependencies declared// ...}"
                },
                {
                    "type": "p",
                    "text": "You want your logic to be reactive with regards toroomId, so you readroomIdinside of your Effect. However, you don’t want a change tonotificationCountto log an extra visit, so you readnotificationCountinside of the Effect Event.Learn more about reading the latest props and state from Effects using Effect Events."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Does some reactive value change unintentionally?"
                },
                {
                    "type": "p",
                    "text": "Sometimes, youdowant your Effect to “react” to a certain value, but that value changes more often than you’d like—and might not reflect any actual change from the user’s perspective. For example, let’s say that you create anoptionsobject in the body of your component, and then read that object from inside of your Effect:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){// ...constoptions={serverUrl:serverUrl,roomId:roomId};useEffect(()=>{constconnection=createConnection(options);connection.connect();// ..."
                },
                {
                    "type": "p",
                    "text": "This object is declared in the component body, so it’s areactive value.When you read a reactive value like this inside an Effect, you declare it as a dependency. This ensures your Effect “reacts” to its changes:"
                },
                {
                    "type": "code",
                    "code": "// ...useEffect(()=>{constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[options]);// ✅ All dependencies declared// ..."
                },
                {
                    "type": "p",
                    "text": "It is important to declare it as a dependency! This ensures, for example, that if theroomIdchanges, your Effect will re-connect to the chat with the newoptions. However, there is also a problem with the code above. To see it, try typing into the input in the sandbox below, and watch what happens in the console:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection}from'./chat.js';constserverUrl='https://localhost:1234';functionChatRoom({roomId}){const[message,setMessage]=useState('');// Temporarily disable the linter to demonstrate the problem// eslint-disable-next-line react-hooks/exhaustive-depsconstoptions={serverUrl:serverUrl,roomId:roomId};useEffect(()=>{constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[options]);return(<><h1>Welcome to the{roomId}room!</h1><inputvalue={message}onChange={e=>setMessage(e.target.value)}/></>);}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><hr/><ChatRoomroomId={roomId}/></>);}"
                },
                {
                    "type": "p",
                    "text": "In the sandbox above, the input only updates themessagestate variable. From the user’s perspective, this should not affect the chat connection. However, every time you update themessage, your component re-renders. When your component re-renders, the code inside of it runs again from scratch."
                },
                {
                    "type": "p",
                    "text": "A newoptionsobject is created from scratch on every re-render of theChatRoomcomponent. React sees that theoptionsobject is adifferent objectfrom theoptionsobject created during the last render. This is why it re-synchronizes your Effect (which depends onoptions), and the chat re-connects as you type."
                },
                {
                    "type": "p",
                    "text": "This problem only affects objects and functions. In JavaScript, each newly created object and function is considered distinct from all the others. It doesn’t matter that the contents inside of them may be the same!"
                },
                {
                    "type": "code",
                    "code": "// During the first renderconstoptions1={serverUrl:'https://localhost:1234',roomId:'music'};// During the next renderconstoptions2={serverUrl:'https://localhost:1234',roomId:'music'};// These are two different objects!console.log(Object.is(options1,options2));// false"
                },
                {
                    "type": "p",
                    "text": "Object and function dependencies can make your Effect re-synchronize more often than you need."
                },
                {
                    "type": "p",
                    "text": "This is why, whenever possible, you should try to avoid objects and functions as your Effect’s dependencies. Instead, try moving them outside the component, inside the Effect, or extracting primitive values out of them."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Move static objects and functions outside your component"
                },
                {
                    "type": "p",
                    "text": "If the object does not depend on any props and state, you can move that object outside your component:"
                },
                {
                    "type": "code",
                    "code": "constoptions={serverUrl:'https://localhost:1234',roomId:'music'};functionChatRoom(){const[message,setMessage]=useState('');useEffect(()=>{constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[]);// ✅ All dependencies declared// ..."
                },
                {
                    "type": "p",
                    "text": "This way, youproveto the linter that it’s not reactive. It can’t change as a result of a re-render, so it doesn’t need to be a dependency. Now re-renderingChatRoomwon’t cause your Effect to re-synchronize."
                },
                {
                    "type": "p",
                    "text": "This works for functions too:"
                },
                {
                    "type": "code",
                    "code": "functioncreateOptions(){return{serverUrl:'https://localhost:1234',roomId:'music'};}functionChatRoom(){const[message,setMessage]=useState('');useEffect(()=>{constoptions=createOptions();constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[]);// ✅ All dependencies declared// ..."
                },
                {
                    "type": "p",
                    "text": "SincecreateOptionsis declared outside your component, it’s not a reactive value. This is why it doesn’t need to be specified in your Effect’s dependencies, and why it won’t ever cause your Effect to re-synchronize."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Move dynamic objects and functions inside your Effect"
                },
                {
                    "type": "p",
                    "text": "If your object depends on some reactive value that may change as a result of a re-render, like aroomIdprop, you can’t pull itoutsideyour component. You can, however, move its creationinsideof your Effect’s code:"
                },
                {
                    "type": "code",
                    "code": "constserverUrl='https://localhost:1234';functionChatRoom({roomId}){const[message,setMessage]=useState('');useEffect(()=>{constoptions={serverUrl:serverUrl,roomId:roomId};constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[roomId]);// ✅ All dependencies declared// ..."
                },
                {
                    "type": "p",
                    "text": "Now thatoptionsis declared inside of your Effect, it is no longer a dependency of your Effect. Instead, the only reactive value used by your Effect isroomId. SinceroomIdis not an object or function, you can be sure that it won’t beunintentionallydifferent. In JavaScript, numbers and strings are compared by their content:"
                },
                {
                    "type": "code",
                    "code": "// During the first renderconstroomId1='music';// During the next renderconstroomId2='music';// These two strings are the same!console.log(Object.is(roomId1,roomId2));// true"
                },
                {
                    "type": "p",
                    "text": "Thanks to this fix, the chat no longer re-connects if you edit the input:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection}from'./chat.js';constserverUrl='https://localhost:1234';functionChatRoom({roomId}){const[message,setMessage]=useState('');useEffect(()=>{constoptions={serverUrl:serverUrl,roomId:roomId};constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[roomId]);return(<><h1>Welcome to the{roomId}room!</h1><inputvalue={message}onChange={e=>setMessage(e.target.value)}/></>);}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><hr/><ChatRoomroomId={roomId}/></>);}"
                },
                {
                    "type": "p",
                    "text": "However, itdoesre-connect when you change theroomIddropdown, as you would expect."
                },
                {
                    "type": "p",
                    "text": "This works for functions, too:"
                },
                {
                    "type": "code",
                    "code": "constserverUrl='https://localhost:1234';functionChatRoom({roomId}){const[message,setMessage]=useState('');useEffect(()=>{functioncreateOptions(){return{serverUrl:serverUrl,roomId:roomId};}constoptions=createOptions();constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[roomId]);// ✅ All dependencies declared// ..."
                },
                {
                    "type": "p",
                    "text": "You can write your own functions to group pieces of logic inside your Effect. As long as you also declare theminsideyour Effect, they’re not reactive values, and so they don’t need to be dependencies of your Effect."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Read primitive values from objects"
                },
                {
                    "type": "p",
                    "text": "Sometimes, you may receive an object from props:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({options}){const[message,setMessage]=useState('');useEffect(()=>{constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[options]);// ✅ All dependencies declared// ..."
                },
                {
                    "type": "p",
                    "text": "The risk here is that the parent component will create the object during rendering:"
                },
                {
                    "type": "code",
                    "code": "<ChatRoomroomId={roomId}options={{serverUrl:serverUrl,roomId:roomId}}/>"
                },
                {
                    "type": "p",
                    "text": "This would cause your Effect to re-connect every time the parent component re-renders. To fix this, read information from the objectoutsidethe Effect, and avoid having object and function dependencies:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({options}){const[message,setMessage]=useState('');const{roomId,serverUrl}=options;useEffect(()=>{constconnection=createConnection({roomId:roomId,serverUrl:serverUrl});connection.connect();return()=>connection.disconnect();},[roomId,serverUrl]);// ✅ All dependencies declared// ..."
                },
                {
                    "type": "p",
                    "text": "The logic gets a little repetitive (you read some values from an object outside an Effect, and then create an object with the same values inside the Effect). But it makes it very explicit what information your Effectactuallydepends on. If an object is re-created unintentionally by the parent component, the chat would not re-connect. However, ifoptions.roomIdoroptions.serverUrlreally are different, the chat would re-connect."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Calculate primitive values from functions"
                },
                {
                    "type": "p",
                    "text": "The same approach can work for functions. For example, suppose the parent component passes a function:"
                },
                {
                    "type": "code",
                    "code": "<ChatRoomroomId={roomId}getOptions={()=>{return{serverUrl:serverUrl,roomId:roomId};}}/>"
                },
                {
                    "type": "p",
                    "text": "To avoid making it a dependency (and causing it to re-connect on re-renders), call it outside the Effect. This gives you theroomIdandserverUrlvalues that aren’t objects, and that you can read from inside your Effect:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({getOptions}){const[message,setMessage]=useState('');const{roomId,serverUrl}=getOptions();useEffect(()=>{constconnection=createConnection({roomId:roomId,serverUrl:serverUrl});connection.connect();return()=>connection.disconnect();},[roomId,serverUrl]);// ✅ All dependencies declared// ..."
                },
                {
                    "type": "p",
                    "text": "This only works forpurefunctions because they are safe to call during rendering. If your function is an event handler, but you don’t want its changes to re-synchronize your Effect,wrap it into an Effect Event instead."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "Dependencies should always match the code.",
                        "When you’re not happy with your dependencies, what you need to edit is the code.",
                        "Suppressing the linter leads to very confusing bugs, and you should always avoid it.",
                        "To remove a dependency, you need to “prove” to the linter that it’s not necessary.",
                        "If some code should run in response to a specific interaction, move that code to an event handler.",
                        "If different parts of your Effect should re-run for different reasons, split it into several Effects.",
                        "If you want to update some state based on the previous state, pass an updater function.",
                        "If you want to read the latest value without “reacting” it, extract an Effect Event from your Effect.",
                        "In JavaScript, objects and functions are considered different if they were created at different times.",
                        "Try to avoid object and function dependencies. Move them outside the component or inside the Effect."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of4:Fix a resetting interval"
                },
                {
                    "type": "p",
                    "text": "This Effect sets up an interval that ticks every second. You’ve noticed something strange happening: it seems like the interval gets destroyed and re-created every time it ticks. Fix the code so that the interval doesn’t get constantly re-created."
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';exportdefaultfunctionTimer(){const[count,setCount]=useState(0);useEffect(()=>{console.log('✅ Creating an interval');constid=setInterval(()=>{console.log('⏰ Interval tick');setCount(count+1);},1000);return()=>{console.log('❌ Clearing an interval');clearInterval(id);};},[count]);return<h1>Counter:{count}</h1>}"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/render-and-commit",
            "title": "Render and Commit – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Render and Commit"
                },
                {
                    "type": "p",
                    "text": "Before your components are displayed on screen, they must be rendered by React. Understanding the steps in this process will help you think about how your code executes and explain its behavior."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "What rendering means in React",
                        "When and why React renders a component",
                        "The steps involved in displaying a component on screen",
                        "Why rendering does not always produce a DOM update"
                    ]
                },
                {
                    "type": "p",
                    "text": "Imagine that your components are cooks in the kitchen, assembling tasty dishes from ingredients. In this scenario, React is the waiter who puts in requests from customers and brings them their orders. This process of requesting and serving UI has three steps:"
                },
                {
                    "type": "list",
                    "items": [
                        "Triggeringa render (delivering the guest’s order to the kitchen)",
                        "Renderingthe component (preparing the order in the kitchen)",
                        "Committingto the DOM (placing the order on the table)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Trigger",
                        "Render",
                        "Commit"
                    ]
                },
                {
                    "type": "p",
                    "text": "Illustrated byRachel Lee Nabors"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Step 1: Trigger a render"
                },
                {
                    "type": "p",
                    "text": "There are two reasons for a component to render:"
                },
                {
                    "type": "list",
                    "items": [
                        "It’s the component’sinitial render.",
                        "The component’s (or one of its ancestors’)state has been updated."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Initial render"
                },
                {
                    "type": "p",
                    "text": "When your app starts, you need to trigger the initial render. Frameworks and sandboxes sometimes hide this code, but it’s done by callingcreateRootwith the target DOM node, and then calling itsrendermethod with your component:"
                },
                {
                    "type": "code",
                    "code": "importImagefrom'./Image.js';import{createRoot}from'react-dom/client';constroot=createRoot(document.getElementById('root'))root.render(<Image/>);"
                },
                {
                    "type": "p",
                    "text": "Try commenting out theroot.render()call and see the component disappear!"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Re-renders when state updates"
                },
                {
                    "type": "p",
                    "text": "Once the component has been initially rendered, you can trigger further renders by updating its state with thesetfunction.Updating your component’s state automatically queues a render. (You can imagine these as a restaurant guest ordering tea, dessert, and all sorts of things after putting in their first order, depending on the state of their thirst or hunger.)"
                },
                {
                    "type": "list",
                    "items": [
                        "State update...",
                        "...triggers...",
                        "...render!"
                    ]
                },
                {
                    "type": "p",
                    "text": "Illustrated byRachel Lee Nabors"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Step 2: React renders your components"
                },
                {
                    "type": "p",
                    "text": "After you trigger a render, React calls your components to figure out what to display on screen.“Rendering” is React calling your components."
                },
                {
                    "type": "list",
                    "items": [
                        "On initial render,React will call the root component.",
                        "For subsequent renders,React will call the function component whose state update triggered the render."
                    ]
                },
                {
                    "type": "p",
                    "text": "This process is recursive: if the updated component returns some other component, React will renderthatcomponent next, and if that component also returns something, it will renderthatcomponent next, and so on. The process will continue until there are no more nested components and React knows exactly what should be displayed on screen."
                },
                {
                    "type": "p",
                    "text": "In the following example, React will callGallery()andImage()several times:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionGallery(){return(<section><h1>Inspiring Sculptures</h1><Image/><Image/><Image/></section>);}functionImage(){return(<imgsrc=\"https://i.imgur.com/ZF6s192.jpg\"alt=\"'Floralis Genérica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals\"/>);}"
                },
                {
                    "type": "list",
                    "items": [
                        "During the initial render,React willcreate the DOM nodesfor<section>,<h1>, and three<img>tags.",
                        "During a re-render,React will calculate which of their properties, if any, have changed since the previous render. It won’t do anything with that information until the next step, the commit phase."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Rendering must always be apure calculation:"
                },
                {
                    "type": "list",
                    "items": [
                        "Same inputs, same output.Given the same inputs, a component should always return the same JSX. (When someone orders a salad with tomatoes, they should not receive a salad with onions!)",
                        "It minds its own business.It should not change any objects or variables that existed before rendering. (One order should not change anyone else’s order.)"
                    ]
                },
                {
                    "type": "p",
                    "text": "Otherwise, you can encounter confusing bugs and unpredictable behavior as your codebase grows in complexity. When developing in “Strict Mode”, React calls each component’s function twice, which can help surface mistakes caused by impure functions."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Optimizing performance"
                },
                {
                    "type": "p",
                    "text": "The default behavior of rendering all components nested within the updated component is not optimal for performance if the updated component is very high in the tree. If you run into a performance issue, there are several opt-in ways to solve it described in thePerformancesection.Don’t optimize prematurely!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Step 3: React commits changes to the DOM"
                },
                {
                    "type": "p",
                    "text": "After rendering (calling) your components, React will modify the DOM."
                },
                {
                    "type": "list",
                    "items": [
                        "For the initial render,React will use theappendChild()DOM API to put all the DOM nodes it has created on screen.",
                        "For re-renders,React will apply the minimal necessary operations (calculated while rendering!) to make the DOM match the latest rendering output."
                    ]
                },
                {
                    "type": "p",
                    "text": "React only changes the DOM nodes if there’s a difference between renders.For example, here is a component that re-renders with different props passed from its parent every second. Notice how you can add some text into the<input>, updating itsvalue, but the text doesn’t disappear when the component re-renders:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionClock({time}){return(<><h1>{time}</h1><input/></>);}"
                },
                {
                    "type": "p",
                    "text": "This works because during this last step, React only updates the content of<h1>with the newtime. It sees that the<input>appears in the JSX in the same place as last time, so React doesn’t touch the<input>—or itsvalue!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Epilogue: Browser paint"
                },
                {
                    "type": "p",
                    "text": "After rendering is done and React updated the DOM, the browser will repaint the screen. Although this process is known as “browser rendering”, we’ll refer to it as “painting” to avoid confusion throughout the docs."
                },
                {
                    "type": "p",
                    "text": "Illustrated byRachel Lee Nabors"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "Any screen update in a React app happens in three steps:TriggerRenderCommit",
                        "Trigger",
                        "Render",
                        "Commit",
                        "You can use Strict Mode to find mistakes in your components",
                        "React does not touch the DOM if the rendering result is the same as last time"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Trigger",
                        "Render",
                        "Commit"
                    ]
                }
            ]
        },
        {
            "url": "https://react.dev/learn/rendering-lists",
            "title": "Rendering Lists – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Rendering Lists"
                },
                {
                    "type": "p",
                    "text": "You will often want to display multiple similar components from a collection of data. You can use theJavaScript array methodsto manipulate an array of data. On this page, you’ll usefilter()andmap()with React to filter and transform your array of data into an array of components."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "How to render components from an array using JavaScript’smap()",
                        "How to render only specific components using JavaScript’sfilter()",
                        "When and why to use React keys"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Rendering data from arrays"
                },
                {
                    "type": "p",
                    "text": "Say that you have a list of content."
                },
                {
                    "type": "code",
                    "code": "<ul><li>Creola Katherine Johnson: mathematician</li><li>Mario José Molina-Pasquel Henríquez: chemist</li><li>Mohammad Abdus Salam: physicist</li><li>Percy Lavon Julian: chemist</li><li>Subrahmanyan Chandrasekhar: astrophysicist</li></ul>"
                },
                {
                    "type": "p",
                    "text": "The only difference among those list items is their contents, their data. You will often need to show several instances of the same component using different data when building interfaces: from lists of comments to galleries of profile images. In these situations, you can store that data in JavaScript objects and arrays and use methods likemap()andfilter()to render lists of components from them."
                },
                {
                    "type": "p",
                    "text": "Here’s a short example of how to generate a list of items from an array:"
                },
                {
                    "type": "list",
                    "items": [
                        "Movethe data into an array:"
                    ]
                },
                {
                    "type": "code",
                    "code": "constpeople=['Creola Katherine Johnson: mathematician','Mario José Molina-Pasquel Henríquez: chemist','Mohammad Abdus Salam: physicist','Percy Lavon Julian: chemist','Subrahmanyan Chandrasekhar: astrophysicist'];"
                },
                {
                    "type": "list",
                    "items": [
                        "Mapthepeoplemembers into a new array of JSX nodes,listItems:"
                    ]
                },
                {
                    "type": "code",
                    "code": "constlistItems=people.map(person=><li>{person}</li>);"
                },
                {
                    "type": "list",
                    "items": [
                        "ReturnlistItemsfrom your component wrapped in a<ul>:"
                    ]
                },
                {
                    "type": "code",
                    "code": "return<ul>{listItems}</ul>;"
                },
                {
                    "type": "p",
                    "text": "Here is the result:"
                },
                {
                    "type": "code",
                    "code": "constpeople=['Creola Katherine Johnson: mathematician','Mario José Molina-Pasquel Henríquez: chemist','Mohammad Abdus Salam: physicist','Percy Lavon Julian: chemist','Subrahmanyan Chandrasekhar: astrophysicist'];exportdefaultfunctionList(){constlistItems=people.map(person=><li>{person}</li>);return<ul>{listItems}</ul>;}"
                },
                {
                    "type": "p",
                    "text": "Notice the sandbox above displays a console error:"
                },
                {
                    "type": "p",
                    "text": "You’ll learn how to fix this error later on this page. Before we get to that, let’s add some structure to your data."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Filtering arrays of items"
                },
                {
                    "type": "p",
                    "text": "This data can be structured even more."
                },
                {
                    "type": "code",
                    "code": "constpeople=[{id:0,name:'Creola Katherine Johnson',profession:'mathematician',},{id:1,name:'Mario José Molina-Pasquel Henríquez',profession:'chemist',},{id:2,name:'Mohammad Abdus Salam',profession:'physicist',},{id:3,name:'Percy Lavon Julian',profession:'chemist',},{id:4,name:'Subrahmanyan Chandrasekhar',profession:'astrophysicist',}];"
                },
                {
                    "type": "p",
                    "text": "Let’s say you want a way to only show people whose profession is'chemist'. You can use JavaScript’sfilter()method to return just those people. This method takes an array of items, passes them through a “test” (a function that returnstrueorfalse), and returns a new array of only those items that passed the test (returnedtrue)."
                },
                {
                    "type": "p",
                    "text": "You only want the items whereprofessionis'chemist'. The “test” function for this looks like(person) => person.profession === 'chemist'. Here’s how to put it together:"
                },
                {
                    "type": "list",
                    "items": [
                        "Createa new array of just “chemist” people,chemists, by callingfilter()on thepeoplefiltering byperson.profession === 'chemist':"
                    ]
                },
                {
                    "type": "code",
                    "code": "constchemists=people.filter(person=>person.profession==='chemist');"
                },
                {
                    "type": "list",
                    "items": [
                        "Nowmapoverchemists:"
                    ]
                },
                {
                    "type": "code",
                    "code": "constlistItems=chemists.map(person=><li><imgsrc={getImageUrl(person)}alt={person.name}/><p><b>{person.name}:</b>{' '+person.profession+' '}known for{person.accomplishment}</p></li>);"
                },
                {
                    "type": "list",
                    "items": [
                        "Lastly,returnthelistItemsfrom your component:"
                    ]
                },
                {
                    "type": "code",
                    "code": "return<ul>{listItems}</ul>;"
                },
                {
                    "type": "code",
                    "code": "import{people}from'./data.js';import{getImageUrl}from'./utils.js';exportdefaultfunctionList(){constchemists=people.filter(person=>person.profession==='chemist');constlistItems=chemists.map(person=><li><imgsrc={getImageUrl(person)}alt={person.name}/><p><b>{person.name}:</b>{' '+person.profession+' '}known for{person.accomplishment}</p></li>);return<ul>{listItems}</ul>;}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Arrow functions implicitly return the expression right after=>, so you didn’t need areturnstatement:"
                },
                {
                    "type": "code",
                    "code": "constlistItems=chemists.map(person=><li>...</li>// Implicit return!);"
                },
                {
                    "type": "p",
                    "text": "However,you must writereturnexplicitly if your=>is followed by a{curly brace!"
                },
                {
                    "type": "code",
                    "code": "constlistItems=chemists.map(person=>{// Curly bracereturn<li>...</li>;});"
                },
                {
                    "type": "p",
                    "text": "Arrow functions containing=> {are said to have a“block body”.They let you write more than a single line of code, but youhave towrite areturnstatement yourself. If you forget it, nothing gets returned!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Keeping list items in order withkey"
                },
                {
                    "type": "p",
                    "text": "Notice that all the sandboxes above show an error in the console:"
                },
                {
                    "type": "p",
                    "text": "You need to give each array item akey— a string or a number that uniquely identifies it among other items in that array:"
                },
                {
                    "type": "code",
                    "code": "<likey={person.id}>...</li>"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "JSX elements directly inside amap()call always need keys!"
                },
                {
                    "type": "p",
                    "text": "Keys tell React which array item each component corresponds to, so that it can match them up later. This becomes important if your array items can move (e.g. due to sorting), get inserted, or get deleted. A well-chosenkeyhelps React infer what exactly has happened, and make the correct updates to the DOM tree."
                },
                {
                    "type": "p",
                    "text": "Rather than generating keys on the fly, you should include them in your data:"
                },
                {
                    "type": "code",
                    "code": "exportconstpeople=[{id:0,// Used in JSX as a keyname:'Creola Katherine Johnson',profession:'mathematician',accomplishment:'spaceflight calculations',imageId:'MK3eW3A'},{id:1,// Used in JSX as a keyname:'Mario José Molina-Pasquel Henríquez',profession:'chemist',accomplishment:'discovery of Arctic ozone hole',imageId:'mynHUSa'},{id:2,// Used in JSX as a keyname:'Mohammad Abdus Salam',profession:'physicist',accomplishment:'electromagnetism theory',imageId:'bE7W1ji'},{id:3,// Used in JSX as a keyname:'Percy Lavon Julian',profession:'chemist',accomplishment:'pioneering cortisone drugs, steroids and birth control pills',imageId:'IOjWm71'},{id:4,// Used in JSX as a keyname:'Subrahmanyan Chandrasekhar',profession:'astrophysicist',accomplishment:'white dwarf star mass calculations',imageId:'lrWQx8l'}];"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Displaying several DOM nodes for each list item"
                },
                {
                    "type": "p",
                    "text": "What do you do when each item needs to render not one, but several DOM nodes?"
                },
                {
                    "type": "p",
                    "text": "The short<>...</>Fragmentsyntax won’t let you pass a key, so you need to either group them into a single<div>, or use the slightly longer andmore explicit<Fragment>syntax:"
                },
                {
                    "type": "code",
                    "code": "import{Fragment}from'react';// ...constlistItems=people.map(person=><Fragmentkey={person.id}><h1>{person.name}</h1><p>{person.bio}</p></Fragment>);"
                },
                {
                    "type": "p",
                    "text": "Fragments disappear from the DOM, so this will produce a flat list of<h1>,<p>,<h1>,<p>, and so on."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Where to get yourkey"
                },
                {
                    "type": "p",
                    "text": "Different sources of data provide different sources of keys:"
                },
                {
                    "type": "list",
                    "items": [
                        "Data from a database:If your data is coming from a database, you can use the database keys/IDs, which are unique by nature.",
                        "Locally generated data:If your data is generated and persisted locally (e.g. notes in a note-taking app), use an incrementing counter,crypto.randomUUID()or a package likeuuidwhen creating items."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rules of keys"
                },
                {
                    "type": "list",
                    "items": [
                        "Keys must be unique among siblings.However, it’s okay to use the same keys for JSX nodes indifferentarrays.",
                        "Keys must not changeor that defeats their purpose! Don’t generate them while rendering."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Why does React need keys?"
                },
                {
                    "type": "p",
                    "text": "Imagine that files on your desktop didn’t have names. Instead, you’d refer to them by their order — the first file, the second file, and so on. You could get used to it, but once you delete a file, it would get confusing. The second file would become the first file, the third file would be the second file, and so on."
                },
                {
                    "type": "p",
                    "text": "File names in a folder and JSX keys in an array serve a similar purpose. They let us uniquely identify an item between its siblings. A well-chosen key provides more information than the position within the array. Even if thepositionchanges due to reordering, thekeylets React identify the item throughout its lifetime."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "You might be tempted to use an item’s index in the array as its key. In fact, that’s what React will use if you don’t specify akeyat all. But the order in which you render items will change over time if an item is inserted, deleted, or if the array gets reordered. Index as a key often leads to subtle and confusing bugs."
                },
                {
                    "type": "p",
                    "text": "Similarly, do not generate keys on the fly, e.g. withkey={Math.random()}. This will cause keys to never match up between renders, leading to all your components and DOM being recreated every time. Not only is this slow, but it will also lose any user input inside the list items. Instead, use a stable ID based on the data."
                },
                {
                    "type": "p",
                    "text": "Note that your components won’t receivekeyas a prop. It’s only used as a hint by React itself. If your component needs an ID, you have to pass it as a separate prop:<Profile key={id} userId={id} />."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "p",
                    "text": "On this page you learned:"
                },
                {
                    "type": "list",
                    "items": [
                        "How to move data out of components and into data structures like arrays and objects.",
                        "How to generate sets of similar components with JavaScript’smap().",
                        "How to create arrays of filtered items with JavaScript’sfilter().",
                        "Why and how to setkeyon each component in a collection so React can keep track of each of them even if their position or data changes."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of4:Splitting a list in two"
                },
                {
                    "type": "p",
                    "text": "This example shows a list of all people."
                },
                {
                    "type": "p",
                    "text": "Change it to show two separate lists one after another:ChemistsandEveryone Else.Like previously, you can determine whether a person is a chemist by checking ifperson.profession === 'chemist'."
                },
                {
                    "type": "code",
                    "code": "import{people}from'./data.js';import{getImageUrl}from'./utils.js';exportdefaultfunctionList(){constlistItems=people.map(person=><likey={person.id}><imgsrc={getImageUrl(person)}alt={person.name}/><p><b>{person.name}:</b>{' '+person.profession+' '}known for{person.accomplishment}</p></li>);return(<article><h1>Scientists</h1><ul>{listItems}</ul></article>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/responding-to-events",
            "title": "Responding to Events – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Responding to Events"
                },
                {
                    "type": "p",
                    "text": "React lets you addevent handlersto your JSX. Event handlers are your own functions that will be triggered in response to interactions like clicking, hovering, focusing form inputs, and so on."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "Different ways to write an event handler",
                        "How to pass event handling logic from a parent component",
                        "How events propagate and how to stop them"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Adding event handlers"
                },
                {
                    "type": "p",
                    "text": "To add an event handler, you will first define a function and thenpass it as a propto the appropriate JSX tag. For example, here is a button that doesn’t do anything yet:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionButton(){return(<button>I don't do anything</button>);}"
                },
                {
                    "type": "p",
                    "text": "You can make it show a message when a user clicks by following these three steps:"
                },
                {
                    "type": "list",
                    "items": [
                        "Declare a function calledhandleClickinsideyourButtoncomponent.",
                        "Implement the logic inside that function (usealertto show the message).",
                        "AddonClick={handleClick}to the<button>JSX."
                    ]
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionButton(){functionhandleClick(){alert('You clicked me!');}return(<buttononClick={handleClick}>Click me</button>);}"
                },
                {
                    "type": "p",
                    "text": "You defined thehandleClickfunction and thenpassed it as a propto<button>.handleClickis anevent handler.Event handler functions:"
                },
                {
                    "type": "list",
                    "items": [
                        "Are usually definedinsideyour components.",
                        "Have names that start withhandle, followed by the name of the event."
                    ]
                },
                {
                    "type": "p",
                    "text": "By convention, it is common to name event handlers ashandlefollowed by the event name. You’ll often seeonClick={handleClick},onMouseEnter={handleMouseEnter}, and so on."
                },
                {
                    "type": "p",
                    "text": "Alternatively, you can define an event handler inline in the JSX:"
                },
                {
                    "type": "code",
                    "code": "<buttononClick={functionhandleClick(){alert('You clicked me!');}}>"
                },
                {
                    "type": "p",
                    "text": "Or, more concisely, using an arrow function:"
                },
                {
                    "type": "code",
                    "code": "<buttononClick={()=>{alert('You clicked me!');}}>"
                },
                {
                    "type": "p",
                    "text": "All of these styles are equivalent. Inline event handlers are convenient for short functions."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Functions passed to event handlers must be passed, not called. For example:"
                },
                {
                    "type": "p",
                    "text": "The difference is subtle. In the first example, thehandleClickfunction is passed as anonClickevent handler. This tells React to remember it and only call your function when the user clicks the button."
                },
                {
                    "type": "p",
                    "text": "In the second example, the()at the end ofhandleClick()fires the functionimmediatelyduringrendering, without any clicks. This is because JavaScript inside theJSX{and}executes right away."
                },
                {
                    "type": "p",
                    "text": "When you write code inline, the same pitfall presents itself in a different way:"
                },
                {
                    "type": "p",
                    "text": "Passing inline code like this won’t fire on click—it fires every time the component renders:"
                },
                {
                    "type": "code",
                    "code": "// This alert fires when the component renders, not when clicked!<buttononClick={alert('You clicked me!')}>"
                },
                {
                    "type": "p",
                    "text": "If you want to define your event handler inline, wrap it in an anonymous function like so:"
                },
                {
                    "type": "code",
                    "code": "<buttononClick={()=>alert('You clicked me!')}>"
                },
                {
                    "type": "p",
                    "text": "Rather than executing the code inside with every render, this creates a function to be called later."
                },
                {
                    "type": "p",
                    "text": "In both cases, what you want to pass is a function:"
                },
                {
                    "type": "list",
                    "items": [
                        "<button onClick={handleClick}>passes thehandleClickfunction.",
                        "<button onClick={() => alert('...')}>passes the() => alert('...')function."
                    ]
                },
                {
                    "type": "p",
                    "text": "Read more about arrow functions."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Reading props in event handlers"
                },
                {
                    "type": "p",
                    "text": "Because event handlers are declared inside of a component, they have access to the component’s props. Here is a button that, when clicked, shows an alert with itsmessageprop:"
                },
                {
                    "type": "code",
                    "code": "functionAlertButton({message,children}){return(<buttononClick={()=>alert(message)}>{children}</button>);}exportdefaultfunctionToolbar(){return(<div><AlertButtonmessage=\"Playing!\">Play Movie</AlertButton><AlertButtonmessage=\"Uploading!\">Upload Image</AlertButton></div>);}"
                },
                {
                    "type": "p",
                    "text": "This lets these two buttons show different messages. Try changing the messages passed to them."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Passing event handlers as props"
                },
                {
                    "type": "p",
                    "text": "Often you’ll want the parent component to specify a child’s event handler. Consider buttons: depending on where you’re using aButtoncomponent, you might want to execute a different function—perhaps one plays a movie and another uploads an image."
                },
                {
                    "type": "p",
                    "text": "To do this, pass a prop the component receives from its parent as the event handler like so:"
                },
                {
                    "type": "code",
                    "code": "functionButton({onClick,children}){return(<buttononClick={onClick}>{children}</button>);}functionPlayButton({movieName}){functionhandlePlayClick(){alert(`Playing${movieName}!`);}return(<ButtononClick={handlePlayClick}>Play \"{movieName}\"</Button>);}functionUploadButton(){return(<ButtononClick={()=>alert('Uploading!')}>Upload Image</Button>);}exportdefaultfunctionToolbar(){return(<div><PlayButtonmovieName=\"Kiki's Delivery Service\"/><UploadButton/></div>);}"
                },
                {
                    "type": "p",
                    "text": "Here, theToolbarcomponent renders aPlayButtonand anUploadButton:"
                },
                {
                    "type": "list",
                    "items": [
                        "PlayButtonpasseshandlePlayClickas theonClickprop to theButtoninside.",
                        "UploadButtonpasses() => alert('Uploading!')as theonClickprop to theButtoninside."
                    ]
                },
                {
                    "type": "p",
                    "text": "Finally, yourButtoncomponent accepts a prop calledonClick. It passes that prop directly to the built-in browser<button>withonClick={onClick}. This tells React to call the passed function on click."
                },
                {
                    "type": "p",
                    "text": "If you use adesign system, it’s common for components like buttons to contain styling but not specify behavior. Instead, components likePlayButtonandUploadButtonwill pass event handlers down."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Naming event handler props"
                },
                {
                    "type": "p",
                    "text": "Built-in components like<button>and<div>only supportbrowser event nameslikeonClick. However, when you’re building your own components, you can name their event handler props any way that you like."
                },
                {
                    "type": "p",
                    "text": "By convention, event handler props should start withon, followed by a capital letter."
                },
                {
                    "type": "p",
                    "text": "For example, theButtoncomponent’sonClickprop could have been calledonSmash:"
                },
                {
                    "type": "code",
                    "code": "functionButton({onSmash,children}){return(<buttononClick={onSmash}>{children}</button>);}exportdefaultfunctionApp(){return(<div><ButtononSmash={()=>alert('Playing!')}>Play Movie</Button><ButtononSmash={()=>alert('Uploading!')}>Upload Image</Button></div>);}"
                },
                {
                    "type": "p",
                    "text": "In this example,<button onClick={onSmash}>shows that the browser<button>(lowercase) still needs a prop calledonClick, but the prop name received by your customButtoncomponent is up to you!"
                },
                {
                    "type": "p",
                    "text": "When your component supports multiple interactions, you might name event handler props for app-specific concepts. For example, thisToolbarcomponent receivesonPlayMovieandonUploadImageevent handlers:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionApp(){return(<ToolbaronPlayMovie={()=>alert('Playing!')}onUploadImage={()=>alert('Uploading!')}/>);}functionToolbar({onPlayMovie,onUploadImage}){return(<div><ButtononClick={onPlayMovie}>Play Movie</Button><ButtononClick={onUploadImage}>Upload Image</Button></div>);}functionButton({onClick,children}){return(<buttononClick={onClick}>{children}</button>);}"
                },
                {
                    "type": "p",
                    "text": "Notice how theAppcomponent does not need to knowwhatToolbarwill do withonPlayMovieoronUploadImage. That’s an implementation detail of theToolbar. Here,Toolbarpasses them down asonClickhandlers to itsButtons, but it could later also trigger them on a keyboard shortcut. Naming props after app-specific interactions likeonPlayMoviegives you the flexibility to change how they’re used later."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Make sure that you use the appropriate HTML tags for your event handlers. For example, to handle clicks, use<button onClick={handleClick}>instead of<div onClick={handleClick}>. Using a real browser<button>enables built-in browser behaviors like keyboard navigation. If you don’t like the default browser styling of a button and want to make it look more like a link or a different UI element, you can achieve it with CSS.Learn more about writing accessible markup."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Event propagation"
                },
                {
                    "type": "p",
                    "text": "Event handlers will also catch events from any children your component might have. We say that an event “bubbles” or “propagates” up the tree: it starts with where the event happened, and then goes up the tree."
                },
                {
                    "type": "p",
                    "text": "This<div>contains two buttons. Both the<div>andeach button have their ownonClickhandlers. Which handlers do you think will fire when you click a button?"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionToolbar(){return(<divclassName=\"Toolbar\"onClick={()=>{alert('You clicked on the toolbar!');}}><buttononClick={()=>alert('Playing!')}>Play Movie</button><buttononClick={()=>alert('Uploading!')}>Upload Image</button></div>);}"
                },
                {
                    "type": "p",
                    "text": "If you click on either button, itsonClickwill run first, followed by the parent<div>’sonClick. So two messages will appear. If you click the toolbar itself, only the parent<div>’sonClickwill run."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "All events propagate in React exceptonScroll, which only works on the JSX tag you attach it to."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Stopping propagation"
                },
                {
                    "type": "p",
                    "text": "Event handlers receive anevent objectas their only argument. By convention, it’s usually callede, which stands for “event”. You can use this object to read information about the event."
                },
                {
                    "type": "p",
                    "text": "That event object also lets you stop the propagation. If you want to prevent an event from reaching parent components, you need to calle.stopPropagation()like thisButtoncomponent does:"
                },
                {
                    "type": "code",
                    "code": "functionButton({onClick,children}){return(<buttononClick={e=>{e.stopPropagation();onClick();}}>{children}</button>);}exportdefaultfunctionToolbar(){return(<divclassName=\"Toolbar\"onClick={()=>{alert('You clicked on the toolbar!');}}><ButtononClick={()=>alert('Playing!')}>Play Movie</Button><ButtononClick={()=>alert('Uploading!')}>Upload Image</Button></div>);}"
                },
                {
                    "type": "p",
                    "text": "When you click on a button:"
                },
                {
                    "type": "list",
                    "items": [
                        "React calls theonClickhandler passed to<button>.",
                        "That handler, defined inButton, does the following:Callse.stopPropagation(), preventing the event from bubbling further.Calls theonClickfunction, which is a prop passed from theToolbarcomponent.",
                        "Callse.stopPropagation(), preventing the event from bubbling further.",
                        "Calls theonClickfunction, which is a prop passed from theToolbarcomponent.",
                        "That function, defined in theToolbarcomponent, displays the button’s own alert.",
                        "Since the propagation was stopped, the parent<div>’sonClickhandler doesnotrun."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Callse.stopPropagation(), preventing the event from bubbling further.",
                        "Calls theonClickfunction, which is a prop passed from theToolbarcomponent."
                    ]
                },
                {
                    "type": "p",
                    "text": "As a result ofe.stopPropagation(), clicking on the buttons now only shows a single alert (from the<button>) rather than the two of them (from the<button>and the parent toolbar<div>). Clicking a button is not the same thing as clicking the surrounding toolbar, so stopping the propagation makes sense for this UI."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Capture phase events"
                },
                {
                    "type": "p",
                    "text": "In rare cases, you might need to catch all events on child elements,even if they stopped propagation. For example, maybe you want to log every click to analytics, regardless of the propagation logic. You can do this by addingCaptureat the end of the event name:"
                },
                {
                    "type": "code",
                    "code": "<divonClickCapture={()=>{/* this runs first */}}><buttononClick={e=>e.stopPropagation()}/><buttononClick={e=>e.stopPropagation()}/></div>"
                },
                {
                    "type": "p",
                    "text": "Each event propagates in three phases:"
                },
                {
                    "type": "list",
                    "items": [
                        "It travels down, calling allonClickCapturehandlers.",
                        "It runs the clicked element’sonClickhandler.",
                        "It travels upwards, calling allonClickhandlers."
                    ]
                },
                {
                    "type": "p",
                    "text": "Capture events are useful for code like routers or analytics, but you probably won’t use them in app code."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Passing handlers as alternative to propagation"
                },
                {
                    "type": "p",
                    "text": "Notice how this click handler runs a line of codeand thencalls theonClickprop passed by the parent:"
                },
                {
                    "type": "code",
                    "code": "functionButton({onClick,children}){return(<buttononClick={e=>{e.stopPropagation();onClick();}}>{children}</button>);}"
                },
                {
                    "type": "p",
                    "text": "You could add more code to this handler before calling the parentonClickevent handler, too. This pattern provides analternativeto propagation. It lets the child component handle the event, while also letting the parent component specify some additional behavior. Unlike propagation, it’s not automatic. But the benefit of this pattern is that you can clearly follow the whole chain of code that executes as a result of some event."
                },
                {
                    "type": "p",
                    "text": "If you rely on propagation and it’s difficult to trace which handlers execute and why, try this approach instead."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Preventing default behavior"
                },
                {
                    "type": "p",
                    "text": "Some browser events have default behavior associated with them. For example, a<form>submit event, which happens when a button inside of it is clicked, will reload the whole page by default:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionSignup(){return(<formonSubmit={()=>alert('Submitting!')}><input/><button>Send</button></form>);}"
                },
                {
                    "type": "p",
                    "text": "You can calle.preventDefault()on the event object to stop this from happening:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionSignup(){return(<formonSubmit={e=>{e.preventDefault();alert('Submitting!');}}><input/><button>Send</button></form>);}"
                },
                {
                    "type": "p",
                    "text": "Don’t confusee.stopPropagation()ande.preventDefault(). They are both useful, but are unrelated:"
                },
                {
                    "type": "list",
                    "items": [
                        "e.stopPropagation()stops the event handlers attached to the tags above from firing.",
                        "e.preventDefault()prevents the default browser behavior for the few events that have it."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Can event handlers have side effects?"
                },
                {
                    "type": "p",
                    "text": "Absolutely! Event handlers are the best place for side effects."
                },
                {
                    "type": "p",
                    "text": "Unlike rendering functions, event handlers don’t need to bepure, so it’s a great place tochangesomething—for example, change an input’s value in response to typing, or change a list in response to a button press. However, in order to change some information, you first need some way to store it. In React, this is done by usingstate, a component’s memory.You will learn all about it on the next page."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "You can handle events by passing a function as a prop to an element like<button>.",
                        "Event handlers must be passed,not called!onClick={handleClick}, notonClick={handleClick()}.",
                        "You can define an event handler function separately or inline.",
                        "Event handlers are defined inside a component, so they can access props.",
                        "You can declare an event handler in a parent and pass it as a prop to a child.",
                        "You can define your own event handler props with application-specific names.",
                        "Events propagate upwards. Calle.stopPropagation()on the first argument to prevent that.",
                        "Events may have unwanted default browser behavior. Calle.preventDefault()to prevent that.",
                        "Explicitly calling an event handler prop from a child handler is a good alternative to propagation."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of2:Fix an event handler"
                },
                {
                    "type": "p",
                    "text": "Clicking this button is supposed to switch the page background between white and black. However, nothing happens when you click it. Fix the problem. (Don’t worry about the logic insidehandleClick—that part is fine.)"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionLightSwitch(){functionhandleClick(){letbodyStyle=document.body.style;if(bodyStyle.backgroundColor==='black'){bodyStyle.backgroundColor='white';}else{bodyStyle.backgroundColor='black';}}return(<buttononClick={handleClick()}>Toggle the lights</button>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/reusing-logic-with-custom-hooks",
            "title": "Reusing Logic with Custom Hooks – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Reusing Logic with Custom Hooks"
                },
                {
                    "type": "p",
                    "text": "React comes with several built-in Hooks likeuseState,useContext, anduseEffect. Sometimes, you’ll wish that there was a Hook for some more specific purpose: for example, to fetch data, to keep track of whether the user is online, or to connect to a chat room. You might not find these Hooks in React, but you can create your own Hooks for your application’s needs."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "What custom Hooks are, and how to write your own",
                        "How to reuse logic between components",
                        "How to name and structure your custom Hooks",
                        "When and why to extract custom Hooks"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Custom Hooks: Sharing logic between components"
                },
                {
                    "type": "p",
                    "text": "Imagine you’re developing an app that heavily relies on the network (as most apps do). You want to warn the user if their network connection has accidentally gone off while they were using your app. How would you go about it? It seems like you’ll need two things in your component:"
                },
                {
                    "type": "list",
                    "items": [
                        "A piece of state that tracks whether the network is online.",
                        "An Effect that subscribes to the globalonlineandofflineevents, and updates that state."
                    ]
                },
                {
                    "type": "p",
                    "text": "This will keep your componentsynchronizedwith the network status. You might start with something like this:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';exportdefaultfunctionStatusBar(){const[isOnline,setIsOnline]=useState(true);useEffect(()=>{functionhandleOnline(){setIsOnline(true);}functionhandleOffline(){setIsOnline(false);}window.addEventListener('online',handleOnline);window.addEventListener('offline',handleOffline);return()=>{window.removeEventListener('online',handleOnline);window.removeEventListener('offline',handleOffline);};},[]);return<h1>{isOnline?'✅ Online':'❌ Disconnected'}</h1>;}"
                },
                {
                    "type": "p",
                    "text": "Try turning your network on and off, and notice how thisStatusBarupdates in response to your actions."
                },
                {
                    "type": "p",
                    "text": "Now imagine youalsowant to use the same logic in a different component. You want to implement a Save button that will become disabled and show “Reconnecting…” instead of “Save” while the network is off."
                },
                {
                    "type": "p",
                    "text": "To start, you can copy and paste theisOnlinestate and the Effect intoSaveButton:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';exportdefaultfunctionSaveButton(){const[isOnline,setIsOnline]=useState(true);useEffect(()=>{functionhandleOnline(){setIsOnline(true);}functionhandleOffline(){setIsOnline(false);}window.addEventListener('online',handleOnline);window.addEventListener('offline',handleOffline);return()=>{window.removeEventListener('online',handleOnline);window.removeEventListener('offline',handleOffline);};},[]);functionhandleSaveClick(){console.log('✅ Progress saved');}return(<buttondisabled={!isOnline}onClick={handleSaveClick}>{isOnline?'Save progress':'Reconnecting...'}</button>);}"
                },
                {
                    "type": "p",
                    "text": "Verify that, if you turn off the network, the button will change its appearance."
                },
                {
                    "type": "p",
                    "text": "These two components work fine, but the duplication in logic between them is unfortunate. It seems like even though they have differentvisual appearance,you want to reuse the logic between them."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Extracting your own custom Hook from a component"
                },
                {
                    "type": "p",
                    "text": "Imagine for a moment that, similar touseStateanduseEffect, there was a built-inuseOnlineStatusHook. Then both of these components could be simplified and you could remove the duplication between them:"
                },
                {
                    "type": "code",
                    "code": "functionStatusBar(){constisOnline=useOnlineStatus();return<h1>{isOnline?'✅ Online':'❌ Disconnected'}</h1>;}functionSaveButton(){constisOnline=useOnlineStatus();functionhandleSaveClick(){console.log('✅ Progress saved');}return(<buttondisabled={!isOnline}onClick={handleSaveClick}>{isOnline?'Save progress':'Reconnecting...'}</button>);}"
                },
                {
                    "type": "p",
                    "text": "Although there is no such built-in Hook, you can write it yourself. Declare a function calleduseOnlineStatusand move all the duplicated code into it from the components you wrote earlier:"
                },
                {
                    "type": "code",
                    "code": "functionuseOnlineStatus(){const[isOnline,setIsOnline]=useState(true);useEffect(()=>{functionhandleOnline(){setIsOnline(true);}functionhandleOffline(){setIsOnline(false);}window.addEventListener('online',handleOnline);window.addEventListener('offline',handleOffline);return()=>{window.removeEventListener('online',handleOnline);window.removeEventListener('offline',handleOffline);};},[]);returnisOnline;}"
                },
                {
                    "type": "p",
                    "text": "At the end of the function, returnisOnline. This lets your components read that value:"
                },
                {
                    "type": "code",
                    "code": "import{useOnlineStatus}from'./useOnlineStatus.js';functionStatusBar(){constisOnline=useOnlineStatus();return<h1>{isOnline?'✅ Online':'❌ Disconnected'}</h1>;}functionSaveButton(){constisOnline=useOnlineStatus();functionhandleSaveClick(){console.log('✅ Progress saved');}return(<buttondisabled={!isOnline}onClick={handleSaveClick}>{isOnline?'Save progress':'Reconnecting...'}</button>);}exportdefaultfunctionApp(){return(<><SaveButton/><StatusBar/></>);}"
                },
                {
                    "type": "p",
                    "text": "Verify that switching the network on and off updates both components."
                },
                {
                    "type": "p",
                    "text": "Now your components don’t have as much repetitive logic.More importantly, the code inside them describeswhat they want to do(use the online status!) rather thanhow to do it(by subscribing to the browser events)."
                },
                {
                    "type": "p",
                    "text": "When you extract logic into custom Hooks, you can hide the gnarly details of how you deal with some external system or a browser API. The code of your components expresses your intent, not the implementation."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Hook names always start withuse"
                },
                {
                    "type": "p",
                    "text": "React applications are built from components. Components are built from Hooks, whether built-in or custom. You’ll likely often use custom Hooks created by others, but occasionally you might write one yourself!"
                },
                {
                    "type": "p",
                    "text": "You must follow these naming conventions:"
                },
                {
                    "type": "list",
                    "items": [
                        "React component names must start with a capital letter,likeStatusBarandSaveButton. React components also need to return something that React knows how to display, like a piece of JSX.",
                        "Hook names must start withusefollowed by a capital letter,likeuseState(built-in) oruseOnlineStatus(custom, like earlier on the page). Hooks may return arbitrary values."
                    ]
                },
                {
                    "type": "p",
                    "text": "This convention guarantees that you can always look at a component and know where its state, Effects, and other React features might “hide”. For example, if you see agetColor()function call inside your component, you can be sure that it can’t possibly contain React state inside because its name doesn’t start withuse. However, a function call likeuseOnlineStatus()will most likely contain calls to other Hooks inside!"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "If your linter isconfigured for React,it will enforce this naming convention. Scroll up to the sandbox above and renameuseOnlineStatustogetOnlineStatus. Notice that the linter won’t allow you to calluseStateoruseEffectinside of it anymore. Only Hooks and components can call other Hooks!"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Should all functions called during rendering start with the use prefix?"
                },
                {
                    "type": "p",
                    "text": "No. Functions that don’tcallHooks don’t need tobeHooks."
                },
                {
                    "type": "p",
                    "text": "If your function doesn’t call any Hooks, avoid theuseprefix. Instead, write it as a regular functionwithouttheuseprefix. For example,useSortedbelow doesn’t call Hooks, so call itgetSortedinstead:"
                },
                {
                    "type": "code",
                    "code": "// 🔴 Avoid: A Hook that doesn't use HooksfunctionuseSorted(items){returnitems.slice().sort();}// ✅ Good: A regular function that doesn't use HooksfunctiongetSorted(items){returnitems.slice().sort();}"
                },
                {
                    "type": "p",
                    "text": "This ensures that your code can call this regular function anywhere, including conditions:"
                },
                {
                    "type": "code",
                    "code": "functionList({items,shouldSort}){letdisplayedItems=items;if(shouldSort){// ✅ It's ok to call getSorted() conditionally because it's not a HookdisplayedItems=getSorted(items);}// ...}"
                },
                {
                    "type": "p",
                    "text": "You should giveuseprefix to a function (and thus make it a Hook) if it uses at least one Hook inside of it:"
                },
                {
                    "type": "code",
                    "code": "// ✅ Good: A Hook that uses other HooksfunctionuseAuth(){returnuseContext(Auth);}"
                },
                {
                    "type": "p",
                    "text": "Technically, this isn’t enforced by React. In principle, you could make a Hook that doesn’t call other Hooks. This is often confusing and limiting so it’s best to avoid that pattern. However, there may be rare cases where it is helpful. For example, maybe your function doesn’t use any Hooks right now, but you plan to add some Hook calls to it in the future. Then it makes sense to name it with theuseprefix:"
                },
                {
                    "type": "code",
                    "code": "// ✅ Good: A Hook that will likely use some other Hooks laterfunctionuseAuth(){// TODO: Replace with this line when authentication is implemented:// return useContext(Auth);returnTEST_USER;}"
                },
                {
                    "type": "p",
                    "text": "Then components won’t be able to call it conditionally. This will become important when you actually add Hook calls inside. If you don’t plan to use Hooks inside it (now or later), don’t make it a Hook."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Custom Hooks let you share stateful logic, not state itself"
                },
                {
                    "type": "p",
                    "text": "In the earlier example, when you turned the network on and off, both components updated together. However, it’s wrong to think that a singleisOnlinestate variable is shared between them. Look at this code:"
                },
                {
                    "type": "code",
                    "code": "functionStatusBar(){constisOnline=useOnlineStatus();// ...}functionSaveButton(){constisOnline=useOnlineStatus();// ...}"
                },
                {
                    "type": "p",
                    "text": "It works the same way as before you extracted the duplication:"
                },
                {
                    "type": "code",
                    "code": "functionStatusBar(){const[isOnline,setIsOnline]=useState(true);useEffect(()=>{// ...},[]);// ...}functionSaveButton(){const[isOnline,setIsOnline]=useState(true);useEffect(()=>{// ...},[]);// ...}"
                },
                {
                    "type": "p",
                    "text": "These are two completely independent state variables and Effects! They happened to have the same value at the same time because you synchronized them with the same external value (whether the network is on)."
                },
                {
                    "type": "p",
                    "text": "To better illustrate this, we’ll need a different example. Consider thisFormcomponent:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionForm(){const[firstName,setFirstName]=useState('Mary');const[lastName,setLastName]=useState('Poppins');functionhandleFirstNameChange(e){setFirstName(e.target.value);}functionhandleLastNameChange(e){setLastName(e.target.value);}return(<><label>First name:<inputvalue={firstName}onChange={handleFirstNameChange}/></label><label>Last name:<inputvalue={lastName}onChange={handleLastNameChange}/></label><p><b>Good morning,{firstName}{lastName}.</b></p></>);}"
                },
                {
                    "type": "p",
                    "text": "There’s some repetitive logic for each form field:"
                },
                {
                    "type": "list",
                    "items": [
                        "There’s a piece of state (firstNameandlastName).",
                        "There’s a change handler (handleFirstNameChangeandhandleLastNameChange).",
                        "There’s a piece of JSX that specifies thevalueandonChangeattributes for that input."
                    ]
                },
                {
                    "type": "p",
                    "text": "You can extract the repetitive logic into thisuseFormInputcustom Hook:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportfunctionuseFormInput(initialValue){const[value,setValue]=useState(initialValue);functionhandleChange(e){setValue(e.target.value);}constinputProps={value:value,onChange:handleChange};returninputProps;}"
                },
                {
                    "type": "p",
                    "text": "Notice that it only declaresonestate variable calledvalue."
                },
                {
                    "type": "p",
                    "text": "However, theFormcomponent callsuseFormInputtwo times:"
                },
                {
                    "type": "code",
                    "code": "functionForm(){constfirstNameProps=useFormInput('Mary');constlastNameProps=useFormInput('Poppins');// ..."
                },
                {
                    "type": "p",
                    "text": "This is why it works like declaring two separate state variables!"
                },
                {
                    "type": "p",
                    "text": "Custom Hooks let you sharestateful logicbut notstate itself.Each call to a Hook is completely independent from every other call to the same Hook.This is why the two sandboxes above are completely equivalent. If you’d like, scroll back up and compare them. The behavior before and after extracting a custom Hook is identical."
                },
                {
                    "type": "p",
                    "text": "When you need to share the state itself between multiple components,lift it up and pass it downinstead."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Passing reactive values between Hooks"
                },
                {
                    "type": "p",
                    "text": "The code inside your custom Hooks will re-run during every re-render of your component. This is why, like components, custom Hooksneed to be pure.Think of custom Hooks’ code as part of your component’s body!"
                },
                {
                    "type": "p",
                    "text": "Because custom Hooks re-render together with your component, they always receive the latest props and state. To see what this means, consider this chat room example. Change the server URL or the chat room:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection}from'./chat.js';import{showNotification}from'./notifications.js';exportdefaultfunctionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useEffect(()=>{constoptions={serverUrl:serverUrl,roomId:roomId};constconnection=createConnection(options);connection.on('message',(msg)=>{showNotification('New message: '+msg);});connection.connect();return()=>connection.disconnect();},[roomId,serverUrl]);return(<><label>Server URL:<inputvalue={serverUrl}onChange={e=>setServerUrl(e.target.value)}/></label><h1>Welcome to the{roomId}room!</h1></>);}"
                },
                {
                    "type": "p",
                    "text": "When you changeserverUrlorroomId, the Effect“reacts” to your changesand re-synchronizes. You can tell by the console messages that the chat re-connects every time that you change your Effect’s dependencies."
                },
                {
                    "type": "p",
                    "text": "Now move the Effect’s code into a custom Hook:"
                },
                {
                    "type": "code",
                    "code": "exportfunctionuseChatRoom({serverUrl,roomId}){useEffect(()=>{constoptions={serverUrl:serverUrl,roomId:roomId};constconnection=createConnection(options);connection.connect();connection.on('message',(msg)=>{showNotification('New message: '+msg);});return()=>connection.disconnect();},[roomId,serverUrl]);}"
                },
                {
                    "type": "p",
                    "text": "This lets yourChatRoomcomponent call your custom Hook without worrying about how it works inside:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useChatRoom({roomId:roomId,serverUrl:serverUrl});return(<><label>Server URL:<inputvalue={serverUrl}onChange={e=>setServerUrl(e.target.value)}/></label><h1>Welcome to the{roomId}room!</h1></>);}"
                },
                {
                    "type": "p",
                    "text": "This looks much simpler! (But it does the same thing.)"
                },
                {
                    "type": "p",
                    "text": "Notice that the logicstill respondsto prop and state changes. Try editing the server URL or the selected room:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';import{useChatRoom}from'./useChatRoom.js';exportdefaultfunctionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useChatRoom({roomId:roomId,serverUrl:serverUrl});return(<><label>Server URL:<inputvalue={serverUrl}onChange={e=>setServerUrl(e.target.value)}/></label><h1>Welcome to the{roomId}room!</h1></>);}"
                },
                {
                    "type": "p",
                    "text": "Notice how you’re taking the return value of one Hook:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useChatRoom({roomId:roomId,serverUrl:serverUrl});// ..."
                },
                {
                    "type": "p",
                    "text": "and pass it as an input to another Hook:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useChatRoom({roomId:roomId,serverUrl:serverUrl});// ..."
                },
                {
                    "type": "p",
                    "text": "Every time yourChatRoomcomponent re-renders, it passes the latestroomIdandserverUrlto your Hook. This is why your Effect re-connects to the chat whenever their values are different after a re-render. (If you ever worked with audio or video processing software, chaining Hooks like this might remind you of chaining visual or audio effects. It’s as if the output ofuseState“feeds into” the input of theuseChatRoom.)"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Passing event handlers to custom Hooks"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Under Construction"
                },
                {
                    "type": "p",
                    "text": "This section describes anexperimental API that has not yet been releasedin a stable version of React."
                },
                {
                    "type": "p",
                    "text": "As you start usinguseChatRoomin more components, you might want to let components customize its behavior. For example, currently, the logic for what to do when a message arrives is hardcoded inside the Hook:"
                },
                {
                    "type": "code",
                    "code": "exportfunctionuseChatRoom({serverUrl,roomId}){useEffect(()=>{constoptions={serverUrl:serverUrl,roomId:roomId};constconnection=createConnection(options);connection.connect();connection.on('message',(msg)=>{showNotification('New message: '+msg);});return()=>connection.disconnect();},[roomId,serverUrl]);}"
                },
                {
                    "type": "p",
                    "text": "Let’s say you want to move this logic back to your component:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useChatRoom({roomId:roomId,serverUrl:serverUrl,onReceiveMessage(msg){showNotification('New message: '+msg);}});// ..."
                },
                {
                    "type": "p",
                    "text": "To make this work, change your custom Hook to takeonReceiveMessageas one of its named options:"
                },
                {
                    "type": "code",
                    "code": "exportfunctionuseChatRoom({serverUrl,roomId,onReceiveMessage}){useEffect(()=>{constoptions={serverUrl:serverUrl,roomId:roomId};constconnection=createConnection(options);connection.connect();connection.on('message',(msg)=>{onReceiveMessage(msg);});return()=>connection.disconnect();},[roomId,serverUrl,onReceiveMessage]);// ✅ All dependencies declared}"
                },
                {
                    "type": "p",
                    "text": "This will work, but there’s one more improvement you can do when your custom Hook accepts event handlers."
                },
                {
                    "type": "p",
                    "text": "Adding a dependency ononReceiveMessageis not ideal because it will cause the chat to re-connect every time the component re-renders.Wrap this event handler into an Effect Event to remove it from the dependencies:"
                },
                {
                    "type": "code",
                    "code": "import{useEffect,useEffectEvent}from'react';// ...exportfunctionuseChatRoom({serverUrl,roomId,onReceiveMessage}){constonMessage=useEffectEvent(onReceiveMessage);useEffect(()=>{constoptions={serverUrl:serverUrl,roomId:roomId};constconnection=createConnection(options);connection.connect();connection.on('message',(msg)=>{onMessage(msg);});return()=>connection.disconnect();},[roomId,serverUrl]);// ✅ All dependencies declared}"
                },
                {
                    "type": "p",
                    "text": "Now the chat won’t re-connect every time that theChatRoomcomponent re-renders. Here is a fully working demo of passing an event handler to a custom Hook that you can play with:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';import{useChatRoom}from'./useChatRoom.js';import{showNotification}from'./notifications.js';exportdefaultfunctionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useChatRoom({roomId:roomId,serverUrl:serverUrl,onReceiveMessage(msg){showNotification('New message: '+msg);}});return(<><label>Server URL:<inputvalue={serverUrl}onChange={e=>setServerUrl(e.target.value)}/></label><h1>Welcome to the{roomId}room!</h1></>);}"
                },
                {
                    "type": "p",
                    "text": "Notice how you no longer need to knowhowuseChatRoomworks in order to use it. You could add it to any other component, pass any other options, and it would work the same way. That’s the power of custom Hooks."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "When to use custom Hooks"
                },
                {
                    "type": "p",
                    "text": "You don’t need to extract a custom Hook for every little duplicated bit of code. Some duplication is fine. For example, extracting auseFormInputHook to wrap a singleuseStatecall like earlier is probably unnecessary."
                },
                {
                    "type": "p",
                    "text": "However, whenever you write an Effect, consider whether it would be clearer to also wrap it in a custom Hook.You shouldn’t need Effects very often,so if you’re writing one, it means that you need to “step outside React” to synchronize with some external system or to do something that React doesn’t have a built-in API for. Wrapping it into a custom Hook lets you precisely communicate your intent and how the data flows through it."
                },
                {
                    "type": "p",
                    "text": "For example, consider aShippingFormcomponent that displays two dropdowns: one shows the list of cities, and another shows the list of areas in the selected city. You might start with some code that looks like this:"
                },
                {
                    "type": "code",
                    "code": "functionShippingForm({country}){const[cities,setCities]=useState(null);// This Effect fetches cities for a countryuseEffect(()=>{letignore=false;fetch(`/api/cities?country=${country}`).then(response=>response.json()).then(json=>{if(!ignore){setCities(json);}});return()=>{ignore=true;};},[country]);const[city,setCity]=useState(null);const[areas,setAreas]=useState(null);// This Effect fetches areas for the selected cityuseEffect(()=>{if(city){letignore=false;fetch(`/api/areas?city=${city}`).then(response=>response.json()).then(json=>{if(!ignore){setAreas(json);}});return()=>{ignore=true;};}},[city]);// ..."
                },
                {
                    "type": "p",
                    "text": "Although this code is quite repetitive,it’s correct to keep these Effects separate from each other.They synchronize two different things, so you shouldn’t merge them into one Effect. Instead, you can simplify theShippingFormcomponent above by extracting the common logic between them into your ownuseDataHook:"
                },
                {
                    "type": "code",
                    "code": "functionuseData(url){const[data,setData]=useState(null);useEffect(()=>{if(url){letignore=false;fetch(url).then(response=>response.json()).then(json=>{if(!ignore){setData(json);}});return()=>{ignore=true;};}},[url]);returndata;}"
                },
                {
                    "type": "p",
                    "text": "Now you can replace both Effects in theShippingFormcomponents with calls touseData:"
                },
                {
                    "type": "code",
                    "code": "functionShippingForm({country}){constcities=useData(`/api/cities?country=${country}`);const[city,setCity]=useState(null);constareas=useData(city?`/api/areas?city=${city}`:null);// ..."
                },
                {
                    "type": "p",
                    "text": "Extracting a custom Hook makes the data flow explicit. You feed theurlin and you get thedataout. By “hiding” your Effect insideuseData, you also prevent someone working on theShippingFormcomponent from addingunnecessary dependenciesto it. With time, most of your app’s Effects will be in custom Hooks."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Keep your custom Hooks focused on concrete high-level use cases"
                },
                {
                    "type": "p",
                    "text": "Start by choosing your custom Hook’s name. If you struggle to pick a clear name, it might mean that your Effect is too coupled to the rest of your component’s logic, and is not yet ready to be extracted."
                },
                {
                    "type": "p",
                    "text": "Ideally, your custom Hook’s name should be clear enough that even a person who doesn’t write code often could have a good guess about what your custom Hook does, what it takes, and what it returns:"
                },
                {
                    "type": "list",
                    "items": [
                        "✅useData(url)",
                        "✅useImpressionLog(eventName, extraData)",
                        "✅useChatRoom(options)"
                    ]
                },
                {
                    "type": "p",
                    "text": "When you synchronize with an external system, your custom Hook name may be more technical and use jargon specific to that system. It’s good as long as it would be clear to a person familiar with that system:"
                },
                {
                    "type": "list",
                    "items": [
                        "✅useMediaQuery(query)",
                        "✅useSocket(url)",
                        "✅useIntersectionObserver(ref, options)"
                    ]
                },
                {
                    "type": "p",
                    "text": "Keep custom Hooks focused on concrete high-level use cases.Avoid creating and using custom “lifecycle” Hooks that act as alternatives and convenience wrappers for theuseEffectAPI itself:"
                },
                {
                    "type": "list",
                    "items": [
                        "🔴useMount(fn)",
                        "🔴useEffectOnce(fn)",
                        "🔴useUpdateEffect(fn)"
                    ]
                },
                {
                    "type": "p",
                    "text": "For example, thisuseMountHook tries to ensure some code only runs “on mount”:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');// 🔴 Avoid: using custom \"lifecycle\" HooksuseMount(()=>{constconnection=createConnection({roomId,serverUrl});connection.connect();post('/analytics/event',{eventName:'visit_chat'});});// ...}// 🔴 Avoid: creating custom \"lifecycle\" HooksfunctionuseMount(fn){useEffect(()=>{fn();},[]);// 🔴 React Hook useEffect has a missing dependency: 'fn'}"
                },
                {
                    "type": "p",
                    "text": "Custom “lifecycle” Hooks likeuseMountdon’t fit well into the React paradigm.For example, this code example has a mistake (it doesn’t “react” toroomIdorserverUrlchanges), but the linter won’t warn you about it because the linter only checks directuseEffectcalls. It won’t know about your Hook."
                },
                {
                    "type": "p",
                    "text": "If you’re writing an Effect, start by using the React API directly:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');// ✅ Good: two raw Effects separated by purposeuseEffect(()=>{constconnection=createConnection({serverUrl,roomId});connection.connect();return()=>connection.disconnect();},[serverUrl,roomId]);useEffect(()=>{post('/analytics/event',{eventName:'visit_chat',roomId});},[roomId]);// ...}"
                },
                {
                    "type": "p",
                    "text": "Then, you can (but don’t have to) extract custom Hooks for different high-level use cases:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');// ✅ Great: custom Hooks named after their purposeuseChatRoom({serverUrl,roomId});useImpressionLog('visit_chat',{roomId});// ...}"
                },
                {
                    "type": "p",
                    "text": "A good custom Hook makes the calling code more declarative by constraining what it does.For example,useChatRoom(options)can only connect to the chat room, whileuseImpressionLog(eventName, extraData)can only send an impression log to the analytics. If your custom Hook API doesn’t constrain the use cases and is very abstract, in the long run it’s likely to introduce more problems than it solves."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Custom Hooks help you migrate to better patterns"
                },
                {
                    "type": "p",
                    "text": "Effects are an“escape hatch”: you use them when you need to “step outside React” and when there is no better built-in solution for your use case. With time, the React team’s goal is to reduce the number of the Effects in your app to the minimum by providing more specific solutions to more specific problems. Wrapping your Effects in custom Hooks makes it easier to upgrade your code when these solutions become available."
                },
                {
                    "type": "p",
                    "text": "Let’s return to this example:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';exportfunctionuseOnlineStatus(){const[isOnline,setIsOnline]=useState(true);useEffect(()=>{functionhandleOnline(){setIsOnline(true);}functionhandleOffline(){setIsOnline(false);}window.addEventListener('online',handleOnline);window.addEventListener('offline',handleOffline);return()=>{window.removeEventListener('online',handleOnline);window.removeEventListener('offline',handleOffline);};},[]);returnisOnline;}"
                },
                {
                    "type": "p",
                    "text": "In the above example,useOnlineStatusis implemented with a pair ofuseStateanduseEffect.However, this isn’t the best possible solution. There is a number of edge cases it doesn’t consider. For example, it assumes that when the component mounts,isOnlineis alreadytrue, but this may be wrong if the network already went offline. You can use the browsernavigator.onLineAPI to check for that, but using it directly would not work on the server for generating the initial HTML. In short, this code could be improved."
                },
                {
                    "type": "p",
                    "text": "Luckily, React 18 includes a dedicated API calleduseSyncExternalStorewhich takes care of all of these problems for you. Here is how youruseOnlineStatusHook, rewritten to take advantage of this new API:"
                },
                {
                    "type": "code",
                    "code": "import{useSyncExternalStore}from'react';functionsubscribe(callback){window.addEventListener('online',callback);window.addEventListener('offline',callback);return()=>{window.removeEventListener('online',callback);window.removeEventListener('offline',callback);};}exportfunctionuseOnlineStatus(){returnuseSyncExternalStore(subscribe,()=>navigator.onLine,// How to get the value on the client()=>true// How to get the value on the server);}"
                },
                {
                    "type": "p",
                    "text": "Notice howyou didn’t need to change any of the componentsto make this migration:"
                },
                {
                    "type": "code",
                    "code": "functionStatusBar(){constisOnline=useOnlineStatus();// ...}functionSaveButton(){constisOnline=useOnlineStatus();// ...}"
                },
                {
                    "type": "p",
                    "text": "This is another reason for why wrapping Effects in custom Hooks is often beneficial:"
                },
                {
                    "type": "list",
                    "items": [
                        "You make the data flow to and from your Effects very explicit.",
                        "You let your components focus on the intent rather than on the exact implementation of your Effects.",
                        "When React adds new features, you can remove those Effects without changing any of your components."
                    ]
                },
                {
                    "type": "p",
                    "text": "Similar to adesign system,you might find it helpful to start extracting common idioms from your app’s components into custom Hooks. This will keep your components’ code focused on the intent, and let you avoid writing raw Effects very often. Many excellent custom Hooks are maintained by the React community."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Will React provide any built-in solution for data fetching?"
                },
                {
                    "type": "p",
                    "text": "We’re still working out the details, but we expect that in the future, you’ll write data fetching like this:"
                },
                {
                    "type": "code",
                    "code": "import{use}from'react';// Not available yet!functionShippingForm({country}){constcities=use(fetch(`/api/cities?country=${country}`));const[city,setCity]=useState(null);constareas=city?use(fetch(`/api/areas?city=${city}`)):null;// ..."
                },
                {
                    "type": "p",
                    "text": "If you use custom Hooks likeuseDataabove in your app, it will require fewer changes to migrate to the eventually recommended approach than if you write raw Effects in every component manually. However, the old approach will still work fine, so if you feel happy writing raw Effects, you can continue to do that."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "There is more than one way to do it"
                },
                {
                    "type": "p",
                    "text": "Let’s say you want to implement a fade-in animationfrom scratchusing the browserrequestAnimationFrameAPI. You might start with an Effect that sets up an animation loop. During each frame of the animation, you could change the opacity of the DOM node youhold in a refuntil it reaches1. Your code might start like this:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect,useRef}from'react';functionWelcome(){constref=useRef(null);useEffect(()=>{constduration=1000;constnode=ref.current;letstartTime=performance.now();letframeId=null;functiononFrame(now){consttimePassed=now-startTime;constprogress=Math.min(timePassed/duration,1);onProgress(progress);if(progress<1){// We still have more frames to paintframeId=requestAnimationFrame(onFrame);}}functiononProgress(progress){node.style.opacity=progress;}functionstart(){onProgress(0);startTime=performance.now();frameId=requestAnimationFrame(onFrame);}functionstop(){cancelAnimationFrame(frameId);startTime=null;frameId=null;}start();return()=>stop();},[]);return(<h1className=\"welcome\"ref={ref}>Welcome</h1>);}exportdefaultfunctionApp(){const[show,setShow]=useState(false);return(<><buttononClick={()=>setShow(!show)}>{show?'Remove':'Show'}</button><hr/>{show&&<Welcome/>}</>);}"
                },
                {
                    "type": "p",
                    "text": "To make the component more readable, you might extract the logic into auseFadeIncustom Hook:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect,useRef}from'react';import{useFadeIn}from'./useFadeIn.js';functionWelcome(){constref=useRef(null);useFadeIn(ref,1000);return(<h1className=\"welcome\"ref={ref}>Welcome</h1>);}exportdefaultfunctionApp(){const[show,setShow]=useState(false);return(<><buttononClick={()=>setShow(!show)}>{show?'Remove':'Show'}</button><hr/>{show&&<Welcome/>}</>);}"
                },
                {
                    "type": "p",
                    "text": "You could keep theuseFadeIncode as is, but you could also refactor it more. For example, you could extract the logic for setting up the animation loop out ofuseFadeIninto a customuseAnimationLoopHook:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{experimental_useEffectEventasuseEffectEvent}from'react';exportfunctionuseFadeIn(ref,duration){const[isRunning,setIsRunning]=useState(true);useAnimationLoop(isRunning,(timePassed)=>{constprogress=Math.min(timePassed/duration,1);ref.current.style.opacity=progress;if(progress===1){setIsRunning(false);}});}functionuseAnimationLoop(isRunning,drawFrame){constonFrame=useEffectEvent(drawFrame);useEffect(()=>{if(!isRunning){return;}conststartTime=performance.now();letframeId=null;functiontick(now){consttimePassed=now-startTime;onFrame(timePassed);frameId=requestAnimationFrame(tick);}tick();return()=>cancelAnimationFrame(frameId);},[isRunning]);}"
                },
                {
                    "type": "p",
                    "text": "However, you didn’thave todo that. As with regular functions, ultimately you decide where to draw the boundaries between different parts of your code. You could also take a very different approach. Instead of keeping the logic in the Effect, you could move most of the imperative logic inside a JavaScriptclass:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{FadeInAnimation}from'./animation.js';exportfunctionuseFadeIn(ref,duration){useEffect(()=>{constanimation=newFadeInAnimation(ref.current);animation.start(duration);return()=>{animation.stop();};},[ref,duration]);}"
                },
                {
                    "type": "p",
                    "text": "Effects let you connect React to external systems. The more coordination between Effects is needed (for example, to chain multiple animations), the more it makes sense to extract that logic out of Effects and Hookscompletelylike in the sandbox above. Then, the code you extractedbecomesthe “external system”. This lets your Effects stay simple because they only need to send messages to the system you’ve moved outside React."
                },
                {
                    "type": "p",
                    "text": "The examples above assume that the fade-in logic needs to be written in JavaScript. However, this particular fade-in animation is both simpler and much more efficient to implement with a plainCSS Animation:"
                },
                {
                    "type": "code",
                    "code": ".welcome{color:white;padding:50px;text-align:center;font-size:50px;background-image:radial-gradient(circle,rgba(63,94,251,1)0%,rgba(252,70,107,1)100%);animation:fadeIn1000ms;}@keyframesfadeIn{0%{opacity:0;}100%{opacity:1;}}"
                },
                {
                    "type": "p",
                    "text": "Sometimes, you don’t even need a Hook!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "Custom Hooks let you share logic between components.",
                        "Custom Hooks must be named starting withusefollowed by a capital letter.",
                        "Custom Hooks only share stateful logic, not state itself.",
                        "You can pass reactive values from one Hook to another, and they stay up-to-date.",
                        "All Hooks re-run every time your component re-renders.",
                        "The code of your custom Hooks should be pure, like your component’s code.",
                        "Wrap event handlers received by custom Hooks into Effect Events.",
                        "Don’t create custom Hooks likeuseMount. Keep their purpose specific.",
                        "It’s up to you how and where to choose the boundaries of your code."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of5:Extract auseCounterHook"
                },
                {
                    "type": "p",
                    "text": "This component uses a state variable and an Effect to display a number that increments every second. Extract this logic into a custom Hook calleduseCounter. Your goal is to make theCountercomponent implementation look exactly like this:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionCounter(){constcount=useCounter();return<h1>Seconds passed:{count}</h1>;}"
                },
                {
                    "type": "p",
                    "text": "You’ll need to write your custom Hook inuseCounter.jsand import it into theApp.jsfile."
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';exportdefaultfunctionCounter(){const[count,setCount]=useState(0);useEffect(()=>{constid=setInterval(()=>{setCount(c=>c+1);},1000);return()=>clearInterval(id);},[]);return<h1>Seconds passed:{count}</h1>;}"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/scaling-up-with-reducer-and-context",
            "title": "Scaling Up with Reducer and Context – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Scaling Up with Reducer and Context"
                },
                {
                    "type": "p",
                    "text": "Reducers let you consolidate a component’s state update logic. Context lets you pass information deep down to other components. You can combine reducers and context together to manage state of a complex screen."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "How to combine a reducer with context",
                        "How to avoid passing state and dispatch through props",
                        "How to keep context and state logic in a separate file"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Combining a reducer with context"
                },
                {
                    "type": "p",
                    "text": "In this example fromthe introduction to reducers, the state is managed by a reducer. The reducer function contains all of the state update logic and is declared at the bottom of this file:"
                },
                {
                    "type": "code",
                    "code": "import{useReducer}from'react';importAddTaskfrom'./AddTask.js';importTaskListfrom'./TaskList.js';exportdefaultfunctionTaskApp(){const[tasks,dispatch]=useReducer(tasksReducer,initialTasks);functionhandleAddTask(text){dispatch({type:'added',id:nextId++,text:text,});}functionhandleChangeTask(task){dispatch({type:'changed',task:task});}functionhandleDeleteTask(taskId){dispatch({type:'deleted',id:taskId});}return(<><h1>Day off in Kyoto</h1><AddTaskonAddTask={handleAddTask}/><TaskListtasks={tasks}onChangeTask={handleChangeTask}onDeleteTask={handleDeleteTask}/></>);}functiontasksReducer(tasks,action){switch(action.type){case'added':{return[...tasks,{id:action.id,text:action.text,done:false}];}case'changed':{returntasks.map(t=>{if(t.id===action.task.id){returnaction.task;}else{returnt;}});}case'deleted':{returntasks.filter(t=>t.id!==action.id);}default:{throwError('Unknown action: '+action.type);}}}letnextId=3;constinitialTasks=[{id:0,text:'Philosopher’s Path',done:true},{id:1,text:'Visit the temple',done:false},{id:2,text:'Drink matcha',done:false}];"
                },
                {
                    "type": "p",
                    "text": "A reducer helps keep the event handlers short and concise. However, as your app grows, you might run into another difficulty.Currently, thetasksstate and thedispatchfunction are only available in the top-levelTaskAppcomponent.To let other components read the list of tasks or change it, you have to explicitlypass downthe current state and the event handlers that change it as props."
                },
                {
                    "type": "p",
                    "text": "For example,TaskApppasses a list of tasks and the event handlers toTaskList:"
                },
                {
                    "type": "code",
                    "code": "<TaskListtasks={tasks}onChangeTask={handleChangeTask}onDeleteTask={handleDeleteTask}/>"
                },
                {
                    "type": "p",
                    "text": "AndTaskListpasses the event handlers toTask:"
                },
                {
                    "type": "code",
                    "code": "<Tasktask={task}onChange={onChangeTask}onDelete={onDeleteTask}/>"
                },
                {
                    "type": "p",
                    "text": "In a small example like this, this works well, but if you have tens or hundreds of components in the middle, passing down all state and functions can be quite frustrating!"
                },
                {
                    "type": "p",
                    "text": "This is why, as an alternative to passing them through props, you might want to put both thetasksstate and thedispatchfunctioninto context.This way, any component belowTaskAppin the tree can read the tasks and dispatch actions without the repetitive “prop drilling”."
                },
                {
                    "type": "p",
                    "text": "Here is how you can combine a reducer with context:"
                },
                {
                    "type": "list",
                    "items": [
                        "Createthe context.",
                        "Putstate and dispatch into context.",
                        "Usecontext anywhere in the tree."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 1: Create the context"
                },
                {
                    "type": "p",
                    "text": "TheuseReducerHook returns the currenttasksand thedispatchfunction that lets you update them:"
                },
                {
                    "type": "code",
                    "code": "const[tasks,dispatch]=useReducer(tasksReducer,initialTasks);"
                },
                {
                    "type": "p",
                    "text": "To pass them down the tree, you willcreatetwo separate contexts:"
                },
                {
                    "type": "list",
                    "items": [
                        "TasksContextprovides the current list of tasks.",
                        "TasksDispatchContextprovides the function that lets components dispatch actions."
                    ]
                },
                {
                    "type": "p",
                    "text": "Export them from a separate file so that you can later import them from other files:"
                },
                {
                    "type": "code",
                    "code": "import{createContext}from'react';exportconstTasksContext=createContext(null);exportconstTasksDispatchContext=createContext(null);"
                },
                {
                    "type": "p",
                    "text": "Here, you’re passingnullas the default value to both contexts. The actual values will be provided by theTaskAppcomponent."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 2: Put state and dispatch into context"
                },
                {
                    "type": "p",
                    "text": "Now you can import both contexts in yourTaskAppcomponent. Take thetasksanddispatchreturned byuseReducer()andprovide themto the entire tree below:"
                },
                {
                    "type": "code",
                    "code": "import{TasksContext,TasksDispatchContext}from'./TasksContext.js';exportdefaultfunctionTaskApp(){const[tasks,dispatch]=useReducer(tasksReducer,initialTasks);// ...return(<TasksContext.Providervalue={tasks}><TasksDispatchContext.Providervalue={dispatch}>...</TasksDispatchContext.Provider></TasksContext.Provider>);}"
                },
                {
                    "type": "p",
                    "text": "For now, you pass the information both via props and in context:"
                },
                {
                    "type": "code",
                    "code": "import{useReducer}from'react';importAddTaskfrom'./AddTask.js';importTaskListfrom'./TaskList.js';import{TasksContext,TasksDispatchContext}from'./TasksContext.js';exportdefaultfunctionTaskApp(){const[tasks,dispatch]=useReducer(tasksReducer,initialTasks);functionhandleAddTask(text){dispatch({type:'added',id:nextId++,text:text,});}functionhandleChangeTask(task){dispatch({type:'changed',task:task});}functionhandleDeleteTask(taskId){dispatch({type:'deleted',id:taskId});}return(<TasksContext.Providervalue={tasks}><TasksDispatchContext.Providervalue={dispatch}><h1>Day off in Kyoto</h1><AddTaskonAddTask={handleAddTask}/><TaskListtasks={tasks}onChangeTask={handleChangeTask}onDeleteTask={handleDeleteTask}/></TasksDispatchContext.Provider></TasksContext.Provider>);}functiontasksReducer(tasks,action){switch(action.type){case'added':{return[...tasks,{id:action.id,text:action.text,done:false}];}case'changed':{returntasks.map(t=>{if(t.id===action.task.id){returnaction.task;}else{returnt;}});}case'deleted':{returntasks.filter(t=>t.id!==action.id);}default:{throwError('Unknown action: '+action.type);}}}letnextId=3;constinitialTasks=[{id:0,text:'Philosopher’s Path',done:true},{id:1,text:'Visit the temple',done:false},{id:2,text:'Drink matcha',done:false}];"
                },
                {
                    "type": "p",
                    "text": "In the next step, you will remove prop passing."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 3: Use context anywhere in the tree"
                },
                {
                    "type": "p",
                    "text": "Now you don’t need to pass the list of tasks or the event handlers down the tree:"
                },
                {
                    "type": "code",
                    "code": "<TasksContext.Providervalue={tasks}><TasksDispatchContext.Providervalue={dispatch}><h1>Day off in Kyoto</h1><AddTask/><TaskList/></TasksDispatchContext.Provider></TasksContext.Provider>"
                },
                {
                    "type": "p",
                    "text": "Instead, any component that needs the task list can read it from theTaskContext:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionTaskList(){consttasks=useContext(TasksContext);// ..."
                },
                {
                    "type": "p",
                    "text": "To update the task list, any component can read thedispatchfunction from context and call it:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionAddTask(){const[text,setText]=useState('');constdispatch=useContext(TasksDispatchContext);// ...return(// ...<buttononClick={()=>{setText('');dispatch({type:'added',id:nextId++,text:text,});}}>Add</button>// ..."
                },
                {
                    "type": "p",
                    "text": "TheTaskAppcomponent does not pass any event handlers down, and theTaskListdoes not pass any event handlers to theTaskcomponent either.Each component reads the context that it needs:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useContext}from'react';import{TasksContext,TasksDispatchContext}from'./TasksContext.js';exportdefaultfunctionTaskList(){consttasks=useContext(TasksContext);return(<ul>{tasks.map(task=>(<likey={task.id}><Tasktask={task}/></li>))}</ul>);}functionTask({task}){const[isEditing,setIsEditing]=useState(false);constdispatch=useContext(TasksDispatchContext);lettaskContent;if(isEditing){taskContent=(<><inputvalue={task.text}onChange={e=>{dispatch({type:'changed',task:{...task,text:e.target.value}});}}/><buttononClick={()=>setIsEditing(false)}>Save</button></>);}else{taskContent=(<>{task.text}<buttononClick={()=>setIsEditing(true)}>Edit</button></>);}return(<label><inputtype=\"checkbox\"checked={task.done}onChange={e=>{dispatch({type:'changed',task:{...task,done:e.target.checked}});}}/>{taskContent}<buttononClick={()=>{dispatch({type:'deleted',id:task.id});}}>Delete</button></label>);}"
                },
                {
                    "type": "p",
                    "text": "The state still “lives” in the top-levelTaskAppcomponent, managed withuseReducer.But itstasksanddispatchare now available to every component below in the tree by importing and using these contexts."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Moving all wiring into a single file"
                },
                {
                    "type": "p",
                    "text": "You don’t have to do this, but you could further declutter the components by moving both reducer and context into a single file. Currently,TasksContext.jscontains only two context declarations:"
                },
                {
                    "type": "code",
                    "code": "import{createContext}from'react';exportconstTasksContext=createContext(null);exportconstTasksDispatchContext=createContext(null);"
                },
                {
                    "type": "p",
                    "text": "This file is about to get crowded! You’ll move the reducer into that same file. Then you’ll declare a newTasksProvidercomponent in the same file. This component will tie all the pieces together:"
                },
                {
                    "type": "list",
                    "items": [
                        "It will manage the state with a reducer.",
                        "It will provide both contexts to components below.",
                        "It willtakechildrenas a propso you can pass JSX to it."
                    ]
                },
                {
                    "type": "code",
                    "code": "exportfunctionTasksProvider({children}){const[tasks,dispatch]=useReducer(tasksReducer,initialTasks);return(<TasksContext.Providervalue={tasks}><TasksDispatchContext.Providervalue={dispatch}>{children}</TasksDispatchContext.Provider></TasksContext.Provider>);}"
                },
                {
                    "type": "p",
                    "text": "This removes all the complexity and wiring from yourTaskAppcomponent:"
                },
                {
                    "type": "code",
                    "code": "importAddTaskfrom'./AddTask.js';importTaskListfrom'./TaskList.js';import{TasksProvider}from'./TasksContext.js';exportdefaultfunctionTaskApp(){return(<TasksProvider><h1>Day off in Kyoto</h1><AddTask/><TaskList/></TasksProvider>);}"
                },
                {
                    "type": "p",
                    "text": "You can also export functions thatusethe context fromTasksContext.js:"
                },
                {
                    "type": "code",
                    "code": "exportfunctionuseTasks(){returnuseContext(TasksContext);}exportfunctionuseTasksDispatch(){returnuseContext(TasksDispatchContext);}"
                },
                {
                    "type": "p",
                    "text": "When a component needs to read context, it can do it through these functions:"
                },
                {
                    "type": "code",
                    "code": "consttasks=useTasks();constdispatch=useTasksDispatch();"
                },
                {
                    "type": "p",
                    "text": "This doesn’t change the behavior in any way, but it lets you later split these contexts further or add some logic to these functions.Now all of the context and reducer wiring is inTasksContext.js. This keeps the components clean and uncluttered, focused on what they display rather than where they get the data:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';import{useTasks,useTasksDispatch}from'./TasksContext.js';exportdefaultfunctionTaskList(){consttasks=useTasks();return(<ul>{tasks.map(task=>(<likey={task.id}><Tasktask={task}/></li>))}</ul>);}functionTask({task}){const[isEditing,setIsEditing]=useState(false);constdispatch=useTasksDispatch();lettaskContent;if(isEditing){taskContent=(<><inputvalue={task.text}onChange={e=>{dispatch({type:'changed',task:{...task,text:e.target.value}});}}/><buttononClick={()=>setIsEditing(false)}>Save</button></>);}else{taskContent=(<>{task.text}<buttononClick={()=>setIsEditing(true)}>Edit</button></>);}return(<label><inputtype=\"checkbox\"checked={task.done}onChange={e=>{dispatch({type:'changed',task:{...task,done:e.target.checked}});}}/>{taskContent}<buttononClick={()=>{dispatch({type:'deleted',id:task.id});}}>Delete</button></label>);}"
                },
                {
                    "type": "p",
                    "text": "You can think ofTasksProvideras a part of the screen that knows how to deal with tasks,useTasksas a way to read them, anduseTasksDispatchas a way to update them from any component below in the tree."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Functions likeuseTasksanduseTasksDispatchare calledCustom Hooks.Your function is considered a custom Hook if its name starts withuse. This lets you use other Hooks, likeuseContext, inside it."
                },
                {
                    "type": "p",
                    "text": "As your app grows, you may have many context-reducer pairs like this. This is a powerful way to scale your app andlift state upwithout too much work whenever you want to access the data deep in the tree."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "You can combine reducer with context to let any component read and update state above it.",
                        "To provide state and the dispatch function to components below:Create two contexts (for state and for dispatch functions).Provide both contexts from the component that uses the reducer.Use either context from components that need to read them.",
                        "Create two contexts (for state and for dispatch functions).",
                        "Provide both contexts from the component that uses the reducer.",
                        "Use either context from components that need to read them.",
                        "You can further declutter the components by moving all wiring into one file.You can export a component likeTasksProviderthat provides context.You can also export custom Hooks likeuseTasksanduseTasksDispatchto read it.",
                        "You can export a component likeTasksProviderthat provides context.",
                        "You can also export custom Hooks likeuseTasksanduseTasksDispatchto read it.",
                        "You can have many context-reducer pairs like this in your app."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Create two contexts (for state and for dispatch functions).",
                        "Provide both contexts from the component that uses the reducer.",
                        "Use either context from components that need to read them."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "You can export a component likeTasksProviderthat provides context.",
                        "You can also export custom Hooks likeuseTasksanduseTasksDispatchto read it."
                    ]
                }
            ]
        },
        {
            "url": "https://react.dev/learn/separating-events-from-effects",
            "title": "Separating Events from Effects – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Separating Events from Effects"
                },
                {
                    "type": "p",
                    "text": "Event handlers only re-run when you perform the same interaction again. Unlike event handlers, Effects re-synchronize if some value they read, like a prop or a state variable, is different from what it was during the last render. Sometimes, you also want a mix of both behaviors: an Effect that re-runs in response to some values but not others. This page will teach you how to do that."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "How to choose between an event handler and an Effect",
                        "Why Effects are reactive, and event handlers are not",
                        "What to do when you want a part of your Effect’s code to not be reactive",
                        "What Effect Events are, and how to extract them from your Effects",
                        "How to read the latest props and state from Effects using Effect Events"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Choosing between event handlers and Effects"
                },
                {
                    "type": "p",
                    "text": "First, let’s recap the difference between event handlers and Effects."
                },
                {
                    "type": "p",
                    "text": "Imagine you’re implementing a chat room component. Your requirements look like this:"
                },
                {
                    "type": "list",
                    "items": [
                        "Your component should automatically connect to the selected chat room.",
                        "When you click the “Send” button, it should send a message to the chat."
                    ]
                },
                {
                    "type": "p",
                    "text": "Let’s say you’ve already implemented the code for them, but you’re not sure where to put it. Should you use event handlers or Effects? Every time you need to answer this question, considerwhythe code needs to run."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Event handlers run in response to specific interactions"
                },
                {
                    "type": "p",
                    "text": "From the user’s perspective, sending a message should happenbecausethe particular “Send” button was clicked. The user will get rather upset if you send their message at any other time or for any other reason. This is why sending a message should be an event handler. Event handlers let you handle specific interactions:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){const[message,setMessage]=useState('');// ...functionhandleSendClick(){sendMessage(message);}// ...return(<><inputvalue={message}onChange={e=>setMessage(e.target.value)}/><buttononClick={handleSendClick}>Send</button></>);}"
                },
                {
                    "type": "p",
                    "text": "With an event handler, you can be sure thatsendMessage(message)willonlyrun if the user presses the button."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Effects run whenever synchronization is needed"
                },
                {
                    "type": "p",
                    "text": "Recall that you also need to keep the component connected to the chat room. Where does that code go?"
                },
                {
                    "type": "p",
                    "text": "Thereasonto run this code is not some particular interaction. It doesn’t matter why or how the user navigated to the chat room screen. Now that they’re looking at it and could interact with it, the component needs to stay connected to the selected chat server. Even if the chat room component was the initial screen of your app, and the user has not performed any interactions at all, you wouldstillneed to connect. This is why it’s an Effect:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){// ...useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{connection.disconnect();};},[roomId]);// ...}"
                },
                {
                    "type": "p",
                    "text": "With this code, you can be sure that there is always an active connection to the currently selected chat server,regardlessof the specific interactions performed by the user. Whether the user has only opened your app, selected a different room, or navigated to another screen and back, your Effect ensures that the component willremain synchronizedwith the currently selected room, and willre-connect whenever it’s necessary."
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection,sendMessage}from'./chat.js';constserverUrl='https://localhost:1234';functionChatRoom({roomId}){const[message,setMessage]=useState('');useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>connection.disconnect();},[roomId]);functionhandleSendClick(){sendMessage(message);}return(<><h1>Welcome to the{roomId}room!</h1><inputvalue={message}onChange={e=>setMessage(e.target.value)}/><buttononClick={handleSendClick}>Send</button></>);}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');const[show,setShow]=useState(false);return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><buttononClick={()=>setShow(!show)}>{show?'Close chat':'Open chat'}</button>{show&&<hr/>}{show&&<ChatRoomroomId={roomId}/>}</>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reactive values and reactive logic"
                },
                {
                    "type": "p",
                    "text": "Intuitively, you could say that event handlers are always triggered “manually”, for example by clicking a button. Effects, on the other hand, are “automatic”: they run and re-run as often as it’s needed to stay synchronized."
                },
                {
                    "type": "p",
                    "text": "There is a more precise way to think about this."
                },
                {
                    "type": "p",
                    "text": "Props, state, and variables declared inside your component’s body are calledreactive values. In this example,serverUrlis not a reactive value, butroomIdandmessageare. They participate in the rendering data flow:"
                },
                {
                    "type": "code",
                    "code": "constserverUrl='https://localhost:1234';functionChatRoom({roomId}){const[message,setMessage]=useState('');// ...}"
                },
                {
                    "type": "p",
                    "text": "Reactive values like these can change due to a re-render. For example, the user may edit themessageor choose a differentroomIdin a dropdown. Event handlers and Effects respond to changes differently:"
                },
                {
                    "type": "list",
                    "items": [
                        "Logic inside event handlers isnot reactive.It will not run again unless the user performs the same interaction (e.g. a click) again. Event handlers can read reactive values without “reacting” to their changes.",
                        "Logic inside Effects isreactive.If your Effect reads a reactive value,you have to specify it as a dependency.Then, if a re-render causes that value to change, React will re-run your Effect’s logic with the new value."
                    ]
                },
                {
                    "type": "p",
                    "text": "Let’s revisit the previous example to illustrate this difference."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Logic inside event handlers is not reactive"
                },
                {
                    "type": "p",
                    "text": "Take a look at this line of code. Should this logic be reactive or not?"
                },
                {
                    "type": "code",
                    "code": "// ...sendMessage(message);// ..."
                },
                {
                    "type": "p",
                    "text": "From the user’s perspective,a change to themessagedoesnotmean that they want to send a message.It only means that the user is typing. In other words, the logic that sends a message should not be reactive. It should not run again only because thereactive valuehas changed. That’s why it belongs in the event handler:"
                },
                {
                    "type": "code",
                    "code": "functionhandleSendClick(){sendMessage(message);}"
                },
                {
                    "type": "p",
                    "text": "Event handlers aren’t reactive, sosendMessage(message)will only run when the user clicks the Send button."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Logic inside Effects is reactive"
                },
                {
                    "type": "p",
                    "text": "Now let’s return to these lines:"
                },
                {
                    "type": "code",
                    "code": "// ...constconnection=createConnection(serverUrl,roomId);connection.connect();// ..."
                },
                {
                    "type": "p",
                    "text": "From the user’s perspective,a change to theroomIddoesmean that they want to connect to a different room.In other words, the logic for connecting to the room should be reactive. Youwantthese lines of code to “keep up” with thereactive value, and to run again if that value is different. That’s why it belongs in an Effect:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{connection.disconnect()};},[roomId]);"
                },
                {
                    "type": "p",
                    "text": "Effects are reactive, socreateConnection(serverUrl, roomId)andconnection.connect()will run for every distinct value ofroomId. Your Effect keeps the chat connection synchronized to the currently selected room."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Extracting non-reactive logic out of Effects"
                },
                {
                    "type": "p",
                    "text": "Things get more tricky when you want to mix reactive logic with non-reactive logic."
                },
                {
                    "type": "p",
                    "text": "For example, imagine that you want to show a notification when the user connects to the chat. You read the current theme (dark or light) from the props so that you can show the notification in the correct color:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId,theme}){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.on('connected',()=>{showNotification('Connected!',theme);});connection.connect();// ..."
                },
                {
                    "type": "p",
                    "text": "However,themeis a reactive value (it can change as a result of re-rendering), andevery reactive value read by an Effect must be declared as its dependency.Now you have to specifythemeas a dependency of your Effect:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId,theme}){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.on('connected',()=>{showNotification('Connected!',theme);});connection.connect();return()=>{connection.disconnect()};},[roomId,theme]);// ✅ All dependencies declared// ..."
                },
                {
                    "type": "p",
                    "text": "Play with this example and see if you can spot the problem with this user experience:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection,sendMessage}from'./chat.js';import{showNotification}from'./notifications.js';constserverUrl='https://localhost:1234';functionChatRoom({roomId,theme}){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.on('connected',()=>{showNotification('Connected!',theme);});connection.connect();return()=>connection.disconnect();},[roomId,theme]);return<h1>Welcome to the{roomId}room!</h1>}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');const[isDark,setIsDark]=useState(false);return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><label><inputtype=\"checkbox\"checked={isDark}onChange={e=>setIsDark(e.target.checked)}/>Use dark theme</label><hr/><ChatRoomroomId={roomId}theme={isDark?'dark':'light'}/></>);}"
                },
                {
                    "type": "p",
                    "text": "When theroomIdchanges, the chat re-connects as you would expect. But sincethemeis also a dependency, the chatalsore-connects every time you switch between the dark and the light theme. That’s not great!"
                },
                {
                    "type": "p",
                    "text": "In other words, youdon’twant this line to be reactive, even though it is inside an Effect (which is reactive):"
                },
                {
                    "type": "code",
                    "code": "// ...showNotification('Connected!',theme);// ..."
                },
                {
                    "type": "p",
                    "text": "You need a way to separate this non-reactive logic from the reactive Effect around it."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Declaring an Effect Event"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Under Construction"
                },
                {
                    "type": "p",
                    "text": "This section describes anexperimental API that has not yet been releasedin a stable version of React."
                },
                {
                    "type": "p",
                    "text": "Use a special Hook calleduseEffectEventto extract this non-reactive logic out of your Effect:"
                },
                {
                    "type": "code",
                    "code": "import{useEffect,useEffectEvent}from'react';functionChatRoom({roomId,theme}){constonConnected=useEffectEvent(()=>{showNotification('Connected!',theme);});// ..."
                },
                {
                    "type": "p",
                    "text": "Here,onConnectedis called anEffect Event.It’s a part of your Effect logic, but it behaves a lot more like an event handler. The logic inside it is not reactive, and it always “sees” the latest values of your props and state."
                },
                {
                    "type": "p",
                    "text": "Now you can call theonConnectedEffect Event from inside your Effect:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId,theme}){constonConnected=useEffectEvent(()=>{showNotification('Connected!',theme);});useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.on('connected',()=>{onConnected();});connection.connect();return()=>connection.disconnect();},[roomId]);// ✅ All dependencies declared// ..."
                },
                {
                    "type": "p",
                    "text": "This solves the problem. Note that you had toremoveonConnectedfrom the list of your Effect’s dependencies.Effect Events are not reactive and must be omitted from dependencies."
                },
                {
                    "type": "p",
                    "text": "Verify that the new behavior works as you would expect:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{experimental_useEffectEventasuseEffectEvent}from'react';import{createConnection,sendMessage}from'./chat.js';import{showNotification}from'./notifications.js';constserverUrl='https://localhost:1234';functionChatRoom({roomId,theme}){constonConnected=useEffectEvent(()=>{showNotification('Connected!',theme);});useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.on('connected',()=>{onConnected();});connection.connect();return()=>connection.disconnect();},[roomId]);return<h1>Welcome to the{roomId}room!</h1>}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');const[isDark,setIsDark]=useState(false);return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><label><inputtype=\"checkbox\"checked={isDark}onChange={e=>setIsDark(e.target.checked)}/>Use dark theme</label><hr/><ChatRoomroomId={roomId}theme={isDark?'dark':'light'}/></>);}"
                },
                {
                    "type": "p",
                    "text": "You can think of Effect Events as being very similar to event handlers. The main difference is that event handlers run in response to a user interactions, whereas Effect Events are triggered by you from Effects. Effect Events let you “break the chain” between the reactivity of Effects and code that should not be reactive."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Reading latest props and state with Effect Events"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Under Construction"
                },
                {
                    "type": "p",
                    "text": "This section describes anexperimental API that has not yet been releasedin a stable version of React."
                },
                {
                    "type": "p",
                    "text": "Effect Events let you fix many patterns where you might be tempted to suppress the dependency linter."
                },
                {
                    "type": "p",
                    "text": "For example, say you have an Effect to log the page visits:"
                },
                {
                    "type": "code",
                    "code": "functionPage(){useEffect(()=>{logVisit();},[]);// ...}"
                },
                {
                    "type": "p",
                    "text": "Later, you add multiple routes to your site. Now yourPagecomponent receives aurlprop with the current path. You want to pass theurlas a part of yourlogVisitcall, but the dependency linter complains:"
                },
                {
                    "type": "code",
                    "code": "functionPage({url}){useEffect(()=>{logVisit(url);},[]);// 🔴 React Hook useEffect has a missing dependency: 'url'// ...}"
                },
                {
                    "type": "p",
                    "text": "Think about what you want the code to do. Youwantto log a separate visit for different URLs since each URL represents a different page. In other words, thislogVisitcallshouldbe reactive with respect to theurl. This is why, in this case, it makes sense to follow the dependency linter, and addurlas a dependency:"
                },
                {
                    "type": "code",
                    "code": "functionPage({url}){useEffect(()=>{logVisit(url);},[url]);// ✅ All dependencies declared// ...}"
                },
                {
                    "type": "p",
                    "text": "Now let’s say you want to include the number of items in the shopping cart together with every page visit:"
                },
                {
                    "type": "code",
                    "code": "functionPage({url}){const{items}=useContext(ShoppingCartContext);constnumberOfItems=items.length;useEffect(()=>{logVisit(url,numberOfItems);},[url]);// 🔴 React Hook useEffect has a missing dependency: 'numberOfItems'// ...}"
                },
                {
                    "type": "p",
                    "text": "You usednumberOfItemsinside the Effect, so the linter asks you to add it as a dependency. However, youdon’twant thelogVisitcall to be reactive with respect tonumberOfItems. If the user puts something into the shopping cart, and thenumberOfItemschanges, thisdoes not meanthat the user visited the page again. In other words,visiting the pageis, in some sense, an “event”. It happens at a precise moment in time."
                },
                {
                    "type": "p",
                    "text": "Split the code in two parts:"
                },
                {
                    "type": "code",
                    "code": "functionPage({url}){const{items}=useContext(ShoppingCartContext);constnumberOfItems=items.length;constonVisit=useEffectEvent(visitedUrl=>{logVisit(visitedUrl,numberOfItems);});useEffect(()=>{onVisit(url);},[url]);// ✅ All dependencies declared// ...}"
                },
                {
                    "type": "p",
                    "text": "Here,onVisitis an Effect Event. The code inside it isn’t reactive. This is why you can usenumberOfItems(or any other reactive value!) without worrying that it will cause the surrounding code to re-execute on changes."
                },
                {
                    "type": "p",
                    "text": "On the other hand, the Effect itself remains reactive. Code inside the Effect uses theurlprop, so the Effect will re-run after every re-render with a differenturl. This, in turn, will call theonVisitEffect Event."
                },
                {
                    "type": "p",
                    "text": "As a result, you will calllogVisitfor every change to theurl, and always read the latestnumberOfItems. However, ifnumberOfItemschanges on its own, this will not cause any of the code to re-run."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "You might be wondering if you could callonVisit()with no arguments, and read theurlinside it:"
                },
                {
                    "type": "code",
                    "code": "constonVisit=useEffectEvent(()=>{logVisit(url,numberOfItems);});useEffect(()=>{onVisit();},[url]);"
                },
                {
                    "type": "p",
                    "text": "This would work, but it’s better to pass thisurlto the Effect Event explicitly.By passingurlas an argument to your Effect Event, you are saying that visiting a page with a differenturlconstitutes a separate “event” from the user’s perspective.ThevisitedUrlis apartof the “event” that happened:"
                },
                {
                    "type": "code",
                    "code": "constonVisit=useEffectEvent(visitedUrl=>{logVisit(visitedUrl,numberOfItems);});useEffect(()=>{onVisit(url);},[url]);"
                },
                {
                    "type": "p",
                    "text": "Since your Effect Event explicitly “asks” for thevisitedUrl, now you can’t accidentally removeurlfrom the Effect’s dependencies. If you remove theurldependency (causing distinct page visits to be counted as one), the linter will warn you about it. You wantonVisitto be reactive with regards to theurl, so instead of reading theurlinside (where it wouldn’t be reactive), you pass itfromyour Effect."
                },
                {
                    "type": "p",
                    "text": "This becomes especially important if there is some asynchronous logic inside the Effect:"
                },
                {
                    "type": "code",
                    "code": "constonVisit=useEffectEvent(visitedUrl=>{logVisit(visitedUrl,numberOfItems);});useEffect(()=>{setTimeout(()=>{onVisit(url);},5000);// Delay logging visits},[url]);"
                },
                {
                    "type": "p",
                    "text": "Here,urlinsideonVisitcorresponds to thelatesturl(which could have already changed), butvisitedUrlcorresponds to theurlthat originally caused this Effect (and thisonVisitcall) to run."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Is it okay to suppress the dependency linter instead?"
                },
                {
                    "type": "p",
                    "text": "In the existing codebases, you may sometimes see the lint rule suppressed like this:"
                },
                {
                    "type": "code",
                    "code": "functionPage({url}){const{items}=useContext(ShoppingCartContext);constnumberOfItems=items.length;useEffect(()=>{logVisit(url,numberOfItems);// 🔴 Avoid suppressing the linter like this:// eslint-disable-next-line react-hooks/exhaustive-deps},[url]);// ...}"
                },
                {
                    "type": "p",
                    "text": "AfteruseEffectEventbecomes a stable part of React, we recommendnever suppressing the linter."
                },
                {
                    "type": "p",
                    "text": "The first downside of suppressing the rule is that React will no longer warn you when your Effect needs to “react” to a new reactive dependency you’ve introduced to your code. In the earlier example, you addedurlto the dependenciesbecauseReact reminded you to do it. You will no longer get such reminders for any future edits to that Effect if you disable the linter. This leads to bugs."
                },
                {
                    "type": "p",
                    "text": "Here is an example of a confusing bug caused by suppressing the linter. In this example, thehandleMovefunction is supposed to read the currentcanMovestate variable value in order to decide whether the dot should follow the cursor. However,canMoveis alwaystrueinsidehandleMove."
                },
                {
                    "type": "p",
                    "text": "Can you see why?"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';exportdefaultfunctionApp(){const[position,setPosition]=useState({x:0,y:0});const[canMove,setCanMove]=useState(true);functionhandleMove(e){if(canMove){setPosition({x:e.clientX,y:e.clientY});}}useEffect(()=>{window.addEventListener('pointermove',handleMove);return()=>window.removeEventListener('pointermove',handleMove);// eslint-disable-next-line react-hooks/exhaustive-deps},[]);return(<><label><inputtype=\"checkbox\"checked={canMove}onChange={e=>setCanMove(e.target.checked)}/>The dot is allowed to move</label><hr/><divstyle={{position:'absolute',backgroundColor:'pink',borderRadius:'50%',opacity:0.6,transform:`translate(${position.x}px,${position.y}px)`,pointerEvents:'none',left:-20,top:-20,width:40,height:40,}}/></>);}"
                },
                {
                    "type": "p",
                    "text": "The problem with this code is in suppressing the dependency linter. If you remove the suppression, you’ll see that this Effect should depend on thehandleMovefunction. This makes sense:handleMoveis declared inside the component body, which makes it a reactive value. Every reactive value must be specified as a dependency, or it can potentially get stale over time!"
                },
                {
                    "type": "p",
                    "text": "The author of the original code has “lied” to React by saying that the Effect does not depend ([]) on any reactive values. This is why React did not re-synchronize the Effect aftercanMovehas changed (andhandleMovewith it). Because React did not re-synchronize the Effect, thehandleMoveattached as a listener is thehandleMovefunction created during the initial render. During the initial render,canMovewastrue, which is whyhandleMovefrom the initial render will forever see that value."
                },
                {
                    "type": "p",
                    "text": "If you never suppress the linter, you will never see problems with stale values."
                },
                {
                    "type": "p",
                    "text": "WithuseEffectEvent, there is no need to “lie” to the linter, and the code works as you would expect:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{experimental_useEffectEventasuseEffectEvent}from'react';exportdefaultfunctionApp(){const[position,setPosition]=useState({x:0,y:0});const[canMove,setCanMove]=useState(true);constonMove=useEffectEvent(e=>{if(canMove){setPosition({x:e.clientX,y:e.clientY});}});useEffect(()=>{window.addEventListener('pointermove',onMove);return()=>window.removeEventListener('pointermove',onMove);},[]);return(<><label><inputtype=\"checkbox\"checked={canMove}onChange={e=>setCanMove(e.target.checked)}/>The dot is allowed to move</label><hr/><divstyle={{position:'absolute',backgroundColor:'pink',borderRadius:'50%',opacity:0.6,transform:`translate(${position.x}px,${position.y}px)`,pointerEvents:'none',left:-20,top:-20,width:40,height:40,}}/></>);}"
                },
                {
                    "type": "p",
                    "text": "This doesn’t mean thatuseEffectEventisalwaysthe correct solution. You should only apply it to the lines of code that you don’t want to be reactive. In the above sandbox, you didn’t want the Effect’s code to be reactive with regards tocanMove. That’s why it made sense to extract an Effect Event."
                },
                {
                    "type": "p",
                    "text": "ReadRemoving Effect Dependenciesfor other correct alternatives to suppressing the linter."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Limitations of Effect Events"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Under Construction"
                },
                {
                    "type": "p",
                    "text": "This section describes anexperimental API that has not yet been releasedin a stable version of React."
                },
                {
                    "type": "p",
                    "text": "Effect Events are very limited in how you can use them:"
                },
                {
                    "type": "list",
                    "items": [
                        "Only call them from inside Effects.",
                        "Never pass them to other components or Hooks."
                    ]
                },
                {
                    "type": "p",
                    "text": "For example, don’t declare and pass an Effect Event like this:"
                },
                {
                    "type": "code",
                    "code": "functionTimer(){const[count,setCount]=useState(0);constonTick=useEffectEvent(()=>{setCount(count+1);});useTimer(onTick,1000);// 🔴 Avoid: Passing Effect Eventsreturn<h1>{count}</h1>}functionuseTimer(callback,delay){useEffect(()=>{constid=setInterval(()=>{callback();},delay);return()=>{clearInterval(id);};},[delay,callback]);// Need to specify \"callback\" in dependencies}"
                },
                {
                    "type": "p",
                    "text": "Instead, always declare Effect Events directly next to the Effects that use them:"
                },
                {
                    "type": "code",
                    "code": "functionTimer(){const[count,setCount]=useState(0);useTimer(()=>{setCount(count+1);},1000);return<h1>{count}</h1>}functionuseTimer(callback,delay){constonTick=useEffectEvent(()=>{callback();});useEffect(()=>{constid=setInterval(()=>{onTick();// ✅ Good: Only called locally inside an Effect},delay);return()=>{clearInterval(id);};},[delay]);// No need to specify \"onTick\" (an Effect Event) as a dependency}"
                },
                {
                    "type": "p",
                    "text": "Effect Events are non-reactive “pieces” of your Effect code. They should be next to the Effect using them."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "Event handlers run in response to specific interactions.",
                        "Effects run whenever synchronization is needed.",
                        "Logic inside event handlers is not reactive.",
                        "Logic inside Effects is reactive.",
                        "You can move non-reactive logic from Effects into Effect Events.",
                        "Only call Effect Events from inside Effects.",
                        "Don’t pass Effect Events to other components or Hooks."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of4:Fix a variable that doesn’t update"
                },
                {
                    "type": "p",
                    "text": "ThisTimercomponent keeps acountstate variable which increases every second. The value by which it’s increasing is stored in theincrementstate variable. You can control theincrementvariable with the plus and minus buttons."
                },
                {
                    "type": "p",
                    "text": "However, no matter how many times you click the plus button, the counter is still incremented by one every second. What’s wrong with this code? Why isincrementalways equal to1inside the Effect’s code? Find the mistake and fix it."
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';exportdefaultfunctionTimer(){const[count,setCount]=useState(0);const[increment,setIncrement]=useState(1);useEffect(()=>{constid=setInterval(()=>{setCount(c=>c+increment);},1000);return()=>{clearInterval(id);};// eslint-disable-next-line react-hooks/exhaustive-deps},[]);return(<><h1>Counter:{count}<buttononClick={()=>setCount(0)}>Reset</button></h1><hr/><p>Every second, increment by:<buttondisabled={increment===0}onClick={()=>{setIncrement(i=>i-1);}}>–</button><b>{increment}</b><buttononClick={()=>{setIncrement(i=>i+1);}}>+</button></p></>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/sharing-state-between-components",
            "title": "Sharing State Between Components – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Sharing State Between Components"
                },
                {
                    "type": "p",
                    "text": "Sometimes, you want the state of two components to always change together. To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. This is known aslifting state up,and it’s one of the most common things you will do writing React code."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "How to share state between components by lifting it up",
                        "What are controlled and uncontrolled components"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Lifting state up by example"
                },
                {
                    "type": "p",
                    "text": "In this example, a parentAccordioncomponent renders two separatePanels:"
                },
                {
                    "type": "list",
                    "items": [
                        "AccordionPanelPanel",
                        "Panel",
                        "Panel"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Panel",
                        "Panel"
                    ]
                },
                {
                    "type": "p",
                    "text": "EachPanelcomponent has a booleanisActivestate that determines whether its content is visible."
                },
                {
                    "type": "p",
                    "text": "Press the Show button for both panels:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';functionPanel({title,children}){const[isActive,setIsActive]=useState(false);return(<sectionclassName=\"panel\"><h3>{title}</h3>{isActive?(<p>{children}</p>):(<buttononClick={()=>setIsActive(true)}>Show</button>)}</section>);}exportdefaultfunctionAccordion(){return(<><h2>Almaty, Kazakhstan</h2><Paneltitle=\"About\">With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city.</Panel><Paneltitle=\"Etymology\">The name comes from<spanlang=\"kk-KZ\">алма</span>, the Kazakh word for \"apple\" and is often translated as \"full of apples\". In fact, the region surrounding Almaty is thought to be the ancestral home of the apple, and the wild<ilang=\"la\">Malus sieversii</i>is considered a likely candidate for the ancestor of the modern domestic apple.</Panel></>);}"
                },
                {
                    "type": "p",
                    "text": "Notice how pressing one panel’s button does not affect the other panel—they are independent."
                },
                {
                    "type": "p",
                    "text": "Initially, eachPanel’sisActivestate isfalse, so they both appear collapsed"
                },
                {
                    "type": "p",
                    "text": "Clicking eitherPanel’s button will only update thatPanel’sisActivestate alone"
                },
                {
                    "type": "p",
                    "text": "But now let’s say you want to change it so that only one panel is expanded at any given time.With that design, expanding the second panel should collapse the first one. How would you do that?"
                },
                {
                    "type": "p",
                    "text": "To coordinate these two panels, you need to “lift their state up” to a parent component in three steps:"
                },
                {
                    "type": "list",
                    "items": [
                        "Removestate from the child components.",
                        "Passhardcoded data from the common parent.",
                        "Addstate to the common parent and pass it down together with the event handlers."
                    ]
                },
                {
                    "type": "p",
                    "text": "This will allow theAccordioncomponent to coordinate bothPanels and only expand one at a time."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 1: Remove state from the child components"
                },
                {
                    "type": "p",
                    "text": "You will give control of thePanel’sisActiveto its parent component. This means that the parent component will passisActivetoPanelas a prop instead. Start byremoving this linefrom thePanelcomponent:"
                },
                {
                    "type": "code",
                    "code": "const[isActive,setIsActive]=useState(false);"
                },
                {
                    "type": "p",
                    "text": "And instead, addisActiveto thePanel’s list of props:"
                },
                {
                    "type": "code",
                    "code": "functionPanel({title,children,isActive}){"
                },
                {
                    "type": "p",
                    "text": "Now thePanel’s parent component cancontrolisActivebypassing it down as a prop.Conversely, thePanelcomponent now hasno controlover the value ofisActive—it’s now up to the parent component!"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 2: Pass hardcoded data from the common parent"
                },
                {
                    "type": "p",
                    "text": "To lift state up, you must locate the closest common parent component ofbothof the child components that you want to coordinate:"
                },
                {
                    "type": "list",
                    "items": [
                        "Accordion(closest common parent)PanelPanel",
                        "Panel",
                        "Panel"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Panel",
                        "Panel"
                    ]
                },
                {
                    "type": "p",
                    "text": "In this example, it’s theAccordioncomponent. Since it’s above both panels and can control their props, it will become the “source of truth” for which panel is currently active. Make theAccordioncomponent pass a hardcoded value ofisActive(for example,true) to both panels:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionAccordion(){return(<><h2>Almaty, Kazakhstan</h2><Paneltitle=\"About\"isActive={true}>With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city.</Panel><Paneltitle=\"Etymology\"isActive={true}>The name comes from<spanlang=\"kk-KZ\">алма</span>, the Kazakh word for \"apple\" and is often translated as \"full of apples\". In fact, the region surrounding Almaty is thought to be the ancestral home of the apple, and the wild<ilang=\"la\">Malus sieversii</i>is considered a likely candidate for the ancestor of the modern domestic apple.</Panel></>);}functionPanel({title,children,isActive}){return(<sectionclassName=\"panel\"><h3>{title}</h3>{isActive?(<p>{children}</p>):(<buttononClick={()=>setIsActive(true)}>Show</button>)}</section>);}"
                },
                {
                    "type": "p",
                    "text": "Try editing the hardcodedisActivevalues in theAccordioncomponent and see the result on the screen."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 3: Add state to the common parent"
                },
                {
                    "type": "p",
                    "text": "Lifting state up often changes the nature of what you’re storing as state."
                },
                {
                    "type": "p",
                    "text": "In this case, only one panel should be active at a time. This means that theAccordioncommon parent component needs to keep track ofwhichpanel is the active one. Instead of abooleanvalue, it could use a number as the index of the activePanelfor the state variable:"
                },
                {
                    "type": "code",
                    "code": "const[activeIndex,setActiveIndex]=useState(0);"
                },
                {
                    "type": "p",
                    "text": "When theactiveIndexis0, the first panel is active, and when it’s1, it’s the second one."
                },
                {
                    "type": "p",
                    "text": "Clicking the “Show” button in eitherPanelneeds to change the active index inAccordion. APanelcan’t set theactiveIndexstate directly because it’s defined inside theAccordion. TheAccordioncomponent needs toexplicitly allowthePanelcomponent to change its state bypassing an event handler down as a prop:"
                },
                {
                    "type": "code",
                    "code": "<><PanelisActive={activeIndex===0}onShow={()=>setActiveIndex(0)}>...</Panel><PanelisActive={activeIndex===1}onShow={()=>setActiveIndex(1)}>...</Panel></>"
                },
                {
                    "type": "p",
                    "text": "The<button>inside thePanelwill now use theonShowprop as its click event handler:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionAccordion(){const[activeIndex,setActiveIndex]=useState(0);return(<><h2>Almaty, Kazakhstan</h2><Paneltitle=\"About\"isActive={activeIndex===0}onShow={()=>setActiveIndex(0)}>With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city.</Panel><Paneltitle=\"Etymology\"isActive={activeIndex===1}onShow={()=>setActiveIndex(1)}>The name comes from<spanlang=\"kk-KZ\">алма</span>, the Kazakh word for \"apple\" and is often translated as \"full of apples\". In fact, the region surrounding Almaty is thought to be the ancestral home of the apple, and the wild<ilang=\"la\">Malus sieversii</i>is considered a likely candidate for the ancestor of the modern domestic apple.</Panel></>);}functionPanel({title,children,isActive,onShow}){return(<sectionclassName=\"panel\"><h3>{title}</h3>{isActive?(<p>{children}</p>):(<buttononClick={onShow}>Show</button>)}</section>);}"
                },
                {
                    "type": "p",
                    "text": "This completes lifting state up! Moving state into the common parent component allowed you to coordinate the two panels. Using the active index instead of two “is shown” flags ensured that only one panel is active at a given time. And passing down the event handler to the child allowed the child to change the parent’s state."
                },
                {
                    "type": "p",
                    "text": "Initially,Accordion’sactiveIndexis0, so the firstPanelreceivesisActive = true"
                },
                {
                    "type": "p",
                    "text": "WhenAccordion’sactiveIndexstate changes to1, the secondPanelreceivesisActive = trueinstead"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Controlled and uncontrolled components"
                },
                {
                    "type": "p",
                    "text": "It is common to call a component with some local state “uncontrolled”. For example, the originalPanelcomponent with anisActivestate variable is uncontrolled because its parent cannot influence whether the panel is active or not."
                },
                {
                    "type": "p",
                    "text": "In contrast, you might say a component is “controlled” when the important information in it is driven by props rather than its own local state. This lets the parent component fully specify its behavior. The finalPanelcomponent with theisActiveprop is controlled by theAccordioncomponent."
                },
                {
                    "type": "p",
                    "text": "Uncontrolled components are easier to use within their parents because they require less configuration. But they’re less flexible when you want to coordinate them together. Controlled components are maximally flexible, but they require the parent components to fully configure them with props."
                },
                {
                    "type": "p",
                    "text": "In practice, “controlled” and “uncontrolled” aren’t strict technical terms—each component usually has some mix of both local state and props. However, this is a useful way to talk about how components are designed and what capabilities they offer."
                },
                {
                    "type": "p",
                    "text": "When writing a component, consider which information in it should be controlled (via props), and which information should be uncontrolled (via state). But you can always change your mind and refactor later."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "A single source of truth for each state"
                },
                {
                    "type": "p",
                    "text": "In a React application, many components will have their own state. Some state may “live” close to the leaf components (components at the bottom of the tree) like inputs. Other state may “live” closer to the top of the app. For example, even client-side routing libraries are usually implemented by storing the current route in the React state, and passing it down by props!"
                },
                {
                    "type": "p",
                    "text": "For each unique piece of state, you will choose the component that “owns” it.This principle is also known as having a“single source of truth”.It doesn’t mean that all state lives in one place—but that foreachpiece of state, there is aspecificcomponent that holds that piece of information. Instead of duplicating shared state between components,lift it upto their common shared parent, andpass it downto the children that need it."
                },
                {
                    "type": "p",
                    "text": "Your app will change as you work on it. It is common that you will move state down or back up while you’re still figuring out where each piece of the state “lives”. This is all part of the process!"
                },
                {
                    "type": "p",
                    "text": "To see what this feels like in practice with a few more components, readThinking in React."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "When you want to coordinate two components, move their state to their common parent.",
                        "Then pass the information down through props from their common parent.",
                        "Finally, pass the event handlers down so that the children can change the parent’s state.",
                        "It’s useful to consider components as “controlled” (driven by props) or “uncontrolled” (driven by state)."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of2:Synced inputs"
                },
                {
                    "type": "p",
                    "text": "These two inputs are independent. Make them stay in sync: editing one input should update the other input with the same text, and vice versa."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionSyncedInputs(){return(<><Inputlabel=\"First input\"/><Inputlabel=\"Second input\"/></>);}functionInput({label}){const[text,setText]=useState('');functionhandleChange(e){setText(e.target.value);}return(<label>{label}{' '}<inputvalue={text}onChange={handleChange}/></label>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/start-a-new-react-project",
            "title": "Start a New React Project – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Start a New React Project"
                },
                {
                    "type": "p",
                    "text": "If you want to build a new app or a new website fully with React, we recommend picking one of the React-powered frameworks popular in the community."
                },
                {
                    "type": "p",
                    "text": "You can use React without a framework, however we’ve found that most apps and sites eventually build solutions to common problems such as code-splitting, routing, data fetching, and generating HTML. These problems are common to all UI libraries, not just React."
                },
                {
                    "type": "p",
                    "text": "By starting with a framework, you can get started with React quickly, and avoid essentially building your own framework later."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Can I use React without a framework?"
                },
                {
                    "type": "p",
                    "text": "You can definitely use React without a framework—that’s how you’duse React for a part of your page.However, if you’re building a new app or a site fully with React, we recommend using a framework."
                },
                {
                    "type": "p",
                    "text": "Here’s why."
                },
                {
                    "type": "p",
                    "text": "Even if you don’t need routing or data fetching at first, you’ll likely want to add some libraries for them. As your JavaScript bundle grows with every new feature, you might have to figure out how to split code for every route individually. As your data fetching needs get more complex, you are likely to encounter server-client network waterfalls that make your app feel very slow. As your audience includes more users with poor network conditions and low-end devices, you might need to generate HTML from your components to display content early—either on the server, or during the build time. Changing your setup to run some of your code on the server or during the build can be very tricky."
                },
                {
                    "type": "p",
                    "text": "These problems are not React-specific. This is why Svelte has SvelteKit, Vue has Nuxt, and so on.To solve these problems on your own, you’ll need to integrate your bundler with your router and with your data fetching library. It’s not hard to get an initial setup working, but there are a lot of subtleties involved in making an app that loads quickly even as it grows over time. You’ll want to send down the minimal amount of app code but do so in a single client–server roundtrip, in parallel with any data required for the page. You’ll likely want the page to be interactive before your JavaScript code even runs, to support progressive enhancement. You may want to generate a folder of fully static HTML files for your marketing pages that can be hosted anywhere and still work with JavaScript disabled. Building these capabilities yourself takes real work."
                },
                {
                    "type": "p",
                    "text": "React frameworks on this page solve problems like these by default, with no extra work from your side.They let you start very lean and then scale your app with your needs. Each React framework has a community, so finding answers to questions and upgrading tooling is easier. Frameworks also give structure to your code, helping you and others retain context and skills between different projects. Conversely, with a custom setup it’s easier to get stuck on unsupported dependency versions, and you’ll essentially end up creating your own framework—albeit one with no community or upgrade path (and if it’s anything like the ones we’ve made in the past, more haphazardly designed)."
                },
                {
                    "type": "p",
                    "text": "If your app has unusual constraints not served well by these frameworks, or you prefer to solve these problems yourself, you can roll your own custom setup with React. Grabreactandreact-domfrom npm, set up your custom build process with a bundler likeViteorParcel, and add other tools as you need them for routing, static generation or server-side rendering, and more."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Production-grade React frameworks"
                },
                {
                    "type": "p",
                    "text": "These frameworks support all the features you need to deploy and scale your app in production and are working towards supporting ourfull-stack architecture vision. All of the frameworks we recommend are open source with active communities for support, and can be deployed to your own server or a hosting provider. If you’re a framework author interested in being included on this list,please let us know."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Next.js"
                },
                {
                    "type": "p",
                    "text": "Next.js’ Pages Routeris a full-stack React framework.It’s versatile and lets you create React apps of any size—from a mostly static blog to a complex dynamic application. To create a new Next.js project, run in your terminal:"
                },
                {
                    "type": "p",
                    "text": "If you’re new to Next.js, check out thelearn Next.js course."
                },
                {
                    "type": "p",
                    "text": "Next.js is maintained byVercel. You candeploy a Next.js appto any Node.js or serverless hosting, or to your own server. Next.js also supports astatic exportwhich doesn’t require a server."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Remix"
                },
                {
                    "type": "p",
                    "text": "Remixis a full-stack React framework with nested routing.It lets you break your app into nested parts that can load data in parallel and refresh in response to the user actions. To create a new Remix project, run:"
                },
                {
                    "type": "p",
                    "text": "If you’re new to Remix, check out the Remixblog tutorial(short) andapp tutorial(long)."
                },
                {
                    "type": "p",
                    "text": "Remix is maintained byShopify. When you create a Remix project, you need topick your deployment target. You can deploy a Remix app to any Node.js or serverless hosting by using or writing anadapter."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Gatsby"
                },
                {
                    "type": "p",
                    "text": "Gatsbyis a React framework for fast CMS-backed websites.Its rich plugin ecosystem and its GraphQL data layer simplify integrating content, APIs, and services into one website. To create a new Gatsby project, run:"
                },
                {
                    "type": "p",
                    "text": "If you’re new to Gatsby, check out theGatsby tutorial."
                },
                {
                    "type": "p",
                    "text": "Gatsby is maintained byNetlify. You candeploy a fully static Gatsby siteto any static hosting. If you opt into using server-only features, make sure your hosting provider supports them for Gatsby."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Expo (for native apps)"
                },
                {
                    "type": "p",
                    "text": "Expois a React framework that lets you create universal Android, iOS, and web apps with truly native UIs.It provides an SDK forReact Nativethat makes the native parts easier to use. To create a new Expo project, run:"
                },
                {
                    "type": "p",
                    "text": "If you’re new to Expo, check out theExpo tutorial."
                },
                {
                    "type": "p",
                    "text": "Expo is maintained byExpo (the company). Building apps with Expo is free, and you can submit them to the Google and Apple app stores without restrictions. Expo additionally provides opt-in paid cloud services."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Bleeding-edge React frameworks"
                },
                {
                    "type": "p",
                    "text": "As we’ve explored how to continue improving React, we realized that integrating React more closely with frameworks (specifically, with routing, bundling, and server technologies) is our biggest opportunity to help React users build better apps. The Next.js team has agreed to collaborate with us in researching, developing, integrating, and testing framework-agnostic bleeding-edge React features likeReact Server Components."
                },
                {
                    "type": "p",
                    "text": "These features are getting closer to being production-ready every day, and we’ve been in talks with other bundler and framework developers about integrating them. Our hope is that in a year or two, all frameworks listed on this page will have full support for these features. (If you’re a framework author interested in partnering with us to experiment with these features, please let us know!)"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Next.js (App Router)"
                },
                {
                    "type": "p",
                    "text": "Next.js’s App Routeris a redesign of the Next.js APIs aiming to fulfill the React team’s full-stack architecture vision.It lets you fetch data in asynchronous components that run on the server or even during the build."
                },
                {
                    "type": "p",
                    "text": "Next.js is maintained byVercel. You candeploy a Next.js appto any Node.js or serverless hosting, or to your own server. Next.js also supportsstatic exportwhich doesn’t require a server."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Which features make up the React team’s full-stack architecture vision?"
                },
                {
                    "type": "p",
                    "text": "Next.js’s App Router bundler fully implements the officialReact Server Components specification. This lets you mix build-time, server-only, and interactive components in a single React tree."
                },
                {
                    "type": "p",
                    "text": "For example, you can write a server-only React component as anasyncfunction that reads from a database or from a file. Then you can pass data down from it to your interactive components:"
                },
                {
                    "type": "code",
                    "code": "// This component runs *only* on the server (or during the build).asyncfunctionTalks({confId}){// 1. You're on the server, so you can talk to your data layer. API endpoint not required.consttalks=awaitdb.Talks.findAll({confId});// 2. Add any amount of rendering logic. It won't make your JavaScript bundle larger.constvideos=talks.map(talk=>talk.video);// 3. Pass the data down to the components that will run in the browser.return<SearchableVideoListvideos={videos}/>;}"
                },
                {
                    "type": "p",
                    "text": "Next.js’s App Router also integratesdata fetching with Suspense. This lets you specify a loading state (like a skeleton placeholder) for different parts of your user interface directly in your React tree:"
                },
                {
                    "type": "code",
                    "code": "<Suspensefallback={<TalksLoading/>}><TalksconfId={conf.id}/></Suspense>"
                },
                {
                    "type": "p",
                    "text": "Server Components and Suspense are React features rather than Next.js features. However, adopting them at the framework level requires buy-in and non-trivial implementation work. At the moment, the Next.js App Router is the most complete implementation. The React team is working with bundler developers to make these features easier to implement in the next generation of frameworks."
                }
            ]
        },
        {
            "url": "https://react.dev/learn/state-a-components-memory",
            "title": "State: A Component's Memory – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "State: A Component's Memory"
                },
                {
                    "type": "p",
                    "text": "Components often need to change what’s on the screen as a result of an interaction. Typing into the form should update the input field, clicking “next” on an image carousel should change which image is displayed, clicking “buy” should put a product in the shopping cart. Components need to “remember” things: the current input value, the current image, the shopping cart. In React, this kind of component-specific memory is calledstate."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "How to add a state variable with theuseStateHook",
                        "What pair of values theuseStateHook returns",
                        "How to add more than one state variable",
                        "Why state is called local"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "When a regular variable isn’t enough"
                },
                {
                    "type": "p",
                    "text": "Here’s a component that renders a sculpture image. Clicking the “Next” button should show the next sculpture by changing theindexto1, then2, and so on. However, thiswon’t work(you can try it!):"
                },
                {
                    "type": "code",
                    "code": "import{sculptureList}from'./data.js';exportdefaultfunctionGallery(){letindex=0;functionhandleClick(){index=index+1;}letsculpture=sculptureList[index];return(<><buttononClick={handleClick}>Next</button><h2><i>{sculpture.name}</i>by{sculpture.artist}</h2><h3>({index+1}of{sculptureList.length})</h3><imgsrc={sculpture.url}alt={sculpture.alt}/><p>{sculpture.description}</p></>);}"
                },
                {
                    "type": "p",
                    "text": "ThehandleClickevent handler is updating a local variable,index. But two things prevent that change from being visible:"
                },
                {
                    "type": "list",
                    "items": [
                        "Local variables don’t persist between renders.When React renders this component a second time, it renders it from scratch—it doesn’t consider any changes to the local variables.",
                        "Changes to local variables won’t trigger renders.React doesn’t realize it needs to render the component again with the new data."
                    ]
                },
                {
                    "type": "p",
                    "text": "To update a component with new data, two things need to happen:"
                },
                {
                    "type": "list",
                    "items": [
                        "Retainthe data between renders.",
                        "TriggerReact to render the component with new data (re-rendering)."
                    ]
                },
                {
                    "type": "p",
                    "text": "TheuseStateHook provides those two things:"
                },
                {
                    "type": "list",
                    "items": [
                        "Astate variableto retain the data between renders.",
                        "Astate setter functionto update the variable and trigger React to render the component again."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Adding a state variable"
                },
                {
                    "type": "p",
                    "text": "To add a state variable, importuseStatefrom React at the top of the file:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';"
                },
                {
                    "type": "p",
                    "text": "Then, replace this line:"
                },
                {
                    "type": "code",
                    "code": "letindex=0;"
                },
                {
                    "type": "p",
                    "text": "with"
                },
                {
                    "type": "code",
                    "code": "const[index,setIndex]=useState(0);"
                },
                {
                    "type": "p",
                    "text": "indexis a state variable andsetIndexis the setter function."
                },
                {
                    "type": "p",
                    "text": "The[and]syntax here is calledarray destructuringand it lets you read values from an array. The array returned byuseStatealways has exactly two items."
                },
                {
                    "type": "p",
                    "text": "This is how they work together inhandleClick:"
                },
                {
                    "type": "code",
                    "code": "functionhandleClick(){setIndex(index+1);}"
                },
                {
                    "type": "p",
                    "text": "Now clicking the “Next” button switches the current sculpture:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';import{sculptureList}from'./data.js';exportdefaultfunctionGallery(){const[index,setIndex]=useState(0);functionhandleClick(){setIndex(index+1);}letsculpture=sculptureList[index];return(<><buttononClick={handleClick}>Next</button><h2><i>{sculpture.name}</i>by{sculpture.artist}</h2><h3>({index+1}of{sculptureList.length})</h3><imgsrc={sculpture.url}alt={sculpture.alt}/><p>{sculpture.description}</p></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Meet your first Hook"
                },
                {
                    "type": "p",
                    "text": "In React,useState, as well as any other function starting with “use”, is called a Hook."
                },
                {
                    "type": "p",
                    "text": "Hooksare special functions that are only available while React isrendering(which we’ll get into in more detail on the next page). They let you “hook into” different React features."
                },
                {
                    "type": "p",
                    "text": "State is just one of those features, but you will meet the other Hooks later."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Hooks—functions starting withuse—can only be called at the top level of your components oryour own Hooks.You can’t call Hooks inside conditions, loops, or other nested functions. Hooks are functions, but it’s helpful to think of them as unconditional declarations about your component’s needs. You “use” React features at the top of your component similar to how you “import” modules at the top of your file."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Anatomy ofuseState"
                },
                {
                    "type": "p",
                    "text": "When you calluseState, you are telling React that you want this component to remember something:"
                },
                {
                    "type": "code",
                    "code": "const[index,setIndex]=useState(0);"
                },
                {
                    "type": "p",
                    "text": "In this case, you want React to rememberindex."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "The convention is to name this pair likeconst [something, setSomething]. You could name it anything you like, but conventions make things easier to understand across projects."
                },
                {
                    "type": "p",
                    "text": "The only argument touseStateis theinitial valueof your state variable. In this example, theindex’s initial value is set to0withuseState(0)."
                },
                {
                    "type": "p",
                    "text": "Every time your component renders,useStategives you an array containing two values:"
                },
                {
                    "type": "list",
                    "items": [
                        "Thestate variable(index) with the value you stored.",
                        "Thestate setter function(setIndex) which can update the state variable and trigger React to render the component again."
                    ]
                },
                {
                    "type": "p",
                    "text": "Here’s how that happens in action:"
                },
                {
                    "type": "code",
                    "code": "const[index,setIndex]=useState(0);"
                },
                {
                    "type": "list",
                    "items": [
                        "Your component renders the first time.Because you passed0touseStateas the initial value forindex, it will return[0, setIndex]. React remembers0is the latest state value.",
                        "You update the state.When a user clicks the button, it callssetIndex(index + 1).indexis0, so it’ssetIndex(1). This tells React to rememberindexis1now and triggers another render.",
                        "Your component’s second render.React still seesuseState(0), but because Reactremembersthat you setindexto1, it returns[1, setIndex]instead.",
                        "And so on!"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Giving a component multiple state variables"
                },
                {
                    "type": "p",
                    "text": "You can have as many state variables of as many types as you like in one component. This component has two state variables, a numberindexand a booleanshowMorethat’s toggled when you click “Show details”:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';import{sculptureList}from'./data.js';exportdefaultfunctionGallery(){const[index,setIndex]=useState(0);const[showMore,setShowMore]=useState(false);functionhandleNextClick(){setIndex(index+1);}functionhandleMoreClick(){setShowMore(!showMore);}letsculpture=sculptureList[index];return(<><buttononClick={handleNextClick}>Next</button><h2><i>{sculpture.name}</i>by{sculpture.artist}</h2><h3>({index+1}of{sculptureList.length})</h3><buttononClick={handleMoreClick}>{showMore?'Hide':'Show'}details</button>{showMore&&<p>{sculpture.description}</p>}<imgsrc={sculpture.url}alt={sculpture.alt}/></>);}"
                },
                {
                    "type": "p",
                    "text": "It is a good idea to have multiple state variables if their state is unrelated, likeindexandshowMorein this example. But if you find that you often change two state variables together, it might be easier to combine them into one. For example, if you have a form with many fields, it’s more convenient to have a single state variable that holds an object than state variable per field. ReadChoosing the State Structurefor more tips."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "How does React know which state to return?"
                },
                {
                    "type": "p",
                    "text": "You might have noticed that theuseStatecall does not receive any information aboutwhichstate variable it refers to. There is no “identifier” that is passed touseState, so how does it know which of the state variables to return? Does it rely on some magic like parsing your functions? The answer is no."
                },
                {
                    "type": "p",
                    "text": "Instead, to enable their concise syntax, Hooksrely on a stable call order on every render of the same component.This works well in practice because if you follow the rule above (“only call Hooks at the top level”), Hooks will always be called in the same order. Additionally, alinter plugincatches most mistakes."
                },
                {
                    "type": "p",
                    "text": "Internally, React holds an array of state pairs for every component. It also maintains the current pair index, which is set to0before rendering. Each time you calluseState, React gives you the next state pair and increments the index. You can read more about this mechanism inReact Hooks: Not Magic, Just Arrays."
                },
                {
                    "type": "p",
                    "text": "This exampledoesn’t use Reactbut it gives you an idea of howuseStateworks internally:"
                },
                {
                    "type": "code",
                    "code": "letcomponentHooks=[];letcurrentHookIndex=0;// How useState works inside React (simplified).functionuseState(initialState){letpair=componentHooks[currentHookIndex];if(pair){// This is not the first render,// so the state pair already exists.// Return it and prepare for next Hook call.currentHookIndex++;returnpair;}// This is the first time we're rendering,// so create a state pair and store it.pair=[initialState,setState];functionsetState(nextState){// When the user requests a state change,// put the new value into the pair.pair[0]=nextState;updateDOM();}// Store the pair for future renders// and prepare for the next Hook call.componentHooks[currentHookIndex]=pair;currentHookIndex++;returnpair;}functionGallery(){// Each useState() call will get the next pair.const[index,setIndex]=useState(0);const[showMore,setShowMore]=useState(false);functionhandleNextClick(){setIndex(index+1);}functionhandleMoreClick(){setShowMore(!showMore);}letsculpture=sculptureList[index];// This example doesn't use React, so// return an output object instead of JSX.return{onNextClick:handleNextClick,onMoreClick:handleMoreClick,header:`${sculpture.name}by${sculpture.artist}`,counter:`${index+1}of${sculptureList.length}`,more:`${showMore?'Hide':'Show'}details`,description:showMore?sculpture.description:null,imageSrc:sculpture.url,imageAlt:sculpture.alt};}functionupdateDOM(){// Reset the current Hook index// before rendering the component.currentHookIndex=0;letoutput=Gallery();// Update the DOM to match the output.// This is the part React does for you.nextButton.onclick=output.onNextClick;header.textContent=output.header;moreButton.onclick=output.onMoreClick;moreButton.textContent=output.more;image.src=output.imageSrc;image.alt=output.imageAlt;if(output.description!==null){description.textContent=output.description;description.style.display='';}else{description.style.display='none';}}letnextButton=document.getElementById('nextButton');letheader=document.getElementById('header');letmoreButton=document.getElementById('moreButton');letdescription=document.getElementById('description');letimage=document.getElementById('image');letsculptureList=[{name:'Homenaje a la Neurocirugía',artist:'Marta Colvin Andrade',description:'Although Colvin is predominantly known for abstract themes that allude to pre-Hispanic symbols, this gigantic sculpture, an homage to neurosurgery, is one of her most recognizable public art pieces.',url:'https://i.imgur.com/Mx7dA2Y.jpg',alt:'A bronze statue of two crossed hands delicately holding a human brain in their fingertips.'},{name:'Floralis Genérica',artist:'Eduardo Catalano',description:'This enormous (75 ft. or 23m) silver flower is located in Buenos Aires. It is designed to move, closing its petals in the evening or when strong winds blow and opening them in the morning.',url:'https://i.imgur.com/ZF6s192m.jpg',alt:'A gigantic metallic flower sculpture with reflective mirror-like petals and strong stamens.'},{name:'Eternal Presence',artist:'John Woodrow Wilson',description:'Wilson was known for his preoccupation with equality, social justice, as well as the essential and spiritual qualities of humankind. This massive (7ft. or 2,13m) bronze represents what he described as \"a symbolic Black presence infused with a sense of universal humanity.\"',url:'https://i.imgur.com/aTtVpES.jpg',alt:'The sculpture depicting a human head seems ever-present and solemn. It radiates calm and serenity.'},{name:'Moai',artist:'Unknown Artist',description:'Located on the Easter Island, there are 1,000 moai, or extant monumental statues, created by the early Rapa Nui people, which some believe represented deified ancestors.',url:'https://i.imgur.com/RCwLEoQm.jpg',alt:'Three monumental stone busts with the heads that are disproportionately large with somber faces.'},{name:'Blue Nana',artist:'Niki de Saint Phalle',description:'The Nanas are triumphant creatures, symbols of femininity and maternity. Initially, Saint Phalle used fabric and found objects for the Nanas, and later on introduced polyester to achieve a more vibrant effect.',url:'https://i.imgur.com/Sd1AgUOm.jpg',alt:'A large mosaic sculpture of a whimsical dancing female figure in a colorful costume emanating joy.'},{name:'Ultimate Form',artist:'Barbara Hepworth',description:'This abstract bronze sculpture is a part of The Family of Man series located at Yorkshire Sculpture Park. Hepworth chose not to create literal representations of the world but developed abstract forms inspired by people and landscapes.',url:'https://i.imgur.com/2heNQDcm.jpg',alt:'A tall sculpture made of three elements stacked on each other reminding of a human figure.'},{name:'Cavaliere',artist:'Lamidi Olonade Fakeye',description:\"Descended from four generations of woodcarvers, Fakeye's work blended traditional and contemporary Yoruba themes.\",url:'https://i.imgur.com/wIdGuZwm.png',alt:'An intricate wood sculpture of a warrior with a focused face on a horse adorned with patterns.'},{name:'Big Bellies',artist:'Alina Szapocznikow',description:\"Szapocznikow is known for her sculptures of the fragmented body as a metaphor for the fragility and impermanence of youth and beauty. This sculpture depicts two very realistic large bellies stacked on top of each other, each around five feet (1,5m) tall.\",url:'https://i.imgur.com/AlHTAdDm.jpg',alt:'The sculpture reminds a cascade of folds, quite different from bellies in classical sculptures.'},{name:'Terracotta Army',artist:'Unknown Artist',description:'The Terracotta Army is a collection of terracotta sculptures depicting the armies of Qin Shi Huang, the first Emperor of China. The army consisted of more than 8,000 soldiers, 130 chariots with 520 horses, and 150 cavalry horses.',url:'https://i.imgur.com/HMFmH6m.jpg',alt:'12 terracotta sculptures of solemn warriors, each with a unique facial expression and armor.'},{name:'Lunar Landscape',artist:'Louise Nevelson',description:'Nevelson was known for scavenging objects from New York City debris, which she would later assemble into monumental constructions. In this one, she used disparate parts like a bedpost, juggling pin, and seat fragment, nailing and gluing them into boxes that reflect the influence of Cubism’s geometric abstraction of space and form.',url:'https://i.imgur.com/rN7hY6om.jpg',alt:'A black matte sculpture where the individual elements are initially indistinguishable.'},{name:'Aureole',artist:'Ranjani Shettar',description:'Shettar merges the traditional and the modern, the natural and the industrial. Her art focuses on the relationship between man and nature. Her work was described as compelling both abstractly and figuratively, gravity defying, and a \"fine synthesis of unlikely materials.\"',url:'https://i.imgur.com/okTpbHhm.jpg',alt:'A pale wire-like sculpture mounted on concrete wall and descending on the floor. It appears light.'},{name:'Hippos',artist:'Taipei Zoo',description:'The Taipei Zoo commissioned a Hippo Square featuring submerged hippos at play.',url:'https://i.imgur.com/6o5Vuyu.jpg',alt:'A group of bronze hippo sculptures emerging from the sett sidewalk as if they were swimming.'}];// Make UI match the initial state.updateDOM();"
                },
                {
                    "type": "p",
                    "text": "You don’t have to understand it to use React, but you might find this a helpful mental model."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "State is isolated and private"
                },
                {
                    "type": "p",
                    "text": "State is local to a component instance on the screen. In other words,if you render the same component twice, each copy will have completely isolated state!Changing one of them will not affect the other."
                },
                {
                    "type": "p",
                    "text": "In this example, theGallerycomponent from earlier is rendered twice with no changes to its logic. Try clicking the buttons inside each of the galleries. Notice that their state is independent:"
                },
                {
                    "type": "code",
                    "code": "importGalleryfrom'./Gallery.js';exportdefaultfunctionPage(){return(<divclassName=\"Page\"><Gallery/><Gallery/></div>);}"
                },
                {
                    "type": "p",
                    "text": "This is what makes state different from regular variables that you might declare at the top of your module. State is not tied to a particular function call or a place in the code, but it’s “local” to the specific place on the screen. You rendered two<Gallery />components, so their state is stored separately."
                },
                {
                    "type": "p",
                    "text": "Also notice how thePagecomponent doesn’t “know” anything about theGallerystate or even whether it has any. Unlike props,state is fully private to the component declaring it.The parent component can’t change it. This lets you add state to any component or remove it without impacting the rest of the components."
                },
                {
                    "type": "p",
                    "text": "What if you wanted both galleries to keep their states in sync? The right way to do it in React is toremovestate from child components and add it to their closest shared parent. The next few pages will focus on organizing state of a single component, but we will return to this topic inSharing State Between Components."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "Use a state variable when a component needs to “remember” some information between renders.",
                        "State variables are declared by calling theuseStateHook.",
                        "Hooks are special functions that start withuse. They let you “hook into” React features like state.",
                        "Hooks might remind you of imports: they need to be called unconditionally. Calling Hooks, includinguseState, is only valid at the top level of a component or another Hook.",
                        "TheuseStateHook returns a pair of values: the current state and the function to update it.",
                        "You can have more than one state variable. Internally, React matches them up by their order.",
                        "State is private to the component. If you render it in two places, each copy gets its own state."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of4:Complete the gallery"
                },
                {
                    "type": "p",
                    "text": "When you press “Next” on the last sculpture, the code crashes. Fix the logic to prevent the crash. You may do this by adding extra logic to event handler or by disabling the button when the action is not possible."
                },
                {
                    "type": "p",
                    "text": "After fixing the crash, add a “Previous” button that shows the previous sculpture. It shouldn’t crash on the first sculpture."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';import{sculptureList}from'./data.js';exportdefaultfunctionGallery(){const[index,setIndex]=useState(0);const[showMore,setShowMore]=useState(false);functionhandleNextClick(){setIndex(index+1);}functionhandleMoreClick(){setShowMore(!showMore);}letsculpture=sculptureList[index];return(<><buttononClick={handleNextClick}>Next</button><h2><i>{sculpture.name}</i>by{sculpture.artist}</h2><h3>({index+1}of{sculptureList.length})</h3><buttononClick={handleMoreClick}>{showMore?'Hide':'Show'}details</button>{showMore&&<p>{sculpture.description}</p>}<imgsrc={sculpture.url}alt={sculpture.alt}/></>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/state-as-a-snapshot",
            "title": "State as a Snapshot – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "State as a Snapshot"
                },
                {
                    "type": "p",
                    "text": "State variables might look like regular JavaScript variables that you can read and write to. However, state behaves more like a snapshot. Setting it does not change the state variable you already have, but instead triggers a re-render."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "How setting state triggers re-renders",
                        "When and how state updates",
                        "Why state does not update immediately after you set it",
                        "How event handlers access a “snapshot” of the state"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Setting state triggers renders"
                },
                {
                    "type": "p",
                    "text": "You might think of your user interface as changing directly in response to the user event like a click. In React, it works a little differently from this mental model. On the previous page, you saw thatsetting state requests a re-renderfrom React. This means that for an interface to react to the event, you need toupdate the state."
                },
                {
                    "type": "p",
                    "text": "In this example, when you press “send”,setIsSent(true)tells React to re-render the UI:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionForm(){const[isSent,setIsSent]=useState(false);const[message,setMessage]=useState('Hi!');if(isSent){return<h1>Your message is on its way!</h1>}return(<formonSubmit={(e)=>{e.preventDefault();setIsSent(true);sendMessage(message);}}><textareaplaceholder=\"Message\"value={message}onChange={e=>setMessage(e.target.value)}/><buttontype=\"submit\">Send</button></form>);}functionsendMessage(message){// ...}"
                },
                {
                    "type": "p",
                    "text": "Here’s what happens when you click the button:"
                },
                {
                    "type": "list",
                    "items": [
                        "TheonSubmitevent handler executes.",
                        "setIsSent(true)setsisSenttotrueand queues a new render.",
                        "React re-renders the component according to the newisSentvalue."
                    ]
                },
                {
                    "type": "p",
                    "text": "Let’s take a closer look at the relationship between state and rendering."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Rendering takes a snapshot in time"
                },
                {
                    "type": "p",
                    "text": "“Rendering”means that React is calling your component, which is a function. The JSX you return from that function is like a snapshot of the UI in time. Its props, event handlers, and local variables were all calculatedusing its state at the time of the render."
                },
                {
                    "type": "p",
                    "text": "Unlike a photograph or a movie frame, the UI “snapshot” you return is interactive. It includes logic like event handlers that specify what happens in response to inputs. React updates the screen to match this snapshot and connects the event handlers. As a result, pressing a button will trigger the click handler from your JSX."
                },
                {
                    "type": "p",
                    "text": "When React re-renders a component:"
                },
                {
                    "type": "list",
                    "items": [
                        "React calls your function again.",
                        "Your function returns a new JSX snapshot.",
                        "React then updates the screen to match the snapshot your function returned."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "React executing the function",
                        "Calculating the snapshot",
                        "Updating the DOM tree"
                    ]
                },
                {
                    "type": "p",
                    "text": "Illustrated byRachel Lee Nabors"
                },
                {
                    "type": "p",
                    "text": "As a component’s memory, state is not like a regular variable that disappears after your function returns. State actually “lives” in React itself—as if on a shelf!—outside of your function. When React calls your component, it gives you a snapshot of the state for that particular render. Your component returns a snapshot of the UI with a fresh set of props and event handlers in its JSX, all calculatedusing the state values from that render!"
                },
                {
                    "type": "list",
                    "items": [
                        "You tell React to update the state",
                        "React updates the state value",
                        "React passes a snapshot of the state value into the component"
                    ]
                },
                {
                    "type": "p",
                    "text": "Illustrated byRachel Lee Nabors"
                },
                {
                    "type": "p",
                    "text": "Here’s a little experiment to show you how this works. In this example, you might expect that clicking the “+3” button would increment the counter three times because it callssetNumber(number + 1)three times."
                },
                {
                    "type": "p",
                    "text": "See what happens when you click the “+3” button:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionCounter(){const[number,setNumber]=useState(0);return(<><h1>{number}</h1><buttononClick={()=>{setNumber(number+1);setNumber(number+1);setNumber(number+1);}}>+3</button></>)}"
                },
                {
                    "type": "p",
                    "text": "Notice thatnumberonly increments once per click!"
                },
                {
                    "type": "p",
                    "text": "Setting state only changes it for thenextrender.During the first render,numberwas0. This is why, inthat render’sonClickhandler, the value ofnumberis still0even aftersetNumber(number + 1)was called:"
                },
                {
                    "type": "code",
                    "code": "<buttononClick={()=>{setNumber(number+1);setNumber(number+1);setNumber(number+1);}}>+3</button>"
                },
                {
                    "type": "p",
                    "text": "Here is what this button’s click handler tells React to do:"
                },
                {
                    "type": "list",
                    "items": [
                        "setNumber(number + 1):numberis0sosetNumber(0 + 1).React prepares to changenumberto1on the next render.",
                        "React prepares to changenumberto1on the next render.",
                        "setNumber(number + 1):numberis0sosetNumber(0 + 1).React prepares to changenumberto1on the next render.",
                        "React prepares to changenumberto1on the next render.",
                        "setNumber(number + 1):numberis0sosetNumber(0 + 1).React prepares to changenumberto1on the next render.",
                        "React prepares to changenumberto1on the next render."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "React prepares to changenumberto1on the next render."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "React prepares to changenumberto1on the next render."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "React prepares to changenumberto1on the next render."
                    ]
                },
                {
                    "type": "p",
                    "text": "Even though you calledsetNumber(number + 1)three times, inthis render’sevent handlernumberis always0, so you set the state to1three times. This is why, after your event handler finishes, React re-renders the component withnumberequal to1rather than3."
                },
                {
                    "type": "p",
                    "text": "You can also visualize this by mentally substituting state variables with their values in your code. Since thenumberstate variable is0forthis render, its event handler looks like this:"
                },
                {
                    "type": "code",
                    "code": "<buttononClick={()=>{setNumber(0+1);setNumber(0+1);setNumber(0+1);}}>+3</button>"
                },
                {
                    "type": "p",
                    "text": "For the next render,numberis1, sothat render’sclick handler looks like this:"
                },
                {
                    "type": "code",
                    "code": "<buttononClick={()=>{setNumber(1+1);setNumber(1+1);setNumber(1+1);}}>+3</button>"
                },
                {
                    "type": "p",
                    "text": "This is why clicking the button again will set the counter to2, then to3on the next click, and so on."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "State over time"
                },
                {
                    "type": "p",
                    "text": "Well, that was fun. Try to guess what clicking this button will alert:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionCounter(){const[number,setNumber]=useState(0);return(<><h1>{number}</h1><buttononClick={()=>{setNumber(number+5);alert(number);}}>+5</button></>)}"
                },
                {
                    "type": "p",
                    "text": "If you use the substitution method from before, you can guess that the alert shows “0”:"
                },
                {
                    "type": "code",
                    "code": "setNumber(0+5);alert(0);"
                },
                {
                    "type": "p",
                    "text": "But what if you put a timer on the alert, so it only firesafterthe component re-rendered? Would it say “0” or “5”? Have a guess!"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionCounter(){const[number,setNumber]=useState(0);return(<><h1>{number}</h1><buttononClick={()=>{setNumber(number+5);setTimeout(()=>{alert(number);},3000);}}>+5</button></>)}"
                },
                {
                    "type": "p",
                    "text": "Surprised? If you use the substitution method, you can see the “snapshot” of the state passed to the alert."
                },
                {
                    "type": "code",
                    "code": "setNumber(0+5);setTimeout(()=>{alert(0);},3000);"
                },
                {
                    "type": "p",
                    "text": "The state stored in React may have changed by the time the alert runs, but it was scheduled using a snapshot of the state at the time the user interacted with it!"
                },
                {
                    "type": "p",
                    "text": "A state variable’s value never changes within a render,even if its event handler’s code is asynchronous. Insidethat render’sonClick, the value ofnumbercontinues to be0even aftersetNumber(number + 5)was called. Its value was “fixed” when React “took the snapshot” of the UI by calling your component."
                },
                {
                    "type": "p",
                    "text": "Here is an example of how that makes your event handlers less prone to timing mistakes. Below is a form that sends a message with a five-second delay. Imagine this scenario:"
                },
                {
                    "type": "list",
                    "items": [
                        "You press the “Send” button, sending “Hello” to Alice.",
                        "Before the five-second delay ends, you change the value of the “To” field to “Bob”."
                    ]
                },
                {
                    "type": "p",
                    "text": "What do you expect thealertto display? Would it display, “You said Hello to Alice”? Or would it display, “You said Hello to Bob”? Make a guess based on what you know, and then try it:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionForm(){const[to,setTo]=useState('Alice');const[message,setMessage]=useState('Hello');functionhandleSubmit(e){e.preventDefault();setTimeout(()=>{alert(`You said${message}to${to}`);},5000);}return(<formonSubmit={handleSubmit}><label>To:{' '}<selectvalue={to}onChange={e=>setTo(e.target.value)}><optionvalue=\"Alice\">Alice</option><optionvalue=\"Bob\">Bob</option></select></label><textareaplaceholder=\"Message\"value={message}onChange={e=>setMessage(e.target.value)}/><buttontype=\"submit\">Send</button></form>);}"
                },
                {
                    "type": "p",
                    "text": "React keeps the state values “fixed” within one render’s event handlers.You don’t need to worry whether the state has changed while the code is running."
                },
                {
                    "type": "p",
                    "text": "But what if you wanted to read the latest state before a re-render? You’ll want to use astate updater function, covered on the next page!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "Setting state requests a new render.",
                        "React stores state outside of your component, as if on a shelf.",
                        "When you calluseState, React gives you a snapshot of the statefor that render.",
                        "Variables and event handlers don’t “survive” re-renders. Every render has its own event handlers.",
                        "Every render (and functions inside it) will always “see” the snapshot of the state that React gave tothatrender.",
                        "You can mentally substitute state in event handlers, similarly to how you think about the rendered JSX.",
                        "Event handlers created in the past have the state values from the render in which they were created."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of1:Implement a traffic light"
                },
                {
                    "type": "p",
                    "text": "Here is a crosswalk light component that toggles when the button is pressed:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionTrafficLight(){const[walk,setWalk]=useState(true);functionhandleClick(){setWalk(!walk);}return(<><buttononClick={handleClick}>Change to{walk?'Stop':'Walk'}</button><h1style={{color:walk?'darkgreen':'darkred'}}>{walk?'Walk':'Stop'}</h1></>);}"
                },
                {
                    "type": "p",
                    "text": "Add analertto the click handler. When the light is green and says “Walk”, clicking the button should say “Stop is next”. When the light is red and says “Stop”, clicking the button should say “Walk is next”."
                },
                {
                    "type": "p",
                    "text": "Does it make a difference whether you put thealertbefore or after thesetWalkcall?"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/synchronizing-with-effects",
            "title": "Synchronizing with Effects – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Synchronizing with Effects"
                },
                {
                    "type": "p",
                    "text": "Some components need to synchronize with external systems. For example, you might want to control a non-React component based on the React state, set up a server connection, or send an analytics log when a component appears on the screen.Effectslet you run some code after rendering so that you can synchronize your component with some system outside of React."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "What Effects are",
                        "How Effects are different from events",
                        "How to declare an Effect in your component",
                        "How to skip re-running an Effect unnecessarily",
                        "Why Effects run twice in development and how to fix them"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "What are Effects and how are they different from events?"
                },
                {
                    "type": "p",
                    "text": "Before getting to Effects, you need to be familiar with two types of logic inside React components:"
                },
                {
                    "type": "list",
                    "items": [
                        "Rendering code(introduced inDescribing the UI) lives at the top level of your component. This is where you take the props and state, transform them, and return the JSX you want to see on the screen.Rendering code must be pure.Like a math formula, it should onlycalculatethe result, but not do anything else.",
                        "Event handlers(introduced inAdding Interactivity) are nested functions inside your components thatdothings rather than just calculate them. An event handler might update an input field, submit an HTTP POST request to buy a product, or navigate the user to another screen. Event handlers contain“side effects”(they change the program’s state) caused by a specific user action (for example, a button click or typing)."
                    ]
                },
                {
                    "type": "p",
                    "text": "Rendering code(introduced inDescribing the UI) lives at the top level of your component. This is where you take the props and state, transform them, and return the JSX you want to see on the screen.Rendering code must be pure.Like a math formula, it should onlycalculatethe result, but not do anything else."
                },
                {
                    "type": "p",
                    "text": "Event handlers(introduced inAdding Interactivity) are nested functions inside your components thatdothings rather than just calculate them. An event handler might update an input field, submit an HTTP POST request to buy a product, or navigate the user to another screen. Event handlers contain“side effects”(they change the program’s state) caused by a specific user action (for example, a button click or typing)."
                },
                {
                    "type": "p",
                    "text": "Sometimes this isn’t enough. Consider aChatRoomcomponent that must connect to the chat server whenever it’s visible on the screen. Connecting to a server is not a pure calculation (it’s a side effect) so it can’t happen during rendering. However, there is no single particular event like a click that causesChatRoomto be displayed."
                },
                {
                    "type": "p",
                    "text": "Effectslet you specify side effects that are caused by rendering itself, rather than by a particular event.Sending a message in the chat is aneventbecause it is directly caused by the user clicking a specific button. However, setting up a server connection is anEffectbecause it should happen no matter which interaction caused the component to appear. Effects run at the end of acommitafter the screen updates. This is a good time to synchronize the React components with some external system (like network or a third-party library)."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Here and later in this text, capitalized “Effect” refers to the React-specific definition above, i.e. a side effect caused by rendering. To refer to the broader programming concept, we’ll say “side effect”."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "You might not need an Effect"
                },
                {
                    "type": "p",
                    "text": "Don’t rush to add Effects to your components.Keep in mind that Effects are typically used to “step out” of your React code and synchronize with someexternalsystem. This includes browser APIs, third-party widgets, network, and so on. If your Effect only adjusts some state based on other state,you might not need an Effect."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "How to write an Effect"
                },
                {
                    "type": "p",
                    "text": "To write an Effect, follow these three steps:"
                },
                {
                    "type": "list",
                    "items": [
                        "Declare an Effect.By default, your Effect will run after everycommit.",
                        "Specify the Effect dependencies.Most Effects should only re-runwhen neededrather than after every render. For example, a fade-in animation should only trigger when a component appears. Connecting and disconnecting to a chat room should only happen when the component appears and disappears, or when the chat room changes. You will learn how to control this by specifyingdependencies.",
                        "Add cleanup if needed.Some Effects need to specify how to stop, undo, or clean up whatever they were doing. For example, “connect” needs “disconnect”, “subscribe” needs “unsubscribe”, and “fetch” needs either “cancel” or “ignore”. You will learn how to do this by returning acleanup function."
                    ]
                },
                {
                    "type": "p",
                    "text": "Let’s look at each of these steps in detail."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 1: Declare an Effect"
                },
                {
                    "type": "p",
                    "text": "To declare an Effect in your component, import theuseEffectHookfrom React:"
                },
                {
                    "type": "code",
                    "code": "import{useEffect}from'react';"
                },
                {
                    "type": "p",
                    "text": "Then, call it at the top level of your component and put some code inside your Effect:"
                },
                {
                    "type": "code",
                    "code": "functionMyComponent(){useEffect(()=>{// Code here will run after *every* render});return<div/>;}"
                },
                {
                    "type": "p",
                    "text": "Every time your component renders, React will update the screenand thenrun the code insideuseEffect. In other words,useEffect“delays” a piece of code from running until that render is reflected on the screen."
                },
                {
                    "type": "p",
                    "text": "Let’s see how you can use an Effect to synchronize with an external system. Consider a<VideoPlayer>React component. It would be nice to control whether it’s playing or paused by passing anisPlayingprop to it:"
                },
                {
                    "type": "code",
                    "code": "<VideoPlayerisPlaying={isPlaying}/>;"
                },
                {
                    "type": "p",
                    "text": "Your customVideoPlayercomponent renders the built-in browser<video>tag:"
                },
                {
                    "type": "code",
                    "code": "functionVideoPlayer({src,isPlaying}){// TODO: do something with isPlayingreturn<videosrc={src}/>;}"
                },
                {
                    "type": "p",
                    "text": "However, the browser<video>tag does not have anisPlayingprop. The only way to control it is to manually call theplay()andpause()methods on the DOM element.You need to synchronize the value ofisPlayingprop, which tells whether the videoshouldcurrently be playing, with calls likeplay()andpause()."
                },
                {
                    "type": "p",
                    "text": "We’ll need to firstget a refto the<video>DOM node."
                },
                {
                    "type": "p",
                    "text": "You might be tempted to try to callplay()orpause()during rendering, but that isn’t correct:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useRef,useEffect}from'react';functionVideoPlayer({src,isPlaying}){constref=useRef(null);if(isPlaying){ref.current.play();// Calling these while rendering isn't allowed.}else{ref.current.pause();// Also, this crashes.}return<videoref={ref}src={src}loopplaysInline/>;}exportdefaultfunctionApp(){const[isPlaying,setIsPlaying]=useState(false);return(<><buttononClick={()=>setIsPlaying(!isPlaying)}>{isPlaying?'Pause':'Play'}</button><VideoPlayerisPlaying={isPlaying}src=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"/></>);}"
                },
                {
                    "type": "p",
                    "text": "The reason this code isn’t correct is that it tries to do something with the DOM node during rendering. In React,rendering should be a pure calculationof JSX and should not contain side effects like modifying the DOM."
                },
                {
                    "type": "p",
                    "text": "Moreover, whenVideoPlayeris called for the first time, its DOM does not exist yet! There isn’t a DOM node yet to callplay()orpause()on, because React doesn’t know what DOM to create until you return the JSX."
                },
                {
                    "type": "p",
                    "text": "The solution here is towrap the side effect withuseEffectto move it out of the rendering calculation:"
                },
                {
                    "type": "code",
                    "code": "import{useEffect,useRef}from'react';functionVideoPlayer({src,isPlaying}){constref=useRef(null);useEffect(()=>{if(isPlaying){ref.current.play();}else{ref.current.pause();}});return<videoref={ref}src={src}loopplaysInline/>;}"
                },
                {
                    "type": "p",
                    "text": "By wrapping the DOM update in an Effect, you let React update the screen first. Then your Effect runs."
                },
                {
                    "type": "p",
                    "text": "When yourVideoPlayercomponent renders (either the first time or if it re-renders), a few things will happen. First, React will update the screen, ensuring the<video>tag is in the DOM with the right props. Then React will run your Effect. Finally, your Effect will callplay()orpause()depending on the value ofisPlaying."
                },
                {
                    "type": "p",
                    "text": "Press Play/Pause multiple times and see how the video player stays synchronized to theisPlayingvalue:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useRef,useEffect}from'react';functionVideoPlayer({src,isPlaying}){constref=useRef(null);useEffect(()=>{if(isPlaying){ref.current.play();}else{ref.current.pause();}});return<videoref={ref}src={src}loopplaysInline/>;}exportdefaultfunctionApp(){const[isPlaying,setIsPlaying]=useState(false);return(<><buttononClick={()=>setIsPlaying(!isPlaying)}>{isPlaying?'Pause':'Play'}</button><VideoPlayerisPlaying={isPlaying}src=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"/></>);}"
                },
                {
                    "type": "p",
                    "text": "In this example, the “external system” you synchronized to React state was the browser media API. You can use a similar approach to wrap legacy non-React code (like jQuery plugins) into declarative React components."
                },
                {
                    "type": "p",
                    "text": "Note that controlling a video player is much more complex in practice. Callingplay()may fail, the user might play or pause using the built-in browser controls, and so on. This example is very simplified and incomplete."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "By default, Effects run aftereveryrender. This is why code like this willproduce an infinite loop:"
                },
                {
                    "type": "code",
                    "code": "const[count,setCount]=useState(0);useEffect(()=>{setCount(count+1);});"
                },
                {
                    "type": "p",
                    "text": "Effects run as aresultof rendering. Setting statetriggersrendering. Setting state immediately in an Effect is like plugging a power outlet into itself. The Effect runs, it sets the state, which causes a re-render, which causes the Effect to run, it sets the state again, this causes another re-render, and so on."
                },
                {
                    "type": "p",
                    "text": "Effects should usually synchronize your components with anexternalsystem. If there’s no external system and you only want to adjust some state based on other state,you might not need an Effect."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 2: Specify the Effect dependencies"
                },
                {
                    "type": "p",
                    "text": "By default, Effects run aftereveryrender. Often, this isnot what you want:"
                },
                {
                    "type": "list",
                    "items": [
                        "Sometimes, it’s slow. Synchronizing with an external system is not always instant, so you might want to skip doing it unless it’s necessary. For example, you don’t want to reconnect to the chat server on every keystroke.",
                        "Sometimes, it’s wrong. For example, you don’t want to trigger a component fade-in animation on every keystroke. The animation should only play once when the component appears for the first time."
                    ]
                },
                {
                    "type": "p",
                    "text": "To demonstrate the issue, here is the previous example with a fewconsole.logcalls and a text input that updates the parent component’s state. Notice how typing causes the Effect to re-run:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useRef,useEffect}from'react';functionVideoPlayer({src,isPlaying}){constref=useRef(null);useEffect(()=>{if(isPlaying){console.log('Calling video.play()');ref.current.play();}else{console.log('Calling video.pause()');ref.current.pause();}});return<videoref={ref}src={src}loopplaysInline/>;}exportdefaultfunctionApp(){const[isPlaying,setIsPlaying]=useState(false);const[text,setText]=useState('');return(<><inputvalue={text}onChange={e=>setText(e.target.value)}/><buttononClick={()=>setIsPlaying(!isPlaying)}>{isPlaying?'Pause':'Play'}</button><VideoPlayerisPlaying={isPlaying}src=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"/></>);}"
                },
                {
                    "type": "p",
                    "text": "You can tell React toskip unnecessarily re-running the Effectby specifying an array ofdependenciesas the second argument to theuseEffectcall. Start by adding an empty[]array to the above example on line 14:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{// ...},[]);"
                },
                {
                    "type": "p",
                    "text": "You should see an error sayingReact Hook useEffect has a missing dependency: 'isPlaying':"
                },
                {
                    "type": "code",
                    "code": "import{useState,useRef,useEffect}from'react';functionVideoPlayer({src,isPlaying}){constref=useRef(null);useEffect(()=>{if(isPlaying){console.log('Calling video.play()');ref.current.play();}else{console.log('Calling video.pause()');ref.current.pause();}},[]);// This causes an errorreturn<videoref={ref}src={src}loopplaysInline/>;}exportdefaultfunctionApp(){const[isPlaying,setIsPlaying]=useState(false);const[text,setText]=useState('');return(<><inputvalue={text}onChange={e=>setText(e.target.value)}/><buttononClick={()=>setIsPlaying(!isPlaying)}>{isPlaying?'Pause':'Play'}</button><VideoPlayerisPlaying={isPlaying}src=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"/></>);}"
                },
                {
                    "type": "p",
                    "text": "The problem is that the code inside of your Effectdepends ontheisPlayingprop to decide what to do, but this dependency was not explicitly declared. To fix this issue, addisPlayingto the dependency array:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{if(isPlaying){// It's used here...// ...}else{// ...}},[isPlaying]);// ...so it must be declared here!"
                },
                {
                    "type": "p",
                    "text": "Now all dependencies are declared, so there is no error. Specifying[isPlaying]as the dependency array tells React that it should skip re-running your Effect ifisPlayingis the same as it was during the previous render. With this change, typing into the input doesn’t cause the Effect to re-run, but pressing Play/Pause does:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useRef,useEffect}from'react';functionVideoPlayer({src,isPlaying}){constref=useRef(null);useEffect(()=>{if(isPlaying){console.log('Calling video.play()');ref.current.play();}else{console.log('Calling video.pause()');ref.current.pause();}},[isPlaying]);return<videoref={ref}src={src}loopplaysInline/>;}exportdefaultfunctionApp(){const[isPlaying,setIsPlaying]=useState(false);const[text,setText]=useState('');return(<><inputvalue={text}onChange={e=>setText(e.target.value)}/><buttononClick={()=>setIsPlaying(!isPlaying)}>{isPlaying?'Pause':'Play'}</button><VideoPlayerisPlaying={isPlaying}src=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"/></>);}"
                },
                {
                    "type": "p",
                    "text": "The dependency array can contain multiple dependencies. React will only skip re-running the Effect ifallof the dependencies you specify have exactly the same values as they had during the previous render. React compares the dependency values using theObject.iscomparison. See theuseEffectreferencefor details."
                },
                {
                    "type": "p",
                    "text": "Notice that you can’t “choose” your dependencies.You will get a lint error if the dependencies you specified don’t match what React expects based on the code inside your Effect. This helps catch many bugs in your code. If you don’t want some code to re-run,edit the Effect code itselfto not “need” that dependency."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "The behaviors without the dependency array and with anempty[]dependency array are different:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{// This runs after every render});useEffect(()=>{// This runs only on mount (when the component appears)},[]);useEffect(()=>{// This runs on mount *and also* if either a or b have changed since the last render},[a,b]);"
                },
                {
                    "type": "p",
                    "text": "We’ll take a close look at what “mount” means in the next step."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Why was the ref omitted from the dependency array?"
                },
                {
                    "type": "p",
                    "text": "This Effect usesbothrefandisPlaying, but onlyisPlayingis declared as a dependency:"
                },
                {
                    "type": "code",
                    "code": "functionVideoPlayer({src,isPlaying}){constref=useRef(null);useEffect(()=>{if(isPlaying){ref.current.play();}else{ref.current.pause();}},[isPlaying]);"
                },
                {
                    "type": "p",
                    "text": "This is because therefobject has astable identity:React guaranteesyou’ll always get the same objectfrom the sameuseRefcall on every render. It never changes, so it will never by itself cause the Effect to re-run. Therefore, it does not matter whether you include it or not. Including it is fine too:"
                },
                {
                    "type": "code",
                    "code": "functionVideoPlayer({src,isPlaying}){constref=useRef(null);useEffect(()=>{if(isPlaying){ref.current.play();}else{ref.current.pause();}},[isPlaying,ref]);"
                },
                {
                    "type": "p",
                    "text": "Thesetfunctionsreturned byuseStatealso have stable identity, so you will often see them omitted from the dependencies too. If the linter lets you omit a dependency without errors, it is safe to do."
                },
                {
                    "type": "p",
                    "text": "Omitting always-stable dependencies only works when the linter can “see” that the object is stable. For example, ifrefwas passed from a parent component, you would have to specify it in the dependency array. However, this is good because you can’t know whether the parent component always passes the same ref, or passes one of several refs conditionally. So your Effectwoulddepend on which ref is passed."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 3: Add cleanup if needed"
                },
                {
                    "type": "p",
                    "text": "Consider a different example. You’re writing aChatRoomcomponent that needs to connect to the chat server when it appears. You are given acreateConnection()API that returns an object withconnect()anddisconnect()methods. How do you keep the component connected while it is displayed to the user?"
                },
                {
                    "type": "p",
                    "text": "Start by writing the Effect logic:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{constconnection=createConnection();connection.connect();});"
                },
                {
                    "type": "p",
                    "text": "It would be slow to connect to the chat after every re-render, so you add the dependency array:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{constconnection=createConnection();connection.connect();},[]);"
                },
                {
                    "type": "p",
                    "text": "The code inside the Effect does not use any props or state, so your dependency array is[](empty). This tells React to only run this code when the component “mounts”, i.e. appears on the screen for the first time."
                },
                {
                    "type": "p",
                    "text": "Let’s try running this code:"
                },
                {
                    "type": "code",
                    "code": "import{useEffect}from'react';import{createConnection}from'./chat.js';exportdefaultfunctionChatRoom(){useEffect(()=>{constconnection=createConnection();connection.connect();},[]);return<h1>Welcome to the chat!</h1>;}"
                },
                {
                    "type": "p",
                    "text": "This Effect only runs on mount, so you might expect\"✅ Connecting...\"to be printed once in the console.However, if you check the console,\"✅ Connecting...\"gets printed twice. Why does it happen?"
                },
                {
                    "type": "p",
                    "text": "Imagine theChatRoomcomponent is a part of a larger app with many different screens. The user starts their journey on theChatRoompage. The component mounts and callsconnection.connect(). Then imagine the user navigates to another screen—for example, to the Settings page. TheChatRoomcomponent unmounts. Finally, the user clicks Back andChatRoommounts again. This would set up a second connection—but the first connection was never destroyed! As the user navigates across the app, the connections would keep piling up."
                },
                {
                    "type": "p",
                    "text": "Bugs like this are easy to miss without extensive manual testing. To help you spot them quickly, in development React remounts every component once immediately after its initial mount."
                },
                {
                    "type": "p",
                    "text": "Seeing the\"✅ Connecting...\"log twice helps you notice the real issue: your code doesn’t close the connection when the component unmounts."
                },
                {
                    "type": "p",
                    "text": "To fix the issue, return acleanup functionfrom your Effect:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{constconnection=createConnection();connection.connect();return()=>{connection.disconnect();};},[]);"
                },
                {
                    "type": "p",
                    "text": "React will call your cleanup function each time before the Effect runs again, and one final time when the component unmounts (gets removed). Let’s see what happens when the cleanup function is implemented:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection}from'./chat.js';exportdefaultfunctionChatRoom(){useEffect(()=>{constconnection=createConnection();connection.connect();return()=>connection.disconnect();},[]);return<h1>Welcome to the chat!</h1>;}"
                },
                {
                    "type": "p",
                    "text": "Now you get three console logs in development:"
                },
                {
                    "type": "list",
                    "items": [
                        "\"✅ Connecting...\"",
                        "\"❌ Disconnected.\"",
                        "\"✅ Connecting...\""
                    ]
                },
                {
                    "type": "p",
                    "text": "This is the correct behavior in development.By remounting your component, React verifies that navigating away and back would not break your code. Disconnecting and then connecting again is exactly what should happen! When you implement the cleanup well, there should be no user-visible difference between running the Effect once vs running it, cleaning it up, and running it again. There’s an extra connect/disconnect call pair because React is probing your code for bugs in development. This is normal—don’t try to make it go away!"
                },
                {
                    "type": "p",
                    "text": "In production, you would only see\"✅ Connecting...\"printed once.Remounting components only happens in development to help you find Effects that need cleanup. You can turn offStrict Modeto opt out of the development behavior, but we recommend keeping it on. This lets you find many bugs like the one above."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "How to handle the Effect firing twice in development?"
                },
                {
                    "type": "p",
                    "text": "React intentionally remounts your components in development to find bugs like in the last example.The right question isn’t “how to run an Effect once”, but “how to fix my Effect so that it works after remounting”."
                },
                {
                    "type": "p",
                    "text": "Usually, the answer is to implement the cleanup function.  The cleanup function should stop or undo whatever the Effect was doing. The rule of thumb is that the user shouldn’t be able to distinguish between the Effect running once (as in production) and asetup → cleanup → setupsequence (as you’d see in development)."
                },
                {
                    "type": "p",
                    "text": "Most of the Effects you’ll write will fit into one of the common patterns below."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Don’t use refs to prevent Effects from firing"
                },
                {
                    "type": "p",
                    "text": "A common pitfall for preventing Effects firing twice in development is to use arefto prevent the Effect from running more than once. For example, you could “fix” the above bug with auseRef:"
                },
                {
                    "type": "code",
                    "code": "constconnectionRef=useRef(null);useEffect(()=>{// 🚩 This wont fix the bug!!!if(!connectionRef.current){connectionRef.current=createConnection();connectionRef.current.connect();}},[]);"
                },
                {
                    "type": "p",
                    "text": "This makes it so you only see\"✅ Connecting...\"once in development, but it doesn’t fix the bug."
                },
                {
                    "type": "p",
                    "text": "When the user navigates away, the connection still isn’t closed and when they navigate back, a new connection is created. As the user navigates across the app, the connections would keep piling up, the same as it would before the “fix”."
                },
                {
                    "type": "p",
                    "text": "To fix the bug, it is not enough to just make the Effect run once. The effect needs to work after re-mounting, which means the connection needs to be cleaned up like in the solution above."
                },
                {
                    "type": "p",
                    "text": "See the examples below for how to handle common patterns."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Controlling non-React widgets"
                },
                {
                    "type": "p",
                    "text": "Sometimes you need to add UI widgets that aren’t written in React. For example, let’s say you’re adding a map component to your page. It has asetZoomLevel()method, and you’d like to keep the zoom level in sync with azoomLevelstate variable in your React code. Your Effect would look similar to this:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{constmap=mapRef.current;map.setZoomLevel(zoomLevel);},[zoomLevel]);"
                },
                {
                    "type": "p",
                    "text": "Note that there is no cleanup needed in this case. In development, React will call the Effect twice, but this is not a problem because callingsetZoomLeveltwice with the same value does not do anything. It may be slightly slower, but this doesn’t matter because it won’t remount needlessly in production."
                },
                {
                    "type": "p",
                    "text": "Some APIs may not allow you to call them twice in a row. For example, theshowModalmethod of the built-in<dialog>element throws if you call it twice. Implement the cleanup function and make it close the dialog:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{constdialog=dialogRef.current;dialog.showModal();return()=>dialog.close();},[]);"
                },
                {
                    "type": "p",
                    "text": "In development, your Effect will callshowModal(), then immediatelyclose(), and thenshowModal()again. This has the same user-visible behavior as callingshowModal()once, as you would see in production."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Subscribing to events"
                },
                {
                    "type": "p",
                    "text": "If your Effect subscribes to something, the cleanup function should unsubscribe:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{functionhandleScroll(e){console.log(window.scrollX,window.scrollY);}window.addEventListener('scroll',handleScroll);return()=>window.removeEventListener('scroll',handleScroll);},[]);"
                },
                {
                    "type": "p",
                    "text": "In development, your Effect will calladdEventListener(), then immediatelyremoveEventListener(), and thenaddEventListener()again with the same handler. So there would be only one active subscription at a time. This has the same user-visible behavior as callingaddEventListener()once, as in production."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Triggering animations"
                },
                {
                    "type": "p",
                    "text": "If your Effect animates something in, the cleanup function should reset the animation to the initial values:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{constnode=ref.current;node.style.opacity=1;// Trigger the animationreturn()=>{node.style.opacity=0;// Reset to the initial value};},[]);"
                },
                {
                    "type": "p",
                    "text": "In development, opacity will be set to1, then to0, and then to1again. This should have the same user-visible behavior as setting it to1directly, which is what would happen in production. If you use a third-party animation library with support for tweening, your cleanup function should reset the timeline to its initial state."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Fetching data"
                },
                {
                    "type": "p",
                    "text": "If your Effect fetches something, the cleanup function should eitherabort the fetchor ignore its result:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{letignore=false;asyncfunctionstartFetching(){constjson=awaitfetchTodos(userId);if(!ignore){setTodos(json);}}startFetching();return()=>{ignore=true;};},[userId]);"
                },
                {
                    "type": "p",
                    "text": "You can’t “undo” a network request that already happened, but your cleanup function should ensure that the fetch that’snot relevant anymoredoes not keep affecting your application. If theuserIdchanges from'Alice'to'Bob', cleanup ensures that the'Alice'response is ignored even if it arrives after'Bob'."
                },
                {
                    "type": "p",
                    "text": "In development, you will see two fetches in the Network tab.There is nothing wrong with that. With the approach above, the first Effect will immediately get cleaned up so its copy of theignorevariable will be set totrue. So even though there is an extra request, it won’t affect the state thanks to theif (!ignore)check."
                },
                {
                    "type": "p",
                    "text": "In production, there will only be one request.If the second request in development is bothering you, the best approach is to use a solution that deduplicates requests and caches their responses between components:"
                },
                {
                    "type": "code",
                    "code": "functionTodoList(){consttodos=useSomeDataLibrary(`/api/user/${userId}/todos`);// ..."
                },
                {
                    "type": "p",
                    "text": "This will not only improve the development experience, but also make your application feel faster. For example, the user pressing the Back button won’t have to wait for some data to load again because it will be cached. You can either build such a cache yourself or use one of the many alternatives to manual fetching in Effects."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "What are good alternatives to data fetching in Effects?"
                },
                {
                    "type": "p",
                    "text": "Writingfetchcalls inside Effects is apopular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:"
                },
                {
                    "type": "list",
                    "items": [
                        "Effects don’t run on the server.This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.",
                        "Fetching directly in Effects makes it easy to create “network waterfalls”.You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.",
                        "Fetching directly in Effects usually means you don’t preload or cache data.For example, if the component unmounts and then mounts again, it would have to fetch the data again.",
                        "It’s not very ergonomic.There’s quite a bit of boilerplate code involved when writingfetchcalls in a way that doesn’t suffer from bugs likerace conditions."
                    ]
                },
                {
                    "type": "p",
                    "text": "This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:"
                },
                {
                    "type": "list",
                    "items": [
                        "If you use aframework, use its built-in data fetching mechanism.Modern React frameworks have integrated data fetching mechanisms that are efficient and don’t suffer from the above pitfalls.",
                        "Otherwise, consider using or building a client-side cache.Popular open source solutions includeReact Query,useSWR, andReact Router 6.4+.You can build your own solution too, in which case you would use Effects under the hood, but add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes)."
                    ]
                },
                {
                    "type": "p",
                    "text": "You can continue fetching data directly in Effects if neither of these approaches suit you."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Sending analytics"
                },
                {
                    "type": "p",
                    "text": "Consider this code that sends an analytics event on the page visit:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{logVisit(url);// Sends a POST request},[url]);"
                },
                {
                    "type": "p",
                    "text": "In development,logVisitwill be called twice for every URL, so you might be tempted to try to fix that.We recommend keeping this code as is.Like with earlier examples, there is nouser-visiblebehavior difference between running it once and running it twice. From a practical point of view,logVisitshould not do anything in development because you don’t want the logs from the development machines to skew the production metrics. Your component remounts every time you save its file, so it logs extra visits in development anyway."
                },
                {
                    "type": "p",
                    "text": "In production, there will be no duplicate visit logs."
                },
                {
                    "type": "p",
                    "text": "To debug the analytics events you’re sending, you can deploy your app to a staging environment (which runs in production mode) or temporarily opt out ofStrict Modeand its development-only remounting checks. You may also send analytics from the route change event handlers instead of Effects. For more precise analytics,intersection observerscan help track which components are in the viewport and how long they remain visible."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Not an Effect: Initializing the application"
                },
                {
                    "type": "p",
                    "text": "Some logic should only run once when the application starts. You can put it outside your components:"
                },
                {
                    "type": "code",
                    "code": "if(typeofwindow!=='undefined'){// Check if we're running in the browser.checkAuthToken();loadDataFromLocalStorage();}functionApp(){// ...}"
                },
                {
                    "type": "p",
                    "text": "This guarantees that such logic only runs once after the browser loads the page."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Not an Effect: Buying a product"
                },
                {
                    "type": "p",
                    "text": "Sometimes, even if you write a cleanup function, there’s no way to prevent user-visible consequences of running the Effect twice. For example, maybe your Effect sends a POST request like buying a product:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{// 🔴 Wrong: This Effect fires twice in development, exposing a problem in the code.fetch('/api/buy',{method:'POST'});},[]);"
                },
                {
                    "type": "p",
                    "text": "You wouldn’t want to buy the product twice. However, this is also why you shouldn’t put this logic in an Effect. What if the user goes to another page and then presses Back? Your Effect would run again. You don’t want to buy the product when the uservisitsa page; you want to buy it when the userclicksthe Buy button."
                },
                {
                    "type": "p",
                    "text": "Buying is not caused by rendering; it’s caused by a specific interaction. It should run only when the user presses the button.Delete the Effect and move your/api/buyrequest into the Buy button event handler:"
                },
                {
                    "type": "code",
                    "code": "functionhandleClick(){// ✅ Buying is an event because it is caused by a particular interaction.fetch('/api/buy',{method:'POST'});}"
                },
                {
                    "type": "p",
                    "text": "This illustrates that if remounting breaks the logic of your application, this usually uncovers existing bugs.From a user’s perspective, visiting a page shouldn’t be different from visiting it, clicking a link, then pressing Back to view the page again. React verifies that your components abide by this principle by remounting them once in development."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Putting it all together"
                },
                {
                    "type": "p",
                    "text": "This playground can help you “get a feel” for how Effects work in practice."
                },
                {
                    "type": "p",
                    "text": "This example usessetTimeoutto schedule a console log with the input text to appear three seconds after the Effect runs. The cleanup function cancels the pending timeout. Start by pressing “Mount the component”:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';functionPlayground(){const[text,setText]=useState('a');useEffect(()=>{functiononTimeout(){console.log('⏰ '+text);}console.log('🔵 Schedule \"'+text+'\" log');consttimeoutId=setTimeout(onTimeout,3000);return()=>{console.log('🟡 Cancel \"'+text+'\" log');clearTimeout(timeoutId);};},[text]);return(<><label>What to log:{' '}<inputvalue={text}onChange={e=>setText(e.target.value)}/></label><h1>{text}</h1></>);}exportdefaultfunctionApp(){const[show,setShow]=useState(false);return(<><buttononClick={()=>setShow(!show)}>{show?'Unmount':'Mount'}the component</button>{show&&<hr/>}{show&&<Playground/>}</>);}"
                },
                {
                    "type": "p",
                    "text": "You will see three logs at first:Schedule \"a\" log,Cancel \"a\" log, andSchedule \"a\" logagain. Three second later there will also be a log sayinga. As you learned earlier, the extra schedule/cancel pair is because React remounts the component once in development to verify that you’ve implemented cleanup well."
                },
                {
                    "type": "p",
                    "text": "Now edit the input to sayabc. If you do it fast enough, you’ll seeSchedule \"ab\" logimmediately followed byCancel \"ab\" logandSchedule \"abc\" log.React always cleans up the previous render’s Effect before the next render’s Effect.This is why even if you type into the input fast, there is at most one timeout scheduled at a time. Edit the input a few times and watch the console to get a feel for how Effects get cleaned up."
                },
                {
                    "type": "p",
                    "text": "Type something into the input and then immediately press “Unmount the component”. Notice how unmounting cleans up the last render’s Effect. Here, it clears the last timeout before it has a chance to fire."
                },
                {
                    "type": "p",
                    "text": "Finally, edit the component above and comment out the cleanup function so that the timeouts don’t get cancelled. Try typingabcdefast. What do you expect to happen in three seconds? Willconsole.log(text)inside the timeout print thelatesttextand produce fiveabcdelogs? Give it a try to check your intuition!"
                },
                {
                    "type": "p",
                    "text": "Three seconds later, you should see a sequence of logs (a,ab,abc,abcd, andabcde) rather than fiveabcdelogs.Each Effect “captures” thetextvalue from its corresponding render.It doesn’t matter that thetextstate changed: an Effect from the render withtext = 'ab'will always see'ab'. In other words, Effects from each render are isolated from each other. If you’re curious how this works, you can read aboutclosures."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Each render has its own Effects"
                },
                {
                    "type": "p",
                    "text": "You can think ofuseEffectas “attaching” a piece of behavior to the render output. Consider this Effect:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionChatRoom({roomId}){useEffect(()=>{constconnection=createConnection(roomId);connection.connect();return()=>connection.disconnect();},[roomId]);return<h1>Welcome to{roomId}!</h1>;}"
                },
                {
                    "type": "p",
                    "text": "Let’s see what exactly happens as the user navigates around the app."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Initial render"
                },
                {
                    "type": "p",
                    "text": "The user visits<ChatRoom roomId=\"general\" />. Let’smentally substituteroomIdwith'general':"
                },
                {
                    "type": "code",
                    "code": "// JSX for the first render (roomId = \"general\")return<h1>Welcome to general!</h1>;"
                },
                {
                    "type": "p",
                    "text": "The Effect isalsoa part of the rendering output.The first render’s Effect becomes:"
                },
                {
                    "type": "code",
                    "code": "// Effect for the first render (roomId = \"general\")()=>{constconnection=createConnection('general');connection.connect();return()=>connection.disconnect();},// Dependencies for the first render (roomId = \"general\")['general']"
                },
                {
                    "type": "p",
                    "text": "React runs this Effect, which connects to the'general'chat room."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Re-render with same dependencies"
                },
                {
                    "type": "p",
                    "text": "Let’s say<ChatRoom roomId=\"general\" />re-renders. The JSX output is the same:"
                },
                {
                    "type": "code",
                    "code": "// JSX for the second render (roomId = \"general\")return<h1>Welcome to general!</h1>;"
                },
                {
                    "type": "p",
                    "text": "React sees that the rendering output has not changed, so it doesn’t update the DOM."
                },
                {
                    "type": "p",
                    "text": "The Effect from the second render looks like this:"
                },
                {
                    "type": "code",
                    "code": "// Effect for the second render (roomId = \"general\")()=>{constconnection=createConnection('general');connection.connect();return()=>connection.disconnect();},// Dependencies for the second render (roomId = \"general\")['general']"
                },
                {
                    "type": "p",
                    "text": "React compares['general']from the second render with['general']from the first render.Because all dependencies are the same, Reactignoresthe Effect from the second render.It never gets called."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Re-render with different dependencies"
                },
                {
                    "type": "p",
                    "text": "Then, the user visits<ChatRoom roomId=\"travel\" />. This time, the component returns different JSX:"
                },
                {
                    "type": "code",
                    "code": "// JSX for the third render (roomId = \"travel\")return<h1>Welcome to travel!</h1>;"
                },
                {
                    "type": "p",
                    "text": "React updates the DOM to change\"Welcome to general\"into\"Welcome to travel\"."
                },
                {
                    "type": "p",
                    "text": "The Effect from the third render looks like this:"
                },
                {
                    "type": "code",
                    "code": "// Effect for the third render (roomId = \"travel\")()=>{constconnection=createConnection('travel');connection.connect();return()=>connection.disconnect();},// Dependencies for the third render (roomId = \"travel\")['travel']"
                },
                {
                    "type": "p",
                    "text": "React compares['travel']from the third render with['general']from the second render. One dependency is different:Object.is('travel', 'general')isfalse. The Effect can’t be skipped."
                },
                {
                    "type": "p",
                    "text": "Before React can apply the Effect from the third render, it needs to clean up the last Effect thatdidrun.The second render’s Effect was skipped, so React needs to clean up the first render’s Effect. If you scroll up to the first render, you’ll see that its cleanup callsdisconnect()on the connection that was created withcreateConnection('general'). This disconnects the app from the'general'chat room."
                },
                {
                    "type": "p",
                    "text": "After that, React runs the third render’s Effect. It connects to the'travel'chat room."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Unmount"
                },
                {
                    "type": "p",
                    "text": "Finally, let’s say the user navigates away, and theChatRoomcomponent unmounts. React runs the last Effect’s cleanup function. The last Effect was from the third render. The third render’s cleanup destroys thecreateConnection('travel')connection. So the app disconnects from the'travel'room."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Development-only behaviors"
                },
                {
                    "type": "p",
                    "text": "WhenStrict Modeis on, React remounts every component once after mount (state and DOM are preserved). Thishelps you find Effects that need cleanupand exposes bugs like race conditions early. Additionally, React will remount the Effects whenever you save a file in development. Both of these behaviors are development-only."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "Unlike events, Effects are caused by rendering itself rather than a particular interaction.",
                        "Effects let you synchronize a component with some external system (third-party API, network, etc).",
                        "By default, Effects run after every render (including the initial one).",
                        "React will skip the Effect if all of its dependencies have the same values as during the last render.",
                        "You can’t “choose” your dependencies. They are determined by the code inside the Effect.",
                        "Empty dependency array ([]) corresponds to the component “mounting”, i.e. being added to the screen.",
                        "In Strict Mode, React mounts components twice (in development only!) to stress-test your Effects.",
                        "If your Effect breaks because of remounting, you need to implement a cleanup function.",
                        "React will call your cleanup function before the Effect runs next time, and during the unmount."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of4:Focus a field on mount"
                },
                {
                    "type": "p",
                    "text": "In this example, the form renders a<MyInput />component."
                },
                {
                    "type": "p",
                    "text": "Use the input’sfocus()method to makeMyInputautomatically focus when it appears on the screen. There is already a commented out implementation, but it doesn’t quite work. Figure out why it doesn’t work, and fix it. (If you’re familiar with theautoFocusattribute, pretend that it does not exist: we are reimplementing the same functionality from scratch.)"
                },
                {
                    "type": "code",
                    "code": "import{useEffect,useRef}from'react';exportdefaultfunctionMyInput({value,onChange}){constref=useRef(null);// TODO: This doesn't quite work. Fix it.// ref.current.focus()return(<inputref={ref}value={value}onChange={onChange}/>);}"
                },
                {
                    "type": "p",
                    "text": "To verify that your solution works, press “Show form” and verify that the input receives focus (becomes highlighted and the cursor is placed inside). Press “Hide form” and “Show form” again. Verify the input is highlighted again."
                },
                {
                    "type": "p",
                    "text": "MyInputshould only focuson mountrather than after every render. To verify that the behavior is right, press “Show form” and then repeatedly press the “Make it uppercase” checkbox. Clicking the checkbox shouldnotfocus the input above it."
                }
            ]
        },
        {
            "url": "https://react.dev/learn/thinking-in-react",
            "title": "Thinking in React – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Thinking in React"
                },
                {
                    "type": "p",
                    "text": "React can change how you think about the designs you look at and the apps you build. When you build a user interface with React, you will first break it apart into pieces calledcomponents. Then, you will describe the different visual states for each of your components. Finally, you will connect your components together so that the data flows through them. In this tutorial, we’ll guide you through the thought process of building a searchable product data table with React."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Start with the mockup"
                },
                {
                    "type": "p",
                    "text": "Imagine that you already have a JSON API and a mockup from a designer."
                },
                {
                    "type": "p",
                    "text": "The JSON API returns some data that looks like this:"
                },
                {
                    "type": "code",
                    "code": "[{category:\"Fruits\",price:\"$1\",stocked:true,name:\"Apple\"},{category:\"Fruits\",price:\"$1\",stocked:true,name:\"Dragonfruit\"},{category:\"Fruits\",price:\"$2\",stocked:false,name:\"Passionfruit\"},{category:\"Vegetables\",price:\"$2\",stocked:true,name:\"Spinach\"},{category:\"Vegetables\",price:\"$4\",stocked:false,name:\"Pumpkin\"},{category:\"Vegetables\",price:\"$1\",stocked:true,name:\"Peas\"}]"
                },
                {
                    "type": "p",
                    "text": "The mockup looks like this:"
                },
                {
                    "type": "p",
                    "text": "To implement a UI in React, you will usually follow the same five steps."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Step 1: Break the UI into a component hierarchy"
                },
                {
                    "type": "p",
                    "text": "Start by drawing boxes around every component and subcomponent in the mockup and naming them. If you work with a designer, they may have already named these components in their design tool. Ask them!"
                },
                {
                    "type": "p",
                    "text": "Depending on your background, you can think about splitting up a design into components in different ways:"
                },
                {
                    "type": "list",
                    "items": [
                        "Programming—use the same techniques for deciding if you should create a new function or object. One such technique is thesingle responsibility principle, that is, a component should ideally only do one thing. If it ends up growing, it should be decomposed into smaller subcomponents.",
                        "CSS—consider what you would make class selectors for. (However, components are a bit less granular.)",
                        "Design—consider how you would organize the design’s layers."
                    ]
                },
                {
                    "type": "p",
                    "text": "If your JSON is well-structured, you’ll often find that it naturally maps to the component structure of your UI. That’s because UI and data models often have the same information architecture—that is, the same shape. Separate your UI into components, where each component matches one piece of your data model."
                },
                {
                    "type": "p",
                    "text": "There are five components on this screen:"
                },
                {
                    "type": "list",
                    "items": [
                        "FilterableProductTable(grey) contains the entire app.",
                        "SearchBar(blue) receives the user input.",
                        "ProductTable(lavender) displays and filters the list according to the user input.",
                        "ProductCategoryRow(green) displays a heading for each category.",
                        "ProductRow(yellow) displays a row for each product."
                    ]
                },
                {
                    "type": "p",
                    "text": "If you look atProductTable(lavender), you’ll see that the table header (containing the “Name” and “Price” labels) isn’t its own component. This is a matter of preference, and you could go either way. For this example, it is a part ofProductTablebecause it appears inside theProductTable’s list. However, if this header grows to be complex (e.g., if you add sorting), you can move it into its ownProductTableHeadercomponent."
                },
                {
                    "type": "p",
                    "text": "Now that you’ve identified the components in the mockup, arrange them into a hierarchy. Components that appear within another component in the mockup should appear as a child in the hierarchy:"
                },
                {
                    "type": "list",
                    "items": [
                        "FilterableProductTableSearchBarProductTableProductCategoryRowProductRow",
                        "SearchBar",
                        "ProductTableProductCategoryRowProductRow",
                        "ProductCategoryRow",
                        "ProductRow"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "SearchBar",
                        "ProductTableProductCategoryRowProductRow",
                        "ProductCategoryRow",
                        "ProductRow"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "ProductCategoryRow",
                        "ProductRow"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Step 2: Build a static version in React"
                },
                {
                    "type": "p",
                    "text": "Now that you have your component hierarchy, it’s time to implement your app. The most straightforward approach is to build a version that renders the UI from your data model without adding any interactivity… yet! It’s often easier to build the static version first and add interactivity later. Building a static version requires a lot of typing and no thinking, but adding interactivity requires a lot of thinking and not a lot of typing."
                },
                {
                    "type": "p",
                    "text": "To build a static version of your app that renders your data model, you’ll want to buildcomponentsthat reuse other components and pass data usingprops.Props are a way of passing data from parent to child. (If you’re familiar with the concept ofstate, don’t use state at all to build this static version. State is reserved only for interactivity, that is, data that changes over time. Since this is a static version of the app, you don’t need it.)"
                },
                {
                    "type": "p",
                    "text": "You can either build “top down” by starting with building the components higher up in the hierarchy (likeFilterableProductTable) or “bottom up” by working from components lower down (likeProductRow). In simpler examples, it’s usually easier to go top-down, and on larger projects, it’s easier to go bottom-up."
                },
                {
                    "type": "code",
                    "code": "functionProductCategoryRow({category}){return(<tr><thcolSpan=\"2\">{category}</th></tr>);}functionProductRow({product}){constname=product.stocked?product.name:<spanstyle={{color:'red'}}>{product.name}</span>;return(<tr><td>{name}</td><td>{product.price}</td></tr>);}functionProductTable({products}){constrows=[];letlastCategory=null;products.forEach((product)=>{if(product.category!==lastCategory){rows.push(<ProductCategoryRowcategory={product.category}key={product.category}/>);}rows.push(<ProductRowproduct={product}key={product.name}/>);lastCategory=product.category;});return(<table><thead><tr><th>Name</th><th>Price</th></tr></thead><tbody>{rows}</tbody></table>);}functionSearchBar(){return(<form><inputtype=\"text\"placeholder=\"Search...\"/><label><inputtype=\"checkbox\"/>{' '}Only show products in stock</label></form>);}functionFilterableProductTable({products}){return(<div><SearchBar/><ProductTableproducts={products}/></div>);}constPRODUCTS=[{category:\"Fruits\",price:\"$1\",stocked:true,name:\"Apple\"},{category:\"Fruits\",price:\"$1\",stocked:true,name:\"Dragonfruit\"},{category:\"Fruits\",price:\"$2\",stocked:false,name:\"Passionfruit\"},{category:\"Vegetables\",price:\"$2\",stocked:true,name:\"Spinach\"},{category:\"Vegetables\",price:\"$4\",stocked:false,name:\"Pumpkin\"},{category:\"Vegetables\",price:\"$1\",stocked:true,name:\"Peas\"}];exportdefaultfunctionApp(){return<FilterableProductTableproducts={PRODUCTS}/>;}"
                },
                {
                    "type": "p",
                    "text": "(If this code looks intimidating, go through theQuick Startfirst!)"
                },
                {
                    "type": "p",
                    "text": "After building your components, you’ll have a library of reusable components that render your data model. Because this is a static app, the components will only return JSX. The component at the top of the hierarchy (FilterableProductTable) will take your data model as a prop. This is calledone-way data flowbecause the data flows down from the top-level component to the ones at the bottom of the tree."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "At this point, you should not be using any state values. That’s for the next step!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Step 3: Find the minimal but complete representation of UI state"
                },
                {
                    "type": "p",
                    "text": "To make the UI interactive, you need to let users change your underlying data model. You will usestatefor this."
                },
                {
                    "type": "p",
                    "text": "Think of state as the minimal set of changing data that your app needs to remember. The most important principle for structuring state is to keep itDRY (Don’t Repeat Yourself).Figure out the absolute minimal representation of the state your application needs and compute everything else on-demand. For example, if you’re building a shopping list, you can store the items as an array in state. If you want to also display the number of items in the list, don’t store the number of items as another state value—instead, read the length of your array."
                },
                {
                    "type": "p",
                    "text": "Now think of all of the pieces of data in this example application:"
                },
                {
                    "type": "list",
                    "items": [
                        "The original list of products",
                        "The search text the user has entered",
                        "The value of the checkbox",
                        "The filtered list of products"
                    ]
                },
                {
                    "type": "p",
                    "text": "Which of these are state? Identify the ones that are not:"
                },
                {
                    "type": "list",
                    "items": [
                        "Does itremain unchangedover time? If so, it isn’t state.",
                        "Is itpassed in from a parentvia props? If so, it isn’t state.",
                        "Can you compute itbased on existing state or props in your component? If so, itdefinitelyisn’t state!"
                    ]
                },
                {
                    "type": "p",
                    "text": "What’s left is probably state."
                },
                {
                    "type": "p",
                    "text": "Let’s go through them one by one again:"
                },
                {
                    "type": "list",
                    "items": [
                        "The original list of products ispassed in as props, so it’s not state.",
                        "The search text seems to be state since it changes over time and can’t be computed from anything.",
                        "The value of the checkbox seems to be state since it changes over time and can’t be computed from anything.",
                        "The filtered list of productsisn’t state because it can be computedby taking the original list of products and filtering it according to the search text and value of the checkbox."
                    ]
                },
                {
                    "type": "p",
                    "text": "This means only the search text and the value of the checkbox are state! Nicely done!"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Props vs State"
                },
                {
                    "type": "p",
                    "text": "There are two types of “model” data in React: props and state. The two are very different:"
                },
                {
                    "type": "list",
                    "items": [
                        "Propsare like arguments you passto a function. They let a parent component pass data to a child component and customize its appearance. For example, aFormcan pass acolorprop to aButton.",
                        "Stateis like a component’s memory.It lets a component keep track of some information and change it in response to interactions. For example, aButtonmight keep track ofisHoveredstate."
                    ]
                },
                {
                    "type": "p",
                    "text": "Props and state are different, but they work together. A parent component will often keep some information in state (so that it can change it), andpass it downto child components as their props. It’s okay if the difference still feels fuzzy on the first read. It takes a bit of practice for it to really stick!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Step 4: Identify where your state should live"
                },
                {
                    "type": "p",
                    "text": "After identifying your app’s minimal state data, you need to identify which component is responsible for changing this state, orownsthe state. Remember: React uses one-way data flow, passing data down the component hierarchy from parent to child component. It may not be immediately clear which component should own what state. This can be challenging if you’re new to this concept, but you can figure it out by following these steps!"
                },
                {
                    "type": "p",
                    "text": "For each piece of state in your application:"
                },
                {
                    "type": "list",
                    "items": [
                        "Identifyeverycomponent that renders something based on that state.",
                        "Find their closest common parent component—a component above them all in the hierarchy.",
                        "Decide where the state should live:Often, you can put the state directly into their common parent.You can also put the state into some component above their common parent.If you can’t find a component where it makes sense to own the state, create a new component solely for holding the state and add it somewhere in the hierarchy above the common parent component.",
                        "Often, you can put the state directly into their common parent.",
                        "You can also put the state into some component above their common parent.",
                        "If you can’t find a component where it makes sense to own the state, create a new component solely for holding the state and add it somewhere in the hierarchy above the common parent component."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Often, you can put the state directly into their common parent.",
                        "You can also put the state into some component above their common parent.",
                        "If you can’t find a component where it makes sense to own the state, create a new component solely for holding the state and add it somewhere in the hierarchy above the common parent component."
                    ]
                },
                {
                    "type": "p",
                    "text": "In the previous step, you found two pieces of state in this application: the search input text, and the value of the checkbox. In this example, they always appear together, so it makes sense to put them into the same place."
                },
                {
                    "type": "p",
                    "text": "Now let’s run through our strategy for them:"
                },
                {
                    "type": "list",
                    "items": [
                        "Identify components that use state:ProductTableneeds to filter the product list based on that state (search text and checkbox value).SearchBarneeds to display that state (search text and checkbox value).",
                        "ProductTableneeds to filter the product list based on that state (search text and checkbox value).",
                        "SearchBarneeds to display that state (search text and checkbox value).",
                        "Find their common parent:The first parent component both components share isFilterableProductTable.",
                        "Decide where the state lives: We’ll keep the filter text and checked state values inFilterableProductTable."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "ProductTableneeds to filter the product list based on that state (search text and checkbox value).",
                        "SearchBarneeds to display that state (search text and checkbox value)."
                    ]
                },
                {
                    "type": "p",
                    "text": "So the state values will live inFilterableProductTable."
                },
                {
                    "type": "p",
                    "text": "Add state to the component with theuseState()Hook.Hooks are special functions that let you “hook into” React. Add two state variables at the top ofFilterableProductTableand specify their initial state:"
                },
                {
                    "type": "code",
                    "code": "functionFilterableProductTable({products}){const[filterText,setFilterText]=useState('');const[inStockOnly,setInStockOnly]=useState(false);"
                },
                {
                    "type": "p",
                    "text": "Then, passfilterTextandinStockOnlytoProductTableandSearchBaras props:"
                },
                {
                    "type": "code",
                    "code": "<div><SearchBarfilterText={filterText}inStockOnly={inStockOnly}/><ProductTableproducts={products}filterText={filterText}inStockOnly={inStockOnly}/></div>"
                },
                {
                    "type": "p",
                    "text": "You can start seeing how your application will behave. Edit thefilterTextinitial value fromuseState('')touseState('fruit')in the sandbox code below. You’ll see both the search input text and the table update:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';functionFilterableProductTable({products}){const[filterText,setFilterText]=useState('');const[inStockOnly,setInStockOnly]=useState(false);return(<div><SearchBarfilterText={filterText}inStockOnly={inStockOnly}/><ProductTableproducts={products}filterText={filterText}inStockOnly={inStockOnly}/></div>);}functionProductCategoryRow({category}){return(<tr><thcolSpan=\"2\">{category}</th></tr>);}functionProductRow({product}){constname=product.stocked?product.name:<spanstyle={{color:'red'}}>{product.name}</span>;return(<tr><td>{name}</td><td>{product.price}</td></tr>);}functionProductTable({products,filterText,inStockOnly}){constrows=[];letlastCategory=null;products.forEach((product)=>{if(product.name.toLowerCase().indexOf(filterText.toLowerCase())=== -1){return;}if(inStockOnly&& !product.stocked){return;}if(product.category!==lastCategory){rows.push(<ProductCategoryRowcategory={product.category}key={product.category}/>);}rows.push(<ProductRowproduct={product}key={product.name}/>);lastCategory=product.category;});return(<table><thead><tr><th>Name</th><th>Price</th></tr></thead><tbody>{rows}</tbody></table>);}functionSearchBar({filterText,inStockOnly}){return(<form><inputtype=\"text\"value={filterText}placeholder=\"Search...\"/><label><inputtype=\"checkbox\"checked={inStockOnly}/>{' '}Only show products in stock</label></form>);}constPRODUCTS=[{category:\"Fruits\",price:\"$1\",stocked:true,name:\"Apple\"},{category:\"Fruits\",price:\"$1\",stocked:true,name:\"Dragonfruit\"},{category:\"Fruits\",price:\"$2\",stocked:false,name:\"Passionfruit\"},{category:\"Vegetables\",price:\"$2\",stocked:true,name:\"Spinach\"},{category:\"Vegetables\",price:\"$4\",stocked:false,name:\"Pumpkin\"},{category:\"Vegetables\",price:\"$1\",stocked:true,name:\"Peas\"}];exportdefaultfunctionApp(){return<FilterableProductTableproducts={PRODUCTS}/>;}"
                },
                {
                    "type": "p",
                    "text": "Notice that editing the form doesn’t work yet. There is a console error in the sandbox above explaining why:"
                },
                {
                    "type": "p",
                    "text": "In the sandbox above,ProductTableandSearchBarread thefilterTextandinStockOnlyprops to render the table, the input, and the checkbox. For example, here is howSearchBarpopulates the input value:"
                },
                {
                    "type": "code",
                    "code": "functionSearchBar({filterText,inStockOnly}){return(<form><inputtype=\"text\"value={filterText}placeholder=\"Search...\"/>"
                },
                {
                    "type": "p",
                    "text": "However, you haven’t added any code to respond to the user actions like typing yet. This will be your final step."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Step 5: Add inverse data flow"
                },
                {
                    "type": "p",
                    "text": "Currently your app renders correctly with props and state flowing down the hierarchy. But to change the state according to user input, you will need to support data flowing the other way: the form components deep in the hierarchy need to update the state inFilterableProductTable."
                },
                {
                    "type": "p",
                    "text": "React makes this data flow explicit, but it requires a little more typing than two-way data binding. If you try to type or check the box in the example above, you’ll see that React ignores your input. This is intentional. By writing<input value={filterText} />, you’ve set thevalueprop of theinputto always be equal to thefilterTextstate passed in fromFilterableProductTable. SincefilterTextstate is never set, the input never changes."
                },
                {
                    "type": "p",
                    "text": "You want to make it so whenever the user changes the form inputs, the state updates to reflect those changes. The state is owned byFilterableProductTable, so only it can callsetFilterTextandsetInStockOnly. To letSearchBarupdate theFilterableProductTable’s state, you need to pass these functions down toSearchBar:"
                },
                {
                    "type": "code",
                    "code": "functionFilterableProductTable({products}){const[filterText,setFilterText]=useState('');const[inStockOnly,setInStockOnly]=useState(false);return(<div><SearchBarfilterText={filterText}inStockOnly={inStockOnly}onFilterTextChange={setFilterText}onInStockOnlyChange={setInStockOnly}/>"
                },
                {
                    "type": "p",
                    "text": "Inside theSearchBar, you will add theonChangeevent handlers and set the parent state from them:"
                },
                {
                    "type": "code",
                    "code": "functionSearchBar({filterText,inStockOnly,onFilterTextChange,onInStockOnlyChange}){return(<form><inputtype=\"text\"value={filterText}placeholder=\"Search...\"onChange={(e)=>onFilterTextChange(e.target.value)}/><label><inputtype=\"checkbox\"checked={inStockOnly}onChange={(e)=>onInStockOnlyChange(e.target.checked)}"
                },
                {
                    "type": "p",
                    "text": "Now the application fully works!"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';functionFilterableProductTable({products}){const[filterText,setFilterText]=useState('');const[inStockOnly,setInStockOnly]=useState(false);return(<div><SearchBarfilterText={filterText}inStockOnly={inStockOnly}onFilterTextChange={setFilterText}onInStockOnlyChange={setInStockOnly}/><ProductTableproducts={products}filterText={filterText}inStockOnly={inStockOnly}/></div>);}functionProductCategoryRow({category}){return(<tr><thcolSpan=\"2\">{category}</th></tr>);}functionProductRow({product}){constname=product.stocked?product.name:<spanstyle={{color:'red'}}>{product.name}</span>;return(<tr><td>{name}</td><td>{product.price}</td></tr>);}functionProductTable({products,filterText,inStockOnly}){constrows=[];letlastCategory=null;products.forEach((product)=>{if(product.name.toLowerCase().indexOf(filterText.toLowerCase())=== -1){return;}if(inStockOnly&& !product.stocked){return;}if(product.category!==lastCategory){rows.push(<ProductCategoryRowcategory={product.category}key={product.category}/>);}rows.push(<ProductRowproduct={product}key={product.name}/>);lastCategory=product.category;});return(<table><thead><tr><th>Name</th><th>Price</th></tr></thead><tbody>{rows}</tbody></table>);}functionSearchBar({filterText,inStockOnly,onFilterTextChange,onInStockOnlyChange}){return(<form><inputtype=\"text\"value={filterText}placeholder=\"Search...\"onChange={(e)=>onFilterTextChange(e.target.value)}/><label><inputtype=\"checkbox\"checked={inStockOnly}onChange={(e)=>onInStockOnlyChange(e.target.checked)}/>{' '}Only show products in stock</label></form>);}constPRODUCTS=[{category:\"Fruits\",price:\"$1\",stocked:true,name:\"Apple\"},{category:\"Fruits\",price:\"$1\",stocked:true,name:\"Dragonfruit\"},{category:\"Fruits\",price:\"$2\",stocked:false,name:\"Passionfruit\"},{category:\"Vegetables\",price:\"$2\",stocked:true,name:\"Spinach\"},{category:\"Vegetables\",price:\"$4\",stocked:false,name:\"Pumpkin\"},{category:\"Vegetables\",price:\"$1\",stocked:true,name:\"Peas\"}];exportdefaultfunctionApp(){return<FilterableProductTableproducts={PRODUCTS}/>;}"
                },
                {
                    "type": "p",
                    "text": "You can learn all about handling events and updating state in theAdding Interactivitysection."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Where to go from here"
                },
                {
                    "type": "p",
                    "text": "This was a very brief introduction to how to think about building components and applications with React. You canstart a React projectright now ordive deeper on all the syntaxused in this tutorial."
                }
            ]
        },
        {
            "url": "https://react.dev/learn/tutorial-tic-tac-toe",
            "title": "Tutorial: Tic-Tac-Toe – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Tutorial: Tic-Tac-Toe"
                },
                {
                    "type": "p",
                    "text": "You will build a small tic-tac-toe game during this tutorial. This tutorial does not assume any existing React knowledge. The techniques you’ll learn in the tutorial are fundamental to building any React app, and fully understanding it will give you a deep understanding of React."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "This tutorial is designed for people who prefer tolearn by doingand want to quickly try making something tangible. If you prefer learning each concept step by step, start withDescribing the UI."
                },
                {
                    "type": "p",
                    "text": "The tutorial is divided into several sections:"
                },
                {
                    "type": "list",
                    "items": [
                        "Setup for the tutorialwill give youa starting pointto follow the tutorial.",
                        "Overviewwill teach youthe fundamentalsof React: components, props, and state.",
                        "Completing the gamewill teach youthe most common techniquesin React development.",
                        "Adding time travelwill give youa deeper insightinto the unique strengths of React."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "What are you building?"
                },
                {
                    "type": "p",
                    "text": "In this tutorial, you’ll build an interactive tic-tac-toe game with React."
                },
                {
                    "type": "p",
                    "text": "You can see what it will look like when you’re finished here:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';functionSquare({value,onSquareClick}){return(<buttonclassName=\"square\"onClick={onSquareClick}>{value}</button>);}functionBoard({xIsNext,squares,onPlay}){functionhandleClick(i){if(calculateWinner(squares)||squares[i]){return;}constnextSquares=squares.slice();if(xIsNext){nextSquares[i]='X';}else{nextSquares[i]='O';}onPlay(nextSquares);}constwinner=calculateWinner(squares);letstatus;if(winner){status='Winner: '+winner;}else{status='Next player: '+(xIsNext?'X':'O');}return(<><divclassName=\"status\">{status}</div><divclassName=\"board-row\"><Squarevalue={squares[0]}onSquareClick={()=>handleClick(0)}/><Squarevalue={squares[1]}onSquareClick={()=>handleClick(1)}/><Squarevalue={squares[2]}onSquareClick={()=>handleClick(2)}/></div><divclassName=\"board-row\"><Squarevalue={squares[3]}onSquareClick={()=>handleClick(3)}/><Squarevalue={squares[4]}onSquareClick={()=>handleClick(4)}/><Squarevalue={squares[5]}onSquareClick={()=>handleClick(5)}/></div><divclassName=\"board-row\"><Squarevalue={squares[6]}onSquareClick={()=>handleClick(6)}/><Squarevalue={squares[7]}onSquareClick={()=>handleClick(7)}/><Squarevalue={squares[8]}onSquareClick={()=>handleClick(8)}/></div></>);}exportdefaultfunctionGame(){const[history,setHistory]=useState([Array(9).fill(null)]);const[currentMove,setCurrentMove]=useState(0);constxIsNext=currentMove%2===0;constcurrentSquares=history[currentMove];functionhandlePlay(nextSquares){constnextHistory=[...history.slice(0,currentMove+1),nextSquares];setHistory(nextHistory);setCurrentMove(nextHistory.length-1);}functionjumpTo(nextMove){setCurrentMove(nextMove);}constmoves=history.map((squares,move)=>{letdescription;if(move>0){description='Go to move #'+move;}else{description='Go to game start';}return(<likey={move}><buttononClick={()=>jumpTo(move)}>{description}</button></li>);});return(<divclassName=\"game\"><divclassName=\"game-board\"><BoardxIsNext={xIsNext}squares={currentSquares}onPlay={handlePlay}/></div><divclassName=\"game-info\"><ol>{moves}</ol></div></div>);}functioncalculateWinner(squares){constlines=[[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6],];for(leti=0;i<lines.length;i++){const[a,b,c]=lines[i];if(squares[a]&&squares[a]===squares[b]&&squares[a]===squares[c]){returnsquares[a];}}returnnull;}"
                },
                {
                    "type": "p",
                    "text": "If the code doesn’t make sense to you yet, or if you are unfamiliar with the code’s syntax, don’t worry! The goal of this tutorial is to help you understand React and its syntax."
                },
                {
                    "type": "p",
                    "text": "We recommend that you check out the tic-tac-toe game above before continuing with the tutorial. One of the features that you’ll notice is that there is a numbered list to the right of the game’s board. This list gives you a history of all of the moves that have occurred in the game, and it is updated as the game progresses."
                },
                {
                    "type": "p",
                    "text": "Once you’ve played around with the finished tic-tac-toe game, keep scrolling. You’ll start with a simpler template in this tutorial. Our next step is to set you up so that you can start building the game."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Setup for the tutorial"
                },
                {
                    "type": "p",
                    "text": "In the live code editor below, clickForkin the top-right corner to open the editor in a new tab using the website CodeSandbox. CodeSandbox lets you write code in your browser and preview how your users will see the app you’ve created. The new tab should display an empty square and the starter code for this tutorial."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionSquare(){return<buttonclassName=\"square\">X</button>;}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "You can also follow this tutorial using your local development environment. To do this, you need to:"
                },
                {
                    "type": "list",
                    "items": [
                        "InstallNode.js",
                        "In the CodeSandbox tab you opened earlier, press the top-left corner button to open the menu, and then chooseDownload Sandboxin that menu to download an archive of the files locally",
                        "Unzip the archive, then open a terminal andcdto the directory you unzipped",
                        "Install the dependencies withnpm install",
                        "Runnpm startto start a local server and follow the prompts to view the code running in a browser"
                    ]
                },
                {
                    "type": "p",
                    "text": "If you get stuck, don’t let this stop you! Follow along online instead and try a local setup again later."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Overview"
                },
                {
                    "type": "p",
                    "text": "Now that you’re set up, let’s get an overview of React!"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Inspecting the starter code"
                },
                {
                    "type": "p",
                    "text": "In CodeSandbox you’ll see three main sections:"
                },
                {
                    "type": "list",
                    "items": [
                        "TheFilessection with a list of files likeApp.js,index.js,styles.cssand a folder calledpublic",
                        "Thecode editorwhere you’ll see the source code of your selected file",
                        "Thebrowsersection where you’ll see how the code you’ve written will be displayed"
                    ]
                },
                {
                    "type": "p",
                    "text": "TheApp.jsfile should be selected in theFilessection. The contents of that file in thecode editorshould be:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionSquare(){return<buttonclassName=\"square\">X</button>;}"
                },
                {
                    "type": "p",
                    "text": "Thebrowsersection should be displaying a square with a X in it like this:"
                },
                {
                    "type": "p",
                    "text": "Now let’s have a look at the files in the starter code."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "App.js"
                },
                {
                    "type": "p",
                    "text": "The code inApp.jscreates acomponent. In React, a component is a piece of reusable code that represents a part of a user interface. Components are used to render, manage, and update the UI elements in your application. Let’s look at the component line by line to see what’s going on:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionSquare(){return<buttonclassName=\"square\">X</button>;}"
                },
                {
                    "type": "p",
                    "text": "The first line defines a function calledSquare. TheexportJavaScript keyword makes this function accessible outside of this file. Thedefaultkeyword tells other files using your code that it’s the main function in your file."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionSquare(){return<buttonclassName=\"square\">X</button>;}"
                },
                {
                    "type": "p",
                    "text": "The second line returns a button. ThereturnJavaScript keyword means whatever comes after is returned as a value to the caller of the function.<button>is aJSX element. A JSX element is a combination of JavaScript code and HTML tags that describes what you’d like to display.className=\"square\"is a button property orpropthat tells CSS how to style the button.Xis the text displayed inside of the button and</button>closes the JSX element to indicate that any following content shouldn’t be placed inside the button."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "styles.css"
                },
                {
                    "type": "p",
                    "text": "Click on the file labeledstyles.cssin theFilessection of CodeSandbox. This file defines the styles for your React app. The first twoCSS selectors(*andbody) define the style of large parts of your app while the.squareselector defines the style of any component where theclassNameproperty is set tosquare. In your code, that would match the button from your Square component in theApp.jsfile."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "index.js"
                },
                {
                    "type": "p",
                    "text": "Click on the file labeledindex.jsin theFilessection of CodeSandbox. You won’t be editing this file during the tutorial but it is the bridge between the component you created in theApp.jsfile and the web browser."
                },
                {
                    "type": "code",
                    "code": "import{StrictMode}from'react';import{createRoot}from'react-dom/client';import'./styles.css';importAppfrom'./App';"
                },
                {
                    "type": "p",
                    "text": "Lines 1-5 bring all the necessary pieces together:"
                },
                {
                    "type": "list",
                    "items": [
                        "React",
                        "React’s library to talk to web browsers (React DOM)",
                        "the styles for your components",
                        "the component you created inApp.js."
                    ]
                },
                {
                    "type": "p",
                    "text": "The remainder of the file brings all the pieces together and injects the final product intoindex.htmlin thepublicfolder."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Building the board"
                },
                {
                    "type": "p",
                    "text": "Let’s get back toApp.js. This is where you’ll spend the rest of the tutorial."
                },
                {
                    "type": "p",
                    "text": "Currently the board is only a single square, but you need nine! If you just try and copy paste your square to make two squares like this:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionSquare(){return<buttonclassName=\"square\">X</button><buttonclassName=\"square\">X</button>;}"
                },
                {
                    "type": "p",
                    "text": "You’ll get this error:"
                },
                {
                    "type": "p",
                    "text": "React components need to return a single JSX element and not multiple adjacent JSX elements like two buttons. To fix this you can useFragments(<>and</>) to wrap multiple adjacent JSX elements like this:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionSquare(){return(<><buttonclassName=\"square\">X</button><buttonclassName=\"square\">X</button></>);}"
                },
                {
                    "type": "p",
                    "text": "Now you should see:"
                },
                {
                    "type": "p",
                    "text": "Great! Now you just need to copy-paste a few times to add nine squares and…"
                },
                {
                    "type": "p",
                    "text": "Oh no! The squares are all in a single line, not in a grid like you need for our board. To fix this you’ll need to group your squares into rows withdivs and add some CSS classes. While you’re at it, you’ll give each square a number to make sure you know where each square is displayed."
                },
                {
                    "type": "p",
                    "text": "In theApp.jsfile, update theSquarecomponent to look like this:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionSquare(){return(<><divclassName=\"board-row\"><buttonclassName=\"square\">1</button><buttonclassName=\"square\">2</button><buttonclassName=\"square\">3</button></div><divclassName=\"board-row\"><buttonclassName=\"square\">4</button><buttonclassName=\"square\">5</button><buttonclassName=\"square\">6</button></div><divclassName=\"board-row\"><buttonclassName=\"square\">7</button><buttonclassName=\"square\">8</button><buttonclassName=\"square\">9</button></div></>);}"
                },
                {
                    "type": "p",
                    "text": "The CSS defined instyles.cssstyles the divs with theclassNameofboard-row. Now that you’ve grouped your components into rows with the styleddivs you have your tic-tac-toe board:"
                },
                {
                    "type": "p",
                    "text": "But you now have a problem. Your component namedSquare, really isn’t a square anymore. Let’s fix that by changing the name toBoard:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionBoard(){//...}"
                },
                {
                    "type": "p",
                    "text": "At this point your code should look something like this:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionBoard(){return(<><divclassName=\"board-row\"><buttonclassName=\"square\">1</button><buttonclassName=\"square\">2</button><buttonclassName=\"square\">3</button></div><divclassName=\"board-row\"><buttonclassName=\"square\">4</button><buttonclassName=\"square\">5</button><buttonclassName=\"square\">6</button></div><divclassName=\"board-row\"><buttonclassName=\"square\">7</button><buttonclassName=\"square\">8</button><buttonclassName=\"square\">9</button></div></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Psssst… That’s a lot to type! It’s okay to copy and paste code from this page. However, if you’re up for a little challenge, we recommend only copying code that you’ve manually typed at least once yourself."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Passing data through props"
                },
                {
                    "type": "p",
                    "text": "Next, you’ll want to change the value of a square from empty to “X” when the user clicks on the square. With how you’ve built the board so far you would need to copy-paste the code that updates the square nine times (once for each square you have)! Instead of copy-pasting, React’s component architecture allows you to create a reusable component to avoid messy, duplicated code."
                },
                {
                    "type": "p",
                    "text": "First, you are going to copy the line defining your first square (<button className=\"square\">1</button>) from yourBoardcomponent into a newSquarecomponent:"
                },
                {
                    "type": "code",
                    "code": "functionSquare(){return<buttonclassName=\"square\">1</button>;}exportdefaultfunctionBoard(){// ...}"
                },
                {
                    "type": "p",
                    "text": "Then you’ll update the Board component to render thatSquarecomponent using JSX syntax:"
                },
                {
                    "type": "code",
                    "code": "// ...exportdefaultfunctionBoard(){return(<><divclassName=\"board-row\"><Square/><Square/><Square/></div><divclassName=\"board-row\"><Square/><Square/><Square/></div><divclassName=\"board-row\"><Square/><Square/><Square/></div></>);}"
                },
                {
                    "type": "p",
                    "text": "Note how unlike the browserdivs, your own componentsBoardandSquaremust start with a capital letter."
                },
                {
                    "type": "p",
                    "text": "Let’s take a look:"
                },
                {
                    "type": "p",
                    "text": "Oh no! You lost the numbered squares you had before. Now each square says “1”. To fix this, you will usepropsto pass the value each square should have from the parent component (Board) to its child (Square)."
                },
                {
                    "type": "p",
                    "text": "Update theSquarecomponent to read thevalueprop that you’ll pass from theBoard:"
                },
                {
                    "type": "code",
                    "code": "functionSquare({value}){return<buttonclassName=\"square\">1</button>;}"
                },
                {
                    "type": "p",
                    "text": "function Square({ value })indicates the Square component can be passed a prop calledvalue."
                },
                {
                    "type": "p",
                    "text": "Now you want to display thatvalueinstead of1inside every square. Try doing it like this:"
                },
                {
                    "type": "code",
                    "code": "functionSquare({value}){return<buttonclassName=\"square\">value</button>;}"
                },
                {
                    "type": "p",
                    "text": "Oops, this is not what you wanted:"
                },
                {
                    "type": "p",
                    "text": "You wanted to render the JavaScript variable calledvaluefrom your component, not the word “value”. To “escape into JavaScript” from JSX, you need curly braces. Add curly braces aroundvaluein JSX like so:"
                },
                {
                    "type": "code",
                    "code": "functionSquare({value}){return<buttonclassName=\"square\">{value}</button>;}"
                },
                {
                    "type": "p",
                    "text": "For now, you should see an empty board:"
                },
                {
                    "type": "p",
                    "text": "This is because theBoardcomponent hasn’t passed thevalueprop to eachSquarecomponent it renders yet. To fix it you’ll add thevalueprop to eachSquarecomponent rendered by theBoardcomponent:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionBoard(){return(<><divclassName=\"board-row\"><Squarevalue=\"1\"/><Squarevalue=\"2\"/><Squarevalue=\"3\"/></div><divclassName=\"board-row\"><Squarevalue=\"4\"/><Squarevalue=\"5\"/><Squarevalue=\"6\"/></div><divclassName=\"board-row\"><Squarevalue=\"7\"/><Squarevalue=\"8\"/><Squarevalue=\"9\"/></div></>);}"
                },
                {
                    "type": "p",
                    "text": "Now you should see a grid of numbers again:"
                },
                {
                    "type": "p",
                    "text": "Your updated code should look like this:"
                },
                {
                    "type": "code",
                    "code": "functionSquare({value}){return<buttonclassName=\"square\">{value}</button>;}exportdefaultfunctionBoard(){return(<><divclassName=\"board-row\"><Squarevalue=\"1\"/><Squarevalue=\"2\"/><Squarevalue=\"3\"/></div><divclassName=\"board-row\"><Squarevalue=\"4\"/><Squarevalue=\"5\"/><Squarevalue=\"6\"/></div><divclassName=\"board-row\"><Squarevalue=\"7\"/><Squarevalue=\"8\"/><Squarevalue=\"9\"/></div></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Making an interactive component"
                },
                {
                    "type": "p",
                    "text": "Let’s fill theSquarecomponent with anXwhen you click it. Declare a function calledhandleClickinside of theSquare. Then, addonClickto the props of the button JSX element returned from theSquare:"
                },
                {
                    "type": "code",
                    "code": "functionSquare({value}){functionhandleClick(){console.log('clicked!');}return(<buttonclassName=\"square\"onClick={handleClick}>{value}</button>);}"
                },
                {
                    "type": "p",
                    "text": "If you click on a square now, you should see a log saying\"clicked!\"in theConsoletab at the bottom of theBrowsersection in CodeSandbox. Clicking the square more than once will log\"clicked!\"again. Repeated console logs with the same message will not create more lines in the console. Instead, you will see an incrementing counter next to your first\"clicked!\"log."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "If you are following this tutorial using your local development environment, you need to open your browser’s Console. For example, if you use the Chrome browser, you can view the Console with the keyboard shortcutShift + Ctrl + J(on Windows/Linux) orOption + ⌘ + J(on macOS)."
                },
                {
                    "type": "p",
                    "text": "As a next step, you want the Square component to “remember” that it got clicked, and fill it with an “X” mark. To “remember” things, components usestate."
                },
                {
                    "type": "p",
                    "text": "React provides a special function calleduseStatethat you can call from your component to let it “remember” things. Let’s store the current value of theSquarein state, and change it when theSquareis clicked."
                },
                {
                    "type": "p",
                    "text": "ImportuseStateat the top of the file. Remove thevalueprop from theSquarecomponent. Instead, add a new line at the start of theSquarethat callsuseState. Have it return a state variable calledvalue:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';functionSquare(){const[value,setValue]=useState(null);functionhandleClick(){//..."
                },
                {
                    "type": "p",
                    "text": "valuestores the value andsetValueis a function that can be used to change the value. Thenullpassed touseStateis used as the initial value for this state variable, sovaluehere starts off equal tonull."
                },
                {
                    "type": "p",
                    "text": "Since theSquarecomponent no longer accepts props anymore, you’ll remove thevalueprop from all nine of the Square components created by the Board component:"
                },
                {
                    "type": "code",
                    "code": "// ...exportdefaultfunctionBoard(){return(<><divclassName=\"board-row\"><Square/><Square/><Square/></div><divclassName=\"board-row\"><Square/><Square/><Square/></div><divclassName=\"board-row\"><Square/><Square/><Square/></div></>);}"
                },
                {
                    "type": "p",
                    "text": "Now you’ll changeSquareto display an “X” when clicked. Replace theconsole.log(\"clicked!\");event handler withsetValue('X');. Now yourSquarecomponent looks like this:"
                },
                {
                    "type": "code",
                    "code": "functionSquare(){const[value,setValue]=useState(null);functionhandleClick(){setValue('X');}return(<buttonclassName=\"square\"onClick={handleClick}>{value}</button>);}"
                },
                {
                    "type": "p",
                    "text": "By calling thissetfunction from anonClickhandler, you’re telling React to re-render thatSquarewhenever its<button>is clicked. After the update, theSquare’svaluewill be'X', so you’ll see the “X” on the game board. Click on any Square, and “X” should show up:"
                },
                {
                    "type": "p",
                    "text": "Each Square has its own state: thevaluestored in each Square is completely independent of the others. When you call asetfunction in a component, React automatically updates the child components inside too."
                },
                {
                    "type": "p",
                    "text": "After you’ve made the above changes, your code will look like this:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';functionSquare(){const[value,setValue]=useState(null);functionhandleClick(){setValue('X');}return(<buttonclassName=\"square\"onClick={handleClick}>{value}</button>);}exportdefaultfunctionBoard(){return(<><divclassName=\"board-row\"><Square/><Square/><Square/></div><divclassName=\"board-row\"><Square/><Square/><Square/></div><divclassName=\"board-row\"><Square/><Square/><Square/></div></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "React Developer Tools"
                },
                {
                    "type": "p",
                    "text": "React DevTools let you check the props and the state of your React components. You can find the React DevTools tab at the bottom of thebrowsersection in CodeSandbox:"
                },
                {
                    "type": "p",
                    "text": "To inspect a particular component on the screen, use the button in the top left corner of React DevTools:"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "For local development, React DevTools is available as aChrome,Firefox, andEdgebrowser extension. Install it, and theComponentstab will appear in your browser Developer Tools for sites using React."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Completing the game"
                },
                {
                    "type": "p",
                    "text": "By this point, you have all the basic building blocks for your tic-tac-toe game. To have a complete game, you now need to alternate placing “X”s and “O”s on the board, and you need a way to determine a winner."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Lifting state up"
                },
                {
                    "type": "p",
                    "text": "Currently, eachSquarecomponent maintains a part of the game’s state. To check for a winner in a tic-tac-toe game, theBoardwould need to somehow know the state of each of the 9Squarecomponents."
                },
                {
                    "type": "p",
                    "text": "How would you approach that? At first, you might guess that theBoardneeds to “ask” eachSquarefor thatSquare’s state. Although this approach is technically possible in React, we discourage it because the code becomes difficult to understand, susceptible to bugs, and hard to refactor. Instead, the best approach is to store the game’s state in the parentBoardcomponent instead of in eachSquare. TheBoardcomponent can tell eachSquarewhat to display by passing a prop, like you did when you passed a number to each Square."
                },
                {
                    "type": "p",
                    "text": "To collect data from multiple children, or to have two child components communicate with each other, declare the shared state in their parent component instead. The parent component can pass that state back down to the children via props. This keeps the child components in sync with each other and with their parent."
                },
                {
                    "type": "p",
                    "text": "Lifting state into a parent component is common when React components are refactored."
                },
                {
                    "type": "p",
                    "text": "Let’s take this opportunity to try it out. Edit theBoardcomponent so that it declares a state variable namedsquaresthat defaults to an array of 9 nulls corresponding to the 9 squares:"
                },
                {
                    "type": "code",
                    "code": "// ...exportdefaultfunctionBoard(){const[squares,setSquares]=useState(Array(9).fill(null));return(// ...);}"
                },
                {
                    "type": "p",
                    "text": "Array(9).fill(null)creates an array with nine elements and sets each of them tonull. TheuseState()call around it declares asquaresstate variable that’s initially set to that array. Each entry in the array corresponds to the value of a square. When you fill the board in later, thesquaresarray will look like this:"
                },
                {
                    "type": "code",
                    "code": "['O',null,'X','X','X','O','O',null,null]"
                },
                {
                    "type": "p",
                    "text": "Now yourBoardcomponent needs to pass thevalueprop down to eachSquarethat it renders:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionBoard(){const[squares,setSquares]=useState(Array(9).fill(null));return(<><divclassName=\"board-row\"><Squarevalue={squares[0]}/><Squarevalue={squares[1]}/><Squarevalue={squares[2]}/></div><divclassName=\"board-row\"><Squarevalue={squares[3]}/><Squarevalue={squares[4]}/><Squarevalue={squares[5]}/></div><divclassName=\"board-row\"><Squarevalue={squares[6]}/><Squarevalue={squares[7]}/><Squarevalue={squares[8]}/></div></>);}"
                },
                {
                    "type": "p",
                    "text": "Next, you’ll edit theSquarecomponent to receive thevalueprop from the Board component. This will require removing the Square component’s own stateful tracking ofvalueand the button’sonClickprop:"
                },
                {
                    "type": "code",
                    "code": "functionSquare({value}){return<buttonclassName=\"square\">{value}</button>;}"
                },
                {
                    "type": "p",
                    "text": "At this point you should see an empty tic-tac-toe board:"
                },
                {
                    "type": "p",
                    "text": "And your code should look like this:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';functionSquare({value}){return<buttonclassName=\"square\">{value}</button>;}exportdefaultfunctionBoard(){const[squares,setSquares]=useState(Array(9).fill(null));return(<><divclassName=\"board-row\"><Squarevalue={squares[0]}/><Squarevalue={squares[1]}/><Squarevalue={squares[2]}/></div><divclassName=\"board-row\"><Squarevalue={squares[3]}/><Squarevalue={squares[4]}/><Squarevalue={squares[5]}/></div><divclassName=\"board-row\"><Squarevalue={squares[6]}/><Squarevalue={squares[7]}/><Squarevalue={squares[8]}/></div></>);}"
                },
                {
                    "type": "p",
                    "text": "Each Square will now receive avalueprop that will either be'X','O', ornullfor empty squares."
                },
                {
                    "type": "p",
                    "text": "Next, you need to change what happens when aSquareis clicked. TheBoardcomponent now maintains which squares are filled. You’ll need to create a way for theSquareto update theBoard’s state. Since state is private to a component that defines it, you cannot update theBoard’s state directly fromSquare."
                },
                {
                    "type": "p",
                    "text": "Instead, you’ll pass down a function from theBoardcomponent to theSquarecomponent, and you’ll haveSquarecall that function when a square is clicked. You’ll start with the function that theSquarecomponent will call when it is clicked. You’ll call that functiononSquareClick:"
                },
                {
                    "type": "code",
                    "code": "functionSquare({value}){return(<buttonclassName=\"square\"onClick={onSquareClick}>{value}</button>);}"
                },
                {
                    "type": "p",
                    "text": "Next, you’ll add theonSquareClickfunction to theSquarecomponent’s props:"
                },
                {
                    "type": "code",
                    "code": "functionSquare({value,onSquareClick}){return(<buttonclassName=\"square\"onClick={onSquareClick}>{value}</button>);}"
                },
                {
                    "type": "p",
                    "text": "Now you’ll connect theonSquareClickprop to a function in theBoardcomponent that you’ll namehandleClick. To connectonSquareClicktohandleClickyou’ll pass a function to theonSquareClickprop of the firstSquarecomponent:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionBoard(){const[squares,setSquares]=useState(Array(9).fill(null));return(<><divclassName=\"board-row\"><Squarevalue={squares[0]}onSquareClick={handleClick}/>//...);}"
                },
                {
                    "type": "p",
                    "text": "Lastly, you will define thehandleClickfunction inside the Board component to update thesquaresarray holding your board’s state:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionBoard(){const[squares,setSquares]=useState(Array(9).fill(null));functionhandleClick(){constnextSquares=squares.slice();nextSquares[0]=\"X\";setSquares(nextSquares);}return(// ...)}"
                },
                {
                    "type": "p",
                    "text": "ThehandleClickfunction creates a copy of thesquaresarray (nextSquares) with the JavaScriptslice()Array method. Then,handleClickupdates thenextSquaresarray to addXto the first ([0]index) square."
                },
                {
                    "type": "p",
                    "text": "Calling thesetSquaresfunction lets React know the state of the component has changed. This will trigger a re-render of the components that use thesquaresstate (Board) as well as its child components (theSquarecomponents that make up the board)."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "JavaScript supportsclosureswhich means an inner function (e.g.handleClick) has access to variables and functions defined in an outer function (e.g.Board). ThehandleClickfunction can read thesquaresstate and call thesetSquaresmethod because they are both defined inside of theBoardfunction."
                },
                {
                    "type": "p",
                    "text": "Now you can add X’s to the board…  but only to the upper left square. YourhandleClickfunction is hardcoded to update the index for the upper left square (0). Let’s updatehandleClickto be able to update any square. Add an argumentito thehandleClickfunction that takes the index of the square to update:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionBoard(){const[squares,setSquares]=useState(Array(9).fill(null));functionhandleClick(i){constnextSquares=squares.slice();nextSquares[i]=\"X\";setSquares(nextSquares);}return(// ...)}"
                },
                {
                    "type": "p",
                    "text": "Next, you will need to pass thatitohandleClick. You could try to set theonSquareClickprop of square to behandleClick(0)directly in the JSX like this, but it won’t work:"
                },
                {
                    "type": "code",
                    "code": "<Squarevalue={squares[0]}onSquareClick={handleClick(0)}/>"
                },
                {
                    "type": "p",
                    "text": "Here is why this doesn’t work. ThehandleClick(0)call will be a part of rendering the board component. BecausehandleClick(0)alters the state of the board component by callingsetSquares, your entire board component will be re-rendered again. But this runshandleClick(0)again, leading to an infinite loop:"
                },
                {
                    "type": "p",
                    "text": "Why didn’t this problem happen earlier?"
                },
                {
                    "type": "p",
                    "text": "When you were passingonSquareClick={handleClick}, you were passing thehandleClickfunction down as a prop. You were not calling it! But now you arecallingthat function right away—notice the parentheses inhandleClick(0)—and that’s why it runs too early. You don’twantto callhandleClickuntil the user clicks!"
                },
                {
                    "type": "p",
                    "text": "You could fix this by creating a function likehandleFirstSquareClickthat callshandleClick(0), a function likehandleSecondSquareClickthat callshandleClick(1), and so on. You would pass (rather than call) these functions down as props likeonSquareClick={handleFirstSquareClick}. This would solve the infinite loop."
                },
                {
                    "type": "p",
                    "text": "However, defining nine different functions and giving each of them a name is too verbose. Instead, let’s do this:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionBoard(){// ...return(<><divclassName=\"board-row\"><Squarevalue={squares[0]}onSquareClick={()=>handleClick(0)}/>// ...);}"
                },
                {
                    "type": "p",
                    "text": "Notice the new() =>syntax. Here,() => handleClick(0)is anarrow function,which is a shorter way to define functions. When the square is clicked, the code after the=>“arrow” will run, callinghandleClick(0)."
                },
                {
                    "type": "p",
                    "text": "Now you need to update the other eight squares to callhandleClickfrom the arrow functions you pass. Make sure that the argument for each call of thehandleClickcorresponds to the index of the correct square:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionBoard(){// ...return(<><divclassName=\"board-row\"><Squarevalue={squares[0]}onSquareClick={()=>handleClick(0)}/><Squarevalue={squares[1]}onSquareClick={()=>handleClick(1)}/><Squarevalue={squares[2]}onSquareClick={()=>handleClick(2)}/></div><divclassName=\"board-row\"><Squarevalue={squares[3]}onSquareClick={()=>handleClick(3)}/><Squarevalue={squares[4]}onSquareClick={()=>handleClick(4)}/><Squarevalue={squares[5]}onSquareClick={()=>handleClick(5)}/></div><divclassName=\"board-row\"><Squarevalue={squares[6]}onSquareClick={()=>handleClick(6)}/><Squarevalue={squares[7]}onSquareClick={()=>handleClick(7)}/><Squarevalue={squares[8]}onSquareClick={()=>handleClick(8)}/></div></>);};"
                },
                {
                    "type": "p",
                    "text": "Now you can again add X’s to any square on the board by clicking on them:"
                },
                {
                    "type": "p",
                    "text": "But this time all the state management is handled by theBoardcomponent!"
                },
                {
                    "type": "p",
                    "text": "This is what your code should look like:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';functionSquare({value,onSquareClick}){return(<buttonclassName=\"square\"onClick={onSquareClick}>{value}</button>);}exportdefaultfunctionBoard(){const[squares,setSquares]=useState(Array(9).fill(null));functionhandleClick(i){constnextSquares=squares.slice();nextSquares[i]='X';setSquares(nextSquares);}return(<><divclassName=\"board-row\"><Squarevalue={squares[0]}onSquareClick={()=>handleClick(0)}/><Squarevalue={squares[1]}onSquareClick={()=>handleClick(1)}/><Squarevalue={squares[2]}onSquareClick={()=>handleClick(2)}/></div><divclassName=\"board-row\"><Squarevalue={squares[3]}onSquareClick={()=>handleClick(3)}/><Squarevalue={squares[4]}onSquareClick={()=>handleClick(4)}/><Squarevalue={squares[5]}onSquareClick={()=>handleClick(5)}/></div><divclassName=\"board-row\"><Squarevalue={squares[6]}onSquareClick={()=>handleClick(6)}/><Squarevalue={squares[7]}onSquareClick={()=>handleClick(7)}/><Squarevalue={squares[8]}onSquareClick={()=>handleClick(8)}/></div></>);}"
                },
                {
                    "type": "p",
                    "text": "Now that your state handling is in theBoardcomponent, the parentBoardcomponent passes props to the childSquarecomponents so that they can be displayed correctly. When clicking on aSquare, the childSquarecomponent now asks the parentBoardcomponent to update the state of the board. When theBoard’s state changes, both theBoardcomponent and every childSquarere-renders automatically. Keeping the state of all squares in theBoardcomponent will allow it to determine the winner in the future."
                },
                {
                    "type": "p",
                    "text": "Let’s recap what happens when a user clicks the top left square on your board to add anXto it:"
                },
                {
                    "type": "list",
                    "items": [
                        "Clicking on the upper left square runs the function that thebuttonreceived as itsonClickprop from theSquare. TheSquarecomponent received that function as itsonSquareClickprop from theBoard. TheBoardcomponent defined that function directly in the JSX. It callshandleClickwith an argument of0.",
                        "handleClickuses the argument (0) to update the first element of thesquaresarray fromnulltoX.",
                        "Thesquaresstate of theBoardcomponent was updated, so theBoardand all of its children re-render. This causes thevalueprop of theSquarecomponent with index0to change fromnulltoX."
                    ]
                },
                {
                    "type": "p",
                    "text": "In the end the user sees that the upper left square has changed from empty to having aXafter clicking it."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "The DOM<button>element’sonClickattribute has a special meaning to React because it is a built-in component. For custom components like Square, the naming is up to you. You could give any name to theSquare’sonSquareClickprop orBoard’shandleClickfunction, and the code would work the same. In React, it’s conventional to useonSomethingnames for props which represent events andhandleSomethingfor the function definitions which handle those events."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Why immutability is important"
                },
                {
                    "type": "p",
                    "text": "Note how inhandleClick, you call.slice()to create a copy of thesquaresarray instead of modifying the existing array. To explain why, we need to discuss immutability and why immutability is important to learn."
                },
                {
                    "type": "p",
                    "text": "There are generally two approaches to changing data. The first approach is tomutatethe data by directly changing the data’s values. The second approach is to replace the data with a new copy which has the desired changes. Here is what it would look like if you mutated thesquaresarray:"
                },
                {
                    "type": "code",
                    "code": "constsquares=[null,null,null,null,null,null,null,null,null];squares[0]='X';// Now `squares` is [\"X\", null, null, null, null, null, null, null, null];"
                },
                {
                    "type": "p",
                    "text": "And here is what it would look like if you changed data without mutating thesquaresarray:"
                },
                {
                    "type": "code",
                    "code": "constsquares=[null,null,null,null,null,null,null,null,null];constnextSquares=['X',null,null,null,null,null,null,null,null];// Now `squares` is unchanged, but `nextSquares` first element is 'X' rather than `null`"
                },
                {
                    "type": "p",
                    "text": "The result is the same but by not mutating (changing the underlying data) directly, you gain several benefits."
                },
                {
                    "type": "p",
                    "text": "Immutability makes complex features much easier to implement. Later in this tutorial, you will implement a “time travel” feature that lets you review the game’s history and “jump back” to past moves. This functionality isn’t specific to games—an ability to undo and redo certain actions is a common requirement for apps. Avoiding direct data mutation lets you keep previous versions of the data intact, and reuse them later."
                },
                {
                    "type": "p",
                    "text": "There is also another benefit of immutability. By default, all child components re-render automatically when the state of a parent component changes. This includes even the child components that weren’t affected by the change. Although re-rendering is not by itself noticeable to the user (you shouldn’t actively try to avoid it!), you might want to skip re-rendering a part of the tree that clearly wasn’t affected by it for performance reasons. Immutability makes it very cheap for components to compare whether their data has changed or not. You can learn more about how React chooses when to re-render a component inthememoAPI reference."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Taking turns"
                },
                {
                    "type": "p",
                    "text": "It’s now time to fix a major defect in this tic-tac-toe game: the “O”s cannot be marked on the board."
                },
                {
                    "type": "p",
                    "text": "You’ll set the first move to be “X” by default. Let’s keep track of this by adding another piece of state to the Board component:"
                },
                {
                    "type": "code",
                    "code": "functionBoard(){const[xIsNext,setXIsNext]=useState(true);const[squares,setSquares]=useState(Array(9).fill(null));// ...}"
                },
                {
                    "type": "p",
                    "text": "Each time a player moves,xIsNext(a boolean) will be flipped to determine which player goes next and the game’s state will be saved. You’ll update theBoard’shandleClickfunction to flip the value ofxIsNext:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionBoard(){const[xIsNext,setXIsNext]=useState(true);const[squares,setSquares]=useState(Array(9).fill(null));functionhandleClick(i){constnextSquares=squares.slice();if(xIsNext){nextSquares[i]=\"X\";}else{nextSquares[i]=\"O\";}setSquares(nextSquares);setXIsNext(!xIsNext);}return(//...);}"
                },
                {
                    "type": "p",
                    "text": "Now, as you click on different squares, they will alternate betweenXandO, as they should!"
                },
                {
                    "type": "p",
                    "text": "But wait, there’s a problem. Try clicking on the same square multiple times:"
                },
                {
                    "type": "p",
                    "text": "TheXis overwritten by anO! While this would add a very interesting twist to the game, we’re going to stick to the original rules for now."
                },
                {
                    "type": "p",
                    "text": "When you mark a square with aXor anOyou aren’t first checking to see if the square already has aXorOvalue. You can fix this byreturning early. You’ll check to see if the square already has aXor anO. If the square is already filled, you willreturnin thehandleClickfunction early—before it tries to update the board state."
                },
                {
                    "type": "code",
                    "code": "functionhandleClick(i){if(squares[i]){return;}constnextSquares=squares.slice();//...}"
                },
                {
                    "type": "p",
                    "text": "Now you can only addX’s orO’s to empty squares! Here is what your code should look like at this point:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';functionSquare({value,onSquareClick}){return(<buttonclassName=\"square\"onClick={onSquareClick}>{value}</button>);}exportdefaultfunctionBoard(){const[xIsNext,setXIsNext]=useState(true);const[squares,setSquares]=useState(Array(9).fill(null));functionhandleClick(i){if(squares[i]){return;}constnextSquares=squares.slice();if(xIsNext){nextSquares[i]='X';}else{nextSquares[i]='O';}setSquares(nextSquares);setXIsNext(!xIsNext);}return(<><divclassName=\"board-row\"><Squarevalue={squares[0]}onSquareClick={()=>handleClick(0)}/><Squarevalue={squares[1]}onSquareClick={()=>handleClick(1)}/><Squarevalue={squares[2]}onSquareClick={()=>handleClick(2)}/></div><divclassName=\"board-row\"><Squarevalue={squares[3]}onSquareClick={()=>handleClick(3)}/><Squarevalue={squares[4]}onSquareClick={()=>handleClick(4)}/><Squarevalue={squares[5]}onSquareClick={()=>handleClick(5)}/></div><divclassName=\"board-row\"><Squarevalue={squares[6]}onSquareClick={()=>handleClick(6)}/><Squarevalue={squares[7]}onSquareClick={()=>handleClick(7)}/><Squarevalue={squares[8]}onSquareClick={()=>handleClick(8)}/></div></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Declaring a winner"
                },
                {
                    "type": "p",
                    "text": "Now that the players can take turns, you’ll want to show when the game is won and there are no more turns to make. To do this you’ll add a helper function calledcalculateWinnerthat takes an array of 9 squares, checks for a winner and returns'X','O', ornullas appropriate. Don’t worry too much about thecalculateWinnerfunction; it’s not specific to React:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionBoard(){//...}functioncalculateWinner(squares){constlines=[[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];for(leti=0;i<lines.length;i++){const[a,b,c]=lines[i];if(squares[a]&&squares[a]===squares[b]&&squares[a]===squares[c]){returnsquares[a];}}returnnull;}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "It does not matter whether you definecalculateWinnerbefore or after theBoard. Let’s put it at the end so that you don’t have to scroll past it every time you edit your components."
                },
                {
                    "type": "p",
                    "text": "You will callcalculateWinner(squares)in theBoardcomponent’shandleClickfunction to check if a player has won. You can perform this check at the same time you check if a user has clicked a square that already has aXor andO. We’d like to return early in both cases:"
                },
                {
                    "type": "code",
                    "code": "functionhandleClick(i){if(squares[i]||calculateWinner(squares)){return;}constnextSquares=squares.slice();//...}"
                },
                {
                    "type": "p",
                    "text": "To let the players know when the game is over, you can display text such as “Winner: X” or “Winner: O”. To do that you’ll add astatussection to theBoardcomponent. The status will display the winner if the game is over and if the game is ongoing you’ll display which player’s turn is next:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionBoard(){// ...constwinner=calculateWinner(squares);letstatus;if(winner){status=\"Winner: \"+winner;}else{status=\"Next player: \"+(xIsNext?\"X\":\"O\");}return(<><divclassName=\"status\">{status}</div><divclassName=\"board-row\">// ...)}"
                },
                {
                    "type": "p",
                    "text": "Congratulations! You now have a working tic-tac-toe game. And you’ve just learned the basics of React too. Soyouare the real winner here. Here is what the code should look like:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';functionSquare({value,onSquareClick}){return(<buttonclassName=\"square\"onClick={onSquareClick}>{value}</button>);}exportdefaultfunctionBoard(){const[xIsNext,setXIsNext]=useState(true);const[squares,setSquares]=useState(Array(9).fill(null));functionhandleClick(i){if(calculateWinner(squares)||squares[i]){return;}constnextSquares=squares.slice();if(xIsNext){nextSquares[i]='X';}else{nextSquares[i]='O';}setSquares(nextSquares);setXIsNext(!xIsNext);}constwinner=calculateWinner(squares);letstatus;if(winner){status='Winner: '+winner;}else{status='Next player: '+(xIsNext?'X':'O');}return(<><divclassName=\"status\">{status}</div><divclassName=\"board-row\"><Squarevalue={squares[0]}onSquareClick={()=>handleClick(0)}/><Squarevalue={squares[1]}onSquareClick={()=>handleClick(1)}/><Squarevalue={squares[2]}onSquareClick={()=>handleClick(2)}/></div><divclassName=\"board-row\"><Squarevalue={squares[3]}onSquareClick={()=>handleClick(3)}/><Squarevalue={squares[4]}onSquareClick={()=>handleClick(4)}/><Squarevalue={squares[5]}onSquareClick={()=>handleClick(5)}/></div><divclassName=\"board-row\"><Squarevalue={squares[6]}onSquareClick={()=>handleClick(6)}/><Squarevalue={squares[7]}onSquareClick={()=>handleClick(7)}/><Squarevalue={squares[8]}onSquareClick={()=>handleClick(8)}/></div></>);}functioncalculateWinner(squares){constlines=[[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6],];for(leti=0;i<lines.length;i++){const[a,b,c]=lines[i];if(squares[a]&&squares[a]===squares[b]&&squares[a]===squares[c]){returnsquares[a];}}returnnull;}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Adding time travel"
                },
                {
                    "type": "p",
                    "text": "As a final exercise, let’s make it possible to “go back in time” to the previous moves in the game."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Storing a history of moves"
                },
                {
                    "type": "p",
                    "text": "If you mutated thesquaresarray, implementing time travel would be very difficult."
                },
                {
                    "type": "p",
                    "text": "However, you usedslice()to create a new copy of thesquaresarray after every move, and treated it as immutable. This will allow you to store every past version of thesquaresarray, and navigate between the turns that have already happened."
                },
                {
                    "type": "p",
                    "text": "You’ll store the pastsquaresarrays in another array calledhistory, which you’ll store as a new state variable. Thehistoryarray represents all board states, from the first to the last move, and has a shape like this:"
                },
                {
                    "type": "code",
                    "code": "[// Before first move[null,null,null,null,null,null,null,null,null],// After first move[null,null,null,null,'X',null,null,null,null],// After second move[null,null,null,null,'X',null,null,null,'O'],// ...]"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Lifting state up, again"
                },
                {
                    "type": "p",
                    "text": "You will now write a new top-level component calledGameto display a list of past moves. That’s where you will place thehistorystate that contains the entire game history."
                },
                {
                    "type": "p",
                    "text": "Placing thehistorystate into theGamecomponent will let you remove thesquaresstate from its childBoardcomponent. Just like you “lifted state up” from theSquarecomponent into theBoardcomponent, you will now lift it up from theBoardinto the top-levelGamecomponent. This gives theGamecomponent full control over theBoard’s data and lets it instruct theBoardto render previous turns from thehistory."
                },
                {
                    "type": "p",
                    "text": "First, add aGamecomponent withexport default. Have it render theBoardcomponent and some markup:"
                },
                {
                    "type": "code",
                    "code": "functionBoard(){// ...}exportdefaultfunctionGame(){return(<divclassName=\"game\"><divclassName=\"game-board\"><Board/></div><divclassName=\"game-info\"><ol>{/*TODO*/}</ol></div></div>);}"
                },
                {
                    "type": "p",
                    "text": "Note that you are removing theexport defaultkeywords before thefunction Board() {declaration and adding them before thefunction Game() {declaration. This tells yourindex.jsfile to use theGamecomponent as the top-level component instead of yourBoardcomponent. The additionaldivs returned by theGamecomponent are making room for the game information you’ll add to the board later."
                },
                {
                    "type": "p",
                    "text": "Add some state to theGamecomponent to track which player is next and the history of moves:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionGame(){const[xIsNext,setXIsNext]=useState(true);const[history,setHistory]=useState([Array(9).fill(null)]);// ..."
                },
                {
                    "type": "p",
                    "text": "Notice how[Array(9).fill(null)]is an array with a single item, which itself is an array of 9nulls."
                },
                {
                    "type": "p",
                    "text": "To render the squares for the current move, you’ll want to read the last squares array from thehistory. You don’t needuseStatefor this—you already have enough information to calculate it during rendering:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionGame(){const[xIsNext,setXIsNext]=useState(true);const[history,setHistory]=useState([Array(9).fill(null)]);constcurrentSquares=history[history.length-1];// ..."
                },
                {
                    "type": "p",
                    "text": "Next, create ahandlePlayfunction inside theGamecomponent that will be called by theBoardcomponent to update the game. PassxIsNext,currentSquaresandhandlePlayas props to theBoardcomponent:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionGame(){const[xIsNext,setXIsNext]=useState(true);const[history,setHistory]=useState([Array(9).fill(null)]);constcurrentSquares=history[history.length-1];functionhandlePlay(nextSquares){// TODO}return(<divclassName=\"game\"><divclassName=\"game-board\"><BoardxIsNext={xIsNext}squares={currentSquares}onPlay={handlePlay}/>//...)}"
                },
                {
                    "type": "p",
                    "text": "Let’s make theBoardcomponent fully controlled by the props it receives. Change theBoardcomponent to take three props:xIsNext,squares, and a newonPlayfunction thatBoardcan call with the updated squares array when a player makes a move. Next, remove the first two lines of theBoardfunction that calluseState:"
                },
                {
                    "type": "code",
                    "code": "functionBoard({xIsNext,squares,onPlay}){functionhandleClick(i){//...}// ...}"
                },
                {
                    "type": "p",
                    "text": "Now replace thesetSquaresandsetXIsNextcalls inhandleClickin theBoardcomponent with a single call to your newonPlayfunction so theGamecomponent can update theBoardwhen the user clicks a square:"
                },
                {
                    "type": "code",
                    "code": "functionBoard({xIsNext,squares,onPlay}){functionhandleClick(i){if(calculateWinner(squares)||squares[i]){return;}constnextSquares=squares.slice();if(xIsNext){nextSquares[i]=\"X\";}else{nextSquares[i]=\"O\";}onPlay(nextSquares);}//...}"
                },
                {
                    "type": "p",
                    "text": "TheBoardcomponent is fully controlled by the props passed to it by theGamecomponent. You need to implement thehandlePlayfunction in theGamecomponent to get the game working again."
                },
                {
                    "type": "p",
                    "text": "What shouldhandlePlaydo when called? Remember that Board used to callsetSquareswith an updated array; now it passes the updatedsquaresarray toonPlay."
                },
                {
                    "type": "p",
                    "text": "ThehandlePlayfunction needs to updateGame’s state to trigger a re-render, but you don’t have asetSquaresfunction that you can call any more—you’re now using thehistorystate variable to store this information. You’ll want to updatehistoryby appending the updatedsquaresarray as a new history entry. You also want to togglexIsNext, just as Board used to do:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionGame(){//...functionhandlePlay(nextSquares){setHistory([...history,nextSquares]);setXIsNext(!xIsNext);}//...}"
                },
                {
                    "type": "p",
                    "text": "Here,[...history, nextSquares]creates a new array that contains all the items inhistory, followed bynextSquares. (You can read the...historyspread syntaxas “enumerate all the items inhistory”.)"
                },
                {
                    "type": "p",
                    "text": "For example, ifhistoryis[[null,null,null], [\"X\",null,null]]andnextSquaresis[\"X\",null,\"O\"], then the new[...history, nextSquares]array will be[[null,null,null], [\"X\",null,null], [\"X\",null,\"O\"]]."
                },
                {
                    "type": "p",
                    "text": "At this point, you’ve moved the state to live in theGamecomponent, and the UI should be fully working, just as it was before the refactor. Here is what the code should look like at this point:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';functionSquare({value,onSquareClick}){return(<buttonclassName=\"square\"onClick={onSquareClick}>{value}</button>);}functionBoard({xIsNext,squares,onPlay}){functionhandleClick(i){if(calculateWinner(squares)||squares[i]){return;}constnextSquares=squares.slice();if(xIsNext){nextSquares[i]='X';}else{nextSquares[i]='O';}onPlay(nextSquares);}constwinner=calculateWinner(squares);letstatus;if(winner){status='Winner: '+winner;}else{status='Next player: '+(xIsNext?'X':'O');}return(<><divclassName=\"status\">{status}</div><divclassName=\"board-row\"><Squarevalue={squares[0]}onSquareClick={()=>handleClick(0)}/><Squarevalue={squares[1]}onSquareClick={()=>handleClick(1)}/><Squarevalue={squares[2]}onSquareClick={()=>handleClick(2)}/></div><divclassName=\"board-row\"><Squarevalue={squares[3]}onSquareClick={()=>handleClick(3)}/><Squarevalue={squares[4]}onSquareClick={()=>handleClick(4)}/><Squarevalue={squares[5]}onSquareClick={()=>handleClick(5)}/></div><divclassName=\"board-row\"><Squarevalue={squares[6]}onSquareClick={()=>handleClick(6)}/><Squarevalue={squares[7]}onSquareClick={()=>handleClick(7)}/><Squarevalue={squares[8]}onSquareClick={()=>handleClick(8)}/></div></>);}exportdefaultfunctionGame(){const[xIsNext,setXIsNext]=useState(true);const[history,setHistory]=useState([Array(9).fill(null)]);constcurrentSquares=history[history.length-1];functionhandlePlay(nextSquares){setHistory([...history,nextSquares]);setXIsNext(!xIsNext);}return(<divclassName=\"game\"><divclassName=\"game-board\"><BoardxIsNext={xIsNext}squares={currentSquares}onPlay={handlePlay}/></div><divclassName=\"game-info\"><ol>{/*TODO*/}</ol></div></div>);}functioncalculateWinner(squares){constlines=[[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6],];for(leti=0;i<lines.length;i++){const[a,b,c]=lines[i];if(squares[a]&&squares[a]===squares[b]&&squares[a]===squares[c]){returnsquares[a];}}returnnull;}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Showing the past moves"
                },
                {
                    "type": "p",
                    "text": "Since you are recording the tic-tac-toe game’s history, you can now display a list of past moves to the player."
                },
                {
                    "type": "p",
                    "text": "React elements like<button>are regular JavaScript objects; you can pass them around in your application. To render multiple items in React, you can use an array of React elements."
                },
                {
                    "type": "p",
                    "text": "You already have an array ofhistorymoves in state, so now you need to transform it to an array of React elements. In JavaScript, to transform one array into another, you can use thearraymapmethod:"
                },
                {
                    "type": "code",
                    "code": "[1,2,3].map((x)=>x*2)// [2, 4, 6]"
                },
                {
                    "type": "p",
                    "text": "You’ll usemapto transform yourhistoryof moves into React elements representing buttons on the screen, and display a list of buttons to “jump” to past moves. Let’smapover thehistoryin the Game component:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionGame(){const[xIsNext,setXIsNext]=useState(true);const[history,setHistory]=useState([Array(9).fill(null)]);constcurrentSquares=history[history.length-1];functionhandlePlay(nextSquares){setHistory([...history,nextSquares]);setXIsNext(!xIsNext);}functionjumpTo(nextMove){// TODO}constmoves=history.map((squares,move)=>{letdescription;if(move>0){description='Go to move #'+move;}else{description='Go to game start';}return(<li><buttononClick={()=>jumpTo(move)}>{description}</button></li>);});return(<divclassName=\"game\"><divclassName=\"game-board\"><BoardxIsNext={xIsNext}squares={currentSquares}onPlay={handlePlay}/></div><divclassName=\"game-info\"><ol>{moves}</ol></div></div>);}"
                },
                {
                    "type": "p",
                    "text": "You can see what your code should look like below. Note that you should see an error in the developer tools console that says:"
                },
                {
                    "type": "p",
                    "text": "You’ll fix this error in the next section."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';functionSquare({value,onSquareClick}){return(<buttonclassName=\"square\"onClick={onSquareClick}>{value}</button>);}functionBoard({xIsNext,squares,onPlay}){functionhandleClick(i){if(calculateWinner(squares)||squares[i]){return;}constnextSquares=squares.slice();if(xIsNext){nextSquares[i]='X';}else{nextSquares[i]='O';}onPlay(nextSquares);}constwinner=calculateWinner(squares);letstatus;if(winner){status='Winner: '+winner;}else{status='Next player: '+(xIsNext?'X':'O');}return(<><divclassName=\"status\">{status}</div><divclassName=\"board-row\"><Squarevalue={squares[0]}onSquareClick={()=>handleClick(0)}/><Squarevalue={squares[1]}onSquareClick={()=>handleClick(1)}/><Squarevalue={squares[2]}onSquareClick={()=>handleClick(2)}/></div><divclassName=\"board-row\"><Squarevalue={squares[3]}onSquareClick={()=>handleClick(3)}/><Squarevalue={squares[4]}onSquareClick={()=>handleClick(4)}/><Squarevalue={squares[5]}onSquareClick={()=>handleClick(5)}/></div><divclassName=\"board-row\"><Squarevalue={squares[6]}onSquareClick={()=>handleClick(6)}/><Squarevalue={squares[7]}onSquareClick={()=>handleClick(7)}/><Squarevalue={squares[8]}onSquareClick={()=>handleClick(8)}/></div></>);}exportdefaultfunctionGame(){const[xIsNext,setXIsNext]=useState(true);const[history,setHistory]=useState([Array(9).fill(null)]);constcurrentSquares=history[history.length-1];functionhandlePlay(nextSquares){setHistory([...history,nextSquares]);setXIsNext(!xIsNext);}functionjumpTo(nextMove){// TODO}constmoves=history.map((squares,move)=>{letdescription;if(move>0){description='Go to move #'+move;}else{description='Go to game start';}return(<li><buttononClick={()=>jumpTo(move)}>{description}</button></li>);});return(<divclassName=\"game\"><divclassName=\"game-board\"><BoardxIsNext={xIsNext}squares={currentSquares}onPlay={handlePlay}/></div><divclassName=\"game-info\"><ol>{moves}</ol></div></div>);}functioncalculateWinner(squares){constlines=[[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6],];for(leti=0;i<lines.length;i++){const[a,b,c]=lines[i];if(squares[a]&&squares[a]===squares[b]&&squares[a]===squares[c]){returnsquares[a];}}returnnull;}"
                },
                {
                    "type": "p",
                    "text": "As you iterate throughhistoryarray inside the function you passed tomap, thesquaresargument goes through each element ofhistory, and themoveargument goes through each array index:0,1,2, …. (In most cases, you’d need the actual array elements, but to render a list of moves you will only need indexes.)"
                },
                {
                    "type": "p",
                    "text": "For each move in the tic-tac-toe game’s history, you create a list item<li>which contains a button<button>. The button has anonClickhandler which calls a function calledjumpTo(that you haven’t implemented yet)."
                },
                {
                    "type": "p",
                    "text": "For now, you should see a list of the moves that occurred in the game and an error in the developer tools console. Let’s discuss what the “key” error means."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Picking a key"
                },
                {
                    "type": "p",
                    "text": "When you render a list, React stores some information about each rendered list item. When you update a list, React needs to determine what has changed. You could have added, removed, re-arranged, or updated the list’s items."
                },
                {
                    "type": "p",
                    "text": "Imagine transitioning from"
                },
                {
                    "type": "code",
                    "code": "<li>Alexa: 7 tasks left</li><li>Ben: 5 tasks left</li>"
                },
                {
                    "type": "p",
                    "text": "to"
                },
                {
                    "type": "code",
                    "code": "<li>Ben: 9 tasks left</li><li>Claudia: 8 tasks left</li><li>Alexa: 5 tasks left</li>"
                },
                {
                    "type": "p",
                    "text": "In addition to the updated counts, a human reading this would probably say that you swapped Alexa and Ben’s ordering and inserted Claudia between Alexa and Ben. However, React is a computer program and does not know what you intended, so you need to specify akeyproperty for each list item to differentiate each list item from its siblings. If your data was from a database, Alexa, Ben, and Claudia’s database IDs could be used as keys."
                },
                {
                    "type": "code",
                    "code": "<likey={user.id}>{user.name}:{user.taskCount}tasks left</li>"
                },
                {
                    "type": "p",
                    "text": "When a list is re-rendered, React takes each list item’s key and searches the previous list’s items for a matching key. If the current list has a key that didn’t exist before, React creates a component. If the current list is missing a key that existed in the previous list, React destroys the previous component. If two keys match, the corresponding component is moved."
                },
                {
                    "type": "p",
                    "text": "Keys tell React about the identity of each component, which allows React to maintain state between re-renders. If a component’s key changes, the component will be destroyed and re-created with a new state."
                },
                {
                    "type": "p",
                    "text": "keyis a special and reserved property in React. When an element is created, React extracts thekeyproperty and stores the key directly on the returned element. Even thoughkeymay look like it is passed as props, React automatically useskeyto decide which components to update. There’s no way for a component to ask whatkeyits parent specified."
                },
                {
                    "type": "p",
                    "text": "It’s strongly recommended that you assign proper keys whenever you build dynamic lists.If you don’t have an appropriate key, you may want to consider restructuring your data so that you do."
                },
                {
                    "type": "p",
                    "text": "If no key is specified, React will report an error and use the array index as a key by default. Using the array index as a key is problematic when trying to re-order a list’s items or inserting/removing list items. Explicitly passingkey={i}silences the error but has the same problems as array indices and is not recommended in most cases."
                },
                {
                    "type": "p",
                    "text": "Keys do not need to be globally unique; they only need to be unique between components and their siblings."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Implementing time travel"
                },
                {
                    "type": "p",
                    "text": "In the tic-tac-toe game’s history, each past move has a unique ID associated with it: it’s the sequential number of the move. Moves will never be re-ordered, deleted, or inserted in the middle, so it’s safe to use the move index as a key."
                },
                {
                    "type": "p",
                    "text": "In theGamefunction, you can add the key as<li key={move}>, and if you reload the rendered game, React’s “key” error should disappear:"
                },
                {
                    "type": "code",
                    "code": "constmoves=history.map((squares,move)=>{//...return(<likey={move}><buttononClick={()=>jumpTo(move)}>{description}</button></li>);});"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';functionSquare({value,onSquareClick}){return(<buttonclassName=\"square\"onClick={onSquareClick}>{value}</button>);}functionBoard({xIsNext,squares,onPlay}){functionhandleClick(i){if(calculateWinner(squares)||squares[i]){return;}constnextSquares=squares.slice();if(xIsNext){nextSquares[i]='X';}else{nextSquares[i]='O';}onPlay(nextSquares);}constwinner=calculateWinner(squares);letstatus;if(winner){status='Winner: '+winner;}else{status='Next player: '+(xIsNext?'X':'O');}return(<><divclassName=\"status\">{status}</div><divclassName=\"board-row\"><Squarevalue={squares[0]}onSquareClick={()=>handleClick(0)}/><Squarevalue={squares[1]}onSquareClick={()=>handleClick(1)}/><Squarevalue={squares[2]}onSquareClick={()=>handleClick(2)}/></div><divclassName=\"board-row\"><Squarevalue={squares[3]}onSquareClick={()=>handleClick(3)}/><Squarevalue={squares[4]}onSquareClick={()=>handleClick(4)}/><Squarevalue={squares[5]}onSquareClick={()=>handleClick(5)}/></div><divclassName=\"board-row\"><Squarevalue={squares[6]}onSquareClick={()=>handleClick(6)}/><Squarevalue={squares[7]}onSquareClick={()=>handleClick(7)}/><Squarevalue={squares[8]}onSquareClick={()=>handleClick(8)}/></div></>);}exportdefaultfunctionGame(){const[xIsNext,setXIsNext]=useState(true);const[history,setHistory]=useState([Array(9).fill(null)]);constcurrentSquares=history[history.length-1];functionhandlePlay(nextSquares){setHistory([...history,nextSquares]);setXIsNext(!xIsNext);}functionjumpTo(nextMove){// TODO}constmoves=history.map((squares,move)=>{letdescription;if(move>0){description='Go to move #'+move;}else{description='Go to game start';}return(<likey={move}><buttononClick={()=>jumpTo(move)}>{description}</button></li>);});return(<divclassName=\"game\"><divclassName=\"game-board\"><BoardxIsNext={xIsNext}squares={currentSquares}onPlay={handlePlay}/></div><divclassName=\"game-info\"><ol>{moves}</ol></div></div>);}functioncalculateWinner(squares){constlines=[[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6],];for(leti=0;i<lines.length;i++){const[a,b,c]=lines[i];if(squares[a]&&squares[a]===squares[b]&&squares[a]===squares[c]){returnsquares[a];}}returnnull;}"
                },
                {
                    "type": "p",
                    "text": "Before you can implementjumpTo, you need theGamecomponent to keep track of which step the user is currently viewing. To do this, define a new state variable calledcurrentMove, defaulting to0:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionGame(){const[xIsNext,setXIsNext]=useState(true);const[history,setHistory]=useState([Array(9).fill(null)]);const[currentMove,setCurrentMove]=useState(0);constcurrentSquares=history[history.length-1];//...}"
                },
                {
                    "type": "p",
                    "text": "Next, update thejumpTofunction insideGameto update thatcurrentMove. You’ll also setxIsNexttotrueif the number that you’re changingcurrentMoveto is even."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionGame(){// ...functionjumpTo(nextMove){setCurrentMove(nextMove);setXIsNext(nextMove%2===0);}//...}"
                },
                {
                    "type": "p",
                    "text": "You will now make two changes to theGame’shandlePlayfunction which is called when you click on a square."
                },
                {
                    "type": "list",
                    "items": [
                        "If you “go back in time” and then make a new move from that point, you only want to keep the history up to that point. Instead of addingnextSquaresafter all items (...spread syntax) inhistory, you’ll add it after all items inhistory.slice(0, currentMove + 1)so that you’re only keeping that portion of the old history.",
                        "Each time a move is made, you need to updatecurrentMoveto point to the latest history entry."
                    ]
                },
                {
                    "type": "code",
                    "code": "functionhandlePlay(nextSquares){constnextHistory=[...history.slice(0,currentMove+1),nextSquares];setHistory(nextHistory);setCurrentMove(nextHistory.length-1);setXIsNext(!xIsNext);}"
                },
                {
                    "type": "p",
                    "text": "Finally, you will modify theGamecomponent to render the currently selected move, instead of always rendering the final move:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionGame(){const[xIsNext,setXIsNext]=useState(true);const[history,setHistory]=useState([Array(9).fill(null)]);const[currentMove,setCurrentMove]=useState(0);constcurrentSquares=history[currentMove];// ...}"
                },
                {
                    "type": "p",
                    "text": "If you click on any step in the game’s history, the tic-tac-toe board should immediately update to show what the board looked like after that step occurred."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';functionSquare({value,onSquareClick}){return(<buttonclassName=\"square\"onClick={onSquareClick}>{value}</button>);}functionBoard({xIsNext,squares,onPlay}){functionhandleClick(i){if(calculateWinner(squares)||squares[i]){return;}constnextSquares=squares.slice();if(xIsNext){nextSquares[i]='X';}else{nextSquares[i]='O';}onPlay(nextSquares);}constwinner=calculateWinner(squares);letstatus;if(winner){status='Winner: '+winner;}else{status='Next player: '+(xIsNext?'X':'O');}return(<><divclassName=\"status\">{status}</div><divclassName=\"board-row\"><Squarevalue={squares[0]}onSquareClick={()=>handleClick(0)}/><Squarevalue={squares[1]}onSquareClick={()=>handleClick(1)}/><Squarevalue={squares[2]}onSquareClick={()=>handleClick(2)}/></div><divclassName=\"board-row\"><Squarevalue={squares[3]}onSquareClick={()=>handleClick(3)}/><Squarevalue={squares[4]}onSquareClick={()=>handleClick(4)}/><Squarevalue={squares[5]}onSquareClick={()=>handleClick(5)}/></div><divclassName=\"board-row\"><Squarevalue={squares[6]}onSquareClick={()=>handleClick(6)}/><Squarevalue={squares[7]}onSquareClick={()=>handleClick(7)}/><Squarevalue={squares[8]}onSquareClick={()=>handleClick(8)}/></div></>);}exportdefaultfunctionGame(){const[xIsNext,setXIsNext]=useState(true);const[history,setHistory]=useState([Array(9).fill(null)]);const[currentMove,setCurrentMove]=useState(0);constcurrentSquares=history[currentMove];functionhandlePlay(nextSquares){constnextHistory=[...history.slice(0,currentMove+1),nextSquares];setHistory(nextHistory);setCurrentMove(nextHistory.length-1);setXIsNext(!xIsNext);}functionjumpTo(nextMove){setCurrentMove(nextMove);setXIsNext(nextMove%2===0);}constmoves=history.map((squares,move)=>{letdescription;if(move>0){description='Go to move #'+move;}else{description='Go to game start';}return(<likey={move}><buttononClick={()=>jumpTo(move)}>{description}</button></li>);});return(<divclassName=\"game\"><divclassName=\"game-board\"><BoardxIsNext={xIsNext}squares={currentSquares}onPlay={handlePlay}/></div><divclassName=\"game-info\"><ol>{moves}</ol></div></div>);}functioncalculateWinner(squares){constlines=[[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6],];for(leti=0;i<lines.length;i++){const[a,b,c]=lines[i];if(squares[a]&&squares[a]===squares[b]&&squares[a]===squares[c]){returnsquares[a];}}returnnull;}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Final cleanup"
                },
                {
                    "type": "p",
                    "text": "If you look at the code very closely, you may notice thatxIsNext === truewhencurrentMoveis even andxIsNext === falsewhencurrentMoveis odd. In other words, if you know the value ofcurrentMove, then you can always figure out whatxIsNextshould be."
                },
                {
                    "type": "p",
                    "text": "There’s no reason for you to store both of these in state. In fact, always try to avoid redundant state. Simplifying what you store in state reduces bugs and makes your code easier to understand. ChangeGameso that it doesn’t storexIsNextas a separate state variable and instead figures it out based on thecurrentMove:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionGame(){const[history,setHistory]=useState([Array(9).fill(null)]);const[currentMove,setCurrentMove]=useState(0);constxIsNext=currentMove%2===0;constcurrentSquares=history[currentMove];functionhandlePlay(nextSquares){constnextHistory=[...history.slice(0,currentMove+1),nextSquares];setHistory(nextHistory);setCurrentMove(nextHistory.length-1);}functionjumpTo(nextMove){setCurrentMove(nextMove);}// ...}"
                },
                {
                    "type": "p",
                    "text": "You no longer need thexIsNextstate declaration or the calls tosetXIsNext. Now, there’s no chance forxIsNextto get out of sync withcurrentMove, even if you make a mistake while coding the components."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Wrapping up"
                },
                {
                    "type": "p",
                    "text": "Congratulations! You’ve created a tic-tac-toe game that:"
                },
                {
                    "type": "list",
                    "items": [
                        "Lets you play tic-tac-toe,",
                        "Indicates when a player has won the game,",
                        "Stores a game’s history as a game progresses,",
                        "Allows players to review a game’s history and see previous versions of a game’s board."
                    ]
                },
                {
                    "type": "p",
                    "text": "Nice work! We hope you now feel like you have a decent grasp of how React works."
                },
                {
                    "type": "p",
                    "text": "Check out the final result here:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';functionSquare({value,onSquareClick}){return(<buttonclassName=\"square\"onClick={onSquareClick}>{value}</button>);}functionBoard({xIsNext,squares,onPlay}){functionhandleClick(i){if(calculateWinner(squares)||squares[i]){return;}constnextSquares=squares.slice();if(xIsNext){nextSquares[i]='X';}else{nextSquares[i]='O';}onPlay(nextSquares);}constwinner=calculateWinner(squares);letstatus;if(winner){status='Winner: '+winner;}else{status='Next player: '+(xIsNext?'X':'O');}return(<><divclassName=\"status\">{status}</div><divclassName=\"board-row\"><Squarevalue={squares[0]}onSquareClick={()=>handleClick(0)}/><Squarevalue={squares[1]}onSquareClick={()=>handleClick(1)}/><Squarevalue={squares[2]}onSquareClick={()=>handleClick(2)}/></div><divclassName=\"board-row\"><Squarevalue={squares[3]}onSquareClick={()=>handleClick(3)}/><Squarevalue={squares[4]}onSquareClick={()=>handleClick(4)}/><Squarevalue={squares[5]}onSquareClick={()=>handleClick(5)}/></div><divclassName=\"board-row\"><Squarevalue={squares[6]}onSquareClick={()=>handleClick(6)}/><Squarevalue={squares[7]}onSquareClick={()=>handleClick(7)}/><Squarevalue={squares[8]}onSquareClick={()=>handleClick(8)}/></div></>);}exportdefaultfunctionGame(){const[history,setHistory]=useState([Array(9).fill(null)]);const[currentMove,setCurrentMove]=useState(0);constxIsNext=currentMove%2===0;constcurrentSquares=history[currentMove];functionhandlePlay(nextSquares){constnextHistory=[...history.slice(0,currentMove+1),nextSquares];setHistory(nextHistory);setCurrentMove(nextHistory.length-1);}functionjumpTo(nextMove){setCurrentMove(nextMove);}constmoves=history.map((squares,move)=>{letdescription;if(move>0){description='Go to move #'+move;}else{description='Go to game start';}return(<likey={move}><buttononClick={()=>jumpTo(move)}>{description}</button></li>);});return(<divclassName=\"game\"><divclassName=\"game-board\"><BoardxIsNext={xIsNext}squares={currentSquares}onPlay={handlePlay}/></div><divclassName=\"game-info\"><ol>{moves}</ol></div></div>);}functioncalculateWinner(squares){constlines=[[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6],];for(leti=0;i<lines.length;i++){const[a,b,c]=lines[i];if(squares[a]&&squares[a]===squares[b]&&squares[a]===squares[c]){returnsquares[a];}}returnnull;}"
                },
                {
                    "type": "p",
                    "text": "If you have extra time or want to practice your new React skills, here are some ideas for improvements that you could make to the tic-tac-toe game, listed in order of increasing difficulty:"
                },
                {
                    "type": "list",
                    "items": [
                        "For the current move only, show “You are at move #…” instead of a button.",
                        "RewriteBoardto use two loops to make the squares instead of hardcoding them.",
                        "Add a toggle button that lets you sort the moves in either ascending or descending order.",
                        "When someone wins, highlight the three squares that caused the win (and when no one wins, display a message about the result being a draw).",
                        "Display the location for each move in the format (row, col) in the move history list."
                    ]
                },
                {
                    "type": "p",
                    "text": "Throughout this tutorial, you’ve touched on React concepts including elements, components, props, and state. Now that you’ve seen how these concepts work when building a game, check outThinking in Reactto see how the same React concepts work when building an app’s UI."
                }
            ]
        },
        {
            "url": "https://react.dev/learn/typescript",
            "title": "Using TypeScript – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Using TypeScript"
                },
                {
                    "type": "p",
                    "text": "TypeScript is a popular way to add type definitions to JavaScript codebases. Out of the box, TypeScriptsupports JSXand you can get full React Web support by adding@types/reactand@types/react-domto your project."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "TypeScript with React Components",
                        "Examples of typing with Hooks",
                        "Common types from@types/react",
                        "Further learning locations"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Installation"
                },
                {
                    "type": "p",
                    "text": "Allproduction-grade React frameworksoffer support for using TypeScript. Follow the framework specific guide for installation:"
                },
                {
                    "type": "list",
                    "items": [
                        "Next.js",
                        "Remix",
                        "Gatsby",
                        "Expo"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Adding TypeScript to an existing React project"
                },
                {
                    "type": "p",
                    "text": "To install the latest version of React’s type definitions:"
                },
                {
                    "type": "p",
                    "text": "The following compiler options need to be set in yourtsconfig.json:"
                },
                {
                    "type": "list",
                    "items": [
                        "dommust be included inlib(Note: If noliboption is specified,domis included by default).",
                        "jsxmust be set to one of the valid options.preserveshould suffice for most applications.\nIf you’re publishing a library, consult thejsxdocumentationon what value to choose."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "TypeScript with React Components"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Every file containing JSX must use the.tsxfile extension. This is a TypeScript-specific extension that tells TypeScript that this file contains JSX."
                },
                {
                    "type": "p",
                    "text": "Writing TypeScript with React is very similar to writing JavaScript with React. The key difference when working with a component is that you can provide types for your component’s props. These types can be used for correctness checking and providing inline documentation in editors."
                },
                {
                    "type": "p",
                    "text": "Taking theMyButtoncomponentfrom theQuick Startguide, we can add a type describing thetitlefor the button:"
                },
                {
                    "type": "code",
                    "code": "functionMyButton({title}:{title:string}){return(<button>{title}</button>);}exportdefaultfunctionMyApp(){return(<div><h1>Welcome to my app</h1><MyButtontitle=\"I'm a button\"/></div>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "These sandboxes can handle TypeScript code, but they do not run the type-checker. This means you can amend the TypeScript sandboxes to learn, but you won’t get any type errors or warnings. To get type-checking, you can use theTypeScript Playgroundor use a more fully-featured online sandbox."
                },
                {
                    "type": "p",
                    "text": "This inline syntax is the simplest way to provide types for a component, though once you start to have a few fields to describe it can become unwieldy. Instead, you can use aninterfaceortypeto describe the component’s props:"
                },
                {
                    "type": "code",
                    "code": "interfaceMyButtonProps{/** The text to display inside the button */title:string;/** Whether the button can be interacted with */disabled:boolean;}functionMyButton({title,disabled}:MyButtonProps){return(<buttondisabled={disabled}>{title}</button>);}exportdefaultfunctionMyApp(){return(<div><h1>Welcome to my app</h1><MyButtontitle=\"I'm a disabled button\"disabled={true}/></div>);}"
                },
                {
                    "type": "p",
                    "text": "The type describing your component’s props can be as simple or as complex as you need, though they should be an object type described with either atypeorinterface. You can learn about how TypeScript describes objects inObject Typesbut you may also be interested in usingUnion Typesto describe a prop that can be one of a few different types and theCreating Types from Typesguide for more advanced use cases."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Example Hooks"
                },
                {
                    "type": "p",
                    "text": "The type definitions from@types/reactinclude types for the built-in Hooks, so you can use them in your components without any additional setup. They are built to take into account the code you write in your component, so you will getinferred typesa lot of the time and ideally do not need to handle the minutiae of providing the types."
                },
                {
                    "type": "p",
                    "text": "However, we can look at a few examples of how to provide types for Hooks."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useState"
                },
                {
                    "type": "p",
                    "text": "TheuseStateHookwill re-use the value passed in as the initial state to determine what the type of the value should be. For example:"
                },
                {
                    "type": "code",
                    "code": "// Infer the type as \"boolean\"const[enabled,setEnabled]=useState(false);"
                },
                {
                    "type": "p",
                    "text": "This will assign the type ofbooleantoenabled, andsetEnabledwill be a function accepting either abooleanargument, or a function that returns aboolean. If you want to explicitly provide a type for the state, you can do so by providing a type argument to theuseStatecall:"
                },
                {
                    "type": "code",
                    "code": "// Explicitly set the type to \"boolean\"const[enabled,setEnabled]=useState<boolean>(false);"
                },
                {
                    "type": "p",
                    "text": "This isn’t very useful in this case, but a common case where you may want to provide a type is when you have a union type. For example,statushere can be one of a few different strings:"
                },
                {
                    "type": "code",
                    "code": "typeStatus=\"idle\"|\"loading\"|\"success\"|\"error\";const[status,setStatus]=useState<Status>(\"idle\");"
                },
                {
                    "type": "p",
                    "text": "Or, as recommended inPrinciples for structuring state, you can group related state as an object and describe the different possibilities via object types:"
                },
                {
                    "type": "code",
                    "code": "typeRequestState=|{status:'idle'}|{status:'loading'}|{status:'success',data:any}|{status:'error',error:Error};const[requestState,setRequestState]=useState<RequestState>({status:'idle'});"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useReducer"
                },
                {
                    "type": "p",
                    "text": "TheuseReducerHookis a more complex Hook that takes a reducer function and an initial state. The types for the reducer function are inferred from the initial state. You can optionally provide a type argument to theuseReducercall to provide a type for the state, but it is often better to set the type on the initial state instead:"
                },
                {
                    "type": "code",
                    "code": "import{useReducer}from'react';interfaceState{count:number};typeCounterAction =\n  |{type:\"reset\"}|{type:\"setCount\";value:State[\"count\"]}constinitialState:State ={count:0};functionstateReducer(state:State,action:CounterAction):State{switch(action.type){case\"reset\":returninitialState;case\"setCount\":return{...state,count:action.value};default:thrownewError(\"Unknown action\");}}exportdefaultfunctionApp(){const[state,dispatch]=useReducer(stateReducer,initialState);constaddFive=()=>dispatch({type:\"setCount\",value:state.count+5});constreset=()=>dispatch({type:\"reset\"});return(<div><h1>Welcome to my counter</h1><p>Count:{state.count}</p><buttononClick={addFive}>Add 5</button><buttononClick={reset}>Reset</button></div>);}"
                },
                {
                    "type": "p",
                    "text": "We are using TypeScript in a few key places:"
                },
                {
                    "type": "list",
                    "items": [
                        "interface Statedescribes the shape of the reducer’s state.",
                        "type CounterActiondescribes the different actions which can be dispatched to the reducer.",
                        "const initialState: Stateprovides a type for the initial state, and also the type which is used byuseReducerby default.",
                        "stateReducer(state: State, action: CounterAction): Statesets the types for the reducer function’s arguments and return value."
                    ]
                },
                {
                    "type": "p",
                    "text": "A more explicit alternative to setting the type oninitialStateis to provide a type argument touseReducer:"
                },
                {
                    "type": "code",
                    "code": "import{stateReducer,State}from'./your-reducer-implementation';constinitialState={count:0};exportdefaultfunctionApp(){const[state,dispatch]=useReducer<State>(stateReducer,initialState);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useContext"
                },
                {
                    "type": "p",
                    "text": "TheuseContextHookis a technique for passing data down the component tree without having to pass props through components. It is used by creating a provider component and often by creating a Hook to consume the value in a child component."
                },
                {
                    "type": "p",
                    "text": "The type of the value provided by the context is inferred from the value passed to thecreateContextcall:"
                },
                {
                    "type": "code",
                    "code": "import{createContext,useContext,useState}from'react';typeTheme =\"light\"|\"dark\"|\"system\";constThemeContext=createContext<Theme>(\"system\");constuseGetTheme=()=>useContext(ThemeContext);exportdefaultfunctionMyApp(){const[theme,setTheme]=useState<Theme>('light');return(<ThemeContext.Providervalue={theme}><MyComponent/></ThemeContext.Provider>)}functionMyComponent(){consttheme=useGetTheme();return(<div><p>Current theme:{theme}</p></div>)}"
                },
                {
                    "type": "p",
                    "text": "This technique works when you have a default value which makes sense - but there are occasionally cases when you do not, and in those casesnullcan feel reasonable as a default value. However, to allow the type-system to understand your code, you need to explicitly setContextShape | nullon thecreateContext."
                },
                {
                    "type": "p",
                    "text": "This causes the issue that you need to eliminate the| nullin the type for context consumers. Our recommendation is to have the Hook do a runtime check for it’s existence and throw an error when not present:"
                },
                {
                    "type": "code",
                    "code": "import{createContext,useContext,useState,useMemo}from'react';// This is a simpler example, but you can imagine a more complex object heretypeComplexObject={kind:string};// The context is created with `| null` in the type, to accurately reflect the default value.constContext=createContext<ComplexObject|null>(null);// The `| null` will be removed via the check in the Hook.constuseGetComplexObject=()=>{constobject=useContext(Context);if(!object){thrownewError(\"useGetComplexObject must be used within a Provider\")}returnobject;}exportdefaultfunctionMyApp(){constobject=useMemo(()=>({kind:\"complex\"}),[]);return(<Context.Providervalue={object}><MyComponent/></Context.Provider>)}functionMyComponent(){constobject=useGetComplexObject();return(<div><p>Current object:{object.kind}</p></div>)}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useMemo"
                },
                {
                    "type": "p",
                    "text": "TheuseMemoHooks will create/re-access a memorized value from a function call, re-running the function only when dependencies passed as the 2nd parameter are changed. The result of calling the Hook is inferred from the return value from the function in the first parameter. You can be more explicit by providing a type argument to the Hook."
                },
                {
                    "type": "code",
                    "code": "// The type of visibleTodos is inferred from the return value of filterTodosconstvisibleTodos=useMemo(()=>filterTodos(todos,tab),[todos,tab]);"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useCallback"
                },
                {
                    "type": "p",
                    "text": "TheuseCallbackprovide a stable reference to a function as long as the dependencies passed into the second parameter are the same. LikeuseMemo, the function’s type is inferred from the return value of the function in the first parameter, and you can be more explicit by providing a type argument to the Hook."
                },
                {
                    "type": "code",
                    "code": "consthandleClick=useCallback(()=>{// ...},[todos]);"
                },
                {
                    "type": "p",
                    "text": "When working in TypeScript strict modeuseCallbackrequires adding types for the parameters in your callback. This is because the type of the callback is inferred from the return value of the function, and without parameters the type cannot be fully understood."
                },
                {
                    "type": "p",
                    "text": "Depending on your code-style preferences, you could use the*EventHandlerfunctions from the React types to provide the type for the event handler at the same time as defining the callback:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useCallback}from'react';exportdefaultfunctionForm(){const[value,setValue]=useState(\"Change me\");consthandleChange=useCallback<React.ChangeEventHandler<HTMLInputElement>>((event)=>{setValue(event.currentTarget.value);},[setValue])return(<><inputvalue={value}onChange={handleChange}/><p>Value:{value}</p></>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Useful Types"
                },
                {
                    "type": "p",
                    "text": "There is quite an expansive set of types which come from the@types/reactpackage, it is worth a read when you feel comfortable with how React and TypeScript interact. You can find themin React’s folder in DefinitelyTyped. We will cover a few of the more common types here."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "DOM Events"
                },
                {
                    "type": "p",
                    "text": "When working with DOM events in React, the type of the event can often be inferred from the event handler. However, when you want to extract a function to be passed to an event handler, you will need to explicitly set the type of the event."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionForm(){const[value,setValue]=useState(\"Change me\");functionhandleChange(event:React.ChangeEvent<HTMLInputElement>){setValue(event.currentTarget.value);}return(<><inputvalue={value}onChange={handleChange}/><p>Value:{value}</p></>);}"
                },
                {
                    "type": "p",
                    "text": "There are many types of events provided in the React types - the full list can be foundherewhich is based on themost popular events from the DOM."
                },
                {
                    "type": "p",
                    "text": "When determining the type you are looking for you can first look at the hover information for the event handler you are using, which will show the type of the event."
                },
                {
                    "type": "p",
                    "text": "If you need to use an event that is not included in this list, you can use theReact.SyntheticEventtype, which is the base type for all events."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Children"
                },
                {
                    "type": "p",
                    "text": "There are two common paths to describing the children of a component. The first is to use theReact.ReactNodetype, which is a union of all the possible types that can be passed as children in JSX:"
                },
                {
                    "type": "code",
                    "code": "interfaceModalRendererProps{title:string;children:React.ReactNode;}"
                },
                {
                    "type": "p",
                    "text": "This is a very broad definition of children. The second is to use theReact.ReactElementtype, which is only JSX elements and not JavaScript primitives like strings or numbers:"
                },
                {
                    "type": "code",
                    "code": "interfaceModalRendererProps{title:string;children:React.ReactElement;}"
                },
                {
                    "type": "p",
                    "text": "Note, that you cannot use TypeScript to describe that the children are a certain type of JSX elements, so you cannot use the type-system to describe a component which only accepts<li>children."
                },
                {
                    "type": "p",
                    "text": "You can see an example of bothReact.ReactNodeandReact.ReactElementwith the type-checker inthis TypeScript playground."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Style Props"
                },
                {
                    "type": "p",
                    "text": "When using inline styles in React, you can useReact.CSSPropertiesto describe the object passed to thestyleprop. This type is a union of all the possible CSS properties, and is a good way to ensure you are passing valid CSS properties to thestyleprop, and to get auto-complete in your editor."
                },
                {
                    "type": "code",
                    "code": "interfaceMyComponentProps{style:React.CSSProperties;}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Further learning"
                },
                {
                    "type": "p",
                    "text": "This guide has covered the basics of using TypeScript with React, but there is a lot more to learn.\nIndividual API pages on the docs may contain more in-depth documentation on how to use them with TypeScript."
                },
                {
                    "type": "p",
                    "text": "We recommend the following resources:"
                },
                {
                    "type": "list",
                    "items": [
                        "The TypeScript handbookis the official documentation for TypeScript, and covers most key language features.",
                        "The TypeScript release notescover new features in depth.",
                        "React TypeScript Cheatsheetis a community-maintained cheatsheet for using TypeScript with React, covering a lot of useful edge cases and providing more breadth than this document.",
                        "TypeScript Community Discordis a great place to ask questions and get help with TypeScript and React issues."
                    ]
                },
                {
                    "type": "p",
                    "text": "The TypeScript handbookis the official documentation for TypeScript, and covers most key language features."
                },
                {
                    "type": "p",
                    "text": "The TypeScript release notescover new features in depth."
                },
                {
                    "type": "p",
                    "text": "React TypeScript Cheatsheetis a community-maintained cheatsheet for using TypeScript with React, covering a lot of useful edge cases and providing more breadth than this document."
                },
                {
                    "type": "p",
                    "text": "TypeScript Community Discordis a great place to ask questions and get help with TypeScript and React issues."
                }
            ]
        },
        {
            "url": "https://react.dev/learn/understanding-your-ui-as-a-tree",
            "title": "Understanding Your UI as a Tree – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Understanding Your UI as a Tree"
                },
                {
                    "type": "p",
                    "text": "Your React app is taking shape with many components being nested within each other. How does React keep track of your app’s component structure?"
                },
                {
                    "type": "p",
                    "text": "React, and many other UI libraries, model UI as a tree. Thinking of your app as a tree is useful for understanding the relationship between components. This understanding will help you debug future concepts like performance and state management."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "How React “sees” component structures",
                        "What a render tree is and what it is useful for",
                        "What a module dependency tree is and what it is useful for"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Your UI as a tree"
                },
                {
                    "type": "p",
                    "text": "Trees are a relationship model between items and UI is often represented using tree structures. For example, browsers use tree structures to model HTML (DOM) and CSS (CSSOM). Mobile platforms also use trees to represent their view hierarchy."
                },
                {
                    "type": "p",
                    "text": "React creates a UI tree from your components. In this example, the UI tree is then used to render to the DOM."
                },
                {
                    "type": "p",
                    "text": "Like browsers and mobile platforms, React also uses tree structures to manage and model the relationship between components in a React app. These trees are useful tools to understand how data flows through a React app and how to optimize rendering and app size."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "The Render Tree"
                },
                {
                    "type": "p",
                    "text": "A major feature of components is the ability to compose components of other components. As wenest components, we have the concept of parent and child components, where each parent component may itself be a child of another component."
                },
                {
                    "type": "p",
                    "text": "When we render a React app, we can model this relationship in a tree, known as the render tree."
                },
                {
                    "type": "p",
                    "text": "Here is a React app that renders inspirational quotes."
                },
                {
                    "type": "code",
                    "code": "importFancyTextfrom'./FancyText';importInspirationGeneratorfrom'./InspirationGenerator';importCopyrightfrom'./Copyright';exportdefaultfunctionApp(){return(<><FancyTexttitletext=\"Get Inspired App\"/><InspirationGenerator><Copyrightyear={2004}/></InspirationGenerator></>);}"
                },
                {
                    "type": "p",
                    "text": "React creates arender tree, a UI tree, composed of the rendered components."
                },
                {
                    "type": "p",
                    "text": "From the example app, we can construct the above render tree."
                },
                {
                    "type": "p",
                    "text": "The tree is composed of nodes, each of which represents a component.App,FancyText,Copyright, to name a few, are all nodes in our tree."
                },
                {
                    "type": "p",
                    "text": "The root node in a React render tree is theroot componentof the app. In this case, the root component isAppand it is the first component React renders. Each arrow in the tree points from a parent component to a child component."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Where are the HTML tags in the render tree?"
                },
                {
                    "type": "p",
                    "text": "You’ll notice in the above render tree, there is no mention of the HTML tags that each component renders. This is because the render tree is only composed of Reactcomponents."
                },
                {
                    "type": "p",
                    "text": "React, as a UI framework, is platform agnostic. On react.dev, we showcase examples that render to the web, which uses HTML markup as its UI primitives. But a React app could just as likely render to a mobile or desktop platform, which may use different UI primitives likeUIVieworFrameworkElement."
                },
                {
                    "type": "p",
                    "text": "These platform UI primitives are not a part of React. React render trees can provide insight to our React app regardless of what platform your app renders to."
                },
                {
                    "type": "p",
                    "text": "A render tree represents a single render pass of a React application. Withconditional rendering, a parent component may render different children depending on the data passed."
                },
                {
                    "type": "p",
                    "text": "We can update the app to conditionally render either an inspirational quote or color."
                },
                {
                    "type": "code",
                    "code": "importFancyTextfrom'./FancyText';importInspirationGeneratorfrom'./InspirationGenerator';importCopyrightfrom'./Copyright';exportdefaultfunctionApp(){return(<><FancyTexttitletext=\"Get Inspired App\"/><InspirationGenerator><Copyrightyear={2004}/></InspirationGenerator></>);}"
                },
                {
                    "type": "p",
                    "text": "With conditional rendering, across different renders, the render tree may render different components."
                },
                {
                    "type": "p",
                    "text": "In this example, depending on whatinspiration.typeis, we may render<FancyText>or<Color>. The render tree may be different for each render pass."
                },
                {
                    "type": "p",
                    "text": "Although render trees may differ across render passes, these trees are generally helpful for identifying what thetop-levelandleaf componentsare in a React app. Top-level components are the components nearest to the root component and affect the rendering performance of all the components beneath them and often contain the most complexity. Leaf components are near the bottom of the tree and have no child components and are often frequently re-rendered."
                },
                {
                    "type": "p",
                    "text": "Identifying these categories of components are useful for understanding data flow and performance of your app."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "The Module Dependency Tree"
                },
                {
                    "type": "p",
                    "text": "Another relationship in a React app that can be modeled with a tree are an app’s module dependencies. As webreak up our componentsand logic into separate files, we createJS moduleswhere we may export components, functions, or constants."
                },
                {
                    "type": "p",
                    "text": "Each node in a module dependency tree is a module and each branch represents animportstatement in that module."
                },
                {
                    "type": "p",
                    "text": "If we take the previous Inspirations app, we can build a module dependency tree, or dependency tree for short."
                },
                {
                    "type": "p",
                    "text": "The module dependency tree for the Inspirations app."
                },
                {
                    "type": "p",
                    "text": "The root node of the tree is the root module, also known as the entrypoint file. It often is the module that contains the root component."
                },
                {
                    "type": "p",
                    "text": "Comparing to the render tree of the same app, there are similar structures but some notable differences:"
                },
                {
                    "type": "list",
                    "items": [
                        "The nodes that make-up the tree represent modules, not components.",
                        "Non-component modules, likeinspirations.js, are also represented in this tree. The render tree only encapsulates components.",
                        "Copyright.jsappears underApp.jsbut in the render tree,Copyright, the component, appears as a child ofInspirationGenerator. This is becauseInspirationGeneratoraccepts JSX aschildren props, so it rendersCopyrightas a child component but does not import the module."
                    ]
                },
                {
                    "type": "p",
                    "text": "Dependency trees are useful to determine what modules are necessary to run your React app. When building a React app for production, there is typically a build step that will bundle all the necessary JavaScript to ship to the client. The tool responsible for this is called abundler, and bundlers will use the dependency tree to determine what modules should be included."
                },
                {
                    "type": "p",
                    "text": "As your app grows, often the bundle size does too. Large bundle sizes are expensive for a client to download and run. Large bundle sizes can delay the time for your UI to get drawn. Getting a sense of your app’s dependency tree may help with debugging these issues."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "Trees are a common way to represent the relationship between entities. They are often used to model UI.",
                        "Render trees represent the nested relationship between React components across a single render.",
                        "With conditional rendering, the render tree may change across different renders. With different prop values, components may render different children components.",
                        "Render trees help identify what the top-level and leaf components are. Top-level components affect the rendering performance of all components beneath them and leaf components are often re-rendered frequently. Identifying them is useful for understanding and debugging rendering performance.",
                        "Dependency trees represent the module dependencies in a React app.",
                        "Dependency trees are used by build tools to bundle the necessary code to ship an app.",
                        "Dependency trees are useful for debugging large bundle sizes that slow time to paint and expose opportunities for optimizing what code is bundled."
                    ]
                }
            ]
        },
        {
            "url": "https://react.dev/learn/updating-arrays-in-state",
            "title": "Updating Arrays in State – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Updating Arrays in State"
                },
                {
                    "type": "p",
                    "text": "Arrays are mutable in JavaScript, but you should treat them as immutable when you store them in state. Just like with objects, when you want to update an array stored in state, you need to create a new one (or make a copy of an existing one), and then set state to use the new array."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "How to add, remove, or change items in an array in React state",
                        "How to update an object inside of an array",
                        "How to make array copying less repetitive with Immer"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Updating arrays without mutation"
                },
                {
                    "type": "p",
                    "text": "In JavaScript, arrays are just another kind of object.Like with objects,you should treat arrays in React state as read-only.This means that you shouldn’t reassign items inside an array likearr[0] = 'bird', and you also shouldn’t use methods that mutate the array, such aspush()andpop()."
                },
                {
                    "type": "p",
                    "text": "Instead, every time you want to update an array, you’ll want to pass anewarray to your state setting function. To do that, you can create a new array from the original array in your state by calling its non-mutating methods likefilter()andmap(). Then you can set your state to the resulting new array."
                },
                {
                    "type": "p",
                    "text": "Here is a reference table of common array operations. When dealing with arrays inside React state, you will need to avoid the methods in the left column, and instead prefer the methods in the right column:"
                },
                {
                    "type": "p",
                    "text": "Alternatively, you canuse Immerwhich lets you use methods from both columns."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Unfortunately,sliceandspliceare named similarly but are very different:"
                },
                {
                    "type": "list",
                    "items": [
                        "slicelets you copy an array or a part of it.",
                        "splicemutatesthe array (to insert or delete items)."
                    ]
                },
                {
                    "type": "p",
                    "text": "In React, you will be usingslice(nop!) a lot more often because you don’t want to mutate objects or arrays in state.Updating Objectsexplains what mutation is and why it’s not recommended for state."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Adding to an array"
                },
                {
                    "type": "p",
                    "text": "push()will mutate an array, which you don’t want:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';letnextId=0;exportdefaultfunctionList(){const[name,setName]=useState('');const[artists,setArtists]=useState([]);return(<><h1>Inspiring sculptors:</h1><inputvalue={name}onChange={e=>setName(e.target.value)}/><buttononClick={()=>{artists.push({id:nextId++,name:name,});}}>Add</button><ul>{artists.map(artist=>(<likey={artist.id}>{artist.name}</li>))}</ul></>);}"
                },
                {
                    "type": "p",
                    "text": "Instead, create anewarray which contains the existing itemsanda new item at the end. There are multiple ways to do this, but the easiest one is to use the...array spreadsyntax:"
                },
                {
                    "type": "code",
                    "code": "setArtists(// Replace the state[// with a new array...artists,// that contains all the old items{id:nextId++,name:name}// and one new item at the end]);"
                },
                {
                    "type": "p",
                    "text": "Now it works correctly:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';letnextId=0;exportdefaultfunctionList(){const[name,setName]=useState('');const[artists,setArtists]=useState([]);return(<><h1>Inspiring sculptors:</h1><inputvalue={name}onChange={e=>setName(e.target.value)}/><buttononClick={()=>{setArtists([...artists,{id:nextId++,name:name}]);}}>Add</button><ul>{artists.map(artist=>(<likey={artist.id}>{artist.name}</li>))}</ul></>);}"
                },
                {
                    "type": "p",
                    "text": "The array spread syntax also lets you prepend an item by placing itbeforethe original...artists:"
                },
                {
                    "type": "code",
                    "code": "setArtists([{id:nextId++,name:name},...artists// Put old items at the end]);"
                },
                {
                    "type": "p",
                    "text": "In this way, spread can do the job of bothpush()by adding to the end of an array andunshift()by adding to the beginning of an array. Try it in the sandbox above!"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Removing from an array"
                },
                {
                    "type": "p",
                    "text": "The easiest way to remove an item from an array is tofilter it out. In other words, you will produce a new array that will not contain that item. To do this, use thefiltermethod, for example:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';letinitialArtists=[{id:0,name:'Marta Colvin Andrade'},{id:1,name:'Lamidi Olonade Fakeye'},{id:2,name:'Louise Nevelson'},];exportdefaultfunctionList(){const[artists,setArtists]=useState(initialArtists);return(<><h1>Inspiring sculptors:</h1><ul>{artists.map(artist=>(<likey={artist.id}>{artist.name}{' '}<buttononClick={()=>{setArtists(artists.filter(a=>a.id!==artist.id));}}>Delete</button></li>))}</ul></>);}"
                },
                {
                    "type": "p",
                    "text": "Click the “Delete” button a few times, and look at its click handler."
                },
                {
                    "type": "code",
                    "code": "setArtists(artists.filter(a=>a.id!==artist.id));"
                },
                {
                    "type": "p",
                    "text": "Here,artists.filter(a => a.id !== artist.id)means “create an array that consists of thoseartistswhose IDs are different fromartist.id”. In other words, each artist’s “Delete” button will filterthatartist out of the array, and then request a re-render with the resulting array. Note thatfilterdoes not modify the original array."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Transforming an array"
                },
                {
                    "type": "p",
                    "text": "If you want to change some or all items of the array, you can usemap()to create anewarray. The function you will pass tomapcan decide what to do with each item, based on its data or its index (or both)."
                },
                {
                    "type": "p",
                    "text": "In this example, an array holds coordinates of two circles and a square. When you press the button, it moves only the circles down by 50 pixels. It does this by producing a new array of data usingmap():"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';letinitialShapes=[{id:0,type:'circle',x:50,y:100},{id:1,type:'square',x:150,y:100},{id:2,type:'circle',x:250,y:100},];exportdefaultfunctionShapeEditor(){const[shapes,setShapes]=useState(initialShapes);functionhandleClick(){constnextShapes=shapes.map(shape=>{if(shape.type==='square'){// No changereturnshape;}else{// Return a new circle 50px belowreturn{...shape,y:shape.y+50,};}});// Re-render with the new arraysetShapes(nextShapes);}return(<><buttononClick={handleClick}>Move circles down!</button>{shapes.map(shape=>(<divkey={shape.id}style={{background:'purple',position:'absolute',left:shape.x,top:shape.y,borderRadius:shape.type==='circle'?'50%':'',width:20,height:20,}}/>))}</>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Replacing items in an array"
                },
                {
                    "type": "p",
                    "text": "It is particularly common to want to replace one or more items in an array. Assignments likearr[0] = 'bird'are mutating the original array, so instead you’ll want to usemapfor this as well."
                },
                {
                    "type": "p",
                    "text": "To replace an item, create a new array withmap. Inside yourmapcall, you will receive the item index as the second argument. Use it to decide whether to return the original item (the first argument) or something else:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';letinitialCounters=[0,0,0];exportdefaultfunctionCounterList(){const[counters,setCounters]=useState(initialCounters);functionhandleIncrementClick(index){constnextCounters=counters.map((c,i)=>{if(i===index){// Increment the clicked counterreturnc+1;}else{// The rest haven't changedreturnc;}});setCounters(nextCounters);}return(<ul>{counters.map((counter,i)=>(<likey={i}>{counter}<buttononClick={()=>{handleIncrementClick(i);}}>+1</button></li>))}</ul>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Inserting into an array"
                },
                {
                    "type": "p",
                    "text": "Sometimes, you may want to insert an item at a particular position that’s neither at the beginning nor at the end. To do this, you can use the...array spread syntax together with theslice()method. Theslice()method lets you cut a “slice” of the array. To insert an item, you will create an array that spreads the slicebeforethe insertion point, then the new item, and then the rest of the original array."
                },
                {
                    "type": "p",
                    "text": "In this example, the Insert button always inserts at the index1:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';letnextId=3;constinitialArtists=[{id:0,name:'Marta Colvin Andrade'},{id:1,name:'Lamidi Olonade Fakeye'},{id:2,name:'Louise Nevelson'},];exportdefaultfunctionList(){const[name,setName]=useState('');const[artists,setArtists]=useState(initialArtists);functionhandleClick(){constinsertAt=1;// Could be any indexconstnextArtists=[// Items before the insertion point:...artists.slice(0,insertAt),// New item:{id:nextId++,name:name},// Items after the insertion point:...artists.slice(insertAt)];setArtists(nextArtists);setName('');}return(<><h1>Inspiring sculptors:</h1><inputvalue={name}onChange={e=>setName(e.target.value)}/><buttononClick={handleClick}>Insert</button><ul>{artists.map(artist=>(<likey={artist.id}>{artist.name}</li>))}</ul></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Making other changes to an array"
                },
                {
                    "type": "p",
                    "text": "There are some things you can’t do with the spread syntax and non-mutating methods likemap()andfilter()alone. For example, you may want to reverse or sort an array. The JavaScriptreverse()andsort()methods are mutating the original array, so you can’t use them directly."
                },
                {
                    "type": "p",
                    "text": "However, you can copy the array first, and then make changes to it."
                },
                {
                    "type": "p",
                    "text": "For example:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';constinitialList=[{id:0,title:'Big Bellies'},{id:1,title:'Lunar Landscape'},{id:2,title:'Terracotta Army'},];exportdefaultfunctionList(){const[list,setList]=useState(initialList);functionhandleClick(){constnextList=[...list];nextList.reverse();setList(nextList);}return(<><buttononClick={handleClick}>Reverse</button><ul>{list.map(artwork=>(<likey={artwork.id}>{artwork.title}</li>))}</ul></>);}"
                },
                {
                    "type": "p",
                    "text": "Here, you use the[...list]spread syntax to create a copy of the original array first. Now that you have a copy, you can use mutating methods likenextList.reverse()ornextList.sort(), or even assign individual items withnextList[0] = \"something\"."
                },
                {
                    "type": "p",
                    "text": "However,even if you copy an array, you can’t mutate existing itemsinsideof it directly.This is because copying is shallow—the new array will contain the same items as the original one. So if you modify an object inside the copied array, you are mutating the existing state. For example, code like this is a problem."
                },
                {
                    "type": "code",
                    "code": "constnextList=[...list];nextList[0].seen=true;// Problem: mutates list[0]setList(nextList);"
                },
                {
                    "type": "p",
                    "text": "AlthoughnextListandlistare two different arrays,nextList[0]andlist[0]point to the same object.So by changingnextList[0].seen, you are also changinglist[0].seen. This is a state mutation, which you should avoid! You can solve this issue in a similar way toupdating nested JavaScript objects—by copying individual items you want to change instead of mutating them. Here’s how."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Updating objects inside arrays"
                },
                {
                    "type": "p",
                    "text": "Objects are notreallylocated “inside” arrays. They might appear to be “inside” in code, but each object in an array is a separate value, to which the array “points”. This is why you need to be careful when changing nested fields likelist[0]. Another person’s artwork list may point to the same element of the array!"
                },
                {
                    "type": "p",
                    "text": "When updating nested state, you need to create copies from the point where you want to update, and all the way up to the top level.Let’s see how this works."
                },
                {
                    "type": "p",
                    "text": "In this example, two separate artwork lists have the same initial state. They are supposed to be isolated, but because of a mutation, their state is accidentally shared, and checking a box in one list affects the other list:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';letnextId=3;constinitialList=[{id:0,title:'Big Bellies',seen:false},{id:1,title:'Lunar Landscape',seen:false},{id:2,title:'Terracotta Army',seen:true},];exportdefaultfunctionBucketList(){const[myList,setMyList]=useState(initialList);const[yourList,setYourList]=useState(initialList);functionhandleToggleMyList(artworkId,nextSeen){constmyNextList=[...myList];constartwork=myNextList.find(a=>a.id===artworkId);artwork.seen=nextSeen;setMyList(myNextList);}functionhandleToggleYourList(artworkId,nextSeen){constyourNextList=[...yourList];constartwork=yourNextList.find(a=>a.id===artworkId);artwork.seen=nextSeen;setYourList(yourNextList);}return(<><h1>Art Bucket List</h1><h2>My list of art to see:</h2><ItemListartworks={myList}onToggle={handleToggleMyList}/><h2>Your list of art to see:</h2><ItemListartworks={yourList}onToggle={handleToggleYourList}/></>);}functionItemList({artworks,onToggle}){return(<ul>{artworks.map(artwork=>(<likey={artwork.id}><label><inputtype=\"checkbox\"checked={artwork.seen}onChange={e=>{onToggle(artwork.id,e.target.checked);}}/>{artwork.title}</label></li>))}</ul>);}"
                },
                {
                    "type": "p",
                    "text": "The problem is in code like this:"
                },
                {
                    "type": "code",
                    "code": "constmyNextList=[...myList];constartwork=myNextList.find(a=>a.id===artworkId);artwork.seen=nextSeen;// Problem: mutates an existing itemsetMyList(myNextList);"
                },
                {
                    "type": "p",
                    "text": "Although themyNextListarray itself is new, theitems themselvesare the same as in the originalmyListarray. So changingartwork.seenchanges theoriginalartwork item. That artwork item is also inyourList, which causes the bug. Bugs like this can be difficult to think about, but thankfully they disappear if you avoid mutating state."
                },
                {
                    "type": "p",
                    "text": "You can usemapto substitute an old item with its updated version without mutation."
                },
                {
                    "type": "code",
                    "code": "setMyList(myList.map(artwork=>{if(artwork.id===artworkId){// Create a *new* object with changesreturn{...artwork,seen:nextSeen};}else{// No changesreturnartwork;}}));"
                },
                {
                    "type": "p",
                    "text": "Here,...is the object spread syntax used tocreate a copy of an object."
                },
                {
                    "type": "p",
                    "text": "With this approach, none of the existing state items are being mutated, and the bug is fixed:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';letnextId=3;constinitialList=[{id:0,title:'Big Bellies',seen:false},{id:1,title:'Lunar Landscape',seen:false},{id:2,title:'Terracotta Army',seen:true},];exportdefaultfunctionBucketList(){const[myList,setMyList]=useState(initialList);const[yourList,setYourList]=useState(initialList);functionhandleToggleMyList(artworkId,nextSeen){setMyList(myList.map(artwork=>{if(artwork.id===artworkId){// Create a *new* object with changesreturn{...artwork,seen:nextSeen};}else{// No changesreturnartwork;}}));}functionhandleToggleYourList(artworkId,nextSeen){setYourList(yourList.map(artwork=>{if(artwork.id===artworkId){// Create a *new* object with changesreturn{...artwork,seen:nextSeen};}else{// No changesreturnartwork;}}));}return(<><h1>Art Bucket List</h1><h2>My list of art to see:</h2><ItemListartworks={myList}onToggle={handleToggleMyList}/><h2>Your list of art to see:</h2><ItemListartworks={yourList}onToggle={handleToggleYourList}/></>);}functionItemList({artworks,onToggle}){return(<ul>{artworks.map(artwork=>(<likey={artwork.id}><label><inputtype=\"checkbox\"checked={artwork.seen}onChange={e=>{onToggle(artwork.id,e.target.checked);}}/>{artwork.title}</label></li>))}</ul>);}"
                },
                {
                    "type": "p",
                    "text": "In general,you should only mutate objects that you have just created.If you were inserting anewartwork, you could mutate it, but if you’re dealing with something that’s already in state, you need to make a copy."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Write concise update logic with Immer"
                },
                {
                    "type": "p",
                    "text": "Updating nested arrays without mutation can get a little bit repetitive.Just as with objects:"
                },
                {
                    "type": "list",
                    "items": [
                        "Generally, you shouldn’t need to update state more than a couple of levels deep. If your state objects are very deep, you might want torestructure them differentlyso that they are flat.",
                        "If you don’t want to change your state structure, you might prefer to useImmer, which lets you write using the convenient but mutating syntax and takes care of producing the copies for you."
                    ]
                },
                {
                    "type": "p",
                    "text": "Here is the Art Bucket List example rewritten with Immer:"
                },
                {
                    "type": "code",
                    "code": "{\"dependencies\":{\"immer\":\"1.7.3\",\"react\":\"latest\",\"react-dom\":\"latest\",\"react-scripts\":\"latest\",\"use-immer\":\"0.5.1\"},\"scripts\":{\"start\":\"react-scripts start\",\"build\":\"react-scripts build\",\"test\":\"react-scripts test --env=jsdom\",\"eject\":\"react-scripts eject\"},\"devDependencies\":{}}"
                },
                {
                    "type": "p",
                    "text": "Note how with Immer,mutation likeartwork.seen = nextSeenis now okay:"
                },
                {
                    "type": "code",
                    "code": "updateMyTodos(draft=>{constartwork=draft.find(a=>a.id===artworkId);artwork.seen=nextSeen;});"
                },
                {
                    "type": "p",
                    "text": "This is because you’re not mutating theoriginalstate, but you’re mutating a specialdraftobject provided by Immer. Similarly, you can apply mutating methods likepush()andpop()to the content of thedraft."
                },
                {
                    "type": "p",
                    "text": "Behind the scenes, Immer always constructs the next state from scratch according to the changes that you’ve done to thedraft. This keeps your event handlers very concise without ever mutating state."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "You can put arrays into state, but you can’t change them.",
                        "Instead of mutating an array, create anewversion of it, and update the state to it.",
                        "You can use the[...arr, newItem]array spread syntax to create arrays with new items.",
                        "You can usefilter()andmap()to create new arrays with filtered or transformed items.",
                        "You can use Immer to keep your code concise."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of4:Update an item in the shopping cart"
                },
                {
                    "type": "p",
                    "text": "Fill in thehandleIncreaseClicklogic so that pressing ”+” increases the corresponding number:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';constinitialProducts=[{id:0,name:'Baklava',count:1,},{id:1,name:'Cheese',count:5,},{id:2,name:'Spaghetti',count:2,}];exportdefaultfunctionShoppingCart(){const[products,setProducts]=useState(initialProducts)functionhandleIncreaseClick(productId){}return(<ul>{products.map(product=>(<likey={product.id}>{product.name}{' '}(<b>{product.count}</b>)<buttononClick={()=>{handleIncreaseClick(product.id);}}>+</button></li>))}</ul>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/updating-objects-in-state",
            "title": "Updating Objects in State – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Updating Objects in State"
                },
                {
                    "type": "p",
                    "text": "State can hold any kind of JavaScript value, including objects. But you shouldn’t change objects that you hold in the React state directly. Instead, when you want to update an object, you need to create a new one (or make a copy of an existing one), and then set the state to use that copy."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "How to correctly update an object in React state",
                        "How to update a nested object without mutating it",
                        "What immutability is, and how not to break it",
                        "How to make object copying less repetitive with Immer"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "What’s a mutation?"
                },
                {
                    "type": "p",
                    "text": "You can store any kind of JavaScript value in state."
                },
                {
                    "type": "code",
                    "code": "const[x,setX]=useState(0);"
                },
                {
                    "type": "p",
                    "text": "So far you’ve been working with numbers, strings, and booleans. These kinds of JavaScript values are “immutable”, meaning unchangeable or “read-only”. You can trigger a re-render toreplacea value:"
                },
                {
                    "type": "code",
                    "code": "setX(5);"
                },
                {
                    "type": "p",
                    "text": "Thexstate changed from0to5, but thenumber0itselfdid not change. It’s not possible to make any changes to the built-in primitive values like numbers, strings, and booleans in JavaScript."
                },
                {
                    "type": "p",
                    "text": "Now consider an object in state:"
                },
                {
                    "type": "code",
                    "code": "const[position,setPosition]=useState({x:0,y:0});"
                },
                {
                    "type": "p",
                    "text": "Technically, it is possible to change the contents ofthe object itself.This is called a mutation:"
                },
                {
                    "type": "code",
                    "code": "position.x=5;"
                },
                {
                    "type": "p",
                    "text": "However, although objects in React state are technically mutable, you should treat themas ifthey were immutable—like numbers, booleans, and strings. Instead of mutating them, you should always replace them."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Treat state as read-only"
                },
                {
                    "type": "p",
                    "text": "In other words, you shouldtreat any JavaScript object that you put into state as read-only."
                },
                {
                    "type": "p",
                    "text": "This example holds an object in state to represent the current pointer position. The red dot is supposed to move when you touch or move the cursor over the preview area. But the dot stays in the initial position:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionMovingDot(){const[position,setPosition]=useState({x:0,y:0});return(<divonPointerMove={e=>{position.x=e.clientX;position.y=e.clientY;}}style={{position:'relative',width:'100vw',height:'100vh',}}><divstyle={{position:'absolute',backgroundColor:'red',borderRadius:'50%',transform:`translate(${position.x}px,${position.y}px)`,left:-10,top:-10,width:20,height:20,}}/></div>);}"
                },
                {
                    "type": "p",
                    "text": "The problem is with this bit of code."
                },
                {
                    "type": "code",
                    "code": "onPointerMove={e=>{position.x=e.clientX;position.y=e.clientY;}}"
                },
                {
                    "type": "p",
                    "text": "This code modifies the object assigned topositionfromthe previous render.But without using the state setting function, React has no idea that object has changed. So React does not do anything in response. It’s like trying to change the order after you’ve already eaten the meal. While mutating state can work in some cases, we don’t recommend it. You should treat the state value you have access to in a render as read-only."
                },
                {
                    "type": "p",
                    "text": "To actuallytrigger a re-renderin this case,create anewobject and pass it to the state setting function:"
                },
                {
                    "type": "code",
                    "code": "onPointerMove={e=>{setPosition({x:e.clientX,y:e.clientY});}}"
                },
                {
                    "type": "p",
                    "text": "WithsetPosition, you’re telling React:"
                },
                {
                    "type": "list",
                    "items": [
                        "Replacepositionwith this new object",
                        "And render this component again"
                    ]
                },
                {
                    "type": "p",
                    "text": "Notice how the red dot now follows your pointer when you touch or hover over the preview area:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionMovingDot(){const[position,setPosition]=useState({x:0,y:0});return(<divonPointerMove={e=>{setPosition({x:e.clientX,y:e.clientY});}}style={{position:'relative',width:'100vw',height:'100vh',}}><divstyle={{position:'absolute',backgroundColor:'red',borderRadius:'50%',transform:`translate(${position.x}px,${position.y}px)`,left:-10,top:-10,width:20,height:20,}}/></div>);}"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Local mutation is fine"
                },
                {
                    "type": "p",
                    "text": "Code like this is a problem because it modifies anexistingobject in state:"
                },
                {
                    "type": "code",
                    "code": "position.x=e.clientX;position.y=e.clientY;"
                },
                {
                    "type": "p",
                    "text": "But code like this isabsolutely finebecause you’re mutating a fresh object you havejust created:"
                },
                {
                    "type": "code",
                    "code": "constnextPosition={};nextPosition.x=e.clientX;nextPosition.y=e.clientY;setPosition(nextPosition);"
                },
                {
                    "type": "p",
                    "text": "In fact, it is completely equivalent to writing this:"
                },
                {
                    "type": "code",
                    "code": "setPosition({x:e.clientX,y:e.clientY});"
                },
                {
                    "type": "p",
                    "text": "Mutation is only a problem when you changeexistingobjects that are already in state. Mutating an object you’ve just created is okay becauseno other code references it yet.Changing it isn’t going to accidentally impact something that depends on it. This is called a “local mutation”. You can even do local mutationwhile rendering.Very convenient and completely okay!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Copying objects with the spread syntax"
                },
                {
                    "type": "p",
                    "text": "In the previous example, thepositionobject is always created fresh from the current cursor position. But often, you will want to includeexistingdata as a part of the new object you’re creating. For example, you may want to updateonly onefield in a form, but keep the previous values for all other fields."
                },
                {
                    "type": "p",
                    "text": "These input fields don’t work because theonChangehandlers mutate the state:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionForm(){const[person,setPerson]=useState({firstName:'Barbara',lastName:'Hepworth',email:'bhepworth@sculpture.com'});functionhandleFirstNameChange(e){person.firstName=e.target.value;}functionhandleLastNameChange(e){person.lastName=e.target.value;}functionhandleEmailChange(e){person.email=e.target.value;}return(<><label>First name:<inputvalue={person.firstName}onChange={handleFirstNameChange}/></label><label>Last name:<inputvalue={person.lastName}onChange={handleLastNameChange}/></label><label>Email:<inputvalue={person.email}onChange={handleEmailChange}/></label><p>{person.firstName}{' '}{person.lastName}{' '}({person.email})</p></>);}"
                },
                {
                    "type": "p",
                    "text": "For example, this line mutates the state from a past render:"
                },
                {
                    "type": "code",
                    "code": "person.firstName=e.target.value;"
                },
                {
                    "type": "p",
                    "text": "The reliable way to get the behavior you’re looking for is to create a new object and pass it tosetPerson. But here, you want to alsocopy the existing data into itbecause only one of the fields has changed:"
                },
                {
                    "type": "code",
                    "code": "setPerson({firstName:e.target.value,// New first name from the inputlastName:person.lastName,email:person.email});"
                },
                {
                    "type": "p",
                    "text": "You can use the...object spreadsyntax so that you don’t need to copy every property separately."
                },
                {
                    "type": "code",
                    "code": "setPerson({...person,// Copy the old fieldsfirstName:e.target.value// But override this one});"
                },
                {
                    "type": "p",
                    "text": "Now the form works!"
                },
                {
                    "type": "p",
                    "text": "Notice how you didn’t declare a separate state variable for each input field. For large forms, keeping all data grouped in an object is very convenient—as long as you update it correctly!"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionForm(){const[person,setPerson]=useState({firstName:'Barbara',lastName:'Hepworth',email:'bhepworth@sculpture.com'});functionhandleFirstNameChange(e){setPerson({...person,firstName:e.target.value});}functionhandleLastNameChange(e){setPerson({...person,lastName:e.target.value});}functionhandleEmailChange(e){setPerson({...person,email:e.target.value});}return(<><label>First name:<inputvalue={person.firstName}onChange={handleFirstNameChange}/></label><label>Last name:<inputvalue={person.lastName}onChange={handleLastNameChange}/></label><label>Email:<inputvalue={person.email}onChange={handleEmailChange}/></label><p>{person.firstName}{' '}{person.lastName}{' '}({person.email})</p></>);}"
                },
                {
                    "type": "p",
                    "text": "Note that the...spread syntax is “shallow”—it only copies things one level deep. This makes it fast, but it also means that if you want to update a nested property, you’ll have to use it more than once."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Using a single event handler for multiple fields"
                },
                {
                    "type": "p",
                    "text": "You can also use the[and]braces inside your object definition to specify a property with a dynamic name. Here is the same example, but with a single event handler instead of three different ones:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionForm(){const[person,setPerson]=useState({firstName:'Barbara',lastName:'Hepworth',email:'bhepworth@sculpture.com'});functionhandleChange(e){setPerson({...person,[e.target.name]:e.target.value});}return(<><label>First name:<inputname=\"firstName\"value={person.firstName}onChange={handleChange}/></label><label>Last name:<inputname=\"lastName\"value={person.lastName}onChange={handleChange}/></label><label>Email:<inputname=\"email\"value={person.email}onChange={handleChange}/></label><p>{person.firstName}{' '}{person.lastName}{' '}({person.email})</p></>);}"
                },
                {
                    "type": "p",
                    "text": "Here,e.target.namerefers to thenameproperty given to the<input>DOM element."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Updating a nested object"
                },
                {
                    "type": "p",
                    "text": "Consider a nested object structure like this:"
                },
                {
                    "type": "code",
                    "code": "const[person,setPerson]=useState({name:'Niki de Saint Phalle',artwork:{title:'Blue Nana',city:'Hamburg',image:'https://i.imgur.com/Sd1AgUOm.jpg',}});"
                },
                {
                    "type": "p",
                    "text": "If you wanted to updateperson.artwork.city, it’s clear how to do it with mutation:"
                },
                {
                    "type": "code",
                    "code": "person.artwork.city='New Delhi';"
                },
                {
                    "type": "p",
                    "text": "But in React, you treat state as immutable! In order to changecity, you would first need to produce the newartworkobject (pre-populated with data from the previous one), and then produce the newpersonobject which points at the newartwork:"
                },
                {
                    "type": "code",
                    "code": "constnextArtwork={...person.artwork,city:'New Delhi'};constnextPerson={...person,artwork:nextArtwork};setPerson(nextPerson);"
                },
                {
                    "type": "p",
                    "text": "Or, written as a single function call:"
                },
                {
                    "type": "code",
                    "code": "setPerson({...person,// Copy other fieldsartwork:{// but replace the artwork...person.artwork,// with the same onecity:'New Delhi'// but in New Delhi!}});"
                },
                {
                    "type": "p",
                    "text": "This gets a bit wordy, but it works fine for many cases:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionForm(){const[person,setPerson]=useState({name:'Niki de Saint Phalle',artwork:{title:'Blue Nana',city:'Hamburg',image:'https://i.imgur.com/Sd1AgUOm.jpg',}});functionhandleNameChange(e){setPerson({...person,name:e.target.value});}functionhandleTitleChange(e){setPerson({...person,artwork:{...person.artwork,title:e.target.value}});}functionhandleCityChange(e){setPerson({...person,artwork:{...person.artwork,city:e.target.value}});}functionhandleImageChange(e){setPerson({...person,artwork:{...person.artwork,image:e.target.value}});}return(<><label>Name:<inputvalue={person.name}onChange={handleNameChange}/></label><label>Title:<inputvalue={person.artwork.title}onChange={handleTitleChange}/></label><label>City:<inputvalue={person.artwork.city}onChange={handleCityChange}/></label><label>Image:<inputvalue={person.artwork.image}onChange={handleImageChange}/></label><p><i>{person.artwork.title}</i>{' by '}{person.name}<br/>(located in{person.artwork.city})</p><imgsrc={person.artwork.image}alt={person.artwork.title}/></>);}"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Objects are not really nested"
                },
                {
                    "type": "p",
                    "text": "An object like this appears “nested” in code:"
                },
                {
                    "type": "code",
                    "code": "letobj={name:'Niki de Saint Phalle',artwork:{title:'Blue Nana',city:'Hamburg',image:'https://i.imgur.com/Sd1AgUOm.jpg',}};"
                },
                {
                    "type": "p",
                    "text": "However, “nesting” is an inaccurate way to think about how objects behave. When the code executes, there is no such thing as a “nested” object. You are really looking at two different objects:"
                },
                {
                    "type": "code",
                    "code": "letobj1={title:'Blue Nana',city:'Hamburg',image:'https://i.imgur.com/Sd1AgUOm.jpg',};letobj2={name:'Niki de Saint Phalle',artwork:obj1};"
                },
                {
                    "type": "p",
                    "text": "Theobj1object is not “inside”obj2. For example,obj3could “point” atobj1too:"
                },
                {
                    "type": "code",
                    "code": "letobj1={title:'Blue Nana',city:'Hamburg',image:'https://i.imgur.com/Sd1AgUOm.jpg',};letobj2={name:'Niki de Saint Phalle',artwork:obj1};letobj3={name:'Copycat',artwork:obj1};"
                },
                {
                    "type": "p",
                    "text": "If you were to mutateobj3.artwork.city, it would affect bothobj2.artwork.cityandobj1.city. This is becauseobj3.artwork,obj2.artwork, andobj1are the same object. This is difficult to see when you think of objects as “nested”. Instead, they are separate objects “pointing” at each other with properties."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Write concise update logic with Immer"
                },
                {
                    "type": "p",
                    "text": "If your state is deeply nested, you might want to considerflattening it.But, if you don’t want to change your state structure, you might prefer a shortcut to nested spreads.Immeris a popular library that lets you write using the convenient but mutating syntax and takes care of producing the copies for you. With Immer, the code you write looks like you are “breaking the rules” and mutating an object:"
                },
                {
                    "type": "code",
                    "code": "updatePerson(draft=>{draft.artwork.city='Lagos';});"
                },
                {
                    "type": "p",
                    "text": "But unlike a regular mutation, it doesn’t overwrite the past state!"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "How does Immer work?"
                },
                {
                    "type": "p",
                    "text": "Thedraftprovided by Immer is a special type of object, called aProxy, that “records” what you do with it. This is why you can mutate it freely as much as you like! Under the hood, Immer figures out which parts of thedrafthave been changed, and produces a completely new object that contains your edits."
                },
                {
                    "type": "p",
                    "text": "To try Immer:"
                },
                {
                    "type": "list",
                    "items": [
                        "Runnpm install use-immerto add Immer as a dependency",
                        "Then replaceimport { useState } from 'react'withimport { useImmer } from 'use-immer'"
                    ]
                },
                {
                    "type": "p",
                    "text": "Here is the above example converted to Immer:"
                },
                {
                    "type": "code",
                    "code": "{\"dependencies\":{\"immer\":\"1.7.3\",\"react\":\"latest\",\"react-dom\":\"latest\",\"react-scripts\":\"latest\",\"use-immer\":\"0.5.1\"},\"scripts\":{\"start\":\"react-scripts start\",\"build\":\"react-scripts build\",\"test\":\"react-scripts test --env=jsdom\",\"eject\":\"react-scripts eject\"},\"devDependencies\":{}}"
                },
                {
                    "type": "p",
                    "text": "Notice how much more concise the event handlers have become. You can mix and matchuseStateanduseImmerin a single component as much as you like. Immer is a great way to keep the update handlers concise, especially if there’s nesting in your state, and copying objects leads to repetitive code."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Why is mutating state not recommended in React?"
                },
                {
                    "type": "p",
                    "text": "There are a few reasons:"
                },
                {
                    "type": "list",
                    "items": [
                        "Debugging:If you useconsole.logand don’t mutate state, your past logs won’t get clobbered by the more recent state changes. So you can clearly see how state has changed between renders.",
                        "Optimizations:Common Reactoptimization strategiesrely on skipping work if previous props or state are the same as the next ones. If you never mutate state, it is very fast to check whether there were any changes. IfprevObj === obj, you can be sure that nothing could have changed inside of it.",
                        "New Features:The new React features we’re building rely on state beingtreated like a snapshot.If you’re mutating past versions of state, that may prevent you from using the new features.",
                        "Requirement Changes:Some application features, like implementing Undo/Redo, showing a history of changes, or letting the user reset a form to earlier values, are easier to do when nothing is mutated. This is because you can keep past copies of state in memory, and reuse them when appropriate. If you start with a mutative approach, features like this can be difficult to add later on.",
                        "Simpler Implementation:Because React does not rely on mutation, it does not need to do anything special with your objects. It does not need to hijack their properties, always wrap them into Proxies, or do other work at initialization as many “reactive” solutions do. This is also why React lets you put any object into state—no matter how large—without additional performance or correctness pitfalls."
                    ]
                },
                {
                    "type": "p",
                    "text": "In practice, you can often “get away” with mutating state in React, but we strongly advise you not to do that so that you can use new React features developed with this approach in mind. Future contributors and perhaps even your future self will thank you!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "Treat all state in React as immutable.",
                        "When you store objects in state, mutating them will not trigger renders and will change the state in previous render “snapshots”.",
                        "Instead of mutating an object, create anewversion of it, and trigger a re-render by setting state to it.",
                        "You can use the{...obj, something: 'newValue'}object spread syntax to create copies of objects.",
                        "Spread syntax is shallow: it only copies one level deep.",
                        "To update a nested object, you need to create copies all the way up from the place you’re updating.",
                        "To reduce repetitive copying code, use Immer."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of3:Fix incorrect state updates"
                },
                {
                    "type": "p",
                    "text": "This form has a few bugs. Click the button that increases the score a few times. Notice that it does not increase. Then edit the first name, and notice that the score has suddenly “caught up” with your changes. Finally, edit the last name, and notice that the score has disappeared completely."
                },
                {
                    "type": "p",
                    "text": "Your task is to fix all of these bugs. As you fix them, explain why each of them happens."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionScoreboard(){const[player,setPlayer]=useState({firstName:'Ranjani',lastName:'Shettar',score:10,});functionhandlePlusClick(){player.score++;}functionhandleFirstNameChange(e){setPlayer({...player,firstName:e.target.value,});}functionhandleLastNameChange(e){setPlayer({lastName:e.target.value});}return(<><label>Score:<b>{player.score}</b>{' '}<buttononClick={handlePlusClick}>+1</button></label><label>First name:<inputvalue={player.firstName}onChange={handleFirstNameChange}/></label><label>Last name:<inputvalue={player.lastName}onChange={handleLastNameChange}/></label></>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/writing-markup-with-jsx",
            "title": "Writing Markup with JSX – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Writing Markup with JSX"
                },
                {
                    "type": "p",
                    "text": "JSXis a syntax extension for JavaScript that lets you write HTML-like markup inside a JavaScript file. Although there are other ways to write components, most React developers prefer the conciseness of JSX, and most codebases use it."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "Why React mixes markup with rendering logic",
                        "How JSX is different from HTML",
                        "How to display information with JSX"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "JSX: Putting markup into JavaScript"
                },
                {
                    "type": "p",
                    "text": "The Web has been built on HTML, CSS, and JavaScript. For many years, web developers kept content in HTML, design in CSS, and logic in JavaScript—often in separate files! Content was marked up inside HTML while the page’s logic lived separately in JavaScript:"
                },
                {
                    "type": "p",
                    "text": "HTML"
                },
                {
                    "type": "p",
                    "text": "JavaScript"
                },
                {
                    "type": "p",
                    "text": "But as the Web became more interactive, logic increasingly determined content. JavaScript was in charge of the HTML! This is whyin React, rendering logic and markup live together in the same place—components."
                },
                {
                    "type": "p",
                    "text": "Sidebar.jsReact component"
                },
                {
                    "type": "p",
                    "text": "Form.jsReact component"
                },
                {
                    "type": "p",
                    "text": "Keeping a button’s rendering logic and markup together ensures that they stay in sync with each other on every edit. Conversely, details that are unrelated, such as the button’s markup and a sidebar’s markup, are isolated from each other, making it safer to change either of them on their own."
                },
                {
                    "type": "p",
                    "text": "Each React component is a JavaScript function that may contain some markup that React renders into the browser. React components use a syntax extension called JSX to represent that markup. JSX looks a lot like HTML, but it is a bit stricter and can display dynamic information. The best way to understand this is to convert some HTML markup to JSX markup."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "JSX and React are two separate things. They’re often used together, but youcanuse them independentlyof each other. JSX is a syntax extension, while React is a JavaScript library."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Converting HTML to JSX"
                },
                {
                    "type": "p",
                    "text": "Suppose that you have some (perfectly valid) HTML:"
                },
                {
                    "type": "code",
                    "code": "<h1>Hedy Lamarr's Todos</h1><imgsrc=\"https://i.imgur.com/yXOvdOSs.jpg\"alt=\"Hedy Lamarr\"class=\"photo\"><ul><li>Invent new traffic lights<li>Rehearse a movie scene<li>Improve the spectrum technology</ul>"
                },
                {
                    "type": "p",
                    "text": "And you want to put it into your component:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionTodoList(){return(// ???)}"
                },
                {
                    "type": "p",
                    "text": "If you copy and paste it as is, it will not work:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionTodoList(){return(// This doesn't quite work!<h1>Hedy Lamarr's Todos</h1><imgsrc=\"https://i.imgur.com/yXOvdOSs.jpg\"alt=\"Hedy Lamarr\"class=\"photo\"><ul><li>Invent new traffic lights<li>Rehearse a movie scene<li>Improve the spectrum technology</ul>"
                },
                {
                    "type": "p",
                    "text": "This is because JSX is stricter and has a few more rules than HTML! If you read the error messages above, they’ll guide you to fix the markup, or you can follow the guide below."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Most of the time, React’s on-screen error messages will help you find where the problem is. Give them a read if you get stuck!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "The Rules of JSX"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "1. Return a single root element"
                },
                {
                    "type": "p",
                    "text": "To return multiple elements from a component,wrap them with a single parent tag."
                },
                {
                    "type": "p",
                    "text": "For example, you can use a<div>:"
                },
                {
                    "type": "code",
                    "code": "<div><h1>Hedy Lamarr's Todos</h1><imgsrc=\"https://i.imgur.com/yXOvdOSs.jpg\"alt=\"Hedy Lamarr\"class=\"photo\"><ul>...</ul></div>"
                },
                {
                    "type": "p",
                    "text": "If you don’t want to add an extra<div>to your markup, you can write<>and</>instead:"
                },
                {
                    "type": "code",
                    "code": "<><h1>Hedy Lamarr's Todos</h1><imgsrc=\"https://i.imgur.com/yXOvdOSs.jpg\"alt=\"Hedy Lamarr\"class=\"photo\"><ul>...</ul></>"
                },
                {
                    "type": "p",
                    "text": "This empty tag is called aFragment.Fragments let you group things without leaving any trace in the browser HTML tree."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Why do multiple JSX tags need to be wrapped?"
                },
                {
                    "type": "p",
                    "text": "JSX looks like HTML, but under the hood it is transformed into plain JavaScript objects. You can’t return two objects from a function without wrapping them into an array. This explains why you also can’t return two JSX tags without wrapping them into another tag or a Fragment."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "2. Close all the tags"
                },
                {
                    "type": "p",
                    "text": "JSX requires tags to be explicitly closed: self-closing tags like<img>must become<img />, and wrapping tags like<li>orangesmust be written as<li>oranges</li>."
                },
                {
                    "type": "p",
                    "text": "This is how Hedy Lamarr’s image and list items look closed:"
                },
                {
                    "type": "code",
                    "code": "<><imgsrc=\"https://i.imgur.com/yXOvdOSs.jpg\"alt=\"Hedy Lamarr\"class=\"photo\"/><ul><li>Invent new traffic lights</li><li>Rehearse a movie scene</li><li>Improve the spectrum technology</li></ul></>"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "3. camelCaseallmost of the things!"
                },
                {
                    "type": "p",
                    "text": "JSX turns into JavaScript and attributes written in JSX become keys of JavaScript objects. In your own components, you will often want to read those attributes into variables. But JavaScript has limitations on variable names. For example, their names can’t contain dashes or be reserved words likeclass."
                },
                {
                    "type": "p",
                    "text": "This is why, in React, many HTML and SVG attributes are written in camelCase. For example, instead ofstroke-widthyou usestrokeWidth. Sinceclassis a reserved word, in React you writeclassNameinstead, named after thecorresponding DOM property:"
                },
                {
                    "type": "code",
                    "code": "<imgsrc=\"https://i.imgur.com/yXOvdOSs.jpg\"alt=\"Hedy Lamarr\"className=\"photo\"/>"
                },
                {
                    "type": "p",
                    "text": "You canfind all these attributes in the list of DOM component props.If you get one wrong, don’t worry—React will print a message with a possible correction to thebrowser console."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "For historical reasons,aria-*anddata-*attributes are written as in HTML with dashes."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pro-tip: Use a JSX Converter"
                },
                {
                    "type": "p",
                    "text": "Converting all these attributes in existing markup can be tedious! We recommend using aconverterto translate your existing HTML and SVG to JSX. Converters are very useful in practice, but it’s still worth understanding what is going on so that you can comfortably write JSX on your own."
                },
                {
                    "type": "p",
                    "text": "Here is your final result:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionTodoList(){return(<><h1>Hedy Lamarr's Todos</h1><imgsrc=\"https://i.imgur.com/yXOvdOSs.jpg\"alt=\"Hedy Lamarr\"className=\"photo\"/><ul><li>Invent new traffic lights</li><li>Rehearse a movie scene</li><li>Improve the spectrum technology</li></ul></>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "p",
                    "text": "Now you know why JSX exists and how to use it in components:"
                },
                {
                    "type": "list",
                    "items": [
                        "React components group rendering logic together with markup because they are related.",
                        "JSX is similar to HTML, with a few differences. You can use aconverterif you need to.",
                        "Error messages will often point you in the right direction to fixing your markup."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of1:Convert some HTML to JSX"
                },
                {
                    "type": "p",
                    "text": "This HTML was pasted into a component, but it’s not valid JSX. Fix it:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionBio(){return(<divclass=\"intro\"><h1>Welcome to my website!</h1></div><pclass=\"summary\">Youcanfindmythoughtshere.\n      <br><br><b>And<i>pictures</b></i>of scientists!</p>);}"
                },
                {
                    "type": "p",
                    "text": "Whether to do it by hand or using the converter is up to you!"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/you-might-not-need-an-effect",
            "title": "You Might Not Need an Effect – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "You Might Not Need an Effect"
                },
                {
                    "type": "p",
                    "text": "Effects are an escape hatch from the React paradigm. They let you “step outside” of React and synchronize your components with some external system like a non-React widget, network, or the browser DOM. If there is no external system involved (for example, if you want to update a component’s state when some props or state change), you shouldn’t need an Effect. Removing unnecessary Effects will make your code easier to follow, faster to run, and less error-prone."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "Why and how to remove unnecessary Effects from your components",
                        "How to cache expensive computations without Effects",
                        "How to reset and adjust component state without Effects",
                        "How to share logic between event handlers",
                        "Which logic should be moved to event handlers",
                        "How to notify parent components about changes"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "How to remove unnecessary Effects"
                },
                {
                    "type": "p",
                    "text": "There are two common cases in which you don’t need Effects:"
                },
                {
                    "type": "list",
                    "items": [
                        "You don’t need Effects to transform data for rendering.For example, let’s say you want to filter a list before displaying it. You might feel tempted to write an Effect that updates a state variable when the list changes. However, this is inefficient. When you update the state, React will first call your component functions to calculate what should be on the screen. Then React will“commit”these changes to the DOM, updating the screen. Then React will run your Effects. If your Effectalsoimmediately updates the state, this restarts the whole process from scratch! To avoid the unnecessary render passes, transform all the data at the top level of your components. That code will automatically re-run whenever your props or state change.",
                        "You don’t need Effects to handle user events.For example, let’s say you want to send an/api/buyPOST request and show a notification when the user buys a product. In the Buy button click event handler, you know exactly what happened. By the time an Effect runs, you don’t knowwhatthe user did (for example, which button was clicked). This is why you’ll usually handle user events in the corresponding event handlers."
                    ]
                },
                {
                    "type": "p",
                    "text": "Youdoneed Effects tosynchronizewith external systems. For example, you can write an Effect that keeps a jQuery widget synchronized with the React state. You can also fetch data with Effects: for example, you can synchronize the search results with the current search query. Keep in mind that modernframeworksprovide more efficient built-in data fetching mechanisms than writing Effects directly in your components."
                },
                {
                    "type": "p",
                    "text": "To help you gain the right intuition, let’s look at some common concrete examples!"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Updating state based on props or state"
                },
                {
                    "type": "p",
                    "text": "Suppose you have a component with two state variables:firstNameandlastName. You want to calculate afullNamefrom them by concatenating them. Moreover, you’d likefullNameto update wheneverfirstNameorlastNamechange. Your first instinct might be to add afullNamestate variable and update it in an Effect:"
                },
                {
                    "type": "code",
                    "code": "functionForm(){const[firstName,setFirstName]=useState('Taylor');const[lastName,setLastName]=useState('Swift');// 🔴 Avoid: redundant state and unnecessary Effectconst[fullName,setFullName]=useState('');useEffect(()=>{setFullName(firstName+' '+lastName);},[firstName,lastName]);// ...}"
                },
                {
                    "type": "p",
                    "text": "This is more complicated than necessary. It is inefficient too: it does an entire render pass with a stale value forfullName, then immediately re-renders with the updated value. Remove the state variable and the Effect:"
                },
                {
                    "type": "code",
                    "code": "functionForm(){const[firstName,setFirstName]=useState('Taylor');const[lastName,setLastName]=useState('Swift');// ✅ Good: calculated during renderingconstfullName=firstName+' '+lastName;// ...}"
                },
                {
                    "type": "p",
                    "text": "When something can be calculated from the existing props or state,don’t put it in state.Instead, calculate it during rendering.This makes your code faster (you avoid the extra “cascading” updates), simpler (you remove some code), and less error-prone (you avoid bugs caused by different state variables getting out of sync with each other). If this approach feels new to you,Thinking in Reactexplains what should go into state."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Caching expensive calculations"
                },
                {
                    "type": "p",
                    "text": "This component computesvisibleTodosby taking thetodosit receives by props and filtering them according to thefilterprop. You might feel tempted to store the result in state and update it from an Effect:"
                },
                {
                    "type": "code",
                    "code": "functionTodoList({todos,filter}){const[newTodo,setNewTodo]=useState('');// 🔴 Avoid: redundant state and unnecessary Effectconst[visibleTodos,setVisibleTodos]=useState([]);useEffect(()=>{setVisibleTodos(getFilteredTodos(todos,filter));},[todos,filter]);// ...}"
                },
                {
                    "type": "p",
                    "text": "Like in the earlier example, this is both unnecessary and inefficient. First, remove the state and the Effect:"
                },
                {
                    "type": "code",
                    "code": "functionTodoList({todos,filter}){const[newTodo,setNewTodo]=useState('');// ✅ This is fine if getFilteredTodos() is not slow.constvisibleTodos=getFilteredTodos(todos,filter);// ...}"
                },
                {
                    "type": "p",
                    "text": "Usually, this code is fine! But maybegetFilteredTodos()is slow or you have a lot oftodos. In that case you don’t want to recalculategetFilteredTodos()if some unrelated state variable likenewTodohas changed."
                },
                {
                    "type": "p",
                    "text": "You can cache (or“memoize”) an expensive calculation by wrapping it in auseMemoHook:"
                },
                {
                    "type": "code",
                    "code": "import{useMemo,useState}from'react';functionTodoList({todos,filter}){const[newTodo,setNewTodo]=useState('');constvisibleTodos=useMemo(()=>{// ✅ Does not re-run unless todos or filter changereturngetFilteredTodos(todos,filter);},[todos,filter]);// ...}"
                },
                {
                    "type": "p",
                    "text": "Or, written as a single line:"
                },
                {
                    "type": "code",
                    "code": "import{useMemo,useState}from'react';functionTodoList({todos,filter}){const[newTodo,setNewTodo]=useState('');// ✅ Does not re-run getFilteredTodos() unless todos or filter changeconstvisibleTodos=useMemo(()=>getFilteredTodos(todos,filter),[todos,filter]);// ...}"
                },
                {
                    "type": "p",
                    "text": "This tells React that you don’t want the inner function to re-run unless eithertodosorfilterhave changed.React will remember the return value ofgetFilteredTodos()during the initial render. During the next renders, it will check iftodosorfilterare different. If they’re the same as last time,useMemowill return the last result it has stored. But if they are different, React will call the inner function again (and store its result)."
                },
                {
                    "type": "p",
                    "text": "The function you wrap inuseMemoruns during rendering, so this only works forpure calculations."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "How to tell if a calculation is expensive?"
                },
                {
                    "type": "p",
                    "text": "In general, unless you’re creating or looping over thousands of objects, it’s probably not expensive. If you want to get more confidence, you can add a console log to measure the time spent in a piece of code:"
                },
                {
                    "type": "code",
                    "code": "console.time('filter array');constvisibleTodos=getFilteredTodos(todos,filter);console.timeEnd('filter array');"
                },
                {
                    "type": "p",
                    "text": "Perform the interaction you’re measuring (for example, typing into the input). You will then see logs likefilter array: 0.15msin your console. If the overall logged time adds up to a significant amount (say,1msor more), it might make sense to memoize that calculation. As an experiment, you can then wrap the calculation inuseMemoto verify whether the total logged time has decreased for that interaction or not:"
                },
                {
                    "type": "code",
                    "code": "console.time('filter array');constvisibleTodos=useMemo(()=>{returngetFilteredTodos(todos,filter);// Skipped if todos and filter haven't changed},[todos,filter]);console.timeEnd('filter array');"
                },
                {
                    "type": "p",
                    "text": "useMemowon’t make thefirstrender faster. It only helps you skip unnecessary work on updates."
                },
                {
                    "type": "p",
                    "text": "Keep in mind that your machine is probably faster than your users’ so it’s a good idea to test the performance with an artificial slowdown. For example, Chrome offers aCPU Throttlingoption for this."
                },
                {
                    "type": "p",
                    "text": "Also note that measuring performance in development will not give you the most accurate results. (For example, whenStrict Modeis on, you will see each component render twice rather than once.) To get the most accurate timings, build your app for production and test it on a device like your users have."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Resetting all state when a prop changes"
                },
                {
                    "type": "p",
                    "text": "ThisProfilePagecomponent receives auserIdprop. The page contains a comment input, and you use acommentstate variable to hold its value. One day, you notice a problem: when you navigate from one profile to another, thecommentstate does not get reset. As a result, it’s easy to accidentally post a comment on a wrong user’s profile. To fix the issue, you want to clear out thecommentstate variable whenever theuserIdchanges:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionProfilePage({userId}){const[comment,setComment]=useState('');// 🔴 Avoid: Resetting state on prop change in an EffectuseEffect(()=>{setComment('');},[userId]);// ...}"
                },
                {
                    "type": "p",
                    "text": "This is inefficient becauseProfilePageand its children will first render with the stale value, and then render again. It is also complicated because you’d need to do this ineverycomponent that has some state insideProfilePage. For example, if the comment UI is nested, you’d want to clear out nested comment state too."
                },
                {
                    "type": "p",
                    "text": "Instead, you can tell React that each user’s profile is conceptually adifferentprofile by giving it an explicit key. Split your component in two and pass akeyattribute from the outer component to the inner one:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionProfilePage({userId}){return(<ProfileuserId={userId}key={userId}/>);}functionProfile({userId}){// ✅ This and any other state below will reset on key change automaticallyconst[comment,setComment]=useState('');// ...}"
                },
                {
                    "type": "p",
                    "text": "Normally, React preserves the state when the same component is rendered in the same spot.By passinguserIdas akeyto theProfilecomponent, you’re asking React to treat twoProfilecomponents with differentuserIdas two different components that should not share any state.Whenever the key (which you’ve set touserId) changes, React will recreate the DOM andreset the stateof theProfilecomponent and all of its children. Now thecommentfield will clear out automatically when navigating between profiles."
                },
                {
                    "type": "p",
                    "text": "Note that in this example, only the outerProfilePagecomponent is exported and visible to other files in the project. Components renderingProfilePagedon’t need to pass the key to it: they passuserIdas a regular prop. The factProfilePagepasses it as akeyto the innerProfilecomponent is an implementation detail."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Adjusting some state when a prop changes"
                },
                {
                    "type": "p",
                    "text": "Sometimes, you might want to reset or adjust a part of the state on a prop change, but not all of it."
                },
                {
                    "type": "p",
                    "text": "ThisListcomponent receives a list ofitemsas a prop, and maintains the selected item in theselectionstate variable. You want to reset theselectiontonullwhenever theitemsprop receives a different array:"
                },
                {
                    "type": "code",
                    "code": "functionList({items}){const[isReverse,setIsReverse]=useState(false);const[selection,setSelection]=useState(null);// 🔴 Avoid: Adjusting state on prop change in an EffectuseEffect(()=>{setSelection(null);},[items]);// ...}"
                },
                {
                    "type": "p",
                    "text": "This, too, is not ideal. Every time theitemschange, theListand its child components will render with a staleselectionvalue at first. Then React will update the DOM and run the Effects. Finally, thesetSelection(null)call will cause another re-render of theListand its child components, restarting this whole process again."
                },
                {
                    "type": "p",
                    "text": "Start by deleting the Effect. Instead, adjust the state directly during rendering:"
                },
                {
                    "type": "code",
                    "code": "functionList({items}){const[isReverse,setIsReverse]=useState(false);const[selection,setSelection]=useState(null);// Better: Adjust the state while renderingconst[prevItems,setPrevItems]=useState(items);if(items!==prevItems){setPrevItems(items);setSelection(null);}// ...}"
                },
                {
                    "type": "p",
                    "text": "Storing information from previous renderslike this can be hard to understand, but it’s better than updating the same state in an Effect. In the above example,setSelectionis called directly during a render. React will re-render theListimmediatelyafter it exits with areturnstatement. React has not rendered theListchildren or updated the DOM yet, so this lets theListchildren skip rendering the staleselectionvalue."
                },
                {
                    "type": "p",
                    "text": "When you update a component during rendering, React throws away the returned JSX and immediately retries rendering. To avoid very slow cascading retries, React only lets you update thesamecomponent’s state during a render. If you update another component’s state during a render, you’ll see an error. A condition likeitems !== prevItemsis necessary to avoid loops. You may adjust state like this, but any other side effects (like changing the DOM or setting timeouts) should stay in event handlers or Effects tokeep components pure."
                },
                {
                    "type": "p",
                    "text": "Although this pattern is more efficient than an Effect, most components shouldn’t need it either.No matter how you do it, adjusting state based on props or other state makes your data flow more difficult to understand and debug. Always check whether you canreset all state with a keyorcalculate everything during renderinginstead. For example, instead of storing (and resetting) the selecteditem, you can store the selecteditem ID:"
                },
                {
                    "type": "code",
                    "code": "functionList({items}){const[isReverse,setIsReverse]=useState(false);const[selectedId,setSelectedId]=useState(null);// ✅ Best: Calculate everything during renderingconstselection=items.find(item=>item.id===selectedId)??null;// ...}"
                },
                {
                    "type": "p",
                    "text": "Now there is no need to “adjust” the state at all. If the item with the selected ID is in the list, it remains selected. If it’s not, theselectioncalculated during rendering will benullbecause no matching item was found. This behavior is different, but arguably better because most changes toitemspreserve the selection."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Sharing logic between event handlers"
                },
                {
                    "type": "p",
                    "text": "Let’s say you have a product page with two buttons (Buy and Checkout) that both let you buy that product. You want to show a notification whenever the user puts the product in the cart. CallingshowNotification()in both buttons’ click handlers feels repetitive so you might be tempted to place this logic in an Effect:"
                },
                {
                    "type": "code",
                    "code": "functionProductPage({product,addToCart}){// 🔴 Avoid: Event-specific logic inside an EffectuseEffect(()=>{if(product.isInCart){showNotification(`Added${product.name}to the shopping cart!`);}},[product]);functionhandleBuyClick(){addToCart(product);}functionhandleCheckoutClick(){addToCart(product);navigateTo('/checkout');}// ...}"
                },
                {
                    "type": "p",
                    "text": "This Effect is unnecessary. It will also most likely cause bugs. For example, let’s say that your app “remembers” the shopping cart between the page reloads. If you add a product to the cart once and refresh the page, the notification will appear again. It will keep appearing every time you refresh that product’s page. This is becauseproduct.isInCartwill already betrueon the page load, so the Effect above will callshowNotification()."
                },
                {
                    "type": "p",
                    "text": "When you’re not sure whether some code should be in an Effect or in an event handler, ask yourselfwhythis code needs to run. Use Effects only for code that should runbecausethe component was displayed to the user.In this example, the notification should appear because the userpressed the button, not because the page was displayed! Delete the Effect and put the shared logic into a function called from both event handlers:"
                },
                {
                    "type": "code",
                    "code": "functionProductPage({product,addToCart}){// ✅ Good: Event-specific logic is called from event handlersfunctionbuyProduct(){addToCart(product);showNotification(`Added${product.name}to the shopping cart!`);}functionhandleBuyClick(){buyProduct();}functionhandleCheckoutClick(){buyProduct();navigateTo('/checkout');}// ...}"
                },
                {
                    "type": "p",
                    "text": "This both removes the unnecessary Effect and fixes the bug."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Sending a POST request"
                },
                {
                    "type": "p",
                    "text": "ThisFormcomponent sends two kinds of POST requests. It sends an analytics event when it mounts. When you fill in the form and click the Submit button, it will send a POST request to the/api/registerendpoint:"
                },
                {
                    "type": "code",
                    "code": "functionForm(){const[firstName,setFirstName]=useState('');const[lastName,setLastName]=useState('');// ✅ Good: This logic should run because the component was displayeduseEffect(()=>{post('/analytics/event',{eventName:'visit_form'});},[]);// 🔴 Avoid: Event-specific logic inside an Effectconst[jsonToSubmit,setJsonToSubmit]=useState(null);useEffect(()=>{if(jsonToSubmit!==null){post('/api/register',jsonToSubmit);}},[jsonToSubmit]);functionhandleSubmit(e){e.preventDefault();setJsonToSubmit({firstName,lastName});}// ...}"
                },
                {
                    "type": "p",
                    "text": "Let’s apply the same criteria as in the example before."
                },
                {
                    "type": "p",
                    "text": "The analytics POST request should remain in an Effect. This is because thereasonto send the analytics event is that the form was displayed. (It would fire twice in development, butsee herefor how to deal with that.)"
                },
                {
                    "type": "p",
                    "text": "However, the/api/registerPOST request is not caused by the form beingdisplayed. You only want to send the request at one specific moment in time: when the user presses the button. It should only ever happenon that particular interaction. Delete the second Effect and move that POST request into the event handler:"
                },
                {
                    "type": "code",
                    "code": "functionForm(){const[firstName,setFirstName]=useState('');const[lastName,setLastName]=useState('');// ✅ Good: This logic runs because the component was displayeduseEffect(()=>{post('/analytics/event',{eventName:'visit_form'});},[]);functionhandleSubmit(e){e.preventDefault();// ✅ Good: Event-specific logic is in the event handlerpost('/api/register',{firstName,lastName});}// ...}"
                },
                {
                    "type": "p",
                    "text": "When you choose whether to put some logic into an event handler or an Effect, the main question you need to answer iswhat kind of logicit is from the user’s perspective. If this logic is caused by a particular interaction, keep it in the event handler. If it’s caused by the userseeingthe component on the screen, keep it in the Effect."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Chains of computations"
                },
                {
                    "type": "p",
                    "text": "Sometimes you might feel tempted to chain Effects that each adjust a piece of state based on other state:"
                },
                {
                    "type": "code",
                    "code": "functionGame(){const[card,setCard]=useState(null);const[goldCardCount,setGoldCardCount]=useState(0);const[round,setRound]=useState(1);const[isGameOver,setIsGameOver]=useState(false);// 🔴 Avoid: Chains of Effects that adjust the state solely to trigger each otheruseEffect(()=>{if(card!==null&&card.gold){setGoldCardCount(c=>c+1);}},[card]);useEffect(()=>{if(goldCardCount>3){setRound(r=>r+1)setGoldCardCount(0);}},[goldCardCount]);useEffect(()=>{if(round>5){setIsGameOver(true);}},[round]);useEffect(()=>{alert('Good game!');},[isGameOver]);functionhandlePlaceCard(nextCard){if(isGameOver){throwError('Game already ended.');}else{setCard(nextCard);}}// ..."
                },
                {
                    "type": "p",
                    "text": "There are two problems with this code."
                },
                {
                    "type": "p",
                    "text": "The first problem is that it is very inefficient: the component (and its children) have to re-render between eachsetcall in the chain. In the example above, in the worst case (setCard→ render →setGoldCardCount→ render →setRound→ render →setIsGameOver→ render) there are three unnecessary re-renders of the tree below."
                },
                {
                    "type": "p",
                    "text": "The second problem is that even if it weren’t slow, as your code evolves, you will run into cases where the “chain” you wrote doesn’t fit the new requirements. Imagine you are adding a way to step through the history of the game moves. You’d do it by updating each state variable to a value from the past. However, setting thecardstate to a value from the past would trigger the Effect chain again and change the data you’re showing. Such code is often rigid and fragile."
                },
                {
                    "type": "p",
                    "text": "In this case, it’s better to calculate what you can during rendering, and adjust the state in the event handler:"
                },
                {
                    "type": "code",
                    "code": "functionGame(){const[card,setCard]=useState(null);const[goldCardCount,setGoldCardCount]=useState(0);const[round,setRound]=useState(1);// ✅ Calculate what you can during renderingconstisGameOver=round>5;functionhandlePlaceCard(nextCard){if(isGameOver){throwError('Game already ended.');}// ✅ Calculate all the next state in the event handlersetCard(nextCard);if(nextCard.gold){if(goldCardCount<=3){setGoldCardCount(goldCardCount+1);}else{setGoldCardCount(0);setRound(round+1);if(round===5){alert('Good game!');}}}}// ..."
                },
                {
                    "type": "p",
                    "text": "This is a lot more efficient. Also, if you implement a way to view game history, now you will be able to set each state variable to a move from the past without triggering the Effect chain that adjusts every other value. If you need to reuse logic between several event handlers, you canextract a functionand call it from those handlers."
                },
                {
                    "type": "p",
                    "text": "Remember that inside event handlers,state behaves like a snapshot.For example, even after you callsetRound(round + 1), theroundvariable will reflect the value at the time the user clicked the button. If you need to use the next value for calculations, define it manually likeconst nextRound = round + 1."
                },
                {
                    "type": "p",
                    "text": "In some cases, youcan’tcalculate the next state directly in the event handler. For example, imagine a form with multiple dropdowns where the options of the next dropdown depend on the selected value of the previous dropdown. Then, a chain of Effects is appropriate because you are synchronizing with network."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Initializing the application"
                },
                {
                    "type": "p",
                    "text": "Some logic should only run once when the app loads."
                },
                {
                    "type": "p",
                    "text": "You might be tempted to place it in an Effect in the top-level component:"
                },
                {
                    "type": "code",
                    "code": "functionApp(){// 🔴 Avoid: Effects with logic that should only ever run onceuseEffect(()=>{loadDataFromLocalStorage();checkAuthToken();},[]);// ...}"
                },
                {
                    "type": "p",
                    "text": "However, you’ll quickly discover that itruns twice in development.This can cause issues—for example, maybe it invalidates the authentication token because the function wasn’t designed to be called twice. In general, your components should be resilient to being remounted. This includes your top-levelAppcomponent."
                },
                {
                    "type": "p",
                    "text": "Although it may not ever get remounted in practice in production, following the same constraints in all components makes it easier to move and reuse code. If some logic must runonce per app loadrather thanonce per component mount, add a top-level variable to track whether it has already executed:"
                },
                {
                    "type": "code",
                    "code": "letdidInit=false;functionApp(){useEffect(()=>{if(!didInit){didInit=true;// ✅ Only runs once per app loadloadDataFromLocalStorage();checkAuthToken();}},[]);// ...}"
                },
                {
                    "type": "p",
                    "text": "You can also run it during module initialization and before the app renders:"
                },
                {
                    "type": "code",
                    "code": "if(typeofwindow!=='undefined'){// Check if we're running in the browser.// ✅ Only runs once per app loadcheckAuthToken();loadDataFromLocalStorage();}functionApp(){// ...}"
                },
                {
                    "type": "p",
                    "text": "Code at the top level runs once when your component is imported—even if it doesn’t end up being rendered. To avoid slowdown or surprising behavior when importing arbitrary components, don’t overuse this pattern. Keep app-wide initialization logic to root component modules likeApp.jsor in your application’s entry point."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Notifying parent components about state changes"
                },
                {
                    "type": "p",
                    "text": "Let’s say you’re writing aTogglecomponent with an internalisOnstate which can be eithertrueorfalse. There are a few different ways to toggle it (by clicking or dragging). You want to notify the parent component whenever theToggleinternal state changes, so you expose anonChangeevent and call it from an Effect:"
                },
                {
                    "type": "code",
                    "code": "functionToggle({onChange}){const[isOn,setIsOn]=useState(false);// 🔴 Avoid: The onChange handler runs too lateuseEffect(()=>{onChange(isOn);},[isOn,onChange])functionhandleClick(){setIsOn(!isOn);}functionhandleDragEnd(e){if(isCloserToRightEdge(e)){setIsOn(true);}else{setIsOn(false);}}// ...}"
                },
                {
                    "type": "p",
                    "text": "Like earlier, this is not ideal. TheToggleupdates its state first, and React updates the screen. Then React runs the Effect, which calls theonChangefunction passed from a parent component. Now the parent component will update its own state, starting another render pass. It would be better to do everything in a single pass."
                },
                {
                    "type": "p",
                    "text": "Delete the Effect and instead update the state ofbothcomponents within the same event handler:"
                },
                {
                    "type": "code",
                    "code": "functionToggle({onChange}){const[isOn,setIsOn]=useState(false);functionupdateToggle(nextIsOn){// ✅ Good: Perform all updates during the event that caused themsetIsOn(nextIsOn);onChange(nextIsOn);}functionhandleClick(){updateToggle(!isOn);}functionhandleDragEnd(e){if(isCloserToRightEdge(e)){updateToggle(true);}else{updateToggle(false);}}// ...}"
                },
                {
                    "type": "p",
                    "text": "With this approach, both theTogglecomponent and its parent component update their state during the event. Reactbatches updatesfrom different components together, so there will only be one render pass."
                },
                {
                    "type": "p",
                    "text": "You might also be able to remove the state altogether, and instead receiveisOnfrom the parent component:"
                },
                {
                    "type": "code",
                    "code": "// ✅ Also good: the component is fully controlled by its parentfunctionToggle({isOn,onChange}){functionhandleClick(){onChange(!isOn);}functionhandleDragEnd(e){if(isCloserToRightEdge(e)){onChange(true);}else{onChange(false);}}// ...}"
                },
                {
                    "type": "p",
                    "text": "“Lifting state up”lets the parent component fully control theToggleby toggling the parent’s own state. This means the parent component will have to contain more logic, but there will be less state overall to worry about. Whenever you try to keep two different state variables synchronized, try lifting state up instead!"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Passing data to the parent"
                },
                {
                    "type": "p",
                    "text": "ThisChildcomponent fetches some data and then passes it to theParentcomponent in an Effect:"
                },
                {
                    "type": "code",
                    "code": "functionParent(){const[data,setData]=useState(null);// ...return<ChildonFetched={setData}/>;}functionChild({onFetched}){constdata=useSomeAPI();// 🔴 Avoid: Passing data to the parent in an EffectuseEffect(()=>{if(data){onFetched(data);}},[onFetched,data]);// ...}"
                },
                {
                    "type": "p",
                    "text": "In React, data flows from the parent components to their children. When you see something wrong on the screen, you can trace where the information comes from by going up the component chain until you find which component passes the wrong prop or has the wrong state. When child components update the state of their parent components in Effects, the data flow becomes very difficult to trace. Since both the child and the parent need the same data, let the parent component fetch that data, andpass it downto the child instead:"
                },
                {
                    "type": "code",
                    "code": "functionParent(){constdata=useSomeAPI();// ...// ✅ Good: Passing data down to the childreturn<Childdata={data}/>;}functionChild({data}){// ...}"
                },
                {
                    "type": "p",
                    "text": "This is simpler and keeps the data flow predictable: the data flows down from the parent to the child."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Subscribing to an external store"
                },
                {
                    "type": "p",
                    "text": "Sometimes, your components may need to subscribe to some data outside of the React state. This data could be from a third-party library or a built-in browser API. Since this data can change without React’s knowledge, you need to manually subscribe your components to it. This is often done with an Effect, for example:"
                },
                {
                    "type": "code",
                    "code": "functionuseOnlineStatus(){// Not ideal: Manual store subscription in an Effectconst[isOnline,setIsOnline]=useState(true);useEffect(()=>{functionupdateState(){setIsOnline(navigator.onLine);}updateState();window.addEventListener('online',updateState);window.addEventListener('offline',updateState);return()=>{window.removeEventListener('online',updateState);window.removeEventListener('offline',updateState);};},[]);returnisOnline;}functionChatIndicator(){constisOnline=useOnlineStatus();// ...}"
                },
                {
                    "type": "p",
                    "text": "Here, the component subscribes to an external data store (in this case, the browsernavigator.onLineAPI). Since this API does not exist on the server (so it can’t be used for the initial HTML), initially the state is set totrue. Whenever the value of that data store changes in the browser, the component updates its state."
                },
                {
                    "type": "p",
                    "text": "Although it’s common to use Effects for this, React has a purpose-built Hook for subscribing to an external store that is preferred instead. Delete the Effect and replace it with a call touseSyncExternalStore:"
                },
                {
                    "type": "code",
                    "code": "functionsubscribe(callback){window.addEventListener('online',callback);window.addEventListener('offline',callback);return()=>{window.removeEventListener('online',callback);window.removeEventListener('offline',callback);};}functionuseOnlineStatus(){// ✅ Good: Subscribing to an external store with a built-in HookreturnuseSyncExternalStore(subscribe,// React won't resubscribe for as long as you pass the same function()=>navigator.onLine,// How to get the value on the client()=>true// How to get the value on the server);}functionChatIndicator(){constisOnline=useOnlineStatus();// ...}"
                },
                {
                    "type": "p",
                    "text": "This approach is less error-prone than manually syncing mutable data to React state with an Effect. Typically, you’ll write a custom Hook likeuseOnlineStatus()above so that you don’t need to repeat this code in the individual components.Read more about subscribing to external stores from React components."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Fetching data"
                },
                {
                    "type": "p",
                    "text": "Many apps use Effects to kick off data fetching. It is quite common to write a data fetching Effect like this:"
                },
                {
                    "type": "code",
                    "code": "functionSearchResults({query}){const[results,setResults]=useState([]);const[page,setPage]=useState(1);useEffect(()=>{// 🔴 Avoid: Fetching without cleanup logicfetchResults(query,page).then(json=>{setResults(json);});},[query,page]);functionhandleNextPageClick(){setPage(page+1);}// ...}"
                },
                {
                    "type": "p",
                    "text": "Youdon’tneed to move this fetch to an event handler."
                },
                {
                    "type": "p",
                    "text": "This might seem like a contradiction with the earlier examples where you needed to put the logic into the event handlers! However, consider that it’s notthe typing eventthat’s the main reason to fetch. Search inputs are often prepopulated from the URL, and the user might navigate Back and Forward without touching the input."
                },
                {
                    "type": "p",
                    "text": "It doesn’t matter wherepageandquerycome from. While this component is visible, you want to keepresultssynchronizedwith data from the network for the currentpageandquery. This is why it’s an Effect."
                },
                {
                    "type": "p",
                    "text": "However, the code above has a bug. Imagine you type\"hello\"fast. Then thequerywill change from\"h\", to\"he\",\"hel\",\"hell\", and\"hello\". This will kick off separate fetches, but there is no guarantee about which order the responses will arrive in. For example, the\"hell\"response may arriveafterthe\"hello\"response. Since it will callsetResults()last, you will be displaying the wrong search results. This is called a“race condition”: two different requests “raced” against each other and came in a different order than you expected."
                },
                {
                    "type": "p",
                    "text": "To fix the race condition, you need toadd a cleanup functionto ignore stale responses:"
                },
                {
                    "type": "code",
                    "code": "functionSearchResults({query}){const[results,setResults]=useState([]);const[page,setPage]=useState(1);useEffect(()=>{letignore=false;fetchResults(query,page).then(json=>{if(!ignore){setResults(json);}});return()=>{ignore=true;};},[query,page]);functionhandleNextPageClick(){setPage(page+1);}// ...}"
                },
                {
                    "type": "p",
                    "text": "This ensures that when your Effect fetches data, all responses except the last requested one will be ignored."
                },
                {
                    "type": "p",
                    "text": "Handling race conditions is not the only difficulty with implementing data fetching. You might also want to think about caching responses (so that the user can click Back and see the previous screen instantly), how to fetch data on the server (so that the initial server-rendered HTML contains the fetched content instead of a spinner), and how to avoid network waterfalls (so that a child can fetch data without waiting for every parent)."
                },
                {
                    "type": "p",
                    "text": "These issues apply to any UI library, not just React. Solving them is not trivial, which is why modernframeworksprovide more efficient built-in data fetching mechanisms than fetching data in Effects."
                },
                {
                    "type": "p",
                    "text": "If you don’t use a framework (and don’t want to build your own) but would like to make data fetching from Effects more ergonomic, consider extracting your fetching logic into a custom Hook like in this example:"
                },
                {
                    "type": "code",
                    "code": "functionSearchResults({query}){const[page,setPage]=useState(1);constparams=newURLSearchParams({query,page});constresults=useData(`/api/search?${params}`);functionhandleNextPageClick(){setPage(page+1);}// ...}functionuseData(url){const[data,setData]=useState(null);useEffect(()=>{letignore=false;fetch(url).then(response=>response.json()).then(json=>{if(!ignore){setData(json);}});return()=>{ignore=true;};},[url]);returndata;}"
                },
                {
                    "type": "p",
                    "text": "You’ll likely also want to add some logic for error handling and to track whether the content is loading. You can build a Hook like this yourself or use one of the many solutions already available in the React ecosystem.Although this alone won’t be as efficient as using a framework’s built-in data fetching mechanism, moving the data fetching logic into a custom Hook will make it easier to adopt an efficient data fetching strategy later."
                },
                {
                    "type": "p",
                    "text": "In general, whenever you have to resort to writing Effects, keep an eye out for when you can extract a piece of functionality into a custom Hook with a more declarative and purpose-built API likeuseDataabove. The fewer rawuseEffectcalls you have in your components, the easier you will find to maintain your application."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "list",
                    "items": [
                        "If you can calculate something during render, you don’t need an Effect.",
                        "To cache expensive calculations, adduseMemoinstead ofuseEffect.",
                        "To reset the state of an entire component tree, pass a differentkeyto it.",
                        "To reset a particular bit of state in response to a prop change, set it during rendering.",
                        "Code that runs because a component wasdisplayedshould be in Effects, the rest should be in events.",
                        "If you need to update the state of several components, it’s better to do it during a single event.",
                        "Whenever you try to synchronize state variables in different components, consider lifting state up.",
                        "You can fetch data with Effects, but you need to implement cleanup to avoid race conditions."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of4:Transform data without Effects"
                },
                {
                    "type": "p",
                    "text": "TheTodoListbelow displays a list of todos. When the “Show only active todos” checkbox is ticked, completed todos are not displayed in the list. Regardless of which todos are visible, the footer displays the count of todos that are not yet completed."
                },
                {
                    "type": "p",
                    "text": "Simplify this component by removing all the unnecessary state and Effects."
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{initialTodos,createTodo}from'./todos.js';exportdefaultfunctionTodoList(){const[todos,setTodos]=useState(initialTodos);const[showActive,setShowActive]=useState(false);const[activeTodos,setActiveTodos]=useState([]);const[visibleTodos,setVisibleTodos]=useState([]);const[footer,setFooter]=useState(null);useEffect(()=>{setActiveTodos(todos.filter(todo=>!todo.completed));},[todos]);useEffect(()=>{setVisibleTodos(showActive?activeTodos:todos);},[showActive,todos,activeTodos]);useEffect(()=>{setFooter(<footer>{activeTodos.length}todos left</footer>);},[activeTodos]);return(<><label><inputtype=\"checkbox\"checked={showActive}onChange={e=>setShowActive(e.target.checked)}/>Show only active todos</label><NewTodoonAdd={newTodo=>setTodos([...todos,newTodo])}/><ul>{visibleTodos.map(todo=>(<likey={todo.id}>{todo.completed?<s>{todo.text}</s>:todo.text}</li>))}</ul>{footer}</>);}functionNewTodo({onAdd}){const[text,setText]=useState('');functionhandleAddClick(){setText('');onAdd(createTodo(text));}return(<><inputvalue={text}onChange={e=>setText(e.target.value)}/><buttononClick={handleAddClick}>Add</button></>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/learn/your-first-component",
            "title": "Your First Component – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Your First Component"
                },
                {
                    "type": "p",
                    "text": "Componentsare one of the core concepts of React. They are the foundation upon which you build user interfaces (UI), which makes them the perfect place to start your React journey!"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "You will learn"
                },
                {
                    "type": "list",
                    "items": [
                        "What a component is",
                        "What role components play in a React application",
                        "How to write your first React component"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Components: UI building blocks"
                },
                {
                    "type": "p",
                    "text": "On the Web, HTML lets us create rich structured documents with its built-in set of tags like<h1>and<li>:"
                },
                {
                    "type": "code",
                    "code": "<article><h1>My First Component</h1><ol><li>Components: UI Building Blocks</li><li>Defining a Component</li><li>Using a Component</li></ol></article>"
                },
                {
                    "type": "p",
                    "text": "This markup represents this article<article>, its heading<h1>, and an (abbreviated) table of contents as an ordered list<ol>. Markup like this, combined with CSS for style, and JavaScript for interactivity, lies behind every sidebar, avatar, modal, dropdown—every piece of UI you see on the Web."
                },
                {
                    "type": "p",
                    "text": "React lets you combine your markup, CSS, and JavaScript into custom “components”,reusable UI elements for your app.The table of contents code you saw above could be turned into a<TableOfContents />component you could render on every page. Under the hood, it still uses the same HTML tags like<article>,<h1>, etc."
                },
                {
                    "type": "p",
                    "text": "Just like with HTML tags, you can compose, order and nest components to design whole pages. For example, the documentation page you’re reading is made out of React components:"
                },
                {
                    "type": "code",
                    "code": "<PageLayout><NavigationHeader><SearchBar/><Linkto=\"/docs\">Docs</Link></NavigationHeader><Sidebar/><PageContent><TableOfContents/><DocumentationText/></PageContent></PageLayout>"
                },
                {
                    "type": "p",
                    "text": "As your project grows, you will notice that many of your designs can be composed by reusing components you already wrote, speeding up your development. Our table of contents above could be added to any screen with<TableOfContents />! You can even jumpstart your project with the thousands of components shared by the React open source community likeChakra UIandMaterial UI."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Defining a component"
                },
                {
                    "type": "p",
                    "text": "Traditionally when creating web pages, web developers marked up their content and then added interaction by sprinkling on some JavaScript. This worked great when interaction was a nice-to-have on the web. Now it is expected for many sites and all apps. React puts interactivity first while still using the same technology:a React component is a JavaScript function that you cansprinkle with markup.Here’s what that looks like (you can edit the example below):"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionProfile(){return(<imgsrc=\"https://i.imgur.com/MK3eW3Am.jpg\"alt=\"Katherine Johnson\"/>)}"
                },
                {
                    "type": "p",
                    "text": "And here’s how to build a component:"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 1: Export the component"
                },
                {
                    "type": "p",
                    "text": "Theexport defaultprefix is astandard JavaScript syntax(not specific to React). It lets you mark the main function in a file so that you can later import it from other files. (More on importing inImporting and Exporting Components!)"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 2: Define the function"
                },
                {
                    "type": "p",
                    "text": "Withfunction Profile() { }you define a JavaScript function with the nameProfile."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "React components are regular JavaScript functions, buttheir names must start with a capital letteror they won’t work!"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Step 3: Add markup"
                },
                {
                    "type": "p",
                    "text": "The component returns an<img />tag withsrcandaltattributes.<img />is written like HTML, but it is actually JavaScript under the hood! This syntax is calledJSX, and it lets you embed markup inside JavaScript."
                },
                {
                    "type": "p",
                    "text": "Return statements can be written all on one line, as in this component:"
                },
                {
                    "type": "code",
                    "code": "return<imgsrc=\"https://i.imgur.com/MK3eW3As.jpg\"alt=\"Katherine Johnson\"/>;"
                },
                {
                    "type": "p",
                    "text": "But if your markup isn’t all on the same line as thereturnkeyword, you must wrap it in a pair of parentheses:"
                },
                {
                    "type": "code",
                    "code": "return(<div><imgsrc=\"https://i.imgur.com/MK3eW3As.jpg\"alt=\"Katherine Johnson\"/></div>);"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Without parentheses, any code on the lines afterreturnwill be ignored!"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Using a component"
                },
                {
                    "type": "p",
                    "text": "Now that you’ve defined yourProfilecomponent, you can nest it inside other components. For example, you can export aGallerycomponent that uses multipleProfilecomponents:"
                },
                {
                    "type": "code",
                    "code": "functionProfile(){return(<imgsrc=\"https://i.imgur.com/MK3eW3As.jpg\"alt=\"Katherine Johnson\"/>);}exportdefaultfunctionGallery(){return(<section><h1>Amazing scientists</h1><Profile/><Profile/><Profile/></section>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "What the browser sees"
                },
                {
                    "type": "p",
                    "text": "Notice the difference in casing:"
                },
                {
                    "type": "list",
                    "items": [
                        "<section>is lowercase, so React knows we refer to an HTML tag.",
                        "<Profile />starts with a capitalP, so React knows that we want to use our component calledProfile."
                    ]
                },
                {
                    "type": "p",
                    "text": "AndProfilecontains even more HTML:<img />. In the end, this is what the browser sees:"
                },
                {
                    "type": "code",
                    "code": "<section><h1>Amazing scientists</h1><imgsrc=\"https://i.imgur.com/MK3eW3As.jpg\"alt=\"Katherine Johnson\"/><imgsrc=\"https://i.imgur.com/MK3eW3As.jpg\"alt=\"Katherine Johnson\"/><imgsrc=\"https://i.imgur.com/MK3eW3As.jpg\"alt=\"Katherine Johnson\"/></section>"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Nesting and organizing components"
                },
                {
                    "type": "p",
                    "text": "Components are regular JavaScript functions, so you can keep multiple components in the same file. This is convenient when components are relatively small or tightly related to each other. If this file gets crowded, you can always moveProfileto a separate file. You will learn how to do this shortly on thepage about imports."
                },
                {
                    "type": "p",
                    "text": "Because theProfilecomponents are rendered insideGallery—even several times!—we can say thatGalleryis aparent component,rendering eachProfileas a “child”. This is part of the magic of React: you can define a component once, and then use it in as many places and as many times as you like."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Components can render other components, butyou must never nest their definitions:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionGallery(){// 🔴 Never define a component inside another component!functionProfile(){// ...}// ...}"
                },
                {
                    "type": "p",
                    "text": "The snippet above isvery slow and causes bugs.Instead, define every component at the top level:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionGallery(){// ...}// ✅ Declare components at the top levelfunctionProfile(){// ...}"
                },
                {
                    "type": "p",
                    "text": "When a child component needs some data from a parent,pass it by propsinstead of nesting definitions."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Components all the way down"
                },
                {
                    "type": "p",
                    "text": "Your React application begins at a “root” component. Usually, it is created automatically when you start a new project. For example, if you useCodeSandboxor if you use the frameworkNext.js, the root component is defined inpages/index.js. In these examples, you’ve been exporting root components."
                },
                {
                    "type": "p",
                    "text": "Most React apps use components all the way down. This means that you won’t only use components for reusable pieces like buttons, but also for larger pieces like sidebars, lists, and ultimately, complete pages! Components are a handy way to organize UI code and markup, even if some of them are only used once."
                },
                {
                    "type": "p",
                    "text": "React-based frameworkstake this a step further. Instead of using an empty HTML file and letting React “take over” managing the page with JavaScript, theyalsogenerate the HTML automatically from your React components. This allows your app to show some content before the JavaScript code loads."
                },
                {
                    "type": "p",
                    "text": "Still, many websites only use React toadd interactivity to existing HTML pages.They have many root components instead of a single one for the entire page. You can use as much—or as little—React as you need."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Recap"
                },
                {
                    "type": "p",
                    "text": "You’ve just gotten your first taste of React! Let’s recap some key points."
                },
                {
                    "type": "list",
                    "items": [
                        "React lets you create components,reusable UI elements for your app.",
                        "In a React app, every piece of UI is a component.",
                        "React components are regular JavaScript functions except:Their names always begin with a capital letter.They return JSX markup.",
                        "Their names always begin with a capital letter.",
                        "They return JSX markup."
                    ]
                },
                {
                    "type": "p",
                    "text": "React lets you create components,reusable UI elements for your app."
                },
                {
                    "type": "p",
                    "text": "In a React app, every piece of UI is a component."
                },
                {
                    "type": "p",
                    "text": "React components are regular JavaScript functions except:"
                },
                {
                    "type": "list",
                    "items": [
                        "Their names always begin with a capital letter.",
                        "They return JSX markup."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Try out some challenges"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Challenge1of4:Export the component"
                },
                {
                    "type": "p",
                    "text": "This sandbox doesn’t work because the root component is not exported:"
                },
                {
                    "type": "code",
                    "code": "functionProfile(){return(<imgsrc=\"https://i.imgur.com/lICfvbD.jpg\"alt=\"Aklilu Lemma\"/>);}"
                },
                {
                    "type": "p",
                    "text": "Try to fix it yourself before looking at the solution!"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react",
            "title": "React Reference Overview – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "React Reference Overview"
                },
                {
                    "type": "p",
                    "text": "This section provides detailed reference documentation for working with React. For an introduction to React, please visit theLearnsection."
                },
                {
                    "type": "p",
                    "text": "The React reference documentation is broken down into functional subsections:"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "React"
                },
                {
                    "type": "p",
                    "text": "Programmatic React features:"
                },
                {
                    "type": "list",
                    "items": [
                        "Hooks- Use different React features from your components.",
                        "Components- Built-in components that you can use in your JSX.",
                        "APIs- APIs that are useful for defining components.",
                        "Directives- Provide instructions to bundlers compatible with React Server Components."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "React DOM"
                },
                {
                    "type": "p",
                    "text": "React-dom contains features that are only supported for web applications (which run in the browser DOM environment). This section is broken into the following:"
                },
                {
                    "type": "list",
                    "items": [
                        "Hooks- Hooks for web applications which run in the browser DOM environment.",
                        "Components- React supports all of the browser built-in HTML and SVG components.",
                        "APIs- Thereact-dompackage contains methods supported only in web applications.",
                        "Client APIs- Thereact-dom/clientAPIs let you render React components on the client (in the browser).",
                        "Server APIs- Thereact-dom/serverAPIs let you render React components to HTML on the server."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Rules of React"
                },
                {
                    "type": "p",
                    "text": "React has idioms — or rules — for how to express patterns in a way that is easy to understand and yields high-quality applications:"
                },
                {
                    "type": "list",
                    "items": [
                        "Components and Hooks must be pure– Purity makes your code easier to understand, debug, and allows React to automatically optimize your components and hooks correctly.",
                        "React calls Components and Hooks– React is responsible for rendering components and hooks when necessary to optimize the user experience.",
                        "Rules of Hooks– Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Legacy APIs"
                },
                {
                    "type": "list",
                    "items": [
                        "Legacy APIs- Exported from thereactpackage, but not recommended for use in newly written code."
                    ]
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom",
            "title": "React DOM APIs – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "React DOM APIs"
                },
                {
                    "type": "p",
                    "text": "Thereact-dompackage contains methods that are only supported for the web applications (which run in the browser DOM environment). They are not supported for React Native."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "APIs"
                },
                {
                    "type": "p",
                    "text": "These APIs can be imported from your components. They are rarely used:"
                },
                {
                    "type": "list",
                    "items": [
                        "createPortallets you render child components in a different part of the DOM tree.",
                        "flushSynclets you force React to flush a state update and update the DOM synchronously."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Resource Preloading APIs"
                },
                {
                    "type": "p",
                    "text": "These APIs can be used to make apps faster by pre-loading resources such as scripts, stylesheets, and fonts as soon as you know you need them, for example before navigating to another page where the resources will be used."
                },
                {
                    "type": "p",
                    "text": "React-based frameworksfrequently handle resource loading for you, so you might not have to call these APIs yourself. Consult your framework’s documentation for details."
                },
                {
                    "type": "list",
                    "items": [
                        "prefetchDNSlets you prefetch the IP address of a DNS domain name that you expect to connect to.",
                        "preconnectlets you connect to a server you expect to request resources from, even if you don’t know what resources you’ll need yet.",
                        "preloadlets you fetch a stylesheet, font, image, or external script that you expect to use.",
                        "preloadModulelets you fetch an ESM module that you expect to use.",
                        "preinitlets you fetch and evaluate an external script or fetch and insert a stylesheet.",
                        "preinitModulelets you fetch and evaluate an ESM module."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Entry points"
                },
                {
                    "type": "p",
                    "text": "Thereact-dompackage provides two additional entry points:"
                },
                {
                    "type": "list",
                    "items": [
                        "react-dom/clientcontains APIs to render React components on the client (in the browser).",
                        "react-dom/servercontains APIs to render React components on the server."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Deprecated APIs"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Deprecated"
                },
                {
                    "type": "p",
                    "text": "These APIs will be removed in a future major version of React."
                },
                {
                    "type": "list",
                    "items": [
                        "findDOMNodefinds the closest DOM node corresponding to a class component instance.",
                        "hydratemounts a tree into the DOM created from server HTML. Deprecated in favor ofhydrateRoot.",
                        "rendermounts a tree into the DOM. Deprecated in favor ofcreateRoot.",
                        "unmountComponentAtNodeunmounts a tree from the DOM. Deprecated in favor ofroot.unmount()."
                    ]
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/client",
            "title": "Client React DOM APIs – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Client React DOM APIs"
                },
                {
                    "type": "p",
                    "text": "Thereact-dom/clientAPIs let you render React components on the client (in the browser). These APIs are typically used at the top level of your app to initialize your React tree. Aframeworkmay call them for you. Most of your components don’t need to import or use them."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Client APIs"
                },
                {
                    "type": "list",
                    "items": [
                        "createRootlets you create a root to display React components inside a browser DOM node.",
                        "hydrateRootlets you display React components inside a browser DOM node whose HTML content was previously generated byreact-dom/server."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Browser support"
                },
                {
                    "type": "p",
                    "text": "React supports all popular browsers, including Internet Explorer 9 and above. Some polyfills are required for older browsers such as IE 9 and IE 10."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/client/createRoot",
            "title": "createRoot – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "createRoot"
                },
                {
                    "type": "p",
                    "text": "createRootlets you create a root to display React components inside a browser DOM node."
                },
                {
                    "type": "code",
                    "code": "constroot=createRoot(domNode,options?)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferencecreateRoot(domNode, options?)root.render(reactNode)root.unmount()",
                        "createRoot(domNode, options?)",
                        "root.render(reactNode)",
                        "root.unmount()",
                        "UsageRendering an app fully built with ReactRendering a page partially built with ReactUpdating a root componentShow a dialog for uncaught errorsDisplaying Error Boundary errorsDisplaying a dialog for recoverable errors",
                        "Rendering an app fully built with React",
                        "Rendering a page partially built with React",
                        "Updating a root component",
                        "Show a dialog for uncaught errors",
                        "Displaying Error Boundary errors",
                        "Displaying a dialog for recoverable errors",
                        "TroubleshootingI’ve created a root, but nothing is displayedI’m getting an error: “You passed a second argument to root.render”I’m getting an error: “Target container is not a DOM element”I’m getting an error: “Functions are not valid as a React child.”My server-rendered HTML gets re-created from scratch",
                        "I’ve created a root, but nothing is displayed",
                        "I’m getting an error: “You passed a second argument to root.render”",
                        "I’m getting an error: “Target container is not a DOM element”",
                        "I’m getting an error: “Functions are not valid as a React child.”",
                        "My server-rendered HTML gets re-created from scratch"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "createRoot(domNode, options?)",
                        "root.render(reactNode)",
                        "root.unmount()"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Rendering an app fully built with React",
                        "Rendering a page partially built with React",
                        "Updating a root component",
                        "Show a dialog for uncaught errors",
                        "Displaying Error Boundary errors",
                        "Displaying a dialog for recoverable errors"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "I’ve created a root, but nothing is displayed",
                        "I’m getting an error: “You passed a second argument to root.render”",
                        "I’m getting an error: “Target container is not a DOM element”",
                        "I’m getting an error: “Functions are not valid as a React child.”",
                        "My server-rendered HTML gets re-created from scratch"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "createRoot(domNode, options?)"
                },
                {
                    "type": "p",
                    "text": "CallcreateRootto create a React root for displaying content inside a browser DOM element."
                },
                {
                    "type": "code",
                    "code": "import{createRoot}from'react-dom/client';constdomNode=document.getElementById('root');constroot=createRoot(domNode);"
                },
                {
                    "type": "p",
                    "text": "React will create a root for thedomNode, and take over managing the DOM inside it. After you’ve created a root, you need to callroot.renderto display a React component inside of it:"
                },
                {
                    "type": "code",
                    "code": "root.render(<App/>);"
                },
                {
                    "type": "p",
                    "text": "An app fully built with React will usually only have onecreateRootcall for its root component. A page that uses “sprinkles” of React for parts of the page may have as many separate roots as needed."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "domNode: ADOM element.React will create a root for this DOM element and allow you to call functions on the root, such asrenderto display rendered React content.",
                        "optionaloptions: An object with options for this React root.Canary onlyoptionalonCaughtError: Callback called when React catches an error in an Error Boundary. Called with theerrorcaught by the Error Boundary, and anerrorInfoobject containing thecomponentStack.Canary onlyoptionalonUncaughtError: Callback called when an error is thrown and not caught by an Error Boundary. Called with theerrorthat was thrown, and anerrorInfoobject containing thecomponentStack.optionalonRecoverableError: Callback called when React automatically recovers from errors. Called with anerrorReact throws, and anerrorInfoobject containing thecomponentStack. Some recoverable errors may include the original error cause aserror.cause.optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page.",
                        "Canary onlyoptionalonCaughtError: Callback called when React catches an error in an Error Boundary. Called with theerrorcaught by the Error Boundary, and anerrorInfoobject containing thecomponentStack.",
                        "Canary onlyoptionalonUncaughtError: Callback called when an error is thrown and not caught by an Error Boundary. Called with theerrorthat was thrown, and anerrorInfoobject containing thecomponentStack.",
                        "optionalonRecoverableError: Callback called when React automatically recovers from errors. Called with anerrorReact throws, and anerrorInfoobject containing thecomponentStack. Some recoverable errors may include the original error cause aserror.cause.",
                        "optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page."
                    ]
                },
                {
                    "type": "p",
                    "text": "domNode: ADOM element.React will create a root for this DOM element and allow you to call functions on the root, such asrenderto display rendered React content."
                },
                {
                    "type": "p",
                    "text": "optionaloptions: An object with options for this React root."
                },
                {
                    "type": "list",
                    "items": [
                        "Canary onlyoptionalonCaughtError: Callback called when React catches an error in an Error Boundary. Called with theerrorcaught by the Error Boundary, and anerrorInfoobject containing thecomponentStack.",
                        "Canary onlyoptionalonUncaughtError: Callback called when an error is thrown and not caught by an Error Boundary. Called with theerrorthat was thrown, and anerrorInfoobject containing thecomponentStack.",
                        "optionalonRecoverableError: Callback called when React automatically recovers from errors. Called with anerrorReact throws, and anerrorInfoobject containing thecomponentStack. Some recoverable errors may include the original error cause aserror.cause.",
                        "optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "createRootreturns an object with two methods:renderandunmount."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "If your app is server-rendered, usingcreateRoot()is not supported. UsehydrateRoot()instead.",
                        "You’ll likely have only onecreateRootcall in your app. If you use a framework, it might do this call for you.",
                        "When you want to render a piece of JSX in a different part of the DOM tree that isn’t a child of your component (for example, a modal or a tooltip), usecreatePortalinstead ofcreateRoot."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "root.render(reactNode)"
                },
                {
                    "type": "p",
                    "text": "Callroot.renderto display a piece ofJSX(“React node”) into the React root’s browser DOM node."
                },
                {
                    "type": "code",
                    "code": "root.render(<App/>);"
                },
                {
                    "type": "p",
                    "text": "React will display<App />in theroot, and take over managing the DOM inside it."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "reactNode: AReact nodethat you want to display. This will usually be a piece of JSX like<App />, but you can also pass a React element constructed withcreateElement(), a string, a number,null, orundefined."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "root.renderreturnsundefined."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "The first time you callroot.render, React will clear all the existing HTML content inside the React root before rendering the React component into it.",
                        "If your root’s DOM node contains HTML generated by React on the server or during the build, usehydrateRoot()instead, which attaches the event handlers to the existing HTML.",
                        "If you callrenderon the same root more than once, React will update the DOM as necessary to reflect the latest JSX you passed. React will decide which parts of the DOM can be reused and which need to be recreated by“matching it up”with the previously rendered tree. Callingrenderon the same root again is similar to calling thesetfunctionon the root component: React avoids unnecessary DOM updates."
                    ]
                },
                {
                    "type": "p",
                    "text": "The first time you callroot.render, React will clear all the existing HTML content inside the React root before rendering the React component into it."
                },
                {
                    "type": "p",
                    "text": "If your root’s DOM node contains HTML generated by React on the server or during the build, usehydrateRoot()instead, which attaches the event handlers to the existing HTML."
                },
                {
                    "type": "p",
                    "text": "If you callrenderon the same root more than once, React will update the DOM as necessary to reflect the latest JSX you passed. React will decide which parts of the DOM can be reused and which need to be recreated by“matching it up”with the previously rendered tree. Callingrenderon the same root again is similar to calling thesetfunctionon the root component: React avoids unnecessary DOM updates."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "root.unmount()"
                },
                {
                    "type": "p",
                    "text": "Callroot.unmountto destroy a rendered tree inside a React root."
                },
                {
                    "type": "code",
                    "code": "root.unmount();"
                },
                {
                    "type": "p",
                    "text": "An app fully built with React will usually not have any calls toroot.unmount."
                },
                {
                    "type": "p",
                    "text": "This is mostly useful if your React root’s DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. In that case, you need to tell React to “stop” managing the removed root’s content by callingroot.unmount. Otherwise, the components inside the removed root won’t know to clean up and free up global resources like subscriptions."
                },
                {
                    "type": "p",
                    "text": "Callingroot.unmountwill unmount all the components in the root and “detach” React from the root DOM node, including removing any event handlers or state in the tree."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "p",
                    "text": "root.unmountdoes not accept any parameters."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "root.unmountreturnsundefined."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Callingroot.unmountwill unmount all the components in the tree and “detach” React from the root DOM node.",
                        "Once you callroot.unmountyou cannot callroot.renderagain on the same root. Attempting to callroot.renderon an unmounted root will throw a “Cannot update an unmounted root” error. However, you can create a new root for the same DOM node after the previous root for that node has been unmounted."
                    ]
                },
                {
                    "type": "p",
                    "text": "Callingroot.unmountwill unmount all the components in the tree and “detach” React from the root DOM node."
                },
                {
                    "type": "p",
                    "text": "Once you callroot.unmountyou cannot callroot.renderagain on the same root. Attempting to callroot.renderon an unmounted root will throw a “Cannot update an unmounted root” error. However, you can create a new root for the same DOM node after the previous root for that node has been unmounted."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rendering an app fully built with React"
                },
                {
                    "type": "p",
                    "text": "If your app is fully built with React, create a single root for your entire app."
                },
                {
                    "type": "code",
                    "code": "import{createRoot}from'react-dom/client';constroot=createRoot(document.getElementById('root'));root.render(<App />);"
                },
                {
                    "type": "p",
                    "text": "Usually, you only need to run this code once at startup. It will:"
                },
                {
                    "type": "list",
                    "items": [
                        "Find thebrowser DOM nodedefined in your HTML.",
                        "Display theReact componentfor your app inside."
                    ]
                },
                {
                    "type": "code",
                    "code": "import{createRoot}from'react-dom/client';importAppfrom'./App.js';import'./styles.css';constroot=createRoot(document.getElementById('root'));root.render(<App/>);"
                },
                {
                    "type": "p",
                    "text": "If your app is fully built with React, you shouldn’t need to create any more roots, or to callroot.renderagain."
                },
                {
                    "type": "p",
                    "text": "From this point on, React will manage the DOM of your entire app. To add more components,nest them inside theAppcomponent.When you need to update the UI, each of your components can do this byusing state.When you need to display extra content like a modal or a tooltip outside the DOM node,render it with a portal."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "When your HTML is empty, the user sees a blank page until the app’s JavaScript code loads and runs:"
                },
                {
                    "type": "code",
                    "code": "<divid=\"root\"></div>"
                },
                {
                    "type": "p",
                    "text": "This can feel very slow! To solve this, you can generate the initial HTML from your componentson the server or during the build.Then your visitors can read text, see images, and click links before any of the JavaScript code loads. We recommendusing a frameworkthat does this optimization out of the box. Depending on when it runs, this is calledserver-side rendering (SSR)orstatic site generation (SSG)."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Apps using server rendering or static generation must callhydrateRootinstead ofcreateRoot.React will thenhydrate(reuse) the DOM nodes from your HTML instead of destroying and re-creating them."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rendering a page partially built with React"
                },
                {
                    "type": "p",
                    "text": "If your pageisn’t fully built with React, you can callcreateRootmultiple times to create a root for each top-level piece of UI managed by React. You can display different content in each root by callingroot.render."
                },
                {
                    "type": "p",
                    "text": "Here, two different React components are rendered into two DOM nodes defined in theindex.htmlfile:"
                },
                {
                    "type": "code",
                    "code": "import'./styles.css';import{createRoot}from'react-dom/client';import{Comments,Navigation}from'./Components.js';constnavDomNode=document.getElementById('navigation');constnavRoot=createRoot(navDomNode);navRoot.render(<Navigation/>);constcommentDomNode=document.getElementById('comments');constcommentRoot=createRoot(commentDomNode);commentRoot.render(<Comments/>);"
                },
                {
                    "type": "p",
                    "text": "You could also create a new DOM node withdocument.createElement()and add it to the document manually."
                },
                {
                    "type": "code",
                    "code": "constdomNode=document.createElement('div');constroot=createRoot(domNode);root.render(<Comment/>);document.body.appendChild(domNode);// You can add it anywhere in the document"
                },
                {
                    "type": "p",
                    "text": "To remove the React tree from the DOM node and clean up all the resources used by it, callroot.unmount."
                },
                {
                    "type": "code",
                    "code": "root.unmount();"
                },
                {
                    "type": "p",
                    "text": "This is mostly useful if your React components are inside an app written in a different framework."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Updating a root component"
                },
                {
                    "type": "p",
                    "text": "You can callrendermore than once on the same root. As long as the component tree structure matches up with what was previously rendered, React willpreserve the state.Notice how you can type in the input, which means that the updates from repeatedrendercalls every second in this example are not destructive:"
                },
                {
                    "type": "code",
                    "code": "import{createRoot}from'react-dom/client';import'./styles.css';importAppfrom'./App.js';constroot=createRoot(document.getElementById('root'));leti=0;setInterval(()=>{root.render(<Appcounter={i}/>);i++;},1000);"
                },
                {
                    "type": "p",
                    "text": "It is uncommon to callrendermultiple times. Usually, your components willupdate stateinstead."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Show a dialog for uncaught errors"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "onUncaughtErroris only available in the latest React Canary release."
                },
                {
                    "type": "p",
                    "text": "By default, React will log all uncaught errors to the console. To implement your own error reporting, you can provide the optionalonUncaughtErrorroot option:"
                },
                {
                    "type": "code",
                    "code": "import{createRoot}from'react-dom/client';constroot=createRoot(document.getElementById('root'),{onUncaughtError:(error,errorInfo)=>{console.error('Uncaught error',error,errorInfo.componentStack);}});root.render(<App/>);"
                },
                {
                    "type": "p",
                    "text": "TheonUncaughtErroroption is a function called with two arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "Theerrorthat was thrown.",
                        "AnerrorInfoobject that contains thecomponentStackof the error."
                    ]
                },
                {
                    "type": "p",
                    "text": "You can use theonUncaughtErrorroot option to display error dialogs:"
                },
                {
                    "type": "code",
                    "code": "import{createRoot}from\"react-dom/client\";importAppfrom\"./App.js\";import{reportUncaughtError}from\"./reportError\";import\"./styles.css\";constcontainer=document.getElementById(\"root\");constroot=createRoot(container,{onUncaughtError:(error,errorInfo)=>{if(error.message!=='Known error'){reportUncaughtError({error,componentStack:errorInfo.componentStack});}}});root.render(<App/>);"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Displaying Error Boundary errors"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "onCaughtErroris only available in the latest React Canary release."
                },
                {
                    "type": "p",
                    "text": "By default, React will log all errors caught by an Error Boundary toconsole.error. To override this behavior, you can provide the optionalonCaughtErrorroot option to handle errors caught by anError Boundary:"
                },
                {
                    "type": "code",
                    "code": "import{createRoot}from'react-dom/client';constroot=createRoot(document.getElementById('root'),{onCaughtError:(error,errorInfo)=>{console.error('Caught error',error,errorInfo.componentStack);}});root.render(<App/>);"
                },
                {
                    "type": "p",
                    "text": "TheonCaughtErroroption is a function called with two arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "Theerrorthat was caught by the boundary.",
                        "AnerrorInfoobject that contains thecomponentStackof the error."
                    ]
                },
                {
                    "type": "p",
                    "text": "You can use theonCaughtErrorroot option to display error dialogs or filter known errors from logging:"
                },
                {
                    "type": "code",
                    "code": "import{createRoot}from\"react-dom/client\";importAppfrom\"./App.js\";import{reportCaughtError}from\"./reportError\";import\"./styles.css\";constcontainer=document.getElementById(\"root\");constroot=createRoot(container,{onCaughtError:(error,errorInfo)=>{if(error.message!=='Known error'){reportCaughtError({error,componentStack:errorInfo.componentStack,});}}});root.render(<App/>);"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Displaying a dialog for recoverable errors"
                },
                {
                    "type": "p",
                    "text": "React may automatically render a component a second time to attempt to recover from an error thrown in render. If successful, React will log a recoverable error to the console to notify the developer. To override this behavior, you can provide the optionalonRecoverableErrorroot option:"
                },
                {
                    "type": "code",
                    "code": "import{createRoot}from'react-dom/client';constroot=createRoot(document.getElementById('root'),{onRecoverableError:(error,errorInfo)=>{console.error('Recoverable error',error,error.cause,errorInfo.componentStack,);}});root.render(<App/>);"
                },
                {
                    "type": "p",
                    "text": "TheonRecoverableErroroption is a function called with two arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "Theerrorthat React throws. Some errors may include the original cause aserror.cause.",
                        "AnerrorInfoobject that contains thecomponentStackof the error."
                    ]
                },
                {
                    "type": "p",
                    "text": "You can use theonRecoverableErrorroot option to display error dialogs:"
                },
                {
                    "type": "code",
                    "code": "import{createRoot}from\"react-dom/client\";importAppfrom\"./App.js\";import{reportRecoverableError}from\"./reportError\";import\"./styles.css\";constcontainer=document.getElementById(\"root\");constroot=createRoot(container,{onRecoverableError:(error,errorInfo)=>{reportRecoverableError({error,cause:error.cause,componentStack:errorInfo.componentStack,});}});root.render(<App/>);"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’ve created a root, but nothing is displayed"
                },
                {
                    "type": "p",
                    "text": "Make sure you haven’t forgotten to actuallyrenderyour app into the root:"
                },
                {
                    "type": "code",
                    "code": "import{createRoot}from'react-dom/client';importAppfrom'./App.js';constroot=createRoot(document.getElementById('root'));root.render(<App/>);"
                },
                {
                    "type": "p",
                    "text": "Until you do that, nothing is displayed."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’m getting an error: “You passed a second argument to root.render”"
                },
                {
                    "type": "p",
                    "text": "A common mistake is to pass the options forcreateRoottoroot.render(...):"
                },
                {
                    "type": "p",
                    "text": "To fix, pass the root options tocreateRoot(...), notroot.render(...):"
                },
                {
                    "type": "code",
                    "code": "// 🚩 Wrong: root.render only takes one argument.root.render(App,{onUncaughtError});// ✅ Correct: pass options to createRoot.constroot=createRoot(container,{onUncaughtError});root.render(<App/>);"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’m getting an error: “Target container is not a DOM element”"
                },
                {
                    "type": "p",
                    "text": "This error means that whatever you’re passing tocreateRootis not a DOM node."
                },
                {
                    "type": "p",
                    "text": "If you’re not sure what’s happening, try logging it:"
                },
                {
                    "type": "code",
                    "code": "constdomNode=document.getElementById('root');console.log(domNode);// ???constroot=createRoot(domNode);root.render(<App/>);"
                },
                {
                    "type": "p",
                    "text": "For example, ifdomNodeisnull, it means thatgetElementByIdreturnednull. This will happen if there is no node in the document with the given ID at the time of your call. There may be a few reasons for it:"
                },
                {
                    "type": "list",
                    "items": [
                        "The ID you’re looking for might differ from the ID you used in the HTML file. Check for typos!",
                        "Your bundle’s<script>tag cannot “see” any DOM nodes that appearafterit in the HTML."
                    ]
                },
                {
                    "type": "p",
                    "text": "Another common way to get this error is to writecreateRoot(<App />)instead ofcreateRoot(domNode)."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’m getting an error: “Functions are not valid as a React child.”"
                },
                {
                    "type": "p",
                    "text": "This error means that whatever you’re passing toroot.renderis not a React component."
                },
                {
                    "type": "p",
                    "text": "This may happen if you callroot.renderwithComponentinstead of<Component />:"
                },
                {
                    "type": "code",
                    "code": "// 🚩 Wrong: App is a function, not a Component.root.render(App);// ✅ Correct: <App /> is a component.root.render(<App/>);"
                },
                {
                    "type": "p",
                    "text": "Or if you pass a function toroot.render, instead of the result of calling it:"
                },
                {
                    "type": "code",
                    "code": "// 🚩 Wrong: createApp is a function, not a component.root.render(createApp);// ✅ Correct: call createApp to return a component.root.render(createApp());"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My server-rendered HTML gets re-created from scratch"
                },
                {
                    "type": "p",
                    "text": "If your app is server-rendered and includes the initial HTML generated by React, you might notice that creating a root and callingroot.renderdeletes all that HTML, and then re-creates all the DOM nodes from scratch. This can be slower, resets focus and scroll positions, and may lose other user input."
                },
                {
                    "type": "p",
                    "text": "Server-rendered apps must usehydrateRootinstead ofcreateRoot:"
                },
                {
                    "type": "code",
                    "code": "import{hydrateRoot}from'react-dom/client';importAppfrom'./App.js';hydrateRoot(document.getElementById('root'),<App/>);"
                },
                {
                    "type": "p",
                    "text": "Note that its API is different. In particular, usually there will be no furtherroot.rendercall."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/client/hydrateRoot",
            "title": "hydrateRoot – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "hydrateRoot"
                },
                {
                    "type": "p",
                    "text": "hydrateRootlets you display React components inside a browser DOM node whose HTML content was previously generated byreact-dom/server."
                },
                {
                    "type": "code",
                    "code": "constroot=hydrateRoot(domNode,reactNode,options?)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferencehydrateRoot(domNode, reactNode, options?)root.render(reactNode)root.unmount()",
                        "hydrateRoot(domNode, reactNode, options?)",
                        "root.render(reactNode)",
                        "root.unmount()",
                        "UsageHydrating server-rendered HTMLHydrating an entire documentSuppressing unavoidable hydration mismatch errorsHandling different client and server contentUpdating a hydrated root componentShow a dialog for uncaught errorsDisplaying Error Boundary errorsShow a dialog for recoverable hydration mismatch errors",
                        "Hydrating server-rendered HTML",
                        "Hydrating an entire document",
                        "Suppressing unavoidable hydration mismatch errors",
                        "Handling different client and server content",
                        "Updating a hydrated root component",
                        "Show a dialog for uncaught errors",
                        "Displaying Error Boundary errors",
                        "Show a dialog for recoverable hydration mismatch errors",
                        "TroubleshootingI’m getting an error: “You passed a second argument to root.render”",
                        "I’m getting an error: “You passed a second argument to root.render”"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "hydrateRoot(domNode, reactNode, options?)",
                        "root.render(reactNode)",
                        "root.unmount()"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Hydrating server-rendered HTML",
                        "Hydrating an entire document",
                        "Suppressing unavoidable hydration mismatch errors",
                        "Handling different client and server content",
                        "Updating a hydrated root component",
                        "Show a dialog for uncaught errors",
                        "Displaying Error Boundary errors",
                        "Show a dialog for recoverable hydration mismatch errors"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "I’m getting an error: “You passed a second argument to root.render”"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "hydrateRoot(domNode, reactNode, options?)"
                },
                {
                    "type": "p",
                    "text": "CallhydrateRootto “attach” React to existing HTML that was already rendered by React in a server environment."
                },
                {
                    "type": "code",
                    "code": "import{hydrateRoot}from'react-dom/client';constdomNode=document.getElementById('root');constroot=hydrateRoot(domNode,reactNode);"
                },
                {
                    "type": "p",
                    "text": "React will attach to the HTML that exists inside thedomNode, and take over managing the DOM inside it. An app fully built with React will usually only have onehydrateRootcall with its root component."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "domNode: ADOM elementthat was rendered as the root element on the server.",
                        "reactNode: The “React node” used to render the existing HTML. This will usually be a piece of JSX like<App />which was rendered with aReactDOM Servermethod such asrenderToPipeableStream(<App />).",
                        "optionaloptions: An object with options for this React root.Canary onlyoptionalonCaughtError: Callback called when React catches an error in an Error Boundary. Called with theerrorcaught by the Error Boundary, and anerrorInfoobject containing thecomponentStack.Canary onlyoptionalonUncaughtError: Callback called when an error is thrown and not caught by an Error Boundary. Called with theerrorthat was thrown and anerrorInfoobject containing thecomponentStack.optionalonRecoverableError: Callback called when React automatically recovers from errors. Called with theerrorReact throws, and anerrorInfoobject containing thecomponentStack. Some recoverable errors may include the original error cause aserror.cause.optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as used on the server.",
                        "Canary onlyoptionalonCaughtError: Callback called when React catches an error in an Error Boundary. Called with theerrorcaught by the Error Boundary, and anerrorInfoobject containing thecomponentStack.",
                        "Canary onlyoptionalonUncaughtError: Callback called when an error is thrown and not caught by an Error Boundary. Called with theerrorthat was thrown and anerrorInfoobject containing thecomponentStack.",
                        "optionalonRecoverableError: Callback called when React automatically recovers from errors. Called with theerrorReact throws, and anerrorInfoobject containing thecomponentStack. Some recoverable errors may include the original error cause aserror.cause.",
                        "optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as used on the server."
                    ]
                },
                {
                    "type": "p",
                    "text": "domNode: ADOM elementthat was rendered as the root element on the server."
                },
                {
                    "type": "p",
                    "text": "reactNode: The “React node” used to render the existing HTML. This will usually be a piece of JSX like<App />which was rendered with aReactDOM Servermethod such asrenderToPipeableStream(<App />)."
                },
                {
                    "type": "p",
                    "text": "optionaloptions: An object with options for this React root."
                },
                {
                    "type": "list",
                    "items": [
                        "Canary onlyoptionalonCaughtError: Callback called when React catches an error in an Error Boundary. Called with theerrorcaught by the Error Boundary, and anerrorInfoobject containing thecomponentStack.",
                        "Canary onlyoptionalonUncaughtError: Callback called when an error is thrown and not caught by an Error Boundary. Called with theerrorthat was thrown and anerrorInfoobject containing thecomponentStack.",
                        "optionalonRecoverableError: Callback called when React automatically recovers from errors. Called with theerrorReact throws, and anerrorInfoobject containing thecomponentStack. Some recoverable errors may include the original error cause aserror.cause.",
                        "optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as used on the server."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "hydrateRootreturns an object with two methods:renderandunmount."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "hydrateRoot()expects the rendered content to be identical with the server-rendered content. You should treat mismatches as bugs and fix them.",
                        "In development mode, React warns about mismatches during hydration. There are no guarantees that attribute differences will be patched up in case of mismatches. This is important for performance reasons because in most apps, mismatches are rare, and so validating all markup would be prohibitively expensive.",
                        "You’ll likely have only onehydrateRootcall in your app. If you use a framework, it might do this call for you.",
                        "If your app is client-rendered with no HTML rendered already, usinghydrateRoot()is not supported. UsecreateRoot()instead."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "root.render(reactNode)"
                },
                {
                    "type": "p",
                    "text": "Callroot.renderto update a React component inside a hydrated React root for a browser DOM element."
                },
                {
                    "type": "code",
                    "code": "root.render(<App/>);"
                },
                {
                    "type": "p",
                    "text": "React will update<App />in the hydratedroot."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "reactNode: A “React node” that you want to update. This will usually be a piece of JSX like<App />, but you can also pass a React element constructed withcreateElement(), a string, a number,null, orundefined."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "root.renderreturnsundefined."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "If you callroot.renderbefore the root has finished hydrating, React will clear the existing server-rendered HTML content and switch the entire root to client rendering."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "root.unmount()"
                },
                {
                    "type": "p",
                    "text": "Callroot.unmountto destroy a rendered tree inside a React root."
                },
                {
                    "type": "code",
                    "code": "root.unmount();"
                },
                {
                    "type": "p",
                    "text": "An app fully built with React will usually not have any calls toroot.unmount."
                },
                {
                    "type": "p",
                    "text": "This is mostly useful if your React root’s DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. You need to tell React to “stop” managing the removed root’s content by callingroot.unmount. Otherwise, the components inside the removed root won’t clean up and free up resources like subscriptions."
                },
                {
                    "type": "p",
                    "text": "Callingroot.unmountwill unmount all the components in the root and “detach” React from the root DOM node, including removing any event handlers or state in the tree."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "p",
                    "text": "root.unmountdoes not accept any parameters."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "root.unmountreturnsundefined."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Callingroot.unmountwill unmount all the components in the tree and “detach” React from the root DOM node.",
                        "Once you callroot.unmountyou cannot callroot.renderagain on the root. Attempting to callroot.renderon an unmounted root will throw a “Cannot update an unmounted root” error."
                    ]
                },
                {
                    "type": "p",
                    "text": "Callingroot.unmountwill unmount all the components in the tree and “detach” React from the root DOM node."
                },
                {
                    "type": "p",
                    "text": "Once you callroot.unmountyou cannot callroot.renderagain on the root. Attempting to callroot.renderon an unmounted root will throw a “Cannot update an unmounted root” error."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Hydrating server-rendered HTML"
                },
                {
                    "type": "p",
                    "text": "If your app’s HTML was generated byreact-dom/server, you need tohydrateit on the client."
                },
                {
                    "type": "code",
                    "code": "import{hydrateRoot}from'react-dom/client';hydrateRoot(document.getElementById('root'),<App />);"
                },
                {
                    "type": "p",
                    "text": "This will hydrate the server HTML inside thebrowser DOM nodewith theReact componentfor your app. Usually, you will do it once at startup. If you use a framework, it might do this behind the scenes for you."
                },
                {
                    "type": "p",
                    "text": "To hydrate your app, React will “attach” your components’ logic to the initial generated HTML from the server. Hydration turns the initial HTML snapshot from the server into a fully interactive app that runs in the browser."
                },
                {
                    "type": "code",
                    "code": "import'./styles.css';import{hydrateRoot}from'react-dom/client';importAppfrom'./App.js';hydrateRoot(document.getElementById('root'),<App/>);"
                },
                {
                    "type": "p",
                    "text": "You shouldn’t need to callhydrateRootagain or to call it in more places. From this point on, React will be managing the DOM of your application. To update the UI, your components willuse stateinstead."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "The React tree you pass tohydrateRootneeds to producethe same outputas it did on the server."
                },
                {
                    "type": "p",
                    "text": "This is important for the user experience. The user will spend some time looking at the server-generated HTML before your JavaScript code loads. Server rendering creates an illusion that the app loads faster by showing the HTML snapshot of its output. Suddenly showing different content breaks that illusion. This is why the server render output must match the initial render output on the client."
                },
                {
                    "type": "p",
                    "text": "The most common causes leading to hydration errors include:"
                },
                {
                    "type": "list",
                    "items": [
                        "Extra whitespace (like newlines) around the React-generated HTML inside the root node.",
                        "Using checks liketypeof window !== 'undefined'in your rendering logic.",
                        "Using browser-only APIs likewindow.matchMediain your rendering logic.",
                        "Rendering different data on the server and the client."
                    ]
                },
                {
                    "type": "p",
                    "text": "React recovers from some hydration errors, butyou must fix them like other bugs.In the best case, they’ll lead to a slowdown; in the worst case, event handlers can get attached to the wrong elements."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Hydrating an entire document"
                },
                {
                    "type": "p",
                    "text": "Apps fully built with React can render the entire document as JSX, including the<html>tag:"
                },
                {
                    "type": "code",
                    "code": "functionApp(){return(<html><head><metacharSet=\"utf-8\"/><metaname=\"viewport\"content=\"width=device-width, initial-scale=1\"/><linkrel=\"stylesheet\"href=\"/styles.css\"></link><title>My app</title></head><body><Router/></body></html>);}"
                },
                {
                    "type": "p",
                    "text": "To hydrate the entire document, pass thedocumentglobal as the first argument tohydrateRoot:"
                },
                {
                    "type": "code",
                    "code": "import{hydrateRoot}from'react-dom/client';importAppfrom'./App.js';hydrateRoot(document,<App/>);"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Suppressing unavoidable hydration mismatch errors"
                },
                {
                    "type": "p",
                    "text": "If a single element’s attribute or text content is unavoidably different between the server and the client (for example, a timestamp), you may silence the hydration mismatch warning."
                },
                {
                    "type": "p",
                    "text": "To silence hydration warnings on an element, addsuppressHydrationWarning={true}:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionApp(){return(<h1suppressHydrationWarning={true}>Current Date:{newDate().toLocaleDateString()}</h1>);}"
                },
                {
                    "type": "p",
                    "text": "This only works one level deep, and is intended to be an escape hatch. Don’t overuse it. Unless it’s text content, React still won’t attempt to patch it up, so it may remain inconsistent until future updates."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Handling different client and server content"
                },
                {
                    "type": "p",
                    "text": "If you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read astate variablelikeisClient, which you can set totruein anEffect:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from\"react\";exportdefaultfunctionApp(){const[isClient,setIsClient]=useState(false);useEffect(()=>{setIsClient(true);},[]);return(<h1>{isClient?'Is Client':'Is Server'}</h1>);}"
                },
                {
                    "type": "p",
                    "text": "This way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "This approach makes hydration slower because your components have to render twice. Be mindful of the user experience on slow connections. The JavaScript code may load significantly later than the initial HTML render, so rendering a different UI immediately after hydration may also feel jarring to the user."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Updating a hydrated root component"
                },
                {
                    "type": "p",
                    "text": "After the root has finished hydrating, you can callroot.renderto update the root React component.Unlike withcreateRoot, you don’t usually need to do this because the initial content was already rendered as HTML."
                },
                {
                    "type": "p",
                    "text": "If you callroot.renderat some point after hydration, and the component tree structure matches up with what was previously rendered, React willpreserve the state.Notice how you can type in the input, which means that the updates from repeatedrendercalls every second in this example are not destructive:"
                },
                {
                    "type": "code",
                    "code": "import{hydrateRoot}from'react-dom/client';import'./styles.css';importAppfrom'./App.js';constroot=hydrateRoot(document.getElementById('root'),<Appcounter={0}/>);leti=0;setInterval(()=>{root.render(<Appcounter={i}/>);i++;},1000);"
                },
                {
                    "type": "p",
                    "text": "It is uncommon to callroot.renderon a hydrated root. Usually, you’llupdate stateinside one of the components instead."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Show a dialog for uncaught errors"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "onUncaughtErroris only available in the latest React Canary release."
                },
                {
                    "type": "p",
                    "text": "By default, React will log all uncaught errors to the console. To implement your own error reporting, you can provide the optionalonUncaughtErrorroot option:"
                },
                {
                    "type": "code",
                    "code": "import{hydrateRoot}from'react-dom/client';constroot=hydrateRoot(document.getElementById('root'),<App/>,{onUncaughtError:(error,errorInfo)=>{console.error('Uncaught error',error,errorInfo.componentStack);}});root.render(<App/>);"
                },
                {
                    "type": "p",
                    "text": "TheonUncaughtErroroption is a function called with two arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "Theerrorthat was thrown.",
                        "AnerrorInfoobject that contains thecomponentStackof the error."
                    ]
                },
                {
                    "type": "p",
                    "text": "You can use theonUncaughtErrorroot option to display error dialogs:"
                },
                {
                    "type": "code",
                    "code": "import{hydrateRoot}from\"react-dom/client\";importAppfrom\"./App.js\";import{reportUncaughtError}from\"./reportError\";import\"./styles.css\";import{renderToString}from'react-dom/server';constcontainer=document.getElementById(\"root\");constroot=hydrateRoot(container,<App/>,{onUncaughtError:(error,errorInfo)=>{if(error.message!=='Known error'){reportUncaughtError({error,componentStack:errorInfo.componentStack});}}});"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Displaying Error Boundary errors"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "onCaughtErroris only available in the latest React Canary release."
                },
                {
                    "type": "p",
                    "text": "By default, React will log all errors caught by an Error Boundary toconsole.error. To override this behavior, you can provide the optionalonCaughtErrorroot option for errors caught by anError Boundary:"
                },
                {
                    "type": "code",
                    "code": "import{hydrateRoot}from'react-dom/client';constroot=hydrateRoot(document.getElementById('root'),<App/>,{onCaughtError:(error,errorInfo)=>{console.error('Caught error',error,errorInfo.componentStack);}});root.render(<App/>);"
                },
                {
                    "type": "p",
                    "text": "TheonCaughtErroroption is a function called with two arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "Theerrorthat was caught by the boundary.",
                        "AnerrorInfoobject that contains thecomponentStackof the error."
                    ]
                },
                {
                    "type": "p",
                    "text": "You can use theonCaughtErrorroot option to display error dialogs or filter known errors from logging:"
                },
                {
                    "type": "code",
                    "code": "import{hydrateRoot}from\"react-dom/client\";importAppfrom\"./App.js\";import{reportCaughtError}from\"./reportError\";import\"./styles.css\";constcontainer=document.getElementById(\"root\");constroot=hydrateRoot(container,<App/>,{onCaughtError:(error,errorInfo)=>{if(error.message!=='Known error'){reportCaughtError({error,componentStack:errorInfo.componentStack});}}});"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Show a dialog for recoverable hydration mismatch errors"
                },
                {
                    "type": "p",
                    "text": "When React encounters a hydration mismatch, it will automatically attempt to recover by rendering on the client. By default, React will log hydration mismatch errors toconsole.error. To override this behavior, you can provide the optionalonRecoverableErrorroot option:"
                },
                {
                    "type": "code",
                    "code": "import{hydrateRoot}from'react-dom/client';constroot=hydrateRoot(document.getElementById('root'),<App/>,{onRecoverableError:(error,errorInfo)=>{console.error('Caught error',error,error.cause,errorInfo.componentStack);}});"
                },
                {
                    "type": "p",
                    "text": "TheonRecoverableErroroption is a function called with two arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "TheerrorReact throws. Some errors may include the original cause aserror.cause.",
                        "AnerrorInfoobject that contains thecomponentStackof the error."
                    ]
                },
                {
                    "type": "p",
                    "text": "You can use theonRecoverableErrorroot option to display error dialogs for hydration mismatches:"
                },
                {
                    "type": "code",
                    "code": "import{hydrateRoot}from\"react-dom/client\";importAppfrom\"./App.js\";import{reportRecoverableError}from\"./reportError\";import\"./styles.css\";constcontainer=document.getElementById(\"root\");constroot=hydrateRoot(container,<App/>,{onRecoverableError:(error,errorInfo)=>{reportRecoverableError({error,cause:error.cause,componentStack:errorInfo.componentStack});}});"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’m getting an error: “You passed a second argument to root.render”"
                },
                {
                    "type": "p",
                    "text": "A common mistake is to pass the options forhydrateRoottoroot.render(...):"
                },
                {
                    "type": "p",
                    "text": "To fix, pass the root options tohydrateRoot(...), notroot.render(...):"
                },
                {
                    "type": "code",
                    "code": "// 🚩 Wrong: root.render only takes one argument.root.render(App,{onUncaughtError});// ✅ Correct: pass options to createRoot.constroot=hydrateRoot(container,<App/>,{onUncaughtError});"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/components",
            "title": "React DOM Components – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "React DOM Components"
                },
                {
                    "type": "p",
                    "text": "React supports all of the browser built-inHTMLandSVGcomponents."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Common components"
                },
                {
                    "type": "p",
                    "text": "All of the built-in browser components support some props and events."
                },
                {
                    "type": "list",
                    "items": [
                        "Common components (e.g.<div>)"
                    ]
                },
                {
                    "type": "p",
                    "text": "This includes React-specific props likerefanddangerouslySetInnerHTML."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Form components"
                },
                {
                    "type": "p",
                    "text": "These built-in browser components accept user input:"
                },
                {
                    "type": "list",
                    "items": [
                        "<input>",
                        "<select>",
                        "<textarea>"
                    ]
                },
                {
                    "type": "p",
                    "text": "They are special in React because passing thevalueprop to them makes themcontrolled."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Resource and Metadata Components"
                },
                {
                    "type": "p",
                    "text": "These built-in browser components let you load external resources or annotate the document with metadata:"
                },
                {
                    "type": "list",
                    "items": [
                        "<link>",
                        "<meta>",
                        "<script>",
                        "<style>",
                        "<title>"
                    ]
                },
                {
                    "type": "p",
                    "text": "They are special in React because React can render them into the document head, suspend while resources are loading, and enact other behaviors that are described on the reference page for each specific component."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "All HTML components"
                },
                {
                    "type": "p",
                    "text": "React supports all built-in browser HTML components. This includes:"
                },
                {
                    "type": "list",
                    "items": [
                        "<aside>",
                        "<audio>",
                        "<b>",
                        "<base>",
                        "<bdi>",
                        "<bdo>",
                        "<blockquote>",
                        "<body>",
                        "<br>",
                        "<button>",
                        "<canvas>",
                        "<caption>",
                        "<cite>",
                        "<code>",
                        "<col>",
                        "<colgroup>",
                        "<data>",
                        "<datalist>",
                        "<dd>",
                        "<del>",
                        "<details>",
                        "<dfn>",
                        "<dialog>",
                        "<div>",
                        "<dl>",
                        "<dt>",
                        "<em>",
                        "<embed>",
                        "<fieldset>",
                        "<figcaption>",
                        "<figure>",
                        "<footer>",
                        "<form>",
                        "<h1>",
                        "<head>",
                        "<header>",
                        "<hgroup>",
                        "<hr>",
                        "<html>",
                        "<i>",
                        "<iframe>",
                        "<img>",
                        "<input>",
                        "<ins>",
                        "<kbd>",
                        "<label>",
                        "<legend>",
                        "<li>",
                        "<link>",
                        "<main>",
                        "<map>",
                        "<mark>",
                        "<menu>",
                        "<meta>",
                        "<meter>",
                        "<nav>",
                        "<noscript>",
                        "<object>",
                        "<ol>",
                        "<optgroup>",
                        "<option>",
                        "<output>",
                        "<p>",
                        "<picture>",
                        "<pre>",
                        "<progress>",
                        "<q>",
                        "<rp>",
                        "<rt>",
                        "<ruby>",
                        "<s>",
                        "<samp>",
                        "<script>",
                        "<section>",
                        "<select>",
                        "<slot>",
                        "<small>",
                        "<source>",
                        "<span>",
                        "<strong>",
                        "<style>",
                        "<sub>",
                        "<summary>",
                        "<sup>",
                        "<table>",
                        "<tbody>",
                        "<td>",
                        "<template>",
                        "<textarea>",
                        "<tfoot>",
                        "<th>",
                        "<thead>",
                        "<time>",
                        "<title>",
                        "<tr>",
                        "<track>",
                        "<u>",
                        "<ul>",
                        "<var>",
                        "<video>",
                        "<wbr>"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Similar to theDOM standard,React uses acamelCaseconvention for prop names. For example, you’ll writetabIndexinstead oftabindex. You can convert existing HTML to JSX with anonline converter."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Custom HTML elements"
                },
                {
                    "type": "p",
                    "text": "If you render a tag with a dash, like<my-element>, React will assume you want to render acustom HTML element.In React, rendering custom elements works differently from rendering built-in browser tags:"
                },
                {
                    "type": "list",
                    "items": [
                        "All custom element props are serialized to strings and are always set using attributes.",
                        "Custom elements acceptclassrather thanclassName, andforrather thanhtmlFor."
                    ]
                },
                {
                    "type": "p",
                    "text": "If you render a built-in browser HTML element with anisattribute, it will also be treated as a custom element."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "A future version of React will include more comprehensive support for custom elements."
                },
                {
                    "type": "p",
                    "text": "You can try it by upgrading React packages to the most recent experimental version:"
                },
                {
                    "type": "list",
                    "items": [
                        "react@experimental",
                        "react-dom@experimental"
                    ]
                },
                {
                    "type": "p",
                    "text": "Experimental versions of React may contain bugs. Don’t use them in production."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "All SVG components"
                },
                {
                    "type": "p",
                    "text": "React supports all built-in browser SVG components. This includes:"
                },
                {
                    "type": "list",
                    "items": [
                        "<a>",
                        "<animate>",
                        "<animateMotion>",
                        "<animateTransform>",
                        "<circle>",
                        "<clipPath>",
                        "<defs>",
                        "<desc>",
                        "<discard>",
                        "<ellipse>",
                        "<feBlend>",
                        "<feColorMatrix>",
                        "<feComponentTransfer>",
                        "<feComposite>",
                        "<feConvolveMatrix>",
                        "<feDiffuseLighting>",
                        "<feDisplacementMap>",
                        "<feDistantLight>",
                        "<feDropShadow>",
                        "<feFlood>",
                        "<feFuncA>",
                        "<feFuncB>",
                        "<feFuncG>",
                        "<feFuncR>",
                        "<feGaussianBlur>",
                        "<feImage>",
                        "<feMerge>",
                        "<feMergeNode>",
                        "<feMorphology>",
                        "<feOffset>",
                        "<fePointLight>",
                        "<feSpecularLighting>",
                        "<feSpotLight>",
                        "<feTile>",
                        "<feTurbulence>",
                        "<filter>",
                        "<foreignObject>",
                        "<g>",
                        "<hatch>",
                        "<hatchpath>",
                        "<image>",
                        "<line>",
                        "<linearGradient>",
                        "<marker>",
                        "<mask>",
                        "<metadata>",
                        "<mpath>",
                        "<path>",
                        "<pattern>",
                        "<polygon>",
                        "<polyline>",
                        "<radialGradient>",
                        "<rect>",
                        "<script>",
                        "<set>",
                        "<stop>",
                        "<style>",
                        "<svg>",
                        "<switch>",
                        "<symbol>",
                        "<text>",
                        "<textPath>",
                        "<title>",
                        "<tspan>",
                        "<use>",
                        "<view>"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Similar to theDOM standard,React uses acamelCaseconvention for prop names. For example, you’ll writetabIndexinstead oftabindex. You can convert existing SVG to JSX with anonline converter."
                },
                {
                    "type": "p",
                    "text": "Namespaced attributes also have to be written without the colon:"
                },
                {
                    "type": "list",
                    "items": [
                        "xlink:actuatebecomesxlinkActuate.",
                        "xlink:arcrolebecomesxlinkArcrole.",
                        "xlink:hrefbecomesxlinkHref.",
                        "xlink:rolebecomesxlinkRole.",
                        "xlink:showbecomesxlinkShow.",
                        "xlink:titlebecomesxlinkTitle.",
                        "xlink:typebecomesxlinkType.",
                        "xml:basebecomesxmlBase.",
                        "xml:langbecomesxmlLang.",
                        "xml:spacebecomesxmlSpace.",
                        "xmlns:xlinkbecomesxmlnsXlink."
                    ]
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/components/common",
            "title": "Common components (e.g. <div>) – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Common components (e.g. <div>)"
                },
                {
                    "type": "p",
                    "text": "All built-in browser components, such as<div>, support some common props and events."
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceCommon components (e.g.<div>)refcallback functionReact event objectAnimationEventhandler functionClipboardEventhandler functionCompositionEventhandler functionDragEventhandler functionFocusEventhandler functionEventhandler functionInputEventhandler functionKeyboardEventhandler functionMouseEventhandler functionPointerEventhandler functionTouchEventhandler functionTransitionEventhandler functionUIEventhandler functionWheelEventhandler function",
                        "Common components (e.g.<div>)",
                        "refcallback function",
                        "React event object",
                        "AnimationEventhandler function",
                        "ClipboardEventhandler function",
                        "CompositionEventhandler function",
                        "DragEventhandler function",
                        "FocusEventhandler function",
                        "Eventhandler function",
                        "InputEventhandler function",
                        "KeyboardEventhandler function",
                        "MouseEventhandler function",
                        "PointerEventhandler function",
                        "TouchEventhandler function",
                        "TransitionEventhandler function",
                        "UIEventhandler function",
                        "WheelEventhandler function",
                        "UsageApplying CSS stylesManipulating a DOM node with a refDangerously setting the inner HTMLHandling mouse eventsHandling pointer eventsHandling focus eventsHandling keyboard events",
                        "Applying CSS styles",
                        "Manipulating a DOM node with a ref",
                        "Dangerously setting the inner HTML",
                        "Handling mouse events",
                        "Handling pointer events",
                        "Handling focus events",
                        "Handling keyboard events"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Common components (e.g.<div>)",
                        "refcallback function",
                        "React event object",
                        "AnimationEventhandler function",
                        "ClipboardEventhandler function",
                        "CompositionEventhandler function",
                        "DragEventhandler function",
                        "FocusEventhandler function",
                        "Eventhandler function",
                        "InputEventhandler function",
                        "KeyboardEventhandler function",
                        "MouseEventhandler function",
                        "PointerEventhandler function",
                        "TouchEventhandler function",
                        "TransitionEventhandler function",
                        "UIEventhandler function",
                        "WheelEventhandler function"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Applying CSS styles",
                        "Manipulating a DOM node with a ref",
                        "Dangerously setting the inner HTML",
                        "Handling mouse events",
                        "Handling pointer events",
                        "Handling focus events",
                        "Handling keyboard events"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Common components (e.g.<div>)"
                },
                {
                    "type": "code",
                    "code": "<divclassName=\"wrapper\">Some content</div>"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Props"
                },
                {
                    "type": "p",
                    "text": "These special React props are supported for all built-in components:"
                },
                {
                    "type": "list",
                    "items": [
                        "children: A React node (an element, a string, a number,a portal,an empty node likenull,undefinedand booleans, or an array of other React nodes). Specifies the content inside the component. When you use JSX, you will usually specify thechildrenprop implicitly by nesting tags like<div><span /></div>.",
                        "dangerouslySetInnerHTML: An object of the form{ __html: '<p>some html</p>' }with a raw HTML string inside. Overrides theinnerHTMLproperty of the DOM node and displays the passed HTML inside. This should be used with extreme caution! If the HTML inside isn’t trusted (for example, if it’s based on user data), you risk introducing anXSSvulnerability.Read more about usingdangerouslySetInnerHTML.",
                        "ref: A ref object fromuseReforcreateRef, or arefcallback function,or a string forlegacy refs.Your ref will be filled with the DOM element for this node.Read more about manipulating the DOM with refs.",
                        "suppressContentEditableWarning: A boolean. Iftrue, suppresses the warning that React shows for elements that both havechildrenandcontentEditable={true}(which normally do not work together). Use this if you’re building a text input library that manages thecontentEditablecontent manually.",
                        "suppressHydrationWarning: A boolean. If you useserver rendering,normally there is a warning when the server and the client render different content. In some rare cases (like timestamps), it is very hard or impossible to guarantee an exact match. If you setsuppressHydrationWarningtotrue, React will not warn you about mismatches in the attributes and the content of that element. It only works one level deep, and is intended to be used as an escape hatch. Don’t overuse it.Read about suppressing hydration errors.",
                        "style: An object with CSS styles, for example{ fontWeight: 'bold', margin: 20 }. Similarly to the DOMstyleproperty, the CSS property names need to be written ascamelCase, for examplefontWeightinstead offont-weight. You can pass strings or numbers as values. If you pass a number, likewidth: 100, React will automatically appendpx(“pixels”) to the value unless it’s aunitless property.We recommend usingstyleonly for dynamic styles where you don’t know the style values ahead of time. In other cases, applying plain CSS classes withclassNameis more efficient.Read more aboutclassNameandstyle."
                    ]
                },
                {
                    "type": "p",
                    "text": "children: A React node (an element, a string, a number,a portal,an empty node likenull,undefinedand booleans, or an array of other React nodes). Specifies the content inside the component. When you use JSX, you will usually specify thechildrenprop implicitly by nesting tags like<div><span /></div>."
                },
                {
                    "type": "p",
                    "text": "dangerouslySetInnerHTML: An object of the form{ __html: '<p>some html</p>' }with a raw HTML string inside. Overrides theinnerHTMLproperty of the DOM node and displays the passed HTML inside. This should be used with extreme caution! If the HTML inside isn’t trusted (for example, if it’s based on user data), you risk introducing anXSSvulnerability.Read more about usingdangerouslySetInnerHTML."
                },
                {
                    "type": "p",
                    "text": "ref: A ref object fromuseReforcreateRef, or arefcallback function,or a string forlegacy refs.Your ref will be filled with the DOM element for this node.Read more about manipulating the DOM with refs."
                },
                {
                    "type": "p",
                    "text": "suppressContentEditableWarning: A boolean. Iftrue, suppresses the warning that React shows for elements that both havechildrenandcontentEditable={true}(which normally do not work together). Use this if you’re building a text input library that manages thecontentEditablecontent manually."
                },
                {
                    "type": "p",
                    "text": "suppressHydrationWarning: A boolean. If you useserver rendering,normally there is a warning when the server and the client render different content. In some rare cases (like timestamps), it is very hard or impossible to guarantee an exact match. If you setsuppressHydrationWarningtotrue, React will not warn you about mismatches in the attributes and the content of that element. It only works one level deep, and is intended to be used as an escape hatch. Don’t overuse it.Read about suppressing hydration errors."
                },
                {
                    "type": "p",
                    "text": "style: An object with CSS styles, for example{ fontWeight: 'bold', margin: 20 }. Similarly to the DOMstyleproperty, the CSS property names need to be written ascamelCase, for examplefontWeightinstead offont-weight. You can pass strings or numbers as values. If you pass a number, likewidth: 100, React will automatically appendpx(“pixels”) to the value unless it’s aunitless property.We recommend usingstyleonly for dynamic styles where you don’t know the style values ahead of time. In other cases, applying plain CSS classes withclassNameis more efficient.Read more aboutclassNameandstyle."
                },
                {
                    "type": "p",
                    "text": "These standard DOM props are also supported for all built-in components:"
                },
                {
                    "type": "list",
                    "items": [
                        "accessKey: A string. Specifies a keyboard shortcut for the element.Not generally recommended.",
                        "aria-*: ARIA attributes let you specify the accessibility tree information for this element. SeeARIA attributesfor a complete reference. In React, all ARIA attribute names are exactly the same as in HTML.",
                        "autoCapitalize: A string. Specifies whether and how the user input should be capitalized.",
                        "className: A string. Specifies the element’s CSS class name.Read more about applying CSS styles.",
                        "contentEditable: A boolean. Iftrue, the browser lets the user edit the rendered element directly. This is used to implement rich text input libraries likeLexical.React warns if you try to pass React children to an element withcontentEditable={true}because React will not be able to update its content after user edits.",
                        "data-*: Data attributes let you attach some string data to the element, for exampledata-fruit=\"banana\". In React, they are not commonly used because you would usually read data from props or state instead.",
                        "dir: Either'ltr'or'rtl'. Specifies the text direction of the element.",
                        "draggable: A boolean. Specifies whether the element is draggable. Part ofHTML Drag and Drop API.",
                        "enterKeyHint: A string. Specifies which action to present for the enter key on virtual keyboards.",
                        "htmlFor: A string. For<label>and<output>, lets youassociate the label with some control.Same asforHTML attribute.React uses the standard DOM property names (htmlFor) instead of HTML attribute names.",
                        "hidden: A boolean or a string. Specifies whether the element should be hidden.",
                        "id: A string. Specifies a unique identifier for this element, which can be used to find it later or connect it with other elements. Generate it withuseIdto avoid clashes between multiple instances of the same component.",
                        "is: A string. If specified, the component will behave like acustom element.",
                        "inputMode: A string. Specifies what kind of keyboard to display (for example, text, number or telephone).",
                        "itemProp: A string. Specifies which property the element represents for structured data crawlers.",
                        "lang: A string. Specifies the language of the element.",
                        "onAnimationEnd: AnAnimationEventhandlerfunction. Fires when a CSS animation completes.",
                        "onAnimationEndCapture: A version ofonAnimationEndthat fires in thecapture phase.",
                        "onAnimationIteration: AnAnimationEventhandlerfunction. Fires when an iteration of a CSS animation ends, and another one begins.",
                        "onAnimationIterationCapture: A version ofonAnimationIterationthat fires in thecapture phase.",
                        "onAnimationStart: AnAnimationEventhandlerfunction. Fires when a CSS animation starts.",
                        "onAnimationStartCapture:onAnimationStart, but fires in thecapture phase.",
                        "onAuxClick: AMouseEventhandlerfunction. Fires when a non-primary pointer button was clicked.",
                        "onAuxClickCapture: A version ofonAuxClickthat fires in thecapture phase.",
                        "onBeforeInput: AnInputEventhandlerfunction. Fires before the value of an editable element is modified. React doesnotyet use the nativebeforeinputevent, and instead attempts to polyfill it using other events.",
                        "onBeforeInputCapture: A version ofonBeforeInputthat fires in thecapture phase.",
                        "onBlur: AFocusEventhandlerfunction. Fires when an element lost focus. Unlike the built-in browserblurevent, in React theonBlurevent bubbles.",
                        "onBlurCapture: A version ofonBlurthat fires in thecapture phase.",
                        "onClick: AMouseEventhandlerfunction. Fires when the primary button was clicked on the pointing device.",
                        "onClickCapture: A version ofonClickthat fires in thecapture phase.",
                        "onCompositionStart: ACompositionEventhandlerfunction. Fires when aninput method editorstarts a new composition session.",
                        "onCompositionStartCapture: A version ofonCompositionStartthat fires in thecapture phase.",
                        "onCompositionEnd: ACompositionEventhandlerfunction. Fires when aninput method editorcompletes or cancels a composition session.",
                        "onCompositionEndCapture: A version ofonCompositionEndthat fires in thecapture phase.",
                        "onCompositionUpdate: ACompositionEventhandlerfunction. Fires when aninput method editorreceives a new character.",
                        "onCompositionUpdateCapture: A version ofonCompositionUpdatethat fires in thecapture phase.",
                        "onContextMenu: AMouseEventhandlerfunction. Fires when the user tries to open a context menu.",
                        "onContextMenuCapture: A version ofonContextMenuthat fires in thecapture phase.",
                        "onCopy: AClipboardEventhandlerfunction. Fires when the user tries to copy something into the clipboard.",
                        "onCopyCapture: A version ofonCopythat fires in thecapture phase.",
                        "onCut: AClipboardEventhandlerfunction. Fires when the user tries to cut something into the clipboard.",
                        "onCutCapture: A version ofonCutthat fires in thecapture phase.",
                        "onDoubleClick: AMouseEventhandlerfunction. Fires when the user clicks twice. Corresponds to the browserdblclickevent.",
                        "onDoubleClickCapture: A version ofonDoubleClickthat fires in thecapture phase.",
                        "onDrag: ADragEventhandlerfunction. Fires while the user is dragging something.",
                        "onDragCapture: A version ofonDragthat fires in thecapture phase.",
                        "onDragEnd: ADragEventhandlerfunction. Fires when the user stops dragging something.",
                        "onDragEndCapture: A version ofonDragEndthat fires in thecapture phase.",
                        "onDragEnter: ADragEventhandlerfunction. Fires when the dragged content enters a valid drop target.",
                        "onDragEnterCapture: A version ofonDragEnterthat fires in thecapture phase.",
                        "onDragOver: ADragEventhandlerfunction. Fires on a valid drop target while the dragged content is dragged over it. You must calle.preventDefault()here to allow dropping.",
                        "onDragOverCapture: A version ofonDragOverthat fires in thecapture phase.",
                        "onDragStart: ADragEventhandlerfunction. Fires when the user starts dragging an element.",
                        "onDragStartCapture: A version ofonDragStartthat fires in thecapture phase.",
                        "onDrop: ADragEventhandlerfunction. Fires when something is dropped on a valid drop target.",
                        "onDropCapture: A version ofonDropthat fires in thecapture phase.",
                        "onFocus: AFocusEventhandlerfunction. Fires when an element receives focus. Unlike the built-in browserfocusevent, in React theonFocusevent bubbles.",
                        "onFocusCapture: A version ofonFocusthat fires in thecapture phase.",
                        "onGotPointerCapture: APointerEventhandlerfunction. Fires when an element programmatically captures a pointer.",
                        "onGotPointerCaptureCapture: A version ofonGotPointerCapturethat fires in thecapture phase.",
                        "onKeyDown: AKeyboardEventhandlerfunction. Fires when a key is pressed.",
                        "onKeyDownCapture: A version ofonKeyDownthat fires in thecapture phase.",
                        "onKeyPress: AKeyboardEventhandlerfunction. Deprecated. UseonKeyDownoronBeforeInputinstead.",
                        "onKeyPressCapture: A version ofonKeyPressthat fires in thecapture phase.",
                        "onKeyUp: AKeyboardEventhandlerfunction. Fires when a key is released.",
                        "onKeyUpCapture: A version ofonKeyUpthat fires in thecapture phase.",
                        "onLostPointerCapture: APointerEventhandlerfunction. Fires when an element stops capturing a pointer.",
                        "onLostPointerCaptureCapture: A version ofonLostPointerCapturethat fires in thecapture phase.",
                        "onMouseDown: AMouseEventhandlerfunction. Fires when the pointer is pressed down.",
                        "onMouseDownCapture: A version ofonMouseDownthat fires in thecapture phase.",
                        "onMouseEnter: AMouseEventhandlerfunction. Fires when the pointer moves inside an element. Does not have a capture phase. Instead,onMouseLeaveandonMouseEnterpropagate from the element being left to the one being entered.",
                        "onMouseLeave: AMouseEventhandlerfunction. Fires when the pointer moves outside an element. Does not have a capture phase. Instead,onMouseLeaveandonMouseEnterpropagate from the element being left to the one being entered.",
                        "onMouseMove: AMouseEventhandlerfunction. Fires when the pointer changes coordinates.",
                        "onMouseMoveCapture: A version ofonMouseMovethat fires in thecapture phase.",
                        "onMouseOut: AMouseEventhandlerfunction. Fires when the pointer moves outside an element, or if it moves into a child element.",
                        "onMouseOutCapture: A version ofonMouseOutthat fires in thecapture phase.",
                        "onMouseUp: AMouseEventhandlerfunction. Fires when the pointer is released.",
                        "onMouseUpCapture: A version ofonMouseUpthat fires in thecapture phase.",
                        "onPointerCancel: APointerEventhandlerfunction. Fires when the browser cancels a pointer interaction.",
                        "onPointerCancelCapture: A version ofonPointerCancelthat fires in thecapture phase.",
                        "onPointerDown: APointerEventhandlerfunction. Fires when a pointer becomes active.",
                        "onPointerDownCapture: A version ofonPointerDownthat fires in thecapture phase.",
                        "onPointerEnter: APointerEventhandlerfunction. Fires when a pointer moves inside an element. Does not have a capture phase. Instead,onPointerLeaveandonPointerEnterpropagate from the element being left to the one being entered.",
                        "onPointerLeave: APointerEventhandlerfunction. Fires when a pointer moves outside an element. Does not have a capture phase. Instead,onPointerLeaveandonPointerEnterpropagate from the element being left to the one being entered.",
                        "onPointerMove: APointerEventhandlerfunction. Fires when a pointer changes coordinates.",
                        "onPointerMoveCapture: A version ofonPointerMovethat fires in thecapture phase.",
                        "onPointerOut: APointerEventhandlerfunction. Fires when a pointer moves outside an element, if the pointer interaction is cancelled, anda few other reasons.",
                        "onPointerOutCapture: A version ofonPointerOutthat fires in thecapture phase.",
                        "onPointerUp: APointerEventhandlerfunction. Fires when a pointer is no longer active.",
                        "onPointerUpCapture: A version ofonPointerUpthat fires in thecapture phase.",
                        "onPaste: AClipboardEventhandlerfunction. Fires when the user tries to paste something from the clipboard.",
                        "onPasteCapture: A version ofonPastethat fires in thecapture phase.",
                        "onScroll: AnEventhandlerfunction. Fires when an element has been scrolled. This event does not bubble.",
                        "onScrollCapture: A version ofonScrollthat fires in thecapture phase.",
                        "onSelect: AnEventhandlerfunction. Fires after the selection inside an editable element like an input changes. React extends theonSelectevent to work forcontentEditable={true}elements as well. In addition, React extends it to fire for empty selection and on edits (which may affect the selection).",
                        "onSelectCapture: A version ofonSelectthat fires in thecapture phase.",
                        "onTouchCancel: ATouchEventhandlerfunction. Fires when the browser cancels a touch interaction.",
                        "onTouchCancelCapture: A version ofonTouchCancelthat fires in thecapture phase.",
                        "onTouchEnd: ATouchEventhandlerfunction. Fires when one or more touch points are removed.",
                        "onTouchEndCapture: A version ofonTouchEndthat fires in thecapture phase.",
                        "onTouchMove: ATouchEventhandlerfunction. Fires one or more touch points are moved.",
                        "onTouchMoveCapture: A version ofonTouchMovethat fires in thecapture phase.",
                        "onTouchStart: ATouchEventhandlerfunction. Fires when one or more touch points are placed.",
                        "onTouchStartCapture: A version ofonTouchStartthat fires in thecapture phase.",
                        "onTransitionEnd: ATransitionEventhandlerfunction. Fires when a CSS transition completes.",
                        "onTransitionEndCapture: A version ofonTransitionEndthat fires in thecapture phase.",
                        "onWheel: AWheelEventhandlerfunction. Fires when the user rotates a wheel button.",
                        "onWheelCapture: A version ofonWheelthat fires in thecapture phase.",
                        "role: A string. Specifies the element role explicitly for assistive technologies.",
                        "slot: A string. Specifies the slot name when using shadow DOM. In React, an equivalent pattern is typically achieved by passing JSX as props, for example<Layout left={<Sidebar />} right={<Content />} />.",
                        "spellCheck: A boolean or null. If explicitly set totrueorfalse, enables or disables spellchecking.",
                        "tabIndex: A number. Overrides the default Tab button behavior.Avoid using values other than-1and0.",
                        "title: A string. Specifies the tooltip text for the element.",
                        "translate: Either'yes'or'no'. Passing'no'excludes the element content from being translated."
                    ]
                },
                {
                    "type": "p",
                    "text": "You can also pass custom attributes as props, for examplemycustomprop=\"someValue\". This can be useful when integrating with third-party libraries. The custom attribute name must be lowercase and must not start withon. The value will be converted to a string. If you passnullorundefined, the custom attribute will be removed."
                },
                {
                    "type": "p",
                    "text": "These events fire only for the<form>elements:"
                },
                {
                    "type": "list",
                    "items": [
                        "onReset: AnEventhandlerfunction. Fires when a form gets reset.",
                        "onResetCapture: A version ofonResetthat fires in thecapture phase.",
                        "onSubmit: AnEventhandlerfunction. Fires when a form gets submitted.",
                        "onSubmitCapture: A version ofonSubmitthat fires in thecapture phase."
                    ]
                },
                {
                    "type": "p",
                    "text": "These events fire only for the<dialog>elements. Unlike browser events, they bubble in React:"
                },
                {
                    "type": "list",
                    "items": [
                        "onCancel: AnEventhandlerfunction. Fires when the user tries to dismiss the dialog.",
                        "onCancelCapture: A version ofonCancelthat fires in thecapture phase.",
                        "onClose: AnEventhandlerfunction. Fires when a dialog has been closed.",
                        "onCloseCapture: A version ofonClosethat fires in thecapture phase."
                    ]
                },
                {
                    "type": "p",
                    "text": "These events fire only for the<details>elements. Unlike browser events, they bubble in React:"
                },
                {
                    "type": "list",
                    "items": [
                        "onToggle: AnEventhandlerfunction. Fires when the user toggles the details.",
                        "onToggleCapture: A version ofonTogglethat fires in thecapture phase."
                    ]
                },
                {
                    "type": "p",
                    "text": "These events fire for<img>,<iframe>,<object>,<embed>,<link>, andSVG<image>elements. Unlike browser events, they bubble in React:"
                },
                {
                    "type": "list",
                    "items": [
                        "onLoad: AnEventhandlerfunction. Fires when the resource has loaded.",
                        "onLoadCapture: A version ofonLoadthat fires in thecapture phase.",
                        "onError: AnEventhandlerfunction. Fires when the resource could not be loaded.",
                        "onErrorCapture: A version ofonErrorthat fires in thecapture phase."
                    ]
                },
                {
                    "type": "p",
                    "text": "These events fire for resources like<audio>and<video>. Unlike browser events, they bubble in React:"
                },
                {
                    "type": "list",
                    "items": [
                        "onAbort: AnEventhandlerfunction. Fires when the resource has not fully loaded, but not due to an error.",
                        "onAbortCapture: A version ofonAbortthat fires in thecapture phase.",
                        "onCanPlay: AnEventhandlerfunction. Fires when there’s enough data to start playing, but not enough to play to the end without buffering.",
                        "onCanPlayCapture: A version ofonCanPlaythat fires in thecapture phase.",
                        "onCanPlayThrough: AnEventhandlerfunction. Fires when there’s enough data that it’s likely possible to start playing without buffering until the end.",
                        "onCanPlayThroughCapture: A version ofonCanPlayThroughthat fires in thecapture phase.",
                        "onDurationChange: AnEventhandlerfunction. Fires when the media duration has updated.",
                        "onDurationChangeCapture: A version ofonDurationChangethat fires in thecapture phase.",
                        "onEmptied: AnEventhandlerfunction. Fires when the media has become empty.",
                        "onEmptiedCapture: A version ofonEmptiedthat fires in thecapture phase.",
                        "onEncrypted: AnEventhandlerfunction. Fires when the browser encounters encrypted media.",
                        "onEncryptedCapture: A version ofonEncryptedthat fires in thecapture phase.",
                        "onEnded: AnEventhandlerfunction. Fires when the playback stops because there’s nothing left to play.",
                        "onEndedCapture: A version ofonEndedthat fires in thecapture phase.",
                        "onError: AnEventhandlerfunction. Fires when the resource could not be loaded.",
                        "onErrorCapture: A version ofonErrorthat fires in thecapture phase.",
                        "onLoadedData: AnEventhandlerfunction. Fires when the current playback frame has loaded.",
                        "onLoadedDataCapture: A version ofonLoadedDatathat fires in thecapture phase.",
                        "onLoadedMetadata: AnEventhandlerfunction. Fires when metadata has loaded.",
                        "onLoadedMetadataCapture: A version ofonLoadedMetadatathat fires in thecapture phase.",
                        "onLoadStart: AnEventhandlerfunction. Fires when the browser started loading the resource.",
                        "onLoadStartCapture: A version ofonLoadStartthat fires in thecapture phase.",
                        "onPause: AnEventhandlerfunction. Fires when the media was paused.",
                        "onPauseCapture: A version ofonPausethat fires in thecapture phase.",
                        "onPlay: AnEventhandlerfunction. Fires when the media is no longer paused.",
                        "onPlayCapture: A version ofonPlaythat fires in thecapture phase.",
                        "onPlaying: AnEventhandlerfunction. Fires when the media starts or restarts playing.",
                        "onPlayingCapture: A version ofonPlayingthat fires in thecapture phase.",
                        "onProgress: AnEventhandlerfunction. Fires periodically while the resource is loading.",
                        "onProgressCapture: A version ofonProgressthat fires in thecapture phase.",
                        "onRateChange: AnEventhandlerfunction. Fires when playback rate changes.",
                        "onRateChangeCapture: A version ofonRateChangethat fires in thecapture phase.",
                        "onResize: AnEventhandlerfunction. Fires when video changes size.",
                        "onResizeCapture: A version ofonResizethat fires in thecapture phase.",
                        "onSeeked: AnEventhandlerfunction. Fires when a seek operation completes.",
                        "onSeekedCapture: A version ofonSeekedthat fires in thecapture phase.",
                        "onSeeking: AnEventhandlerfunction. Fires when a seek operation starts.",
                        "onSeekingCapture: A version ofonSeekingthat fires in thecapture phase.",
                        "onStalled: AnEventhandlerfunction. Fires when the browser is waiting for data but it keeps not loading.",
                        "onStalledCapture: A version ofonStalledthat fires in thecapture phase.",
                        "onSuspend: AnEventhandlerfunction. Fires when loading the resource was suspended.",
                        "onSuspendCapture: A version ofonSuspendthat fires in thecapture phase.",
                        "onTimeUpdate: AnEventhandlerfunction. Fires when the current playback time updates.",
                        "onTimeUpdateCapture: A version ofonTimeUpdatethat fires in thecapture phase.",
                        "onVolumeChange: AnEventhandlerfunction. Fires when the volume has changed.",
                        "onVolumeChangeCapture: A version ofonVolumeChangethat fires in thecapture phase.",
                        "onWaiting: AnEventhandlerfunction. Fires when the playback stopped due to temporary lack of data.",
                        "onWaitingCapture: A version ofonWaitingthat fires in thecapture phase."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "You cannot pass bothchildrenanddangerouslySetInnerHTMLat the same time.",
                        "Some events (likeonAbortandonLoad) don’t bubble in the browser, but bubble in React."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "refcallback function"
                },
                {
                    "type": "p",
                    "text": "Instead of a ref object (like the one returned byuseRef), you may pass a function to therefattribute."
                },
                {
                    "type": "code",
                    "code": "<divref={(node)=>console.log(node)}/>"
                },
                {
                    "type": "p",
                    "text": "See an example of using therefcallback."
                },
                {
                    "type": "p",
                    "text": "When the<div>DOM node is added to the screen, React will call yourrefcallback with the DOMnodeas the argument. When that<div>DOM node is removed, React will call yourrefcallback withnull."
                },
                {
                    "type": "p",
                    "text": "React will also call yourrefcallback whenever you pass adifferentrefcallback. In the above example,(node) => { ... }is a different function on every render. When your component re-renders, thepreviousfunction will be called withnullas the argument, and thenextfunction will be called with the DOM node."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "node: A DOM node ornull. React will pass you the DOM node when the ref gets attached, andnullwhen therefgets detached. Unless you pass the same function reference for therefcallback on every render, the callback will get temporarily detached and re-attached during every re-render of the component."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "list",
                    "items": [
                        "optionalcleanup function: When therefis detached, React will call the cleanup function. If a function is not returned by therefcallback, React will call the callback again withnullas the argument when therefgets detached."
                    ]
                },
                {
                    "type": "code",
                    "code": "<divref={(node)=>{console.log(node);return()=>{console.log('Clean up',node)}}}>"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "When Strict Mode is on, React willrun one extra development-only setup+cleanup cyclebefore the first real setup. This is a stress-test that ensures that your cleanup logic “mirrors” your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function.",
                        "When you pass adifferentrefcallback, React will call thepreviouscallback’s cleanup function if provided. If not cleanup function is defined, therefcallback will be called withnullas the argument. Thenextfunction will be called with the DOM node."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "React event object"
                },
                {
                    "type": "p",
                    "text": "Your event handlers will receive aReact event object.It is also sometimes known as a “synthetic event”."
                },
                {
                    "type": "code",
                    "code": "<buttononClick={e=>{console.log(e);// React event object}}/>"
                },
                {
                    "type": "p",
                    "text": "It conforms to the same standard as the underlying DOM events, but fixes some browser inconsistencies."
                },
                {
                    "type": "p",
                    "text": "Some React events do not map directly to the browser’s native events. For example inonMouseLeave,e.nativeEventwill point to amouseoutevent. The specific mapping is not part of the public API and may change in the future. If you need the underlying browser event for some reason, read it frome.nativeEvent."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Properties"
                },
                {
                    "type": "p",
                    "text": "React event objects implement some of the standardEventproperties:"
                },
                {
                    "type": "list",
                    "items": [
                        "bubbles: A boolean. Returns whether the event bubbles through the DOM.",
                        "cancelable: A boolean. Returns whether the event can be canceled.",
                        "currentTarget: A DOM node. Returns the node to which the current handler is attached in the React tree.",
                        "defaultPrevented: A boolean. Returns whetherpreventDefaultwas called.",
                        "eventPhase: A number. Returns which phase the event is currently in.",
                        "isTrusted: A boolean. Returns whether the event was initiated by user.",
                        "target: A DOM node. Returns the node on which the event has occurred (which could be a distant child).",
                        "timeStamp: A number. Returns the time when the event occurred."
                    ]
                },
                {
                    "type": "p",
                    "text": "Additionally, React event objects provide these properties:"
                },
                {
                    "type": "list",
                    "items": [
                        "nativeEvent: A DOMEvent. The original browser event object."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Methods"
                },
                {
                    "type": "p",
                    "text": "React event objects implement some of the standardEventmethods:"
                },
                {
                    "type": "list",
                    "items": [
                        "preventDefault(): Prevents the default browser action for the event.",
                        "stopPropagation(): Stops the event propagation through the React tree."
                    ]
                },
                {
                    "type": "p",
                    "text": "Additionally, React event objects provide these methods:"
                },
                {
                    "type": "list",
                    "items": [
                        "isDefaultPrevented(): Returns a boolean value indicating whetherpreventDefaultwas called.",
                        "isPropagationStopped(): Returns a boolean value indicating whetherstopPropagationwas called.",
                        "persist(): Not used with React DOM. With React Native, call this to read event’s properties after the event.",
                        "isPersistent(): Not used with React DOM. With React Native, returns whetherpersisthas been called."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "The values ofcurrentTarget,eventPhase,target, andtypereflect the values your React code expects. Under the hood, React attaches event handlers at the root, but this is not reflected in React event objects. For example,e.currentTargetmay not be the same as the underlyinge.nativeEvent.currentTarget. For polyfilled events,e.type(React event type) may differ frome.nativeEvent.type(underlying type)."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "AnimationEventhandler function"
                },
                {
                    "type": "p",
                    "text": "An event handler type for theCSS animationevents."
                },
                {
                    "type": "code",
                    "code": "<divonAnimationStart={e=>console.log('onAnimationStart')}onAnimationIteration={e=>console.log('onAnimationIteration')}onAnimationEnd={e=>console.log('onAnimationEnd')}/>"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "e: AReact event objectwith these extraAnimationEventproperties:animationNameelapsedTimepseudoElement",
                        "animationName",
                        "elapsedTime",
                        "pseudoElement"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "animationName",
                        "elapsedTime",
                        "pseudoElement"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "ClipboardEventhandler function"
                },
                {
                    "type": "p",
                    "text": "An event handler type for theClipboard APIevents."
                },
                {
                    "type": "code",
                    "code": "<inputonCopy={e=>console.log('onCopy')}onCut={e=>console.log('onCut')}onPaste={e=>console.log('onPaste')}/>"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "e: AReact event objectwith these extraClipboardEventproperties:clipboardData",
                        "clipboardData"
                    ]
                },
                {
                    "type": "p",
                    "text": "e: AReact event objectwith these extraClipboardEventproperties:"
                },
                {
                    "type": "list",
                    "items": [
                        "clipboardData"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "CompositionEventhandler function"
                },
                {
                    "type": "p",
                    "text": "An event handler type for theinput method editor (IME)events."
                },
                {
                    "type": "code",
                    "code": "<inputonCompositionStart={e=>console.log('onCompositionStart')}onCompositionUpdate={e=>console.log('onCompositionUpdate')}onCompositionEnd={e=>console.log('onCompositionEnd')}/>"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "e: AReact event objectwith these extraCompositionEventproperties:data",
                        "data"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "data"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "DragEventhandler function"
                },
                {
                    "type": "p",
                    "text": "An event handler type for theHTML Drag and Drop APIevents."
                },
                {
                    "type": "code",
                    "code": "<><divdraggable={true}onDragStart={e=>console.log('onDragStart')}onDragEnd={e=>console.log('onDragEnd')}>Drag source</div><divonDragEnter={e=>console.log('onDragEnter')}onDragLeave={e=>console.log('onDragLeave')}onDragOver={e=>{e.preventDefault();console.log('onDragOver');}}onDrop={e=>console.log('onDrop')}>Drop target</div></>"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "e: AReact event objectwith these extraDragEventproperties:dataTransferIt also includes the inheritedMouseEventproperties:altKeybuttonbuttonsctrlKeyclientXclientYgetModifierState(key)metaKeymovementXmovementYpageXpageYrelatedTargetscreenXscreenYshiftKeyIt also includes the inheritedUIEventproperties:detailview",
                        "dataTransfer",
                        "altKey",
                        "button",
                        "buttons",
                        "ctrlKey",
                        "clientX",
                        "clientY",
                        "getModifierState(key)",
                        "metaKey",
                        "movementX",
                        "movementY",
                        "pageX",
                        "pageY",
                        "relatedTarget",
                        "screenX",
                        "screenY",
                        "shiftKey",
                        "detail",
                        "view"
                    ]
                },
                {
                    "type": "p",
                    "text": "e: AReact event objectwith these extraDragEventproperties:"
                },
                {
                    "type": "list",
                    "items": [
                        "dataTransfer"
                    ]
                },
                {
                    "type": "p",
                    "text": "It also includes the inheritedMouseEventproperties:"
                },
                {
                    "type": "list",
                    "items": [
                        "altKey",
                        "button",
                        "buttons",
                        "ctrlKey",
                        "clientX",
                        "clientY",
                        "getModifierState(key)",
                        "metaKey",
                        "movementX",
                        "movementY",
                        "pageX",
                        "pageY",
                        "relatedTarget",
                        "screenX",
                        "screenY",
                        "shiftKey"
                    ]
                },
                {
                    "type": "p",
                    "text": "It also includes the inheritedUIEventproperties:"
                },
                {
                    "type": "list",
                    "items": [
                        "detail",
                        "view"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "FocusEventhandler function"
                },
                {
                    "type": "p",
                    "text": "An event handler type for the focus events."
                },
                {
                    "type": "code",
                    "code": "<inputonFocus={e=>console.log('onFocus')}onBlur={e=>console.log('onBlur')}/>"
                },
                {
                    "type": "p",
                    "text": "See an example."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "e: AReact event objectwith these extraFocusEventproperties:relatedTargetIt also includes the inheritedUIEventproperties:detailview",
                        "relatedTarget",
                        "detail",
                        "view"
                    ]
                },
                {
                    "type": "p",
                    "text": "e: AReact event objectwith these extraFocusEventproperties:"
                },
                {
                    "type": "list",
                    "items": [
                        "relatedTarget"
                    ]
                },
                {
                    "type": "p",
                    "text": "It also includes the inheritedUIEventproperties:"
                },
                {
                    "type": "list",
                    "items": [
                        "detail",
                        "view"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Eventhandler function"
                },
                {
                    "type": "p",
                    "text": "An event handler type for generic events."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "e: AReact event objectwith no additional properties."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "InputEventhandler function"
                },
                {
                    "type": "p",
                    "text": "An event handler type for theonBeforeInputevent."
                },
                {
                    "type": "code",
                    "code": "<inputonBeforeInput={e=>console.log('onBeforeInput')}/>"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "e: AReact event objectwith these extraInputEventproperties:data",
                        "data"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "data"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "KeyboardEventhandler function"
                },
                {
                    "type": "p",
                    "text": "An event handler type for keyboard events."
                },
                {
                    "type": "code",
                    "code": "<inputonKeyDown={e=>console.log('onKeyDown')}onKeyUp={e=>console.log('onKeyUp')}/>"
                },
                {
                    "type": "p",
                    "text": "See an example."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "e: AReact event objectwith these extraKeyboardEventproperties:altKeycharCodecodectrlKeygetModifierState(key)keykeyCodelocalemetaKeylocationrepeatshiftKeywhichIt also includes the inheritedUIEventproperties:detailview",
                        "altKey",
                        "charCode",
                        "code",
                        "ctrlKey",
                        "getModifierState(key)",
                        "key",
                        "keyCode",
                        "locale",
                        "metaKey",
                        "location",
                        "repeat",
                        "shiftKey",
                        "which",
                        "detail",
                        "view"
                    ]
                },
                {
                    "type": "p",
                    "text": "e: AReact event objectwith these extraKeyboardEventproperties:"
                },
                {
                    "type": "list",
                    "items": [
                        "altKey",
                        "charCode",
                        "code",
                        "ctrlKey",
                        "getModifierState(key)",
                        "key",
                        "keyCode",
                        "locale",
                        "metaKey",
                        "location",
                        "repeat",
                        "shiftKey",
                        "which"
                    ]
                },
                {
                    "type": "p",
                    "text": "It also includes the inheritedUIEventproperties:"
                },
                {
                    "type": "list",
                    "items": [
                        "detail",
                        "view"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "MouseEventhandler function"
                },
                {
                    "type": "p",
                    "text": "An event handler type for mouse events."
                },
                {
                    "type": "code",
                    "code": "<divonClick={e=>console.log('onClick')}onMouseEnter={e=>console.log('onMouseEnter')}onMouseOver={e=>console.log('onMouseOver')}onMouseDown={e=>console.log('onMouseDown')}onMouseUp={e=>console.log('onMouseUp')}onMouseLeave={e=>console.log('onMouseLeave')}/>"
                },
                {
                    "type": "p",
                    "text": "See an example."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "e: AReact event objectwith these extraMouseEventproperties:altKeybuttonbuttonsctrlKeyclientXclientYgetModifierState(key)metaKeymovementXmovementYpageXpageYrelatedTargetscreenXscreenYshiftKeyIt also includes the inheritedUIEventproperties:detailview",
                        "altKey",
                        "button",
                        "buttons",
                        "ctrlKey",
                        "clientX",
                        "clientY",
                        "getModifierState(key)",
                        "metaKey",
                        "movementX",
                        "movementY",
                        "pageX",
                        "pageY",
                        "relatedTarget",
                        "screenX",
                        "screenY",
                        "shiftKey",
                        "detail",
                        "view"
                    ]
                },
                {
                    "type": "p",
                    "text": "e: AReact event objectwith these extraMouseEventproperties:"
                },
                {
                    "type": "list",
                    "items": [
                        "altKey",
                        "button",
                        "buttons",
                        "ctrlKey",
                        "clientX",
                        "clientY",
                        "getModifierState(key)",
                        "metaKey",
                        "movementX",
                        "movementY",
                        "pageX",
                        "pageY",
                        "relatedTarget",
                        "screenX",
                        "screenY",
                        "shiftKey"
                    ]
                },
                {
                    "type": "p",
                    "text": "It also includes the inheritedUIEventproperties:"
                },
                {
                    "type": "list",
                    "items": [
                        "detail",
                        "view"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "PointerEventhandler function"
                },
                {
                    "type": "p",
                    "text": "An event handler type forpointer events."
                },
                {
                    "type": "code",
                    "code": "<divonPointerEnter={e=>console.log('onPointerEnter')}onPointerMove={e=>console.log('onPointerMove')}onPointerDown={e=>console.log('onPointerDown')}onPointerUp={e=>console.log('onPointerUp')}onPointerLeave={e=>console.log('onPointerLeave')}/>"
                },
                {
                    "type": "p",
                    "text": "See an example."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "e: AReact event objectwith these extraPointerEventproperties:heightisPrimarypointerIdpointerTypepressuretangentialPressuretiltXtiltYtwistwidthIt also includes the inheritedMouseEventproperties:altKeybuttonbuttonsctrlKeyclientXclientYgetModifierState(key)metaKeymovementXmovementYpageXpageYrelatedTargetscreenXscreenYshiftKeyIt also includes the inheritedUIEventproperties:detailview",
                        "height",
                        "isPrimary",
                        "pointerId",
                        "pointerType",
                        "pressure",
                        "tangentialPressure",
                        "tiltX",
                        "tiltY",
                        "twist",
                        "width",
                        "altKey",
                        "button",
                        "buttons",
                        "ctrlKey",
                        "clientX",
                        "clientY",
                        "getModifierState(key)",
                        "metaKey",
                        "movementX",
                        "movementY",
                        "pageX",
                        "pageY",
                        "relatedTarget",
                        "screenX",
                        "screenY",
                        "shiftKey",
                        "detail",
                        "view"
                    ]
                },
                {
                    "type": "p",
                    "text": "e: AReact event objectwith these extraPointerEventproperties:"
                },
                {
                    "type": "list",
                    "items": [
                        "height",
                        "isPrimary",
                        "pointerId",
                        "pointerType",
                        "pressure",
                        "tangentialPressure",
                        "tiltX",
                        "tiltY",
                        "twist",
                        "width"
                    ]
                },
                {
                    "type": "p",
                    "text": "It also includes the inheritedMouseEventproperties:"
                },
                {
                    "type": "list",
                    "items": [
                        "altKey",
                        "button",
                        "buttons",
                        "ctrlKey",
                        "clientX",
                        "clientY",
                        "getModifierState(key)",
                        "metaKey",
                        "movementX",
                        "movementY",
                        "pageX",
                        "pageY",
                        "relatedTarget",
                        "screenX",
                        "screenY",
                        "shiftKey"
                    ]
                },
                {
                    "type": "p",
                    "text": "It also includes the inheritedUIEventproperties:"
                },
                {
                    "type": "list",
                    "items": [
                        "detail",
                        "view"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "TouchEventhandler function"
                },
                {
                    "type": "p",
                    "text": "An event handler type fortouch events."
                },
                {
                    "type": "code",
                    "code": "<divonTouchStart={e=>console.log('onTouchStart')}onTouchMove={e=>console.log('onTouchMove')}onTouchEnd={e=>console.log('onTouchEnd')}onTouchCancel={e=>console.log('onTouchCancel')}/>"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "e: AReact event objectwith these extraTouchEventproperties:altKeyctrlKeychangedTouchesgetModifierState(key)metaKeyshiftKeytouchestargetTouchesIt also includes the inheritedUIEventproperties:detailview",
                        "altKey",
                        "ctrlKey",
                        "changedTouches",
                        "getModifierState(key)",
                        "metaKey",
                        "shiftKey",
                        "touches",
                        "targetTouches",
                        "detail",
                        "view"
                    ]
                },
                {
                    "type": "p",
                    "text": "e: AReact event objectwith these extraTouchEventproperties:"
                },
                {
                    "type": "list",
                    "items": [
                        "altKey",
                        "ctrlKey",
                        "changedTouches",
                        "getModifierState(key)",
                        "metaKey",
                        "shiftKey",
                        "touches",
                        "targetTouches"
                    ]
                },
                {
                    "type": "p",
                    "text": "It also includes the inheritedUIEventproperties:"
                },
                {
                    "type": "list",
                    "items": [
                        "detail",
                        "view"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "TransitionEventhandler function"
                },
                {
                    "type": "p",
                    "text": "An event handler type for the CSS transition events."
                },
                {
                    "type": "code",
                    "code": "<divonTransitionEnd={e=>console.log('onTransitionEnd')}/>"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "e: AReact event objectwith these extraTransitionEventproperties:elapsedTimepropertyNamepseudoElement",
                        "elapsedTime",
                        "propertyName",
                        "pseudoElement"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "elapsedTime",
                        "propertyName",
                        "pseudoElement"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "UIEventhandler function"
                },
                {
                    "type": "p",
                    "text": "An event handler type for generic UI events."
                },
                {
                    "type": "code",
                    "code": "<divonScroll={e=>console.log('onScroll')}/>"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "e: AReact event objectwith these extraUIEventproperties:detailview",
                        "detail",
                        "view"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "detail",
                        "view"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "WheelEventhandler function"
                },
                {
                    "type": "p",
                    "text": "An event handler type for theonWheelevent."
                },
                {
                    "type": "code",
                    "code": "<divonWheel={e=>console.log('onWheel')}/>"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "e: AReact event objectwith these extraWheelEventproperties:deltaModedeltaXdeltaYdeltaZIt also includes the inheritedMouseEventproperties:altKeybuttonbuttonsctrlKeyclientXclientYgetModifierState(key)metaKeymovementXmovementYpageXpageYrelatedTargetscreenXscreenYshiftKeyIt also includes the inheritedUIEventproperties:detailview",
                        "deltaMode",
                        "deltaX",
                        "deltaY",
                        "deltaZ",
                        "altKey",
                        "button",
                        "buttons",
                        "ctrlKey",
                        "clientX",
                        "clientY",
                        "getModifierState(key)",
                        "metaKey",
                        "movementX",
                        "movementY",
                        "pageX",
                        "pageY",
                        "relatedTarget",
                        "screenX",
                        "screenY",
                        "shiftKey",
                        "detail",
                        "view"
                    ]
                },
                {
                    "type": "p",
                    "text": "e: AReact event objectwith these extraWheelEventproperties:"
                },
                {
                    "type": "list",
                    "items": [
                        "deltaMode",
                        "deltaX",
                        "deltaY",
                        "deltaZ"
                    ]
                },
                {
                    "type": "p",
                    "text": "It also includes the inheritedMouseEventproperties:"
                },
                {
                    "type": "list",
                    "items": [
                        "altKey",
                        "button",
                        "buttons",
                        "ctrlKey",
                        "clientX",
                        "clientY",
                        "getModifierState(key)",
                        "metaKey",
                        "movementX",
                        "movementY",
                        "pageX",
                        "pageY",
                        "relatedTarget",
                        "screenX",
                        "screenY",
                        "shiftKey"
                    ]
                },
                {
                    "type": "p",
                    "text": "It also includes the inheritedUIEventproperties:"
                },
                {
                    "type": "list",
                    "items": [
                        "detail",
                        "view"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Applying CSS styles"
                },
                {
                    "type": "p",
                    "text": "In React, you specify a CSS class withclassName.It works like theclassattribute in HTML:"
                },
                {
                    "type": "code",
                    "code": "<imgclassName=\"avatar\"/>"
                },
                {
                    "type": "p",
                    "text": "Then you write the CSS rules for it in a separate CSS file:"
                },
                {
                    "type": "code",
                    "code": "/* In your CSS */.avatar{border-radius:50%;}"
                },
                {
                    "type": "p",
                    "text": "React does not prescribe how you add CSS files. In the simplest case, you’ll add a<link>tag to your HTML. If you use a build tool or a framework, consult its documentation to learn how to add a CSS file to your project."
                },
                {
                    "type": "p",
                    "text": "Sometimes, the style values depend on data. Use thestyleattribute to pass some styles dynamically:"
                },
                {
                    "type": "code",
                    "code": "<imgclassName=\"avatar\"style={{width:user.imageSize,height:user.imageSize}}/>"
                },
                {
                    "type": "p",
                    "text": "In the above example,style={{}}is not a special syntax, but a regular{}object inside thestyle={ }JSX curly braces.We recommend only using thestyleattribute when your styles depend on JavaScript variables."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionAvatar({user}){return(<imgsrc={user.imageUrl}alt={'Photo of '+user.name}className=\"avatar\"style={{width:user.imageSize,height:user.imageSize}}/>);}"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "How to apply multiple CSS classes conditionally?"
                },
                {
                    "type": "p",
                    "text": "To apply CSS classes conditionally, you need to produce theclassNamestring yourself using JavaScript."
                },
                {
                    "type": "p",
                    "text": "For example,className={'row ' + (isSelected ? 'selected': '')}will produce eitherclassName=\"row\"orclassName=\"row selected\"depending on whetherisSelectedistrue."
                },
                {
                    "type": "p",
                    "text": "To make this more readable, you can use a tiny helper library likeclassnames:"
                },
                {
                    "type": "code",
                    "code": "importcnfrom'classnames';functionRow({isSelected}){return(<divclassName={cn('row',isSelected&&'selected')}>...</div>);}"
                },
                {
                    "type": "p",
                    "text": "It is especially convenient if you have multiple conditional classes:"
                },
                {
                    "type": "code",
                    "code": "importcnfrom'classnames';functionRow({isSelected,size}){return(<divclassName={cn('row',{selected:isSelected,large:size==='large',small:size==='small',})}>...</div>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Manipulating a DOM node with a ref"
                },
                {
                    "type": "p",
                    "text": "Sometimes, you’ll need to get the browser DOM node associated with a tag in JSX. For example, if you want to focus an<input>when a button is clicked, you need to callfocus()on the browser<input>DOM node."
                },
                {
                    "type": "p",
                    "text": "To obtain the browser DOM node for a tag,declare a refand pass it as therefattribute to that tag:"
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';exportdefaultfunctionForm(){constinputRef=useRef(null);// ...return(<inputref={inputRef}/>// ..."
                },
                {
                    "type": "p",
                    "text": "React will put the DOM node intoinputRef.currentafter it’s been rendered to the screen."
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';exportdefaultfunctionForm(){constinputRef=useRef(null);functionhandleClick(){inputRef.current.focus();}return(<><inputref={inputRef}/><buttononClick={handleClick}>Focus the input</button></>);}"
                },
                {
                    "type": "p",
                    "text": "Read more aboutmanipulating DOM with refsandcheck out more examples."
                },
                {
                    "type": "p",
                    "text": "For more advanced use cases, therefattribute also accepts acallback function."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Dangerously setting the inner HTML"
                },
                {
                    "type": "p",
                    "text": "You can pass a raw HTML string to an element like so:"
                },
                {
                    "type": "code",
                    "code": "constmarkup={__html:'<p>some raw html</p>'};return<divdangerouslySetInnerHTML={markup}/>;"
                },
                {
                    "type": "p",
                    "text": "This is dangerous. As with the underlying DOMinnerHTMLproperty, you must exercise extreme caution! Unless the markup is coming from a completely trusted source, it is trivial to introduce anXSSvulnerability this way."
                },
                {
                    "type": "p",
                    "text": "For example, if you use a Markdown library that converts Markdown to HTML, you trust that its parser doesn’t contain bugs, and the user only sees their own input, you can display the resulting HTML like this:"
                },
                {
                    "type": "code",
                    "code": "import{Remarkable}from'remarkable';constmd=newRemarkable();functionrenderMarkdownToHTML(markdown){// This is ONLY safe because the output HTML// is shown to the same user, and because you// trust this Markdown parser to not have bugs.constrenderedHTML=md.render(markdown);return{__html:renderedHTML};}exportdefaultfunctionMarkdownPreview({markdown}){constmarkup=renderMarkdownToHTML(markdown);return<divdangerouslySetInnerHTML={markup}/>;}"
                },
                {
                    "type": "p",
                    "text": "The{__html}object should be created as close to where the HTML is generated as possible, like the above example does in therenderMarkdownToHTMLfunction. This ensures that all raw HTML being used in your code is explicitly marked as such, and that only variables that you expect to contain HTML are passed todangerouslySetInnerHTML. It is not recommended to create the object inline like<div dangerouslySetInnerHTML={{__html: markup}} />."
                },
                {
                    "type": "p",
                    "text": "To see why rendering arbitrary HTML is dangerous, replace the code above with this:"
                },
                {
                    "type": "code",
                    "code": "constpost={// Imagine this content is stored in the database.content:`<img src=\"\" onerror='alert(\"you were hacked\")'>`};exportdefaultfunctionMarkdownPreview(){// 🔴 SECURITY HOLE: passing untrusted input to dangerouslySetInnerHTMLconstmarkup={__html:post.content};return<divdangerouslySetInnerHTML={markup}/>;}"
                },
                {
                    "type": "p",
                    "text": "The code embedded in the HTML will run. A hacker could use this security hole to steal user information or to perform actions on their behalf.Only usedangerouslySetInnerHTMLwith trusted and sanitized data."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Handling mouse events"
                },
                {
                    "type": "p",
                    "text": "This example shows some commonmouse eventsand when they fire."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionMouseExample(){return(<divonMouseEnter={e=>console.log('onMouseEnter (parent)')}onMouseLeave={e=>console.log('onMouseLeave (parent)')}><buttononClick={e=>console.log('onClick (first button)')}onMouseDown={e=>console.log('onMouseDown (first button)')}onMouseEnter={e=>console.log('onMouseEnter (first button)')}onMouseLeave={e=>console.log('onMouseLeave (first button)')}onMouseOver={e=>console.log('onMouseOver (first button)')}onMouseUp={e=>console.log('onMouseUp (first button)')}>First button</button><buttononClick={e=>console.log('onClick (second button)')}onMouseDown={e=>console.log('onMouseDown (second button)')}onMouseEnter={e=>console.log('onMouseEnter (second button)')}onMouseLeave={e=>console.log('onMouseLeave (second button)')}onMouseOver={e=>console.log('onMouseOver (second button)')}onMouseUp={e=>console.log('onMouseUp (second button)')}>Second button</button></div>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Handling pointer events"
                },
                {
                    "type": "p",
                    "text": "This example shows some commonpointer eventsand when they fire."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionPointerExample(){return(<divonPointerEnter={e=>console.log('onPointerEnter (parent)')}onPointerLeave={e=>console.log('onPointerLeave (parent)')}style={{padding:20,backgroundColor:'#ddd'}}><divonPointerDown={e=>console.log('onPointerDown (first child)')}onPointerEnter={e=>console.log('onPointerEnter (first child)')}onPointerLeave={e=>console.log('onPointerLeave (first child)')}onPointerMove={e=>console.log('onPointerMove (first child)')}onPointerUp={e=>console.log('onPointerUp (first child)')}style={{padding:20,backgroundColor:'lightyellow'}}>First child</div><divonPointerDown={e=>console.log('onPointerDown (second child)')}onPointerEnter={e=>console.log('onPointerEnter (second child)')}onPointerLeave={e=>console.log('onPointerLeave (second child)')}onPointerMove={e=>console.log('onPointerMove (second child)')}onPointerUp={e=>console.log('onPointerUp (second child)')}style={{padding:20,backgroundColor:'lightblue'}}>Second child</div></div>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Handling focus events"
                },
                {
                    "type": "p",
                    "text": "In React,focus eventsbubble. You can use thecurrentTargetandrelatedTargetto differentiate if the focusing or blurring events originated from outside of the parent element. The example shows how to detect focusing a child, focusing the parent element, and how to detect focus entering or leaving the whole subtree."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionFocusExample(){return(<divtabIndex={1}onFocus={(e)=>{if(e.currentTarget===e.target){console.log('focused parent');}else{console.log('focused child',e.target.name);}if(!e.currentTarget.contains(e.relatedTarget)){// Not triggered when swapping focus between childrenconsole.log('focus entered parent');}}}onBlur={(e)=>{if(e.currentTarget===e.target){console.log('unfocused parent');}else{console.log('unfocused child',e.target.name);}if(!e.currentTarget.contains(e.relatedTarget)){// Not triggered when swapping focus between childrenconsole.log('focus left parent');}}}><label>First name:<inputname=\"firstName\"/></label><label>Last name:<inputname=\"lastName\"/></label></div>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Handling keyboard events"
                },
                {
                    "type": "p",
                    "text": "This example shows some commonkeyboard eventsand when they fire."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionKeyboardExample(){return(<label>First name:<inputname=\"firstName\"onKeyDown={e=>console.log('onKeyDown:',e.key,e.code)}onKeyUp={e=>console.log('onKeyUp:',e.key,e.code)}/></label>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/components/form",
            "title": "<form> – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "<form>- This feature is available in the latest Canary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "React’s extensions to<form>are currently only available in React’s canary and experimental channels. In stable releases of React,<form>works only as abuilt-in browser HTML component. Learn more aboutReact’s release channels here."
                },
                {
                    "type": "p",
                    "text": "Thebuilt-in browser<form>componentlets you create interactive controls for submitting information."
                },
                {
                    "type": "code",
                    "code": "<formaction={search}><inputname=\"query\"/><buttontype=\"submit\">Search</button></form>"
                },
                {
                    "type": "list",
                    "items": [
                        "Reference<form>",
                        "<form>",
                        "UsageHandle form submission on the clientHandle form submission with a Server ActionDisplay a pending state during form submissionOptimistically updating form dataHandling form submission errorsDisplay a form submission error without JavaScriptHandling multiple submission types",
                        "Handle form submission on the client",
                        "Handle form submission with a Server Action",
                        "Display a pending state during form submission",
                        "Optimistically updating form data",
                        "Handling form submission errors",
                        "Display a form submission error without JavaScript",
                        "Handling multiple submission types"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "<form>"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Handle form submission on the client",
                        "Handle form submission with a Server Action",
                        "Display a pending state during form submission",
                        "Optimistically updating form data",
                        "Handling form submission errors",
                        "Display a form submission error without JavaScript",
                        "Handling multiple submission types"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "<form>"
                },
                {
                    "type": "p",
                    "text": "To create interactive controls for submitting information, render thebuilt-in browser<form>component."
                },
                {
                    "type": "code",
                    "code": "<formaction={search}><inputname=\"query\"/><buttontype=\"submit\">Search</button></form>"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Props"
                },
                {
                    "type": "p",
                    "text": "<form>supports allcommon element props."
                },
                {
                    "type": "p",
                    "text": "action: a URL or function. When a URL is passed toactionthe form will behave like the HTML form component. When a function is passed toactionthe function will handle the form submission. The function passed toactionmay be async and will be called with a single argument containing theform dataof the submitted form. Theactionprop can be overridden by aformActionattribute on a<button>,<input type=\"submit\">, or<input type=\"image\">component."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "When a function is passed toactionorformActionthe HTTP method will be POST regardless of value of themethodprop."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Handle form submission on the client"
                },
                {
                    "type": "p",
                    "text": "Pass a function to theactionprop of form to run the function when the form is submitted.formDatawill be passed to the function as an argument so you can access the data submitted by the form. This differs from the conventionalHTML action, which only accepts URLs."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionSearch(){functionsearch(formData){constquery=formData.get(\"query\");alert(`You searched for '${query}'`);}return(<formaction={search}><inputname=\"query\"/><buttontype=\"submit\">Search</button></form>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Handle form submission with a Server Action"
                },
                {
                    "type": "p",
                    "text": "Render a<form>with an input and submit button. Pass a Server Action (a function marked with'use server') to theactionprop of form to run the function when the form is submitted."
                },
                {
                    "type": "p",
                    "text": "Passing a Server Action to<form action>allow users to submit forms without JavaScript enabled or before the code has loaded. This is beneficial to users who have a slow connection, device, or have JavaScript disabled and is similar to the way forms work when a URL is passed to theactionprop."
                },
                {
                    "type": "p",
                    "text": "You can use hidden form fields to provide data to the<form>’s action. The Server Action will be called with the hidden form field data as an instance ofFormData."
                },
                {
                    "type": "code",
                    "code": "import{updateCart}from'./lib.js';functionAddToCart({productId}){asyncfunctionaddToCart(formData){'use server'constproductId=formData.get('productId')awaitupdateCart(productId)}return(<formaction={addToCart}><inputtype=\"hidden\"name=\"productId\"value={productId}/><buttontype=\"submit\">Add to Cart</button></form>);}"
                },
                {
                    "type": "p",
                    "text": "In lieu of using hidden form fields to provide data to the<form>’s action, you can call thebindmethod to supply it with extra arguments. This will bind a new argument (productId) to the function in addition to theformDatathat is passed as an argument to the function."
                },
                {
                    "type": "code",
                    "code": "import{updateCart}from'./lib.js';functionAddToCart({productId}){asyncfunctionaddToCart(productId,formData){\"use server\";awaitupdateCart(productId)}constaddProductToCart=addToCart.bind(null,productId);return(<formaction={addProductToCart}><buttontype=\"submit\">Add to Cart</button></form>);}"
                },
                {
                    "type": "p",
                    "text": "When<form>is rendered by aServer Component, and aServer Actionis passed to the<form>’sactionprop, the form isprogressively enhanced."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Display a pending state during form submission"
                },
                {
                    "type": "p",
                    "text": "To display a pending state when a form is being submitted, you can call theuseFormStatusHook in a component rendered in a<form>and read thependingproperty returned."
                },
                {
                    "type": "p",
                    "text": "Here, we use thependingproperty to indicate the form is submitting."
                },
                {
                    "type": "code",
                    "code": "import{useFormStatus}from\"react-dom\";import{submitForm}from\"./actions.js\";functionSubmit(){const{pending}=useFormStatus();return(<buttontype=\"submit\"disabled={pending}>{pending?\"Submitting...\":\"Submit\"}</button>);}functionForm({action}){return(<formaction={action}><Submit/></form>);}exportdefaultfunctionApp(){return<Formaction={submitForm}/>;}"
                },
                {
                    "type": "p",
                    "text": "To learn more about theuseFormStatusHook see thereference documentation."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Optimistically updating form data"
                },
                {
                    "type": "p",
                    "text": "TheuseOptimisticHook provides a way to optimistically update the user interface before a background operation, like a network request, completes. In the context of forms, this technique helps to make apps feel more responsive. When a user submits a form, instead of waiting for the server’s response to reflect the changes, the interface is immediately updated with the expected outcome."
                },
                {
                    "type": "p",
                    "text": "For example, when a user types a message into the form and hits the “Send” button, theuseOptimisticHook allows the message to immediately appear in the list with a “Sending…” label, even before the message is actually sent to a server. This “optimistic” approach gives the impression of speed and responsiveness. The form then attempts to truly send the message in the background. Once the server confirms the message has been received, the “Sending…” label is removed."
                },
                {
                    "type": "code",
                    "code": "import{useOptimistic,useState,useRef}from\"react\";import{deliverMessage}from\"./actions.js\";functionThread({messages,sendMessage}){constformRef=useRef();asyncfunctionformAction(formData){addOptimisticMessage(formData.get(\"message\"));formRef.current.reset();awaitsendMessage(formData);}const[optimisticMessages,addOptimisticMessage]=useOptimistic(messages,(state,newMessage)=>[...state,{text:newMessage,sending:true}]);return(<>{optimisticMessages.map((message,index)=>(<divkey={index}>{message.text}{!!message.sending&&<small>(Sending...)</small>}</div>))}<formaction={formAction}ref={formRef}><inputtype=\"text\"name=\"message\"placeholder=\"Hello!\"/><buttontype=\"submit\">Send</button></form></>);}exportdefaultfunctionApp(){const[messages,setMessages]=useState([{text:\"Hello there!\",sending:false,key:1}]);asyncfunctionsendMessage(formData){constsentMessage=awaitdeliverMessage(formData.get(\"message\"));setMessages([...messages,{text:sentMessage}]);}return<Threadmessages={messages}sendMessage={sendMessage}/>;}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Handling form submission errors"
                },
                {
                    "type": "p",
                    "text": "In some cases the function called by a<form>’sactionprop throws an error. You can handle these errors by wrapping<form>in an Error Boundary. If the function called by a<form>’sactionprop throws an error, the fallback for the error boundary will be displayed."
                },
                {
                    "type": "code",
                    "code": "import{ErrorBoundary}from\"react-error-boundary\";exportdefaultfunctionSearch(){functionsearch(){thrownewError(\"search error\");}return(<ErrorBoundaryfallback={<p>There was an error while submitting the form</p>}><formaction={search}><inputname=\"query\"/><buttontype=\"submit\">Search</button></form></ErrorBoundary>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Display a form submission error without JavaScript"
                },
                {
                    "type": "p",
                    "text": "Displaying a form submission error message before the JavaScript bundle loads for progressive enhancement requires that:"
                },
                {
                    "type": "list",
                    "items": [
                        "<form>be rendered by aServer Component",
                        "the function passed to the<form>’sactionprop be aServer Action",
                        "theuseActionStateHook be used to display the error message"
                    ]
                },
                {
                    "type": "p",
                    "text": "useActionStatetakes two parameters: aServer Actionand an initial state.useActionStatereturns two values, a state variable and an action. The action returned byuseActionStateshould be passed to theactionprop of the form. The state variable returned byuseActionStatecan be used to displayed an error message. The value returned by theServer Actionpassed touseActionStatewill be used to update the state variable."
                },
                {
                    "type": "code",
                    "code": "import{useActionState}from\"react\";import{signUpNewUser}from\"./api\";exportdefaultfunctionPage(){asyncfunctionsignup(prevState,formData){\"use server\";constemail=formData.get(\"email\");try{awaitsignUpNewUser(email);alert(`Added \"${email}\"`);}catch(err){returnerr.toString();}}const[message,signupAction]=useActionState(signup,null);return(<><h1>Signup for my newsletter</h1><p>Signup with the same email twice to see an error</p><formaction={signupAction}id=\"signup-form\"><labelhtmlFor=\"email\">Email:</label><inputname=\"email\"id=\"email\"placeholder=\"react@example.com\"/><button>Sign up</button>{!!message&&<p>{message}</p>}</form></>);}"
                },
                {
                    "type": "p",
                    "text": "Learn more about updating state from a form action with theuseActionStatedocs"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Handling multiple submission types"
                },
                {
                    "type": "p",
                    "text": "Forms can be designed to handle multiple submission actions based on the button pressed by the user. Each button inside a form can be associated with a distinct action or behavior by setting theformActionprop."
                },
                {
                    "type": "p",
                    "text": "When a user taps a specific button, the form is submitted, and a corresponding action, defined by that button’s attributes and action, is executed. For instance, a form might submit an article for review by default but have a separate button withformActionset to save the article as a draft."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionSearch(){functionpublish(formData){constcontent=formData.get(\"content\");constbutton=formData.get(\"button\");alert(`'${content}' was published with the '${button}' button`);}functionsave(formData){constcontent=formData.get(\"content\");alert(`Your draft of '${content}' has been saved!`);}return(<formaction={publish}><textareaname=\"content\"rows={4}cols={40}/><br/><buttontype=\"submit\"name=\"button\"value=\"submit\">Publish</button><buttonformAction={save}>Save draft</button></form>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/components/input",
            "title": "<input> – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "<input>"
                },
                {
                    "type": "p",
                    "text": "Thebuilt-in browser<input>componentlets you render different kinds of form inputs."
                },
                {
                    "type": "code",
                    "code": "<input/>"
                },
                {
                    "type": "list",
                    "items": [
                        "Reference<input>",
                        "<input>",
                        "UsageDisplaying inputs of different typesProviding a label for an inputProviding an initial value for an inputReading the input values when submitting a formControlling an input with a state variableOptimizing re-rendering on every keystroke",
                        "Displaying inputs of different types",
                        "Providing a label for an input",
                        "Providing an initial value for an input",
                        "Reading the input values when submitting a form",
                        "Controlling an input with a state variable",
                        "Optimizing re-rendering on every keystroke",
                        "TroubleshootingMy text input doesn’t update when I type into itMy checkbox doesn’t update when I click on itMy input caret jumps to the beginning on every keystrokeI’m getting an error: “A component is changing an uncontrolled input to be controlled”",
                        "My text input doesn’t update when I type into it",
                        "My checkbox doesn’t update when I click on it",
                        "My input caret jumps to the beginning on every keystroke",
                        "I’m getting an error: “A component is changing an uncontrolled input to be controlled”"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "<input>"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Displaying inputs of different types",
                        "Providing a label for an input",
                        "Providing an initial value for an input",
                        "Reading the input values when submitting a form",
                        "Controlling an input with a state variable",
                        "Optimizing re-rendering on every keystroke"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "My text input doesn’t update when I type into it",
                        "My checkbox doesn’t update when I click on it",
                        "My input caret jumps to the beginning on every keystroke",
                        "I’m getting an error: “A component is changing an uncontrolled input to be controlled”"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "<input>"
                },
                {
                    "type": "p",
                    "text": "To display an input, render thebuilt-in browser<input>component."
                },
                {
                    "type": "code",
                    "code": "<inputname=\"myInput\"/>"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Props"
                },
                {
                    "type": "p",
                    "text": "<input>supports allcommon element props."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "React’s extensions to theformActionprop are currently only available in React’s Canary and experimental channels. In stable releases of React,formActionworks only as abuilt-in browser HTML component. Learn more aboutReact’s release channels here."
                },
                {
                    "type": "p",
                    "text": "formAction: A string or function. Overrides the parent<form action>fortype=\"submit\"andtype=\"image\". When a URL is passed toactionthe form will behave like a standard HTML form. When a function is passed toformActionthe function will handle the form submission. See<form action>."
                },
                {
                    "type": "p",
                    "text": "You canmake an input controlledby passing one of these props:"
                },
                {
                    "type": "list",
                    "items": [
                        "checked: A boolean. For a checkbox input or a radio button, controls whether it is selected.",
                        "value: A string. For a text input, controls its text. (For a radio button, specifies its form data.)"
                    ]
                },
                {
                    "type": "p",
                    "text": "When you pass either of them, you must also pass anonChangehandler that updates the passed value."
                },
                {
                    "type": "p",
                    "text": "These<input>props are only relevant for uncontrolled inputs:"
                },
                {
                    "type": "list",
                    "items": [
                        "defaultChecked: A boolean. Specifiesthe initial valuefortype=\"checkbox\"andtype=\"radio\"inputs.",
                        "defaultValue: A string. Specifiesthe initial valuefor a text input."
                    ]
                },
                {
                    "type": "p",
                    "text": "These<input>props are relevant both for uncontrolled and controlled inputs:"
                },
                {
                    "type": "list",
                    "items": [
                        "accept: A string. Specifies which filetypes are accepted by atype=\"file\"input.",
                        "alt: A string. Specifies the alternative image text for atype=\"image\"input.",
                        "capture: A string. Specifies the media (microphone, video, or camera) captured by atype=\"file\"input.",
                        "autoComplete: A string. Specifies one of the possibleautocomplete behaviors.",
                        "autoFocus: A boolean. Iftrue, React will focus the element on mount.",
                        "dirname: A string. Specifies the form field name for the element’s directionality.",
                        "disabled: A boolean. Iftrue, the input will not be interactive and will appear dimmed.",
                        "children:<input>does not accept children.",
                        "form: A string. Specifies theidof the<form>this input belongs to. If omitted, it’s the closest parent form.",
                        "formAction: A string. Overrides the parent<form action>fortype=\"submit\"andtype=\"image\".",
                        "formEnctype: A string. Overrides the parent<form enctype>fortype=\"submit\"andtype=\"image\".",
                        "formMethod: A string. Overrides the parent<form method>fortype=\"submit\"andtype=\"image\".",
                        "formNoValidate: A string. Overrides the parent<form noValidate>fortype=\"submit\"andtype=\"image\".",
                        "formTarget: A string. Overrides the parent<form target>fortype=\"submit\"andtype=\"image\".",
                        "height: A string. Specifies the image height fortype=\"image\".",
                        "list: A string. Specifies theidof the<datalist>with the autocomplete options.",
                        "max: A number. Specifies the maximum value of numerical and datetime inputs.",
                        "maxLength: A number. Specifies the maximum length of text and other inputs.",
                        "min: A number. Specifies the minimum value of numerical and datetime inputs.",
                        "minLength: A number. Specifies the minimum length of text and other inputs.",
                        "multiple: A boolean. Specifies whether multiple values are allowed for<type=\"file\"andtype=\"email\".",
                        "name: A string. Specifies the name for this input that’ssubmitted with the form.",
                        "onChange: AnEventhandlerfunction. Required forcontrolled inputs.Fires immediately when the input’s value is changed by the user (for example, it fires on every keystroke). Behaves like the browserinputevent.",
                        "onChangeCapture: A version ofonChangethat fires in thecapture phase.",
                        "onInput: AnEventhandlerfunction. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to useonChangeinstead which works similarly.",
                        "onInputCapture: A version ofonInputthat fires in thecapture phase.",
                        "onInvalid: AnEventhandlerfunction. Fires if an input fails validation on form submit. Unlike the built-ininvalidevent, the ReactonInvalidevent bubbles.",
                        "onInvalidCapture: A version ofonInvalidthat fires in thecapture phase.",
                        "onSelect: AnEventhandlerfunction. Fires after the selection inside the<input>changes. React extends theonSelectevent to also fire for empty selection and on edits (which may affect the selection).",
                        "onSelectCapture: A version ofonSelectthat fires in thecapture phase.",
                        "pattern: A string. Specifies the pattern that thevaluemust match.",
                        "placeholder: A string. Displayed in a dimmed color when the input value is empty.",
                        "readOnly: A boolean. Iftrue, the input is not editable by the user.",
                        "required: A boolean. Iftrue, the value must be provided for the form to submit.",
                        "size: A number. Similar to setting width, but the unit depends on the control.",
                        "src: A string. Specifies the image source for atype=\"image\"input.",
                        "step: A positive number or an'any'string. Specifies the distance between valid values.",
                        "type: A string. One of theinput types.",
                        "width:  A string. Specifies the image width for atype=\"image\"input."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Checkboxes needchecked(ordefaultChecked), notvalue(ordefaultValue).",
                        "If a text input receives a stringvalueprop, it will betreated as controlled.",
                        "If a checkbox or a radio button receives a booleancheckedprop, it will betreated as controlled.",
                        "An input can’t be both controlled and uncontrolled at the same time.",
                        "An input cannot switch between being controlled or uncontrolled over its lifetime.",
                        "Every controlled input needs anonChangeevent handler that synchronously updates its backing value."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Displaying inputs of different types"
                },
                {
                    "type": "p",
                    "text": "To display an input, render an<input>component. By default, it will be a text input. You can passtype=\"checkbox\"for a checkbox,type=\"radio\"for a radio button,or one of the other input types."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionMyForm(){return(<><label>Text input:<inputname=\"myInput\"/></label><hr/><label>Checkbox:<inputtype=\"checkbox\"name=\"myCheckbox\"/></label><hr/><p>Radio buttons:<label><inputtype=\"radio\"name=\"myRadio\"value=\"option1\"/>Option 1</label><label><inputtype=\"radio\"name=\"myRadio\"value=\"option2\"/>Option 2</label><label><inputtype=\"radio\"name=\"myRadio\"value=\"option3\"/>Option 3</label></p></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Providing a label for an input"
                },
                {
                    "type": "p",
                    "text": "Typically, you will place every<input>inside a<label>tag. This tells the browser that this label is associated with that input. When the user clicks the label, the browser will automatically focus the input. It’s also essential for accessibility: a screen reader will announce the label caption when the user focuses the associated input."
                },
                {
                    "type": "p",
                    "text": "If you can’t nest<input>into a<label>, associate them by passing the same ID to<input id>and<label htmlFor>.To avoid conflicts between multiple instances of one component, generate such an ID withuseId."
                },
                {
                    "type": "code",
                    "code": "import{useId}from'react';exportdefaultfunctionForm(){constageInputId=useId();return(<><label>Your first name:<inputname=\"firstName\"/></label><hr/><labelhtmlFor={ageInputId}>Your age:</label><inputid={ageInputId}name=\"age\"type=\"number\"/></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Providing an initial value for an input"
                },
                {
                    "type": "p",
                    "text": "You can optionally specify the initial value for any input. Pass it as thedefaultValuestring for text inputs. Checkboxes and radio buttons should specify the initial value with thedefaultCheckedboolean instead."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionMyForm(){return(<><label>Text input:<inputname=\"myInput\"defaultValue=\"Some initial value\"/></label><hr/><label>Checkbox:<inputtype=\"checkbox\"name=\"myCheckbox\"defaultChecked={true}/></label><hr/><p>Radio buttons:<label><inputtype=\"radio\"name=\"myRadio\"value=\"option1\"/>Option 1</label><label><inputtype=\"radio\"name=\"myRadio\"value=\"option2\"defaultChecked={true}/>Option 2</label><label><inputtype=\"radio\"name=\"myRadio\"value=\"option3\"/>Option 3</label></p></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Reading the input values when submitting a form"
                },
                {
                    "type": "p",
                    "text": "Add a<form>around your inputs with a<button type=\"submit\">inside. It will call your<form onSubmit>event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by callinge.preventDefault(). Read the form data withnew FormData(e.target)."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionMyForm(){functionhandleSubmit(e){// Prevent the browser from reloading the pagee.preventDefault();// Read the form dataconstform=e.target;constformData=newFormData(form);// You can pass formData as a fetch body directly:fetch('/some-api',{method:form.method,body:formData});// Or you can work with it as a plain object:constformJson=Object.fromEntries(formData.entries());console.log(formJson);}return(<formmethod=\"post\"onSubmit={handleSubmit}><label>Text input:<inputname=\"myInput\"defaultValue=\"Some initial value\"/></label><hr/><label>Checkbox:<inputtype=\"checkbox\"name=\"myCheckbox\"defaultChecked={true}/></label><hr/><p>Radio buttons:<label><inputtype=\"radio\"name=\"myRadio\"value=\"option1\"/>Option 1</label><label><inputtype=\"radio\"name=\"myRadio\"value=\"option2\"defaultChecked={true}/>Option 2</label><label><inputtype=\"radio\"name=\"myRadio\"value=\"option3\"/>Option 3</label></p><hr/><buttontype=\"reset\">Reset form</button><buttontype=\"submit\">Submit form</button></form>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Give anameto every<input>, for example<input name=\"firstName\" defaultValue=\"Taylor\" />. Thenameyou specified will be used as a key in the form data, for example{ firstName: \"Taylor\" }."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "By default,any<button>inside a<form>will submit it. This can be surprising! If you have your own customButtonReact component, consider returning<button type=\"button\">instead of<button>. Then, to be explicit, use<button type=\"submit\">for buttons thataresupposed to submit the form."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Controlling an input with a state variable"
                },
                {
                    "type": "p",
                    "text": "An input like<input />isuncontrolled.Even if youpass an initial valuelike<input defaultValue=\"Initial text\" />, your JSX only specifies the initial value. It does not control what the value should be right now."
                },
                {
                    "type": "p",
                    "text": "To render acontrolledinput, pass thevalueprop to it (orcheckedfor checkboxes and radios).React will force the input to always have thevalueyou passed. Usually, you would do this by declaring astate variable:"
                },
                {
                    "type": "code",
                    "code": "functionForm(){const[firstName,setFirstName]=useState('');// Declare a state variable...// ...return(<inputvalue={firstName}// ...force the input's value to match the state variable...onChange={e=>setFirstName(e.target.value)}// ... and update the state variable on any edits!/>);}"
                },
                {
                    "type": "p",
                    "text": "A controlled input makes sense if you needed state anyway—for example, to re-render your UI on every edit:"
                },
                {
                    "type": "code",
                    "code": "functionForm(){const[firstName,setFirstName]=useState('');return(<><label>First name:<inputvalue={firstName}onChange={e=>setFirstName(e.target.value)}/></label>{firstName!==''&&<p>Your name is{firstName}.</p>}..."
                },
                {
                    "type": "p",
                    "text": "It’s also useful if you want to offer multiple ways to adjust the input state (for example, by clicking a button):"
                },
                {
                    "type": "code",
                    "code": "functionForm(){// ...const[age,setAge]=useState('');constageAsNumber=Number(age);return(<><label>Age:<inputvalue={age}onChange={e=>setAge(e.target.value)}type=\"number\"/><buttononClick={()=>setAge(ageAsNumber+10)}>Add 10 years</button>"
                },
                {
                    "type": "p",
                    "text": "Thevalueyou pass to controlled components should not beundefinedornull. If you need the initial value to be empty (such as with thefirstNamefield below), initialize your state variable to an empty string ('')."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionForm(){const[firstName,setFirstName]=useState('');const[age,setAge]=useState('20');constageAsNumber=Number(age);return(<><label>First name:<inputvalue={firstName}onChange={e=>setFirstName(e.target.value)}/></label><label>Age:<inputvalue={age}onChange={e=>setAge(e.target.value)}type=\"number\"/><buttononClick={()=>setAge(ageAsNumber+10)}>Add 10 years</button></label>{firstName!==''&&<p>Your name is{firstName}.</p>}{ageAsNumber>0&&<p>Your age is{ageAsNumber}.</p>}</>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "If you passvaluewithoutonChange, it will be impossible to type into the input.When you control an input by passing somevalueto it, youforceit to always have the value you passed. So if you pass a state variable as avaluebut forget to update that state variable synchronously during theonChangeevent handler, React will revert the input after every keystroke back to thevaluethat you specified."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Optimizing re-rendering on every keystroke"
                },
                {
                    "type": "p",
                    "text": "When you use a controlled input, you set the state on every keystroke. If the component containing your state re-renders a large tree, this can get slow. There’s a few ways you can optimize re-rendering performance."
                },
                {
                    "type": "p",
                    "text": "For example, suppose you start with a form that re-renders all page content on every keystroke:"
                },
                {
                    "type": "code",
                    "code": "functionApp(){const[firstName,setFirstName]=useState('');return(<><form><inputvalue={firstName}onChange={e=>setFirstName(e.target.value)}/></form><PageContent/></>);}"
                },
                {
                    "type": "p",
                    "text": "Since<PageContent />doesn’t rely on the input state, you can move the input state into its own component:"
                },
                {
                    "type": "code",
                    "code": "functionApp(){return(<><SignupForm/><PageContent/></>);}functionSignupForm(){const[firstName,setFirstName]=useState('');return(<form><inputvalue={firstName}onChange={e=>setFirstName(e.target.value)}/></form>);}"
                },
                {
                    "type": "p",
                    "text": "This significantly improves performance because now onlySignupFormre-renders on every keystroke."
                },
                {
                    "type": "p",
                    "text": "If there is no way to avoid re-rendering (for example, ifPageContentdepends on the search input’s value),useDeferredValuelets you keep the controlled input responsive even in the middle of a large re-render."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My text input doesn’t update when I type into it"
                },
                {
                    "type": "p",
                    "text": "If you render an input withvaluebut noonChange, you will see an error in the console:"
                },
                {
                    "type": "code",
                    "code": "// 🔴 Bug: controlled text input with no onChange handler<inputvalue={something}/>"
                },
                {
                    "type": "p",
                    "text": "As the error message suggests, if you only wanted tospecify theinitialvalue,passdefaultValueinstead:"
                },
                {
                    "type": "code",
                    "code": "// ✅ Good: uncontrolled input with an initial value<inputdefaultValue={something}/>"
                },
                {
                    "type": "p",
                    "text": "If you wantto control this input with a state variable,specify anonChangehandler:"
                },
                {
                    "type": "code",
                    "code": "// ✅ Good: controlled input with onChange<inputvalue={something}onChange={e=>setSomething(e.target.value)}/>"
                },
                {
                    "type": "p",
                    "text": "If the value is intentionally read-only, add areadOnlyprop to suppress the error:"
                },
                {
                    "type": "code",
                    "code": "// ✅ Good: readonly controlled input without on change<inputvalue={something}readOnly={true}/>"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My checkbox doesn’t update when I click on it"
                },
                {
                    "type": "p",
                    "text": "If you render a checkbox withcheckedbut noonChange, you will see an error in the console:"
                },
                {
                    "type": "code",
                    "code": "// 🔴 Bug: controlled checkbox with no onChange handler<inputtype=\"checkbox\"checked={something}/>"
                },
                {
                    "type": "p",
                    "text": "As the error message suggests, if you only wanted tospecify theinitialvalue,passdefaultCheckedinstead:"
                },
                {
                    "type": "code",
                    "code": "// ✅ Good: uncontrolled checkbox with an initial value<inputtype=\"checkbox\"defaultChecked={something}/>"
                },
                {
                    "type": "p",
                    "text": "If you wantto control this checkbox with a state variable,specify anonChangehandler:"
                },
                {
                    "type": "code",
                    "code": "// ✅ Good: controlled checkbox with onChange<inputtype=\"checkbox\"checked={something}onChange={e=>setSomething(e.target.checked)}/>"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "You need to reade.target.checkedrather thane.target.valuefor checkboxes."
                },
                {
                    "type": "p",
                    "text": "If the checkbox is intentionally read-only, add areadOnlyprop to suppress the error:"
                },
                {
                    "type": "code",
                    "code": "// ✅ Good: readonly controlled input without on change<inputtype=\"checkbox\"checked={something}readOnly={true}/>"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My input caret jumps to the beginning on every keystroke"
                },
                {
                    "type": "p",
                    "text": "If youcontrol an input,you must update its state variable to the input’s value from the DOM duringonChange."
                },
                {
                    "type": "p",
                    "text": "You can’t update it to something other thane.target.value(ore.target.checkedfor checkboxes):"
                },
                {
                    "type": "code",
                    "code": "functionhandleChange(e){// 🔴 Bug: updating an input to something other than e.target.valuesetFirstName(e.target.value.toUpperCase());}"
                },
                {
                    "type": "p",
                    "text": "You also can’t update it asynchronously:"
                },
                {
                    "type": "code",
                    "code": "functionhandleChange(e){// 🔴 Bug: updating an input asynchronouslysetTimeout(()=>{setFirstName(e.target.value);},100);}"
                },
                {
                    "type": "p",
                    "text": "To fix your code, update it synchronously toe.target.value:"
                },
                {
                    "type": "code",
                    "code": "functionhandleChange(e){// ✅ Updating a controlled input to e.target.value synchronouslysetFirstName(e.target.value);}"
                },
                {
                    "type": "p",
                    "text": "If this doesn’t fix the problem, it’s possible that the input gets removed and re-added from the DOM on every keystroke. This can happen if you’re accidentallyresetting stateon every re-render, for example if the input or one of its parents always receives a differentkeyattribute, or if you nest component function definitions (which is not supported and causes the “inner” component to always be considered a different tree)."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’m getting an error: “A component is changing an uncontrolled input to be controlled”"
                },
                {
                    "type": "p",
                    "text": "If you provide avalueto the component, it must remain a string throughout its lifetime."
                },
                {
                    "type": "p",
                    "text": "You cannot passvalue={undefined}first and later passvalue=\"some string\"because React won’t know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a stringvalue, notnullorundefined."
                },
                {
                    "type": "p",
                    "text": "If yourvalueis coming from an API or a state variable, it might be initialized tonullorundefined. In that case, either set it to an empty string ('') initially, or passvalue={someValue ?? ''}to ensurevalueis a string."
                },
                {
                    "type": "p",
                    "text": "Similarly, if you passcheckedto a checkbox, ensure it’s always a boolean."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/components/link",
            "title": "<link> – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "<link>- This feature is available in the latest Canary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "React’s extensions to<link>are currently only available in React’s canary and experimental channels. In stable releases of React<link>works only as abuilt-in browser HTML component. Learn more aboutReact’s release channels here."
                },
                {
                    "type": "p",
                    "text": "Thebuilt-in browser<link>componentlets you use external resources such as stylesheets or annotate the document with link metadata."
                },
                {
                    "type": "code",
                    "code": "<linkrel=\"icon\"href=\"favicon.ico\"/>"
                },
                {
                    "type": "list",
                    "items": [
                        "Reference<link>",
                        "<link>",
                        "UsageLinking to related resourcesLinking to a stylesheetControlling stylesheet precedenceDeduplicated stylesheet renderingAnnotating specific items within the document with links",
                        "Linking to related resources",
                        "Linking to a stylesheet",
                        "Controlling stylesheet precedence",
                        "Deduplicated stylesheet rendering",
                        "Annotating specific items within the document with links"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "<link>"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Linking to related resources",
                        "Linking to a stylesheet",
                        "Controlling stylesheet precedence",
                        "Deduplicated stylesheet rendering",
                        "Annotating specific items within the document with links"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "<link>"
                },
                {
                    "type": "p",
                    "text": "To link to external resources such as stylesheets, fonts, and icons, or to annotate the document with link metadata, render thebuilt-in browser<link>component. You can render<link>from any component and React willin most casesplace the corresponding DOM element in the document head."
                },
                {
                    "type": "code",
                    "code": "<linkrel=\"icon\"href=\"favicon.ico\"/>"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Props"
                },
                {
                    "type": "p",
                    "text": "<link>supports allcommon element props."
                },
                {
                    "type": "list",
                    "items": [
                        "rel: a string, required. Specifies therelationship to the resource. Reacttreats links withrel=\"stylesheet\"differentlyfrom other links."
                    ]
                },
                {
                    "type": "p",
                    "text": "These props apply whenrel=\"stylesheet\":"
                },
                {
                    "type": "list",
                    "items": [
                        "precedence: a string. Tells React where to rank the<link>DOM node relative to others in the document<head>, which determines which stylesheet can override the other. React will infer that precedence values it discovers first are “lower” and precedence values it discovers later are “higher”. Many style systems can work fine using a single precedence value because style rules are atomic. Stylesheets with the same precedence go together whether they are<link>or inline<style>tags or loaded usingpreinitfunctions.",
                        "media: a string. Restricts the stylesheet to a certainmedia query.",
                        "title: a string. Specifies the name of analternative stylesheet."
                    ]
                },
                {
                    "type": "p",
                    "text": "These props apply whenrel=\"stylesheet\"but disable React’sspecial treatment of stylesheets:"
                },
                {
                    "type": "list",
                    "items": [
                        "disabled: a boolean. Disables the stylesheet.",
                        "onError: a function. Called when the stylesheet fails to load.",
                        "onLoad: a function. Called when the stylesheet finishes being loaded."
                    ]
                },
                {
                    "type": "p",
                    "text": "These props apply whenrel=\"preload\"orrel=\"modulepreload\":"
                },
                {
                    "type": "list",
                    "items": [
                        "as: a string. The type of resource. Its possible values areaudio,document,embed,fetch,font,image,object,script,style,track,video,worker.",
                        "imageSrcSet: a string. Applicable only whenas=\"image\". Specifies thesource set of the image.",
                        "imageSizes: a string. Applicable only whenas=\"image\". Specifies thesizes of the image."
                    ]
                },
                {
                    "type": "p",
                    "text": "These props apply whenrel=\"icon\"orrel=\"apple-touch-icon\":"
                },
                {
                    "type": "list",
                    "items": [
                        "sizes: a string. Thesizes of the icon."
                    ]
                },
                {
                    "type": "p",
                    "text": "These props apply in all cases:"
                },
                {
                    "type": "list",
                    "items": [
                        "href: a string. The URL of the linked resource.",
                        "crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials. It is required whenasis set to\"fetch\".",
                        "referrerPolicy: a string. TheReferrer headerto send when fetching. Its possible values areno-referrer-when-downgrade(the default),no-referrer,origin,origin-when-cross-origin, andunsafe-url.",
                        "fetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values areauto(the default),high, andlow.",
                        "hrefLang: a string. The language of the linked resource.",
                        "integrity: a string. A cryptographic hash of the resource, toverify its authenticity.",
                        "type: a string. The MIME type of the linked resource."
                    ]
                },
                {
                    "type": "p",
                    "text": "Props that arenot recommendedfor use with React:"
                },
                {
                    "type": "list",
                    "items": [
                        "blocking: a string. If set to\"render\", instructs the browser not to render the page until the stylesheet is loaded. React provides more fine-grained control using Suspense."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Special rendering behavior"
                },
                {
                    "type": "p",
                    "text": "React will always place the DOM element corresponding to the<link>component within the document’s<head>, regardless of where in the React tree it is rendered. The<head>is the only valid place for<link>to exist within the DOM, yet it’s convenient and keeps things composable if a component representing a specific page can render<link>components itself."
                },
                {
                    "type": "p",
                    "text": "There are a few exceptions to this:"
                },
                {
                    "type": "list",
                    "items": [
                        "If the<link>has arel=\"stylesheet\"prop, then it has to also have aprecedenceprop to get this special behavior. This is because the order of stylesheets within the document is significant, so React needs to know how to order this stylesheet relative to others, which you specify using theprecedenceprop. If theprecedenceprop is omitted, there is no special behavior.",
                        "If the<link>has anitemPropprop, there is no special behavior, because in this case it doesn’t apply to the document but instead represents metadata about a specific part of the page.",
                        "If the<link>has anonLoadoronErrorprop, because in that case you are managing the loading of the linked resource manually within your React component."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Special behavior for stylesheets"
                },
                {
                    "type": "p",
                    "text": "In addition, if the<link>is to a stylesheet (namely, it hasrel=\"stylesheet\"in its props), React treats it specially in the following ways:"
                },
                {
                    "type": "list",
                    "items": [
                        "The component that renders<link>willsuspendwhile the stylesheet is loading.",
                        "If multiple components render links to the same stylesheet, React will de-duplicate them and only put a single link into the DOM. Two links are considered the same if they have the samehrefprop."
                    ]
                },
                {
                    "type": "p",
                    "text": "There are two exception to this special behavior:"
                },
                {
                    "type": "list",
                    "items": [
                        "If the link doesn’t have aprecedenceprop, there is no special behavior, because the order of stylesheets within the document is significant, so React needs to know how to order this stylesheet relative to others, which you specify using theprecedenceprop.",
                        "If you supply any of theonLoad,onError, ordisabledprops, there is no special behavior, because these props indicate that you are managing the loading of the stylesheet manually within your component."
                    ]
                },
                {
                    "type": "p",
                    "text": "This special treatment comes with two caveats:"
                },
                {
                    "type": "list",
                    "items": [
                        "React will ignore changes to props after the link has been rendered. (React will issue a warning in development if this happens.)",
                        "React may leave the link in the DOM even after the component that rendered it has been unmounted."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Linking to related resources"
                },
                {
                    "type": "p",
                    "text": "You can annotate the document with links to related resources such as an icon, canonical URL, or pingback. React will place this metadata within the document<head>regardless of where in the React tree it is rendered."
                },
                {
                    "type": "code",
                    "code": "importShowRenderedHTMLfrom'./ShowRenderedHTML.js';exportdefaultfunctionBlogPage(){return(<ShowRenderedHTML><linkrel=\"icon\"href=\"favicon.ico\"/><linkrel=\"pingback\"href=\"http://www.example.com/xmlrpc.php\"/><h1>My Blog</h1><p>...</p></ShowRenderedHTML>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Linking to a stylesheet"
                },
                {
                    "type": "p",
                    "text": "If a component depends on a certain stylesheet in order to be displayed correctly, you can render a link to that stylesheet within the component. Your component willsuspendwhile the stylesheet is loading. You must supply theprecedenceprop, which tells React where to place this stylesheet relative to others — stylesheets with higher precedence can override those with lower precedence."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "When you want to use a stylesheet, it can be beneficial to call thepreinitfunction. Calling this function may allow the browser to start fetching the stylesheet earlier than if you just render a<link>component, for example by sending anHTTP Early Hints response."
                },
                {
                    "type": "code",
                    "code": "importShowRenderedHTMLfrom'./ShowRenderedHTML.js';exportdefaultfunctionSiteMapPage(){return(<ShowRenderedHTML><linkrel=\"stylesheet\"href=\"sitemap.css\"precedence=\"medium\"/><p>...</p></ShowRenderedHTML>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Controlling stylesheet precedence"
                },
                {
                    "type": "p",
                    "text": "Stylesheets can conflict with each other, and when they do, the browser goes with the one that comes later in the document. React lets you control the order of stylesheets with theprecedenceprop. In this example, two components render stylesheets, and the one with the higher precedence goes later in the document even though the component that renders it comes earlier."
                },
                {
                    "type": "code",
                    "code": "importShowRenderedHTMLfrom'./ShowRenderedHTML.js';exportdefaultfunctionHomePage(){return(<ShowRenderedHTML><FirstComponent/><SecondComponent/>...</ShowRenderedHTML>);}functionFirstComponent(){return<linkrel=\"stylesheet\"href=\"first.css\"precedence=\"high\"/>;}functionSecondComponent(){return<linkrel=\"stylesheet\"href=\"second.css\"precedence=\"low\"/>;}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Deduplicated stylesheet rendering"
                },
                {
                    "type": "p",
                    "text": "If you render the same stylesheet from multiple components, React will place only a single<link>in the document head."
                },
                {
                    "type": "code",
                    "code": "importShowRenderedHTMLfrom'./ShowRenderedHTML.js';exportdefaultfunctionHomePage(){return(<ShowRenderedHTML><Component/><Component/>...</ShowRenderedHTML>);}functionComponent(){return<linkrel=\"stylesheet\"href=\"styles.css\"precedence=\"medium\"/>;}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Annotating specific items within the document with links"
                },
                {
                    "type": "p",
                    "text": "You can use the<link>component with theitemPropprop to annotate specific items within the document with links to related resources. In this case, React willnotplace these annotations within the document<head>but will place them like any other React component."
                },
                {
                    "type": "code",
                    "code": "<sectionitemScope><h3>Annotating specific items</h3><linkitemProp=\"author\"href=\"http://example.com/\"/><p>...</p></section>"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/components/meta",
            "title": "<meta> – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "<meta>- This feature is available in the latest Canary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "React’s extensions to<meta>are currently only available in React’s canary and experimental channels. In stable releases of React<meta>works only as abuilt-in browser HTML component. Learn more aboutReact’s release channels here."
                },
                {
                    "type": "p",
                    "text": "Thebuilt-in browser<meta>componentlets you add metadata to the document."
                },
                {
                    "type": "code",
                    "code": "<metaname=\"keywords\"content=\"React, JavaScript, semantic markup, html\"/>"
                },
                {
                    "type": "list",
                    "items": [
                        "Reference<meta>",
                        "<meta>",
                        "UsageAnnotating the document with metadataAnnotating specific items within the document with metadata",
                        "Annotating the document with metadata",
                        "Annotating specific items within the document with metadata"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "<meta>"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Annotating the document with metadata",
                        "Annotating specific items within the document with metadata"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "<meta>"
                },
                {
                    "type": "p",
                    "text": "To add document metadata, render thebuilt-in browser<meta>component. You can render<meta>from any component and React will always place the corresponding DOM element in the document head."
                },
                {
                    "type": "code",
                    "code": "<metaname=\"keywords\"content=\"React, JavaScript, semantic markup, html\"/>"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Props"
                },
                {
                    "type": "p",
                    "text": "<meta>supports allcommon element props."
                },
                {
                    "type": "p",
                    "text": "It should haveexactly oneof the following props:name,httpEquiv,charset,itemProp. The<meta>component does something different depending on which of these props is specified."
                },
                {
                    "type": "list",
                    "items": [
                        "name: a string. Specifies thekind of metadatato be attached to the document.",
                        "charset: a string. Specifies the character set used by the document. The only valid value is\"utf-8\".",
                        "httpEquiv: a string. Specifies a directive for processing the document.",
                        "itemProp: a string. Specifies metadata about a particular item within the document rather than the document as a whole.",
                        "content: a string. Specifies the metadata to be attached when used with thenameoritemPropprops or the behavior of the directive when used with thehttpEquivprop."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Special rendering behavior"
                },
                {
                    "type": "p",
                    "text": "React will always place the DOM element corresponding to the<meta>component within the document’s<head>, regardless of where in the React tree it is rendered. The<head>is the only valid place for<meta>to exist within the DOM, yet it’s convenient and keeps things composable if a component representing a specific page can render<meta>components itself."
                },
                {
                    "type": "p",
                    "text": "There is one exception to this: if<meta>has anitemPropprop, there is no special behavior, because in this case it doesn’t represent metadata about the document but rather metadata about a specific part of the page."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Annotating the document with metadata"
                },
                {
                    "type": "p",
                    "text": "You can annotate the document with metadata such as keywords, a summary, or the author’s name. React will place this metadata within the document<head>regardless of where in the React tree it is rendered."
                },
                {
                    "type": "code",
                    "code": "<metaname=\"author\"content=\"John Smith\"/><metaname=\"keywords\"content=\"React, JavaScript, semantic markup, html\"/><metaname=\"description\"content=\"API reference for the <meta> component in React DOM\"/>"
                },
                {
                    "type": "p",
                    "text": "You can render the<meta>component from any component. React will put a<meta>DOM node in the document<head>."
                },
                {
                    "type": "code",
                    "code": "importShowRenderedHTMLfrom'./ShowRenderedHTML.js';exportdefaultfunctionSiteMapPage(){return(<ShowRenderedHTML><metaname=\"keywords\"content=\"React\"/><metaname=\"description\"content=\"A site map for the React website\"/><h1>Site Map</h1><p>...</p></ShowRenderedHTML>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Annotating specific items within the document with metadata"
                },
                {
                    "type": "p",
                    "text": "You can use the<meta>component with theitemPropprop to annotate specific items within the document with metadata. In this case, React willnotplace these annotations within the document<head>but will place them like any other React component."
                },
                {
                    "type": "code",
                    "code": "<sectionitemScope><h3>Annotating specific items</h3><metaitemProp=\"description\"content=\"API reference for using <meta> with itemProp\"/><p>...</p></section>"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/components/option",
            "title": "<option> – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "<option>"
                },
                {
                    "type": "p",
                    "text": "Thebuilt-in browser<option>componentlets you render an option inside a<select>box."
                },
                {
                    "type": "code",
                    "code": "<select><optionvalue=\"someOption\">Some option</option><optionvalue=\"otherOption\">Other option</option></select>"
                },
                {
                    "type": "list",
                    "items": [
                        "Reference<option>",
                        "<option>",
                        "UsageDisplaying a select box with options",
                        "Displaying a select box with options"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "<option>"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Displaying a select box with options"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "<option>"
                },
                {
                    "type": "p",
                    "text": "Thebuilt-in browser<option>componentlets you render an option inside a<select>box."
                },
                {
                    "type": "code",
                    "code": "<select><optionvalue=\"someOption\">Some option</option><optionvalue=\"otherOption\">Other option</option></select>"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Props"
                },
                {
                    "type": "p",
                    "text": "<option>supports allcommon element props."
                },
                {
                    "type": "p",
                    "text": "Additionally,<option>supports these props:"
                },
                {
                    "type": "list",
                    "items": [
                        "disabled: A boolean. Iftrue, the option will not be selectable and will appear dimmed.",
                        "label: A string. Specifies the meaning of the option. If not specified, the text inside the option is used.",
                        "value: The value to be usedwhen submitting the parent<select>in a formif this option is selected."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "React does not support theselectedattribute on<option>. Instead, pass this option’svalueto the parent<select defaultValue>for an uncontrolled select box, or<select value>for a controlled select."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Displaying a select box with options"
                },
                {
                    "type": "p",
                    "text": "Render a<select>with a list of<option>components inside to display a select box. Give each<option>avaluerepresenting the data to be submitted with the form."
                },
                {
                    "type": "p",
                    "text": "Read more about displaying a<select>with a list of<option>components."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionFruitPicker(){return(<label>Pick a fruit:<selectname=\"selectedFruit\"><optionvalue=\"apple\">Apple</option><optionvalue=\"banana\">Banana</option><optionvalue=\"orange\">Orange</option></select></label>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/components/progress",
            "title": "<progress> – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "<progress>"
                },
                {
                    "type": "p",
                    "text": "Thebuilt-in browser<progress>componentlets you render a progress indicator."
                },
                {
                    "type": "code",
                    "code": "<progressvalue={0.5}/>"
                },
                {
                    "type": "list",
                    "items": [
                        "Reference<progress>",
                        "<progress>",
                        "UsageControlling a progress indicator",
                        "Controlling a progress indicator"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "<progress>"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Controlling a progress indicator"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "<progress>"
                },
                {
                    "type": "p",
                    "text": "To display a progress indicator, render thebuilt-in browser<progress>component."
                },
                {
                    "type": "code",
                    "code": "<progressvalue={0.5}/>"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Props"
                },
                {
                    "type": "p",
                    "text": "<progress>supports allcommon element props."
                },
                {
                    "type": "p",
                    "text": "Additionally,<progress>supports these props:"
                },
                {
                    "type": "list",
                    "items": [
                        "max: A number. Specifies the maximumvalue. Defaults to1.",
                        "value: A number between0andmax, ornullfor indeterminate progress. Specifies how much was done."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Controlling a progress indicator"
                },
                {
                    "type": "p",
                    "text": "To display a progress indicator, render a<progress>component. You can pass a numbervaluebetween0and themaxvalue you specify. If you don’t pass amaxvalue, it will assumed to be1by default."
                },
                {
                    "type": "p",
                    "text": "If the operation is not ongoing, passvalue={null}to put the progress indicator into an indeterminate state."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionApp(){return(<><progressvalue={0}/><progressvalue={0.5}/><progressvalue={0.7}/><progressvalue={75}max={100}/><progressvalue={1}/><progressvalue={null}/></>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/components/script",
            "title": "<script> – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "<script>- This feature is available in the latest Canary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "React’s extensions to<script>are currently only available in React’s canary and experimental channels. In stable releases of React<script>works only as abuilt-in browser HTML component. Learn more aboutReact’s release channels here."
                },
                {
                    "type": "p",
                    "text": "Thebuilt-in browser<script>componentlets you add a script to your document."
                },
                {
                    "type": "code",
                    "code": "<script>alert(\"hi!\")</script>"
                },
                {
                    "type": "list",
                    "items": [
                        "Reference<script>",
                        "<script>",
                        "UsageRendering an external scriptRendering an inline script",
                        "Rendering an external script",
                        "Rendering an inline script"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "<script>"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Rendering an external script",
                        "Rendering an inline script"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "<script>"
                },
                {
                    "type": "p",
                    "text": "To add inline or external scripts to your document, render thebuilt-in browser<script>component. You can render<script>from any component and React willin certain casesplace the corresponding DOM element in the document head and de-duplicate identical scripts."
                },
                {
                    "type": "code",
                    "code": "<script>alert(\"hi!\")</script><scriptsrc=\"script.js\"/>"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Props"
                },
                {
                    "type": "p",
                    "text": "<script>supports allcommon element props."
                },
                {
                    "type": "p",
                    "text": "It should haveeitherchildrenor asrcprop."
                },
                {
                    "type": "list",
                    "items": [
                        "children: a string. The source code of an inline script.",
                        "src: a string. The URL of an external script."
                    ]
                },
                {
                    "type": "p",
                    "text": "Other supported props:"
                },
                {
                    "type": "list",
                    "items": [
                        "async: a boolean. Allows the browser to defer execution of the script until the rest of the document has been processed — the preferred behavior for performance.",
                        "crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials.",
                        "fetchPriority: a string. Lets the browser rank scripts in priority when fetching multiple scripts at the same time. Can be\"high\",\"low\", or\"auto\"(the default).",
                        "integrity: a string. A cryptographic hash of the script, toverify its authenticity.",
                        "noModule: a boolean. Disables the script in browsers that support ES modules — allowing for a fallback script for browsers that do not.",
                        "nonce: a string. A cryptographicnonce to allow the resourcewhen using a strict Content Security Policy.",
                        "referrer: a string. Sayswhat Referer header to sendwhen fetching the script and any resources that the script fetches in turn.",
                        "type: a string. Says whether the script is aclassic script, ES module, or import map."
                    ]
                },
                {
                    "type": "p",
                    "text": "Props that disable React’sspecial treatment of scripts:"
                },
                {
                    "type": "list",
                    "items": [
                        "onError: a function. Called when the script fails to load.",
                        "onLoad: a function. Called when the script finishes being loaded."
                    ]
                },
                {
                    "type": "p",
                    "text": "Props that arenot recommendedfor use with React:"
                },
                {
                    "type": "list",
                    "items": [
                        "blocking: a string. If set to\"render\", instructs the browser not to render the page until the scriptsheet is loaded. React provides more fine-grained control using Suspense.",
                        "defer: a string. Prevents the browser from executing the script until the document is done loading. Not compatible with streaming server-rendered components. Use theasyncprop instead."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Special rendering behavior"
                },
                {
                    "type": "p",
                    "text": "React can move<script>components to the document’s<head>and de-duplicate identical scripts."
                },
                {
                    "type": "p",
                    "text": "To opt into this behavior, provide thesrcandasync={true}props. React will de-duplicate scripts if they have the samesrc. Theasyncprop must be true to allow scripts to be safely moved."
                },
                {
                    "type": "p",
                    "text": "This special treatment comes with two caveats:"
                },
                {
                    "type": "list",
                    "items": [
                        "React will ignore changes to props after the script has been rendered. (React will issue a warning in development if this happens.)",
                        "React may leave the script in the DOM even after the component that rendered it has been unmounted. (This has no effect as scripts just execute once when they are inserted into the DOM.)"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rendering an external script"
                },
                {
                    "type": "p",
                    "text": "If a component depends on certain scripts in order to be displayed correctly, you can render a<script>within the component.\nHowever, the component might be committed before the script has finished loading.\nYou can start depending on the script content once theloadevent is fired e.g. by using theonLoadprop."
                },
                {
                    "type": "p",
                    "text": "React will de-duplicate scripts that have the samesrc, inserting only one of them into the DOM even if multiple components render it."
                },
                {
                    "type": "code",
                    "code": "importShowRenderedHTMLfrom'./ShowRenderedHTML.js';functionMap({lat,long}){return(<><scriptasyncsrc=\"map-api.js\"onLoad={()=>console.log('script loaded')}/><divid=\"map\"data-lat={lat}data-long={long}/></>);}exportdefaultfunctionPage(){return(<ShowRenderedHTML><Map/></ShowRenderedHTML>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "When you want to use a script, it can be beneficial to call thepreinitfunction. Calling this function may allow the browser to start fetching the script earlier than if you just render a<script>component, for example by sending anHTTP Early Hints response."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rendering an inline script"
                },
                {
                    "type": "p",
                    "text": "To include an inline script, render the<script>component with the script source code as its children. Inline scripts are not de-duplicated or moved to the document<head>."
                },
                {
                    "type": "code",
                    "code": "importShowRenderedHTMLfrom'./ShowRenderedHTML.js';functionTracking(){return(<script>ga('send', 'pageview');</script>);}exportdefaultfunctionPage(){return(<ShowRenderedHTML><h1>My Website</h1><Tracking/><p>Welcome</p></ShowRenderedHTML>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/components/select",
            "title": "<select> – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "<select>"
                },
                {
                    "type": "p",
                    "text": "Thebuilt-in browser<select>componentlets you render a select box with options."
                },
                {
                    "type": "code",
                    "code": "<select><optionvalue=\"someOption\">Some option</option><optionvalue=\"otherOption\">Other option</option></select>"
                },
                {
                    "type": "list",
                    "items": [
                        "Reference<select>",
                        "<select>",
                        "UsageDisplaying a select box with optionsProviding a label for a select boxProviding an initially selected optionEnabling multiple selectionReading the select box value when submitting a formControlling a select box with a state variable",
                        "Displaying a select box with options",
                        "Providing a label for a select box",
                        "Providing an initially selected option",
                        "Enabling multiple selection",
                        "Reading the select box value when submitting a form",
                        "Controlling a select box with a state variable"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "<select>"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Displaying a select box with options",
                        "Providing a label for a select box",
                        "Providing an initially selected option",
                        "Enabling multiple selection",
                        "Reading the select box value when submitting a form",
                        "Controlling a select box with a state variable"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "<select>"
                },
                {
                    "type": "p",
                    "text": "To display a select box, render thebuilt-in browser<select>component."
                },
                {
                    "type": "code",
                    "code": "<select><optionvalue=\"someOption\">Some option</option><optionvalue=\"otherOption\">Other option</option></select>"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Props"
                },
                {
                    "type": "p",
                    "text": "<select>supports allcommon element props."
                },
                {
                    "type": "p",
                    "text": "You canmake a select box controlledby passing avalueprop:"
                },
                {
                    "type": "list",
                    "items": [
                        "value: A string (or an array of strings formultiple={true}). Controls which option is selected. Every value string match thevalueof some<option>nested inside the<select>."
                    ]
                },
                {
                    "type": "p",
                    "text": "When you passvalue, you must also pass anonChangehandler that updates the passed value."
                },
                {
                    "type": "p",
                    "text": "If your<select>is uncontrolled, you may pass thedefaultValueprop instead:"
                },
                {
                    "type": "list",
                    "items": [
                        "defaultValue: A string (or an array of strings formultiple={true}). Specifiesthe initially selected option."
                    ]
                },
                {
                    "type": "p",
                    "text": "These<select>props are relevant both for uncontrolled and controlled select boxes:"
                },
                {
                    "type": "list",
                    "items": [
                        "autoComplete: A string. Specifies one of the possibleautocomplete behaviors.",
                        "autoFocus: A boolean. Iftrue, React will focus the element on mount.",
                        "children:<select>accepts<option>,<optgroup>, and<datalist>components as children. You can also pass your own components as long as they eventually render one of the allowed components. If you pass your own components that eventually render<option>tags, each<option>you render must have avalue.",
                        "disabled: A boolean. Iftrue, the select box will not be interactive and will appear dimmed.",
                        "form: A string. Specifies theidof the<form>this select box belongs to. If omitted, it’s the closest parent form.",
                        "multiple: A boolean. Iftrue, the browser allowsmultiple selection.",
                        "name: A string. Specifies the name for this select box that’ssubmitted with the form.",
                        "onChange: AnEventhandlerfunction. Required forcontrolled select boxes.Fires immediately when the user picks a different option. Behaves like the browserinputevent.",
                        "onChangeCapture: A version ofonChangethat fires in thecapture phase.",
                        "onInput: AnEventhandlerfunction. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to useonChangeinstead which works similarly.",
                        "onInputCapture: A version ofonInputthat fires in thecapture phase.",
                        "onInvalid: AnEventhandlerfunction. Fires if an input fails validation on form submit. Unlike the built-ininvalidevent, the ReactonInvalidevent bubbles.",
                        "onInvalidCapture: A version ofonInvalidthat fires in thecapture phase.",
                        "required: A boolean. Iftrue, the value must be provided for the form to submit.",
                        "size: A number. Formultiple={true}selects, specifies the preferred number of initially visible items."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Unlike in HTML, passing aselectedattribute to<option>is not supported. Instead, use<select defaultValue>for uncontrolled select boxes and<select value>for controlled select boxes.",
                        "If a select box receives avalueprop, it will betreated as controlled.",
                        "A select box can’t be both controlled and uncontrolled at the same time.",
                        "A select box cannot switch between being controlled or uncontrolled over its lifetime.",
                        "Every controlled select box needs anonChangeevent handler that synchronously updates its backing value."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Displaying a select box with options"
                },
                {
                    "type": "p",
                    "text": "Render a<select>with a list of<option>components inside to display a select box. Give each<option>avaluerepresenting the data to be submitted with the form."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionFruitPicker(){return(<label>Pick a fruit:<selectname=\"selectedFruit\"><optionvalue=\"apple\">Apple</option><optionvalue=\"banana\">Banana</option><optionvalue=\"orange\">Orange</option></select></label>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Providing a label for a select box"
                },
                {
                    "type": "p",
                    "text": "Typically, you will place every<select>inside a<label>tag. This tells the browser that this label is associated with that select box. When the user clicks the label, the browser will automatically focus the select box. It’s also essential for accessibility: a screen reader will announce the label caption when the user focuses the select box."
                },
                {
                    "type": "p",
                    "text": "If you can’t nest<select>into a<label>, associate them by passing the same ID to<select id>and<label htmlFor>.To avoid conflicts between multiple instances of one component, generate such an ID withuseId."
                },
                {
                    "type": "code",
                    "code": "import{useId}from'react';exportdefaultfunctionForm(){constvegetableSelectId=useId();return(<><label>Pick a fruit:<selectname=\"selectedFruit\"><optionvalue=\"apple\">Apple</option><optionvalue=\"banana\">Banana</option><optionvalue=\"orange\">Orange</option></select></label><hr/><labelhtmlFor={vegetableSelectId}>Pick a vegetable:</label><selectid={vegetableSelectId}name=\"selectedVegetable\"><optionvalue=\"cucumber\">Cucumber</option><optionvalue=\"corn\">Corn</option><optionvalue=\"tomato\">Tomato</option></select></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Providing an initially selected option"
                },
                {
                    "type": "p",
                    "text": "By default, the browser will select the first<option>in the list. To select a different option by default, pass that<option>’svalueas thedefaultValueto the<select>element."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionFruitPicker(){return(<label>Pick a fruit:<selectname=\"selectedFruit\"defaultValue=\"orange\"><optionvalue=\"apple\">Apple</option><optionvalue=\"banana\">Banana</option><optionvalue=\"orange\">Orange</option></select></label>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Unlike in HTML, passing aselectedattribute to an individual<option>is not supported."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Enabling multiple selection"
                },
                {
                    "type": "p",
                    "text": "Passmultiple={true}to the<select>to let the user select multiple options. In that case, if you also specifydefaultValueto choose the initially selected options, it must be an array."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionFruitPicker(){return(<label>Pick some fruits:<selectname=\"selectedFruit\"defaultValue={['orange','banana']}multiple={true}><optionvalue=\"apple\">Apple</option><optionvalue=\"banana\">Banana</option><optionvalue=\"orange\">Orange</option></select></label>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Reading the select box value when submitting a form"
                },
                {
                    "type": "p",
                    "text": "Add a<form>around your select box with a<button type=\"submit\">inside. It will call your<form onSubmit>event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by callinge.preventDefault(). Read the form data withnew FormData(e.target)."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionEditPost(){functionhandleSubmit(e){// Prevent the browser from reloading the pagee.preventDefault();// Read the form dataconstform=e.target;constformData=newFormData(form);// You can pass formData as a fetch body directly:fetch('/some-api',{method:form.method,body:formData});// You can generate a URL out of it, as the browser does by default:console.log(newURLSearchParams(formData).toString());// You can work with it as a plain object.constformJson=Object.fromEntries(formData.entries());console.log(formJson);// (!) This doesn't include multiple select values// Or you can get an array of name-value pairs.console.log([...formData.entries()]);}return(<formmethod=\"post\"onSubmit={handleSubmit}><label>Pick your favorite fruit:<selectname=\"selectedFruit\"defaultValue=\"orange\"><optionvalue=\"apple\">Apple</option><optionvalue=\"banana\">Banana</option><optionvalue=\"orange\">Orange</option></select></label><label>Pick all your favorite vegetables:<selectname=\"selectedVegetables\"multiple={true}defaultValue={['corn','tomato']}><optionvalue=\"cucumber\">Cucumber</option><optionvalue=\"corn\">Corn</option><optionvalue=\"tomato\">Tomato</option></select></label><hr/><buttontype=\"reset\">Reset</button><buttontype=\"submit\">Submit</button></form>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Give anameto your<select>, for example<select name=\"selectedFruit\" />. Thenameyou specified will be used as a key in the form data, for example{ selectedFruit: \"orange\" }."
                },
                {
                    "type": "p",
                    "text": "If you use<select multiple={true}>, theFormDatayou’ll read from the form will include each selected value as a separate name-value pair. Look closely at the console logs in the example above."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "By default,any<button>inside a<form>will submit it. This can be surprising! If you have your own customButtonReact component, consider returning<button type=\"button\">instead of<button>. Then, to be explicit, use<button type=\"submit\">for buttons thataresupposed to submit the form."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Controlling a select box with a state variable"
                },
                {
                    "type": "p",
                    "text": "A select box like<select />isuncontrolled.Even if youpass an initially selected valuelike<select defaultValue=\"orange\" />, your JSX only specifies the initial value, not the value right now."
                },
                {
                    "type": "p",
                    "text": "To render acontrolledselect box, pass thevalueprop to it.React will force the select box to always have thevalueyou passed. Typically, you will control a select box by declaring astate variable:"
                },
                {
                    "type": "code",
                    "code": "functionFruitPicker(){const[selectedFruit,setSelectedFruit]=useState('orange');// Declare a state variable...// ...return(<selectvalue={selectedFruit}// ...force the select's value to match the state variable...onChange={e=>setSelectedFruit(e.target.value)}// ... and update the state variable on any change!><optionvalue=\"apple\">Apple</option><optionvalue=\"banana\">Banana</option><optionvalue=\"orange\">Orange</option></select>);}"
                },
                {
                    "type": "p",
                    "text": "This is useful if you want to re-render some part of the UI in response to every selection."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionFruitPicker(){const[selectedFruit,setSelectedFruit]=useState('orange');const[selectedVegs,setSelectedVegs]=useState(['corn','tomato']);return(<><label>Pick a fruit:<selectvalue={selectedFruit}onChange={e=>setSelectedFruit(e.target.value)}><optionvalue=\"apple\">Apple</option><optionvalue=\"banana\">Banana</option><optionvalue=\"orange\">Orange</option></select></label><hr/><label>Pick all your favorite vegetables:<selectmultiple={true}value={selectedVegs}onChange={e=>{constoptions=[...e.target.selectedOptions];constvalues=options.map(option=>option.value);setSelectedVegs(values);}}><optionvalue=\"cucumber\">Cucumber</option><optionvalue=\"corn\">Corn</option><optionvalue=\"tomato\">Tomato</option></select></label><hr/><p>Your favorite fruit:{selectedFruit}</p><p>Your favorite vegetables:{selectedVegs.join(', ')}</p></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "If you passvaluewithoutonChange, it will be impossible to select an option.When you control a select box by passing somevalueto it, youforceit to always have the value you passed. So if you pass a state variable as avaluebut forget to update that state variable synchronously during theonChangeevent handler, React will revert the select box after every keystroke back to thevaluethat you specified."
                },
                {
                    "type": "p",
                    "text": "Unlike in HTML, passing aselectedattribute to an individual<option>is not supported."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/components/style",
            "title": "<style> – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "<style>- This feature is available in the latest Canary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "React’s extensions to<style>are currently only available in React’s canary and experimental channels. In stable releases of React<style>works only as abuilt-in browser HTML component. Learn more aboutReact’s release channels here."
                },
                {
                    "type": "p",
                    "text": "Thebuilt-in browser<style>componentlets you add inline CSS stylesheets to your document."
                },
                {
                    "type": "code",
                    "code": "<style>{` p { color: red; } `}</style>"
                },
                {
                    "type": "list",
                    "items": [
                        "Reference<style>",
                        "<style>",
                        "UsageRendering an inline CSS stylesheet",
                        "Rendering an inline CSS stylesheet"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "<style>"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Rendering an inline CSS stylesheet"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "<style>"
                },
                {
                    "type": "p",
                    "text": "To add inline styles to your document, render thebuilt-in browser<style>component. You can render<style>from any component and React willin certain casesplace the corresponding DOM element in the document head and de-duplicate identical styles."
                },
                {
                    "type": "code",
                    "code": "<style>{` p { color: red; } `}</style>"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Props"
                },
                {
                    "type": "p",
                    "text": "<style>supports allcommon element props."
                },
                {
                    "type": "list",
                    "items": [
                        "children: a string, required. The contents of the stylesheet.",
                        "precedence: a string. Tells React where to rank the<style>DOM node relative to others in the document<head>, which determines which stylesheet can override the other. React will infer that precedence values it discovers first are “lower” and precedence values it discovers later are “higher”. Many style systems can work fine using a single precedence value because style rules are atomic. Stylesheets with the same precedence go together whether they are<link>or inline<style>tags or loaded usingpreinitfunctions.",
                        "href: a string. Allows React tode-duplicate stylesthat have the samehref.",
                        "media: a string. Restricts the stylesheet to a certainmedia query.",
                        "nonce: a string. A cryptographicnonce to allow the resourcewhen using a strict Content Security Policy.",
                        "title: a string. Specifies the name of analternative stylesheet."
                    ]
                },
                {
                    "type": "p",
                    "text": "Props that arenot recommendedfor use with React:"
                },
                {
                    "type": "list",
                    "items": [
                        "blocking: a string. If set to\"render\", instructs the browser not to render the page until the stylesheet is loaded. React provides more fine-grained control using Suspense."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Special rendering behavior"
                },
                {
                    "type": "p",
                    "text": "React can move<style>components to the document’s<head>, de-duplicate identical stylesheets, andsuspendwhile the stylesheet is loading."
                },
                {
                    "type": "p",
                    "text": "To opt into this behavior, provide thehrefandprecedenceprops. React will de-duplicate styles if they have the samehref. The precedence prop tells React where to rank the<style>DOM node relative to others in the document<head>, which determines which stylesheet can override the other."
                },
                {
                    "type": "p",
                    "text": "This special treatment comes with two caveats:"
                },
                {
                    "type": "list",
                    "items": [
                        "React will ignore changes to props after the style has been rendered. (React will issue a warning in development if this happens.)",
                        "React may leave the style in the DOM even after the component that rendered it has been unmounted."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rendering an inline CSS stylesheet"
                },
                {
                    "type": "p",
                    "text": "If a component depends on certain CSS styles in order to be displayed correctly, you can render an inline stylesheet within the component."
                },
                {
                    "type": "p",
                    "text": "If you supply anhrefandprecedenceprop, your component will suspend while the stylesheet is loading. (Even with inline stylesheets, there may be a loading time due to fonts and images that the stylesheet refers to.) Thehrefprop should uniquely identify the stylesheet, because React will de-duplicate stylesheets that have the samehref."
                },
                {
                    "type": "code",
                    "code": "importShowRenderedHTMLfrom'./ShowRenderedHTML.js';import{useId}from'react';functionPieChart({data,colors}){constid=useId();conststylesheet=colors.map((color,index)=>`#${id}.color-${index}: \\{ color: \"${color}\"; \\}`).join();return(<><stylehref={\"PieChart-\"+JSON.stringify(colors)}precedence=\"medium\">{stylesheet}</style><svgid={id}>…</svg></>);}exportdefaultfunctionApp(){return(<ShowRenderedHTML><PieChartdata=\"...\"colors={['red','green','blue']}/></ShowRenderedHTML>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/components/textarea",
            "title": "<textarea> – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "<textarea>"
                },
                {
                    "type": "p",
                    "text": "Thebuilt-in browser<textarea>componentlets you render a multiline text input."
                },
                {
                    "type": "code",
                    "code": "<textarea/>"
                },
                {
                    "type": "list",
                    "items": [
                        "Reference<textarea>",
                        "<textarea>",
                        "UsageDisplaying a text areaProviding a label for a text areaProviding an initial value for a text areaReading the text area value when submitting a formControlling a text area with a state variable",
                        "Displaying a text area",
                        "Providing a label for a text area",
                        "Providing an initial value for a text area",
                        "Reading the text area value when submitting a form",
                        "Controlling a text area with a state variable",
                        "TroubleshootingMy text area doesn’t update when I type into itMy text area caret jumps to the beginning on every keystrokeI’m getting an error: “A component is changing an uncontrolled input to be controlled”",
                        "My text area doesn’t update when I type into it",
                        "My text area caret jumps to the beginning on every keystroke",
                        "I’m getting an error: “A component is changing an uncontrolled input to be controlled”"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "<textarea>"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Displaying a text area",
                        "Providing a label for a text area",
                        "Providing an initial value for a text area",
                        "Reading the text area value when submitting a form",
                        "Controlling a text area with a state variable"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "My text area doesn’t update when I type into it",
                        "My text area caret jumps to the beginning on every keystroke",
                        "I’m getting an error: “A component is changing an uncontrolled input to be controlled”"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "<textarea>"
                },
                {
                    "type": "p",
                    "text": "To display a text area, render thebuilt-in browser<textarea>component."
                },
                {
                    "type": "code",
                    "code": "<textareaname=\"postContent\"/>"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Props"
                },
                {
                    "type": "p",
                    "text": "<textarea>supports allcommon element props."
                },
                {
                    "type": "p",
                    "text": "You canmake a text area controlledby passing avalueprop:"
                },
                {
                    "type": "list",
                    "items": [
                        "value: A string. Controls the text inside the text area."
                    ]
                },
                {
                    "type": "p",
                    "text": "When you passvalue, you must also pass anonChangehandler that updates the passed value."
                },
                {
                    "type": "p",
                    "text": "If your<textarea>is uncontrolled, you may pass thedefaultValueprop instead:"
                },
                {
                    "type": "list",
                    "items": [
                        "defaultValue: A string. Specifiesthe initial valuefor a text area."
                    ]
                },
                {
                    "type": "p",
                    "text": "These<textarea>props are relevant both for uncontrolled and controlled text areas:"
                },
                {
                    "type": "list",
                    "items": [
                        "autoComplete: Either'on'or'off'. Specifies the autocomplete behavior.",
                        "autoFocus: A boolean. Iftrue, React will focus the element on mount.",
                        "children:<textarea>does not accept children. To set the initial value, usedefaultValue.",
                        "cols: A number. Specifies the default width in average character widths. Defaults to20.",
                        "disabled: A boolean. Iftrue, the input will not be interactive and will appear dimmed.",
                        "form: A string. Specifies theidof the<form>this input belongs to. If omitted, it’s the closest parent form.",
                        "maxLength: A number. Specifies the maximum length of text.",
                        "minLength: A number. Specifies the minimum length of text.",
                        "name: A string. Specifies the name for this input that’ssubmitted with the form.",
                        "onChange: AnEventhandlerfunction. Required forcontrolled text areas.Fires immediately when the input’s value is changed by the user (for example, it fires on every keystroke). Behaves like the browserinputevent.",
                        "onChangeCapture: A version ofonChangethat fires in thecapture phase.",
                        "onInput: AnEventhandlerfunction. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to useonChangeinstead which works similarly.",
                        "onInputCapture: A version ofonInputthat fires in thecapture phase.",
                        "onInvalid: AnEventhandlerfunction. Fires if an input fails validation on form submit. Unlike the built-ininvalidevent, the ReactonInvalidevent bubbles.",
                        "onInvalidCapture: A version ofonInvalidthat fires in thecapture phase.",
                        "onSelect: AnEventhandlerfunction. Fires after the selection inside the<textarea>changes. React extends theonSelectevent to also fire for empty selection and on edits (which may affect the selection).",
                        "onSelectCapture: A version ofonSelectthat fires in thecapture phase.",
                        "placeholder: A string. Displayed in a dimmed color when the text area value is empty.",
                        "readOnly: A boolean. Iftrue, the text area is not editable by the user.",
                        "required: A boolean. Iftrue, the value must be provided for the form to submit.",
                        "rows: A number. Specifies the default height in average character heights. Defaults to2.",
                        "wrap: Either'hard','soft', or'off'. Specifies how the text should be wrapped when submitting a form."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Passing children like<textarea>something</textarea>is not allowed.UsedefaultValuefor initial content.",
                        "If a text area receives a stringvalueprop, it will betreated as controlled.",
                        "A text area can’t be both controlled and uncontrolled at the same time.",
                        "A text area cannot switch between being controlled or uncontrolled over its lifetime.",
                        "Every controlled text area needs anonChangeevent handler that synchronously updates its backing value."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Displaying a text area"
                },
                {
                    "type": "p",
                    "text": "Render<textarea>to display a text area. You can specify its default size with therowsandcolsattributes, but by default the user will be able to resize it. To disable resizing, you can specifyresize: nonein the CSS."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionNewPost(){return(<label>Write your post:<textareaname=\"postContent\"rows={4}cols={40}/></label>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Providing a label for a text area"
                },
                {
                    "type": "p",
                    "text": "Typically, you will place every<textarea>inside a<label>tag. This tells the browser that this label is associated with that text area. When the user clicks the label, the browser will focus the text area. It’s also essential for accessibility: a screen reader will announce the label caption when the user focuses the text area."
                },
                {
                    "type": "p",
                    "text": "If you can’t nest<textarea>into a<label>, associate them by passing the same ID to<textarea id>and<label htmlFor>.To avoid conflicts between instances of one component, generate such an ID withuseId."
                },
                {
                    "type": "code",
                    "code": "import{useId}from'react';exportdefaultfunctionForm(){constpostTextAreaId=useId();return(<><labelhtmlFor={postTextAreaId}>Write your post:</label><textareaid={postTextAreaId}name=\"postContent\"rows={4}cols={40}/></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Providing an initial value for a text area"
                },
                {
                    "type": "p",
                    "text": "You can optionally specify the initial value for the text area. Pass it as thedefaultValuestring."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionEditPost(){return(<label>Edit your post:<textareaname=\"postContent\"defaultValue=\"I really enjoyed biking yesterday!\"rows={4}cols={40}/></label>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Unlike in HTML, passing initial text like<textarea>Some content</textarea>is not supported."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Reading the text area value when submitting a form"
                },
                {
                    "type": "p",
                    "text": "Add a<form>around your textarea with a<button type=\"submit\">inside. It will call your<form onSubmit>event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by callinge.preventDefault(). Read the form data withnew FormData(e.target)."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionEditPost(){functionhandleSubmit(e){// Prevent the browser from reloading the pagee.preventDefault();// Read the form dataconstform=e.target;constformData=newFormData(form);// You can pass formData as a fetch body directly:fetch('/some-api',{method:form.method,body:formData});// Or you can work with it as a plain object:constformJson=Object.fromEntries(formData.entries());console.log(formJson);}return(<formmethod=\"post\"onSubmit={handleSubmit}><label>Post title:<inputname=\"postTitle\"defaultValue=\"Biking\"/></label><label>Edit your post:<textareaname=\"postContent\"defaultValue=\"I really enjoyed biking yesterday!\"rows={4}cols={40}/></label><hr/><buttontype=\"reset\">Reset edits</button><buttontype=\"submit\">Save post</button></form>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Give anameto your<textarea>, for example<textarea name=\"postContent\" />. Thenameyou specified will be used as a key in the form data, for example{ postContent: \"Your post\" }."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "By default,any<button>inside a<form>will submit it. This can be surprising! If you have your own customButtonReact component, consider returning<button type=\"button\">instead of<button>. Then, to be explicit, use<button type=\"submit\">for buttons thataresupposed to submit the form."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Controlling a text area with a state variable"
                },
                {
                    "type": "p",
                    "text": "A text area like<textarea />isuncontrolled.Even if youpass an initial valuelike<textarea defaultValue=\"Initial text\" />, your JSX only specifies the initial value, not the value right now."
                },
                {
                    "type": "p",
                    "text": "To render acontrolledtext area, pass thevalueprop to it.React will force the text area to always have thevalueyou passed. Typically, you will control a text area by declaring astate variable:"
                },
                {
                    "type": "code",
                    "code": "functionNewPost(){const[postContent,setPostContent]=useState('');// Declare a state variable...// ...return(<textareavalue={postContent}// ...force the input's value to match the state variable...onChange={e=>setPostContent(e.target.value)}// ... and update the state variable on any edits!/>);}"
                },
                {
                    "type": "p",
                    "text": "This is useful if you want to re-render some part of the UI in response to every keystroke."
                },
                {
                    "type": "code",
                    "code": "{\"dependencies\":{\"react\":\"latest\",\"react-dom\":\"latest\",\"react-scripts\":\"latest\",\"remarkable\":\"2.0.1\"},\"scripts\":{\"start\":\"react-scripts start\",\"build\":\"react-scripts build\",\"test\":\"react-scripts test --env=jsdom\",\"eject\":\"react-scripts eject\"},\"devDependencies\":{}}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "If you passvaluewithoutonChange, it will be impossible to type into the text area.When you control a text area by passing somevalueto it, youforceit to always have the value you passed. So if you pass a state variable as avaluebut forget to update that state variable synchronously during theonChangeevent handler, React will revert the text area after every keystroke back to thevaluethat you specified."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My text area doesn’t update when I type into it"
                },
                {
                    "type": "p",
                    "text": "If you render a text area withvaluebut noonChange, you will see an error in the console:"
                },
                {
                    "type": "code",
                    "code": "// 🔴 Bug: controlled text area with no onChange handler<textareavalue={something}/>"
                },
                {
                    "type": "p",
                    "text": "As the error message suggests, if you only wanted tospecify theinitialvalue,passdefaultValueinstead:"
                },
                {
                    "type": "code",
                    "code": "// ✅ Good: uncontrolled text area with an initial value<textareadefaultValue={something}/>"
                },
                {
                    "type": "p",
                    "text": "If you wantto control this text area with a state variable,specify anonChangehandler:"
                },
                {
                    "type": "code",
                    "code": "// ✅ Good: controlled text area with onChange<textareavalue={something}onChange={e=>setSomething(e.target.value)}/>"
                },
                {
                    "type": "p",
                    "text": "If the value is intentionally read-only, add areadOnlyprop to suppress the error:"
                },
                {
                    "type": "code",
                    "code": "// ✅ Good: readonly controlled text area without on change<textareavalue={something}readOnly={true}/>"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My text area caret jumps to the beginning on every keystroke"
                },
                {
                    "type": "p",
                    "text": "If youcontrol a text area,you must update its state variable to the text area’s value from the DOM duringonChange."
                },
                {
                    "type": "p",
                    "text": "You can’t update it to something other thane.target.value:"
                },
                {
                    "type": "code",
                    "code": "functionhandleChange(e){// 🔴 Bug: updating an input to something other than e.target.valuesetFirstName(e.target.value.toUpperCase());}"
                },
                {
                    "type": "p",
                    "text": "You also can’t update it asynchronously:"
                },
                {
                    "type": "code",
                    "code": "functionhandleChange(e){// 🔴 Bug: updating an input asynchronouslysetTimeout(()=>{setFirstName(e.target.value);},100);}"
                },
                {
                    "type": "p",
                    "text": "To fix your code, update it synchronously toe.target.value:"
                },
                {
                    "type": "code",
                    "code": "functionhandleChange(e){// ✅ Updating a controlled input to e.target.value synchronouslysetFirstName(e.target.value);}"
                },
                {
                    "type": "p",
                    "text": "If this doesn’t fix the problem, it’s possible that the text area gets removed and re-added from the DOM on every keystroke. This can happen if you’re accidentallyresetting stateon every re-render. For example, this can happen if the text area or one of its parents always receives a differentkeyattribute, or if you nest component definitions (which is not allowed in React and causes the “inner” component to remount on every render)."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’m getting an error: “A component is changing an uncontrolled input to be controlled”"
                },
                {
                    "type": "p",
                    "text": "If you provide avalueto the component, it must remain a string throughout its lifetime."
                },
                {
                    "type": "p",
                    "text": "You cannot passvalue={undefined}first and later passvalue=\"some string\"because React won’t know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a stringvalue, notnullorundefined."
                },
                {
                    "type": "p",
                    "text": "If yourvalueis coming from an API or a state variable, it might be initialized tonullorundefined. In that case, either set it to an empty string ('') initially, or passvalue={someValue ?? ''}to ensurevalueis a string."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/components/title",
            "title": "<title> – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "<title>- This feature is available in the latest Canary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "React’s extensions to<title>are currently only available in React’s canary and experimental channels. In stable releases of React<title>works only as abuilt-in browser HTML component. Learn more aboutReact’s release channels here."
                },
                {
                    "type": "p",
                    "text": "Thebuilt-in browser<title>componentlets you specify the title of the document."
                },
                {
                    "type": "code",
                    "code": "<title>My Blog</title>"
                },
                {
                    "type": "list",
                    "items": [
                        "Reference<title>",
                        "<title>",
                        "UsageSet the document titleUse variables in the title",
                        "Set the document title",
                        "Use variables in the title"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "<title>"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Set the document title",
                        "Use variables in the title"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "<title>"
                },
                {
                    "type": "p",
                    "text": "To specify the title of the document, render thebuilt-in browser<title>component. You can render<title>from any component and React will always place the corresponding DOM element in the document head."
                },
                {
                    "type": "code",
                    "code": "<title>My Blog</title>"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Props"
                },
                {
                    "type": "p",
                    "text": "<title>supports allcommon element props."
                },
                {
                    "type": "list",
                    "items": [
                        "children:<title>accepts only text as a child. This text will become the title of the document. You can also pass your own components as long as they only render text."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Special rendering behavior"
                },
                {
                    "type": "p",
                    "text": "React will always place the DOM element corresponding to the<title>component within the document’s<head>, regardless of where in the React tree it is rendered. The<head>is the only valid place for<title>to exist within the DOM, yet it’s convenient and keeps things composable if a component representing a specific page can render its<title>itself."
                },
                {
                    "type": "p",
                    "text": "There are two exception to this:"
                },
                {
                    "type": "list",
                    "items": [
                        "If<title>is within an<svg>component, then there is no special behavior, because in this context it doesn’t represent the document’s title but rather is anaccessibility annotation for that SVG graphic.",
                        "If the<title>has anitemPropprop, there is no special behavior, because in this case it doesn’t represent the document’s title but rather metadata about a specific part of the page."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Only render a single<title>at a time. If more than one component renders a<title>tag at the same time, React will place all of those titles in the document head. When this happens, the behavior of browsers and search engines is undefined."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Set the document title"
                },
                {
                    "type": "p",
                    "text": "Render the<title>component from any component with text as its children. React will put a<title>DOM node in the document<head>."
                },
                {
                    "type": "code",
                    "code": "importShowRenderedHTMLfrom'./ShowRenderedHTML.js';exportdefaultfunctionContactUsPage(){return(<ShowRenderedHTML><title>My Site: Contact Us</title><h1>Contact Us</h1><p>Email us at support@example.com</p></ShowRenderedHTML>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Use variables in the title"
                },
                {
                    "type": "p",
                    "text": "The children of the<title>component must be a single string of text. (Or a single number or a single object with atoStringmethod.) It might not be obvious, but using JSX curly braces like this:"
                },
                {
                    "type": "code",
                    "code": "<title>Results page{pageNumber}</title>// 🔴 Problem: This is not a single string"
                },
                {
                    "type": "p",
                    "text": "… actually causes the<title>component to get a two-element array as its children (the string\"Results page\"and the value ofpageNumber). This will cause an error. Instead, use string interpolation to pass<title>a single string:"
                },
                {
                    "type": "code",
                    "code": "<title>{`Results page${pageNumber}`}</title>"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/createPortal",
            "title": "createPortal – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "createPortal"
                },
                {
                    "type": "p",
                    "text": "createPortallets you render some children into a different part of the DOM."
                },
                {
                    "type": "code",
                    "code": "<div><SomeComponent/>{createPortal(children,domNode,key?)}</div>"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferencecreatePortal(children, domNode, key?)",
                        "createPortal(children, domNode, key?)",
                        "UsageRendering to a different part of the DOMRendering a modal dialog with a portalRendering React components into non-React server markupRendering React components into non-React DOM nodes",
                        "Rendering to a different part of the DOM",
                        "Rendering a modal dialog with a portal",
                        "Rendering React components into non-React server markup",
                        "Rendering React components into non-React DOM nodes"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "createPortal(children, domNode, key?)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Rendering to a different part of the DOM",
                        "Rendering a modal dialog with a portal",
                        "Rendering React components into non-React server markup",
                        "Rendering React components into non-React DOM nodes"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "createPortal(children, domNode, key?)"
                },
                {
                    "type": "p",
                    "text": "To create a portal, callcreatePortal, passing some JSX, and the DOM node where it should be rendered:"
                },
                {
                    "type": "code",
                    "code": "import{createPortal}from'react-dom';// ...<div><p>This child is placed in the parent div.</p>{createPortal(<p>This child is placed in the document body.</p>,document.body)}</div>"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "p",
                    "text": "A portal only changes the physical placement of the DOM node. In every other way, the JSX you render into a portal acts as a child node of the React component that renders it. For example, the child can access the context provided by the parent tree, and events bubble up from children to parents according to the React tree."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "children: Anything that can be rendered with React, such as a piece of JSX (e.g.<div />or<SomeComponent />), aFragment(<>...</>), a string or a number, or an array of these.",
                        "domNode: Some DOM node, such as those returned bydocument.getElementById(). The node must already exist. Passing a different DOM node during an update will cause the portal content to be recreated.",
                        "optionalkey: A unique string or number to be used as the portal’skey."
                    ]
                },
                {
                    "type": "p",
                    "text": "children: Anything that can be rendered with React, such as a piece of JSX (e.g.<div />or<SomeComponent />), aFragment(<>...</>), a string or a number, or an array of these."
                },
                {
                    "type": "p",
                    "text": "domNode: Some DOM node, such as those returned bydocument.getElementById(). The node must already exist. Passing a different DOM node during an update will cause the portal content to be recreated."
                },
                {
                    "type": "p",
                    "text": "optionalkey: A unique string or number to be used as the portal’skey."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "createPortalreturns a React node that can be included into JSX or returned from a React component. If React encounters it in the render output, it will place the providedchildreninside the provideddomNode."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Events from portals propagate according to the React tree rather than the DOM tree. For example, if you click inside a portal, and the portal is wrapped in<div onClick>, thatonClickhandler will fire. If this causes issues, either stop the event propagation from inside the portal, or move the portal itself up in the React tree."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rendering to a different part of the DOM"
                },
                {
                    "type": "p",
                    "text": "Portalslet your components render some of their children into a different place in the DOM. This lets a part of your component “escape” from whatever containers it may be in. For example, a component can display a modal dialog or a tooltip that appears above and outside of the rest of the page."
                },
                {
                    "type": "p",
                    "text": "To create a portal, render the result ofcreatePortalwithsome JSXand theDOM node where it should go:"
                },
                {
                    "type": "code",
                    "code": "import{createPortal}from'react-dom';functionMyComponent(){return(<divstyle={{border:'2px solid black'}}><p>This child is placed in the parent div.</p>{createPortal(<p>This child is placed in the document body.</p>,document.body)}</div>);}"
                },
                {
                    "type": "p",
                    "text": "React will put the DOM nodes forthe JSX you passedinside of theDOM node you provided."
                },
                {
                    "type": "p",
                    "text": "Without a portal, the second<p>would be placed inside the parent<div>, but the portal “teleported” it into thedocument.body:"
                },
                {
                    "type": "code",
                    "code": "import{createPortal}from'react-dom';exportdefaultfunctionMyComponent(){return(<divstyle={{border:'2px solid black'}}><p>This child is placed in the parent div.</p>{createPortal(<p>This child is placed in the document body.</p>,document.body)}</div>);}"
                },
                {
                    "type": "p",
                    "text": "Notice how the second paragraph visually appears outside the parent<div>with the border. If you inspect the DOM structure with developer tools, you’ll see that the second<p>got placed directly into the<body>:"
                },
                {
                    "type": "code",
                    "code": "<body><divid=\"root\">...<divstyle=\"border:2pxsolidblack\"><p>This child is placed inside the parent div.</p></div>...</div><p>This child is placed in the document body.</p></body>"
                },
                {
                    "type": "p",
                    "text": "A portal only changes the physical placement of the DOM node. In every other way, the JSX you render into a portal acts as a child node of the React component that renders it. For example, the child can access the context provided by the parent tree, and events still bubble up from children to parents according to the React tree."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rendering a modal dialog with a portal"
                },
                {
                    "type": "p",
                    "text": "You can use a portal to create a modal dialog that floats above the rest of the page, even if the component that summons the dialog is inside a container withoverflow: hiddenor other styles that interfere with the dialog."
                },
                {
                    "type": "p",
                    "text": "In this example, the two containers have styles that disrupt the modal dialog, but the one rendered into a portal is unaffected because, in the DOM, the modal is not contained within the parent JSX elements."
                },
                {
                    "type": "code",
                    "code": "importNoPortalExamplefrom'./NoPortalExample';importPortalExamplefrom'./PortalExample';exportdefaultfunctionApp(){return(<><divclassName=\"clipping-container\"><NoPortalExample/></div><divclassName=\"clipping-container\"><PortalExample/></div></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "It’s important to make sure that your app is accessible when using portals. For instance, you may need to manage keyboard focus so that the user can move the focus in and out of the portal in a natural way."
                },
                {
                    "type": "p",
                    "text": "Follow theWAI-ARIA Modal Authoring Practiceswhen creating modals. If you use a community package, ensure that it is accessible and follows these guidelines."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rendering React components into non-React server markup"
                },
                {
                    "type": "p",
                    "text": "Portals can be useful if your React root is only part of a static or server-rendered page that isn’t built with React. For example, if your page is built with a server framework like Rails, you can create areas of interactivity within static areas such as sidebars. Compared with havingmultiple separate React roots,portals let you treat the app as a single React tree with shared state even though its parts render to different parts of the DOM."
                },
                {
                    "type": "code",
                    "code": "import{createPortal}from'react-dom';constsidebarContentEl=document.getElementById('sidebar-content');exportdefaultfunctionApp(){return(<><MainContent/>{createPortal(<SidebarContent/>,sidebarContentEl)}</>);}functionMainContent(){return<p>This part is rendered by React</p>;}functionSidebarContent(){return<p>This part is also rendered by React!</p>;}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rendering React components into non-React DOM nodes"
                },
                {
                    "type": "p",
                    "text": "You can also use a portal to manage the content of a DOM node that’s managed outside of React. For example, suppose you’re integrating with a non-React map widget and you want to render React content inside a popup. To do this, declare apopupContainerstate variable to store the DOM node you’re going to render into:"
                },
                {
                    "type": "code",
                    "code": "const[popupContainer,setPopupContainer]=useState(null);"
                },
                {
                    "type": "p",
                    "text": "When you create the third-party widget, store the DOM node returned by the widget so you can render into it:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{if(mapRef.current===null){constmap=createMapWidget(containerRef.current);mapRef.current=map;constpopupDiv=addPopupToMapWidget(map);setPopupContainer(popupDiv);}},[]);"
                },
                {
                    "type": "p",
                    "text": "This lets you usecreatePortalto render React content intopopupContaineronce it becomes available:"
                },
                {
                    "type": "code",
                    "code": "return(<divstyle={{width:250,height:250}}ref={containerRef}>{popupContainer!==null&&createPortal(<p>Hello from React!</p>,popupContainer)}</div>);"
                },
                {
                    "type": "p",
                    "text": "Here is a complete example you can play with:"
                },
                {
                    "type": "code",
                    "code": "import{useRef,useEffect,useState}from'react';import{createPortal}from'react-dom';import{createMapWidget,addPopupToMapWidget}from'./map-widget.js';exportdefaultfunctionMap(){constcontainerRef=useRef(null);constmapRef=useRef(null);const[popupContainer,setPopupContainer]=useState(null);useEffect(()=>{if(mapRef.current===null){constmap=createMapWidget(containerRef.current);mapRef.current=map;constpopupDiv=addPopupToMapWidget(map);setPopupContainer(popupDiv);}},[]);return(<divstyle={{width:250,height:250}}ref={containerRef}>{popupContainer!==null&&createPortal(<p>Hello from React!</p>,popupContainer)}</div>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/findDOMNode",
            "title": "findDOMNode – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "findDOMNode"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Deprecated"
                },
                {
                    "type": "p",
                    "text": "This API will be removed in a future major version of React.See the alternatives."
                },
                {
                    "type": "p",
                    "text": "findDOMNodefinds the browser DOM node for a Reactclass componentinstance."
                },
                {
                    "type": "code",
                    "code": "constdomNode=findDOMNode(componentInstance)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferencefindDOMNode(componentInstance)",
                        "findDOMNode(componentInstance)",
                        "UsageFinding the root DOM node of a class component",
                        "Finding the root DOM node of a class component",
                        "AlternativesReading component’s own DOM node from a refReading a child component’s DOM node from a forwarded refAdding a wrapper<div>element",
                        "Reading component’s own DOM node from a ref",
                        "Reading a child component’s DOM node from a forwarded ref",
                        "Adding a wrapper<div>element"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "findDOMNode(componentInstance)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Finding the root DOM node of a class component"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Reading component’s own DOM node from a ref",
                        "Reading a child component’s DOM node from a forwarded ref",
                        "Adding a wrapper<div>element"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "findDOMNode(componentInstance)"
                },
                {
                    "type": "p",
                    "text": "CallfindDOMNodeto find the browser DOM node for a given Reactclass componentinstance."
                },
                {
                    "type": "code",
                    "code": "import{findDOMNode}from'react-dom';constdomNode=findDOMNode(componentInstance);"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "componentInstance: An instance of theComponentsubclass. For example,thisinside a class component."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "findDOMNodereturns the first closest browser DOM node within the givencomponentInstance. When a component renders tonull, or rendersfalse,findDOMNodereturnsnull. When a component renders to a string,findDOMNodereturns a text DOM node containing that value."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "A component may return an array or aFragmentwith multiple children. In that casefindDOMNode, will return the DOM node corresponding to the first non-empty child.",
                        "findDOMNodeonly works on mounted components (that is, components that have been placed in the DOM). If you try to call this on a component that has not been mounted yet (like callingfindDOMNode()inrender()on a component that has yet to be created), an exception will be thrown.",
                        "findDOMNodeonly returns the result at the time of your call. If a child component renders a different node later, there is no way for you to be notified of this change.",
                        "findDOMNodeaccepts a class component instance, so it can’t be used with function components."
                    ]
                },
                {
                    "type": "p",
                    "text": "A component may return an array or aFragmentwith multiple children. In that casefindDOMNode, will return the DOM node corresponding to the first non-empty child."
                },
                {
                    "type": "p",
                    "text": "findDOMNodeonly works on mounted components (that is, components that have been placed in the DOM). If you try to call this on a component that has not been mounted yet (like callingfindDOMNode()inrender()on a component that has yet to be created), an exception will be thrown."
                },
                {
                    "type": "p",
                    "text": "findDOMNodeonly returns the result at the time of your call. If a child component renders a different node later, there is no way for you to be notified of this change."
                },
                {
                    "type": "p",
                    "text": "findDOMNodeaccepts a class component instance, so it can’t be used with function components."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Finding the root DOM node of a class component"
                },
                {
                    "type": "p",
                    "text": "CallfindDOMNodewith aclass componentinstance (usually,this) to find the DOM node it has rendered."
                },
                {
                    "type": "code",
                    "code": "classAutoselectingInputextendsComponent{componentDidMount(){constinput=findDOMNode(this);input.select()}render(){return<inputdefaultValue=\"Hello\"/>}}"
                },
                {
                    "type": "p",
                    "text": "Here, theinputvariable will be set to the<input>DOM element. This lets you do something with it. For example, when clicking “Show example” below mounts the input,input.select()selects all text in the input:"
                },
                {
                    "type": "code",
                    "code": "import{Component}from'react';import{findDOMNode}from'react-dom';classAutoselectingInputextendsComponent{componentDidMount(){constinput=findDOMNode(this);input.select()}render(){return<inputdefaultValue=\"Hello\"/>}}exportdefaultAutoselectingInput;"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Alternatives"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Reading component’s own DOM node from a ref"
                },
                {
                    "type": "p",
                    "text": "Code usingfindDOMNodeis fragile because the connection between the JSX node and the code manipulating the corresponding DOM node is not explicit. For example, try wrapping this<input />into a<div>:"
                },
                {
                    "type": "code",
                    "code": "import{Component}from'react';import{findDOMNode}from'react-dom';classAutoselectingInputextendsComponent{componentDidMount(){constinput=findDOMNode(this);input.select()}render(){return<inputdefaultValue=\"Hello\"/>}}exportdefaultAutoselectingInput;"
                },
                {
                    "type": "p",
                    "text": "This will break the code because now,findDOMNode(this)finds the<div>DOM node, but the code expects an<input>DOM node. To avoid these kinds of problems, usecreateRefto manage a specific DOM node."
                },
                {
                    "type": "p",
                    "text": "In this example,findDOMNodeis no longer used. Instead,inputRef = createRef(null)is defined as an instance field on the class. To read the DOM node from it, you can usethis.inputRef.current. To attach it to the JSX, you render<input ref={this.inputRef} />. This connects the code using the DOM node to its JSX:"
                },
                {
                    "type": "code",
                    "code": "import{createRef,Component}from'react';classAutoselectingInputextendsComponent{inputRef=createRef(null);componentDidMount(){constinput=this.inputRef.current;input.select()}render(){return(<inputref={this.inputRef}defaultValue=\"Hello\"/>);}}exportdefaultAutoselectingInput;"
                },
                {
                    "type": "p",
                    "text": "In modern React without class components, the equivalent code would calluseRefinstead:"
                },
                {
                    "type": "code",
                    "code": "import{useRef,useEffect}from'react';exportdefaultfunctionAutoselectingInput(){constinputRef=useRef(null);useEffect(()=>{constinput=inputRef.current;input.select();},[]);return<inputref={inputRef}defaultValue=\"Hello\"/>}"
                },
                {
                    "type": "p",
                    "text": "Read more about manipulating the DOM with refs."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Reading a child component’s DOM node from a forwarded ref"
                },
                {
                    "type": "p",
                    "text": "In this example,findDOMNode(this)finds a DOM node that belongs to another component. TheAutoselectingInputrendersMyInput, which is your own component that renders a browser<input>."
                },
                {
                    "type": "code",
                    "code": "import{Component}from'react';import{findDOMNode}from'react-dom';importMyInputfrom'./MyInput.js';classAutoselectingInputextendsComponent{componentDidMount(){constinput=findDOMNode(this);input.select()}render(){return<MyInput/>;}}exportdefaultAutoselectingInput;"
                },
                {
                    "type": "p",
                    "text": "Notice that callingfindDOMNode(this)insideAutoselectingInputstill gives you the DOM<input>—even though the JSX for this<input>is hidden inside theMyInputcomponent. This seems convenient for the above example, but it leads to fragile code. Imagine that you wanted to editMyInputlater and add a wrapper<div>around it. This would break the code ofAutoselectingInput(which expects to find an<input>)."
                },
                {
                    "type": "p",
                    "text": "To replacefindDOMNodein this example, the two components need to coordinate:"
                },
                {
                    "type": "list",
                    "items": [
                        "AutoSelectingInputshould declare a ref, likein the earlier example, and pass it to<MyInput>.",
                        "MyInputshould be declared withforwardRefto take that ref and forward it down to the<input>node."
                    ]
                },
                {
                    "type": "p",
                    "text": "This version does that, so it no longer needsfindDOMNode:"
                },
                {
                    "type": "code",
                    "code": "import{createRef,Component}from'react';importMyInputfrom'./MyInput.js';classAutoselectingInputextendsComponent{inputRef=createRef(null);componentDidMount(){constinput=this.inputRef.current;input.select()}render(){return(<MyInputref={this.inputRef}/>);}}exportdefaultAutoselectingInput;"
                },
                {
                    "type": "p",
                    "text": "Here is how this code would look like with function components instead of classes:"
                },
                {
                    "type": "code",
                    "code": "import{useRef,useEffect}from'react';importMyInputfrom'./MyInput.js';exportdefaultfunctionAutoselectingInput(){constinputRef=useRef(null);useEffect(()=>{constinput=inputRef.current;input.select();},[]);return<MyInputref={inputRef}defaultValue=\"Hello\"/>}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Adding a wrapper<div>element"
                },
                {
                    "type": "p",
                    "text": "Sometimes a component needs to know the position and size of its children. This makes it tempting to find the children withfindDOMNode(this), and then use DOM methods likegetBoundingClientRectfor measurements."
                },
                {
                    "type": "p",
                    "text": "There is currently no direct equivalent for this use case, which is whyfindDOMNodeis deprecated but is not yet removed completely from React. In the meantime, you can try rendering a wrapper<div>node around the content as a workaround, and getting a ref to that node. However, extra wrappers can break styling."
                },
                {
                    "type": "code",
                    "code": "<divref={someRef}>{children}</div>"
                },
                {
                    "type": "p",
                    "text": "This also applies to focusing and scrolling to arbitrary children."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/flushSync",
            "title": "flushSync – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "flushSync"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "UsingflushSyncis uncommon and can hurt the performance of your app."
                },
                {
                    "type": "p",
                    "text": "flushSynclets you force React to flush any updates inside the provided callback synchronously. This ensures that the DOM is updated immediately."
                },
                {
                    "type": "code",
                    "code": "flushSync(callback)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceflushSync(callback)",
                        "flushSync(callback)",
                        "UsageFlushing updates for third-party integrations",
                        "Flushing updates for third-party integrations"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "flushSync(callback)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Flushing updates for third-party integrations"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "flushSync(callback)"
                },
                {
                    "type": "p",
                    "text": "CallflushSyncto force React to flush any pending work and update the DOM synchronously."
                },
                {
                    "type": "code",
                    "code": "import{flushSync}from'react-dom';flushSync(()=>{setSomething(123);});"
                },
                {
                    "type": "p",
                    "text": "Most of the time,flushSynccan be avoided. UseflushSyncas last resort."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "callback: A function. React will immediately call this callback and flush any updates it contains synchronously. It may also flush any pending updates, or Effects, or updates inside of Effects. If an update suspends as a result of thisflushSynccall, the fallbacks may be re-shown."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "flushSyncreturnsundefined."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "flushSynccan significantly hurt performance. Use sparingly.",
                        "flushSyncmay force pending Suspense boundaries to show theirfallbackstate.",
                        "flushSyncmay run pending Effects and synchronously apply any updates they contain before returning.",
                        "flushSyncmay flush updates outside the callback when necessary to flush the updates inside the callback. For example, if there are pending updates from a click, React may flush those before flushing the updates inside the callback."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Flushing updates for third-party integrations"
                },
                {
                    "type": "p",
                    "text": "When integrating with third-party code such as browser APIs or UI libraries, it may be necessary to force React to flush updates. UseflushSyncto force React to flush anystate updatesinside the callback synchronously:"
                },
                {
                    "type": "code",
                    "code": "flushSync(()=>{setSomething(123);});// By this line, the DOM is updated."
                },
                {
                    "type": "p",
                    "text": "This ensures that, by the time the next line of code runs, React has already updated the DOM."
                },
                {
                    "type": "p",
                    "text": "UsingflushSyncis uncommon, and using it often can significantly hurt the performance of your app.If your app only uses React APIs, and does not integrate with third-party libraries,flushSyncshould be unnecessary."
                },
                {
                    "type": "p",
                    "text": "However, it can be helpful for integrating with third-party code like browser APIs."
                },
                {
                    "type": "p",
                    "text": "Some browser APIs expect results inside of callbacks to be written to the DOM synchronously, by the end of the callback, so the browser can do something with the rendered DOM. In most cases, React handles this for you automatically. But in some cases it may be necessary to force a synchronous update."
                },
                {
                    "type": "p",
                    "text": "For example, the browseronbeforeprintAPI allows you to change the page immediately before the print dialog opens. This is useful for applying custom print styles that allow the document to display better for printing. In the example below, you useflushSyncinside of theonbeforeprintcallback to immediately “flush” the React state to the DOM. Then, by the time the print dialog opens,isPrintingdisplays “yes”:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{flushSync}from'react-dom';exportdefaultfunctionPrintApp(){const[isPrinting,setIsPrinting]=useState(false);useEffect(()=>{functionhandleBeforePrint(){flushSync(()=>{setIsPrinting(true);})}functionhandleAfterPrint(){setIsPrinting(false);}window.addEventListener('beforeprint',handleBeforePrint);window.addEventListener('afterprint',handleAfterPrint);return()=>{window.removeEventListener('beforeprint',handleBeforePrint);window.removeEventListener('afterprint',handleAfterPrint);}},[]);return(<><h1>isPrinting:{isPrinting?'yes':'no'}</h1><buttononClick={()=>window.print()}>Print</button></>);}"
                },
                {
                    "type": "p",
                    "text": "WithoutflushSync, the print dialog will displayisPrintingas “no”. This is because React batches the updates asynchronously and the print dialog is displayed before the state is updated."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "flushSynccan significantly hurt performance, and may unexpectedly force pending Suspense boundaries to show their fallback state."
                },
                {
                    "type": "p",
                    "text": "Most of the time,flushSynccan be avoided, so useflushSyncas a last resort."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/hooks",
            "title": "Built-in React DOM Hooks – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Built-in React DOM Hooks"
                },
                {
                    "type": "p",
                    "text": "Thereact-dompackage contains Hooks that are only supported for web applications (which run in the browser DOM environment). These Hooks are not supported in non-browser environments like iOS, Android, or Windows applications. If you are looking for Hooks that are supported in web browsersand other environmentsseethe React Hooks page. This page lists all the Hooks in thereact-dompackage."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Form Hooks"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "Form Hooks are currently only available in React’s canary and experimental channels. Learn more aboutReact’s release channels here."
                },
                {
                    "type": "p",
                    "text": "Formslet you create interactive controls for submitting information.  To manage forms in your components, use one of these Hooks:"
                },
                {
                    "type": "list",
                    "items": [
                        "useFormStatusallows you to make updates to the UI based on the status of the a form."
                    ]
                },
                {
                    "type": "code",
                    "code": "functionForm({action}){asyncfunctionincrement(n){returnn+1;}const[count,incrementFormAction]=useActionState(increment,0);return(<formaction={action}><buttonformAction={incrementFormAction}>Count:{count}</button><Button/></form>);}functionButton(){const{pending}=useFormStatus();return(<buttondisabled={pending}type=\"submit\">Submit</button>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/hooks/useFormState",
            "title": "useActionState – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "useActionState- This feature is available in the latest Canary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "TheuseActionStateHook is currently only available in React’s Canary and experimental channels. Learn more aboutrelease channels here. In addition, you need to use a framework that supportsReact Server Componentsto get the full benefit ofuseActionState."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "In earlier React Canary versions, this API was part of React DOM and calleduseFormState."
                },
                {
                    "type": "p",
                    "text": "useActionStateis a Hook that allows you to update state based on the result of a form action."
                },
                {
                    "type": "code",
                    "code": "const[state,formAction,isPending]=useActionState(fn,initialState,permalink?);"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceuseActionState(action, initialState, permalink?)",
                        "useActionState(action, initialState, permalink?)",
                        "UsageUsing information returned by a form action",
                        "Using information returned by a form action",
                        "TroubleshootingMy action can no longer read the submitted form data",
                        "My action can no longer read the submitted form data"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "useActionState(action, initialState, permalink?)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Using information returned by a form action"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "My action can no longer read the submitted form data"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useActionState(action, initialState, permalink?)"
                },
                {
                    "type": "p",
                    "text": "CalluseActionStateat the top level of your component to create component state that is updatedwhen a form action is invoked. You passuseActionStatean existing form action function as well as an initial state, and it returns a new action that you use in your form, along with the latest form state and whether the Action is still pending. The latest form state is also passed to the function that you provided."
                },
                {
                    "type": "code",
                    "code": "import{useActionState}from\"react\";asyncfunctionincrement(previousState,formData){returnpreviousState+1;}functionStatefulForm({}){const[state,formAction]=useActionState(increment,0);return(<form>{state}<buttonformAction={formAction}>Increment</button></form>)}"
                },
                {
                    "type": "p",
                    "text": "The form state is the value returned by the action when the form was last submitted. If the form has not yet been submitted, it is the initial state that you pass."
                },
                {
                    "type": "p",
                    "text": "If used with a Server Action,useActionStateallows the server’s response from submitting the form to be shown even before hydration has completed."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "fn: The function to be called when the form is submitted or button pressed. When the function is called, it will receive the previous state of the form (initially theinitialStatethat you pass, subsequently its previous return value) as its initial argument, followed by the arguments that a form action normally receives.",
                        "initialState: The value you want the state to be initially. It can be any serializable value. This argument is ignored after the action is first invoked.",
                        "optionalpermalink: A string containing the unique page URL that this form modifies. For use on pages with dynamic content (eg: feeds) in conjunction with progressive enhancement: iffnis aserver actionand the form is submitted before the JavaScript bundle loads, the browser will navigate to the specified permalink URL, rather than the current page’s URL. Ensure that the same form component is rendered on the destination page (including the same actionfnandpermalink) so that React knows how to pass the state through. Once the form has been hydrated, this parameter has no effect."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "useActionStatereturns an array with the following values:"
                },
                {
                    "type": "list",
                    "items": [
                        "The current state. During the first render, it will match theinitialStateyou have passed. After the action is invoked, it will match the value returned by the action.",
                        "A new action that you can pass as theactionprop to yourformcomponent orformActionprop to anybuttoncomponent within the form.",
                        "TheisPendingflag that tells you whether there is a pending Transition."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "When used with a framework that supports React Server Components,useActionStatelets you make forms interactive before JavaScript has executed on the client. When used without Server Components, it is equivalent to component local state.",
                        "The function passed touseActionStatereceives an extra argument, the previous or initial state, as its first argument. This makes its signature different than if it were used directly as a form action without usinguseActionState."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Using information returned by a form action"
                },
                {
                    "type": "p",
                    "text": "CalluseActionStateat the top level of your component to access the return value of an action from the last time a form was submitted."
                },
                {
                    "type": "code",
                    "code": "import{useActionState}from'react';import{action}from'./actions.js';functionMyComponent(){const[state,formAction]=useActionState(action,null);// ...return(<formaction={formAction}>{/* ... */}</form>);}"
                },
                {
                    "type": "p",
                    "text": "useActionStatereturns an array with the following items:"
                },
                {
                    "type": "list",
                    "items": [
                        "Thecurrent stateof the form, which is initially set to theinitial stateyou provided, and after the form is submitted is set to the return value of theactionyou provided.",
                        "Anew actionthat you pass to<form>as itsactionprop.",
                        "Apending statethat you can utilise whilst your action is processing."
                    ]
                },
                {
                    "type": "p",
                    "text": "When the form is submitted, theactionfunction that you provided will be called. Its return value will become the newcurrent stateof the form."
                },
                {
                    "type": "p",
                    "text": "Theactionthat you provide will also receive a new first argument, namely thecurrent stateof the form. The first time the form is submitted, this will be theinitial stateyou provided, while with subsequent submissions, it will be the return value from the last time the action was called. The rest of the arguments are the same as ifuseActionStatehad not been used."
                },
                {
                    "type": "code",
                    "code": "functionaction(currentState,formData){// ...return'next state';}"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Display information after submitting a form"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of2:Display form errors"
                },
                {
                    "type": "p",
                    "text": "To display messages such as an error message or toast that’s returned by a Server Action, wrap the action in a call touseActionState."
                },
                {
                    "type": "code",
                    "code": "import{useActionState,useState}from\"react\";import{addToCart}from\"./actions.js\";functionAddToCartForm({itemID,itemTitle}){const[message,formAction,isPending]=useActionState(addToCart,null);return(<formaction={formAction}><h2>{itemTitle}</h2><inputtype=\"hidden\"name=\"itemID\"value={itemID}/><buttontype=\"submit\">Add to Cart</button>{isPending?\"Loading...\":message}</form>);}exportdefaultfunctionApp(){return(<><AddToCartFormitemID=\"1\"itemTitle=\"JavaScript: The Definitive Guide\"/><AddToCartFormitemID=\"2\"itemTitle=\"JavaScript: The Good Parts\"/></>)}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My action can no longer read the submitted form data"
                },
                {
                    "type": "p",
                    "text": "When you wrap an action withuseActionState, it gets an extra argumentas its first argument. The submitted form data is therefore itssecondargument instead of its first as it would usually be. The new first argument that gets added is the current state of the form."
                },
                {
                    "type": "code",
                    "code": "functionaction(currentState,formData){// ...}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/hooks/useFormStatus",
            "title": "useFormStatus – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "useFormStatus- This feature is available in the latest Canary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "TheuseFormStatusHook is currently only available in React’s Canary and experimental channels. Learn more aboutReact’s release channels here."
                },
                {
                    "type": "p",
                    "text": "useFormStatusis a Hook that gives you status information of the last form submission."
                },
                {
                    "type": "code",
                    "code": "const{pending,data,method,action}=useFormStatus();"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceuseFormStatus()",
                        "useFormStatus()",
                        "UsageDisplay a pending state during form submissionRead the form data being submitted",
                        "Display a pending state during form submission",
                        "Read the form data being submitted",
                        "Troubleshootingstatus.pendingis nevertrue",
                        "status.pendingis nevertrue"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "useFormStatus()"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Display a pending state during form submission",
                        "Read the form data being submitted"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "status.pendingis nevertrue"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useFormStatus()"
                },
                {
                    "type": "p",
                    "text": "TheuseFormStatusHook provides status information of the last form submission."
                },
                {
                    "type": "code",
                    "code": "import{useFormStatus}from\"react-dom\";importactionfrom'./actions';functionSubmit(){conststatus=useFormStatus();return<buttondisabled={status.pending}>Submit</button>}exportdefaultfunctionApp(){return(<formaction={action}><Submit/></form>);}"
                },
                {
                    "type": "p",
                    "text": "To get status information, theSubmitcomponent must be rendered within a<form>. The Hook returns information like thependingproperty which tells you if the form is actively submitting."
                },
                {
                    "type": "p",
                    "text": "In the above example,Submituses this information to disable<button>presses while the form is submitting."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "p",
                    "text": "useFormStatusdoes not take any parameters."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "Astatusobject with the following properties:"
                },
                {
                    "type": "list",
                    "items": [
                        "pending: A boolean. Iftrue, this means the parent<form>is pending submission. Otherwise,false.",
                        "data: An object implementing theFormData interfacethat contains the data the parent<form>is submitting. If there is no active submission or no parent<form>, it will benull.",
                        "method: A string value of either'get'or'post'. This represents whether the parent<form>is submitting with either aGETorPOSTHTTP method. By default, a<form>will use theGETmethod and can be specified by themethodproperty."
                    ]
                },
                {
                    "type": "p",
                    "text": "pending: A boolean. Iftrue, this means the parent<form>is pending submission. Otherwise,false."
                },
                {
                    "type": "p",
                    "text": "data: An object implementing theFormData interfacethat contains the data the parent<form>is submitting. If there is no active submission or no parent<form>, it will benull."
                },
                {
                    "type": "p",
                    "text": "method: A string value of either'get'or'post'. This represents whether the parent<form>is submitting with either aGETorPOSTHTTP method. By default, a<form>will use theGETmethod and can be specified by themethodproperty."
                },
                {
                    "type": "list",
                    "items": [
                        "action: A reference to the function passed to theactionprop on the parent<form>. If there is no parent<form>, the property isnull. If there is a URI value provided to theactionprop, or noactionprop specified,status.actionwill benull."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "TheuseFormStatusHook must be called from a component that is rendered inside a<form>.",
                        "useFormStatuswill only return status information for a parent<form>. It will not return status information for any<form>rendered in that same component or children components."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Display a pending state during form submission"
                },
                {
                    "type": "p",
                    "text": "To display a pending state while a form is submitting, you can call theuseFormStatusHook in a component rendered in a<form>and read thependingproperty returned."
                },
                {
                    "type": "p",
                    "text": "Here, we use thependingproperty to indicate the form is submitting."
                },
                {
                    "type": "code",
                    "code": "import{useFormStatus}from\"react-dom\";import{submitForm}from\"./actions.js\";functionSubmit(){const{pending}=useFormStatus();return(<buttontype=\"submit\"disabled={pending}>{pending?\"Submitting...\":\"Submit\"}</button>);}functionForm({action}){return(<formaction={action}><Submit/></form>);}exportdefaultfunctionApp(){return<Formaction={submitForm}/>;}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "useFormStatuswill not return status information for a<form>rendered in the same component."
                },
                {
                    "type": "p",
                    "text": "TheuseFormStatusHook only returns status information for a parent<form>and not for any<form>rendered in the same component calling the Hook, or child components."
                },
                {
                    "type": "code",
                    "code": "functionForm(){// 🚩 `pending` will never be true// useFormStatus does not track the form rendered in this componentconst{pending}=useFormStatus();return<formaction={submit}></form>;}"
                },
                {
                    "type": "p",
                    "text": "Instead calluseFormStatusfrom inside a component that is located inside<form>."
                },
                {
                    "type": "code",
                    "code": "functionSubmit(){// ✅ `pending` will be derived from the form that wraps the Submit componentconst{pending}=useFormStatus();return<buttondisabled={pending}>...</button>;}functionForm(){// This is the <form> `useFormStatus` tracksreturn(<formaction={submit}><Submit/></form>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Read the form data being submitted"
                },
                {
                    "type": "p",
                    "text": "You can use thedataproperty of the status information returned fromuseFormStatusto display what data is being submitted by the user."
                },
                {
                    "type": "p",
                    "text": "Here, we have a form where users can request a username. We can useuseFormStatusto display a temporary status message confirming what username they have requested."
                },
                {
                    "type": "code",
                    "code": "import{useState,useMemo,useRef}from'react';import{useFormStatus}from'react-dom';exportdefaultfunctionUsernameForm(){const{pending,data}=useFormStatus();return(<div><h3>Request a Username:</h3><inputtype=\"text\"name=\"username\"disabled={pending}/><buttontype=\"submit\"disabled={pending}>Submit</button><br/><p>{data?`Requesting${data?.get(\"username\")}...`:''}</p></div>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "status.pendingis nevertrue"
                },
                {
                    "type": "p",
                    "text": "useFormStatuswill only return status information for a parent<form>."
                },
                {
                    "type": "p",
                    "text": "If the component that callsuseFormStatusis not nested in a<form>,status.pendingwill always returnfalse. VerifyuseFormStatusis called in a component that is a child of a<form>element."
                },
                {
                    "type": "p",
                    "text": "useFormStatuswill not track the status of a<form>rendered in the same component. SeePitfallfor more details."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/hydrate",
            "title": "hydrate – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "hydrate"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Deprecated"
                },
                {
                    "type": "p",
                    "text": "This API will be removed in a future major version of React."
                },
                {
                    "type": "p",
                    "text": "In React 18,hydratewas replaced byhydrateRoot.Usinghydratein React 18 will warn that your app will behave as if it’s running React 17. Learn morehere."
                },
                {
                    "type": "p",
                    "text": "hydratelets you display React components inside a browser DOM node whose HTML content was previously generated byreact-dom/serverin React 17 and below."
                },
                {
                    "type": "code",
                    "code": "hydrate(reactNode,domNode,callback?)"
                },
                {
                    "type": "list",
                    "items": [
                        "Referencehydrate(reactNode, domNode, callback?)",
                        "hydrate(reactNode, domNode, callback?)",
                        "UsageHydrating server-rendered HTMLSuppressing unavoidable hydration mismatch errorsHandling different client and server content",
                        "Hydrating server-rendered HTML",
                        "Suppressing unavoidable hydration mismatch errors",
                        "Handling different client and server content"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "hydrate(reactNode, domNode, callback?)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Hydrating server-rendered HTML",
                        "Suppressing unavoidable hydration mismatch errors",
                        "Handling different client and server content"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "hydrate(reactNode, domNode, callback?)"
                },
                {
                    "type": "p",
                    "text": "Callhydratein React 17 and below to “attach” React to existing HTML that was already rendered by React in a server environment."
                },
                {
                    "type": "code",
                    "code": "import{hydrate}from'react-dom';hydrate(reactNode,domNode);"
                },
                {
                    "type": "p",
                    "text": "React will attach to the HTML that exists inside thedomNode, and take over managing the DOM inside it. An app fully built with React will usually only have onehydratecall with its root component."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "reactNode: The “React node” used to render the existing HTML. This will usually be a piece of JSX like<App />which was rendered with aReactDOM Servermethod such asrenderToString(<App />)in React 17.",
                        "domNode: ADOM elementthat was rendered as the root element on the server.",
                        "optional:callback: A function. If passed, React will call it after your component is hydrated."
                    ]
                },
                {
                    "type": "p",
                    "text": "reactNode: The “React node” used to render the existing HTML. This will usually be a piece of JSX like<App />which was rendered with aReactDOM Servermethod such asrenderToString(<App />)in React 17."
                },
                {
                    "type": "p",
                    "text": "domNode: ADOM elementthat was rendered as the root element on the server."
                },
                {
                    "type": "p",
                    "text": "optional:callback: A function. If passed, React will call it after your component is hydrated."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "hydratereturns null."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "hydrateexpects the rendered content to be identical with the server-rendered content. React can patch up differences in text content, but you should treat mismatches as bugs and fix them.",
                        "In development mode, React warns about mismatches during hydration. There are no guarantees that attribute differences will be patched up in case of mismatches. This is important for performance reasons because in most apps, mismatches are rare, and so validating all markup would be prohibitively expensive.",
                        "You’ll likely have only onehydratecall in your app. If you use a framework, it might do this call for you.",
                        "If your app is client-rendered with no HTML rendered already, usinghydrate()is not supported. Userender()(for React 17 and below) orcreateRoot()(for React 18+) instead."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "p",
                    "text": "Callhydrateto attach aReact componentinto a server-renderedbrowser DOM node."
                },
                {
                    "type": "code",
                    "code": "import{hydrate}from'react-dom';hydrate(<App />,document.getElementById('root'));"
                },
                {
                    "type": "p",
                    "text": "Usinghydrate()to render a client-only app (an app without server-rendered HTML) is not supported. Userender()(in React 17 and below) orcreateRoot()(in React 18+) instead."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Hydrating server-rendered HTML"
                },
                {
                    "type": "p",
                    "text": "In React, “hydration” is how React “attaches” to existing HTML that was already rendered by React in a server environment. During hydration, React will attempt to attach event listeners to the existing markup and take over rendering the app on the client."
                },
                {
                    "type": "p",
                    "text": "In apps fully built with React,you will usually only hydrate one “root”, once at startup for your entire app."
                },
                {
                    "type": "code",
                    "code": "import'./styles.css';import{hydrate}from'react-dom';importAppfrom'./App.js';hydrate(<App/>,document.getElementById('root'));"
                },
                {
                    "type": "p",
                    "text": "Usually you shouldn’t need to callhydrateagain or to call it in more places. From this point on, React will be managing the DOM of your application. To update the UI, your components willuse state."
                },
                {
                    "type": "p",
                    "text": "For more information on hydration, see the docs forhydrateRoot."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Suppressing unavoidable hydration mismatch errors"
                },
                {
                    "type": "p",
                    "text": "If a single element’s attribute or text content is unavoidably different between the server and the client (for example, a timestamp), you may silence the hydration mismatch warning."
                },
                {
                    "type": "p",
                    "text": "To silence hydration warnings on an element, addsuppressHydrationWarning={true}:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionApp(){return(<h1suppressHydrationWarning={true}>Current Date:{newDate().toLocaleDateString()}</h1>);}"
                },
                {
                    "type": "p",
                    "text": "This only works one level deep, and is intended to be an escape hatch. Don’t overuse it. Unless it’s text content, React still won’t attempt to patch it up, so it may remain inconsistent until future updates."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Handling different client and server content"
                },
                {
                    "type": "p",
                    "text": "If you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read astate variablelikeisClient, which you can set totruein anEffect:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from\"react\";exportdefaultfunctionApp(){const[isClient,setIsClient]=useState(false);useEffect(()=>{setIsClient(true);},[]);return(<h1>{isClient?'Is Client':'Is Server'}</h1>);}"
                },
                {
                    "type": "p",
                    "text": "This way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "This approach makes hydration slower because your components have to render twice. Be mindful of the user experience on slow connections. The JavaScript code may load significantly later than the initial HTML render, so rendering a different UI immediately after hydration may feel jarring to the user."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/preconnect",
            "title": "preconnect – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "preconnect- This feature is available in the latest Canary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "Thepreconnectfunction is currently only available in React’s Canary and experimental channels. Learn more aboutReact’s release channels here."
                },
                {
                    "type": "p",
                    "text": "preconnectlets you eagerly connect to a server that you expect to load resources from."
                },
                {
                    "type": "code",
                    "code": "preconnect(\"https://example.com\");"
                },
                {
                    "type": "list",
                    "items": [
                        "Referencepreconnect(href)",
                        "preconnect(href)",
                        "UsagePreconnecting when renderingPreconnecting in an event handler",
                        "Preconnecting when rendering",
                        "Preconnecting in an event handler"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "preconnect(href)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Preconnecting when rendering",
                        "Preconnecting in an event handler"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "preconnect(href)"
                },
                {
                    "type": "p",
                    "text": "To preconnect to a host, call thepreconnectfunction fromreact-dom."
                },
                {
                    "type": "code",
                    "code": "import{preconnect}from'react-dom';functionAppRoot(){preconnect(\"https://example.com\");// ...}"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "p",
                    "text": "Thepreconnectfunction provides the browser with a hint that it should open a connection to the given server. If the browser chooses to do so, this can speed up the loading of resources from that server."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "href: a string. The URL of the server you want to connect to."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "preconnectreturns nothing."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Multiple calls topreconnectwith the same server have the same effect as a single call.",
                        "In the browser, you can callpreconnectin any situation: while rendering a component, in an Effect, in an event handler, and so on.",
                        "In server-side rendering or when rendering Server Components,preconnectonly has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.",
                        "If you know the specific resources you’ll need, you can callother functionsinstead that will start loading the resources right away.",
                        "There is no benefit to preconnecting to the same server the webpage itself is hosted from because it’s already been connected to by the time the hint would be given."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Preconnecting when rendering"
                },
                {
                    "type": "p",
                    "text": "Callpreconnectwhen rendering a component if you know that its children will load external resources from that host."
                },
                {
                    "type": "code",
                    "code": "import{preconnect}from'react-dom';functionAppRoot(){preconnect(\"https://example.com\");return...;}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Preconnecting in an event handler"
                },
                {
                    "type": "p",
                    "text": "Callpreconnectin an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state."
                },
                {
                    "type": "code",
                    "code": "import{preconnect}from'react-dom';functionCallToAction(){constonClick=()=>{preconnect('http://example.com');startWizard();}return(<buttononClick={onClick}>Start Wizard</button>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/prefetchDNS",
            "title": "prefetchDNS – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "prefetchDNS- This feature is available in the latest Canary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "TheprefetchDNSfunction is currently only available in React’s Canary and experimental channels. Learn more aboutReact’s release channels here."
                },
                {
                    "type": "p",
                    "text": "prefetchDNSlets you eagerly look up the IP of a server that you expect to load resources from."
                },
                {
                    "type": "code",
                    "code": "prefetchDNS(\"https://example.com\");"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceprefetchDNS(href)",
                        "prefetchDNS(href)",
                        "UsagePrefetching DNS when renderingPrefetching DNS in an event handler",
                        "Prefetching DNS when rendering",
                        "Prefetching DNS in an event handler"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "prefetchDNS(href)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Prefetching DNS when rendering",
                        "Prefetching DNS in an event handler"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "prefetchDNS(href)"
                },
                {
                    "type": "p",
                    "text": "To look up a host, call theprefetchDNSfunction fromreact-dom."
                },
                {
                    "type": "code",
                    "code": "import{prefetchDNS}from'react-dom';functionAppRoot(){prefetchDNS(\"https://example.com\");// ...}"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "p",
                    "text": "The prefetchDNS function provides the browser with a hint that it should look up the IP address of a given server. If the browser chooses to do so, this can speed up the loading of resources from that server."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "href: a string. The URL of the server you want to connect to."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "prefetchDNSreturns nothing."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Multiple calls toprefetchDNSwith the same server have the same effect as a single call.",
                        "In the browser, you can callprefetchDNSin any situation: while rendering a component, in an Effect, in an event handler, and so on.",
                        "In server-side rendering or when rendering Server Components,prefetchDNSonly has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.",
                        "If you know the specific resources you’ll need, you can callother functionsinstead that will start loading the resources right away.",
                        "There is no benefit to prefetching the same server the webpage itself is hosted from because it’s already been looked up by the time the hint would be given.",
                        "Compared withpreconnect,prefetchDNSmay be better if you are speculatively connecting to a large number of domains, in which case the overhead of preconnections might outweigh the benefit."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Prefetching DNS when rendering"
                },
                {
                    "type": "p",
                    "text": "CallprefetchDNSwhen rendering a component if you know that its children will load external resources from that host."
                },
                {
                    "type": "code",
                    "code": "import{prefetchDNS}from'react-dom';functionAppRoot(){prefetchDNS(\"https://example.com\");return...;}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Prefetching DNS in an event handler"
                },
                {
                    "type": "p",
                    "text": "CallprefetchDNSin an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state."
                },
                {
                    "type": "code",
                    "code": "import{prefetchDNS}from'react-dom';functionCallToAction(){constonClick=()=>{prefetchDNS('http://example.com');startWizard();}return(<buttononClick={onClick}>Start Wizard</button>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/preinit",
            "title": "preinit – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "preinit- This feature is available in the latest Canary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "Thepreinitfunction is currently only available in React’s Canary and experimental channels. Learn more aboutReact’s release channels here."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "React-based frameworksfrequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework’s documentation for details."
                },
                {
                    "type": "p",
                    "text": "preinitlets you eagerly fetch and evaluate a stylesheet or external script."
                },
                {
                    "type": "code",
                    "code": "preinit(\"https://example.com/script.js\",{as:\"script\"});"
                },
                {
                    "type": "list",
                    "items": [
                        "Referencepreinit(href, options)",
                        "preinit(href, options)",
                        "UsagePreiniting when renderingPreiniting in an event handler",
                        "Preiniting when rendering",
                        "Preiniting in an event handler"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "preinit(href, options)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Preiniting when rendering",
                        "Preiniting in an event handler"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "preinit(href, options)"
                },
                {
                    "type": "p",
                    "text": "To preinit a script or stylesheet, call thepreinitfunction fromreact-dom."
                },
                {
                    "type": "code",
                    "code": "import{preinit}from'react-dom';functionAppRoot(){preinit(\"https://example.com/script.js\",{as:\"script\"});// ...}"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "p",
                    "text": "Thepreinitfunction provides the browser with a hint that it should start downloading and executing the given resource, which can save time. Scripts that youpreinitare executed when they finish downloading. Stylesheets that you preinit are inserted into the document, which causes them to go into effect right away."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "href: a string. The URL of the resource you want to download and execute.",
                        "options: an object. It contains the following properties:as: a required string. The type of resource. Its possible values arescriptandstyle.precedence: a string. Required with stylesheets. Says where to insert the stylesheet relative to others. Stylesheets with higher precedence can override those with lower precedence. The possible values arereset,low,medium,high.crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials. It is required whenasis set to\"fetch\".integrity: a string. A cryptographic hash of the resource, toverify its authenticity.nonce: a string. A cryptographicnonce to allow the resourcewhen using a strict Content Security Policy.fetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values areauto(the default),high, andlow.",
                        "as: a required string. The type of resource. Its possible values arescriptandstyle.",
                        "precedence: a string. Required with stylesheets. Says where to insert the stylesheet relative to others. Stylesheets with higher precedence can override those with lower precedence. The possible values arereset,low,medium,high.",
                        "crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials. It is required whenasis set to\"fetch\".",
                        "integrity: a string. A cryptographic hash of the resource, toverify its authenticity.",
                        "nonce: a string. A cryptographicnonce to allow the resourcewhen using a strict Content Security Policy.",
                        "fetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values areauto(the default),high, andlow."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "as: a required string. The type of resource. Its possible values arescriptandstyle.",
                        "precedence: a string. Required with stylesheets. Says where to insert the stylesheet relative to others. Stylesheets with higher precedence can override those with lower precedence. The possible values arereset,low,medium,high.",
                        "crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials. It is required whenasis set to\"fetch\".",
                        "integrity: a string. A cryptographic hash of the resource, toverify its authenticity.",
                        "nonce: a string. A cryptographicnonce to allow the resourcewhen using a strict Content Security Policy.",
                        "fetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values areauto(the default),high, andlow."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "preinitreturns nothing."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Multiple calls topreinitwith the samehrefhave the same effect as a single call.",
                        "In the browser, you can callpreinitin any situation: while rendering a component, in an Effect, in an event handler, and so on.",
                        "In server-side rendering or when rendering Server Components,preinitonly has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Preiniting when rendering"
                },
                {
                    "type": "p",
                    "text": "Callpreinitwhen rendering a component if you know that it or its children will use a specific resource, and you’re OK with the resource being evaluated and thereby taking effect immediately upon being downloaded."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Examples of preiniting"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of2:Preiniting an external script"
                },
                {
                    "type": "code",
                    "code": "import{preinit}from'react-dom';functionAppRoot(){preinit(\"https://example.com/script.js\",{as:\"script\"});return...;}"
                },
                {
                    "type": "p",
                    "text": "If you want the browser to download the script but not to execute it right away, usepreloadinstead. If you want to load an ESM module, usepreinitModule."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Preiniting in an event handler"
                },
                {
                    "type": "p",
                    "text": "Callpreinitin an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state."
                },
                {
                    "type": "code",
                    "code": "import{preinit}from'react-dom';functionCallToAction(){constonClick=()=>{preinit(\"https://example.com/wizardStyles.css\",{as:\"style\"});startWizard();}return(<buttononClick={onClick}>Start Wizard</button>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/preinitModule",
            "title": "preinitModule – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "preinitModule- This feature is available in the latest Canary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "ThepreinitModulefunction is currently only available in React’s Canary and experimental channels. Learn more aboutReact’s release channels here."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "React-based frameworksfrequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework’s documentation for details."
                },
                {
                    "type": "p",
                    "text": "preinitModulelets you eagerly fetch and evaluate an ESM module."
                },
                {
                    "type": "code",
                    "code": "preinitModule(\"https://example.com/module.js\",{as:\"script\"});"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferencepreinitModule(href, options)",
                        "preinitModule(href, options)",
                        "UsagePreloading when renderingPreloading in an event handler",
                        "Preloading when rendering",
                        "Preloading in an event handler"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "preinitModule(href, options)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Preloading when rendering",
                        "Preloading in an event handler"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "preinitModule(href, options)"
                },
                {
                    "type": "p",
                    "text": "To preinit an ESM module, call thepreinitModulefunction fromreact-dom."
                },
                {
                    "type": "code",
                    "code": "import{preinitModule}from'react-dom';functionAppRoot(){preinitModule(\"https://example.com/module.js\",{as:\"script\"});// ...}"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "p",
                    "text": "ThepreinitModulefunction provides the browser with a hint that it should start downloading and executing the given module, which can save time. Modules that youpreinitare executed when they finish downloading."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "href: a string. The URL of the module you want to download and execute.",
                        "options: an object. It contains the following properties:as: a required string. It must be'script'.crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials.integrity: a string. A cryptographic hash of the module, toverify its authenticity.nonce: a string. A cryptographicnonce to allow the modulewhen using a strict Content Security Policy.",
                        "as: a required string. It must be'script'.",
                        "crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials.",
                        "integrity: a string. A cryptographic hash of the module, toverify its authenticity.",
                        "nonce: a string. A cryptographicnonce to allow the modulewhen using a strict Content Security Policy."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "as: a required string. It must be'script'.",
                        "crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials.",
                        "integrity: a string. A cryptographic hash of the module, toverify its authenticity.",
                        "nonce: a string. A cryptographicnonce to allow the modulewhen using a strict Content Security Policy."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "preinitModulereturns nothing."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Multiple calls topreinitModulewith the samehrefhave the same effect as a single call.",
                        "In the browser, you can callpreinitModulein any situation: while rendering a component, in an Effect, in an event handler, and so on.",
                        "In server-side rendering or when rendering Server Components,preinitModuleonly has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Preloading when rendering"
                },
                {
                    "type": "p",
                    "text": "CallpreinitModulewhen rendering a component if you know that it or its children will use a specific module and you’re OK with the module being evaluated and thereby taking effect immediately upon being downloaded."
                },
                {
                    "type": "code",
                    "code": "import{preinitModule}from'react-dom';functionAppRoot(){preinitModule(\"https://example.com/module.js\",{as:\"script\"});return...;}"
                },
                {
                    "type": "p",
                    "text": "If you want the browser to download the module but not to execute it right away, usepreloadModuleinstead. If you want to preinit a script that isn’t an ESM module, usepreinit."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Preloading in an event handler"
                },
                {
                    "type": "p",
                    "text": "CallpreinitModulein an event handler before transitioning to a page or state where the module will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state."
                },
                {
                    "type": "code",
                    "code": "import{preinitModule}from'react-dom';functionCallToAction(){constonClick=()=>{preinitModule(\"https://example.com/module.js\",{as:\"script\"});startWizard();}return(<buttononClick={onClick}>Start Wizard</button>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/preload",
            "title": "preload – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "preload- This feature is available in the latest Canary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "Thepreloadfunction is currently only available in React’s Canary and experimental channels. Learn more aboutReact’s release channels here."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "React-based frameworksfrequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework’s documentation for details."
                },
                {
                    "type": "p",
                    "text": "preloadlets you eagerly fetch a resource such as a stylesheet, font, or external script that you expect to use."
                },
                {
                    "type": "code",
                    "code": "preload(\"https://example.com/font.woff2\",{as:\"font\"});"
                },
                {
                    "type": "list",
                    "items": [
                        "Referencepreload(href, options)",
                        "preload(href, options)",
                        "UsagePreloading when renderingPreloading in an event handler",
                        "Preloading when rendering",
                        "Preloading in an event handler"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "preload(href, options)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Preloading when rendering",
                        "Preloading in an event handler"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "preload(href, options)"
                },
                {
                    "type": "p",
                    "text": "To preload a resource, call thepreloadfunction fromreact-dom."
                },
                {
                    "type": "code",
                    "code": "import{preload}from'react-dom';functionAppRoot(){preload(\"https://example.com/font.woff2\",{as:\"font\"});// ...}"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "p",
                    "text": "Thepreloadfunction provides the browser with a hint that it should start downloading the given resource, which can save time."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "href: a string. The URL of the resource you want to download.",
                        "options: an object. It contains the following properties:as: a required string. The type of resource. Itspossible valuesareaudio,document,embed,fetch,font,image,object,script,style,track,video,worker.crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials. It is required whenasis set to\"fetch\".referrerPolicy: a string. TheReferrer headerto send when fetching. Its possible values areno-referrer-when-downgrade(the default),no-referrer,origin,origin-when-cross-origin, andunsafe-url.integrity: a string. A cryptographic hash of the resource, toverify its authenticity.type: a string. The MIME type of the resource.nonce: a string. A cryptographicnonce to allow the resourcewhen using a strict Content Security Policy.fetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values areauto(the default),high, andlow.imageSrcSet: a string. For use only withas: \"image\". Specifies thesource set of the image.imageSizes: a string. For use only withas: \"image\". Specifies thesizes of the image.",
                        "as: a required string. The type of resource. Itspossible valuesareaudio,document,embed,fetch,font,image,object,script,style,track,video,worker.",
                        "crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials. It is required whenasis set to\"fetch\".",
                        "referrerPolicy: a string. TheReferrer headerto send when fetching. Its possible values areno-referrer-when-downgrade(the default),no-referrer,origin,origin-when-cross-origin, andunsafe-url.",
                        "integrity: a string. A cryptographic hash of the resource, toverify its authenticity.",
                        "type: a string. The MIME type of the resource.",
                        "nonce: a string. A cryptographicnonce to allow the resourcewhen using a strict Content Security Policy.",
                        "fetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values areauto(the default),high, andlow.",
                        "imageSrcSet: a string. For use only withas: \"image\". Specifies thesource set of the image.",
                        "imageSizes: a string. For use only withas: \"image\". Specifies thesizes of the image."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "as: a required string. The type of resource. Itspossible valuesareaudio,document,embed,fetch,font,image,object,script,style,track,video,worker.",
                        "crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials. It is required whenasis set to\"fetch\".",
                        "referrerPolicy: a string. TheReferrer headerto send when fetching. Its possible values areno-referrer-when-downgrade(the default),no-referrer,origin,origin-when-cross-origin, andunsafe-url.",
                        "integrity: a string. A cryptographic hash of the resource, toverify its authenticity.",
                        "type: a string. The MIME type of the resource.",
                        "nonce: a string. A cryptographicnonce to allow the resourcewhen using a strict Content Security Policy.",
                        "fetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values areauto(the default),high, andlow.",
                        "imageSrcSet: a string. For use only withas: \"image\". Specifies thesource set of the image.",
                        "imageSizes: a string. For use only withas: \"image\". Specifies thesizes of the image."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "preloadreturns nothing."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Multiple equivalent calls topreloadhave the same effect as a single call. Calls topreloadare considered equivalent according to the following rules:Two calls are equivalent if they have the samehref, except:Ifasis set toimage, two calls are equivalent if they have the samehref,imageSrcSet, andimageSizes.",
                        "Two calls are equivalent if they have the samehref, except:",
                        "Ifasis set toimage, two calls are equivalent if they have the samehref,imageSrcSet, andimageSizes.",
                        "In the browser, you can callpreloadin any situation: while rendering a component, in an Effect, in an event handler, and so on.",
                        "In server-side rendering or when rendering Server Components,preloadonly has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Two calls are equivalent if they have the samehref, except:",
                        "Ifasis set toimage, two calls are equivalent if they have the samehref,imageSrcSet, andimageSizes."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Preloading when rendering"
                },
                {
                    "type": "p",
                    "text": "Callpreloadwhen rendering a component if you know that it or its children will use a specific resource."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Examples of preloading"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of4:Preloading an external script"
                },
                {
                    "type": "code",
                    "code": "import{preload}from'react-dom';functionAppRoot(){preload(\"https://example.com/script.js\",{as:\"script\"});return...;}"
                },
                {
                    "type": "p",
                    "text": "If you want the browser to start executing the script immediately (rather than just downloading it), usepreinitinstead. If you want to load an ESM module, usepreloadModule."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Preloading in an event handler"
                },
                {
                    "type": "p",
                    "text": "Callpreloadin an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state."
                },
                {
                    "type": "code",
                    "code": "import{preload}from'react-dom';functionCallToAction(){constonClick=()=>{preload(\"https://example.com/wizardStyles.css\",{as:\"style\"});startWizard();}return(<buttononClick={onClick}>Start Wizard</button>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/preloadModule",
            "title": "preloadModule – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "preloadModule- This feature is available in the latest Canary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "ThepreloadModulefunction is currently only available in React’s Canary and experimental channels. Learn more aboutReact’s release channels here."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "React-based frameworksfrequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework’s documentation for details."
                },
                {
                    "type": "p",
                    "text": "preloadModulelets you eagerly fetch an ESM module that you expect to use."
                },
                {
                    "type": "code",
                    "code": "preloadModule(\"https://example.com/module.js\",{as:\"script\"});"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferencepreloadModule(href, options)",
                        "preloadModule(href, options)",
                        "UsagePreloading when renderingPreloading in an event handler",
                        "Preloading when rendering",
                        "Preloading in an event handler"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "preloadModule(href, options)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Preloading when rendering",
                        "Preloading in an event handler"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "preloadModule(href, options)"
                },
                {
                    "type": "p",
                    "text": "To preload an ESM module, call thepreloadModulefunction fromreact-dom."
                },
                {
                    "type": "code",
                    "code": "import{preloadModule}from'react-dom';functionAppRoot(){preloadModule(\"https://example.com/module.js\",{as:\"script\"});// ...}"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "p",
                    "text": "ThepreloadModulefunction provides the browser with a hint that it should start downloading the given module, which can save time."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "href: a string. The URL of the module you want to download.",
                        "options: an object. It contains the following properties:as: a required string. It must be'script'.crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials.integrity: a string. A cryptographic hash of the module, toverify its authenticity.nonce: a string. A cryptographicnonce to allow the modulewhen using a strict Content Security Policy.",
                        "as: a required string. It must be'script'.",
                        "crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials.",
                        "integrity: a string. A cryptographic hash of the module, toverify its authenticity.",
                        "nonce: a string. A cryptographicnonce to allow the modulewhen using a strict Content Security Policy."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "as: a required string. It must be'script'.",
                        "crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials.",
                        "integrity: a string. A cryptographic hash of the module, toverify its authenticity.",
                        "nonce: a string. A cryptographicnonce to allow the modulewhen using a strict Content Security Policy."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "preloadModulereturns nothing."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Multiple calls topreloadModulewith the samehrefhave the same effect as a single call.",
                        "In the browser, you can callpreloadModulein any situation: while rendering a component, in an Effect, in an event handler, and so on.",
                        "In server-side rendering or when rendering Server Components,preloadModuleonly has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Preloading when rendering"
                },
                {
                    "type": "p",
                    "text": "CallpreloadModulewhen rendering a component if you know that it or its children will use a specific module."
                },
                {
                    "type": "code",
                    "code": "import{preloadModule}from'react-dom';functionAppRoot(){preloadModule(\"https://example.com/module.js\",{as:\"script\"});return...;}"
                },
                {
                    "type": "p",
                    "text": "If you want the browser to start executing the module immediately (rather than just downloading it), usepreinitModuleinstead. If you want to load a script that isn’t an ESM module, usepreload."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Preloading in an event handler"
                },
                {
                    "type": "p",
                    "text": "CallpreloadModulein an event handler before transitioning to a page or state where the module will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state."
                },
                {
                    "type": "code",
                    "code": "import{preloadModule}from'react-dom';functionCallToAction(){constonClick=()=>{preloadModule(\"https://example.com/module.js\",{as:\"script\"});startWizard();}return(<buttononClick={onClick}>Start Wizard</button>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/render",
            "title": "render – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "render"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Deprecated"
                },
                {
                    "type": "p",
                    "text": "This API will be removed in a future major version of React."
                },
                {
                    "type": "p",
                    "text": "In React 18,renderwas replaced bycreateRoot.Usingrenderin React 18 will warn that your app will behave as if it’s running React 17. Learn morehere."
                },
                {
                    "type": "p",
                    "text": "renderrenders a piece ofJSX(“React node”) into a browser DOM node."
                },
                {
                    "type": "code",
                    "code": "render(reactNode,domNode,callback?)"
                },
                {
                    "type": "list",
                    "items": [
                        "Referencerender(reactNode, domNode, callback?)",
                        "render(reactNode, domNode, callback?)",
                        "UsageRendering the root componentRendering multiple rootsUpdating the rendered tree",
                        "Rendering the root component",
                        "Rendering multiple roots",
                        "Updating the rendered tree"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "render(reactNode, domNode, callback?)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Rendering the root component",
                        "Rendering multiple roots",
                        "Updating the rendered tree"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "render(reactNode, domNode, callback?)"
                },
                {
                    "type": "p",
                    "text": "Callrenderto display a React component inside a browser DOM element."
                },
                {
                    "type": "code",
                    "code": "import{render}from'react-dom';constdomNode=document.getElementById('root');render(<App/>,domNode);"
                },
                {
                    "type": "p",
                    "text": "React will display<App />in thedomNode, and take over managing the DOM inside it."
                },
                {
                    "type": "p",
                    "text": "An app fully built with React will usually only have onerendercall with its root component.  A page that uses “sprinkles” of React for parts of the page may have as manyrendercalls as needed."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "reactNode: AReact nodethat you want to display. This will usually be a piece of JSX like<App />, but you can also pass a React element constructed withcreateElement(), a string, a number,null, orundefined.",
                        "domNode: ADOM element.React will display thereactNodeyou pass inside this DOM element. From this moment, React will manage the DOM inside thedomNodeand update it when your React tree changes.",
                        "optionalcallback: A function. If passed, React will call it after your component is placed into the DOM."
                    ]
                },
                {
                    "type": "p",
                    "text": "reactNode: AReact nodethat you want to display. This will usually be a piece of JSX like<App />, but you can also pass a React element constructed withcreateElement(), a string, a number,null, orundefined."
                },
                {
                    "type": "p",
                    "text": "domNode: ADOM element.React will display thereactNodeyou pass inside this DOM element. From this moment, React will manage the DOM inside thedomNodeand update it when your React tree changes."
                },
                {
                    "type": "p",
                    "text": "optionalcallback: A function. If passed, React will call it after your component is placed into the DOM."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "renderusually returnsnull. However, if thereactNodeyou pass is aclass component, then it will return an instance of that component."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "In React 18,renderwas replaced bycreateRoot.Please usecreateRootfor React 18 and beyond.",
                        "The first time you callrender, React will clear all the existing HTML content inside thedomNodebefore rendering the React component into it. If yourdomNodecontains HTML generated by React on the server or during the build, usehydrate()instead, which attaches the event handlers to the existing HTML.",
                        "If you callrenderon the samedomNodemore than once, React will update the DOM as necessary to reflect the latest JSX you passed. React will decide which parts of the DOM can be reused and which need to be recreated by“matching it up”with the previously rendered tree. Callingrenderon the samedomNodeagain is similar to calling thesetfunctionon the root component: React avoids unnecessary DOM updates.",
                        "If your app is fully built with React, you’ll likely have only onerendercall in your app. (If you use a framework, it might do this call for you.) When you want to render a piece of JSX in a different part of the DOM tree that isn’t a child of your component (for example, a modal or a tooltip), usecreatePortalinstead ofrender."
                    ]
                },
                {
                    "type": "p",
                    "text": "In React 18,renderwas replaced bycreateRoot.Please usecreateRootfor React 18 and beyond."
                },
                {
                    "type": "p",
                    "text": "The first time you callrender, React will clear all the existing HTML content inside thedomNodebefore rendering the React component into it. If yourdomNodecontains HTML generated by React on the server or during the build, usehydrate()instead, which attaches the event handlers to the existing HTML."
                },
                {
                    "type": "p",
                    "text": "If you callrenderon the samedomNodemore than once, React will update the DOM as necessary to reflect the latest JSX you passed. React will decide which parts of the DOM can be reused and which need to be recreated by“matching it up”with the previously rendered tree. Callingrenderon the samedomNodeagain is similar to calling thesetfunctionon the root component: React avoids unnecessary DOM updates."
                },
                {
                    "type": "p",
                    "text": "If your app is fully built with React, you’ll likely have only onerendercall in your app. (If you use a framework, it might do this call for you.) When you want to render a piece of JSX in a different part of the DOM tree that isn’t a child of your component (for example, a modal or a tooltip), usecreatePortalinstead ofrender."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "p",
                    "text": "Callrenderto display aReact componentinside abrowser DOM node."
                },
                {
                    "type": "code",
                    "code": "import{render}from'react-dom';importAppfrom'./App.js';render(<App />,document.getElementById('root'));"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rendering the root component"
                },
                {
                    "type": "p",
                    "text": "In apps fully built with React,you will usually only do this once at startup—to render the “root” component."
                },
                {
                    "type": "code",
                    "code": "import'./styles.css';import{render}from'react-dom';importAppfrom'./App.js';render(<App/>,document.getElementById('root'));"
                },
                {
                    "type": "p",
                    "text": "Usually you shouldn’t need to callrenderagain or to call it in more places. From this point on, React will be managing the DOM of your application. To update the UI, your components willuse state."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rendering multiple roots"
                },
                {
                    "type": "p",
                    "text": "If your pageisn’t fully built with React, callrenderfor each top-level piece of UI managed by React."
                },
                {
                    "type": "code",
                    "code": "import'./styles.css';import{render}from'react-dom';import{Comments,Navigation}from'./Components.js';render(<Navigation/>,document.getElementById('navigation'));render(<Comments/>,document.getElementById('comments'));"
                },
                {
                    "type": "p",
                    "text": "You can destroy the rendered trees withunmountComponentAtNode()."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Updating the rendered tree"
                },
                {
                    "type": "p",
                    "text": "You can callrendermore than once on the same DOM node. As long as the component tree structure matches up with what was previously rendered, React willpreserve the state.Notice how you can type in the input, which means that the updates from repeatedrendercalls every second are not destructive:"
                },
                {
                    "type": "code",
                    "code": "import{render}from'react-dom';import'./styles.css';importAppfrom'./App.js';leti=0;setInterval(()=>{render(<Appcounter={i}/>,document.getElementById('root'));i++;},1000);"
                },
                {
                    "type": "p",
                    "text": "It is uncommon to callrendermultiple times. Usually, you’llupdate stateinside your components instead."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/server",
            "title": "Server React DOM APIs – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Server React DOM APIs"
                },
                {
                    "type": "p",
                    "text": "Thereact-dom/serverAPIs let you render React components to HTML on the server. These APIs are only used on the server at the top level of your app to generate the initial HTML. Aframeworkmay call them for you. Most of your components don’t need to import or use them."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Server APIs for Node.js Streams"
                },
                {
                    "type": "p",
                    "text": "These methods are only available in the environments withNode.js Streams:"
                },
                {
                    "type": "list",
                    "items": [
                        "renderToPipeableStreamrenders a React tree to a pipeableNode.js Stream.",
                        "renderToStaticNodeStreamrenders a non-interactive React tree to aNode.js Readable Stream."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Server APIs for Web Streams"
                },
                {
                    "type": "p",
                    "text": "These methods are only available in the environments withWeb Streams, which includes browsers, Deno, and some modern edge runtimes:"
                },
                {
                    "type": "list",
                    "items": [
                        "renderToReadableStreamrenders a React tree to aReadable Web Stream."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Server APIs for non-streaming environments"
                },
                {
                    "type": "p",
                    "text": "These methods can be used in the environments that don’t support streams:"
                },
                {
                    "type": "list",
                    "items": [
                        "renderToStringrenders a React tree to a string.",
                        "renderToStaticMarkuprenders a non-interactive React tree to a string."
                    ]
                },
                {
                    "type": "p",
                    "text": "They have limited functionality compared to the streaming APIs."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Deprecated server APIs"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Deprecated"
                },
                {
                    "type": "p",
                    "text": "These APIs will be removed in a future major version of React."
                },
                {
                    "type": "list",
                    "items": [
                        "renderToNodeStreamrenders a React tree to aNode.js Readable stream.(Deprecated.)"
                    ]
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/server/renderToNodeStream",
            "title": "renderToNodeStream – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "renderToNodeStream"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Deprecated"
                },
                {
                    "type": "p",
                    "text": "This API will be removed in a future major version of React. UserenderToPipeableStreaminstead."
                },
                {
                    "type": "p",
                    "text": "renderToNodeStreamrenders a React tree to aNode.js Readable Stream."
                },
                {
                    "type": "code",
                    "code": "conststream=renderToNodeStream(reactNode,options?)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferencerenderToNodeStream(reactNode, options?)",
                        "renderToNodeStream(reactNode, options?)",
                        "UsageRendering a React tree as HTML to a Node.js Readable Stream",
                        "Rendering a React tree as HTML to a Node.js Readable Stream"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "renderToNodeStream(reactNode, options?)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Rendering a React tree as HTML to a Node.js Readable Stream"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "renderToNodeStream(reactNode, options?)"
                },
                {
                    "type": "p",
                    "text": "On the server, callrenderToNodeStreamto get aNode.js Readable Streamwhich you can pipe into the response."
                },
                {
                    "type": "code",
                    "code": "import{renderToNodeStream}from'react-dom/server';conststream=renderToNodeStream(<App/>);stream.pipe(response);"
                },
                {
                    "type": "p",
                    "text": "On the client, callhydrateRootto make the server-generated HTML interactive."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "reactNode: A React node you want to render to HTML. For example, a JSX element like<App />.",
                        "optionaloptions: An object for server render.optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot.",
                        "optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot."
                    ]
                },
                {
                    "type": "p",
                    "text": "reactNode: A React node you want to render to HTML. For example, a JSX element like<App />."
                },
                {
                    "type": "p",
                    "text": "optionaloptions: An object for server render."
                },
                {
                    "type": "list",
                    "items": [
                        "optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "ANode.js Readable Streamthat outputs an HTML string."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "This method will wait for allSuspense boundariesto complete before returning any output.",
                        "As of React 18, this method buffers all of its output, so it doesn’t actually provide any streaming benefits. This is why it’s recommended that you migrate torenderToPipeableStreaminstead.",
                        "The returned stream is a byte stream encoded in utf-8. If you need a stream in another encoding, take a look at a project likeiconv-lite, which provides transform streams for transcoding text."
                    ]
                },
                {
                    "type": "p",
                    "text": "This method will wait for allSuspense boundariesto complete before returning any output."
                },
                {
                    "type": "p",
                    "text": "As of React 18, this method buffers all of its output, so it doesn’t actually provide any streaming benefits. This is why it’s recommended that you migrate torenderToPipeableStreaminstead."
                },
                {
                    "type": "p",
                    "text": "The returned stream is a byte stream encoded in utf-8. If you need a stream in another encoding, take a look at a project likeiconv-lite, which provides transform streams for transcoding text."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rendering a React tree as HTML to a Node.js Readable Stream"
                },
                {
                    "type": "p",
                    "text": "CallrenderToNodeStreamto get aNode.js Readable Streamwhich you can pipe to your server response:"
                },
                {
                    "type": "code",
                    "code": "import{renderToNodeStream}from'react-dom/server';// The route handler syntax depends on your backend frameworkapp.use('/',(request,response)=>{conststream=renderToNodeStream(<App/>);stream.pipe(response);});"
                },
                {
                    "type": "p",
                    "text": "The stream will produce the initial non-interactive HTML output of your React components. On the client, you will need to callhydrateRoottohydratethat server-generated HTML and make it interactive."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/server/renderToPipeableStream",
            "title": "renderToPipeableStream – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "renderToPipeableStream"
                },
                {
                    "type": "p",
                    "text": "renderToPipeableStreamrenders a React tree to a pipeableNode.js Stream."
                },
                {
                    "type": "code",
                    "code": "const{pipe,abort}=renderToPipeableStream(reactNode,options?)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferencerenderToPipeableStream(reactNode, options?)",
                        "renderToPipeableStream(reactNode, options?)",
                        "UsageRendering a React tree as HTML to a Node.js StreamStreaming more content as it loadsSpecifying what goes into the shellLogging crashes on the serverRecovering from errors inside the shellRecovering from errors outside the shellSetting the status codeHandling different errors in different waysWaiting for all content to load for crawlers and static generationAborting server rendering",
                        "Rendering a React tree as HTML to a Node.js Stream",
                        "Streaming more content as it loads",
                        "Specifying what goes into the shell",
                        "Logging crashes on the server",
                        "Recovering from errors inside the shell",
                        "Recovering from errors outside the shell",
                        "Setting the status code",
                        "Handling different errors in different ways",
                        "Waiting for all content to load for crawlers and static generation",
                        "Aborting server rendering"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "renderToPipeableStream(reactNode, options?)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Rendering a React tree as HTML to a Node.js Stream",
                        "Streaming more content as it loads",
                        "Specifying what goes into the shell",
                        "Logging crashes on the server",
                        "Recovering from errors inside the shell",
                        "Recovering from errors outside the shell",
                        "Setting the status code",
                        "Handling different errors in different ways",
                        "Waiting for all content to load for crawlers and static generation",
                        "Aborting server rendering"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "This API is specific to Node.js. Environments withWeb Streams,like Deno and modern edge runtimes, should userenderToReadableStreaminstead."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "renderToPipeableStream(reactNode, options?)"
                },
                {
                    "type": "p",
                    "text": "CallrenderToPipeableStreamto render your React tree as HTML into aNode.js Stream."
                },
                {
                    "type": "code",
                    "code": "import{renderToPipeableStream}from'react-dom/server';const{pipe}=renderToPipeableStream(<App/>,{bootstrapScripts:['/main.js'],onShellReady(){response.setHeader('content-type','text/html');pipe(response);}});"
                },
                {
                    "type": "p",
                    "text": "On the client, callhydrateRootto make the server-generated HTML interactive."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "reactNode: A React node you want to render to HTML. For example, a JSX element like<App />. It is expected to represent the entire document, so theAppcomponent should render the<html>tag.",
                        "optionaloptions: An object with streaming options.optionalbootstrapScriptContent: If specified, this string will be placed in an inline<script>tag.optionalbootstrapScripts: An array of string URLs for the<script>tags to emit on the page. Use this to include the<script>that callshydrateRoot.Omit it if you don’t want to run React on the client at all.optionalbootstrapModules: LikebootstrapScripts, but emits<script type=\"module\">instead.optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot.optionalnamespaceURI: A string with the rootnamespace URIfor the stream. Defaults to regular HTML. Pass'http://www.w3.org/2000/svg'for SVG or'http://www.w3.org/1998/Math/MathML'for MathML.optionalnonce: Anoncestring to allow scripts forscript-srcContent-Security-Policy.optionalonAllReady: A callback that fires when all rendering is complete, including both theshelland all additionalcontent.You can use this instead ofonShellReadyfor crawlers and static generation.If you start streaming here, you won’t get any progressive loading. The stream will contain the final HTML.optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error. You can also use it toadjust the status codebefore the shell is emitted.optionalonShellReady: A callback that fires right after theinitial shellhas been rendered. You canset the status codeand callpipehere to start streaming. React willstream the additional contentafter the shell along with the inline<script>tags that replace the HTML loading fallbacks with the content.optionalonShellError: A callback that fires if there was an error rendering the initial shell.  It receives the error as an argument. No bytes were emitted from the stream yet, and neitheronShellReadynoronAllReadywill get called, so you canoutput a fallback HTML shell.optionalprogressiveChunkSize: The number of bytes in a chunk.Read more about the default heuristic.",
                        "optionalbootstrapScriptContent: If specified, this string will be placed in an inline<script>tag.",
                        "optionalbootstrapScripts: An array of string URLs for the<script>tags to emit on the page. Use this to include the<script>that callshydrateRoot.Omit it if you don’t want to run React on the client at all.",
                        "optionalbootstrapModules: LikebootstrapScripts, but emits<script type=\"module\">instead.",
                        "optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot.",
                        "optionalnamespaceURI: A string with the rootnamespace URIfor the stream. Defaults to regular HTML. Pass'http://www.w3.org/2000/svg'for SVG or'http://www.w3.org/1998/Math/MathML'for MathML.",
                        "optionalnonce: Anoncestring to allow scripts forscript-srcContent-Security-Policy.",
                        "optionalonAllReady: A callback that fires when all rendering is complete, including both theshelland all additionalcontent.You can use this instead ofonShellReadyfor crawlers and static generation.If you start streaming here, you won’t get any progressive loading. The stream will contain the final HTML.",
                        "optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error. You can also use it toadjust the status codebefore the shell is emitted.",
                        "optionalonShellReady: A callback that fires right after theinitial shellhas been rendered. You canset the status codeand callpipehere to start streaming. React willstream the additional contentafter the shell along with the inline<script>tags that replace the HTML loading fallbacks with the content.",
                        "optionalonShellError: A callback that fires if there was an error rendering the initial shell.  It receives the error as an argument. No bytes were emitted from the stream yet, and neitheronShellReadynoronAllReadywill get called, so you canoutput a fallback HTML shell.",
                        "optionalprogressiveChunkSize: The number of bytes in a chunk.Read more about the default heuristic."
                    ]
                },
                {
                    "type": "p",
                    "text": "reactNode: A React node you want to render to HTML. For example, a JSX element like<App />. It is expected to represent the entire document, so theAppcomponent should render the<html>tag."
                },
                {
                    "type": "p",
                    "text": "optionaloptions: An object with streaming options."
                },
                {
                    "type": "list",
                    "items": [
                        "optionalbootstrapScriptContent: If specified, this string will be placed in an inline<script>tag.",
                        "optionalbootstrapScripts: An array of string URLs for the<script>tags to emit on the page. Use this to include the<script>that callshydrateRoot.Omit it if you don’t want to run React on the client at all.",
                        "optionalbootstrapModules: LikebootstrapScripts, but emits<script type=\"module\">instead.",
                        "optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot.",
                        "optionalnamespaceURI: A string with the rootnamespace URIfor the stream. Defaults to regular HTML. Pass'http://www.w3.org/2000/svg'for SVG or'http://www.w3.org/1998/Math/MathML'for MathML.",
                        "optionalnonce: Anoncestring to allow scripts forscript-srcContent-Security-Policy.",
                        "optionalonAllReady: A callback that fires when all rendering is complete, including both theshelland all additionalcontent.You can use this instead ofonShellReadyfor crawlers and static generation.If you start streaming here, you won’t get any progressive loading. The stream will contain the final HTML.",
                        "optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error. You can also use it toadjust the status codebefore the shell is emitted.",
                        "optionalonShellReady: A callback that fires right after theinitial shellhas been rendered. You canset the status codeand callpipehere to start streaming. React willstream the additional contentafter the shell along with the inline<script>tags that replace the HTML loading fallbacks with the content.",
                        "optionalonShellError: A callback that fires if there was an error rendering the initial shell.  It receives the error as an argument. No bytes were emitted from the stream yet, and neitheronShellReadynoronAllReadywill get called, so you canoutput a fallback HTML shell.",
                        "optionalprogressiveChunkSize: The number of bytes in a chunk.Read more about the default heuristic."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "renderToPipeableStreamreturns an object with two methods:"
                },
                {
                    "type": "list",
                    "items": [
                        "pipeoutputs the HTML into the providedWritable Node.js Stream.CallpipeinonShellReadyif you want to enable streaming, or inonAllReadyfor crawlers and static generation.",
                        "abortlets youabort server renderingand render the rest on the client."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rendering a React tree as HTML to a Node.js Stream"
                },
                {
                    "type": "p",
                    "text": "CallrenderToPipeableStreamto render your React tree as HTML into aNode.js Stream:"
                },
                {
                    "type": "code",
                    "code": "import{renderToPipeableStream}from'react-dom/server';// The route handler syntax depends on your backend frameworkapp.use('/',(request,response)=>{const{pipe}=renderToPipeableStream(<App />,{bootstrapScripts:['/main.js'],onShellReady(){response.setHeader('content-type','text/html');pipe(response);}});});"
                },
                {
                    "type": "p",
                    "text": "Along with theroot component, you need to provide a list ofbootstrap<script>paths. Your root component should returnthe entire document including the root<html>tag."
                },
                {
                    "type": "p",
                    "text": "For example, it might look like this:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionApp(){return(<html><head><metacharSet=\"utf-8\"/><metaname=\"viewport\"content=\"width=device-width, initial-scale=1\"/><linkrel=\"stylesheet\"href=\"/styles.css\"></link><title>My app</title></head><body><Router/></body></html>);}"
                },
                {
                    "type": "p",
                    "text": "React will inject thedoctypeand yourbootstrap<script>tagsinto the resulting HTML stream:"
                },
                {
                    "type": "code",
                    "code": "<!DOCTYPE html><html><!-- ... HTML from your components ... --></html><scriptsrc=\"/main.js\"async=\"\"></script>"
                },
                {
                    "type": "p",
                    "text": "On the client, your bootstrap script shouldhydrate the entiredocumentwith a call tohydrateRoot:"
                },
                {
                    "type": "code",
                    "code": "import{hydrateRoot}from'react-dom/client';importAppfrom'./App.js';hydrateRoot(document,<App />);"
                },
                {
                    "type": "p",
                    "text": "This will attach event listeners to the server-generated HTML and make it interactive."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Reading CSS and JS asset paths from the build output"
                },
                {
                    "type": "p",
                    "text": "The final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead ofstyles.cssyou might end up withstyles.123456.css. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content."
                },
                {
                    "type": "p",
                    "text": "However, if you don’t know the asset URLs until after the build, there’s no way for you to put them in the source code. For example, hardcoding\"/styles.css\"into JSX like earlier wouldn’t work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionApp({assetMap}){return(<html><head>...<linkrel=\"stylesheet\"href={assetMap['styles.css']}></link>...</head>...</html>);}"
                },
                {
                    "type": "p",
                    "text": "On the server, render<App assetMap={assetMap} />and pass yourassetMapwith the asset URLs:"
                },
                {
                    "type": "code",
                    "code": "// You'd need to get this JSON from your build tooling, e.g. read it from the build output.constassetMap={'styles.css':'/styles.123456.css','main.js':'/main.123456.js'};app.use('/',(request,response)=>{const{pipe}=renderToPipeableStream(<AppassetMap={assetMap}/>,{bootstrapScripts:[assetMap['main.js']],onShellReady(){response.setHeader('content-type','text/html');pipe(response);}});});"
                },
                {
                    "type": "p",
                    "text": "Since your server is now rendering<App assetMap={assetMap} />, you need to render it withassetMapon the client too to avoid hydration errors. You can serialize and passassetMapto the client like this:"
                },
                {
                    "type": "code",
                    "code": "// You'd need to get this JSON from your build tooling.constassetMap={'styles.css':'/styles.123456.css','main.js':'/main.123456.js'};app.use('/',(request,response)=>{const{pipe}=renderToPipeableStream(<AppassetMap={assetMap}/>,{// Careful: It's safe to stringify() this because this data isn't user-generated.bootstrapScriptContent:`window.assetMap =${JSON.stringify(assetMap)};`,bootstrapScripts:[assetMap['main.js']],onShellReady(){response.setHeader('content-type','text/html');pipe(response);}});});"
                },
                {
                    "type": "p",
                    "text": "In the example above, thebootstrapScriptContentoption adds an extra inline<script>tag that sets the globalwindow.assetMapvariable on the client. This lets the client code read the sameassetMap:"
                },
                {
                    "type": "code",
                    "code": "import{hydrateRoot}from'react-dom/client';importAppfrom'./App.js';hydrateRoot(document,<AppassetMap={window.assetMap}/>);"
                },
                {
                    "type": "p",
                    "text": "Both client and server renderAppwith the sameassetMapprop, so there are no hydration errors."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Streaming more content as it loads"
                },
                {
                    "type": "p",
                    "text": "Streaming allows the user to start seeing the content even before all the data has loaded on the server. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:"
                },
                {
                    "type": "code",
                    "code": "functionProfilePage(){return(<ProfileLayout><ProfileCover/><Sidebar><Friends/><Photos/></Sidebar><Posts/></ProfileLayout>);}"
                },
                {
                    "type": "p",
                    "text": "Imagine that loading data for<Posts />takes some time. Ideally, you’d want to show the rest of the profile page content to the user without waiting for the posts. To do this,wrapPostsin a<Suspense>boundary:"
                },
                {
                    "type": "code",
                    "code": "functionProfilePage(){return(<ProfileLayout><ProfileCover/><Sidebar><Friends/><Photos/></Sidebar><Suspensefallback={<PostsGlimmer/>}><Posts/></Suspense></ProfileLayout>);}"
                },
                {
                    "type": "p",
                    "text": "This tells React to start streaming the HTML beforePostsloads its data. React will send the HTML for the loading fallback (PostsGlimmer) first, and then, whenPostsfinishes loading its data, React will send the remaining HTML along with an inline<script>tag that replaces the loading fallback with that HTML. From the user’s perspective, the page will first appear with thePostsGlimmer, later replaced by thePosts."
                },
                {
                    "type": "p",
                    "text": "You can furthernest<Suspense>boundariesto create a more granular loading sequence:"
                },
                {
                    "type": "code",
                    "code": "functionProfilePage(){return(<ProfileLayout><ProfileCover/><Suspensefallback={<BigSpinner/>}><Sidebar><Friends/><Photos/></Sidebar><Suspensefallback={<PostsGlimmer/>}><Posts/></Suspense></Suspense></ProfileLayout>);}"
                },
                {
                    "type": "p",
                    "text": "In this example, React can start streaming the page even earlier. OnlyProfileLayoutandProfileCovermust finish rendering first because they are not wrapped in any<Suspense>boundary. However, ifSidebar,Friends, orPhotosneed to load some data, React will send the HTML for theBigSpinnerfallback instead. Then, as more data becomes available, more content will continue to be revealed until all of it becomes visible."
                },
                {
                    "type": "p",
                    "text": "Streaming does not need to wait for React itself to load in the browser, or for your app to become interactive. The HTML content from the server will get progressively revealed before any of the<script>tags load."
                },
                {
                    "type": "p",
                    "text": "Read more about how streaming HTML works."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Only Suspense-enabled data sources will activate the Suspense component.They include:"
                },
                {
                    "type": "list",
                    "items": [
                        "Data fetching with Suspense-enabled frameworks likeRelayandNext.js",
                        "Lazy-loading component code withlazy",
                        "Reading the value of a Promise withuse"
                    ]
                },
                {
                    "type": "p",
                    "text": "Suspensedoes notdetect when data is fetched inside an Effect or event handler."
                },
                {
                    "type": "p",
                    "text": "The exact way you would load data in thePostscomponent above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation."
                },
                {
                    "type": "p",
                    "text": "Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Specifying what goes into the shell"
                },
                {
                    "type": "p",
                    "text": "The part of your app outside of any<Suspense>boundaries is calledthe shell:"
                },
                {
                    "type": "code",
                    "code": "functionProfilePage(){return(<ProfileLayout><ProfileCover/><Suspensefallback={<BigSpinner/>}><Sidebar><Friends/><Photos/></Sidebar><Suspensefallback={<PostsGlimmer/>}><Posts/></Suspense></Suspense></ProfileLayout>);}"
                },
                {
                    "type": "p",
                    "text": "It determines the earliest loading state that the user may see:"
                },
                {
                    "type": "code",
                    "code": "<ProfileLayout><ProfileCover/><BigSpinner/></ProfileLayout>"
                },
                {
                    "type": "p",
                    "text": "If you wrap the whole app into a<Suspense>boundary at the root, the shell will only contain that spinner. However, that’s not a pleasant user experience because seeing a big spinner on the screen can feel slower and more annoying than waiting a bit more and seeing the real layout. This is why usually you’ll want to place the<Suspense>boundaries so that the shell feelsminimal but complete—like a skeleton of the entire page layout."
                },
                {
                    "type": "p",
                    "text": "TheonShellReadycallback fires when the entire shell has been rendered. Usually, you’ll start streaming then:"
                },
                {
                    "type": "code",
                    "code": "const{pipe}=renderToPipeableStream(<App/>,{bootstrapScripts:['/main.js'],onShellReady(){response.setHeader('content-type','text/html');pipe(response);}});"
                },
                {
                    "type": "p",
                    "text": "By the timeonShellReadyfires, components in nested<Suspense>boundaries might still be loading data."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Logging crashes on the server"
                },
                {
                    "type": "p",
                    "text": "By default, all errors on the server are logged to console. You can override this behavior to log crash reports:"
                },
                {
                    "type": "code",
                    "code": "const{pipe}=renderToPipeableStream(<App/>,{bootstrapScripts:['/main.js'],onShellReady(){response.setHeader('content-type','text/html');pipe(response);},onError(error){console.error(error);logServerCrashReport(error);}});"
                },
                {
                    "type": "p",
                    "text": "If you provide a customonErrorimplementation, don’t forget to also log errors to the console like above."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Recovering from errors inside the shell"
                },
                {
                    "type": "p",
                    "text": "In this example, the shell containsProfileLayout,ProfileCover, andPostsGlimmer:"
                },
                {
                    "type": "code",
                    "code": "functionProfilePage(){return(<ProfileLayout><ProfileCover/><Suspensefallback={<PostsGlimmer/>}><Posts/></Suspense></ProfileLayout>);}"
                },
                {
                    "type": "p",
                    "text": "If an error occurs while rendering those components, React won’t have any meaningful HTML to send to the client. OverrideonShellErrorto send a fallback HTML that doesn’t rely on server rendering as the last resort:"
                },
                {
                    "type": "code",
                    "code": "const{pipe}=renderToPipeableStream(<App/>,{bootstrapScripts:['/main.js'],onShellReady(){response.setHeader('content-type','text/html');pipe(response);},onShellError(error){response.statusCode=500;response.setHeader('content-type','text/html');response.send('<h1>Something went wrong</h1>');},onError(error){console.error(error);logServerCrashReport(error);}});"
                },
                {
                    "type": "p",
                    "text": "If there is an error while generating the shell, bothonErrorandonShellErrorwill fire. UseonErrorfor error reporting and useonShellErrorto send the fallback HTML document. Your fallback HTML does not have to be an error page. Instead, you may include an alternative shell that renders your app on the client only."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Recovering from errors outside the shell"
                },
                {
                    "type": "p",
                    "text": "In this example, the<Posts />component is wrapped in<Suspense>so it isnota part of the shell:"
                },
                {
                    "type": "code",
                    "code": "functionProfilePage(){return(<ProfileLayout><ProfileCover/><Suspensefallback={<PostsGlimmer/>}><Posts/></Suspense></ProfileLayout>);}"
                },
                {
                    "type": "p",
                    "text": "If an error happens in thePostscomponent or somewhere inside it, React willtry to recover from it:"
                },
                {
                    "type": "list",
                    "items": [
                        "It will emit the loading fallback for the closest<Suspense>boundary (PostsGlimmer) into the HTML.",
                        "It will “give up” on trying to render thePostscontent on the server anymore.",
                        "When the JavaScript code loads on the client, React willretryrenderingPostson the client."
                    ]
                },
                {
                    "type": "p",
                    "text": "If retrying renderingPostson the clientalsofails, React will throw the error on the client. As with all the errors thrown during rendering, theclosest parent error boundarydetermines how to present the error to the user. In practice, this means that the user will see a loading indicator until it is certain that the error is not recoverable."
                },
                {
                    "type": "p",
                    "text": "If retrying renderingPostson the client succeeds, the loading fallback from the server will be replaced with the client rendering output. The user will not know that there was a server error. However, the serveronErrorcallback and the clientonRecoverableErrorcallbacks will fire so that you can get notified about the error."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Setting the status code"
                },
                {
                    "type": "p",
                    "text": "Streaming introduces a tradeoff. You want to start streaming the page as early as possible so that the user can see the content sooner. However, once you start streaming, you can no longer set the response status code."
                },
                {
                    "type": "p",
                    "text": "Bydividing your appinto the shell (above all<Suspense>boundaries) and the rest of the content, you’ve already solved a part of this problem. If the shell errors, you’ll get theonShellErrorcallback which lets you set the error status code. Otherwise, you know that the app may recover on the client, so you can send “OK”."
                },
                {
                    "type": "code",
                    "code": "const{pipe}=renderToPipeableStream(<App/>,{bootstrapScripts:['/main.js'],onShellReady(){response.statusCode=200;response.setHeader('content-type','text/html');pipe(response);},onShellError(error){response.statusCode=500;response.setHeader('content-type','text/html');response.send('<h1>Something went wrong</h1>');},onError(error){console.error(error);logServerCrashReport(error);}});"
                },
                {
                    "type": "p",
                    "text": "If a componentoutsidethe shell (i.e. inside a<Suspense>boundary) throws an error, React will not stop rendering. This means that theonErrorcallback will fire, but you will still getonShellReadyinstead ofonShellError. This is because React will try to recover from that error on the client,as described above."
                },
                {
                    "type": "p",
                    "text": "However, if you’d like, you can use the fact that something has errored to set the status code:"
                },
                {
                    "type": "code",
                    "code": "letdidError=false;const{pipe}=renderToPipeableStream(<App/>,{bootstrapScripts:['/main.js'],onShellReady(){response.statusCode=didError?500:200;response.setHeader('content-type','text/html');pipe(response);},onShellError(error){response.statusCode=500;response.setHeader('content-type','text/html');response.send('<h1>Something went wrong</h1>');},onError(error){didError=true;console.error(error);logServerCrashReport(error);}});"
                },
                {
                    "type": "p",
                    "text": "This will only catch errors outside the shell that happened while generating the initial shell content, so it’s not exhaustive. If knowing whether an error occurred for some content is critical, you can move it up into the shell."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Handling different errors in different ways"
                },
                {
                    "type": "p",
                    "text": "You cancreate your ownErrorsubclassesand use theinstanceofoperator to check which error is thrown. For example, you can define a customNotFoundErrorand throw it from your component. Then youronError,onShellReady, andonShellErrorcallbacks can do something different depending on the error type:"
                },
                {
                    "type": "code",
                    "code": "letdidError=false;letcaughtError=null;functiongetStatusCode(){if(didError){if(caughtErrorinstanceofNotFoundError){return404;}else{return500;}}else{return200;}}const{pipe}=renderToPipeableStream(<App/>,{bootstrapScripts:['/main.js'],onShellReady(){response.statusCode=getStatusCode();response.setHeader('content-type','text/html');pipe(response);},onShellError(error){response.statusCode=getStatusCode();response.setHeader('content-type','text/html');response.send('<h1>Something went wrong</h1>');},onError(error){didError=true;caughtError=error;console.error(error);logServerCrashReport(error);}});"
                },
                {
                    "type": "p",
                    "text": "Keep in mind that once you emit the shell and start streaming, you can’t change the status code."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Waiting for all content to load for crawlers and static generation"
                },
                {
                    "type": "p",
                    "text": "Streaming offers a better user experience because the user can see the content as it becomes available."
                },
                {
                    "type": "p",
                    "text": "However, when a crawler visits your page, or if you’re generating the pages at the build time, you might want to let all of the content load first and then produce the final HTML output instead of revealing it progressively."
                },
                {
                    "type": "p",
                    "text": "You can wait for all the content to load using theonAllReadycallback:"
                },
                {
                    "type": "code",
                    "code": "letdidError=false;letisCrawler=// ... depends on your bot detection strategy ...const{pipe}=renderToPipeableStream(<App/>,{bootstrapScripts:['/main.js'],onShellReady(){if(!isCrawler){response.statusCode=didError?500:200;response.setHeader('content-type','text/html');pipe(response);}},onShellError(error){response.statusCode=500;response.setHeader('content-type','text/html');response.send('<h1>Something went wrong</h1>');},onAllReady(){if(isCrawler){response.statusCode=didError?500:200;response.setHeader('content-type','text/html');pipe(response);}},onError(error){didError=true;console.error(error);logServerCrashReport(error);}});"
                },
                {
                    "type": "p",
                    "text": "A regular visitor will get a stream of progressively loaded content. A crawler will receive the final HTML output after all the data loads. However, this also means that the crawler will have to wait foralldata, some of which might be slow to load or error. Depending on your app, you could choose to send the shell to the crawlers too."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Aborting server rendering"
                },
                {
                    "type": "p",
                    "text": "You can force the server rendering to “give up” after a timeout:"
                },
                {
                    "type": "code",
                    "code": "const{pipe,abort}=renderToPipeableStream(<App/>,{// ...});setTimeout(()=>{abort();},10000);"
                },
                {
                    "type": "p",
                    "text": "React will flush the remaining loading fallbacks as HTML, and will attempt to render the rest on the client."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/server/renderToReadableStream",
            "title": "renderToReadableStream – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "renderToReadableStream"
                },
                {
                    "type": "p",
                    "text": "renderToReadableStreamrenders a React tree to aReadable Web Stream."
                },
                {
                    "type": "code",
                    "code": "conststream=awaitrenderToReadableStream(reactNode,options?)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferencerenderToReadableStream(reactNode, options?)",
                        "renderToReadableStream(reactNode, options?)",
                        "UsageRendering a React tree as HTML to a Readable Web StreamStreaming more content as it loadsSpecifying what goes into the shellLogging crashes on the serverRecovering from errors inside the shellRecovering from errors outside the shellSetting the status codeHandling different errors in different waysWaiting for all content to load for crawlers and static generationAborting server rendering",
                        "Rendering a React tree as HTML to a Readable Web Stream",
                        "Streaming more content as it loads",
                        "Specifying what goes into the shell",
                        "Logging crashes on the server",
                        "Recovering from errors inside the shell",
                        "Recovering from errors outside the shell",
                        "Setting the status code",
                        "Handling different errors in different ways",
                        "Waiting for all content to load for crawlers and static generation",
                        "Aborting server rendering"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "renderToReadableStream(reactNode, options?)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Rendering a React tree as HTML to a Readable Web Stream",
                        "Streaming more content as it loads",
                        "Specifying what goes into the shell",
                        "Logging crashes on the server",
                        "Recovering from errors inside the shell",
                        "Recovering from errors outside the shell",
                        "Setting the status code",
                        "Handling different errors in different ways",
                        "Waiting for all content to load for crawlers and static generation",
                        "Aborting server rendering"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "This API depends onWeb Streams.For Node.js, userenderToPipeableStreaminstead."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "renderToReadableStream(reactNode, options?)"
                },
                {
                    "type": "p",
                    "text": "CallrenderToReadableStreamto render your React tree as HTML into aReadable Web Stream."
                },
                {
                    "type": "code",
                    "code": "import{renderToReadableStream}from'react-dom/server';asyncfunctionhandler(request){conststream=awaitrenderToReadableStream(<App/>,{bootstrapScripts:['/main.js']});returnnewResponse(stream,{headers:{'content-type':'text/html'},});}"
                },
                {
                    "type": "p",
                    "text": "On the client, callhydrateRootto make the server-generated HTML interactive."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "reactNode: A React node you want to render to HTML. For example, a JSX element like<App />. It is expected to represent the entire document, so theAppcomponent should render the<html>tag.",
                        "optionaloptions: An object with streaming options.optionalbootstrapScriptContent: If specified, this string will be placed in an inline<script>tag.optionalbootstrapScripts: An array of string URLs for the<script>tags to emit on the page. Use this to include the<script>that callshydrateRoot.Omit it if you don’t want to run React on the client at all.optionalbootstrapModules: LikebootstrapScripts, but emits<script type=\"module\">instead.optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot.optionalnamespaceURI: A string with the rootnamespace URIfor the stream. Defaults to regular HTML. Pass'http://www.w3.org/2000/svg'for SVG or'http://www.w3.org/1998/Math/MathML'for MathML.optionalnonce: Anoncestring to allow scripts forscript-srcContent-Security-Policy.optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error. You can also use it toadjust the status codebefore the shell is emitted.optionalprogressiveChunkSize: The number of bytes in a chunk.Read more about the default heuristic.optionalsignal: Anabort signalthat lets youabort server renderingand render the rest on the client.",
                        "optionalbootstrapScriptContent: If specified, this string will be placed in an inline<script>tag.",
                        "optionalbootstrapScripts: An array of string URLs for the<script>tags to emit on the page. Use this to include the<script>that callshydrateRoot.Omit it if you don’t want to run React on the client at all.",
                        "optionalbootstrapModules: LikebootstrapScripts, but emits<script type=\"module\">instead.",
                        "optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot.",
                        "optionalnamespaceURI: A string with the rootnamespace URIfor the stream. Defaults to regular HTML. Pass'http://www.w3.org/2000/svg'for SVG or'http://www.w3.org/1998/Math/MathML'for MathML.",
                        "optionalnonce: Anoncestring to allow scripts forscript-srcContent-Security-Policy.",
                        "optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error. You can also use it toadjust the status codebefore the shell is emitted.",
                        "optionalprogressiveChunkSize: The number of bytes in a chunk.Read more about the default heuristic.",
                        "optionalsignal: Anabort signalthat lets youabort server renderingand render the rest on the client."
                    ]
                },
                {
                    "type": "p",
                    "text": "reactNode: A React node you want to render to HTML. For example, a JSX element like<App />. It is expected to represent the entire document, so theAppcomponent should render the<html>tag."
                },
                {
                    "type": "p",
                    "text": "optionaloptions: An object with streaming options."
                },
                {
                    "type": "list",
                    "items": [
                        "optionalbootstrapScriptContent: If specified, this string will be placed in an inline<script>tag.",
                        "optionalbootstrapScripts: An array of string URLs for the<script>tags to emit on the page. Use this to include the<script>that callshydrateRoot.Omit it if you don’t want to run React on the client at all.",
                        "optionalbootstrapModules: LikebootstrapScripts, but emits<script type=\"module\">instead.",
                        "optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot.",
                        "optionalnamespaceURI: A string with the rootnamespace URIfor the stream. Defaults to regular HTML. Pass'http://www.w3.org/2000/svg'for SVG or'http://www.w3.org/1998/Math/MathML'for MathML.",
                        "optionalnonce: Anoncestring to allow scripts forscript-srcContent-Security-Policy.",
                        "optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error. You can also use it toadjust the status codebefore the shell is emitted.",
                        "optionalprogressiveChunkSize: The number of bytes in a chunk.Read more about the default heuristic.",
                        "optionalsignal: Anabort signalthat lets youabort server renderingand render the rest on the client."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "renderToReadableStreamreturns a Promise:"
                },
                {
                    "type": "list",
                    "items": [
                        "If rendering theshellis successful, that Promise will resolve to aReadable Web Stream.",
                        "If rendering the shell fails, the Promise will be rejected.Use this to output a fallback shell."
                    ]
                },
                {
                    "type": "p",
                    "text": "The returned stream has an additional property:"
                },
                {
                    "type": "list",
                    "items": [
                        "allReady: A Promise that resolves when all rendering is complete, including both theshelland all additionalcontent.You canawait stream.allReadybefore returning a responsefor crawlers and static generation.If you do that, you won’t get any progressive loading. The stream will contain the final HTML."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rendering a React tree as HTML to a Readable Web Stream"
                },
                {
                    "type": "p",
                    "text": "CallrenderToReadableStreamto render your React tree as HTML into aReadable Web Stream:"
                },
                {
                    "type": "code",
                    "code": "import{renderToReadableStream}from'react-dom/server';asyncfunctionhandler(request){conststream=awaitrenderToReadableStream(<App />,{bootstrapScripts:['/main.js']});returnnewResponse(stream,{headers:{'content-type':'text/html'},});}"
                },
                {
                    "type": "p",
                    "text": "Along with theroot component, you need to provide a list ofbootstrap<script>paths. Your root component should returnthe entire document including the root<html>tag."
                },
                {
                    "type": "p",
                    "text": "For example, it might look like this:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionApp(){return(<html><head><metacharSet=\"utf-8\"/><metaname=\"viewport\"content=\"width=device-width, initial-scale=1\"/><linkrel=\"stylesheet\"href=\"/styles.css\"></link><title>My app</title></head><body><Router/></body></html>);}"
                },
                {
                    "type": "p",
                    "text": "React will inject thedoctypeand yourbootstrap<script>tagsinto the resulting HTML stream:"
                },
                {
                    "type": "code",
                    "code": "<!DOCTYPE html><html><!-- ... HTML from your components ... --></html><scriptsrc=\"/main.js\"async=\"\"></script>"
                },
                {
                    "type": "p",
                    "text": "On the client, your bootstrap script shouldhydrate the entiredocumentwith a call tohydrateRoot:"
                },
                {
                    "type": "code",
                    "code": "import{hydrateRoot}from'react-dom/client';importAppfrom'./App.js';hydrateRoot(document,<App />);"
                },
                {
                    "type": "p",
                    "text": "This will attach event listeners to the server-generated HTML and make it interactive."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Reading CSS and JS asset paths from the build output"
                },
                {
                    "type": "p",
                    "text": "The final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead ofstyles.cssyou might end up withstyles.123456.css. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content."
                },
                {
                    "type": "p",
                    "text": "However, if you don’t know the asset URLs until after the build, there’s no way for you to put them in the source code. For example, hardcoding\"/styles.css\"into JSX like earlier wouldn’t work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionApp({assetMap}){return(<html><head><title>My app</title><linkrel=\"stylesheet\"href={assetMap['styles.css']}></link></head>...</html>);}"
                },
                {
                    "type": "p",
                    "text": "On the server, render<App assetMap={assetMap} />and pass yourassetMapwith the asset URLs:"
                },
                {
                    "type": "code",
                    "code": "// You'd need to get this JSON from your build tooling, e.g. read it from the build output.constassetMap={'styles.css':'/styles.123456.css','main.js':'/main.123456.js'};asyncfunctionhandler(request){conststream=awaitrenderToReadableStream(<AppassetMap={assetMap}/>,{bootstrapScripts:[assetMap['/main.js']]});returnnewResponse(stream,{headers:{'content-type':'text/html'},});}"
                },
                {
                    "type": "p",
                    "text": "Since your server is now rendering<App assetMap={assetMap} />, you need to render it withassetMapon the client too to avoid hydration errors. You can serialize and passassetMapto the client like this:"
                },
                {
                    "type": "code",
                    "code": "// You'd need to get this JSON from your build tooling.constassetMap={'styles.css':'/styles.123456.css','main.js':'/main.123456.js'};asyncfunctionhandler(request){conststream=awaitrenderToReadableStream(<AppassetMap={assetMap}/>,{// Careful: It's safe to stringify() this because this data isn't user-generated.bootstrapScriptContent:`window.assetMap =${JSON.stringify(assetMap)};`,bootstrapScripts:[assetMap['/main.js']],});returnnewResponse(stream,{headers:{'content-type':'text/html'},});}"
                },
                {
                    "type": "p",
                    "text": "In the example above, thebootstrapScriptContentoption adds an extra inline<script>tag that sets the globalwindow.assetMapvariable on the client. This lets the client code read the sameassetMap:"
                },
                {
                    "type": "code",
                    "code": "import{hydrateRoot}from'react-dom/client';importAppfrom'./App.js';hydrateRoot(document,<AppassetMap={window.assetMap}/>);"
                },
                {
                    "type": "p",
                    "text": "Both client and server renderAppwith the sameassetMapprop, so there are no hydration errors."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Streaming more content as it loads"
                },
                {
                    "type": "p",
                    "text": "Streaming allows the user to start seeing the content even before all the data has loaded on the server. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:"
                },
                {
                    "type": "code",
                    "code": "functionProfilePage(){return(<ProfileLayout><ProfileCover/><Sidebar><Friends/><Photos/></Sidebar><Posts/></ProfileLayout>);}"
                },
                {
                    "type": "p",
                    "text": "Imagine that loading data for<Posts />takes some time. Ideally, you’d want to show the rest of the profile page content to the user without waiting for the posts. To do this,wrapPostsin a<Suspense>boundary:"
                },
                {
                    "type": "code",
                    "code": "functionProfilePage(){return(<ProfileLayout><ProfileCover/><Sidebar><Friends/><Photos/></Sidebar><Suspensefallback={<PostsGlimmer/>}><Posts/></Suspense></ProfileLayout>);}"
                },
                {
                    "type": "p",
                    "text": "This tells React to start streaming the HTML beforePostsloads its data. React will send the HTML for the loading fallback (PostsGlimmer) first, and then, whenPostsfinishes loading its data, React will send the remaining HTML along with an inline<script>tag that replaces the loading fallback with that HTML. From the user’s perspective, the page will first appear with thePostsGlimmer, later replaced by thePosts."
                },
                {
                    "type": "p",
                    "text": "You can furthernest<Suspense>boundariesto create a more granular loading sequence:"
                },
                {
                    "type": "code",
                    "code": "functionProfilePage(){return(<ProfileLayout><ProfileCover/><Suspensefallback={<BigSpinner/>}><Sidebar><Friends/><Photos/></Sidebar><Suspensefallback={<PostsGlimmer/>}><Posts/></Suspense></Suspense></ProfileLayout>);}"
                },
                {
                    "type": "p",
                    "text": "In this example, React can start streaming the page even earlier. OnlyProfileLayoutandProfileCovermust finish rendering first because they are not wrapped in any<Suspense>boundary. However, ifSidebar,Friends, orPhotosneed to load some data, React will send the HTML for theBigSpinnerfallback instead. Then, as more data becomes available, more content will continue to be revealed until all of it becomes visible."
                },
                {
                    "type": "p",
                    "text": "Streaming does not need to wait for React itself to load in the browser, or for your app to become interactive. The HTML content from the server will get progressively revealed before any of the<script>tags load."
                },
                {
                    "type": "p",
                    "text": "Read more about how streaming HTML works."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Only Suspense-enabled data sources will activate the Suspense component.They include:"
                },
                {
                    "type": "list",
                    "items": [
                        "Data fetching with Suspense-enabled frameworks likeRelayandNext.js",
                        "Lazy-loading component code withlazy",
                        "Reading the value of a Promise withuse"
                    ]
                },
                {
                    "type": "p",
                    "text": "Suspensedoes notdetect when data is fetched inside an Effect or event handler."
                },
                {
                    "type": "p",
                    "text": "The exact way you would load data in thePostscomponent above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation."
                },
                {
                    "type": "p",
                    "text": "Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Specifying what goes into the shell"
                },
                {
                    "type": "p",
                    "text": "The part of your app outside of any<Suspense>boundaries is calledthe shell:"
                },
                {
                    "type": "code",
                    "code": "functionProfilePage(){return(<ProfileLayout><ProfileCover/><Suspensefallback={<BigSpinner/>}><Sidebar><Friends/><Photos/></Sidebar><Suspensefallback={<PostsGlimmer/>}><Posts/></Suspense></Suspense></ProfileLayout>);}"
                },
                {
                    "type": "p",
                    "text": "It determines the earliest loading state that the user may see:"
                },
                {
                    "type": "code",
                    "code": "<ProfileLayout><ProfileCover/><BigSpinner/></ProfileLayout>"
                },
                {
                    "type": "p",
                    "text": "If you wrap the whole app into a<Suspense>boundary at the root, the shell will only contain that spinner. However, that’s not a pleasant user experience because seeing a big spinner on the screen can feel slower and more annoying than waiting a bit more and seeing the real layout. This is why usually you’ll want to place the<Suspense>boundaries so that the shell feelsminimal but complete—like a skeleton of the entire page layout."
                },
                {
                    "type": "p",
                    "text": "The async call torenderToReadableStreamwill resolve to astreamas soon as the entire shell has been rendered. Usually, you’ll start streaming then by creating and returning a response with thatstream:"
                },
                {
                    "type": "code",
                    "code": "asyncfunctionhandler(request){conststream=awaitrenderToReadableStream(<App/>,{bootstrapScripts:['/main.js']});returnnewResponse(stream,{headers:{'content-type':'text/html'},});}"
                },
                {
                    "type": "p",
                    "text": "By the time thestreamis returned, components in nested<Suspense>boundaries might still be loading data."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Logging crashes on the server"
                },
                {
                    "type": "p",
                    "text": "By default, all errors on the server are logged to console. You can override this behavior to log crash reports:"
                },
                {
                    "type": "code",
                    "code": "asyncfunctionhandler(request){conststream=awaitrenderToReadableStream(<App/>,{bootstrapScripts:['/main.js'],onError(error){console.error(error);logServerCrashReport(error);}});returnnewResponse(stream,{headers:{'content-type':'text/html'},});}"
                },
                {
                    "type": "p",
                    "text": "If you provide a customonErrorimplementation, don’t forget to also log errors to the console like above."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Recovering from errors inside the shell"
                },
                {
                    "type": "p",
                    "text": "In this example, the shell containsProfileLayout,ProfileCover, andPostsGlimmer:"
                },
                {
                    "type": "code",
                    "code": "functionProfilePage(){return(<ProfileLayout><ProfileCover/><Suspensefallback={<PostsGlimmer/>}><Posts/></Suspense></ProfileLayout>);}"
                },
                {
                    "type": "p",
                    "text": "If an error occurs while rendering those components, React won’t have any meaningful HTML to send to the client. Wrap yourrenderToReadableStreamcall in atry...catchto send a fallback HTML that doesn’t rely on server rendering as the last resort:"
                },
                {
                    "type": "code",
                    "code": "asyncfunctionhandler(request){try{conststream=awaitrenderToReadableStream(<App/>,{bootstrapScripts:['/main.js'],onError(error){console.error(error);logServerCrashReport(error);}});returnnewResponse(stream,{headers:{'content-type':'text/html'},});}catch(error){returnnewResponse('<h1>Something went wrong</h1>',{status:500,headers:{'content-type':'text/html'},});}}"
                },
                {
                    "type": "p",
                    "text": "If there is an error while generating the shell, bothonErrorand yourcatchblock will fire. UseonErrorfor error reporting and use thecatchblock to send the fallback HTML document. Your fallback HTML does not have to be an error page. Instead, you may include an alternative shell that renders your app on the client only."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Recovering from errors outside the shell"
                },
                {
                    "type": "p",
                    "text": "In this example, the<Posts />component is wrapped in<Suspense>so it isnota part of the shell:"
                },
                {
                    "type": "code",
                    "code": "functionProfilePage(){return(<ProfileLayout><ProfileCover/><Suspensefallback={<PostsGlimmer/>}><Posts/></Suspense></ProfileLayout>);}"
                },
                {
                    "type": "p",
                    "text": "If an error happens in thePostscomponent or somewhere inside it, React willtry to recover from it:"
                },
                {
                    "type": "list",
                    "items": [
                        "It will emit the loading fallback for the closest<Suspense>boundary (PostsGlimmer) into the HTML.",
                        "It will “give up” on trying to render thePostscontent on the server anymore.",
                        "When the JavaScript code loads on the client, React willretryrenderingPostson the client."
                    ]
                },
                {
                    "type": "p",
                    "text": "If retrying renderingPostson the clientalsofails, React will throw the error on the client. As with all the errors thrown during rendering, theclosest parent error boundarydetermines how to present the error to the user. In practice, this means that the user will see a loading indicator until it is certain that the error is not recoverable."
                },
                {
                    "type": "p",
                    "text": "If retrying renderingPostson the client succeeds, the loading fallback from the server will be replaced with the client rendering output. The user will not know that there was a server error. However, the serveronErrorcallback and the clientonRecoverableErrorcallbacks will fire so that you can get notified about the error."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Setting the status code"
                },
                {
                    "type": "p",
                    "text": "Streaming introduces a tradeoff. You want to start streaming the page as early as possible so that the user can see the content sooner. However, once you start streaming, you can no longer set the response status code."
                },
                {
                    "type": "p",
                    "text": "Bydividing your appinto the shell (above all<Suspense>boundaries) and the rest of the content, you’ve already solved a part of this problem. If the shell errors, yourcatchblock will run which lets you set the error status code. Otherwise, you know that the app may recover on the client, so you can send “OK”."
                },
                {
                    "type": "code",
                    "code": "asyncfunctionhandler(request){try{conststream=awaitrenderToReadableStream(<App/>,{bootstrapScripts:['/main.js'],onError(error){console.error(error);logServerCrashReport(error);}});returnnewResponse(stream,{status:200,headers:{'content-type':'text/html'},});}catch(error){returnnewResponse('<h1>Something went wrong</h1>',{status:500,headers:{'content-type':'text/html'},});}}"
                },
                {
                    "type": "p",
                    "text": "If a componentoutsidethe shell (i.e. inside a<Suspense>boundary) throws an error, React will not stop rendering. This means that theonErrorcallback will fire, but your code will continue running without getting into thecatchblock. This is because React will try to recover from that error on the client,as described above."
                },
                {
                    "type": "p",
                    "text": "However, if you’d like, you can use the fact that something has errored to set the status code:"
                },
                {
                    "type": "code",
                    "code": "asyncfunctionhandler(request){try{letdidError=false;conststream=awaitrenderToReadableStream(<App/>,{bootstrapScripts:['/main.js'],onError(error){didError=true;console.error(error);logServerCrashReport(error);}});returnnewResponse(stream,{status:didError?500:200,headers:{'content-type':'text/html'},});}catch(error){returnnewResponse('<h1>Something went wrong</h1>',{status:500,headers:{'content-type':'text/html'},});}}"
                },
                {
                    "type": "p",
                    "text": "This will only catch errors outside the shell that happened while generating the initial shell content, so it’s not exhaustive. If knowing whether an error occurred for some content is critical, you can move it up into the shell."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Handling different errors in different ways"
                },
                {
                    "type": "p",
                    "text": "You cancreate your ownErrorsubclassesand use theinstanceofoperator to check which error is thrown. For example, you can define a customNotFoundErrorand throw it from your component. Then you can save the error inonErrorand do something different before returning the response depending on the error type:"
                },
                {
                    "type": "code",
                    "code": "asyncfunctionhandler(request){letdidError=false;letcaughtError=null;functiongetStatusCode(){if(didError){if(caughtErrorinstanceofNotFoundError){return404;}else{return500;}}else{return200;}}try{conststream=awaitrenderToReadableStream(<App/>,{bootstrapScripts:['/main.js'],onError(error){didError=true;caughtError=error;console.error(error);logServerCrashReport(error);}});returnnewResponse(stream,{status:getStatusCode(),headers:{'content-type':'text/html'},});}catch(error){returnnewResponse('<h1>Something went wrong</h1>',{status:getStatusCode(),headers:{'content-type':'text/html'},});}}"
                },
                {
                    "type": "p",
                    "text": "Keep in mind that once you emit the shell and start streaming, you can’t change the status code."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Waiting for all content to load for crawlers and static generation"
                },
                {
                    "type": "p",
                    "text": "Streaming offers a better user experience because the user can see the content as it becomes available."
                },
                {
                    "type": "p",
                    "text": "However, when a crawler visits your page, or if you’re generating the pages at the build time, you might want to let all of the content load first and then produce the final HTML output instead of revealing it progressively."
                },
                {
                    "type": "p",
                    "text": "You can wait for all the content to load by awaiting thestream.allReadyPromise:"
                },
                {
                    "type": "code",
                    "code": "asyncfunctionhandler(request){try{letdidError=false;conststream=awaitrenderToReadableStream(<App/>,{bootstrapScripts:['/main.js'],onError(error){didError=true;console.error(error);logServerCrashReport(error);}});letisCrawler=// ... depends on your bot detection strategy ...if(isCrawler){awaitstream.allReady;}returnnewResponse(stream,{status:didError?500:200,headers:{'content-type':'text/html'},});}catch(error){returnnewResponse('<h1>Something went wrong</h1>',{status:500,headers:{'content-type':'text/html'},});}}"
                },
                {
                    "type": "p",
                    "text": "A regular visitor will get a stream of progressively loaded content. A crawler will receive the final HTML output after all the data loads. However, this also means that the crawler will have to wait foralldata, some of which might be slow to load or error. Depending on your app, you could choose to send the shell to the crawlers too."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Aborting server rendering"
                },
                {
                    "type": "p",
                    "text": "You can force the server rendering to “give up” after a timeout:"
                },
                {
                    "type": "code",
                    "code": "asyncfunctionhandler(request){try{constcontroller=newAbortController();setTimeout(()=>{controller.abort();},10000);conststream=awaitrenderToReadableStream(<App/>,{signal:controller.signal,bootstrapScripts:['/main.js'],onError(error){didError=true;console.error(error);logServerCrashReport(error);}});// ..."
                },
                {
                    "type": "p",
                    "text": "React will flush the remaining loading fallbacks as HTML, and will attempt to render the rest on the client."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/server/renderToStaticMarkup",
            "title": "renderToStaticMarkup – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "renderToStaticMarkup"
                },
                {
                    "type": "p",
                    "text": "renderToStaticMarkuprenders a non-interactive React tree to an HTML string."
                },
                {
                    "type": "code",
                    "code": "consthtml=renderToStaticMarkup(reactNode,options?)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferencerenderToStaticMarkup(reactNode, options?)",
                        "renderToStaticMarkup(reactNode, options?)",
                        "UsageRendering a non-interactive React tree as HTML to a string",
                        "Rendering a non-interactive React tree as HTML to a string"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "renderToStaticMarkup(reactNode, options?)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Rendering a non-interactive React tree as HTML to a string"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "renderToStaticMarkup(reactNode, options?)"
                },
                {
                    "type": "p",
                    "text": "On the server, callrenderToStaticMarkupto render your app to HTML."
                },
                {
                    "type": "code",
                    "code": "import{renderToStaticMarkup}from'react-dom/server';consthtml=renderToStaticMarkup(<Page/>);"
                },
                {
                    "type": "p",
                    "text": "It will produce non-interactive HTML output of your React components."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "reactNode: A React node you want to render to HTML. For example, a JSX node like<Page />.",
                        "optionaloptions: An object for server render.optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page.",
                        "optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "An HTML string."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "renderToStaticMarkupoutput cannot be hydrated.",
                        "renderToStaticMarkuphas limited Suspense support. If a component suspends,renderToStaticMarkupimmediately sends its fallback as HTML.",
                        "renderToStaticMarkupworks in the browser, but using it in the client code is not recommended. If you need to render a component to HTML in the browser,get the HTML by rendering it into a DOM node."
                    ]
                },
                {
                    "type": "p",
                    "text": "renderToStaticMarkupoutput cannot be hydrated."
                },
                {
                    "type": "p",
                    "text": "renderToStaticMarkuphas limited Suspense support. If a component suspends,renderToStaticMarkupimmediately sends its fallback as HTML."
                },
                {
                    "type": "p",
                    "text": "renderToStaticMarkupworks in the browser, but using it in the client code is not recommended. If you need to render a component to HTML in the browser,get the HTML by rendering it into a DOM node."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rendering a non-interactive React tree as HTML to a string"
                },
                {
                    "type": "p",
                    "text": "CallrenderToStaticMarkupto render your app to an HTML string which you can send with your server response:"
                },
                {
                    "type": "code",
                    "code": "import{renderToStaticMarkup}from'react-dom/server';// The route handler syntax depends on your backend frameworkapp.use('/',(request,response)=>{consthtml=renderToStaticMarkup(<Page/>);response.send(html);});"
                },
                {
                    "type": "p",
                    "text": "This will produce the initial non-interactive HTML output of your React components."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "This method rendersnon-interactive HTML that cannot be hydrated.This is useful if you want to use React as a simple static page generator, or if you’re rendering completely static content like emails."
                },
                {
                    "type": "p",
                    "text": "Interactive apps should userenderToStringon the server andhydrateRooton the client."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/server/renderToStaticNodeStream",
            "title": "renderToStaticNodeStream – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "renderToStaticNodeStream"
                },
                {
                    "type": "p",
                    "text": "renderToStaticNodeStreamrenders a non-interactive React tree to aNode.js Readable Stream."
                },
                {
                    "type": "code",
                    "code": "conststream=renderToStaticNodeStream(reactNode,options?)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferencerenderToStaticNodeStream(reactNode, options?)",
                        "renderToStaticNodeStream(reactNode, options?)",
                        "UsageRendering a React tree as static HTML to a Node.js Readable Stream",
                        "Rendering a React tree as static HTML to a Node.js Readable Stream"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "renderToStaticNodeStream(reactNode, options?)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Rendering a React tree as static HTML to a Node.js Readable Stream"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "renderToStaticNodeStream(reactNode, options?)"
                },
                {
                    "type": "p",
                    "text": "On the server, callrenderToStaticNodeStreamto get aNode.js Readable Stream."
                },
                {
                    "type": "code",
                    "code": "import{renderToStaticNodeStream}from'react-dom/server';conststream=renderToStaticNodeStream(<Page/>);stream.pipe(response);"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "p",
                    "text": "The stream will produce non-interactive HTML output of your React components."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "reactNode: A React node you want to render to HTML. For example, a JSX element like<Page />.",
                        "optionaloptions: An object for server render.optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page.",
                        "optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page."
                    ]
                },
                {
                    "type": "p",
                    "text": "reactNode: A React node you want to render to HTML. For example, a JSX element like<Page />."
                },
                {
                    "type": "p",
                    "text": "optionaloptions: An object for server render."
                },
                {
                    "type": "list",
                    "items": [
                        "optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "ANode.js Readable Streamthat outputs an HTML string. The resulting HTML can’t be hydrated on the client."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "renderToStaticNodeStreamoutput cannot be hydrated.",
                        "This method will wait for allSuspense boundariesto complete before returning any output.",
                        "As of React 18, this method buffers all of its output, so it doesn’t actually provide any streaming benefits.",
                        "The returned stream is a byte stream encoded in utf-8. If you need a stream in another encoding, take a look at a project likeiconv-lite, which provides transform streams for transcoding text."
                    ]
                },
                {
                    "type": "p",
                    "text": "renderToStaticNodeStreamoutput cannot be hydrated."
                },
                {
                    "type": "p",
                    "text": "This method will wait for allSuspense boundariesto complete before returning any output."
                },
                {
                    "type": "p",
                    "text": "As of React 18, this method buffers all of its output, so it doesn’t actually provide any streaming benefits."
                },
                {
                    "type": "p",
                    "text": "The returned stream is a byte stream encoded in utf-8. If you need a stream in another encoding, take a look at a project likeiconv-lite, which provides transform streams for transcoding text."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rendering a React tree as static HTML to a Node.js Readable Stream"
                },
                {
                    "type": "p",
                    "text": "CallrenderToStaticNodeStreamto get aNode.js Readable Streamwhich you can pipe to your server response:"
                },
                {
                    "type": "code",
                    "code": "import{renderToStaticNodeStream}from'react-dom/server';// The route handler syntax depends on your backend frameworkapp.use('/',(request,response)=>{conststream=renderToStaticNodeStream(<Page/>);stream.pipe(response);});"
                },
                {
                    "type": "p",
                    "text": "The stream will produce the initial non-interactive HTML output of your React components."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "This method rendersnon-interactive HTML that cannot be hydrated.This is useful if you want to use React as a simple static page generator, or if you’re rendering completely static content like emails."
                },
                {
                    "type": "p",
                    "text": "Interactive apps should userenderToPipeableStreamon the server andhydrateRooton the client."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/server/renderToString",
            "title": "renderToString – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "renderToString"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "renderToStringdoes not support streaming or waiting for data.See the alternatives."
                },
                {
                    "type": "p",
                    "text": "renderToStringrenders a React tree to an HTML string."
                },
                {
                    "type": "code",
                    "code": "consthtml=renderToString(reactNode,options?)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferencerenderToString(reactNode, options?)",
                        "renderToString(reactNode, options?)",
                        "UsageRendering a React tree as HTML to a string",
                        "Rendering a React tree as HTML to a string",
                        "AlternativesMigrating fromrenderToStringto a streaming method on the serverRemovingrenderToStringfrom the client code",
                        "Migrating fromrenderToStringto a streaming method on the server",
                        "RemovingrenderToStringfrom the client code",
                        "TroubleshootingWhen a component suspends, the HTML always contains a fallback",
                        "When a component suspends, the HTML always contains a fallback"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "renderToString(reactNode, options?)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Rendering a React tree as HTML to a string"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Migrating fromrenderToStringto a streaming method on the server",
                        "RemovingrenderToStringfrom the client code"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "When a component suspends, the HTML always contains a fallback"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "renderToString(reactNode, options?)"
                },
                {
                    "type": "p",
                    "text": "On the server, callrenderToStringto render your app to HTML."
                },
                {
                    "type": "code",
                    "code": "import{renderToString}from'react-dom/server';consthtml=renderToString(<App/>);"
                },
                {
                    "type": "p",
                    "text": "On the client, callhydrateRootto make the server-generated HTML interactive."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "reactNode: A React node you want to render to HTML. For example, a JSX node like<App />.",
                        "optionaloptions: An object for server render.optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot.",
                        "optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot."
                    ]
                },
                {
                    "type": "p",
                    "text": "reactNode: A React node you want to render to HTML. For example, a JSX node like<App />."
                },
                {
                    "type": "p",
                    "text": "optionaloptions: An object for server render."
                },
                {
                    "type": "list",
                    "items": [
                        "optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "An HTML string."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "renderToStringhas limited Suspense support. If a component suspends,renderToStringimmediately sends its fallback as HTML.",
                        "renderToStringworks in the browser, but using it in the client code isnot recommended."
                    ]
                },
                {
                    "type": "p",
                    "text": "renderToStringhas limited Suspense support. If a component suspends,renderToStringimmediately sends its fallback as HTML."
                },
                {
                    "type": "p",
                    "text": "renderToStringworks in the browser, but using it in the client code isnot recommended."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rendering a React tree as HTML to a string"
                },
                {
                    "type": "p",
                    "text": "CallrenderToStringto render your app to an HTML string which you can send with your server response:"
                },
                {
                    "type": "code",
                    "code": "import{renderToString}from'react-dom/server';// The route handler syntax depends on your backend frameworkapp.use('/',(request,response)=>{consthtml=renderToString(<App/>);response.send(html);});"
                },
                {
                    "type": "p",
                    "text": "This will produce the initial non-interactive HTML output of your React components. On the client, you will need to callhydrateRoottohydratethat server-generated HTML and make it interactive."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "renderToStringdoes not support streaming or waiting for data.See the alternatives."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Alternatives"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Migrating fromrenderToStringto a streaming method on the server"
                },
                {
                    "type": "p",
                    "text": "renderToStringreturns a string immediately, so it does not support streaming or waiting for data."
                },
                {
                    "type": "p",
                    "text": "When possible, we recommend using these fully-featured alternatives:"
                },
                {
                    "type": "list",
                    "items": [
                        "If you use Node.js, userenderToPipeableStream.",
                        "If you use Deno or a modern edge runtime withWeb Streams, userenderToReadableStream."
                    ]
                },
                {
                    "type": "p",
                    "text": "You can continue usingrenderToStringif your server environment does not support streams."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "RemovingrenderToStringfrom the client code"
                },
                {
                    "type": "p",
                    "text": "Sometimes,renderToStringis used on the client to convert some component to HTML."
                },
                {
                    "type": "code",
                    "code": "// 🚩 Unnecessary: using renderToString on the clientimport{renderToString}from'react-dom/server';consthtml=renderToString(<MyIcon/>);console.log(html);// For example, \"<svg>...</svg>\""
                },
                {
                    "type": "p",
                    "text": "Importingreact-dom/serveron the clientunnecessarily increases your bundle size and should be avoided. If you need to render some component to HTML in the browser, usecreateRootand read HTML from the DOM:"
                },
                {
                    "type": "code",
                    "code": "import{createRoot}from'react-dom/client';import{flushSync}from'react-dom';constdiv=document.createElement('div');constroot=createRoot(div);flushSync(()=>{root.render(<MyIcon/>);});console.log(div.innerHTML);// For example, \"<svg>...</svg>\""
                },
                {
                    "type": "p",
                    "text": "TheflushSynccall is necessary so that the DOM is updated before reading itsinnerHTMLproperty."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "When a component suspends, the HTML always contains a fallback"
                },
                {
                    "type": "p",
                    "text": "renderToStringdoes not fully support Suspense."
                },
                {
                    "type": "p",
                    "text": "If some component suspends (for example, because it’s defined withlazyor fetches data),renderToStringwill not wait for its content to resolve. Instead,renderToStringwill find the closest<Suspense>boundary above it and render itsfallbackprop in the HTML. The content will not appear until the client code loads."
                },
                {
                    "type": "p",
                    "text": "To solve this, use one of therecommended streaming solutions.They can stream content in chunks as it resolves on the server so that the user sees the page being progressively filled in before the client code loads."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react-dom/unmountComponentAtNode",
            "title": "unmountComponentAtNode – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "unmountComponentAtNode"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Deprecated"
                },
                {
                    "type": "p",
                    "text": "This API will be removed in a future major version of React."
                },
                {
                    "type": "p",
                    "text": "In React 18,unmountComponentAtNodewas replaced byroot.unmount()."
                },
                {
                    "type": "p",
                    "text": "unmountComponentAtNoderemoves a mounted React component from the DOM."
                },
                {
                    "type": "code",
                    "code": "unmountComponentAtNode(domNode)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceunmountComponentAtNode(domNode)",
                        "unmountComponentAtNode(domNode)",
                        "UsageRemoving a React app from a DOM element",
                        "Removing a React app from a DOM element"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "unmountComponentAtNode(domNode)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Removing a React app from a DOM element"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "unmountComponentAtNode(domNode)"
                },
                {
                    "type": "p",
                    "text": "CallunmountComponentAtNodeto remove a mounted React component from the DOM and clean up its event handlers and state."
                },
                {
                    "type": "code",
                    "code": "import{unmountComponentAtNode}from'react-dom';constdomNode=document.getElementById('root');render(<App/>,domNode);unmountComponentAtNode(domNode);"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "domNode: ADOM element.React will remove a mounted React component from this element."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "unmountComponentAtNodereturnstrueif a component was unmounted andfalseotherwise."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "p",
                    "text": "CallunmountComponentAtNodeto remove amounted React componentfrom abrowser DOM nodeand clean up its event handlers and state."
                },
                {
                    "type": "code",
                    "code": "import{render,unmountComponentAtNode}from'react-dom';importAppfrom'./App.js';constrootNode=document.getElementById('root');render(<App />,rootNode);// ...unmountComponentAtNode(rootNode);"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Removing a React app from a DOM element"
                },
                {
                    "type": "p",
                    "text": "Occasionally, you may want to “sprinkle” React on an existing page, or a page that is not fully written in React. In those cases, you may need to “stop” the React app, by removing all of the UI, state, and listeners from the DOM node it was rendered to."
                },
                {
                    "type": "p",
                    "text": "In this example, clicking “Render React App” will render a React app. Click “Unmount React App” to destroy it:"
                },
                {
                    "type": "code",
                    "code": "import'./styles.css';import{render,unmountComponentAtNode}from'react-dom';importAppfrom'./App.js';constdomNode=document.getElementById('root');document.getElementById('render').addEventListener('click',()=>{render(<App/>,domNode);});document.getElementById('unmount').addEventListener('click',()=>{unmountComponentAtNode(domNode);});"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/Children",
            "title": "Children – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Children"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "UsingChildrenis uncommon and can lead to fragile code.See common alternatives."
                },
                {
                    "type": "p",
                    "text": "Childrenlets you manipulate and transform the JSX you received as thechildrenprop."
                },
                {
                    "type": "code",
                    "code": "constmappedChildren=Children.map(children,child=><divclassName=\"Row\">{child}</div>);"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceChildren.count(children)Children.forEach(children, fn, thisArg?)Children.map(children, fn, thisArg?)Children.only(children)Children.toArray(children)",
                        "Children.count(children)",
                        "Children.forEach(children, fn, thisArg?)",
                        "Children.map(children, fn, thisArg?)",
                        "Children.only(children)",
                        "Children.toArray(children)",
                        "UsageTransforming childrenRunning some code for each childCounting childrenConverting children to an array",
                        "Transforming children",
                        "Running some code for each child",
                        "Counting children",
                        "Converting children to an array",
                        "AlternativesExposing multiple componentsAccepting an array of objects as a propCalling a render prop to customize rendering",
                        "Exposing multiple components",
                        "Accepting an array of objects as a prop",
                        "Calling a render prop to customize rendering",
                        "TroubleshootingI pass a custom component, but theChildrenmethods don’t show its render result",
                        "I pass a custom component, but theChildrenmethods don’t show its render result"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Children.count(children)",
                        "Children.forEach(children, fn, thisArg?)",
                        "Children.map(children, fn, thisArg?)",
                        "Children.only(children)",
                        "Children.toArray(children)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Transforming children",
                        "Running some code for each child",
                        "Counting children",
                        "Converting children to an array"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Exposing multiple components",
                        "Accepting an array of objects as a prop",
                        "Calling a render prop to customize rendering"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "I pass a custom component, but theChildrenmethods don’t show its render result"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Children.count(children)"
                },
                {
                    "type": "p",
                    "text": "CallChildren.count(children)to count the number of children in thechildrendata structure."
                },
                {
                    "type": "code",
                    "code": "import{Children}from'react';functionRowList({children}){return(<><h1>Total rows:{Children.count(children)}</h1>...</>);}"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "children: The value of thechildrenpropreceived by your component."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "The number of nodes inside thesechildren."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Empty nodes (null,undefined, and Booleans), strings, numbers, andReact elementscount as individual nodes. Arrays don’t count as individual nodes, but their children do.The traversal does not go deeper than React elements:they don’t get rendered, and their children aren’t traversed.Fragmentsdon’t get traversed."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Children.forEach(children, fn, thisArg?)"
                },
                {
                    "type": "p",
                    "text": "CallChildren.forEach(children, fn, thisArg?)to run some code for each child in thechildrendata structure."
                },
                {
                    "type": "code",
                    "code": "import{Children}from'react';functionSeparatorList({children}){constresult=[];Children.forEach(children,(child,index)=>{result.push(child);result.push(<hrkey={index}/>);});// ..."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "children: The value of thechildrenpropreceived by your component.",
                        "fn: The function you want to run for each child, similar to thearrayforEachmethodcallback. It will be called with the child as the first argument and its index as the second argument. The index starts at0and increments on each call.",
                        "optionalthisArg: Thethisvaluewith which thefnfunction should be called. If omitted, it’sundefined."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "Children.forEachreturnsundefined."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Empty nodes (null,undefined, and Booleans), strings, numbers, andReact elementscount as individual nodes. Arrays don’t count as individual nodes, but their children do.The traversal does not go deeper than React elements:they don’t get rendered, and their children aren’t traversed.Fragmentsdon’t get traversed."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Children.map(children, fn, thisArg?)"
                },
                {
                    "type": "p",
                    "text": "CallChildren.map(children, fn, thisArg?)to map or transform each child in thechildrendata structure."
                },
                {
                    "type": "code",
                    "code": "import{Children}from'react';functionRowList({children}){return(<divclassName=\"RowList\">{Children.map(children,child=><divclassName=\"Row\">{child}</div>)}</div>);}"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "children: The value of thechildrenpropreceived by your component.",
                        "fn: The mapping function, similar to thearraymapmethodcallback. It will be called with the child as the first argument and its index as the second argument. The index starts at0and increments on each call. You need to return a React node from this function. This may be an empty node (null,undefined, or a Boolean), a string, a number, a React element, or an array of other React nodes.",
                        "optionalthisArg: Thethisvaluewith which thefnfunction should be called. If omitted, it’sundefined."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "Ifchildrenisnullorundefined, returns the same value."
                },
                {
                    "type": "p",
                    "text": "Otherwise, returns a flat array consisting of the nodes you’ve returned from thefnfunction. The returned array will contain all nodes you returned except fornullandundefined."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Empty nodes (null,undefined, and Booleans), strings, numbers, andReact elementscount as individual nodes. Arrays don’t count as individual nodes, but their children do.The traversal does not go deeper than React elements:they don’t get rendered, and their children aren’t traversed.Fragmentsdon’t get traversed.",
                        "If you return an element or an array of elements with keys fromfn,the returned elements’ keys will be automatically combined with the key of the corresponding original item fromchildren.When you return multiple elements fromfnin an array, their keys only need to be unique locally amongst each other."
                    ]
                },
                {
                    "type": "p",
                    "text": "Empty nodes (null,undefined, and Booleans), strings, numbers, andReact elementscount as individual nodes. Arrays don’t count as individual nodes, but their children do.The traversal does not go deeper than React elements:they don’t get rendered, and their children aren’t traversed.Fragmentsdon’t get traversed."
                },
                {
                    "type": "p",
                    "text": "If you return an element or an array of elements with keys fromfn,the returned elements’ keys will be automatically combined with the key of the corresponding original item fromchildren.When you return multiple elements fromfnin an array, their keys only need to be unique locally amongst each other."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Children.only(children)"
                },
                {
                    "type": "p",
                    "text": "CallChildren.only(children)to assert thatchildrenrepresent a single React element."
                },
                {
                    "type": "code",
                    "code": "functionBox({children}){constelement=Children.only(children);// ..."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "children: The value of thechildrenpropreceived by your component."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "Ifchildrenis a valid element,returns that element."
                },
                {
                    "type": "p",
                    "text": "Otherwise, throws an error."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "This method alwaysthrows if you pass an array (such as the return value ofChildren.map) aschildren.In other words, it enforces thatchildrenis a single React element, not that it’s an array with a single element."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Children.toArray(children)"
                },
                {
                    "type": "p",
                    "text": "CallChildren.toArray(children)to create an array out of thechildrendata structure."
                },
                {
                    "type": "code",
                    "code": "import{Children}from'react';exportdefaultfunctionReversedList({children}){constresult=Children.toArray(children);result.reverse();// ..."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "children: The value of thechildrenpropreceived by your component."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "Returns a flat array of elements inchildren."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Empty nodes (null,undefined, and Booleans) will be omitted in the returned array.The returned elements’ keys will be calculated from the original elements’ keys and their level of nesting and position.This ensures that flattening the array does not introduce changes in behavior."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Transforming children"
                },
                {
                    "type": "p",
                    "text": "To transform the children JSX that your componentreceives as thechildrenprop,callChildren.map:"
                },
                {
                    "type": "code",
                    "code": "import{Children}from'react';functionRowList({children}){return(<divclassName=\"RowList\">{Children.map(children,child=><divclassName=\"Row\">{child}</div>)}</div>);}"
                },
                {
                    "type": "p",
                    "text": "In the example above, theRowListwraps every child it receives into a<div className=\"Row\">container. For example, let’s say the parent component passes three<p>tags as thechildrenprop toRowList:"
                },
                {
                    "type": "code",
                    "code": "<RowList><p>This is the first item.</p><p>This is the second item.</p><p>This is the third item.</p></RowList>"
                },
                {
                    "type": "p",
                    "text": "Then, with theRowListimplementation above, the final rendered result will look like this:"
                },
                {
                    "type": "code",
                    "code": "<divclassName=\"RowList\"><divclassName=\"Row\"><p>This is the first item.</p></div><divclassName=\"Row\"><p>This is the second item.</p></div><divclassName=\"Row\"><p>This is the third item.</p></div></div>"
                },
                {
                    "type": "p",
                    "text": "Children.mapis similar toto transforming arrays withmap().The difference is that thechildrendata structure is consideredopaque.This means that even if it’s sometimes an array, you should not assume it’s an array or any other particular data type. This is why you should useChildren.mapif you need to transform it."
                },
                {
                    "type": "code",
                    "code": "import{Children}from'react';exportdefaultfunctionRowList({children}){return(<divclassName=\"RowList\">{Children.map(children,child=><divclassName=\"Row\">{child}</div>)}</div>);}"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Why is the children prop not always an array?"
                },
                {
                    "type": "p",
                    "text": "In React, thechildrenprop is considered anopaquedata structure. This means that you shouldn’t rely on how it is structured. To transform, filter, or count children, you should use theChildrenmethods."
                },
                {
                    "type": "p",
                    "text": "In practice, thechildrendata structure is often represented as an array internally. However, if there is only a single child, then React won’t create an extra array since this would lead to unnecessary memory overhead. As long as you use theChildrenmethods instead of directly introspecting thechildrenprop, your code will not break even if React changes how the data structure is actually implemented."
                },
                {
                    "type": "p",
                    "text": "Even whenchildrenis an array,Children.maphas useful special behavior. For example,Children.mapcombines thekeyson the returned elements with the keys on thechildrenyou’ve passed to it. This ensures the original JSX children don’t “lose” keys even if they get wrapped like in the example above."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Thechildrendata structuredoes not include rendered outputof the components you pass as JSX. In the example below, thechildrenreceived by theRowListonly contains two items rather than three:"
                },
                {
                    "type": "list",
                    "items": [
                        "<p>This is the first item.</p>",
                        "<MoreRows />"
                    ]
                },
                {
                    "type": "p",
                    "text": "This is why only two row wrappers are generated in this example:"
                },
                {
                    "type": "code",
                    "code": "importRowListfrom'./RowList.js';exportdefaultfunctionApp(){return(<RowList><p>This is the first item.</p><MoreRows/></RowList>);}functionMoreRows(){return(<><p>This is the second item.</p><p>This is the third item.</p></>);}"
                },
                {
                    "type": "p",
                    "text": "There is no way to get the rendered output of an inner componentlike<MoreRows />when manipulatingchildren. This is whyit’s usually better to use one of the alternative solutions."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Running some code for each child"
                },
                {
                    "type": "p",
                    "text": "CallChildren.forEachto iterate over each child in thechildrendata structure. It does not return any value and is similar to thearrayforEachmethod.You can use it to run custom logic like constructing your own array."
                },
                {
                    "type": "code",
                    "code": "import{Children}from'react';exportdefaultfunctionSeparatorList({children}){constresult=[];Children.forEach(children,(child,index)=>{result.push(child);result.push(<hrkey={index}/>);});result.pop();// Remove the last separatorreturnresult;}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "As mentioned earlier, there is no way to get the rendered output of an inner component when manipulatingchildren. This is whyit’s usually better to use one of the alternative solutions."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Counting children"
                },
                {
                    "type": "p",
                    "text": "CallChildren.count(children)to calculate the number of children."
                },
                {
                    "type": "code",
                    "code": "import{Children}from'react';exportdefaultfunctionRowList({children}){return(<divclassName=\"RowList\"><h1className=\"RowListHeader\">Total rows:{Children.count(children)}</h1>{Children.map(children,child=><divclassName=\"Row\">{child}</div>)}</div>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "As mentioned earlier, there is no way to get the rendered output of an inner component when manipulatingchildren. This is whyit’s usually better to use one of the alternative solutions."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Converting children to an array"
                },
                {
                    "type": "p",
                    "text": "CallChildren.toArray(children)to turn thechildrendata structure into a regular JavaScript array. This lets you manipulate the array with built-in array methods likefilter,sort, orreverse."
                },
                {
                    "type": "code",
                    "code": "import{Children}from'react';exportdefaultfunctionReversedList({children}){constresult=Children.toArray(children);result.reverse();returnresult;}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "As mentioned earlier, there is no way to get the rendered output of an inner component when manipulatingchildren. This is whyit’s usually better to use one of the alternative solutions."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Alternatives"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "This section describes alternatives to theChildrenAPI (with capitalC) that’s imported like this:"
                },
                {
                    "type": "code",
                    "code": "import{Children}from'react';"
                },
                {
                    "type": "p",
                    "text": "Don’t confuse it withusing thechildrenprop(lowercasec), which is good and encouraged."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Exposing multiple components"
                },
                {
                    "type": "p",
                    "text": "Manipulating children with theChildrenmethods often leads to fragile code. When you pass children to a component in JSX, you don’t usually expect the component to manipulate or transform the individual children."
                },
                {
                    "type": "p",
                    "text": "When you can, try to avoid using theChildrenmethods. For example, if you want every child ofRowListto be wrapped in<div className=\"Row\">, export aRowcomponent, and manually wrap every row into it like this:"
                },
                {
                    "type": "code",
                    "code": "import{RowList,Row}from'./RowList.js';exportdefaultfunctionApp(){return(<RowList><Row><p>This is the first item.</p></Row><Row><p>This is the second item.</p></Row><Row><p>This is the third item.</p></Row></RowList>);}"
                },
                {
                    "type": "p",
                    "text": "Unlike usingChildren.map, this approach does not wrap every child automatically.However, this approach has a significant benefit compared to theearlier example withChildren.mapbecause it works even if you keep extracting more components.For example, it still works if you extract your ownMoreRowscomponent:"
                },
                {
                    "type": "code",
                    "code": "import{RowList,Row}from'./RowList.js';exportdefaultfunctionApp(){return(<RowList><Row><p>This is the first item.</p></Row><MoreRows/></RowList>);}functionMoreRows(){return(<><Row><p>This is the second item.</p></Row><Row><p>This is the third item.</p></Row></>);}"
                },
                {
                    "type": "p",
                    "text": "This wouldn’t work withChildren.mapbecause it would “see”<MoreRows />as a single child (and a single row)."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Accepting an array of objects as a prop"
                },
                {
                    "type": "p",
                    "text": "You can also explicitly pass an array as a prop. For example, thisRowListaccepts arowsarray as a prop:"
                },
                {
                    "type": "code",
                    "code": "import{RowList,Row}from'./RowList.js';exportdefaultfunctionApp(){return(<RowListrows={[{id:'first',content:<p>This is the first item.</p>},{id:'second',content:<p>This is the second item.</p>},{id:'third',content:<p>This is the third item.</p>}]}/>);}"
                },
                {
                    "type": "p",
                    "text": "Sincerowsis a regular JavaScript array, theRowListcomponent can use built-in array methods likemapon it."
                },
                {
                    "type": "p",
                    "text": "This pattern is especially useful when you want to be able to pass more information as structured data together with children. In the below example, theTabSwitchercomponent receives an array of objects as thetabsprop:"
                },
                {
                    "type": "code",
                    "code": "importTabSwitcherfrom'./TabSwitcher.js';exportdefaultfunctionApp(){return(<TabSwitchertabs={[{id:'first',header:'First',content:<p>This is the first item.</p>},{id:'second',header:'Second',content:<p>This is the second item.</p>},{id:'third',header:'Third',content:<p>This is the third item.</p>}]}/>);}"
                },
                {
                    "type": "p",
                    "text": "Unlike passing the children as JSX, this approach lets you associate some extra data likeheaderwith each item. Because you are working with thetabsdirectly, and it is an array, you do not need theChildrenmethods."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Calling a render prop to customize rendering"
                },
                {
                    "type": "p",
                    "text": "Instead of producing JSX for every single item, you can also pass a function that returns JSX, and call that function when necessary. In this example, theAppcomponent passes arenderContentfunction to theTabSwitchercomponent. TheTabSwitchercomponent callsrenderContentonly for the selected tab:"
                },
                {
                    "type": "code",
                    "code": "importTabSwitcherfrom'./TabSwitcher.js';exportdefaultfunctionApp(){return(<TabSwitchertabIds={['first','second','third']}getHeader={tabId=>{returntabId[0].toUpperCase()+tabId.slice(1);}}renderContent={tabId=>{return<p>This is the{tabId}item.</p>;}}/>);}"
                },
                {
                    "type": "p",
                    "text": "A prop likerenderContentis called arender propbecause it is a prop that specifies how to render a piece of the user interface. However, there is nothing special about it: it is a regular prop which happens to be a function."
                },
                {
                    "type": "p",
                    "text": "Render props are functions, so you can pass information to them. For example, thisRowListcomponent passes theidand theindexof each row to therenderRowrender prop, which usesindexto highlight even rows:"
                },
                {
                    "type": "code",
                    "code": "import{RowList,Row}from'./RowList.js';exportdefaultfunctionApp(){return(<RowListrowIds={['first','second','third']}renderRow={(id,index)=>{return(<RowisHighlighted={index%2===0}><p>This is the{id}item.</p></Row>);}}/>);}"
                },
                {
                    "type": "p",
                    "text": "This is another example of how parent and child components can cooperate without manipulating the children."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I pass a custom component, but theChildrenmethods don’t show its render result"
                },
                {
                    "type": "p",
                    "text": "Suppose you pass two children toRowListlike this:"
                },
                {
                    "type": "code",
                    "code": "<RowList><p>First item</p><MoreRows/></RowList>"
                },
                {
                    "type": "p",
                    "text": "If you doChildren.count(children)insideRowList, you will get2. Even ifMoreRowsrenders 10 different items, or if it returnsnull,Children.count(children)will still be2. From theRowList’s perspective, it only “sees” the JSX it has received. It does not “see” the internals of theMoreRowscomponent."
                },
                {
                    "type": "p",
                    "text": "The limitation makes it hard to extract a component. This is whyalternativesare preferred to usingChildren."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/Component",
            "title": "Component – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Component"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "We recommend defining components as functions instead of classes.See how to migrate."
                },
                {
                    "type": "p",
                    "text": "Componentis the base class for the React components defined asJavaScript classes.Class components are still supported by React, but we don’t recommend using them in new code."
                },
                {
                    "type": "code",
                    "code": "classGreetingextendsComponent{render(){return<h1>Hello,{this.props.name}!</h1>;}}"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceComponentcontextpropsrefsstateconstructor(props)componentDidCatch(error, info)componentDidMount()componentDidUpdate(prevProps, prevState, snapshot?)componentWillMount()componentWillReceiveProps(nextProps)componentWillUpdate(nextProps, nextState)componentWillUnmount()forceUpdate(callback?)getChildContext()getSnapshotBeforeUpdate(prevProps, prevState)render()setState(nextState, callback?)shouldComponentUpdate(nextProps, nextState, nextContext)UNSAFE_componentWillMount()UNSAFE_componentWillReceiveProps(nextProps, nextContext)UNSAFE_componentWillUpdate(nextProps, nextState)static childContextTypesstatic contextTypesstatic contextTypestatic defaultPropsstatic propTypesstatic getDerivedStateFromError(error)static getDerivedStateFromProps(props, state)",
                        "Component",
                        "context",
                        "props",
                        "refs",
                        "state",
                        "constructor(props)",
                        "componentDidCatch(error, info)",
                        "componentDidMount()",
                        "componentDidUpdate(prevProps, prevState, snapshot?)",
                        "componentWillMount()",
                        "componentWillReceiveProps(nextProps)",
                        "componentWillUpdate(nextProps, nextState)",
                        "componentWillUnmount()",
                        "forceUpdate(callback?)",
                        "getChildContext()",
                        "getSnapshotBeforeUpdate(prevProps, prevState)",
                        "render()",
                        "setState(nextState, callback?)",
                        "shouldComponentUpdate(nextProps, nextState, nextContext)",
                        "UNSAFE_componentWillMount()",
                        "UNSAFE_componentWillReceiveProps(nextProps, nextContext)",
                        "UNSAFE_componentWillUpdate(nextProps, nextState)",
                        "static childContextTypes",
                        "static contextTypes",
                        "static contextType",
                        "static defaultProps",
                        "static propTypes",
                        "static getDerivedStateFromError(error)",
                        "static getDerivedStateFromProps(props, state)",
                        "UsageDefining a class componentAdding state to a class componentAdding lifecycle methods to a class componentCatching rendering errors with an error boundary",
                        "Defining a class component",
                        "Adding state to a class component",
                        "Adding lifecycle methods to a class component",
                        "Catching rendering errors with an error boundary",
                        "AlternativesMigrating a simple component from a class to a functionMigrating a component with state from a class to a functionMigrating a component with lifecycle methods from a class to a functionMigrating a component with context from a class to a function",
                        "Migrating a simple component from a class to a function",
                        "Migrating a component with state from a class to a function",
                        "Migrating a component with lifecycle methods from a class to a function",
                        "Migrating a component with context from a class to a function"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Component",
                        "context",
                        "props",
                        "refs",
                        "state",
                        "constructor(props)",
                        "componentDidCatch(error, info)",
                        "componentDidMount()",
                        "componentDidUpdate(prevProps, prevState, snapshot?)",
                        "componentWillMount()",
                        "componentWillReceiveProps(nextProps)",
                        "componentWillUpdate(nextProps, nextState)",
                        "componentWillUnmount()",
                        "forceUpdate(callback?)",
                        "getChildContext()",
                        "getSnapshotBeforeUpdate(prevProps, prevState)",
                        "render()",
                        "setState(nextState, callback?)",
                        "shouldComponentUpdate(nextProps, nextState, nextContext)",
                        "UNSAFE_componentWillMount()",
                        "UNSAFE_componentWillReceiveProps(nextProps, nextContext)",
                        "UNSAFE_componentWillUpdate(nextProps, nextState)",
                        "static childContextTypes",
                        "static contextTypes",
                        "static contextType",
                        "static defaultProps",
                        "static propTypes",
                        "static getDerivedStateFromError(error)",
                        "static getDerivedStateFromProps(props, state)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Defining a class component",
                        "Adding state to a class component",
                        "Adding lifecycle methods to a class component",
                        "Catching rendering errors with an error boundary"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Migrating a simple component from a class to a function",
                        "Migrating a component with state from a class to a function",
                        "Migrating a component with lifecycle methods from a class to a function",
                        "Migrating a component with context from a class to a function"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Component"
                },
                {
                    "type": "p",
                    "text": "To define a React component as a class, extend the built-inComponentclass and define arendermethod:"
                },
                {
                    "type": "code",
                    "code": "import{Component}from'react';classGreetingextendsComponent{render(){return<h1>Hello,{this.props.name}!</h1>;}}"
                },
                {
                    "type": "p",
                    "text": "Only therendermethod is required, other methods are optional."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "context"
                },
                {
                    "type": "p",
                    "text": "Thecontextof a class component is available asthis.context. It is only available if you specifywhichcontext you want to receive usingstatic contextType(modern) orstatic contextTypes(deprecated)."
                },
                {
                    "type": "p",
                    "text": "A class component can only read one context at a time."
                },
                {
                    "type": "code",
                    "code": "classButtonextendsComponent{staticcontextType=ThemeContext;render(){consttheme=this.context;constclassName='button-'+theme;return(<buttonclassName={className}>{this.props.children}</button>);}}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Readingthis.contextin class components is equivalent touseContextin function components."
                },
                {
                    "type": "p",
                    "text": "See how to migrate."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "props"
                },
                {
                    "type": "p",
                    "text": "The props passed to a class component are available asthis.props."
                },
                {
                    "type": "code",
                    "code": "classGreetingextendsComponent{render(){return<h1>Hello,{this.props.name}!</h1>;}}<Greetingname=\"Taylor\"/>"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Readingthis.propsin class components is equivalent todeclaring propsin function components."
                },
                {
                    "type": "p",
                    "text": "See how to migrate."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "refs"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Deprecated"
                },
                {
                    "type": "p",
                    "text": "This API will be removed in a future major version of React.UsecreateRefinstead."
                },
                {
                    "type": "p",
                    "text": "Lets you accesslegacy string refsfor this component."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "state"
                },
                {
                    "type": "p",
                    "text": "The state of a class component is available asthis.state. Thestatefield must be an object. Do not mutate the state directly. If you wish to change the state, callsetStatewith the new state."
                },
                {
                    "type": "code",
                    "code": "classCounterextendsComponent{state={age:42,};handleAgeChange=()=>{this.setState({age:this.state.age+1});};render(){return(<><buttononClick={this.handleAgeChange}>Increment age</button><p>You are{this.state.age}.</p></>);}}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Definingstatein class components is equivalent to callinguseStatein function components."
                },
                {
                    "type": "p",
                    "text": "See how to migrate."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "constructor(props)"
                },
                {
                    "type": "p",
                    "text": "Theconstructorruns before your class componentmounts(gets added to the screen). Typically, a constructor is only used for two purposes in React. It lets you declare state andbindyour class methods to the class instance:"
                },
                {
                    "type": "code",
                    "code": "classCounterextendsComponent{constructor(props){super(props);this.state={counter:0};this.handleClick=this.handleClick.bind(this);}handleClick(){// ...}"
                },
                {
                    "type": "p",
                    "text": "If you use modern JavaScript syntax, constructors are rarely needed. Instead, you can rewrite this code above using thepublic class field syntaxwhich is supported both by modern browsers and tools likeBabel:"
                },
                {
                    "type": "code",
                    "code": "classCounterextendsComponent{state={counter:0};handleClick=()=>{// ...}"
                },
                {
                    "type": "p",
                    "text": "A constructor should not contain any side effects or subscriptions."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "props: The component’s initial props."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "constructorshould not return anything."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Do not run any side effects or subscriptions in the constructor. Instead, usecomponentDidMountfor that.",
                        "Inside a constructor, you need to callsuper(props)before any other statement. If you don’t do that,this.propswill beundefinedwhile the constructor runs, which can be confusing and cause bugs.",
                        "Constructor is the only place where you can assignthis.statedirectly. In all other methods, you need to usethis.setState()instead. Do not callsetStatein the constructor.",
                        "When you useserver rendering,the constructor will run on the server too, followed by therendermethod. However, lifecycle methods likecomponentDidMountorcomponentWillUnmountwill not run on the server.",
                        "WhenStrict Modeis on, React will callconstructortwice in development and then throw away one of the instances. This helps you notice the accidental side effects that need to be moved out of theconstructor."
                    ]
                },
                {
                    "type": "p",
                    "text": "Do not run any side effects or subscriptions in the constructor. Instead, usecomponentDidMountfor that."
                },
                {
                    "type": "p",
                    "text": "Inside a constructor, you need to callsuper(props)before any other statement. If you don’t do that,this.propswill beundefinedwhile the constructor runs, which can be confusing and cause bugs."
                },
                {
                    "type": "p",
                    "text": "Constructor is the only place where you can assignthis.statedirectly. In all other methods, you need to usethis.setState()instead. Do not callsetStatein the constructor."
                },
                {
                    "type": "p",
                    "text": "When you useserver rendering,the constructor will run on the server too, followed by therendermethod. However, lifecycle methods likecomponentDidMountorcomponentWillUnmountwill not run on the server."
                },
                {
                    "type": "p",
                    "text": "WhenStrict Modeis on, React will callconstructortwice in development and then throw away one of the instances. This helps you notice the accidental side effects that need to be moved out of theconstructor."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "There is no exact equivalent forconstructorin function components. To declare state in a function component, calluseState.To avoid recalculating the initial state,pass a function touseState."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "componentDidCatch(error, info)"
                },
                {
                    "type": "p",
                    "text": "If you definecomponentDidCatch, React will call it when some child component (including distant children) throws an error during rendering. This lets you log that error to an error reporting service in production."
                },
                {
                    "type": "p",
                    "text": "Typically, it is used together withstatic getDerivedStateFromErrorwhich lets you update state in response to an error and display an error message to the user. A component with these methods is called anerror boundary."
                },
                {
                    "type": "p",
                    "text": "See an example."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "error: The error that was thrown. In practice, it will usually be an instance ofErrorbut this is not guaranteed because JavaScript allows tothrowany value, including strings or evennull.",
                        "info: An object containing additional information about the error. ItscomponentStackfield contains a stack trace with the component that threw, as well as the names and source locations of all its parent components. In production, the component names will be minified. If you set up production error reporting, you can decode the component stack using sourcemaps the same way as you would do for regular JavaScript error stacks."
                    ]
                },
                {
                    "type": "p",
                    "text": "error: The error that was thrown. In practice, it will usually be an instance ofErrorbut this is not guaranteed because JavaScript allows tothrowany value, including strings or evennull."
                },
                {
                    "type": "p",
                    "text": "info: An object containing additional information about the error. ItscomponentStackfield contains a stack trace with the component that threw, as well as the names and source locations of all its parent components. In production, the component names will be minified. If you set up production error reporting, you can decode the component stack using sourcemaps the same way as you would do for regular JavaScript error stacks."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "componentDidCatchshould not return anything."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "In the past, it was common to callsetStateinsidecomponentDidCatchin order to update the UI and display the fallback error message. This is deprecated in favor of definingstatic getDerivedStateFromError.",
                        "Production and development builds of React slightly differ in the waycomponentDidCatchhandles errors. In development, the errors will bubble up towindow, which means that anywindow.onerrororwindow.addEventListener('error', callback)will intercept the errors that have been caught bycomponentDidCatch. In production, instead, the errors will not bubble up, which means any ancestor error handler will only receive errors not explicitly caught bycomponentDidCatch."
                    ]
                },
                {
                    "type": "p",
                    "text": "In the past, it was common to callsetStateinsidecomponentDidCatchin order to update the UI and display the fallback error message. This is deprecated in favor of definingstatic getDerivedStateFromError."
                },
                {
                    "type": "p",
                    "text": "Production and development builds of React slightly differ in the waycomponentDidCatchhandles errors. In development, the errors will bubble up towindow, which means that anywindow.onerrororwindow.addEventListener('error', callback)will intercept the errors that have been caught bycomponentDidCatch. In production, instead, the errors will not bubble up, which means any ancestor error handler will only receive errors not explicitly caught bycomponentDidCatch."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "There is no direct equivalent forcomponentDidCatchin function components yet. If you’d like to avoid creating class components, write a singleErrorBoundarycomponent like above and use it throughout your app. Alternatively, you can use thereact-error-boundarypackage which does that for you."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "componentDidMount()"
                },
                {
                    "type": "p",
                    "text": "If you define thecomponentDidMountmethod, React will call it when your component is added(mounted)to the screen. This is a common place to start data fetching, set up subscriptions, or manipulate the DOM nodes."
                },
                {
                    "type": "p",
                    "text": "If you implementcomponentDidMount, you usually need to implement other lifecycle methods to avoid bugs. For example, ifcomponentDidMountreads some state or props, you also have to implementcomponentDidUpdateto handle their changes, andcomponentWillUnmountto clean up whatevercomponentDidMountwas doing."
                },
                {
                    "type": "code",
                    "code": "classChatRoomextendsComponent{state={serverUrl:'https://localhost:1234'};componentDidMount(){this.setupConnection();}componentDidUpdate(prevProps,prevState){if(this.props.roomId!==prevProps.roomId||this.state.serverUrl!==prevState.serverUrl){this.destroyConnection();this.setupConnection();}}componentWillUnmount(){this.destroyConnection();}// ...}"
                },
                {
                    "type": "p",
                    "text": "See more examples."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "p",
                    "text": "componentDidMountdoes not take any parameters."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "componentDidMountshould not return anything."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "WhenStrict Modeis on, in development React will callcomponentDidMount, then immediately callcomponentWillUnmount,and then callcomponentDidMountagain. This helps you notice if you forgot to implementcomponentWillUnmountor if its logic doesn’t fully “mirror” whatcomponentDidMountdoes.",
                        "Although you may callsetStateimmediately incomponentDidMount, it’s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though therenderwill be called twice in this case, the user won’t see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in theconstructorinstead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position."
                    ]
                },
                {
                    "type": "p",
                    "text": "WhenStrict Modeis on, in development React will callcomponentDidMount, then immediately callcomponentWillUnmount,and then callcomponentDidMountagain. This helps you notice if you forgot to implementcomponentWillUnmountor if its logic doesn’t fully “mirror” whatcomponentDidMountdoes."
                },
                {
                    "type": "p",
                    "text": "Although you may callsetStateimmediately incomponentDidMount, it’s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though therenderwill be called twice in this case, the user won’t see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in theconstructorinstead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "For many use cases, definingcomponentDidMount,componentDidUpdate, andcomponentWillUnmounttogether in class components is equivalent to callinguseEffectin function components. In the rare cases where it’s important for the code to run before browser paint,useLayoutEffectis a closer match."
                },
                {
                    "type": "p",
                    "text": "See how to migrate."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "componentDidUpdate(prevProps, prevState, snapshot?)"
                },
                {
                    "type": "p",
                    "text": "If you define thecomponentDidUpdatemethod, React will call it immediately after your component has been re-rendered with updated props or state.  This method is not called for the initial render."
                },
                {
                    "type": "p",
                    "text": "You can use it to manipulate the DOM after an update. This is also a common place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed). Typically, you’d use it together withcomponentDidMountandcomponentWillUnmount:"
                },
                {
                    "type": "code",
                    "code": "classChatRoomextendsComponent{state={serverUrl:'https://localhost:1234'};componentDidMount(){this.setupConnection();}componentDidUpdate(prevProps,prevState){if(this.props.roomId!==prevProps.roomId||this.state.serverUrl!==prevState.serverUrl){this.destroyConnection();this.setupConnection();}}componentWillUnmount(){this.destroyConnection();}// ...}"
                },
                {
                    "type": "p",
                    "text": "See more examples."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "prevProps: Props before the update. CompareprevPropstothis.propsto determine what changed.",
                        "prevState: State before the update. CompareprevStatetothis.stateto determine what changed.",
                        "snapshot: If you implementedgetSnapshotBeforeUpdate,snapshotwill contain the value you returned from that method. Otherwise, it will beundefined."
                    ]
                },
                {
                    "type": "p",
                    "text": "prevProps: Props before the update. CompareprevPropstothis.propsto determine what changed."
                },
                {
                    "type": "p",
                    "text": "prevState: State before the update. CompareprevStatetothis.stateto determine what changed."
                },
                {
                    "type": "p",
                    "text": "snapshot: If you implementedgetSnapshotBeforeUpdate,snapshotwill contain the value you returned from that method. Otherwise, it will beundefined."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "componentDidUpdateshould not return anything."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "componentDidUpdatewill not get called ifshouldComponentUpdateis defined and returnsfalse.",
                        "The logic insidecomponentDidUpdateshould usually be wrapped in conditions comparingthis.propswithprevProps, andthis.statewithprevState. Otherwise, there’s a risk of creating infinite loops.",
                        "Although you may callsetStateimmediately incomponentDidUpdate, it’s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though therenderwill be called twice in this case, the user won’t see the intermediate state. This pattern often causes performance issues, but it may be necessary for rare cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position."
                    ]
                },
                {
                    "type": "p",
                    "text": "componentDidUpdatewill not get called ifshouldComponentUpdateis defined and returnsfalse."
                },
                {
                    "type": "p",
                    "text": "The logic insidecomponentDidUpdateshould usually be wrapped in conditions comparingthis.propswithprevProps, andthis.statewithprevState. Otherwise, there’s a risk of creating infinite loops."
                },
                {
                    "type": "p",
                    "text": "Although you may callsetStateimmediately incomponentDidUpdate, it’s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though therenderwill be called twice in this case, the user won’t see the intermediate state. This pattern often causes performance issues, but it may be necessary for rare cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "For many use cases, definingcomponentDidMount,componentDidUpdate, andcomponentWillUnmounttogether in class components is equivalent to callinguseEffectin function components. In the rare cases where it’s important for the code to run before browser paint,useLayoutEffectis a closer match."
                },
                {
                    "type": "p",
                    "text": "See how to migrate."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "componentWillMount()"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Deprecated"
                },
                {
                    "type": "p",
                    "text": "This API has been renamed fromcomponentWillMounttoUNSAFE_componentWillMount.The old name has been deprecated. In a future major version of React, only the new name will work."
                },
                {
                    "type": "p",
                    "text": "Run therename-unsafe-lifecyclescodemodto automatically update your components."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "componentWillReceiveProps(nextProps)"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Deprecated"
                },
                {
                    "type": "p",
                    "text": "This API has been renamed fromcomponentWillReceivePropstoUNSAFE_componentWillReceiveProps.The old name has been deprecated. In a future major version of React, only the new name will work."
                },
                {
                    "type": "p",
                    "text": "Run therename-unsafe-lifecyclescodemodto automatically update your components."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "componentWillUpdate(nextProps, nextState)"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Deprecated"
                },
                {
                    "type": "p",
                    "text": "This API has been renamed fromcomponentWillUpdatetoUNSAFE_componentWillUpdate.The old name has been deprecated. In a future major version of React, only the new name will work."
                },
                {
                    "type": "p",
                    "text": "Run therename-unsafe-lifecyclescodemodto automatically update your components."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "componentWillUnmount()"
                },
                {
                    "type": "p",
                    "text": "If you define thecomponentWillUnmountmethod, React will call it before your component is removed(unmounted)from the screen. This is a common place to cancel data fetching or remove subscriptions."
                },
                {
                    "type": "p",
                    "text": "The logic insidecomponentWillUnmountshould “mirror” the logic insidecomponentDidMount.For example, ifcomponentDidMountsets up a subscription,componentWillUnmountshould clean up that subscription. If the cleanup logic in yourcomponentWillUnmountreads some props or state, you will usually also need to implementcomponentDidUpdateto clean up resources (such as subscriptions) corresponding to the old props and state."
                },
                {
                    "type": "code",
                    "code": "classChatRoomextendsComponent{state={serverUrl:'https://localhost:1234'};componentDidMount(){this.setupConnection();}componentDidUpdate(prevProps,prevState){if(this.props.roomId!==prevProps.roomId||this.state.serverUrl!==prevState.serverUrl){this.destroyConnection();this.setupConnection();}}componentWillUnmount(){this.destroyConnection();}// ...}"
                },
                {
                    "type": "p",
                    "text": "See more examples."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "p",
                    "text": "componentWillUnmountdoes not take any parameters."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "componentWillUnmountshould not return anything."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "WhenStrict Modeis on, in development React will callcomponentDidMount,then immediately callcomponentWillUnmount, and then callcomponentDidMountagain. This helps you notice if you forgot to implementcomponentWillUnmountor if its logic doesn’t fully “mirror” whatcomponentDidMountdoes."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "For many use cases, definingcomponentDidMount,componentDidUpdate, andcomponentWillUnmounttogether in class components is equivalent to callinguseEffectin function components. In the rare cases where it’s important for the code to run before browser paint,useLayoutEffectis a closer match."
                },
                {
                    "type": "p",
                    "text": "See how to migrate."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "forceUpdate(callback?)"
                },
                {
                    "type": "p",
                    "text": "Forces a component to re-render."
                },
                {
                    "type": "p",
                    "text": "Usually, this is not necessary. If your component’srendermethod only reads fromthis.props,this.state, orthis.context,it will re-render automatically when you callsetStateinside your component or one of its parents. However, if your component’srendermethod reads directly from an external data source, you have to tell React to update the user interface when that data source changes. That’s whatforceUpdatelets you do."
                },
                {
                    "type": "p",
                    "text": "Try to avoid all uses offorceUpdateand only read fromthis.propsandthis.stateinrender."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "optionalcallbackIf specified, React will call thecallbackyou’ve provided after the update is committed."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "forceUpdatedoes not return anything."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "If you callforceUpdate, React will re-render without callingshouldComponentUpdate."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Reading an external data source and forcing class components to re-render in response to its changes withforceUpdatehas been superseded byuseSyncExternalStorein function components."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "getChildContext()"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Deprecated"
                },
                {
                    "type": "p",
                    "text": "This API will be removed in a future major version of React.UseContext.Providerinstead."
                },
                {
                    "type": "p",
                    "text": "Lets you specify the values for thelegacy contextis provided by this component."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "getSnapshotBeforeUpdate(prevProps, prevState)"
                },
                {
                    "type": "p",
                    "text": "If you implementgetSnapshotBeforeUpdate, React will call it immediately before React updates the DOM. It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle method will be passed as a parameter tocomponentDidUpdate."
                },
                {
                    "type": "p",
                    "text": "For example, you can use it in a UI like a chat thread that needs to preserve its scroll position during updates:"
                },
                {
                    "type": "code",
                    "code": "classScrollingListextendsReact.Component{constructor(props){super(props);this.listRef=React.createRef();}getSnapshotBeforeUpdate(prevProps,prevState){// Are we adding new items to the list?// Capture the scroll position so we can adjust scroll later.if(prevProps.list.length<this.props.list.length){constlist=this.listRef.current;returnlist.scrollHeight-list.scrollTop;}returnnull;}componentDidUpdate(prevProps,prevState,snapshot){// If we have a snapshot value, we've just added new items.// Adjust scroll so these new items don't push the old ones out of view.// (snapshot here is the value returned from getSnapshotBeforeUpdate)if(snapshot!==null){constlist=this.listRef.current;list.scrollTop=list.scrollHeight-snapshot;}}render(){return(<divref={this.listRef}>{/* ...contents... */}</div>);}}"
                },
                {
                    "type": "p",
                    "text": "In the above example, it is important to read thescrollHeightproperty directly ingetSnapshotBeforeUpdate. It is not safe to read it inrender,UNSAFE_componentWillReceiveProps, orUNSAFE_componentWillUpdatebecause there is a potential time gap between these methods getting called and React updating the DOM."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "prevProps: Props before the update. CompareprevPropstothis.propsto determine what changed.",
                        "prevState: State before the update. CompareprevStatetothis.stateto determine what changed."
                    ]
                },
                {
                    "type": "p",
                    "text": "prevProps: Props before the update. CompareprevPropstothis.propsto determine what changed."
                },
                {
                    "type": "p",
                    "text": "prevState: State before the update. CompareprevStatetothis.stateto determine what changed."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "You should return a snapshot value of any type that you’d like, ornull. The value you returned will be passed as the third argument tocomponentDidUpdate."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "getSnapshotBeforeUpdatewill not get called ifshouldComponentUpdateis defined and returnsfalse."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "At the moment, there is no equivalent togetSnapshotBeforeUpdatefor function components. This use case is very uncommon, but if you have the need for it, for now you’ll have to write a class component."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "render()"
                },
                {
                    "type": "p",
                    "text": "Therendermethod is the only required method in a class component."
                },
                {
                    "type": "p",
                    "text": "Therendermethod should specify what you want to appear on the screen, for example:"
                },
                {
                    "type": "code",
                    "code": "import{Component}from'react';classGreetingextendsComponent{render(){return<h1>Hello,{this.props.name}!</h1>;}}"
                },
                {
                    "type": "p",
                    "text": "React may callrenderat any moment, so you shouldn’t assume that it runs at a particular time. Usually, therendermethod should return a piece ofJSX, but a fewother return types(like strings) are supported. To calculate the returned JSX, therendermethod can readthis.props,this.state, andthis.context."
                },
                {
                    "type": "p",
                    "text": "You should write therendermethod as a pure function, meaning that it should return the same result if props, state, and context are the same. It also shouldn’t contain side effects (like setting up subscriptions) or interact with the browser APIs. Side effects should happen either in event handlers or methods likecomponentDidMount."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "p",
                    "text": "renderdoes not take any parameters."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "rendercan return any valid React node. This includes React elements such as<div />, strings, numbers,portals, empty nodes (null,undefined,true, andfalse), and arrays of React nodes."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "rendershould be written as a pure function of props, state, and context. It should not have side effects.",
                        "renderwill not get called ifshouldComponentUpdateis defined and returnsfalse.",
                        "WhenStrict Modeis on, React will callrendertwice in development and then throw away one of the results. This helps you notice the accidental side effects that need to be moved out of therendermethod.",
                        "There is no one-to-one correspondence between therendercall and the subsequentcomponentDidMountorcomponentDidUpdatecall. Some of therendercall results may be discarded by React when it’s beneficial."
                    ]
                },
                {
                    "type": "p",
                    "text": "rendershould be written as a pure function of props, state, and context. It should not have side effects."
                },
                {
                    "type": "p",
                    "text": "renderwill not get called ifshouldComponentUpdateis defined and returnsfalse."
                },
                {
                    "type": "p",
                    "text": "WhenStrict Modeis on, React will callrendertwice in development and then throw away one of the results. This helps you notice the accidental side effects that need to be moved out of therendermethod."
                },
                {
                    "type": "p",
                    "text": "There is no one-to-one correspondence between therendercall and the subsequentcomponentDidMountorcomponentDidUpdatecall. Some of therendercall results may be discarded by React when it’s beneficial."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "setState(nextState, callback?)"
                },
                {
                    "type": "p",
                    "text": "CallsetStateto update the state of your React component."
                },
                {
                    "type": "code",
                    "code": "classFormextendsComponent{state={name:'Taylor',};handleNameChange=(e)=>{constnewName=e.target.value;this.setState({name:newName});}render(){return(<><inputvalue={this.state.name}onChange={this.handleNameChange}/><p>Hello,{this.state.name}.</p></>);}}"
                },
                {
                    "type": "p",
                    "text": "setStateenqueues changes to the component state. It tells React that this component and its children need to re-render with the new state. This is the main way you’ll update the user interface in response to interactions."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "CallingsetStatedoes notchange the current state in the already executing code:"
                },
                {
                    "type": "code",
                    "code": "functionhandleClick(){console.log(this.state.name);// \"Taylor\"this.setState({name:'Robin'});console.log(this.state.name);// Still \"Taylor\"!}"
                },
                {
                    "type": "p",
                    "text": "It only affects whatthis.statewill return starting from thenextrender."
                },
                {
                    "type": "p",
                    "text": "You can also pass a function tosetState. It lets you update state based on the previous state:"
                },
                {
                    "type": "code",
                    "code": "handleIncreaseAge=()=>{this.setState(prevState=>{return{age:prevState.age+1};});}"
                },
                {
                    "type": "p",
                    "text": "You don’t have to do this, but it’s handy if you want to update state multiple times during the same event."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "nextState: Either an object or a function.If you pass an object asnextState, it will be shallowly merged intothis.state.If you pass a function asnextState, it will be treated as anupdater function. It must be pure, should take the pending state and props as arguments, and should return the object to be shallowly merged intothis.state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state.",
                        "If you pass an object asnextState, it will be shallowly merged intothis.state.",
                        "If you pass a function asnextState, it will be treated as anupdater function. It must be pure, should take the pending state and props as arguments, and should return the object to be shallowly merged intothis.state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state.",
                        "optionalcallback: If specified, React will call thecallbackyou’ve provided after the update is committed."
                    ]
                },
                {
                    "type": "p",
                    "text": "nextState: Either an object or a function."
                },
                {
                    "type": "list",
                    "items": [
                        "If you pass an object asnextState, it will be shallowly merged intothis.state.",
                        "If you pass a function asnextState, it will be treated as anupdater function. It must be pure, should take the pending state and props as arguments, and should return the object to be shallowly merged intothis.state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state."
                    ]
                },
                {
                    "type": "p",
                    "text": "optionalcallback: If specified, React will call thecallbackyou’ve provided after the update is committed."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "setStatedoes not return anything."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Think ofsetStateas arequestrather than an immediate command to update the component. When multiple components update their state in response to an event, React will batch their updates and re-render them together in a single pass at the end of the event. In the rare case that you need to force a particular state update to be applied synchronously, you may wrap it influshSync,but this may hurt performance.",
                        "setStatedoes not updatethis.stateimmediately. This makes readingthis.stateright after callingsetStatea potential pitfall. Instead, usecomponentDidUpdateor the setStatecallbackargument, either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, you can pass a function tonextStateas described above."
                    ]
                },
                {
                    "type": "p",
                    "text": "Think ofsetStateas arequestrather than an immediate command to update the component. When multiple components update their state in response to an event, React will batch their updates and re-render them together in a single pass at the end of the event. In the rare case that you need to force a particular state update to be applied synchronously, you may wrap it influshSync,but this may hurt performance."
                },
                {
                    "type": "p",
                    "text": "setStatedoes not updatethis.stateimmediately. This makes readingthis.stateright after callingsetStatea potential pitfall. Instead, usecomponentDidUpdateor the setStatecallbackargument, either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, you can pass a function tonextStateas described above."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "CallingsetStatein class components is similar to calling asetfunctionin function components."
                },
                {
                    "type": "p",
                    "text": "See how to migrate."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "shouldComponentUpdate(nextProps, nextState, nextContext)"
                },
                {
                    "type": "p",
                    "text": "If you defineshouldComponentUpdate, React will call it to determine whether a re-render can be skipped."
                },
                {
                    "type": "p",
                    "text": "If you are confident you want to write it by hand, you may comparethis.propswithnextPropsandthis.statewithnextStateand returnfalseto tell React the update can be skipped."
                },
                {
                    "type": "code",
                    "code": "classRectangleextendsComponent{state={isHovered:false};shouldComponentUpdate(nextProps,nextState){if(nextProps.position.x===this.props.position.x&&nextProps.position.y===this.props.position.y&&nextProps.size.width===this.props.size.width&&nextProps.size.height===this.props.size.height&&nextState.isHovered===this.state.isHovered){// Nothing has changed, so a re-render is unnecessaryreturnfalse;}returntrue;}// ...}"
                },
                {
                    "type": "p",
                    "text": "React callsshouldComponentUpdatebefore rendering when new props or state are being received. Defaults totrue. This method is not called for the initial render or whenforceUpdateis used."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "nextProps: The next props that the component is about to render with. ComparenextPropstothis.propsto determine what changed.",
                        "nextState: The next state that the component is about to render with. ComparenextStatetothis.stateto determine what changed.",
                        "nextContext: The next context that the component is about to render with. ComparenextContexttothis.contextto determine what changed. Only available if you specifystatic contextType(modern) orstatic contextTypes(legacy)."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "Returntrueif you want the component to re-render. That’s the default behavior."
                },
                {
                    "type": "p",
                    "text": "Returnfalseto tell React that re-rendering can be skipped."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "This methodonlyexists as a performance optimization. If your component breaks without it, fix that first.",
                        "Consider usingPureComponentinstead of writingshouldComponentUpdateby hand.PureComponentshallowly compares props and state, and reduces the chance that you’ll skip a necessary update.",
                        "We do not recommend doing deep equality checks or usingJSON.stringifyinshouldComponentUpdate. It makes performance unpredictable and dependent on the data structure of every prop and state. In the best case, you risk introducing multi-second stalls to your application, and in the worst case you risk crashing it.",
                        "Returningfalsedoes not prevent child components from re-rendering whentheirstate changes.",
                        "Returningfalsedoes notguaranteethat the component will not re-render. React will use the return value as a hint but it may still choose to re-render your component if it makes sense to do for other reasons."
                    ]
                },
                {
                    "type": "p",
                    "text": "This methodonlyexists as a performance optimization. If your component breaks without it, fix that first."
                },
                {
                    "type": "p",
                    "text": "Consider usingPureComponentinstead of writingshouldComponentUpdateby hand.PureComponentshallowly compares props and state, and reduces the chance that you’ll skip a necessary update."
                },
                {
                    "type": "p",
                    "text": "We do not recommend doing deep equality checks or usingJSON.stringifyinshouldComponentUpdate. It makes performance unpredictable and dependent on the data structure of every prop and state. In the best case, you risk introducing multi-second stalls to your application, and in the worst case you risk crashing it."
                },
                {
                    "type": "p",
                    "text": "Returningfalsedoes not prevent child components from re-rendering whentheirstate changes."
                },
                {
                    "type": "p",
                    "text": "Returningfalsedoes notguaranteethat the component will not re-render. React will use the return value as a hint but it may still choose to re-render your component if it makes sense to do for other reasons."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Optimizing class components withshouldComponentUpdateis similar to optimizing function components withmemo.Function components also offer more granular optimization withuseMemo."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "UNSAFE_componentWillMount()"
                },
                {
                    "type": "p",
                    "text": "If you defineUNSAFE_componentWillMount, React will call it immediately after theconstructor.It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:"
                },
                {
                    "type": "list",
                    "items": [
                        "To initialize state, declarestateas a class field or setthis.stateinside theconstructor.",
                        "If you need to run a side effect or set up a subscription, move that logic tocomponentDidMountinstead."
                    ]
                },
                {
                    "type": "p",
                    "text": "See examples of migrating away from unsafe lifecycles."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "p",
                    "text": "UNSAFE_componentWillMountdoes not take any parameters."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "UNSAFE_componentWillMountshould not return anything."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "UNSAFE_componentWillMountwill not get called if the component implementsstatic getDerivedStateFromPropsorgetSnapshotBeforeUpdate.",
                        "Despite its naming,UNSAFE_componentWillMountdoes not guarantee that the componentwillget mounted if your app uses modern React features likeSuspense.If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. This is why this method is “unsafe”. Code that relies on mounting (like adding a subscription) should go intocomponentDidMount.",
                        "UNSAFE_componentWillMountis the only lifecycle method that runs duringserver rendering.For all practical purposes, it is identical toconstructor,so you should use theconstructorfor this type of logic instead."
                    ]
                },
                {
                    "type": "p",
                    "text": "UNSAFE_componentWillMountwill not get called if the component implementsstatic getDerivedStateFromPropsorgetSnapshotBeforeUpdate."
                },
                {
                    "type": "p",
                    "text": "Despite its naming,UNSAFE_componentWillMountdoes not guarantee that the componentwillget mounted if your app uses modern React features likeSuspense.If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. This is why this method is “unsafe”. Code that relies on mounting (like adding a subscription) should go intocomponentDidMount."
                },
                {
                    "type": "p",
                    "text": "UNSAFE_componentWillMountis the only lifecycle method that runs duringserver rendering.For all practical purposes, it is identical toconstructor,so you should use theconstructorfor this type of logic instead."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "CallingsetStateinsideUNSAFE_componentWillMountin a class component to initialize state is equivalent to passing that state as the initial state touseStatein a function component."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "UNSAFE_componentWillReceiveProps(nextProps, nextContext)"
                },
                {
                    "type": "p",
                    "text": "If you defineUNSAFE_componentWillReceiveProps, React will call it when the component receives new props. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:"
                },
                {
                    "type": "list",
                    "items": [
                        "If you need torun a side effect(for example, fetch data, run an animation, or reinitialize a subscription) in response to prop changes, move that logic tocomponentDidUpdateinstead.",
                        "If you need toavoid re-computing some data only when a prop changes,use amemoization helperinstead.",
                        "If you need to“reset” some state when a prop changes,consider either making a componentfully controlledorfully uncontrolled with a keyinstead.",
                        "If you need to“adjust” some state when a prop changes,check whether you can compute all the necessary information from props alone during rendering. If you can’t, usestatic getDerivedStateFromPropsinstead."
                    ]
                },
                {
                    "type": "p",
                    "text": "See examples of migrating away from unsafe lifecycles."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "nextProps: The next props that the component is about to receive from its parent component. ComparenextPropstothis.propsto determine what changed.",
                        "nextContext: The next context that the component is about to receive from the closest provider. ComparenextContexttothis.contextto determine what changed. Only available if you specifystatic contextType(modern) orstatic contextTypes(legacy)."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "UNSAFE_componentWillReceivePropsshould not return anything."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "UNSAFE_componentWillReceivePropswill not get called if the component implementsstatic getDerivedStateFromPropsorgetSnapshotBeforeUpdate.",
                        "Despite its naming,UNSAFE_componentWillReceivePropsdoes not guarantee that the componentwillreceive those props if your app uses modern React features likeSuspense.If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props might be different. This is why this method is “unsafe”. Code that should run only for committed updates (like resetting a subscription) should go intocomponentDidUpdate.",
                        "UNSAFE_componentWillReceivePropsdoes not mean that the component has receiveddifferentprops than the last time. You need to comparenextPropsandthis.propsyourself to check if something changed.",
                        "React doesn’t callUNSAFE_componentWillReceivePropswith initial props during mounting. It only calls this method if some of component’s props are going to be updated. For example, callingsetStatedoesn’t generally triggerUNSAFE_componentWillReceivePropsinside the same component."
                    ]
                },
                {
                    "type": "p",
                    "text": "UNSAFE_componentWillReceivePropswill not get called if the component implementsstatic getDerivedStateFromPropsorgetSnapshotBeforeUpdate."
                },
                {
                    "type": "p",
                    "text": "Despite its naming,UNSAFE_componentWillReceivePropsdoes not guarantee that the componentwillreceive those props if your app uses modern React features likeSuspense.If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props might be different. This is why this method is “unsafe”. Code that should run only for committed updates (like resetting a subscription) should go intocomponentDidUpdate."
                },
                {
                    "type": "p",
                    "text": "UNSAFE_componentWillReceivePropsdoes not mean that the component has receiveddifferentprops than the last time. You need to comparenextPropsandthis.propsyourself to check if something changed."
                },
                {
                    "type": "p",
                    "text": "React doesn’t callUNSAFE_componentWillReceivePropswith initial props during mounting. It only calls this method if some of component’s props are going to be updated. For example, callingsetStatedoesn’t generally triggerUNSAFE_componentWillReceivePropsinside the same component."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "CallingsetStateinsideUNSAFE_componentWillReceivePropsin a class component to “adjust” state is equivalent tocalling thesetfunction fromuseStateduring renderingin a function component."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "UNSAFE_componentWillUpdate(nextProps, nextState)"
                },
                {
                    "type": "p",
                    "text": "If you defineUNSAFE_componentWillUpdate, React will call it before rendering with the new props or state. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:"
                },
                {
                    "type": "list",
                    "items": [
                        "If you need to run a side effect (for example, fetch data, run an animation, or reinitialize a subscription) in response to prop or state changes, move that logic tocomponentDidUpdateinstead.",
                        "If you need to read some information from the DOM (for example, to save the current scroll position) so that you can use it incomponentDidUpdatelater, read it insidegetSnapshotBeforeUpdateinstead."
                    ]
                },
                {
                    "type": "p",
                    "text": "See examples of migrating away from unsafe lifecycles."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "nextProps: The next props that the component is about to render with. ComparenextPropstothis.propsto determine what changed.",
                        "nextState: The next state that the component is about to render with. ComparenextStatetothis.stateto determine what changed."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "UNSAFE_componentWillUpdateshould not return anything."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "UNSAFE_componentWillUpdatewill not get called ifshouldComponentUpdateis defined and returnsfalse.",
                        "UNSAFE_componentWillUpdatewill not get called if the component implementsstatic getDerivedStateFromPropsorgetSnapshotBeforeUpdate.",
                        "It’s not supported to callsetState(or any method that leads tosetStatebeing called, like dispatching a Redux action) duringcomponentWillUpdate.",
                        "Despite its naming,UNSAFE_componentWillUpdatedoes not guarantee that the componentwillupdate if your app uses modern React features likeSuspense.If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props and state might be different. This is why this method is “unsafe”. Code that should run only for committed updates (like resetting a subscription) should go intocomponentDidUpdate.",
                        "UNSAFE_componentWillUpdatedoes not mean that the component has receiveddifferentprops or state than the last time. You need to comparenextPropswiththis.propsandnextStatewiththis.stateyourself to check if something changed.",
                        "React doesn’t callUNSAFE_componentWillUpdatewith initial props and state during mounting."
                    ]
                },
                {
                    "type": "p",
                    "text": "UNSAFE_componentWillUpdatewill not get called ifshouldComponentUpdateis defined and returnsfalse."
                },
                {
                    "type": "p",
                    "text": "UNSAFE_componentWillUpdatewill not get called if the component implementsstatic getDerivedStateFromPropsorgetSnapshotBeforeUpdate."
                },
                {
                    "type": "p",
                    "text": "It’s not supported to callsetState(or any method that leads tosetStatebeing called, like dispatching a Redux action) duringcomponentWillUpdate."
                },
                {
                    "type": "p",
                    "text": "Despite its naming,UNSAFE_componentWillUpdatedoes not guarantee that the componentwillupdate if your app uses modern React features likeSuspense.If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props and state might be different. This is why this method is “unsafe”. Code that should run only for committed updates (like resetting a subscription) should go intocomponentDidUpdate."
                },
                {
                    "type": "p",
                    "text": "UNSAFE_componentWillUpdatedoes not mean that the component has receiveddifferentprops or state than the last time. You need to comparenextPropswiththis.propsandnextStatewiththis.stateyourself to check if something changed."
                },
                {
                    "type": "p",
                    "text": "React doesn’t callUNSAFE_componentWillUpdatewith initial props and state during mounting."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "There is no direct equivalent toUNSAFE_componentWillUpdatein function components."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "static childContextTypes"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Deprecated"
                },
                {
                    "type": "p",
                    "text": "This API will be removed in a future major version of React.Usestatic contextTypeinstead."
                },
                {
                    "type": "p",
                    "text": "Lets you specify whichlegacy contextis provided by this component."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "static contextTypes"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Deprecated"
                },
                {
                    "type": "p",
                    "text": "This API will be removed in a future major version of React.Usestatic contextTypeinstead."
                },
                {
                    "type": "p",
                    "text": "Lets you specify whichlegacy contextis consumed by this component."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "static contextType"
                },
                {
                    "type": "p",
                    "text": "If you want to readthis.contextfrom your class component, you must specify which context it needs to read. The context you specify as thestatic contextTypemust be a value previously created bycreateContext."
                },
                {
                    "type": "code",
                    "code": "classButtonextendsComponent{staticcontextType=ThemeContext;render(){consttheme=this.context;constclassName='button-'+theme;return(<buttonclassName={className}>{this.props.children}</button>);}}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Readingthis.contextin class components is equivalent touseContextin function components."
                },
                {
                    "type": "p",
                    "text": "See how to migrate."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "static defaultProps"
                },
                {
                    "type": "p",
                    "text": "You can definestatic defaultPropsto set the default props for the class. They will be used forundefinedand missing props, but not fornullprops."
                },
                {
                    "type": "p",
                    "text": "For example, here is how you define that thecolorprop should default to'blue':"
                },
                {
                    "type": "code",
                    "code": "classButtonextendsComponent{staticdefaultProps={color:'blue'};render(){return<buttonclassName={this.props.color}>click me</button>;}}"
                },
                {
                    "type": "p",
                    "text": "If thecolorprop is not provided or isundefined, it will be set by default to'blue':"
                },
                {
                    "type": "code",
                    "code": "<>{/* this.props.color is \"blue\" */}<Button/>{/* this.props.color is \"blue\" */}<Buttoncolor={undefined}/>{/* this.props.color is null */}<Buttoncolor={null}/>{/* this.props.color is \"red\" */}<Buttoncolor=\"red\"/></>"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "DefiningdefaultPropsin class components is similar to usingdefault valuesin function components."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "static propTypes"
                },
                {
                    "type": "p",
                    "text": "You can definestatic propTypestogether with theprop-typeslibrary to declare the types of the props accepted by your component. These types will be checked during rendering and in development only."
                },
                {
                    "type": "code",
                    "code": "importPropTypesfrom'prop-types';classGreetingextendsReact.Component{staticpropTypes={name:PropTypes.string};render(){return(<h1>Hello,{this.props.name}</h1>);}}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "We recommend usingTypeScriptinstead of checking prop types at runtime."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "static getDerivedStateFromError(error)"
                },
                {
                    "type": "p",
                    "text": "If you definestatic getDerivedStateFromError, React will call it when a child component (including distant children) throws an error during rendering. This lets you display an error message instead of clearing the UI."
                },
                {
                    "type": "p",
                    "text": "Typically, it is used together withcomponentDidCatchwhich lets you send the error report to some analytics service. A component with these methods is called anerror boundary."
                },
                {
                    "type": "p",
                    "text": "See an example."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "error: The error that was thrown. In practice, it will usually be an instance ofErrorbut this is not guaranteed because JavaScript allows tothrowany value, including strings or evennull."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "static getDerivedStateFromErrorshould return the state telling the component to display the error message."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "static getDerivedStateFromErrorshould be a pure function. If you want to perform a side effect (for example, to call an analytics service), you need to also implementcomponentDidCatch."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "There is no direct equivalent forstatic getDerivedStateFromErrorin function components yet. If you’d like to avoid creating class components, write a singleErrorBoundarycomponent like above and use it throughout your app. Alternatively, use thereact-error-boundarypackage which does that."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "static getDerivedStateFromProps(props, state)"
                },
                {
                    "type": "p",
                    "text": "If you definestatic getDerivedStateFromProps, React will call it right before callingrender,both on the initial mount and on subsequent updates. It should return an object to update the state, ornullto update nothing."
                },
                {
                    "type": "p",
                    "text": "This method exists forrare use caseswhere the state depends on changes in props over time. For example, thisFormcomponent resets theemailstate when theuserIDprop changes:"
                },
                {
                    "type": "code",
                    "code": "classFormextendsComponent{state={email:this.props.defaultEmail,prevUserID:this.props.userID};staticgetDerivedStateFromProps(props,state){// Any time the current user changes,// Reset any parts of state that are tied to that user.// In this simple example, that's just the email.if(props.userID!==state.prevUserID){return{prevUserID:props.userID,email:props.defaultEmail};}returnnull;}// ...}"
                },
                {
                    "type": "p",
                    "text": "Note that this pattern requires you to keep a previous value of the prop (likeuserID) in state (likeprevUserID)."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Deriving state leads to verbose code and makes your components difficult to think about.Make sure you’re familiar with simpler alternatives:"
                },
                {
                    "type": "list",
                    "items": [
                        "If you need toperform a side effect(for example, data fetching or an animation) in response to a change in props, usecomponentDidUpdatemethod instead.",
                        "If you want tore-compute some data only when a prop changes,use a memoization helper instead.",
                        "If you want to“reset” some state when a prop changes,consider either making a componentfully controlledorfully uncontrolled with a keyinstead."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "props: The next props that the component is about to render with.",
                        "state: The next state that the component is about to render with."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "static getDerivedStateFromPropsreturn an object to update the state, ornullto update nothing."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "This method is fired oneveryrender, regardless of the cause. This is different fromUNSAFE_componentWillReceiveProps, which only fires when the parent causes a re-render and not as a result of a localsetState.",
                        "This method doesn’t have access to the component instance. If you’d like, you can reuse some code betweenstatic getDerivedStateFromPropsand the other class methods by extracting pure functions of the component props and state outside the class definition."
                    ]
                },
                {
                    "type": "p",
                    "text": "This method is fired oneveryrender, regardless of the cause. This is different fromUNSAFE_componentWillReceiveProps, which only fires when the parent causes a re-render and not as a result of a localsetState."
                },
                {
                    "type": "p",
                    "text": "This method doesn’t have access to the component instance. If you’d like, you can reuse some code betweenstatic getDerivedStateFromPropsand the other class methods by extracting pure functions of the component props and state outside the class definition."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Implementingstatic getDerivedStateFromPropsin a class component is equivalent tocalling thesetfunction fromuseStateduring renderingin a function component."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Defining a class component"
                },
                {
                    "type": "p",
                    "text": "To define a React component as a class, extend the built-inComponentclass and define arendermethod:"
                },
                {
                    "type": "code",
                    "code": "import{Component}from'react';classGreetingextendsComponent{render(){return<h1>Hello,{this.props.name}!</h1>;}}"
                },
                {
                    "type": "p",
                    "text": "React will call yourrendermethod whenever it needs to figure out what to display on the screen. Usually, you will return someJSXfrom it. Yourrendermethod should be apure function:it should only calculate the JSX."
                },
                {
                    "type": "p",
                    "text": "Similarly tofunction components,a class component canreceive information by propsfrom its parent component. However, the syntax for reading props is different. For example, if the parent component renders<Greeting name=\"Taylor\" />, then you can read thenameprop fromthis.props, likethis.props.name:"
                },
                {
                    "type": "code",
                    "code": "import{Component}from'react';classGreetingextendsComponent{render(){return<h1>Hello,{this.props.name}!</h1>;}}exportdefaultfunctionApp(){return(<><Greetingname=\"Sara\"/><Greetingname=\"Cahal\"/><Greetingname=\"Edite\"/></>);}"
                },
                {
                    "type": "p",
                    "text": "Note that Hooks (functions starting withuse, likeuseState) are not supported inside class components."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "We recommend defining components as functions instead of classes.See how to migrate."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Adding state to a class component"
                },
                {
                    "type": "p",
                    "text": "To addstateto a class, assign an object to a property calledstate. To update state, callthis.setState."
                },
                {
                    "type": "code",
                    "code": "import{Component}from'react';exportdefaultclassCounterextendsComponent{state={name:'Taylor',age:42,};handleNameChange=(e)=>{this.setState({name:e.target.value});}handleAgeChange=()=>{this.setState({age:this.state.age+1});};render(){return(<><inputvalue={this.state.name}onChange={this.handleNameChange}/><buttononClick={this.handleAgeChange}>Increment age</button><p>Hello,{this.state.name}. You are{this.state.age}.</p></>);}}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "We recommend defining components as functions instead of classes.See how to migrate."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Adding lifecycle methods to a class component"
                },
                {
                    "type": "p",
                    "text": "There are a few special methods you can define on your class."
                },
                {
                    "type": "p",
                    "text": "If you define thecomponentDidMountmethod, React will call it when your component is added(mounted)to the screen. React will callcomponentDidUpdateafter your component re-renders due to changed props or state. React will callcomponentWillUnmountafter your component has been removed(unmounted)from the screen."
                },
                {
                    "type": "p",
                    "text": "If you implementcomponentDidMount, you usually need to implement all three lifecycles to avoid bugs. For example, ifcomponentDidMountreads some state or props, you also have to implementcomponentDidUpdateto handle their changes, andcomponentWillUnmountto clean up whatevercomponentDidMountwas doing."
                },
                {
                    "type": "p",
                    "text": "For example, thisChatRoomcomponent keeps a chat connection synchronized with props and state:"
                },
                {
                    "type": "code",
                    "code": "import{Component}from'react';import{createConnection}from'./chat.js';exportdefaultclassChatRoomextendsComponent{state={serverUrl:'https://localhost:1234'};componentDidMount(){this.setupConnection();}componentDidUpdate(prevProps,prevState){if(this.props.roomId!==prevProps.roomId||this.state.serverUrl!==prevState.serverUrl){this.destroyConnection();this.setupConnection();}}componentWillUnmount(){this.destroyConnection();}setupConnection(){this.connection=createConnection(this.state.serverUrl,this.props.roomId);this.connection.connect();}destroyConnection(){this.connection.disconnect();this.connection=null;}render(){return(<><label>Server URL:{' '}<inputvalue={this.state.serverUrl}onChange={e=>{this.setState({serverUrl:e.target.value});}}/></label><h1>Welcome to the{this.props.roomId}room!</h1></>);}}"
                },
                {
                    "type": "p",
                    "text": "Note that in development whenStrict Modeis on, React will callcomponentDidMount, immediately callcomponentWillUnmount, and then callcomponentDidMountagain. This helps you notice if you forgot to implementcomponentWillUnmountor if its logic doesn’t fully “mirror” whatcomponentDidMountdoes."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "We recommend defining components as functions instead of classes.See how to migrate."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Catching rendering errors with an error boundary"
                },
                {
                    "type": "p",
                    "text": "By default, if your application throws an error during rendering, React will remove its UI from the screen. To prevent this, you can wrap a part of your UI into anerror boundary. An error boundary is a special component that lets you display some fallback UI instead of the part that crashed—for example, an error message."
                },
                {
                    "type": "p",
                    "text": "To implement an error boundary component, you need to providestatic getDerivedStateFromErrorwhich lets you update state in response to an error and display an error message to the user. You can also optionally implementcomponentDidCatchto add some extra logic, for example, to log the error to an analytics service."
                },
                {
                    "type": "code",
                    "code": "classErrorBoundaryextendsReact.Component{constructor(props){super(props);this.state={hasError:false};}staticgetDerivedStateFromError(error){// Update state so the next render will show the fallback UI.return{hasError:true};}componentDidCatch(error,info){// Example \"componentStack\"://   in ComponentThatThrows (created by App)//   in ErrorBoundary (created by App)//   in div (created by App)//   in ApplogErrorToMyService(error,info.componentStack);}render(){if(this.state.hasError){// You can render any custom fallback UIreturnthis.props.fallback;}returnthis.props.children;}}"
                },
                {
                    "type": "p",
                    "text": "Then you can wrap a part of your component tree with it:"
                },
                {
                    "type": "code",
                    "code": "<ErrorBoundaryfallback={<p>Something went wrong</p>}><Profile/></ErrorBoundary>"
                },
                {
                    "type": "p",
                    "text": "IfProfileor its child component throws an error,ErrorBoundarywill “catch” that error, display a fallback UI with the error message you’ve provided, and send a production error report to your error reporting service."
                },
                {
                    "type": "p",
                    "text": "You don’t need to wrap every component into a separate error boundary. When you think about thegranularity of error boundaries,consider where it makes sense to display an error message. For example, in a messaging app, it makes sense to place an error boundary around the list of conversations. It also makes sense to place one around every individual message. However, it wouldn’t make sense to place a boundary around every avatar."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "There is currently no way to write an error boundary as a function component. However, you don’t have to write the error boundary class yourself. For example, you can usereact-error-boundaryinstead."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Alternatives"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Migrating a simple component from a class to a function"
                },
                {
                    "type": "p",
                    "text": "Typically, you willdefine components as functionsinstead."
                },
                {
                    "type": "p",
                    "text": "For example, suppose you’re converting thisGreetingclass component to a function:"
                },
                {
                    "type": "code",
                    "code": "import{Component}from'react';classGreetingextendsComponent{render(){return<h1>Hello,{this.props.name}!</h1>;}}exportdefaultfunctionApp(){return(<><Greetingname=\"Sara\"/><Greetingname=\"Cahal\"/><Greetingname=\"Edite\"/></>);}"
                },
                {
                    "type": "p",
                    "text": "Define a function calledGreeting. This is where you will move the body of yourrenderfunction."
                },
                {
                    "type": "code",
                    "code": "functionGreeting(){// ... move the code from the render method here ...}"
                },
                {
                    "type": "p",
                    "text": "Instead ofthis.props.name, define thenamepropusing the destructuring syntaxand read it directly:"
                },
                {
                    "type": "code",
                    "code": "functionGreeting({name}){return<h1>Hello,{name}!</h1>;}"
                },
                {
                    "type": "p",
                    "text": "Here is a complete example:"
                },
                {
                    "type": "code",
                    "code": "functionGreeting({name}){return<h1>Hello,{name}!</h1>;}exportdefaultfunctionApp(){return(<><Greetingname=\"Sara\"/><Greetingname=\"Cahal\"/><Greetingname=\"Edite\"/></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Migrating a component with state from a class to a function"
                },
                {
                    "type": "p",
                    "text": "Suppose you’re converting thisCounterclass component to a function:"
                },
                {
                    "type": "code",
                    "code": "import{Component}from'react';exportdefaultclassCounterextendsComponent{state={name:'Taylor',age:42,};handleNameChange=(e)=>{this.setState({name:e.target.value});}handleAgeChange=(e)=>{this.setState({age:this.state.age+1});};render(){return(<><inputvalue={this.state.name}onChange={this.handleNameChange}/><buttononClick={this.handleAgeChange}>Increment age</button><p>Hello,{this.state.name}. You are{this.state.age}.</p></>);}}"
                },
                {
                    "type": "p",
                    "text": "Start by declaring a function with the necessarystate variables:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';functionCounter(){const[name,setName]=useState('Taylor');const[age,setAge]=useState(42);// ..."
                },
                {
                    "type": "p",
                    "text": "Next, convert the event handlers:"
                },
                {
                    "type": "code",
                    "code": "functionCounter(){const[name,setName]=useState('Taylor');const[age,setAge]=useState(42);functionhandleNameChange(e){setName(e.target.value);}functionhandleAgeChange(){setAge(age+1);}// ..."
                },
                {
                    "type": "p",
                    "text": "Finally, replace all references starting withthiswith the variables and functions you defined in your component. For example, replacethis.state.agewithage, and replacethis.handleNameChangewithhandleNameChange."
                },
                {
                    "type": "p",
                    "text": "Here is a fully converted component:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionCounter(){const[name,setName]=useState('Taylor');const[age,setAge]=useState(42);functionhandleNameChange(e){setName(e.target.value);}functionhandleAgeChange(){setAge(age+1);}return(<><inputvalue={name}onChange={handleNameChange}/><buttononClick={handleAgeChange}>Increment age</button><p>Hello,{name}. You are{age}.</p></>)}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Migrating a component with lifecycle methods from a class to a function"
                },
                {
                    "type": "p",
                    "text": "Suppose you’re converting thisChatRoomclass component with lifecycle methods to a function:"
                },
                {
                    "type": "code",
                    "code": "import{Component}from'react';import{createConnection}from'./chat.js';exportdefaultclassChatRoomextendsComponent{state={serverUrl:'https://localhost:1234'};componentDidMount(){this.setupConnection();}componentDidUpdate(prevProps,prevState){if(this.props.roomId!==prevProps.roomId||this.state.serverUrl!==prevState.serverUrl){this.destroyConnection();this.setupConnection();}}componentWillUnmount(){this.destroyConnection();}setupConnection(){this.connection=createConnection(this.state.serverUrl,this.props.roomId);this.connection.connect();}destroyConnection(){this.connection.disconnect();this.connection=null;}render(){return(<><label>Server URL:{' '}<inputvalue={this.state.serverUrl}onChange={e=>{this.setState({serverUrl:e.target.value});}}/></label><h1>Welcome to the{this.props.roomId}room!</h1></>);}}"
                },
                {
                    "type": "p",
                    "text": "First, verify that yourcomponentWillUnmountdoes the opposite ofcomponentDidMount.In the above example, that’s true: it disconnects the connection thatcomponentDidMountsets up. If such logic is missing, add it first."
                },
                {
                    "type": "p",
                    "text": "Next, verify that yourcomponentDidUpdatemethod handles changes to any props and state you’re using incomponentDidMount. In the above example,componentDidMountcallssetupConnectionwhich readsthis.state.serverUrlandthis.props.roomId. This is whycomponentDidUpdatechecks whetherthis.state.serverUrlandthis.props.roomIdhave changed, and resets the connection if they did. If yourcomponentDidUpdatelogic is missing or doesn’t handle changes to all relevant props and state, fix that first."
                },
                {
                    "type": "p",
                    "text": "In the above example, the logic inside the lifecycle methods connects the component to a system outside of React (a chat server). To connect a component to an external system,describe this logic as a single Effect:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';functionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{connection.disconnect();};},[serverUrl,roomId]);// ...}"
                },
                {
                    "type": "p",
                    "text": "ThisuseEffectcall is equivalent to the logic in the lifecycle methods above. If your lifecycle methods do multiple unrelated things,split them into multiple independent Effects.Here is a complete example you can play with:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection}from'./chat.js';exportdefaultfunctionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{connection.disconnect();};},[roomId,serverUrl]);return(<><label>Server URL:{' '}<inputvalue={serverUrl}onChange={e=>setServerUrl(e.target.value)}/></label><h1>Welcome to the{roomId}room!</h1></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "If your component does not synchronize with any external systems,you might not need an Effect."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Migrating a component with context from a class to a function"
                },
                {
                    "type": "p",
                    "text": "In this example, thePanelandButtonclass components readcontextfromthis.context:"
                },
                {
                    "type": "code",
                    "code": "import{createContext,Component}from'react';constThemeContext=createContext(null);classPanelextendsComponent{staticcontextType=ThemeContext;render(){consttheme=this.context;constclassName='panel-'+theme;return(<sectionclassName={className}><h1>{this.props.title}</h1>{this.props.children}</section>);}}classButtonextendsComponent{staticcontextType=ThemeContext;render(){consttheme=this.context;constclassName='button-'+theme;return(<buttonclassName={className}>{this.props.children}</button>);}}functionForm(){return(<Paneltitle=\"Welcome\"><Button>Sign up</Button><Button>Log in</Button></Panel>);}exportdefaultfunctionMyApp(){return(<ThemeContext.Providervalue=\"dark\"><Form/></ThemeContext.Provider>)}"
                },
                {
                    "type": "p",
                    "text": "When you convert them to function components, replacethis.contextwithuseContextcalls:"
                },
                {
                    "type": "code",
                    "code": "import{createContext,useContext}from'react';constThemeContext=createContext(null);functionPanel({title,children}){consttheme=useContext(ThemeContext);constclassName='panel-'+theme;return(<sectionclassName={className}><h1>{title}</h1>{children}</section>)}functionButton({children}){consttheme=useContext(ThemeContext);constclassName='button-'+theme;return(<buttonclassName={className}>{children}</button>);}functionForm(){return(<Paneltitle=\"Welcome\"><Button>Sign up</Button><Button>Log in</Button></Panel>);}exportdefaultfunctionMyApp(){return(<ThemeContext.Providervalue=\"dark\"><Form/></ThemeContext.Provider>)}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/Fragment",
            "title": "<Fragment> (<>...</>) – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "<Fragment> (<>...</>)"
                },
                {
                    "type": "p",
                    "text": "<Fragment>, often used via<>...</>syntax, lets you group elements without a wrapper node."
                },
                {
                    "type": "code",
                    "code": "<><OneChild/><AnotherChild/></>"
                },
                {
                    "type": "list",
                    "items": [
                        "Reference<Fragment>",
                        "<Fragment>",
                        "UsageReturning multiple elementsAssigning multiple elements to a variableGrouping elements with textRendering a list of Fragments",
                        "Returning multiple elements",
                        "Assigning multiple elements to a variable",
                        "Grouping elements with text",
                        "Rendering a list of Fragments"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "<Fragment>"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Returning multiple elements",
                        "Assigning multiple elements to a variable",
                        "Grouping elements with text",
                        "Rendering a list of Fragments"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "<Fragment>"
                },
                {
                    "type": "p",
                    "text": "Wrap elements in<Fragment>to group them together in situations where you need a single element. Grouping elements inFragmenthas no effect on the resulting DOM; it is the same as if the elements were not grouped. The empty JSX tag<></>is shorthand for<Fragment></Fragment>in most cases."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Props"
                },
                {
                    "type": "list",
                    "items": [
                        "optionalkey: Fragments declared with the explicit<Fragment>syntax may havekeys."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "If you want to passkeyto a Fragment, you can’t use the<>...</>syntax. You have to explicitly importFragmentfrom'react'and render<Fragment key={yourKey}>...</Fragment>.",
                        "React does notreset statewhen you go from rendering<><Child /></>to[<Child />]or back, or when you go from rendering<><Child /></>to<Child />and back. This only works a single level deep: for example, going from<><><Child /></></>to<Child />resets the state. See the precise semanticshere."
                    ]
                },
                {
                    "type": "p",
                    "text": "If you want to passkeyto a Fragment, you can’t use the<>...</>syntax. You have to explicitly importFragmentfrom'react'and render<Fragment key={yourKey}>...</Fragment>."
                },
                {
                    "type": "p",
                    "text": "React does notreset statewhen you go from rendering<><Child /></>to[<Child />]or back, or when you go from rendering<><Child /></>to<Child />and back. This only works a single level deep: for example, going from<><><Child /></></>to<Child />resets the state. See the precise semanticshere."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Returning multiple elements"
                },
                {
                    "type": "p",
                    "text": "UseFragment, or the equivalent<>...</>syntax, to group multiple elements together. You can use it to put multiple elements in any place where a single element can go. For example, a component can only return one element, but by using a Fragment you can group multiple elements together and then return them as a group:"
                },
                {
                    "type": "code",
                    "code": "functionPost(){return(<><PostTitle/><PostBody/></>);}"
                },
                {
                    "type": "p",
                    "text": "Fragments are useful because grouping elements with a Fragment has no effect on layout or styles, unlike if you wrapped the elements in another container like a DOM element. If you inspect this example with the browser tools, you’ll see that all<h1>and<article>DOM nodes appear as siblings without wrappers around them:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionBlog(){return(<><Posttitle=\"An update\"body=\"It's been a while since I posted...\"/><Posttitle=\"My new blog\"body=\"I am starting a new blog!\"/></>)}functionPost({title,body}){return(<><PostTitletitle={title}/><PostBodybody={body}/></>);}functionPostTitle({title}){return<h1>{title}</h1>}functionPostBody({body}){return(<article><p>{body}</p></article>);}"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "How to write a Fragment without the special syntax?"
                },
                {
                    "type": "p",
                    "text": "The example above is equivalent to importingFragmentfrom React:"
                },
                {
                    "type": "code",
                    "code": "import{Fragment}from'react';functionPost(){return(<Fragment><PostTitle/><PostBody/></Fragment>);}"
                },
                {
                    "type": "p",
                    "text": "Usually you won’t need this unless you need topass akeyto yourFragment."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Assigning multiple elements to a variable"
                },
                {
                    "type": "p",
                    "text": "Like any other element, you can assign Fragment elements to variables, pass them as props, and so on:"
                },
                {
                    "type": "code",
                    "code": "functionCloseDialog(){constbuttons=(<><OKButton/><CancelButton/></>);return(<AlertDialogbuttons={buttons}>Are you sure you want to leave this page?</AlertDialog>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Grouping elements with text"
                },
                {
                    "type": "p",
                    "text": "You can useFragmentto group text together with components:"
                },
                {
                    "type": "code",
                    "code": "functionDateRangePicker({start,end}){return(<>From<DatePickerdate={start}/>to<DatePickerdate={end}/></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rendering a list of Fragments"
                },
                {
                    "type": "p",
                    "text": "Here’s a situation where you need to writeFragmentexplicitly instead of using the<></>syntax. When yourender multiple elements in a loop, you need to assign akeyto each element. If the elements within the loop are Fragments, you need to use the normal JSX element syntax in order to provide thekeyattribute:"
                },
                {
                    "type": "code",
                    "code": "functionBlog(){returnposts.map(post=><Fragmentkey={post.id}><PostTitletitle={post.title}/><PostBodybody={post.body}/></Fragment>);}"
                },
                {
                    "type": "p",
                    "text": "You can inspect the DOM to verify that there are no wrapper elements around the Fragment children:"
                },
                {
                    "type": "code",
                    "code": "import{Fragment}from'react';constposts=[{id:1,title:'An update',body:\"It's been a while since I posted...\"},{id:2,title:'My new blog',body:'I am starting a new blog!'}];exportdefaultfunctionBlog(){returnposts.map(post=><Fragmentkey={post.id}><PostTitletitle={post.title}/><PostBodybody={post.body}/></Fragment>);}functionPostTitle({title}){return<h1>{title}</h1>}functionPostBody({body}){return(<article><p>{body}</p></article>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/Profiler",
            "title": "<Profiler> – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "<Profiler>"
                },
                {
                    "type": "p",
                    "text": "<Profiler>lets you measure rendering performance of a React tree programmatically."
                },
                {
                    "type": "code",
                    "code": "<Profilerid=\"App\"onRender={onRender}><App/></Profiler>"
                },
                {
                    "type": "list",
                    "items": [
                        "Reference<Profiler>onRendercallback",
                        "<Profiler>",
                        "onRendercallback",
                        "UsageMeasuring rendering performance programmaticallyMeasuring different parts of the application",
                        "Measuring rendering performance programmatically",
                        "Measuring different parts of the application"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "<Profiler>",
                        "onRendercallback"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Measuring rendering performance programmatically",
                        "Measuring different parts of the application"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "<Profiler>"
                },
                {
                    "type": "p",
                    "text": "Wrap a component tree in a<Profiler>to measure its rendering performance."
                },
                {
                    "type": "code",
                    "code": "<Profilerid=\"App\"onRender={onRender}><App/></Profiler>"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Props"
                },
                {
                    "type": "list",
                    "items": [
                        "id: A string identifying the part of the UI you are measuring.",
                        "onRender: AnonRendercallbackthat React calls every time components within the profiled tree update. It receives information about what was rendered and how much time it took."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Profiling adds some additional overhead, soit is disabled in the production build by default.To opt into production profiling, you need to enable aspecial production build with profiling enabled."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "onRendercallback"
                },
                {
                    "type": "p",
                    "text": "React will call youronRendercallback with information about what was rendered."
                },
                {
                    "type": "code",
                    "code": "functiononRender(id,phase,actualDuration,baseDuration,startTime,commitTime){// Aggregate or log render timings...}"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "id: The stringidprop of the<Profiler>tree that has just committed. This lets you identify which part of the tree was committed if you are using multiple profilers.",
                        "phase:\"mount\",\"update\"or\"nested-update\". This lets you know whether the tree has just been mounted for the first time or re-rendered due to a change in props, state, or Hooks.",
                        "actualDuration: The number of milliseconds spent rendering the<Profiler>and its descendants for the current update. This indicates how well the subtree makes use of memoization (e.g.memoanduseMemo). Ideally this value should decrease significantly after the initial mount as many of the descendants will only need to re-render if their specific props change.",
                        "baseDuration: The number of milliseconds estimating how much time it would take to re-render the entire<Profiler>subtree without any optimizations. It is calculated by summing up the most recent render durations of each component in the tree. This value estimates a worst-case cost of rendering (e.g. the initial mount or a tree with no memoization). CompareactualDurationagainst it to see if memoization is working.",
                        "startTime: A numeric timestamp for when React began rendering the current update.",
                        "commitTime: A numeric timestamp for when React committed the current update. This value is shared between all profilers in a commit, enabling them to be grouped if desirable."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Measuring rendering performance programmatically"
                },
                {
                    "type": "p",
                    "text": "Wrap the<Profiler>component around a React tree to measure its rendering performance."
                },
                {
                    "type": "code",
                    "code": "<App><Profilerid=\"Sidebar\"onRender={onRender}><Sidebar/></Profiler><PageContent/></App>"
                },
                {
                    "type": "p",
                    "text": "It requires two props: anid(string) and anonRendercallback (function) which React calls any time a component within the tree “commits” an update."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Profiling adds some additional overhead, soit is disabled in the production build by default.To opt into production profiling, you need to enable aspecial production build with profiling enabled."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "<Profiler>lets you gather measurements programmatically. If you’re looking for an interactive profiler, try the Profiler tab inReact Developer Tools. It exposes similar functionality as a browser extension."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Measuring different parts of the application"
                },
                {
                    "type": "p",
                    "text": "You can use multiple<Profiler>components to measure different parts of your application:"
                },
                {
                    "type": "code",
                    "code": "<App><Profilerid=\"Sidebar\"onRender={onRender}><Sidebar/></Profiler><Profilerid=\"Content\"onRender={onRender}><Content/></Profiler></App>"
                },
                {
                    "type": "p",
                    "text": "You can also nest<Profiler>components:"
                },
                {
                    "type": "code",
                    "code": "<App><Profilerid=\"Sidebar\"onRender={onRender}><Sidebar/></Profiler><Profilerid=\"Content\"onRender={onRender}><Content><Profilerid=\"Editor\"onRender={onRender}><Editor/></Profiler><Preview/></Content></Profiler></App>"
                },
                {
                    "type": "p",
                    "text": "Although<Profiler>is a lightweight component, it should be used only when necessary. Each use adds some CPU and memory overhead to an application."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/PureComponent",
            "title": "PureComponent – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "PureComponent"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "We recommend defining components as functions instead of classes.See how to migrate."
                },
                {
                    "type": "p",
                    "text": "PureComponentis similar toComponentbut it skips re-renders for same props and state. Class components are still supported by React, but we don’t recommend using them in new code."
                },
                {
                    "type": "code",
                    "code": "classGreetingextendsPureComponent{render(){return<h1>Hello,{this.props.name}!</h1>;}}"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferencePureComponent",
                        "PureComponent",
                        "UsageSkipping unnecessary re-renders for class components",
                        "Skipping unnecessary re-renders for class components",
                        "AlternativesMigrating from aPureComponentclass component to a function",
                        "Migrating from aPureComponentclass component to a function"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "PureComponent"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Skipping unnecessary re-renders for class components"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Migrating from aPureComponentclass component to a function"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "PureComponent"
                },
                {
                    "type": "p",
                    "text": "To skip re-rendering a class component for same props and state, extendPureComponentinstead ofComponent:"
                },
                {
                    "type": "code",
                    "code": "import{PureComponent}from'react';classGreetingextendsPureComponent{render(){return<h1>Hello,{this.props.name}!</h1>;}}"
                },
                {
                    "type": "p",
                    "text": "PureComponentis a subclass ofComponentand supportsall theComponentAPIs.ExtendingPureComponentis equivalent to defining a customshouldComponentUpdatemethod that shallowly compares props and state."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Skipping unnecessary re-renders for class components"
                },
                {
                    "type": "p",
                    "text": "React normally re-renders a component whenever its parent re-renders. As an optimization, you can create a component that React will not re-render when its parent re-renders so long as its new props and state are the same as the old props and state.Class componentscan opt into this behavior by extendingPureComponent:"
                },
                {
                    "type": "code",
                    "code": "classGreetingextendsPureComponent{render(){return<h1>Hello,{this.props.name}!</h1>;}}"
                },
                {
                    "type": "p",
                    "text": "A React component should always havepure rendering logic.This means that it must return the same output if its props, state, and context haven’t changed. By usingPureComponent, you are telling React that your component complies with this requirement, so React doesn’t need to re-render as long as its props and state haven’t changed. However, your component will still re-render if a context that it’s using changes."
                },
                {
                    "type": "p",
                    "text": "In this example, notice that theGreetingcomponent re-renders whenevernameis changed (because that’s one of its props), but not whenaddressis changed (because it’s not passed toGreetingas a prop):"
                },
                {
                    "type": "code",
                    "code": "import{PureComponent,useState}from'react';classGreetingextendsPureComponent{render(){console.log(\"Greeting was rendered at\",newDate().toLocaleTimeString());return<h3>Hello{this.props.name&&', '}{this.props.name}!</h3>;}}exportdefaultfunctionMyApp(){const[name,setName]=useState('');const[address,setAddress]=useState('');return(<><label>Name{': '}<inputvalue={name}onChange={e=>setName(e.target.value)}/></label><label>Address{': '}<inputvalue={address}onChange={e=>setAddress(e.target.value)}/></label><Greetingname={name}/></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "We recommend defining components as functions instead of classes.See how to migrate."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Alternatives"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Migrating from aPureComponentclass component to a function"
                },
                {
                    "type": "p",
                    "text": "We recommend using function components instead ofclass componentsin new code. If you have some existing class components usingPureComponent, here is how you can convert them. This is the original code:"
                },
                {
                    "type": "code",
                    "code": "import{PureComponent,useState}from'react';classGreetingextendsPureComponent{render(){console.log(\"Greeting was rendered at\",newDate().toLocaleTimeString());return<h3>Hello{this.props.name&&', '}{this.props.name}!</h3>;}}exportdefaultfunctionMyApp(){const[name,setName]=useState('');const[address,setAddress]=useState('');return(<><label>Name{': '}<inputvalue={name}onChange={e=>setName(e.target.value)}/></label><label>Address{': '}<inputvalue={address}onChange={e=>setAddress(e.target.value)}/></label><Greetingname={name}/></>);}"
                },
                {
                    "type": "p",
                    "text": "When youconvert this component from a class to a function,wrap it inmemo:"
                },
                {
                    "type": "code",
                    "code": "import{memo,useState}from'react';constGreeting=memo(functionGreeting({name}){console.log(\"Greeting was rendered at\",newDate().toLocaleTimeString());return<h3>Hello{name&&', '}{name}!</h3>;});exportdefaultfunctionMyApp(){const[name,setName]=useState('');const[address,setAddress]=useState('');return(<><label>Name{': '}<inputvalue={name}onChange={e=>setName(e.target.value)}/></label><label>Address{': '}<inputvalue={address}onChange={e=>setAddress(e.target.value)}/></label><Greetingname={name}/></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "UnlikePureComponent,memodoes not compare the new and the old state. In function components, calling thesetfunctionwith the same statealready prevents re-renders by default,even withoutmemo."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/StrictMode",
            "title": "<StrictMode> – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "<StrictMode>"
                },
                {
                    "type": "p",
                    "text": "<StrictMode>lets you find common bugs in your components early during development."
                },
                {
                    "type": "code",
                    "code": "<StrictMode><App/></StrictMode>"
                },
                {
                    "type": "list",
                    "items": [
                        "Reference<StrictMode>",
                        "<StrictMode>",
                        "UsageEnabling Strict Mode for entire appEnabling Strict Mode for a part of the appFixing bugs found by double rendering in developmentFixing bugs found by re-running Effects in developmentFixing deprecation warnings enabled by Strict Mode",
                        "Enabling Strict Mode for entire app",
                        "Enabling Strict Mode for a part of the app",
                        "Fixing bugs found by double rendering in development",
                        "Fixing bugs found by re-running Effects in development",
                        "Fixing deprecation warnings enabled by Strict Mode"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "<StrictMode>"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Enabling Strict Mode for entire app",
                        "Enabling Strict Mode for a part of the app",
                        "Fixing bugs found by double rendering in development",
                        "Fixing bugs found by re-running Effects in development",
                        "Fixing deprecation warnings enabled by Strict Mode"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "<StrictMode>"
                },
                {
                    "type": "p",
                    "text": "UseStrictModeto enable additional development behaviors and warnings for the component tree inside:"
                },
                {
                    "type": "code",
                    "code": "import{StrictMode}from'react';import{createRoot}from'react-dom/client';constroot=createRoot(document.getElementById('root'));root.render(<StrictMode><App/></StrictMode>);"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "p",
                    "text": "Strict Mode enables the following development-only behaviors:"
                },
                {
                    "type": "list",
                    "items": [
                        "Your components willre-render an extra timeto find bugs caused by impure rendering.",
                        "Your components willre-run Effects an extra timeto find bugs caused by missing Effect cleanup.",
                        "Your components willbe checked for usage of deprecated APIs."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Props"
                },
                {
                    "type": "p",
                    "text": "StrictModeaccepts no props."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "There is no way to opt out of Strict Mode inside a tree wrapped in<StrictMode>. This gives you confidence that all components inside<StrictMode>are checked. If two teams working on a product disagree whether they find the checks valuable, they need to either reach consensus or move<StrictMode>down in the tree."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Enabling Strict Mode for entire app"
                },
                {
                    "type": "p",
                    "text": "Strict Mode enables extra development-only checks for the entire component tree inside the<StrictMode>component. These checks help you find common bugs in your components early in the development process."
                },
                {
                    "type": "p",
                    "text": "To enable Strict Mode for your entire app, wrap your root component with<StrictMode>when you render it:"
                },
                {
                    "type": "code",
                    "code": "import{StrictMode}from'react';import{createRoot}from'react-dom/client';constroot=createRoot(document.getElementById('root'));root.render(<StrictMode><App/></StrictMode>);"
                },
                {
                    "type": "p",
                    "text": "We recommend wrapping your entire app in Strict Mode, especially for newly created apps. If you use a framework that callscreateRootfor you, check its documentation for how to enable Strict Mode."
                },
                {
                    "type": "p",
                    "text": "Although the Strict Mode checksonly run in development,they help you find bugs that already exist in your code but can be tricky to reliably reproduce in production. Strict Mode lets you fix bugs before your users report them."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Strict Mode enables the following checks in development:"
                },
                {
                    "type": "list",
                    "items": [
                        "Your components willre-render an extra timeto find bugs caused by impure rendering.",
                        "Your components willre-run Effects an extra timeto find bugs caused by missing Effect cleanup.",
                        "Your components willbe checked for usage of deprecated APIs."
                    ]
                },
                {
                    "type": "p",
                    "text": "All of these checks are development-only and do not impact the production build."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Enabling Strict Mode for a part of the app"
                },
                {
                    "type": "p",
                    "text": "You can also enable Strict Mode for any part of your application:"
                },
                {
                    "type": "code",
                    "code": "import{StrictMode}from'react';functionApp(){return(<><Header/><StrictMode><main><Sidebar/><Content/></main></StrictMode><Footer/></>);}"
                },
                {
                    "type": "p",
                    "text": "In this example, Strict Mode checks will not run against theHeaderandFootercomponents. However, they will run onSidebarandContent, as well as all of the components inside them, no matter how deep."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Fixing bugs found by double rendering in development"
                },
                {
                    "type": "p",
                    "text": "React assumes that every component you write is a pure function.This means that React components you write must always return the same JSX given the same inputs (props, state, and context)."
                },
                {
                    "type": "p",
                    "text": "Components breaking this rule behave unpredictably and cause bugs. To help you find accidentally impure code, Strict Mode calls some of your functions (only the ones that should be pure)twice in development.This includes:"
                },
                {
                    "type": "list",
                    "items": [
                        "Your component function body (only top-level logic, so this doesn’t include code inside event handlers)",
                        "Functions that you pass touseState,setfunctions,useMemo, oruseReducer",
                        "Some class component methods likeconstructor,render,shouldComponentUpdate(see the whole list)"
                    ]
                },
                {
                    "type": "p",
                    "text": "If a function is pure, running it twice does not change its behavior because a pure function produces the same result every time. However, if a function is impure (for example, it mutates the data it receives), running it twice tends to be noticeable (that’s what makes it impure!) This helps you spot and fix the bug early."
                },
                {
                    "type": "p",
                    "text": "Here is an example to illustrate how double rendering in Strict Mode helps you find bugs early."
                },
                {
                    "type": "p",
                    "text": "ThisStoryTraycomponent takes an array ofstoriesand adds one last “Create Story” item at the end:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionStoryTray({stories}){constitems=stories;items.push({id:'create',label:'Create Story'});return(<ul>{items.map(story=>(<likey={story.id}>{story.label}</li>))}</ul>);}"
                },
                {
                    "type": "p",
                    "text": "There is a mistake in the code above. However, it is easy to miss because the initial output appears correct."
                },
                {
                    "type": "p",
                    "text": "This mistake will become more noticeable if theStoryTraycomponent re-renders multiple times. For example, let’s make theStoryTrayre-render with a different background color whenever you hover over it:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionStoryTray({stories}){const[isHover,setIsHover]=useState(false);constitems=stories;items.push({id:'create',label:'Create Story'});return(<ulonPointerEnter={()=>setIsHover(true)}onPointerLeave={()=>setIsHover(false)}style={{backgroundColor:isHover?'#ddd':'#fff'}}>{items.map(story=>(<likey={story.id}>{story.label}</li>))}</ul>);}"
                },
                {
                    "type": "p",
                    "text": "Notice how every time you hover over theStoryTraycomponent, “Create Story” gets added to the list again. The intention of the code was to add it once at the end. ButStoryTraydirectly modifies thestoriesarray from the props. Every timeStoryTrayrenders, it adds “Create Story” again at the end of the same array. In other words,StoryTrayis not a pure function—running it multiple times produces different results."
                },
                {
                    "type": "p",
                    "text": "To fix this problem, you can make a copy of the array, and modify that copy instead of the original one:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionStoryTray({stories}){constitems=stories.slice();// Clone the array// ✅ Good: Pushing into a new arrayitems.push({id:'create',label:'Create Story'});"
                },
                {
                    "type": "p",
                    "text": "This wouldmake theStoryTrayfunction pure.Each time it is called, it would only modify a new copy of the array, and would not affect any external objects or variables. This solves the bug, but you had to make the component re-render more often before it became obvious that something is wrong with its behavior."
                },
                {
                    "type": "p",
                    "text": "In the original example, the bug wasn’t obvious. Now let’s wrap the original (buggy) code in<StrictMode>:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionStoryTray({stories}){constitems=stories;items.push({id:'create',label:'Create Story'});return(<ul>{items.map(story=>(<likey={story.id}>{story.label}</li>))}</ul>);}"
                },
                {
                    "type": "p",
                    "text": "Strict Modealwayscalls your rendering function twice, so you can see the mistake right away(“Create Story” appears twice). This lets you notice such mistakes early in the process. When you fix your component to render in Strict Mode, youalsofix many possible future production bugs like the hover functionality from before:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionStoryTray({stories}){const[isHover,setIsHover]=useState(false);constitems=stories.slice();// Clone the arrayitems.push({id:'create',label:'Create Story'});return(<ulonPointerEnter={()=>setIsHover(true)}onPointerLeave={()=>setIsHover(false)}style={{backgroundColor:isHover?'#ddd':'#fff'}}>{items.map(story=>(<likey={story.id}>{story.label}</li>))}</ul>);}"
                },
                {
                    "type": "p",
                    "text": "Without Strict Mode, it was easy to miss the bug until you added more re-renders. Strict Mode made the same bug appear right away. Strict Mode helps you find bugs before you push them to your team and to your users."
                },
                {
                    "type": "p",
                    "text": "Read more about keeping components pure."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "If you haveReact DevToolsinstalled, anyconsole.logcalls during the second render call will appear slightly dimmed. React DevTools also offers a setting (off by default) to suppress them completely."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Fixing bugs found by re-running Effects in development"
                },
                {
                    "type": "p",
                    "text": "Strict Mode can also help find bugs inEffects."
                },
                {
                    "type": "p",
                    "text": "Every Effect has some setup code and may have some cleanup code. Normally, React calls setup when the componentmounts(is added to the screen) and calls cleanup when the componentunmounts(is removed from the screen). React then calls cleanup and setup again if its dependencies changed since the last render."
                },
                {
                    "type": "p",
                    "text": "When Strict Mode is on, React will also runone extra setup+cleanup cycle in development for every Effect.This may feel surprising, but it helps reveal subtle bugs that are hard to catch manually."
                },
                {
                    "type": "p",
                    "text": "Here is an example to illustrate how re-running Effects in Strict Mode helps you find bugs early."
                },
                {
                    "type": "p",
                    "text": "Consider this example that connects a component to a chat:"
                },
                {
                    "type": "code",
                    "code": "import{createRoot}from'react-dom/client';import'./styles.css';importAppfrom'./App';constroot=createRoot(document.getElementById(\"root\"));root.render(<App/>);"
                },
                {
                    "type": "p",
                    "text": "There is an issue with this code, but it might not be immediately clear."
                },
                {
                    "type": "p",
                    "text": "To make the issue more obvious, let’s implement a feature. In the example below,roomIdis not hardcoded. Instead, the user can select theroomIdthat they want to connect to from a dropdown. Click “Open chat” and then select different chat rooms one by one. Keep track of the number of active connections in the console:"
                },
                {
                    "type": "code",
                    "code": "import{createRoot}from'react-dom/client';import'./styles.css';importAppfrom'./App';constroot=createRoot(document.getElementById(\"root\"));root.render(<App/>);"
                },
                {
                    "type": "p",
                    "text": "You’ll notice that the number of open connections always keeps growing. In a real app, this would cause performance and network problems. The issue is thatyour Effect is missing a cleanup function:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>connection.disconnect();},[roomId]);"
                },
                {
                    "type": "p",
                    "text": "Now that your Effect “cleans up” after itself and destroys the outdated connections, the leak is solved. However, notice that the problem did not become visible until you’ve added more features (the select box)."
                },
                {
                    "type": "p",
                    "text": "In the original example, the bug wasn’t obvious. Now let’s wrap the original (buggy) code in<StrictMode>:"
                },
                {
                    "type": "code",
                    "code": "import{StrictMode}from'react';import{createRoot}from'react-dom/client';import'./styles.css';importAppfrom'./App';constroot=createRoot(document.getElementById(\"root\"));root.render(<StrictMode><App/></StrictMode>);"
                },
                {
                    "type": "p",
                    "text": "With Strict Mode, you immediately see that there is a problem(the number of active connections jumps to 2). Strict Mode runs an extra setup+cleanup cycle for every Effect. This Effect has no cleanup logic, so it creates an extra connection but doesn’t destroy it. This is a hint that you’re missing a cleanup function."
                },
                {
                    "type": "p",
                    "text": "Strict Mode lets you notice such mistakes early in the process. When you fix your Effect by adding a cleanup function in Strict Mode, youalsofix many possible future production bugs like the select box from before:"
                },
                {
                    "type": "code",
                    "code": "import{StrictMode}from'react';import{createRoot}from'react-dom/client';import'./styles.css';importAppfrom'./App';constroot=createRoot(document.getElementById(\"root\"));root.render(<StrictMode><App/></StrictMode>);"
                },
                {
                    "type": "p",
                    "text": "Notice how the active connection count in the console doesn’t keep growing anymore."
                },
                {
                    "type": "p",
                    "text": "Without Strict Mode, it was easy to miss that your Effect needed cleanup. By runningsetup → cleanup → setupinstead ofsetupfor your Effect in development, Strict Mode made the missing cleanup logic more noticeable."
                },
                {
                    "type": "p",
                    "text": "Read more about implementing Effect cleanup."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Fixing deprecation warnings enabled by Strict Mode"
                },
                {
                    "type": "p",
                    "text": "React warns if some component anywhere inside a<StrictMode>tree uses one of these deprecated APIs:"
                },
                {
                    "type": "list",
                    "items": [
                        "findDOMNode.See alternatives.",
                        "UNSAFE_class lifecycle methods likeUNSAFE_componentWillMount.See alternatives.",
                        "Legacy context (childContextTypes,contextTypes, andgetChildContext).See alternatives.",
                        "Legacy string refs (this.refs).See alternatives."
                    ]
                },
                {
                    "type": "p",
                    "text": "These APIs are primarily used in olderclass componentsso they rarely appear in modern apps."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/Suspense",
            "title": "<Suspense> – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "<Suspense>"
                },
                {
                    "type": "p",
                    "text": "<Suspense>lets you display a fallback until its children have finished loading."
                },
                {
                    "type": "code",
                    "code": "<Suspensefallback={<Loading/>}><SomeComponent/></Suspense>"
                },
                {
                    "type": "list",
                    "items": [
                        "Reference<Suspense>",
                        "<Suspense>",
                        "UsageDisplaying a fallback while content is loadingRevealing content together at onceRevealing nested content as it loadsShowing stale content while fresh content is loadingPreventing already revealed content from hidingIndicating that a Transition is happeningResetting Suspense boundaries on navigationProviding a fallback for server errors and client-only content",
                        "Displaying a fallback while content is loading",
                        "Revealing content together at once",
                        "Revealing nested content as it loads",
                        "Showing stale content while fresh content is loading",
                        "Preventing already revealed content from hiding",
                        "Indicating that a Transition is happening",
                        "Resetting Suspense boundaries on navigation",
                        "Providing a fallback for server errors and client-only content",
                        "TroubleshootingHow do I prevent the UI from being replaced by a fallback during an update?",
                        "How do I prevent the UI from being replaced by a fallback during an update?"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "<Suspense>"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Displaying a fallback while content is loading",
                        "Revealing content together at once",
                        "Revealing nested content as it loads",
                        "Showing stale content while fresh content is loading",
                        "Preventing already revealed content from hiding",
                        "Indicating that a Transition is happening",
                        "Resetting Suspense boundaries on navigation",
                        "Providing a fallback for server errors and client-only content"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "How do I prevent the UI from being replaced by a fallback during an update?"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "<Suspense>"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Props"
                },
                {
                    "type": "list",
                    "items": [
                        "children: The actual UI you intend to render. Ifchildrensuspends while rendering, the Suspense boundary will switch to renderingfallback.",
                        "fallback: An alternate UI to render in place of the actual UI if it has not finished loading. Any valid React node is accepted, though in practice, a fallback is a lightweight placeholder view, such as a loading spinner or skeleton. Suspense will automatically switch tofallbackwhenchildrensuspends, and back tochildrenwhen the data is ready. Iffallbacksuspends while rendering, it will activate the closest parent Suspense boundary."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "React does not preserve any state for renders that got suspended before they were able to mount for the first time. When the component has loaded, React will retry rendering the suspended tree from scratch.",
                        "If Suspense was displaying content for the tree, but then it suspended again, thefallbackwill be shown again unless the update causing it was caused bystartTransitionoruseDeferredValue.",
                        "If React needs to hide the already visible content because it suspended again, it will clean uplayout Effectsin the content tree. When the content is ready to be shown again, React will fire the layout Effects again. This ensures that Effects measuring the DOM layout don’t try to do this while the content is hidden.",
                        "React includes under-the-hood optimizations likeStreaming Server RenderingandSelective Hydrationthat are integrated with Suspense. Readan architectural overviewand watcha technical talkto learn more."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Displaying a fallback while content is loading"
                },
                {
                    "type": "p",
                    "text": "You can wrap any part of your application with a Suspense boundary:"
                },
                {
                    "type": "code",
                    "code": "<Suspensefallback={<Loading />}><Albums /></Suspense>"
                },
                {
                    "type": "p",
                    "text": "React will display yourloading fallbackuntil all the code and data needed bythe childrenhas been loaded."
                },
                {
                    "type": "p",
                    "text": "In the example below, theAlbumscomponentsuspendswhile fetching the list of albums. Until it’s ready to render, React switches the closest Suspense boundary above to show the fallback—yourLoadingcomponent. Then, when the data loads, React hides theLoadingfallback and renders theAlbumscomponent with data."
                },
                {
                    "type": "code",
                    "code": "import{Suspense}from'react';importAlbumsfrom'./Albums.js';exportdefaultfunctionArtistPage({artist}){return(<><h1>{artist.name}</h1><Suspensefallback={<Loading/>}><AlbumsartistId={artist.id}/></Suspense></>);}functionLoading(){return<h2>🌀 Loading...</h2>;}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Only Suspense-enabled data sources will activate the Suspense component.They include:"
                },
                {
                    "type": "list",
                    "items": [
                        "Data fetching with Suspense-enabled frameworks likeRelayandNext.js",
                        "Lazy-loading component code withlazy",
                        "Reading the value of a Promise withuse"
                    ]
                },
                {
                    "type": "p",
                    "text": "Suspensedoes notdetect when data is fetched inside an Effect or event handler."
                },
                {
                    "type": "p",
                    "text": "The exact way you would load data in theAlbumscomponent above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation."
                },
                {
                    "type": "p",
                    "text": "Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Revealing content together at once"
                },
                {
                    "type": "p",
                    "text": "By default, the whole tree inside Suspense is treated as a single unit. For example, even ifonly oneof these components suspends waiting for some data,allof them together will be replaced by the loading indicator:"
                },
                {
                    "type": "code",
                    "code": "<Suspensefallback={<Loading/>}><Biography/><Panel><Albums/></Panel></Suspense>"
                },
                {
                    "type": "p",
                    "text": "Then, after all of them are ready to be displayed, they will all appear together at once."
                },
                {
                    "type": "p",
                    "text": "In the example below, bothBiographyandAlbumsfetch some data. However, because they are grouped under a single Suspense boundary, these components always “pop in” together at the same time."
                },
                {
                    "type": "code",
                    "code": "import{Suspense}from'react';importAlbumsfrom'./Albums.js';importBiographyfrom'./Biography.js';importPanelfrom'./Panel.js';exportdefaultfunctionArtistPage({artist}){return(<><h1>{artist.name}</h1><Suspensefallback={<Loading/>}><BiographyartistId={artist.id}/><Panel><AlbumsartistId={artist.id}/></Panel></Suspense></>);}functionLoading(){return<h2>🌀 Loading...</h2>;}"
                },
                {
                    "type": "p",
                    "text": "Components that load data don’t have to be direct children of the Suspense boundary. For example, you can moveBiographyandAlbumsinto a newDetailscomponent. This doesn’t change the behavior.BiographyandAlbumsshare the same closest parent Suspense boundary, so their reveal is coordinated together."
                },
                {
                    "type": "code",
                    "code": "<Suspensefallback={<Loading/>}><DetailsartistId={artist.id}/></Suspense>functionDetails({artistId}){return(<><BiographyartistId={artistId}/><Panel><AlbumsartistId={artistId}/></Panel></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Revealing nested content as it loads"
                },
                {
                    "type": "p",
                    "text": "When a component suspends, the closest parent Suspense component shows the fallback. This lets you nest multiple Suspense components to create a loading sequence. Each Suspense boundary’s fallback will be filled in as the next level of content becomes available. For example, you can give the album list its own fallback:"
                },
                {
                    "type": "code",
                    "code": "<Suspensefallback={<BigSpinner/>}><Biography/><Suspensefallback={<AlbumsGlimmer/>}><Panel><Albums/></Panel></Suspense></Suspense>"
                },
                {
                    "type": "p",
                    "text": "With this change, displaying theBiographydoesn’t need to “wait” for theAlbumsto load."
                },
                {
                    "type": "p",
                    "text": "The sequence will be:"
                },
                {
                    "type": "list",
                    "items": [
                        "IfBiographyhasn’t loaded yet,BigSpinneris shown in place of the entire content area.",
                        "OnceBiographyfinishes loading,BigSpinneris replaced by the content.",
                        "IfAlbumshasn’t loaded yet,AlbumsGlimmeris shown in place ofAlbumsand its parentPanel.",
                        "Finally, onceAlbumsfinishes loading, it replacesAlbumsGlimmer."
                    ]
                },
                {
                    "type": "code",
                    "code": "import{Suspense}from'react';importAlbumsfrom'./Albums.js';importBiographyfrom'./Biography.js';importPanelfrom'./Panel.js';exportdefaultfunctionArtistPage({artist}){return(<><h1>{artist.name}</h1><Suspensefallback={<BigSpinner/>}><BiographyartistId={artist.id}/><Suspensefallback={<AlbumsGlimmer/>}><Panel><AlbumsartistId={artist.id}/></Panel></Suspense></Suspense></>);}functionBigSpinner(){return<h2>🌀 Loading...</h2>;}functionAlbumsGlimmer(){return(<divclassName=\"glimmer-panel\"><divclassName=\"glimmer-line\"/><divclassName=\"glimmer-line\"/><divclassName=\"glimmer-line\"/></div>);}"
                },
                {
                    "type": "p",
                    "text": "Suspense boundaries let you coordinate which parts of your UI should always “pop in” together at the same time, and which parts should progressively reveal more content in a sequence of loading states. You can add, move, or delete Suspense boundaries in any place in the tree without affecting the rest of your app’s behavior."
                },
                {
                    "type": "p",
                    "text": "Don’t put a Suspense boundary around every component. Suspense boundaries should not be more granular than the loading sequence that you want the user to experience. If you work with a designer, ask them where the loading states should be placed—it’s likely that they’ve already included them in their design wireframes."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Showing stale content while fresh content is loading"
                },
                {
                    "type": "p",
                    "text": "In this example, theSearchResultscomponent suspends while fetching the search results. Type\"a\", wait for the results, and then edit it to\"ab\". The results for\"a\"will get replaced by the loading fallback."
                },
                {
                    "type": "code",
                    "code": "import{Suspense,useState}from'react';importSearchResultsfrom'./SearchResults.js';exportdefaultfunctionApp(){const[query,setQuery]=useState('');return(<><label>Search albums:<inputvalue={query}onChange={e=>setQuery(e.target.value)}/></label><Suspensefallback={<h2>Loading...</h2>}><SearchResultsquery={query}/></Suspense></>);}"
                },
                {
                    "type": "p",
                    "text": "A common alternative UI pattern is todeferupdating the list and to keep showing the previous results until the new results are ready. TheuseDeferredValueHook lets you pass a deferred version of the query down:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionApp(){const[query,setQuery]=useState('');constdeferredQuery=useDeferredValue(query);return(<><label>Search albums:<inputvalue={query}onChange={e=>setQuery(e.target.value)}/></label><Suspensefallback={<h2>Loading...</h2>}><SearchResultsquery={deferredQuery}/></Suspense></>);}"
                },
                {
                    "type": "p",
                    "text": "Thequerywill update immediately, so the input will display the new value. However, thedeferredQuerywill keep its previous value until the data has loaded, soSearchResultswill show the stale results for a bit."
                },
                {
                    "type": "p",
                    "text": "To make it more obvious to the user, you can add a visual indication when the stale result list is displayed:"
                },
                {
                    "type": "code",
                    "code": "<divstyle={{opacity:query!==deferredQuery?0.5:1}}><SearchResultsquery={deferredQuery}/></div>"
                },
                {
                    "type": "p",
                    "text": "Enter\"a\"in the example below, wait for the results to load, and then edit the input to\"ab\". Notice how instead of the Suspense fallback, you now see the dimmed stale result list until the new results have loaded:"
                },
                {
                    "type": "code",
                    "code": "import{Suspense,useState,useDeferredValue}from'react';importSearchResultsfrom'./SearchResults.js';exportdefaultfunctionApp(){const[query,setQuery]=useState('');constdeferredQuery=useDeferredValue(query);constisStale=query!==deferredQuery;return(<><label>Search albums:<inputvalue={query}onChange={e=>setQuery(e.target.value)}/></label><Suspensefallback={<h2>Loading...</h2>}><divstyle={{opacity:isStale?0.5:1}}><SearchResultsquery={deferredQuery}/></div></Suspense></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Both deferred values andTransitionslet you avoid showing Suspense fallback in favor of inline indicators. Transitions mark the whole update as non-urgent so they are typically used by frameworks and router libraries for navigation. Deferred values, on the other hand, are mostly useful in application code where you want to mark a part of UI as non-urgent and let it “lag behind” the rest of the UI."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Preventing already revealed content from hiding"
                },
                {
                    "type": "p",
                    "text": "When a component suspends, the closest parent Suspense boundary switches to showing the fallback. This can lead to a jarring user experience if it was already displaying some content. Try pressing this button:"
                },
                {
                    "type": "code",
                    "code": "import{Suspense,useState}from'react';importIndexPagefrom'./IndexPage.js';importArtistPagefrom'./ArtistPage.js';importLayoutfrom'./Layout.js';exportdefaultfunctionApp(){return(<Suspensefallback={<BigSpinner/>}><Router/></Suspense>);}functionRouter(){const[page,setPage]=useState('/');functionnavigate(url){setPage(url);}letcontent;if(page==='/'){content=(<IndexPagenavigate={navigate}/>);}elseif(page==='/the-beatles'){content=(<ArtistPageartist={{id:'the-beatles',name:'The Beatles',}}/>);}return(<Layout>{content}</Layout>);}functionBigSpinner(){return<h2>🌀 Loading...</h2>;}"
                },
                {
                    "type": "p",
                    "text": "When you pressed the button, theRoutercomponent renderedArtistPageinstead ofIndexPage. A component insideArtistPagesuspended, so the closest Suspense boundary started showing the fallback. The closest Suspense boundary was near the root, so the whole site layout got replaced byBigSpinner."
                },
                {
                    "type": "p",
                    "text": "To prevent this, you can mark the navigation state update as aTransitionwithstartTransition:"
                },
                {
                    "type": "code",
                    "code": "functionRouter(){const[page,setPage]=useState('/');functionnavigate(url){startTransition(()=>{setPage(url);});}// ..."
                },
                {
                    "type": "p",
                    "text": "This tells React that the state transition is not urgent, and it’s better to keep showing the previous page instead of hiding any already revealed content. Now clicking the button “waits” for theBiographyto load:"
                },
                {
                    "type": "code",
                    "code": "import{Suspense,startTransition,useState}from'react';importIndexPagefrom'./IndexPage.js';importArtistPagefrom'./ArtistPage.js';importLayoutfrom'./Layout.js';exportdefaultfunctionApp(){return(<Suspensefallback={<BigSpinner/>}><Router/></Suspense>);}functionRouter(){const[page,setPage]=useState('/');functionnavigate(url){startTransition(()=>{setPage(url);});}letcontent;if(page==='/'){content=(<IndexPagenavigate={navigate}/>);}elseif(page==='/the-beatles'){content=(<ArtistPageartist={{id:'the-beatles',name:'The Beatles',}}/>);}return(<Layout>{content}</Layout>);}functionBigSpinner(){return<h2>🌀 Loading...</h2>;}"
                },
                {
                    "type": "p",
                    "text": "A Transition doesn’t wait forallcontent to load. It only waits long enough to avoid hiding already revealed content. For example, the websiteLayoutwas already revealed, so it would be bad to hide it behind a loading spinner. However, the nestedSuspenseboundary aroundAlbumsis new, so the Transition doesn’t wait for it."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Suspense-enabled routers are expected to wrap the navigation updates into Transitions by default."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Indicating that a Transition is happening"
                },
                {
                    "type": "p",
                    "text": "In the above example, once you click the button, there is no visual indication that a navigation is in progress. To add an indicator, you can replacestartTransitionwithuseTransitionwhich gives you a booleanisPendingvalue. In the example below, it’s used to change the website header styling while a Transition is happening:"
                },
                {
                    "type": "code",
                    "code": "import{Suspense,useState,useTransition}from'react';importIndexPagefrom'./IndexPage.js';importArtistPagefrom'./ArtistPage.js';importLayoutfrom'./Layout.js';exportdefaultfunctionApp(){return(<Suspensefallback={<BigSpinner/>}><Router/></Suspense>);}functionRouter(){const[page,setPage]=useState('/');const[isPending,startTransition]=useTransition();functionnavigate(url){startTransition(()=>{setPage(url);});}letcontent;if(page==='/'){content=(<IndexPagenavigate={navigate}/>);}elseif(page==='/the-beatles'){content=(<ArtistPageartist={{id:'the-beatles',name:'The Beatles',}}/>);}return(<LayoutisPending={isPending}>{content}</Layout>);}functionBigSpinner(){return<h2>🌀 Loading...</h2>;}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Resetting Suspense boundaries on navigation"
                },
                {
                    "type": "p",
                    "text": "During a Transition, React will avoid hiding already revealed content. However, if you navigate to a route with different parameters, you might want to tell React it isdifferentcontent. You can express this with akey:"
                },
                {
                    "type": "code",
                    "code": "<ProfilePagekey={queryParams.id}/>"
                },
                {
                    "type": "p",
                    "text": "Imagine you’re navigating within a user’s profile page, and something suspends. If that update is wrapped in a Transition, it will not trigger the fallback for already visible content. That’s the expected behavior."
                },
                {
                    "type": "p",
                    "text": "However, now imagine you’re navigating between two different user profiles. In that case, it makes sense to show the fallback. For example, one user’s timeline isdifferent contentfrom another user’s timeline. By specifying akey, you ensure that React treats different users’ profiles as different components, and resets the Suspense boundaries during navigation. Suspense-integrated routers should do this automatically."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Providing a fallback for server errors and client-only content"
                },
                {
                    "type": "p",
                    "text": "If you use one of thestreaming server rendering APIs(or a framework that relies on them), React will also use your<Suspense>boundaries to handle errors on the server. If a component throws an error on the server, React will not abort the server render. Instead, it will find the closest<Suspense>component above it and include its fallback (such as a spinner) into the generated server HTML. The user will see a spinner at first."
                },
                {
                    "type": "p",
                    "text": "On the client, React will attempt to render the same component again. If it errors on the client too, React will throw the error and display the closesterror boundary.However, if it does not error on the client, React will not display the error to the user since the content was eventually displayed successfully."
                },
                {
                    "type": "p",
                    "text": "You can use this to opt out some components from rendering on the server. To do this, throw an error in the server environment and then wrap them in a<Suspense>boundary to replace their HTML with fallbacks:"
                },
                {
                    "type": "code",
                    "code": "<Suspensefallback={<Loading/>}><Chat/></Suspense>functionChat(){if(typeofwindow==='undefined'){throwError('Chat should only render on the client.');}// ...}"
                },
                {
                    "type": "p",
                    "text": "The server HTML will include the loading indicator. It will be replaced by theChatcomponent on the client."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "How do I prevent the UI from being replaced by a fallback during an update?"
                },
                {
                    "type": "p",
                    "text": "Replacing visible UI with a fallback creates a jarring user experience. This can happen when an update causes a component to suspend, and the nearest Suspense boundary is already showing content to the user."
                },
                {
                    "type": "p",
                    "text": "To prevent this from happening,mark the update as non-urgent usingstartTransition. During a Transition, React will wait until enough data has loaded to prevent an unwanted fallback from appearing:"
                },
                {
                    "type": "code",
                    "code": "functionhandleNextPageClick(){// If this update suspends, don't hide the already displayed contentstartTransition(()=>{setCurrentPage(currentPage+1);});}"
                },
                {
                    "type": "p",
                    "text": "This will avoid hiding existing content. However, any newly renderedSuspenseboundaries will still immediately display fallbacks to avoid blocking the UI and let the user see the content as it becomes available."
                },
                {
                    "type": "p",
                    "text": "React will only prevent unwanted fallbacks during non-urgent updates. It will not delay a render if it’s the result of an urgent update. You must opt in with an API likestartTransitionoruseDeferredValue."
                },
                {
                    "type": "p",
                    "text": "If your router is integrated with Suspense, it should wrap its updates intostartTransitionautomatically."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/act",
            "title": "act – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "act"
                },
                {
                    "type": "p",
                    "text": "actis a test helper to apply pending React updates before making assertions."
                },
                {
                    "type": "code",
                    "code": "awaitact(asyncactFn)"
                },
                {
                    "type": "p",
                    "text": "To prepare a component for assertions, wrap the code rendering it and performing updates inside anawait act()call. This makes your test run closer to how React works in the browser."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "You might find usingact()directly a bit too verbose. To avoid some of the boilerplate, you could use a library likeReact Testing Library, whose helpers are wrapped withact()."
                },
                {
                    "type": "list",
                    "items": [
                        "Referenceawait act(async actFn)",
                        "await act(async actFn)",
                        "UsageRendering components in testsDispatching events in tests",
                        "Rendering components in tests",
                        "Dispatching events in tests",
                        "TroubleshootingI’m getting an error: “The current testing environment is not configured to support act”(…)”",
                        "I’m getting an error: “The current testing environment is not configured to support act”(…)”"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "await act(async actFn)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Rendering components in tests",
                        "Dispatching events in tests"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "I’m getting an error: “The current testing environment is not configured to support act”(…)”"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "await act(async actFn)"
                },
                {
                    "type": "p",
                    "text": "When writing UI tests, tasks like rendering, user events, or data fetching can be considered as “units” of interaction with a user interface. React provides a helper calledact()that makes sure all updates related to these “units” have been processed and applied to the DOM before you make any assertions."
                },
                {
                    "type": "p",
                    "text": "The nameactcomes from theArrange-Act-Assertpattern."
                },
                {
                    "type": "code",
                    "code": "it('renders with button disabled',async()=>{awaitact(async()=>{root.render(<TestComponent/>)});expect(container.querySelector('button')).toBeDisabled();});"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "We recommend usingactwithawaitand anasyncfunction. Although the sync version works in many cases, it doesn’t work in all cases and due to the way React schedules updates internally, it’s difficult to predict when you can use the sync version."
                },
                {
                    "type": "p",
                    "text": "We will deprecate and remove the sync version in the future."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "async actFn: An async function wrapping renders or interactions for components being tested. Any updates triggered within theactFn, are added to an internal act queue, which are then flushed together to process and apply any changes to the DOM. Since it is async, React will also run any code that crosses an async boundary, and flush any updates scheduled."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "actdoes not return anything."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "p",
                    "text": "When testing a component, you can useactto make assertions about its output."
                },
                {
                    "type": "p",
                    "text": "For example, let’s say we have thisCountercomponent, the usage examples below show how to test it:"
                },
                {
                    "type": "code",
                    "code": "functionCounter(){const[count,setCount]=useState(0);consthandleClick=()=>{setCount(prev=>prev+1);}useEffect(()=>{document.title=`You clicked${this.state.count}times`;},[count]);return(<div><p>You clicked{this.state.count}times</p><buttononClick={this.handleClick}>Click me</button></div>)}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Rendering components in tests"
                },
                {
                    "type": "p",
                    "text": "To test the render output of a component, wrap the render insideact():"
                },
                {
                    "type": "code",
                    "code": "import{act}from'react';importReactDOMClientfrom'react-dom/client';importCounterfrom'./Counter';it('can render and update a counter',async()=>{container=document.createElement('div');document.body.appendChild(container);// ✅ Render the component inside act().awaitact(()=>{ReactDOMClient.createRoot(container).render(<Counter/>);});constbutton=container.querySelector('button');constlabel=container.querySelector('p');expect(label.textContent).toBe('You clicked 0 times');expect(document.title).toBe('You clicked 0 times');});"
                },
                {
                    "type": "p",
                    "text": "Here, we create a container, append it to the document, and render theCountercomponent insideact(). This ensures that the component is rendered and its effects are applied before making assertions."
                },
                {
                    "type": "p",
                    "text": "Usingactensures that all updates have been applied before we make assertions."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Dispatching events in tests"
                },
                {
                    "type": "p",
                    "text": "To test events, wrap the event dispatch insideact():"
                },
                {
                    "type": "code",
                    "code": "import{act}from'react';importReactDOMClientfrom'react-dom/client';importCounterfrom'./Counter';it.only('can render and update a counter',async()=>{constcontainer=document.createElement('div');document.body.appendChild(container);awaitact(async()=>{ReactDOMClient.createRoot(container).render(<Counter/>);});// ✅ Dispatch the event inside act().awaitact(async()=>{button.dispatchEvent(newMouseEvent('click',{bubbles:true}));});constbutton=container.querySelector('button');constlabel=container.querySelector('p');expect(label.textContent).toBe('You clicked 1 times');expect(document.title).toBe('You clicked 1 times');});"
                },
                {
                    "type": "p",
                    "text": "Here, we render the component withact, and then dispatch the event inside anotheract(). This ensures that all updates from the event are applied before making assertions."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Don’t forget that dispatching DOM events only works when the DOM container is added to the document. You can use a library likeReact Testing Libraryto reduce the boilerplate code."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’m getting an error: “The current testing environment is not configured to support act”(…)”"
                },
                {
                    "type": "p",
                    "text": "Usingactrequires settingglobal.IS_REACT_ACT_ENVIRONMENT=truein your test environment. This is to ensure thatactis only used in the correct environment."
                },
                {
                    "type": "p",
                    "text": "If you don’t set the global, you will see an error like this:"
                },
                {
                    "type": "p",
                    "text": "To fix, add this to your global setup file for React tests:"
                },
                {
                    "type": "code",
                    "code": "global.IS_REACT_ACT_ENVIRONMENT=true"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "In testing frameworks likeReact Testing Library,IS_REACT_ACT_ENVIRONMENTis already set for you."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/apis",
            "title": "Built-in React APIs – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Built-in React APIs"
                },
                {
                    "type": "p",
                    "text": "In addition toHooksandComponents, thereactpackage exports a few other APIs that are useful for defining components. This page lists all the remaining modern React APIs."
                },
                {
                    "type": "list",
                    "items": [
                        "createContextlets you define and provide context to the child components. Used withuseContext.",
                        "forwardReflets your component expose a DOM node as a ref to the parent. Used withuseRef.",
                        "lazylets you defer loading a component’s code until it’s rendered for the first time.",
                        "memolets your component skip re-renders with same props. Used withuseMemoanduseCallback.",
                        "startTransitionlets you mark a state update as non-urgent. Similar touseTransition.",
                        "actlets you wrap renders and interactions in tests to ensure updates have processed before making assertions."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Resource APIs"
                },
                {
                    "type": "p",
                    "text": "Resourcescan be accessed by a component without having them as part of their state. For example, a component can read a message from a Promise or read styling information from a context."
                },
                {
                    "type": "p",
                    "text": "To read a value from a resource, use this API:"
                },
                {
                    "type": "list",
                    "items": [
                        "uselets you read the value of a resource like aPromiseorcontext."
                    ]
                },
                {
                    "type": "code",
                    "code": "functionMessageComponent({messagePromise}){constmessage=use(messagePromise);consttheme=use(ThemeContext);// ...}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/cache",
            "title": "cache – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "cache- This feature is available in the latest Canary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "list",
                    "items": [
                        "cacheis only for use withReact Server Components. Seeframeworksthat support React Server Components.",
                        "cacheis only available in React’sCanaryandexperimentalchannels. Please ensure you understand the limitations before usingcachein production. Learn more aboutReact’s release channels here."
                    ]
                },
                {
                    "type": "p",
                    "text": "cacheis only for use withReact Server Components. Seeframeworksthat support React Server Components."
                },
                {
                    "type": "p",
                    "text": "cacheis only available in React’sCanaryandexperimentalchannels. Please ensure you understand the limitations before usingcachein production. Learn more aboutReact’s release channels here."
                },
                {
                    "type": "p",
                    "text": "cachelets you cache the result of a data fetch or computation."
                },
                {
                    "type": "code",
                    "code": "constcachedFn=cache(fn);"
                },
                {
                    "type": "list",
                    "items": [
                        "Referencecache(fn)",
                        "cache(fn)",
                        "UsageCache an expensive computationShare a snapshot of dataPreload data",
                        "Cache an expensive computation",
                        "Share a snapshot of data",
                        "Preload data",
                        "TroubleshootingMy memoized function still runs even though I’ve called it with the same arguments",
                        "My memoized function still runs even though I’ve called it with the same arguments"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "cache(fn)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Cache an expensive computation",
                        "Share a snapshot of data",
                        "Preload data"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "My memoized function still runs even though I’ve called it with the same arguments"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "cache(fn)"
                },
                {
                    "type": "p",
                    "text": "Callcacheoutside of any components to create a version of the function with caching."
                },
                {
                    "type": "code",
                    "code": "import{cache}from'react';importcalculateMetricsfrom'lib/metrics';constgetMetrics=cache(calculateMetrics);functionChart({data}){constreport=getMetrics(data);// ...}"
                },
                {
                    "type": "p",
                    "text": "WhengetMetricsis first called withdata,getMetricswill callcalculateMetrics(data)and store the result in cache. IfgetMetricsis called again with the samedata, it will return the cached result instead of callingcalculateMetrics(data)again."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "fn: The function you want to cache results for.fncan take any arguments and return any value."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "cachereturns a cached version offnwith the same type signature. It does not callfnin the process."
                },
                {
                    "type": "p",
                    "text": "When callingcachedFnwith given arguments, it first checks if a cached result exists in the cache. If a cached result exists, it returns the result. If not, it callsfnwith the arguments, stores the result in the cache, and returns the result. The only timefnis called is when there is a cache miss."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "The optimization of caching return values based on inputs is known asmemoization. We refer to the function returned fromcacheas a memoized function."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "React will invalidate the cache for all memoized functions for each server request.",
                        "Each call tocachecreates a new function. This means that callingcachewith the same function multiple times will return different memoized functions that do not share the same cache.",
                        "cachedFnwill also cache errors. Iffnthrows an error for certain arguments, it will be cached, and the same error is re-thrown whencachedFnis called with those same arguments.",
                        "cacheis for use inServer Componentsonly."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Cache an expensive computation"
                },
                {
                    "type": "p",
                    "text": "Usecacheto skip duplicate work."
                },
                {
                    "type": "code",
                    "code": "import{cache}from'react';importcalculateUserMetricsfrom'lib/user';constgetUserMetrics=cache(calculateUserMetrics);functionProfile({user}){constmetrics=getUserMetrics(user);// ...}functionTeamReport({users}){for(letuserinusers){constmetrics=getUserMetrics(user);// ...}// ...}"
                },
                {
                    "type": "p",
                    "text": "If the sameuserobject is rendered in bothProfileandTeamReport, the two components can share work and only callcalculateUserMetricsonce for thatuser."
                },
                {
                    "type": "p",
                    "text": "AssumeProfileis rendered first. It will callgetUserMetrics, and check if there is a cached result. Since it is the first timegetUserMetricsis called with thatuser, there will be a cache miss.getUserMetricswill then callcalculateUserMetricswith thatuserand write the result to cache."
                },
                {
                    "type": "p",
                    "text": "WhenTeamReportrenders its list ofusersand reaches the sameuserobject, it will callgetUserMetricsand read the result from cache."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Calling different memoized functions will read from different caches."
                },
                {
                    "type": "p",
                    "text": "To access the same cache, components must call the same memoized function."
                },
                {
                    "type": "code",
                    "code": "// Temperature.jsimport{cache}from'react';import{calculateWeekReport}from'./report';exportfunctionTemperature({cityData}){// 🚩 Wrong: Calling `cache` in component creates new `getWeekReport` for each renderconstgetWeekReport=cache(calculateWeekReport);constreport=getWeekReport(cityData);// ...}"
                },
                {
                    "type": "code",
                    "code": "// Precipitation.jsimport{cache}from'react';import{calculateWeekReport}from'./report';// 🚩 Wrong: `getWeekReport` is only accessible for `Precipitation` component.constgetWeekReport=cache(calculateWeekReport);exportfunctionPrecipitation({cityData}){constreport=getWeekReport(cityData);// ...}"
                },
                {
                    "type": "p",
                    "text": "In the above example,PrecipitationandTemperatureeach callcacheto create a new memoized function with their own cache look-up. If both components render for the samecityData, they will do duplicate work to callcalculateWeekReport."
                },
                {
                    "type": "p",
                    "text": "In addition,Temperaturecreates anew memoized functioneach time the component is rendered which doesn’t allow for any cache sharing."
                },
                {
                    "type": "p",
                    "text": "To maximize cache hits and reduce work, the two components should call the same memoized function to access the same cache. Instead, define the memoized function in a dedicated module that can beimport-edacross components."
                },
                {
                    "type": "code",
                    "code": "// getWeekReport.jsimport{cache}from'react';import{calculateWeekReport}from'./report';export default cache(calculateWeekReport);"
                },
                {
                    "type": "code",
                    "code": "// Temperature.jsimportgetWeekReportfrom'./getWeekReport';exportdefaultfunctionTemperature({cityData}){constreport=getWeekReport(cityData);// ...}"
                },
                {
                    "type": "code",
                    "code": "// Precipitation.jsimportgetWeekReportfrom'./getWeekReport';exportdefaultfunctionPrecipitation({cityData}){constreport=getWeekReport(cityData);// ...}"
                },
                {
                    "type": "p",
                    "text": "Here, both components call thesame memoized functionexported from./getWeekReport.jsto read and write to the same cache."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Share a snapshot of data"
                },
                {
                    "type": "p",
                    "text": "To share a snapshot of data between components, callcachewith a data-fetching function likefetch. When multiple components make the same data fetch, only one request is made and the data returned is cached and shared across components. All components refer to the same snapshot of data across the server render."
                },
                {
                    "type": "code",
                    "code": "import{cache}from'react';import{fetchTemperature}from'./api.js';constgetTemperature=cache(async(city)=>{returnawaitfetchTemperature(city);});asyncfunctionAnimatedWeatherCard({city}){consttemperature=awaitgetTemperature(city);// ...}asyncfunctionMinimalWeatherCard({city}){consttemperature=awaitgetTemperature(city);// ...}"
                },
                {
                    "type": "p",
                    "text": "IfAnimatedWeatherCardandMinimalWeatherCardboth render for the samecity, they will receive the same snapshot of data from thememoized function."
                },
                {
                    "type": "p",
                    "text": "IfAnimatedWeatherCardandMinimalWeatherCardsupply differentcityarguments togetTemperature, thenfetchTemperaturewill be called twice and each call site will receive different data."
                },
                {
                    "type": "p",
                    "text": "Thecityacts as a cache key."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Asynchronous renderingis only supported for Server Components."
                },
                {
                    "type": "code",
                    "code": "asyncfunctionAnimatedWeatherCard({city}){consttemperature=awaitgetTemperature(city);// ...}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Preload data"
                },
                {
                    "type": "p",
                    "text": "By caching a long-running data fetch, you can kick off asynchronous work prior to rendering the component."
                },
                {
                    "type": "code",
                    "code": "constgetUser=cache(async(id)=>{returnawaitdb.user.query(id);});asyncfunctionProfile({id}){constuser=await getUser(id);return(<section><imgsrc={user.profilePic}/><h2>{user.name}</h2></section>);}functionPage({id}){// ✅ Good: start fetching the user datagetUser(id);// ... some computational workreturn(<><Profileid={id}/></>);}"
                },
                {
                    "type": "p",
                    "text": "When renderingPage, the component callsgetUserbut note that it doesn’t use the returned data. This earlygetUsercall kicks off the asynchronous database query that occurs whilePageis doing other computational work and rendering children."
                },
                {
                    "type": "p",
                    "text": "When renderingProfile, we callgetUseragain. If the initialgetUsercall has already returned and cached the user data, whenProfileasks and waits for this data, it can simply read from the cache without requiring another remote procedure call. If theinitial data requesthasn’t been completed, preloading data in this pattern reduces delay in data-fetching."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caching asynchronous work"
                },
                {
                    "type": "p",
                    "text": "When evaluating anasynchronous function, you will receive aPromisefor that work. The promise holds the state of that work (pending,fulfilled,failed) and its eventual settled result."
                },
                {
                    "type": "p",
                    "text": "In this example, the asynchronous functionfetchDatareturns a promise that is awaiting thefetch."
                },
                {
                    "type": "code",
                    "code": "asyncfunctionfetchData(){returnawaitfetch(`https://...`);}constgetData=cache(fetchData);asyncfunctionMyComponent(){getData();// ... some computational workawaitgetData();// ...}"
                },
                {
                    "type": "p",
                    "text": "In callinggetDatathe first time, the promise returned fromfetchDatais cached. Subsequent look-ups will then return the same promise."
                },
                {
                    "type": "p",
                    "text": "Notice that the firstgetDatacall does notawaitwhereas theseconddoes.awaitis a JavaScript operator that will wait and return the settled result of the promise. The firstgetDatacall simply initiates thefetchto cache the promise for the secondgetDatato look-up."
                },
                {
                    "type": "p",
                    "text": "If by thesecond callthe promise is stillpending, thenawaitwill pause for the result. The optimization is that while we wait on thefetch, React can continue with computational work, thus reducing the wait time for thesecond call."
                },
                {
                    "type": "p",
                    "text": "If the promise is already settled, either to an error or thefulfilledresult,awaitwill return that value immediately. In both outcomes, there is a performance benefit."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Calling a memoized function outside of a component will not use the cache."
                },
                {
                    "type": "code",
                    "code": "import{cache}from'react';constgetUser=cache(async(userId)=>{returnawaitdb.user.query(userId);});// 🚩 Wrong: Calling memoized function outside of component will not memoize.getUser('demo-id');asyncfunctionDemoProfile(){// ✅ Good: `getUser` will memoize.constuser=awaitgetUser('demo-id');return<Profileuser={user}/>;}"
                },
                {
                    "type": "p",
                    "text": "React only provides cache access to the memoized function in a component. When callinggetUseroutside of a component, it will still evaluate the function but not read or update the cache."
                },
                {
                    "type": "p",
                    "text": "This is because cache access is provided through acontextwhich is only accessible from a component."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "When should I usecache,memo, oruseMemo?"
                },
                {
                    "type": "p",
                    "text": "All mentioned APIs offer memoization but the difference is what they’re intended to memoize, who can access the cache, and when their cache is invalidated."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "useMemo"
                },
                {
                    "type": "p",
                    "text": "In general, you should useuseMemofor caching a expensive computation in a Client Component across renders. As an example, to memoize a transformation of data within a component."
                },
                {
                    "type": "code",
                    "code": "'use client';functionWeatherReport({record}){constavgTemp=useMemo(()=>calculateAvg(record),record);// ...}functionApp(){constrecord=getRecord();return(<><WeatherReportrecord={record}/><WeatherReportrecord={record}/></>);}"
                },
                {
                    "type": "p",
                    "text": "In this example,Apprenders twoWeatherReports with the same record. Even though both components do the same work, they cannot share work.useMemo’s cache is only local to the component."
                },
                {
                    "type": "p",
                    "text": "However,useMemodoes ensure that ifAppre-renders and therecordobject doesn’t change, each component instance would skip work and use the memoized value ofavgTemp.useMemowill only cache the last computation ofavgTempwith the given dependencies."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "cache"
                },
                {
                    "type": "p",
                    "text": "In general, you should usecachein Server Components to memoize work that can be shared across components."
                },
                {
                    "type": "code",
                    "code": "constcachedFetchReport=cache(fetchReport);functionWeatherReport({city}){constreport=cachedFetchReport(city);// ...}functionApp(){constcity=\"Los Angeles\";return(<><WeatherReport city={city} /><WeatherReport city={city} /></>);}"
                },
                {
                    "type": "p",
                    "text": "Re-writing the previous example to usecache, in this case thesecond instance ofWeatherReportwill be able to skip duplicate work and read from the same cache as thefirstWeatherReport. Another difference from the previous example is thatcacheis also recommended formemoizing data fetches, unlikeuseMemowhich should only be used for computations."
                },
                {
                    "type": "p",
                    "text": "At this time,cacheshould only be used in Server Components and the cache will be invalidated across server requests."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "memo"
                },
                {
                    "type": "p",
                    "text": "You should usememoto prevent a component re-rendering if its props are unchanged."
                },
                {
                    "type": "code",
                    "code": "'use client';functionWeatherReport({record}){constavgTemp=calculateAvg(record);// ...}constMemoWeatherReport=memo(WeatherReport);functionApp(){constrecord=getRecord();return(<><MemoWeatherReportrecord={record}/><MemoWeatherReportrecord={record}/></>);}"
                },
                {
                    "type": "p",
                    "text": "In this example, bothMemoWeatherReportcomponents will callcalculateAvgwhen first rendered. However, ifAppre-renders, with no changes torecord, none of the props have changed andMemoWeatherReportwill not re-render."
                },
                {
                    "type": "p",
                    "text": "Compared touseMemo,memomemoizes the component render based on props vs. specific computations. Similar touseMemo, the memoized component only caches the last render with the last prop values. Once the props change, the cache invalidates and the component re-renders."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My memoized function still runs even though I’ve called it with the same arguments"
                },
                {
                    "type": "p",
                    "text": "See prior mentioned pitfalls"
                },
                {
                    "type": "list",
                    "items": [
                        "Calling different memoized functions will read from different caches.",
                        "Calling a memoized function outside of a component will not use the cache."
                    ]
                },
                {
                    "type": "p",
                    "text": "If none of the above apply, it may be a problem with how React checks if something exists in cache."
                },
                {
                    "type": "p",
                    "text": "If your arguments are notprimitives(ex. objects, functions, arrays), ensure you’re passing the same object reference."
                },
                {
                    "type": "p",
                    "text": "When calling a memoized function, React will look up the input arguments to see if a result is already cached. React will use shallow equality of the arguments to determine if there is a cache hit."
                },
                {
                    "type": "code",
                    "code": "import{cache}from'react';constcalculateNorm=cache((vector)=>{// ...});functionMapMarker(props){// 🚩 Wrong: props is an object that changes every render.constlength=calculateNorm(props);// ...}functionApp(){return(<><MapMarkerx={10}y={10}z={10}/><MapMarkerx={10}y={10}z={10}/></>);}"
                },
                {
                    "type": "p",
                    "text": "In this case the twoMapMarkers look like they’re doing the same work and callingcalculateNormwith the same value of{x: 10, y: 10, z:10}. Even though the objects contain the same values, they are not the same object reference as each component creates its ownpropsobject."
                },
                {
                    "type": "p",
                    "text": "React will callObject.ison the input to verify if there is a cache hit."
                },
                {
                    "type": "code",
                    "code": "import{cache}from'react';constcalculateNorm=cache((x,y,z)=>{// ...});functionMapMarker(props){// ✅ Good: Pass primitives to memoized functionconstlength=calculateNorm(props.x,props.y,props.z);// ...}functionApp(){return(<><MapMarkerx={10}y={10}z={10}/><MapMarkerx={10}y={10}z={10}/></>);}"
                },
                {
                    "type": "p",
                    "text": "One way to address this could be to pass the vector dimensions tocalculateNorm. This works because the dimensions themselves are primitives."
                },
                {
                    "type": "p",
                    "text": "Another solution may be to pass the vector object itself as a prop to the component. We’ll need to pass the same object to both component instances."
                },
                {
                    "type": "code",
                    "code": "import{cache}from'react';constcalculateNorm=cache((vector)=>{// ...});functionMapMarker(props){// ✅ Good: Pass the same `vector` objectconstlength=calculateNorm(props.vector);// ...}functionApp(){constvector=[10,10,10];return(<><MapMarkervector={vector}/><MapMarkervector={vector}/></>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/cloneElement",
            "title": "cloneElement – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "cloneElement"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "UsingcloneElementis uncommon and can lead to fragile code.See common alternatives."
                },
                {
                    "type": "p",
                    "text": "cloneElementlets you create a new React element using another element as a starting point."
                },
                {
                    "type": "code",
                    "code": "constclonedElement=cloneElement(element,props,...children)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferencecloneElement(element, props, ...children)",
                        "cloneElement(element, props, ...children)",
                        "UsageOverriding props of an element",
                        "Overriding props of an element",
                        "AlternativesPassing data with a render propPassing data through contextExtracting logic into a custom Hook",
                        "Passing data with a render prop",
                        "Passing data through context",
                        "Extracting logic into a custom Hook"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "cloneElement(element, props, ...children)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Overriding props of an element"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Passing data with a render prop",
                        "Passing data through context",
                        "Extracting logic into a custom Hook"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "cloneElement(element, props, ...children)"
                },
                {
                    "type": "p",
                    "text": "CallcloneElementto create a React element based on theelement, but with differentpropsandchildren:"
                },
                {
                    "type": "code",
                    "code": "import{cloneElement}from'react';// ...constclonedElement=cloneElement(<Rowtitle=\"Cabbage\">Hello</Row>,{isHighlighted:true},'Goodbye');console.log(clonedElement);// <Row title=\"Cabbage\" isHighlighted={true}>Goodbye</Row>"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "element: Theelementargument must be a valid React element. For example, it could be a JSX node like<Something />, the result of callingcreateElement, or the result of anothercloneElementcall.",
                        "props: Thepropsargument must either be an object ornull. If you passnull, the cloned element will retain all of the originalelement.props. Otherwise, for every prop in thepropsobject, the returned element will “prefer” the value frompropsover the value fromelement.props. The rest of the props will be filled from the originalelement.props. If you passprops.keyorprops.ref, they will replace the original ones.",
                        "optional...children: Zero or more child nodes. They can be any React nodes, including React elements, strings, numbers,portals, empty nodes (null,undefined,true, andfalse), and arrays of React nodes. If you don’t pass any...childrenarguments, the originalelement.props.childrenwill be preserved."
                    ]
                },
                {
                    "type": "p",
                    "text": "element: Theelementargument must be a valid React element. For example, it could be a JSX node like<Something />, the result of callingcreateElement, or the result of anothercloneElementcall."
                },
                {
                    "type": "p",
                    "text": "props: Thepropsargument must either be an object ornull. If you passnull, the cloned element will retain all of the originalelement.props. Otherwise, for every prop in thepropsobject, the returned element will “prefer” the value frompropsover the value fromelement.props. The rest of the props will be filled from the originalelement.props. If you passprops.keyorprops.ref, they will replace the original ones."
                },
                {
                    "type": "p",
                    "text": "optional...children: Zero or more child nodes. They can be any React nodes, including React elements, strings, numbers,portals, empty nodes (null,undefined,true, andfalse), and arrays of React nodes. If you don’t pass any...childrenarguments, the originalelement.props.childrenwill be preserved."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "cloneElementreturns a React element object with a few properties:"
                },
                {
                    "type": "list",
                    "items": [
                        "type: Same aselement.type.",
                        "props: The result of shallowly mergingelement.propswith the overridingpropsyou have passed.",
                        "ref: The originalelement.ref, unless it was overridden byprops.ref.",
                        "key: The originalelement.key, unless it was overridden byprops.key."
                    ]
                },
                {
                    "type": "p",
                    "text": "Usually, you’ll return the element from your component or make it a child of another element. Although you may read the element’s properties, it’s best to treat every element as opaque after it’s created, and only render it."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Cloning an elementdoes not modify the original element.",
                        "You should onlypass children as multiple arguments tocloneElementif they are all statically known,likecloneElement(element, null, child1, child2, child3). If your children are dynamic, pass the entire array as the third argument:cloneElement(element, null, listItems). This ensures that React willwarn you about missingkeysfor any dynamic lists. For static lists this is not necessary because they never reorder.",
                        "cloneElementmakes it harder to trace the data flow, sotry thealternativesinstead."
                    ]
                },
                {
                    "type": "p",
                    "text": "Cloning an elementdoes not modify the original element."
                },
                {
                    "type": "p",
                    "text": "You should onlypass children as multiple arguments tocloneElementif they are all statically known,likecloneElement(element, null, child1, child2, child3). If your children are dynamic, pass the entire array as the third argument:cloneElement(element, null, listItems). This ensures that React willwarn you about missingkeysfor any dynamic lists. For static lists this is not necessary because they never reorder."
                },
                {
                    "type": "p",
                    "text": "cloneElementmakes it harder to trace the data flow, sotry thealternativesinstead."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Overriding props of an element"
                },
                {
                    "type": "p",
                    "text": "To override the props of someReact element, pass it tocloneElementwith theprops you want to override:"
                },
                {
                    "type": "code",
                    "code": "import{cloneElement}from'react';// ...constclonedElement=cloneElement(<Row title=\"Cabbage\" />,{ isHighlighted: true });"
                },
                {
                    "type": "p",
                    "text": "Here, the resultingcloned elementwill be<Row title=\"Cabbage\" isHighlighted={true} />."
                },
                {
                    "type": "p",
                    "text": "Let’s walk through an example to see when it’s useful."
                },
                {
                    "type": "p",
                    "text": "Imagine aListcomponent that renders itschildrenas a list of selectable rows with a “Next” button that changes which row is selected. TheListcomponent needs to render the selectedRowdifferently, so it clones every<Row>child that it has received, and adds an extraisHighlighted: trueorisHighlighted: falseprop:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionList({children}){const[selectedIndex,setSelectedIndex]=useState(0);return(<divclassName=\"List\">{Children.map(children,(child,index)=>cloneElement(child,{isHighlighted:index===selectedIndex}))}"
                },
                {
                    "type": "p",
                    "text": "Let’s say the original JSX received byListlooks like this:"
                },
                {
                    "type": "code",
                    "code": "<List><Rowtitle=\"Cabbage\"/><Rowtitle=\"Garlic\"/><Rowtitle=\"Apple\"/></List>"
                },
                {
                    "type": "p",
                    "text": "By cloning its children, theListcan pass extra information to everyRowinside. The result looks like this:"
                },
                {
                    "type": "code",
                    "code": "<List><Rowtitle=\"Cabbage\"isHighlighted={true}/><Rowtitle=\"Garlic\"isHighlighted={false}/><Rowtitle=\"Apple\"isHighlighted={false}/></List>"
                },
                {
                    "type": "p",
                    "text": "Notice how pressing “Next” updates the state of theList, and highlights a different row:"
                },
                {
                    "type": "code",
                    "code": "import{Children,cloneElement,useState}from'react';exportdefaultfunctionList({children}){const[selectedIndex,setSelectedIndex]=useState(0);return(<divclassName=\"List\">{Children.map(children,(child,index)=>cloneElement(child,{isHighlighted:index===selectedIndex}))}<hr/><buttononClick={()=>{setSelectedIndex(i=>(i+1)%Children.count(children));}}>Next</button></div>);}"
                },
                {
                    "type": "p",
                    "text": "To summarize, theListcloned the<Row />elements it received and added an extra prop to them."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Cloning children makes it hard to tell how the data flows through your app. Try one of thealternatives."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Alternatives"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Passing data with a render prop"
                },
                {
                    "type": "p",
                    "text": "Instead of usingcloneElement, consider accepting arender proplikerenderItem. Here,ListreceivesrenderItemas a prop.ListcallsrenderItemfor every item and passesisHighlightedas an argument:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionList({items,renderItem}){const[selectedIndex,setSelectedIndex]=useState(0);return(<divclassName=\"List\">{items.map((item,index)=>{constisHighlighted=index===selectedIndex;returnrenderItem(item,isHighlighted);})}"
                },
                {
                    "type": "p",
                    "text": "TherenderItemprop is called a “render prop” because it’s a prop that specifies how to render something. For example, you can pass arenderItemimplementation that renders a<Row>with the givenisHighlightedvalue:"
                },
                {
                    "type": "code",
                    "code": "<Listitems={products}renderItem={(product,isHighlighted)=><Rowkey={product.id}title={product.title}isHighlighted={isHighlighted}/>}/>"
                },
                {
                    "type": "p",
                    "text": "The end result is the same as withcloneElement:"
                },
                {
                    "type": "code",
                    "code": "<List><Rowtitle=\"Cabbage\"isHighlighted={true}/><Rowtitle=\"Garlic\"isHighlighted={false}/><Rowtitle=\"Apple\"isHighlighted={false}/></List>"
                },
                {
                    "type": "p",
                    "text": "However, you can clearly trace where theisHighlightedvalue is coming from."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionList({items,renderItem}){const[selectedIndex,setSelectedIndex]=useState(0);return(<divclassName=\"List\">{items.map((item,index)=>{constisHighlighted=index===selectedIndex;returnrenderItem(item,isHighlighted);})}<hr/><buttononClick={()=>{setSelectedIndex(i=>(i+1)%items.length);}}>Next</button></div>);}"
                },
                {
                    "type": "p",
                    "text": "This pattern is preferred tocloneElementbecause it is more explicit."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Passing data through context"
                },
                {
                    "type": "p",
                    "text": "Another alternative tocloneElementis topass data through context."
                },
                {
                    "type": "p",
                    "text": "For example, you can callcreateContextto define aHighlightContext:"
                },
                {
                    "type": "code",
                    "code": "exportconstHighlightContext=createContext(false);"
                },
                {
                    "type": "p",
                    "text": "YourListcomponent can wrap every item it renders into aHighlightContextprovider:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionList({items,renderItem}){const[selectedIndex,setSelectedIndex]=useState(0);return(<divclassName=\"List\">{items.map((item,index)=>{constisHighlighted=index===selectedIndex;return(<HighlightContext.Providerkey={item.id}value={isHighlighted}>{renderItem(item)}</HighlightContext.Provider>);})}"
                },
                {
                    "type": "p",
                    "text": "With this approach,Rowdoes not need to receive anisHighlightedprop at all. Instead, it reads the context:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionRow({title}){constisHighlighted=useContext(HighlightContext);// ..."
                },
                {
                    "type": "p",
                    "text": "This allows the calling component to not know or worry about passingisHighlightedto<Row>:"
                },
                {
                    "type": "code",
                    "code": "<Listitems={products}renderItem={product=><Rowtitle={product.title}/>}/>"
                },
                {
                    "type": "p",
                    "text": "Instead,ListandRowcoordinate the highlighting logic through context."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';import{HighlightContext}from'./HighlightContext.js';exportdefaultfunctionList({items,renderItem}){const[selectedIndex,setSelectedIndex]=useState(0);return(<divclassName=\"List\">{items.map((item,index)=>{constisHighlighted=index===selectedIndex;return(<HighlightContext.Providerkey={item.id}value={isHighlighted}>{renderItem(item)}</HighlightContext.Provider>);})}<hr/><buttononClick={()=>{setSelectedIndex(i=>(i+1)%items.length);}}>Next</button></div>);}"
                },
                {
                    "type": "p",
                    "text": "Learn more about passing data through context."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Extracting logic into a custom Hook"
                },
                {
                    "type": "p",
                    "text": "Another approach you can try is to extract the “non-visual” logic into your own Hook, and use the information returned by your Hook to decide what to render. For example, you could write auseListcustom Hook like this:"
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionuseList(items){const[selectedIndex,setSelectedIndex]=useState(0);functiononNext(){setSelectedIndex(i=>(i+1)%items.length);}constselected=items[selectedIndex];return[selected,onNext];}"
                },
                {
                    "type": "p",
                    "text": "Then you could use it like this:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionApp(){const[selected,onNext]=useList(products);return(<divclassName=\"List\">{products.map(product=><Rowkey={product.id}title={product.title}isHighlighted={selected===product}/>)}<hr/><buttononClick={onNext}>Next</button></div>);}"
                },
                {
                    "type": "p",
                    "text": "The data flow is explicit, but the state is inside theuseListcustom Hook that you can use from any component:"
                },
                {
                    "type": "code",
                    "code": "importRowfrom'./Row.js';importuseListfrom'./useList.js';import{products}from'./data.js';exportdefaultfunctionApp(){const[selected,onNext]=useList(products);return(<divclassName=\"List\">{products.map(product=><Rowkey={product.id}title={product.title}isHighlighted={selected===product}/>)}<hr/><buttononClick={onNext}>Next</button></div>);}"
                },
                {
                    "type": "p",
                    "text": "This approach is particularly useful if you want to reuse this logic between different components."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/components",
            "title": "Built-in React Components – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Built-in React Components"
                },
                {
                    "type": "p",
                    "text": "React exposes a few built-in components that you can use in your JSX."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Built-in components"
                },
                {
                    "type": "list",
                    "items": [
                        "<Fragment>, alternatively written as<>...</>, lets you group multiple JSX nodes together.",
                        "<Profiler>lets you measure rendering performance of a React tree programmatically.",
                        "<Suspense>lets you display a fallback while the child components are loading.",
                        "<StrictMode>enables extra development-only checks that help you find bugs early."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Your own components"
                },
                {
                    "type": "p",
                    "text": "You can alsodefine your own componentsas JavaScript functions."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/createContext",
            "title": "createContext – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "createContext"
                },
                {
                    "type": "p",
                    "text": "createContextlets you create acontextthat components can provide or read."
                },
                {
                    "type": "code",
                    "code": "constSomeContext=createContext(defaultValue)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferencecreateContext(defaultValue)SomeContext.ProviderSomeContext.Consumer",
                        "createContext(defaultValue)",
                        "SomeContext.Provider",
                        "SomeContext.Consumer",
                        "UsageCreating contextImporting and exporting context from a file",
                        "Creating context",
                        "Importing and exporting context from a file",
                        "TroubleshootingI can’t find a way to change the context value",
                        "I can’t find a way to change the context value"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "createContext(defaultValue)",
                        "SomeContext.Provider",
                        "SomeContext.Consumer"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Creating context",
                        "Importing and exporting context from a file"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "I can’t find a way to change the context value"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "createContext(defaultValue)"
                },
                {
                    "type": "p",
                    "text": "CallcreateContextoutside of any components to create a context."
                },
                {
                    "type": "code",
                    "code": "import{createContext}from'react';constThemeContext=createContext('light');"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "defaultValue: The value that you want the context to have when there is no matching context provider in the tree above the component that reads context. If you don’t have any meaningful default value, specifynull. The default value is meant as a “last resort” fallback. It is static and never changes over time."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "createContextreturns a context object."
                },
                {
                    "type": "p",
                    "text": "The context object itself does not hold any information.It representswhichcontext other components read or provide. Typically, you will useSomeContext.Providerin components above to specify the context value, and calluseContext(SomeContext)in components below to read it. The context object has a few properties:"
                },
                {
                    "type": "list",
                    "items": [
                        "SomeContext.Providerlets you provide the context value to components.",
                        "SomeContext.Consumeris an alternative and rarely used way to read the context value."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "SomeContext.Provider"
                },
                {
                    "type": "p",
                    "text": "Wrap your components into a context provider to specify the value of this context for all components inside:"
                },
                {
                    "type": "code",
                    "code": "functionApp(){const[theme,setTheme]=useState('light');// ...return(<ThemeContext.Providervalue={theme}><Page/></ThemeContext.Provider>);}"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Props"
                },
                {
                    "type": "list",
                    "items": [
                        "value: The value that you want to pass to all the components reading this context inside this provider, no matter how deep. The context value can be of any type. A component callinguseContext(SomeContext)inside of the provider receives thevalueof the innermost corresponding context provider above it."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "SomeContext.Consumer"
                },
                {
                    "type": "p",
                    "text": "BeforeuseContextexisted, there was an older way to read context:"
                },
                {
                    "type": "code",
                    "code": "functionButton(){// 🟡 Legacy way (not recommended)return(<ThemeContext.Consumer>{theme=>(<buttonclassName={theme}/>)}</ThemeContext.Consumer>);}"
                },
                {
                    "type": "p",
                    "text": "Although this older way still works, butnewly written code should read context withuseContext()instead:"
                },
                {
                    "type": "code",
                    "code": "functionButton(){// ✅ Recommended wayconsttheme=useContext(ThemeContext);return<buttonclassName={theme}/>;}"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Props"
                },
                {
                    "type": "list",
                    "items": [
                        "children: A function. React will call the function you pass with the current context value determined by the same algorithm asuseContext()does, and render the result you return from this function. React will also re-run this function and update the UI whenever the context from the parent components changes."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Creating context"
                },
                {
                    "type": "p",
                    "text": "Context lets componentspass information deep downwithout explicitly passing props."
                },
                {
                    "type": "p",
                    "text": "CallcreateContextoutside any components to create one or more contexts."
                },
                {
                    "type": "code",
                    "code": "import{createContext}from'react';constThemeContext=createContext('light');constAuthContext=createContext(null);"
                },
                {
                    "type": "p",
                    "text": "createContextreturns acontext object. Components can read context by passing it touseContext():"
                },
                {
                    "type": "code",
                    "code": "functionButton(){consttheme=useContext(ThemeContext);// ...}functionProfile(){constcurrentUser=useContext(AuthContext);// ...}"
                },
                {
                    "type": "p",
                    "text": "By default, the values they receive will be thedefault valuesyou have specified when creating the contexts. However, by itself this isn’t useful because the default values never change."
                },
                {
                    "type": "p",
                    "text": "Context is useful because you canprovide other, dynamic values from your components:"
                },
                {
                    "type": "code",
                    "code": "functionApp(){const[theme,setTheme]=useState('dark');const[currentUser,setCurrentUser]=useState({name:'Taylor'});// ...return(<ThemeContext.Providervalue={theme}><AuthContext.Providervalue={currentUser}><Page/></AuthContext.Provider></ThemeContext.Provider>);}"
                },
                {
                    "type": "p",
                    "text": "Now thePagecomponent and any components inside it, no matter how deep, will “see” the passed context values. If the passed context values change, React will re-render the components reading the context as well."
                },
                {
                    "type": "p",
                    "text": "Read more about reading and providing context and see examples."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Importing and exporting context from a file"
                },
                {
                    "type": "p",
                    "text": "Often, components in different files will need access to the same context. This is why it’s common to declare contexts in a separate file. Then you can use theexportstatementto make context available for other files:"
                },
                {
                    "type": "code",
                    "code": "// Contexts.jsimport{createContext}from'react';exportconstThemeContext=createContext('light');exportconstAuthContext=createContext(null);"
                },
                {
                    "type": "p",
                    "text": "Components declared in other files can then use theimportstatement to read or provide this context:"
                },
                {
                    "type": "code",
                    "code": "// Button.jsimport{ThemeContext}from'./Contexts.js';functionButton(){consttheme=useContext(ThemeContext);// ...}"
                },
                {
                    "type": "code",
                    "code": "// App.jsimport{ThemeContext,AuthContext}from'./Contexts.js';functionApp(){// ...return(<ThemeContext.Providervalue={theme}><AuthContext.Providervalue={currentUser}><Page/></AuthContext.Provider></ThemeContext.Provider>);}"
                },
                {
                    "type": "p",
                    "text": "This works similar toimporting and exporting components."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I can’t find a way to change the context value"
                },
                {
                    "type": "p",
                    "text": "Code like this specifies thedefaultcontext value:"
                },
                {
                    "type": "code",
                    "code": "constThemeContext=createContext('light');"
                },
                {
                    "type": "p",
                    "text": "This value never changes. React only uses this value as a fallback if it can’t find a matching provider above."
                },
                {
                    "type": "p",
                    "text": "To make context change over time,add state and wrap components in a context provider."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/createElement",
            "title": "createElement – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "createElement"
                },
                {
                    "type": "p",
                    "text": "createElementlets you create a React element. It serves as an alternative to writingJSX."
                },
                {
                    "type": "code",
                    "code": "constelement=createElement(type,props,...children)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferencecreateElement(type, props, ...children)",
                        "createElement(type, props, ...children)",
                        "UsageCreating an element without JSX",
                        "Creating an element without JSX"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "createElement(type, props, ...children)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Creating an element without JSX"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "createElement(type, props, ...children)"
                },
                {
                    "type": "p",
                    "text": "CallcreateElementto create a React element with the giventype,props, andchildren."
                },
                {
                    "type": "code",
                    "code": "import{createElement}from'react';functionGreeting({name}){returncreateElement('h1',{className:'greeting'},'Hello');}"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "type: Thetypeargument must be a valid React component type. For example, it could be a tag name string (such as'div'or'span'), or a React component (a function, a class, or a special component likeFragment).",
                        "props: Thepropsargument must either be an object ornull. If you passnull, it will be treated the same as an empty object. React will create an element with props matching thepropsyou have passed. Note thatrefandkeyfrom yourpropsobject are special and willnotbe available aselement.props.refandelement.props.keyon the returnedelement. They will be available aselement.refandelement.key.",
                        "optional...children: Zero or more child nodes. They can be any React nodes, including React elements, strings, numbers,portals, empty nodes (null,undefined,true, andfalse), and arrays of React nodes."
                    ]
                },
                {
                    "type": "p",
                    "text": "type: Thetypeargument must be a valid React component type. For example, it could be a tag name string (such as'div'or'span'), or a React component (a function, a class, or a special component likeFragment)."
                },
                {
                    "type": "p",
                    "text": "props: Thepropsargument must either be an object ornull. If you passnull, it will be treated the same as an empty object. React will create an element with props matching thepropsyou have passed. Note thatrefandkeyfrom yourpropsobject are special and willnotbe available aselement.props.refandelement.props.keyon the returnedelement. They will be available aselement.refandelement.key."
                },
                {
                    "type": "p",
                    "text": "optional...children: Zero or more child nodes. They can be any React nodes, including React elements, strings, numbers,portals, empty nodes (null,undefined,true, andfalse), and arrays of React nodes."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "createElementreturns a React element object with a few properties:"
                },
                {
                    "type": "list",
                    "items": [
                        "type: Thetypeyou have passed.",
                        "props: Thepropsyou have passed except forrefandkey. If thetypeis a component with legacytype.defaultProps, then any missing or undefinedpropswill get the values fromtype.defaultProps.",
                        "ref: Therefyou have passed. If missing,null.",
                        "key: Thekeyyou have passed, coerced to a string. If missing,null."
                    ]
                },
                {
                    "type": "p",
                    "text": "Usually, you’ll return the element from your component or make it a child of another element. Although you may read the element’s properties, it’s best to treat every element as opaque after it’s created, and only render it."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "You musttreat React elements and their props asimmutableand never change their contents after creation. In development, React willfreezethe returned element and itspropsproperty shallowly to enforce this.",
                        "When you use JSX,you must start a tag with a capital letter to render your own custom component.In other words,<Something />is equivalent tocreateElement(Something), but<something />(lowercase) is equivalent tocreateElement('something')(note it’s a string, so it will be treated as a built-in HTML tag).",
                        "You should onlypass children as multiple arguments tocreateElementif they are all statically known,likecreateElement('h1', {}, child1, child2, child3). If your children are dynamic, pass the entire array as the third argument:createElement('ul', {}, listItems). This ensures that React willwarn you about missingkeysfor any dynamic lists. For static lists this is not necessary because they never reorder."
                    ]
                },
                {
                    "type": "p",
                    "text": "You musttreat React elements and their props asimmutableand never change their contents after creation. In development, React willfreezethe returned element and itspropsproperty shallowly to enforce this."
                },
                {
                    "type": "p",
                    "text": "When you use JSX,you must start a tag with a capital letter to render your own custom component.In other words,<Something />is equivalent tocreateElement(Something), but<something />(lowercase) is equivalent tocreateElement('something')(note it’s a string, so it will be treated as a built-in HTML tag)."
                },
                {
                    "type": "p",
                    "text": "You should onlypass children as multiple arguments tocreateElementif they are all statically known,likecreateElement('h1', {}, child1, child2, child3). If your children are dynamic, pass the entire array as the third argument:createElement('ul', {}, listItems). This ensures that React willwarn you about missingkeysfor any dynamic lists. For static lists this is not necessary because they never reorder."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Creating an element without JSX"
                },
                {
                    "type": "p",
                    "text": "If you don’t likeJSXor can’t use it in your project, you can usecreateElementas an alternative."
                },
                {
                    "type": "p",
                    "text": "To create an element without JSX, callcreateElementwith sometype,props, andchildren:"
                },
                {
                    "type": "code",
                    "code": "import{createElement}from'react';functionGreeting({name}){returncreateElement('h1',{ className: 'greeting' },'Hello ',createElement('i', null, name),'. Welcome!');}"
                },
                {
                    "type": "p",
                    "text": "Thechildrenare optional, and you can pass as many as you need (the example above has three children). This code will display a<h1>header with a greeting. For comparison, here is the same example rewritten with JSX:"
                },
                {
                    "type": "code",
                    "code": "functionGreeting({name}){return(<h1className=\"greeting\">Hello <i>{name}</i>. Welcome!</h1>);}"
                },
                {
                    "type": "p",
                    "text": "To render your own React component, pass a function likeGreetingas thetypeinstead of a string like'h1':"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionApp(){returncreateElement(Greeting,{ name: 'Taylor' });}"
                },
                {
                    "type": "p",
                    "text": "With JSX, it would look like this:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionApp(){return<Greetingname=\"Taylor\"/>;}"
                },
                {
                    "type": "p",
                    "text": "Here is a complete example written withcreateElement:"
                },
                {
                    "type": "code",
                    "code": "import{createElement}from'react';functionGreeting({name}){returncreateElement('h1',{className:'greeting'},'Hello ',createElement('i',null,name),'. Welcome!');}exportdefaultfunctionApp(){returncreateElement(Greeting,{name:'Taylor'});}"
                },
                {
                    "type": "p",
                    "text": "And here is the same example written using JSX:"
                },
                {
                    "type": "code",
                    "code": "functionGreeting({name}){return(<h1className=\"greeting\">Hello<i>{name}</i>. Welcome!</h1>);}exportdefaultfunctionApp(){return<Greetingname=\"Taylor\"/>;}"
                },
                {
                    "type": "p",
                    "text": "Both coding styles are fine, so you can use whichever one you prefer for your project. The main benefit of using JSX compared tocreateElementis that it’s easy to see which closing tag corresponds to which opening tag."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "What is a React element, exactly?"
                },
                {
                    "type": "p",
                    "text": "An element is a lightweight description of a piece of the user interface. For example, both<Greeting name=\"Taylor\" />andcreateElement(Greeting, { name: 'Taylor' })produce an object like this:"
                },
                {
                    "type": "code",
                    "code": "// Slightly simplified{type:Greeting,props:{name:'Taylor'},key:null,ref:null,}"
                },
                {
                    "type": "p",
                    "text": "Note that creating this object does not render theGreetingcomponent or create any DOM elements."
                },
                {
                    "type": "p",
                    "text": "A React element is more like a description—an instruction for React to later render theGreetingcomponent. By returning this object from yourAppcomponent, you tell React what to do next."
                },
                {
                    "type": "p",
                    "text": "Creating elements is extremely cheap so you don’t need to try to optimize or avoid it."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/createFactory",
            "title": "createFactory – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "createFactory"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Deprecated"
                },
                {
                    "type": "p",
                    "text": "This API will be removed in a future major version of React.See the alternatives."
                },
                {
                    "type": "p",
                    "text": "createFactorylets you create a function that produces React elements of a given type."
                },
                {
                    "type": "code",
                    "code": "constfactory=createFactory(type)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferencecreateFactory(type)",
                        "createFactory(type)",
                        "UsageCreating React elements with a factory",
                        "Creating React elements with a factory",
                        "AlternativesCopyingcreateFactoryinto your projectReplacingcreateFactorywithcreateElementReplacingcreateFactorywith JSX",
                        "CopyingcreateFactoryinto your project",
                        "ReplacingcreateFactorywithcreateElement",
                        "ReplacingcreateFactorywith JSX"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "createFactory(type)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Creating React elements with a factory"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "CopyingcreateFactoryinto your project",
                        "ReplacingcreateFactorywithcreateElement",
                        "ReplacingcreateFactorywith JSX"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "createFactory(type)"
                },
                {
                    "type": "p",
                    "text": "CallcreateFactory(type)to create a factory function which produces React elements of a giventype."
                },
                {
                    "type": "code",
                    "code": "import{createFactory}from'react';constbutton=createFactory('button');"
                },
                {
                    "type": "p",
                    "text": "Then you can use it to create React elements without JSX:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionApp(){returnbutton({onClick:()=>{alert('Clicked!')}},'Click me');}"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "type: Thetypeargument must be a valid React component type. For example, it could be a tag name string (such as'div'or'span'), or a React component (a function, a class, or a special component likeFragment)."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "Returns a factory function. That factory function receives apropsobject as the first argument, followed by a list of...childrenarguments, and returns a React element with the giventype,propsandchildren."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Creating React elements with a factory"
                },
                {
                    "type": "p",
                    "text": "Although most React projects useJSXto describe the user interface, JSX is not required. In the past,createFactoryused to be one of the ways you could describe the user interface without JSX."
                },
                {
                    "type": "p",
                    "text": "CallcreateFactoryto create afactory functionfor a specific element type like'button':"
                },
                {
                    "type": "code",
                    "code": "import{createFactory}from'react';constbutton=createFactory('button');"
                },
                {
                    "type": "p",
                    "text": "Calling that factory function will produce React elements with the props and children you have provided:"
                },
                {
                    "type": "code",
                    "code": "import{createFactory}from'react';constbutton=createFactory('button');exportdefaultfunctionApp(){returnbutton({onClick:()=>{alert('Clicked!')}},'Click me');}"
                },
                {
                    "type": "p",
                    "text": "This is howcreateFactorywas used as an alternative to JSX. However,createFactoryis deprecated, and you should not callcreateFactoryin any new code. See how to migrate away fromcreateFactorybelow."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Alternatives"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "CopyingcreateFactoryinto your project"
                },
                {
                    "type": "p",
                    "text": "If your project has manycreateFactorycalls, copy thiscreateFactory.jsimplementation into your project:"
                },
                {
                    "type": "code",
                    "code": "import{createFactory}from'./createFactory.js';constbutton=createFactory('button');exportdefaultfunctionApp(){returnbutton({onClick:()=>{alert('Clicked!')}},'Click me');}"
                },
                {
                    "type": "p",
                    "text": "This lets you keep all of your code unchanged except the imports."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "ReplacingcreateFactorywithcreateElement"
                },
                {
                    "type": "p",
                    "text": "If you have a fewcreateFactorycalls that you don’t mind porting manually, and you don’t want to use JSX, you can replace every call a factory function with acreateElementcall. For example, you can replace this code:"
                },
                {
                    "type": "code",
                    "code": "import{createFactory}from'react';constbutton=createFactory('button');exportdefaultfunctionApp(){returnbutton({onClick:()=>{alert('Clicked!')}},'Click me');}"
                },
                {
                    "type": "p",
                    "text": "with this code:"
                },
                {
                    "type": "code",
                    "code": "import{createElement}from'react';exportdefaultfunctionApp(){returncreateElement('button',{onClick:()=>{alert('Clicked!')}},'Click me');}"
                },
                {
                    "type": "p",
                    "text": "Here is a complete example of using React without JSX:"
                },
                {
                    "type": "code",
                    "code": "import{createElement}from'react';exportdefaultfunctionApp(){returncreateElement('button',{onClick:()=>{alert('Clicked!')}},'Click me');}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "ReplacingcreateFactorywith JSX"
                },
                {
                    "type": "p",
                    "text": "Finally, you can use JSX instead ofcreateFactory. This is the most common way to use React:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionApp(){return(<buttononClick={()=>{alert('Clicked!');}}>Click me</button>);};"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Sometimes, your existing code might pass some variable as atypeinstead of a constant like'button':"
                },
                {
                    "type": "code",
                    "code": "functionHeading({isSubheading,...props}){consttype=isSubheading?'h2':'h1';constfactory=createFactory(type);returnfactory(props);}"
                },
                {
                    "type": "p",
                    "text": "To do the same in JSX, you need to rename your variable to start with an uppercase letter likeType:"
                },
                {
                    "type": "code",
                    "code": "functionHeading({isSubheading,...props}){constType=isSubheading?'h2':'h1';return<Type{...props}/>;}"
                },
                {
                    "type": "p",
                    "text": "Otherwise React will interpret<type>as a built-in HTML tag because it is lowercase."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/createRef",
            "title": "createRef – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "createRef"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "createRefis mostly used forclass components.Function components typically rely onuseRefinstead."
                },
                {
                    "type": "p",
                    "text": "createRefcreates arefobject which can contain arbitrary value."
                },
                {
                    "type": "code",
                    "code": "classMyInputextendsComponent{inputRef=createRef();// ...}"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferencecreateRef()",
                        "createRef()",
                        "UsageDeclaring a ref in a class component",
                        "Declaring a ref in a class component",
                        "AlternativesMigrating from a class withcreateRefto a function withuseRef",
                        "Migrating from a class withcreateRefto a function withuseRef"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "createRef()"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Declaring a ref in a class component"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Migrating from a class withcreateRefto a function withuseRef"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "createRef()"
                },
                {
                    "type": "p",
                    "text": "CallcreateRefto declare arefinside aclass component."
                },
                {
                    "type": "code",
                    "code": "import{createRef,Component}from'react';classMyComponentextendsComponent{intervalRef=createRef();inputRef=createRef();// ..."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "p",
                    "text": "createReftakes no parameters."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "createRefreturns an object with a single property:"
                },
                {
                    "type": "list",
                    "items": [
                        "current: Initially, it’s set to thenull. You can later set it to something else. If you pass the ref object to React as arefattribute to a JSX node, React will set itscurrentproperty."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "createRefalways returns adifferentobject. It’s equivalent to writing{ current: null }yourself.",
                        "In a function component, you probably wantuseRefinstead which always returns the same object.",
                        "const ref = useRef()is equivalent toconst [ref, _] = useState(() => createRef(null))."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Declaring a ref in a class component"
                },
                {
                    "type": "p",
                    "text": "To declare a ref inside aclass component,callcreateRefand assign its result to a class field:"
                },
                {
                    "type": "code",
                    "code": "import{Component,createRef}from'react';classFormextendsComponent{inputRef=createRef();// ...}"
                },
                {
                    "type": "p",
                    "text": "If you now passref={this.inputRef}to an<input>in your JSX, React will populatethis.inputRef.currentwith the input DOM node. For example, here is how you make a button that focuses the input:"
                },
                {
                    "type": "code",
                    "code": "import{Component,createRef}from'react';exportdefaultclassFormextendsComponent{inputRef=createRef();handleClick=()=>{this.inputRef.current.focus();}render(){return(<><inputref={this.inputRef}/><buttononClick={this.handleClick}>Focus the input</button></>);}}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "createRefis mostly used forclass components.Function components typically rely onuseRefinstead."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Alternatives"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Migrating from a class withcreateRefto a function withuseRef"
                },
                {
                    "type": "p",
                    "text": "We recommend using function components instead ofclass componentsin new code. If you have some existing class components usingcreateRef, here is how you can convert them. This is the original code:"
                },
                {
                    "type": "code",
                    "code": "import{Component,createRef}from'react';exportdefaultclassFormextendsComponent{inputRef=createRef();handleClick=()=>{this.inputRef.current.focus();}render(){return(<><inputref={this.inputRef}/><buttononClick={this.handleClick}>Focus the input</button></>);}}"
                },
                {
                    "type": "p",
                    "text": "When youconvert this component from a class to a function,replace calls tocreateRefwith calls touseRef:"
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';exportdefaultfunctionForm(){constinputRef=useRef(null);functionhandleClick(){inputRef.current.focus();}return(<><inputref={inputRef}/><buttononClick={handleClick}>Focus the input</button></>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/experimental_taintObjectReference",
            "title": "experimental_taintObjectReference – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "experimental_taintObjectReference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Under Construction"
                },
                {
                    "type": "p",
                    "text": "This API is experimental and is not available in a stable version of React yet."
                },
                {
                    "type": "p",
                    "text": "You can try it by upgrading React packages to the most recent experimental version:"
                },
                {
                    "type": "list",
                    "items": [
                        "react@experimental",
                        "react-dom@experimental",
                        "eslint-plugin-react-hooks@experimental"
                    ]
                },
                {
                    "type": "p",
                    "text": "Experimental versions of React may contain bugs. Don’t use them in production."
                },
                {
                    "type": "p",
                    "text": "This API is only available inside React Server Components."
                },
                {
                    "type": "p",
                    "text": "taintObjectReferencelets you prevent a specific object instance from being passed to a Client Component like auserobject."
                },
                {
                    "type": "code",
                    "code": "experimental_taintObjectReference(message,object);"
                },
                {
                    "type": "p",
                    "text": "To prevent passing a key, hash or token, seetaintUniqueValue."
                },
                {
                    "type": "list",
                    "items": [
                        "ReferencetaintObjectReference(message, object)",
                        "taintObjectReference(message, object)",
                        "UsagePrevent user data from unintentionally reaching the client",
                        "Prevent user data from unintentionally reaching the client"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "taintObjectReference(message, object)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Prevent user data from unintentionally reaching the client"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "taintObjectReference(message, object)"
                },
                {
                    "type": "p",
                    "text": "CalltaintObjectReferencewith an object to register it with React as something that should not be allowed to be passed to the Client as is:"
                },
                {
                    "type": "code",
                    "code": "import{experimental_taintObjectReference}from'react';experimental_taintObjectReference('Do not pass ALL environment variables to the client.',process.env);"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "message: The message you want to display if the object gets passed to a Client Component. This message will be displayed as a part of the Error that will be thrown if the object gets passed to a Client Component.",
                        "object: The object to be tainted. Functions and class instances can be passed totaintObjectReferenceasobject. Functions and classes are already blocked from being passed to Client Components but the React’s default error message will be replaced by what you defined inmessage. When a specific instance of a Typed Array is passed totaintObjectReferenceasobject, any other copies of the Typed Array will not be tainted."
                    ]
                },
                {
                    "type": "p",
                    "text": "message: The message you want to display if the object gets passed to a Client Component. This message will be displayed as a part of the Error that will be thrown if the object gets passed to a Client Component."
                },
                {
                    "type": "p",
                    "text": "object: The object to be tainted. Functions and class instances can be passed totaintObjectReferenceasobject. Functions and classes are already blocked from being passed to Client Components but the React’s default error message will be replaced by what you defined inmessage. When a specific instance of a Typed Array is passed totaintObjectReferenceasobject, any other copies of the Typed Array will not be tainted."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "experimental_taintObjectReferencereturnsundefined."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Recreating or cloning a tainted object creates a new untainted object which may contain sensitive data. For example, if you have a tainteduserobject,const userInfo = {name: user.name, ssn: user.ssn}or{...user}will create new objects which are not tainted.taintObjectReferenceonly protects against simple mistakes when the object is passed through to a Client Component unchanged."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Do not rely on just tainting for security.Tainting an object doesn’t prevent leaking of every possible derived value. For example, the clone of a tainted object will create a new untainted object. Using data from a tainted object (e.g.{secret: taintedObj.secret}) will create a new value or object that is not tainted. Tainting is a layer of protection; a secure app will have multiple layers of protection, well designed APIs, and isolation patterns."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Prevent user data from unintentionally reaching the client"
                },
                {
                    "type": "p",
                    "text": "A Client Component should never accept objects that carry sensitive data. Ideally, the data fetching functions should not expose data that the current user should not have access to. Sometimes mistakes happen during refactoring. To protect against these mistakes happening down the line we can “taint” the user object in our data API."
                },
                {
                    "type": "code",
                    "code": "import{experimental_taintObjectReference}from'react';exportasyncfunctiongetUser(id){constuser=awaitdb`SELECT * FROM users WHERE id =${id}`;experimental_taintObjectReference('Do not pass the entire user object to the client. '+'Instead, pick off the specific properties you need for this use case.',user,);returnuser;}"
                },
                {
                    "type": "p",
                    "text": "Now whenever anyone tries to pass this object to a Client Component, an error will be thrown with the passed in error message instead."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Protecting against leaks in data fetching"
                },
                {
                    "type": "p",
                    "text": "If you’re running a Server Components environment that has access to sensitive data, you have to be careful not to pass objects straight through:"
                },
                {
                    "type": "code",
                    "code": "// api.jsexportasyncfunctiongetUser(id){constuser=awaitdb`SELECT * FROM users WHERE id =${id}`;returnuser;}"
                },
                {
                    "type": "code",
                    "code": "import{getUser}from'api.js';import{InfoCard}from'components.js';exportasyncfunctionProfile(props){constuser=awaitgetUser(props.userId);// DO NOT DO THISreturn<InfoCarduser={user}/>;}"
                },
                {
                    "type": "code",
                    "code": "// components.js\"use client\";exportasyncfunctionInfoCard({user}){return<div>{user.name}</div>;}"
                },
                {
                    "type": "p",
                    "text": "Ideally, thegetUsershould not expose data that the current user should not have access to. To prevent passing theuserobject to a Client Component down the line we can “taint” the user object:"
                },
                {
                    "type": "code",
                    "code": "// api.jsimport{experimental_taintObjectReference}from'react';exportasyncfunctiongetUser(id){constuser=awaitdb`SELECT * FROM users WHERE id =${id}`;experimental_taintObjectReference('Do not pass the entire user object to the client. '+'Instead, pick off the specific properties you need for this use case.',user,);returnuser;}"
                },
                {
                    "type": "p",
                    "text": "Now if anyone tries to pass theuserobject to a Client Component, an error will be thrown with the passed in error message."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/experimental_taintUniqueValue",
            "title": "experimental_taintUniqueValue – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "experimental_taintUniqueValue"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Under Construction"
                },
                {
                    "type": "p",
                    "text": "This API is experimental and is not available in a stable version of React yet."
                },
                {
                    "type": "p",
                    "text": "You can try it by upgrading React packages to the most recent experimental version:"
                },
                {
                    "type": "list",
                    "items": [
                        "react@experimental",
                        "react-dom@experimental",
                        "eslint-plugin-react-hooks@experimental"
                    ]
                },
                {
                    "type": "p",
                    "text": "Experimental versions of React may contain bugs. Don’t use them in production."
                },
                {
                    "type": "p",
                    "text": "This API is only available insideReact Server Components."
                },
                {
                    "type": "p",
                    "text": "taintUniqueValuelets you prevent unique values from being passed to Client Components like passwords, keys, or tokens."
                },
                {
                    "type": "code",
                    "code": "taintUniqueValue(errMessage,lifetime,value)"
                },
                {
                    "type": "p",
                    "text": "To prevent passing an object containing sensitive data, seetaintObjectReference."
                },
                {
                    "type": "list",
                    "items": [
                        "ReferencetaintUniqueValue(message, lifetime, value)",
                        "taintUniqueValue(message, lifetime, value)",
                        "UsagePrevent a token from being passed to Client Components",
                        "Prevent a token from being passed to Client Components"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "taintUniqueValue(message, lifetime, value)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Prevent a token from being passed to Client Components"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "taintUniqueValue(message, lifetime, value)"
                },
                {
                    "type": "p",
                    "text": "CalltaintUniqueValuewith a password, token, key or hash to register it with React as something that should not be allowed to be passed to the Client as is:"
                },
                {
                    "type": "code",
                    "code": "import{experimental_taintUniqueValue}from'react';experimental_taintUniqueValue('Do not pass secret keys to the client.',process,process.env.SECRET_KEY);"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "message: The message you want to display ifvalueis passed to a Client Component. This message will be displayed as a part of the Error that will be thrown ifvalueis passed to a Client Component.",
                        "lifetime: Any object that indicates how longvalueshould be tainted.valuewill be blocked from being sent to any Client Component while this object still exists. For example, passingglobalThisblocks the value for the lifetime of an app.lifetimeis typically an object whose properties containsvalue.",
                        "value: A string, bigint or TypedArray.valuemust be a unique sequence of characters or bytes with high entropy such as a cryptographic token, private key, hash, or a long password.valuewill be blocked from being sent to any Client Component."
                    ]
                },
                {
                    "type": "p",
                    "text": "message: The message you want to display ifvalueis passed to a Client Component. This message will be displayed as a part of the Error that will be thrown ifvalueis passed to a Client Component."
                },
                {
                    "type": "p",
                    "text": "lifetime: Any object that indicates how longvalueshould be tainted.valuewill be blocked from being sent to any Client Component while this object still exists. For example, passingglobalThisblocks the value for the lifetime of an app.lifetimeis typically an object whose properties containsvalue."
                },
                {
                    "type": "p",
                    "text": "value: A string, bigint or TypedArray.valuemust be a unique sequence of characters or bytes with high entropy such as a cryptographic token, private key, hash, or a long password.valuewill be blocked from being sent to any Client Component."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "experimental_taintUniqueValuereturnsundefined."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Deriving new values from tainted values can compromise tainting protection. New values created by uppercasing tainted values, concatenating tainted string values into a larger string, converting tainted values to base64, substringing tainted values, and other similar transformations are not tainted unless you explicitly calltaintUniqueValueon these newly created values.",
                        "Do not usetaintUniqueValueto protect low-entropy values such as PIN codes or phone numbers. If any value in a request is controlled by an attacker, they could infer which value is tainted by enumerating all possible values of the secret."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Prevent a token from being passed to Client Components"
                },
                {
                    "type": "p",
                    "text": "To ensure that sensitive information such as passwords, session tokens, or other unique values do not inadvertently get passed to Client Components, thetaintUniqueValuefunction provides a layer of protection. When a value is tainted, any attempt to pass it to a Client Component will result in an error."
                },
                {
                    "type": "p",
                    "text": "Thelifetimeargument defines the duration for which the value remains tainted. For values that should remain tainted indefinitely, objects likeglobalThisorprocesscan serve as thelifetimeargument. These objects have a lifespan that spans the entire duration of your app’s execution."
                },
                {
                    "type": "code",
                    "code": "import{experimental_taintUniqueValue}from'react';experimental_taintUniqueValue('Do not pass a user password to the client.',globalThis,process.env.SECRET_KEY);"
                },
                {
                    "type": "p",
                    "text": "If the tainted value’s lifespan is tied to a object, thelifetimeshould be the object that encapsulates the value. This ensures the tainted value remains protected for the lifetime of the encapsulating object."
                },
                {
                    "type": "code",
                    "code": "import{experimental_taintUniqueValue}from'react';exportasyncfunctiongetUser(id){constuser=awaitdb`SELECT * FROM users WHERE id =${id}`;experimental_taintUniqueValue('Do not pass a user session token to the client.',user,user.session.token);returnuser;}"
                },
                {
                    "type": "p",
                    "text": "In this example, theuserobject serves as thelifetimeargument. If this object gets stored in a global cache or is accessible by another request, the session token remains tainted."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Do not rely solely on tainting for security.Tainting a value doesn’t block every possible derived value. For example, creating a new value by upper casing a tainted string will not taint the new value."
                },
                {
                    "type": "code",
                    "code": "import{experimental_taintUniqueValue}from'react';constpassword='correct horse battery staple';experimental_taintUniqueValue('Do not pass the password to the client.',globalThis,password);constuppercasePassword=password.toUpperCase()// `uppercasePassword` is not tainted"
                },
                {
                    "type": "p",
                    "text": "In this example, the constantpasswordis tainted. Thenpasswordis used to create a new valueuppercasePasswordby calling thetoUpperCasemethod onpassword. The newly createduppercasePasswordis not tainted."
                },
                {
                    "type": "p",
                    "text": "Other similar ways of deriving new values from tainted values like concatenating it into a larger string, converting it to base64, or returning a substring create untained values."
                },
                {
                    "type": "p",
                    "text": "Tainting only protects against simple mistakes like explicitly passing secret values to the client. Mistakes in calling thetaintUniqueValuelike using a global store outside of React, without the corresponding lifetime object, can cause the tainted value to become untainted. Tainting is a layer of protection; a secure app will have multiple layers of protection, well designed APIs, and isolation patterns."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Usingserver-onlyandtaintUniqueValueto prevent leaking secrets"
                },
                {
                    "type": "p",
                    "text": "If you’re running a Server Components environment that has access to private keys or passwords such as database passwords, you have to be careful not to pass that to a Client Component."
                },
                {
                    "type": "code",
                    "code": "exportasyncfunctionDashboard(props){// DO NOT DO THISreturn<Overviewpassword={process.env.API_PASSWORD}/>;}"
                },
                {
                    "type": "code",
                    "code": "\"use client\";import{useEffect}from'...'exportasyncfunctionOverview({password}){useEffect(()=>{constheaders={Authorization:password};fetch(url,{headers}).then(...);},[password]);...}"
                },
                {
                    "type": "p",
                    "text": "This example would leak the secret API token to the client. If this API token can be used to access data this particular user shouldn’t have access to, it could lead to a data breach."
                },
                {
                    "type": "p",
                    "text": "Ideally, secrets like this are abstracted into a single helper file that can only be imported by trusted data utilities on the server. The helper can even be tagged withserver-onlyto ensure that this file isn’t imported on the client."
                },
                {
                    "type": "code",
                    "code": "import\"server-only\";exportfunctionfetchAPI(url){constheaders={Authorization:process.env.API_PASSWORD};returnfetch(url,{headers});}"
                },
                {
                    "type": "p",
                    "text": "Sometimes mistakes happen during refactoring and not all of your colleagues might know about this.\nTo protect against this mistakes happening down the line we can “taint” the actual password:"
                },
                {
                    "type": "code",
                    "code": "import\"server-only\";import{experimental_taintUniqueValue}from'react';experimental_taintUniqueValue('Do not pass the API token password to the client. '+'Instead do all fetches on the server.'process,process.env.API_PASSWORD);"
                },
                {
                    "type": "p",
                    "text": "Now whenever anyone tries to pass this password to a Client Component, or send the password to a Client Component with a Server Action, an error will be thrown with message you defined when you calledtaintUniqueValue."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/experimental_useEffectEvent",
            "title": "experimental_useEffectEvent – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "experimental_useEffectEvent"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Under Construction"
                },
                {
                    "type": "p",
                    "text": "This API is experimental and is not available in a stable version of React yet."
                },
                {
                    "type": "p",
                    "text": "You can try it by upgrading React packages to the most recent experimental version:"
                },
                {
                    "type": "list",
                    "items": [
                        "react@experimental",
                        "react-dom@experimental",
                        "eslint-plugin-react-hooks@experimental"
                    ]
                },
                {
                    "type": "p",
                    "text": "Experimental versions of React may contain bugs. Don’t use them in production."
                },
                {
                    "type": "p",
                    "text": "useEffectEventis a React Hook that lets you extract non-reactive logic into anEffect Event."
                },
                {
                    "type": "code",
                    "code": "constonSomething=useEffectEvent(callback)"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/forwardRef",
            "title": "forwardRef – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "forwardRef"
                },
                {
                    "type": "p",
                    "text": "forwardReflets your component expose a DOM node to parent component with aref."
                },
                {
                    "type": "code",
                    "code": "constSomeComponent=forwardRef(render)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceforwardRef(render)renderfunction",
                        "forwardRef(render)",
                        "renderfunction",
                        "UsageExposing a DOM node to the parent componentForwarding a ref through multiple componentsExposing an imperative handle instead of a DOM node",
                        "Exposing a DOM node to the parent component",
                        "Forwarding a ref through multiple components",
                        "Exposing an imperative handle instead of a DOM node",
                        "TroubleshootingMy component is wrapped inforwardRef, but therefto it is alwaysnull",
                        "My component is wrapped inforwardRef, but therefto it is alwaysnull"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "forwardRef(render)",
                        "renderfunction"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Exposing a DOM node to the parent component",
                        "Forwarding a ref through multiple components",
                        "Exposing an imperative handle instead of a DOM node"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "My component is wrapped inforwardRef, but therefto it is alwaysnull"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "forwardRef(render)"
                },
                {
                    "type": "p",
                    "text": "CallforwardRef()to let your component receive a ref and forward it to a child component:"
                },
                {
                    "type": "code",
                    "code": "import{forwardRef}from'react';constMyInput=forwardRef(functionMyInput(props,ref){// ...});"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "render: The render function for your component. React calls this function with the props andrefthat your component received from its parent. The JSX you return will be the output of your component."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "forwardRefreturns a React component that you can render in JSX. Unlike React components defined as plain functions, a component returned byforwardRefis also able to receive arefprop."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "In Strict Mode, React willcall your render function twicein order tohelp you find accidental impurities.This is development-only behavior and does not affect production. If your render function is pure (as it should be), this should not affect the logic of your component. The result from one of the calls will be ignored."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "renderfunction"
                },
                {
                    "type": "p",
                    "text": "forwardRefaccepts a render function as an argument. React calls this function withpropsandref:"
                },
                {
                    "type": "code",
                    "code": "constMyInput=forwardRef(functionMyInput(props,ref){return(<label>{props.label}<inputref={ref}/></label>);});"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "props: The props passed by the parent component.",
                        "ref:  Therefattribute passed by the parent component. Therefcan be an object or a function. If the parent component has not passed a ref, it will benull. You should either pass therefyou receive to another component, or pass it touseImperativeHandle."
                    ]
                },
                {
                    "type": "p",
                    "text": "props: The props passed by the parent component."
                },
                {
                    "type": "p",
                    "text": "ref:  Therefattribute passed by the parent component. Therefcan be an object or a function. If the parent component has not passed a ref, it will benull. You should either pass therefyou receive to another component, or pass it touseImperativeHandle."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "forwardRefreturns a React component that you can render in JSX. Unlike React components defined as plain functions, the component returned byforwardRefis able to take arefprop."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Exposing a DOM node to the parent component"
                },
                {
                    "type": "p",
                    "text": "By default, each component’s DOM nodes are private. However, sometimes it’s useful to expose a DOM node to the parent—for example, to allow focusing it. To opt in, wrap your component definition intoforwardRef():"
                },
                {
                    "type": "code",
                    "code": "import{forwardRef}from'react';constMyInput=forwardRef(functionMyInput(props,ref){const{label,...otherProps}=props;return(<label>{label}<input{...otherProps}/></label>);});"
                },
                {
                    "type": "p",
                    "text": "You will receive arefas the second argument after props. Pass it to the DOM node that you want to expose:"
                },
                {
                    "type": "code",
                    "code": "import{forwardRef}from'react';constMyInput=forwardRef(functionMyInput(props,ref){const{label,...otherProps}=props;return(<label>{label}<input{...otherProps}ref={ref}/></label>);});"
                },
                {
                    "type": "p",
                    "text": "This lets the parentFormcomponent access the<input>DOM nodeexposed byMyInput:"
                },
                {
                    "type": "code",
                    "code": "functionForm(){constref=useRef(null);functionhandleClick(){ref.current.focus();}return(<form><MyInputlabel=\"Enter your name:\"ref={ref}/><buttontype=\"button\"onClick={handleClick}>Edit</button></form>);}"
                },
                {
                    "type": "p",
                    "text": "ThisFormcomponentpasses a reftoMyInput. TheMyInputcomponentforwardsthat ref to the<input>browser tag. As a result, theFormcomponent can access that<input>DOM node and callfocus()on it."
                },
                {
                    "type": "p",
                    "text": "Keep in mind that exposing a ref to the DOM node inside your component makes it harder to change your component’s internals later. You will typically expose DOM nodes from reusable low-level components like buttons or text inputs, but you won’t do it for application-level components like an avatar or a comment."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Examples of forwarding a ref"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of2:Focusing a text input"
                },
                {
                    "type": "p",
                    "text": "Clicking the button will focus the input. TheFormcomponent defines a ref and passes it to theMyInputcomponent. TheMyInputcomponent forwards that ref to the browser<input>. This lets theFormcomponent focus the<input>."
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';importMyInputfrom'./MyInput.js';exportdefaultfunctionForm(){constref=useRef(null);functionhandleClick(){ref.current.focus();}return(<form><MyInputlabel=\"Enter your name:\"ref={ref}/><buttontype=\"button\"onClick={handleClick}>Edit</button></form>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Forwarding a ref through multiple components"
                },
                {
                    "type": "p",
                    "text": "Instead of forwarding arefto a DOM node, you can forward it to your own component likeMyInput:"
                },
                {
                    "type": "code",
                    "code": "constFormField=forwardRef(functionFormField(props,ref){// ...return(<><MyInputref={ref}/>...</>);});"
                },
                {
                    "type": "p",
                    "text": "If thatMyInputcomponent forwards a ref to its<input>, a ref toFormFieldwill give you that<input>:"
                },
                {
                    "type": "code",
                    "code": "functionForm(){constref=useRef(null);functionhandleClick(){ref.current.focus();}return(<form><FormFieldlabel=\"Enter your name:\"ref={ref}isRequired={true}/><buttontype=\"button\"onClick={handleClick}>Edit</button></form>);}"
                },
                {
                    "type": "p",
                    "text": "TheFormcomponent defines a ref and passes it toFormField. TheFormFieldcomponent forwards that ref toMyInput, which forwards it to a browser<input>DOM node. This is howFormaccesses that DOM node."
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';importFormFieldfrom'./FormField.js';exportdefaultfunctionForm(){constref=useRef(null);functionhandleClick(){ref.current.focus();}return(<form><FormFieldlabel=\"Enter your name:\"ref={ref}isRequired={true}/><buttontype=\"button\"onClick={handleClick}>Edit</button></form>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Exposing an imperative handle instead of a DOM node"
                },
                {
                    "type": "p",
                    "text": "Instead of exposing an entire DOM node, you can expose a custom object, called animperative handle,with a more constrained set of methods. To do this, you’d need to define a separate ref to hold the DOM node:"
                },
                {
                    "type": "code",
                    "code": "constMyInput=forwardRef(functionMyInput(props,ref){constinputRef=useRef(null);// ...return<input{...props}ref={inputRef}/>;});"
                },
                {
                    "type": "p",
                    "text": "Pass therefyou received touseImperativeHandleand specify the value you want to expose to theref:"
                },
                {
                    "type": "code",
                    "code": "import{forwardRef,useRef,useImperativeHandle}from'react';constMyInput=forwardRef(functionMyInput(props,ref){constinputRef=useRef(null);useImperativeHandle(ref,()=>{return{focus(){inputRef.current.focus();},scrollIntoView(){inputRef.current.scrollIntoView();},};},[]);return<input{...props}ref={inputRef}/>;});"
                },
                {
                    "type": "p",
                    "text": "If some component gets a ref toMyInput, it will only receive your{ focus, scrollIntoView }object instead of the DOM node. This lets you limit the information you expose about your DOM node to the minimum."
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';importMyInputfrom'./MyInput.js';exportdefaultfunctionForm(){constref=useRef(null);functionhandleClick(){ref.current.focus();// This won't work because the DOM node isn't exposed:// ref.current.style.opacity = 0.5;}return(<form><MyInputplaceholder=\"Enter your name\"ref={ref}/><buttontype=\"button\"onClick={handleClick}>Edit</button></form>);}"
                },
                {
                    "type": "p",
                    "text": "Read more about using imperative handles."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Do not overuse refs.You should only use refs forimperativebehaviors that you can’t express as props: for example, scrolling to a node, focusing a node, triggering an animation, selecting text, and so on."
                },
                {
                    "type": "p",
                    "text": "If you can express something as a prop, you should not use a ref.For example, instead of exposing an imperative handle like{ open, close }from aModalcomponent, it is better to takeisOpenas a prop like<Modal isOpen={isOpen} />.Effectscan help you expose imperative behaviors via props."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My component is wrapped inforwardRef, but therefto it is alwaysnull"
                },
                {
                    "type": "p",
                    "text": "This usually means that you forgot to actually use therefthat you received."
                },
                {
                    "type": "p",
                    "text": "For example, this component doesn’t do anything with itsref:"
                },
                {
                    "type": "code",
                    "code": "constMyInput=forwardRef(functionMyInput({label},ref){return(<label>{label}<input/></label>);});"
                },
                {
                    "type": "p",
                    "text": "To fix it, pass therefdown to a DOM node or another component that can accept a ref:"
                },
                {
                    "type": "code",
                    "code": "constMyInput=forwardRef(functionMyInput({label},ref){return(<label>{label}<inputref={ref}/></label>);});"
                },
                {
                    "type": "p",
                    "text": "ThereftoMyInputcould also benullif some of the logic is conditional:"
                },
                {
                    "type": "code",
                    "code": "constMyInput=forwardRef(functionMyInput({label,showInput},ref){return(<label>{label}{showInput&&<inputref={ref}/>}</label>);});"
                },
                {
                    "type": "p",
                    "text": "IfshowInputisfalse, then the ref won’t be forwarded to any node, and a ref toMyInputwill remain empty. This is particularly easy to miss if the condition is hidden inside another component, likePanelin this example:"
                },
                {
                    "type": "code",
                    "code": "constMyInput=forwardRef(functionMyInput({label,showInput},ref){return(<label>{label}<PanelisExpanded={showInput}><inputref={ref}/></Panel></label>);});"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/hooks",
            "title": "Built-in React Hooks – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Built-in React Hooks"
                },
                {
                    "type": "p",
                    "text": "Hookslet you use different React features from your components. You can either use the built-in Hooks or combine them to build your own. This page lists all built-in Hooks in React."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "State Hooks"
                },
                {
                    "type": "p",
                    "text": "Statelets a component“remember” information like user input.For example, a form component can use state to store the input value, while an image gallery component can use state to store the selected image index."
                },
                {
                    "type": "p",
                    "text": "To add state to a component, use one of these Hooks:"
                },
                {
                    "type": "list",
                    "items": [
                        "useStatedeclares a state variable that you can update directly.",
                        "useReducerdeclares a state variable with the update logic inside areducer function."
                    ]
                },
                {
                    "type": "code",
                    "code": "functionImageGallery(){const[index,setIndex]=useState(0);// ..."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Context Hooks"
                },
                {
                    "type": "p",
                    "text": "Contextlets a componentreceive information from distant parents without passing it as props.For example, your app’s top-level component can pass the current UI theme to all components below, no matter how deep."
                },
                {
                    "type": "list",
                    "items": [
                        "useContextreads and subscribes to a context."
                    ]
                },
                {
                    "type": "code",
                    "code": "functionButton(){consttheme=useContext(ThemeContext);// ..."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Ref Hooks"
                },
                {
                    "type": "p",
                    "text": "Refslet a componenthold some information that isn’t used for rendering,like a DOM node or a timeout ID. Unlike with state, updating a ref does not re-render your component. Refs are an “escape hatch” from the React paradigm. They are useful when you need to work with non-React systems, such as the built-in browser APIs."
                },
                {
                    "type": "list",
                    "items": [
                        "useRefdeclares a ref. You can hold any value in it, but most often it’s used to hold a DOM node.",
                        "useImperativeHandlelets you customize the ref exposed by your component. This is rarely used."
                    ]
                },
                {
                    "type": "code",
                    "code": "functionForm(){constinputRef=useRef(null);// ..."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Effect Hooks"
                },
                {
                    "type": "p",
                    "text": "Effectslet a componentconnect to and synchronize with external systems.This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code."
                },
                {
                    "type": "list",
                    "items": [
                        "useEffectconnects a component to an external system."
                    ]
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){useEffect(()=>{constconnection=createConnection(roomId);connection.connect();return()=>connection.disconnect();},[roomId]);// ..."
                },
                {
                    "type": "p",
                    "text": "Effects are an “escape hatch” from the React paradigm. Don’t use Effects to orchestrate the data flow of your application. If you’re not interacting with an external system,you might not need an Effect."
                },
                {
                    "type": "p",
                    "text": "There are two rarely used variations ofuseEffectwith differences in timing:"
                },
                {
                    "type": "list",
                    "items": [
                        "useLayoutEffectfires before the browser repaints the screen. You can measure layout here.",
                        "useInsertionEffectfires before React makes changes to the DOM. Libraries can insert dynamic CSS here."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Performance Hooks"
                },
                {
                    "type": "p",
                    "text": "A common way to optimize re-rendering performance is to skip unnecessary work. For example, you can tell React to reuse a cached calculation or to skip a re-render if the data has not changed since the previous render."
                },
                {
                    "type": "p",
                    "text": "To skip calculations and unnecessary re-rendering, use one of these Hooks:"
                },
                {
                    "type": "list",
                    "items": [
                        "useMemolets you cache the result of an expensive calculation.",
                        "useCallbacklets you cache a function definition before passing it down to an optimized component."
                    ]
                },
                {
                    "type": "code",
                    "code": "functionTodoList({todos,tab,theme}){constvisibleTodos=useMemo(()=>filterTodos(todos,tab),[todos,tab]);// ...}"
                },
                {
                    "type": "p",
                    "text": "Sometimes, you can’t skip re-rendering because the screen actually needs to update. In that case, you can improve performance by separating blocking updates that must be synchronous (like typing into an input) from non-blocking updates which don’t need to block the user interface (like updating a chart)."
                },
                {
                    "type": "p",
                    "text": "To prioritize rendering, use one of these Hooks:"
                },
                {
                    "type": "list",
                    "items": [
                        "useTransitionlets you mark a state transition as non-blocking and allow other updates to interrupt it.",
                        "useDeferredValuelets you defer updating a non-critical part of the UI and let other parts update first."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Other Hooks"
                },
                {
                    "type": "p",
                    "text": "These Hooks are mostly useful to library authors and aren’t commonly used in the application code."
                },
                {
                    "type": "list",
                    "items": [
                        "useDebugValuelets you customize the label React DevTools displays for your custom Hook.",
                        "useIdlets a component associate a unique ID with itself. Typically used with accessibility APIs.",
                        "useSyncExternalStorelets a component subscribe to an external store."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "useActionStateallows you to manage state of actions."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Your own Hooks"
                },
                {
                    "type": "p",
                    "text": "You can alsodefine your own custom Hooksas JavaScript functions."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/isValidElement",
            "title": "isValidElement – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "isValidElement"
                },
                {
                    "type": "p",
                    "text": "isValidElementchecks whether a value is a React element."
                },
                {
                    "type": "code",
                    "code": "constisElement=isValidElement(value)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceisValidElement(value)",
                        "isValidElement(value)",
                        "UsageChecking if something is a React element",
                        "Checking if something is a React element"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "isValidElement(value)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Checking if something is a React element"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "isValidElement(value)"
                },
                {
                    "type": "p",
                    "text": "CallisValidElement(value)to check whethervalueis a React element."
                },
                {
                    "type": "code",
                    "code": "import{isValidElement,createElement}from'react';// ✅ React elementsconsole.log(isValidElement(<p/>));// trueconsole.log(isValidElement(createElement('p')));// true// ❌ Not React elementsconsole.log(isValidElement(25));// falseconsole.log(isValidElement('Hello'));// falseconsole.log(isValidElement({age:42}));// false"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "value: Thevalueyou want to check. It can be any a value of any type."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "isValidElementreturnstrueif thevalueis a React element. Otherwise, it returnsfalse."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "OnlyJSX tagsand objects returned bycreateElementare considered to be React elements.For example, even though a number like42is a valid Reactnode(and can be returned from a component), it is not a valid React element. Arrays and portals created withcreatePortalare alsonotconsidered to be React elements."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Checking if something is a React element"
                },
                {
                    "type": "p",
                    "text": "CallisValidElementto check if some value is aReact element."
                },
                {
                    "type": "p",
                    "text": "React elements are:"
                },
                {
                    "type": "list",
                    "items": [
                        "Values produced by writing aJSX tag",
                        "Values produced by callingcreateElement"
                    ]
                },
                {
                    "type": "p",
                    "text": "For React elements,isValidElementreturnstrue:"
                },
                {
                    "type": "code",
                    "code": "import{isValidElement,createElement}from'react';// ✅ JSX tags are React elementsconsole.log(isValidElement(<p/>));// trueconsole.log(isValidElement(<MyComponent/>));// true// ✅ Values returned by createElement are React elementsconsole.log(isValidElement(createElement('p')));// trueconsole.log(isValidElement(createElement(MyComponent)));// true"
                },
                {
                    "type": "p",
                    "text": "Any other values, such as strings, numbers, or arbitrary objects and arrays, are not React elements."
                },
                {
                    "type": "p",
                    "text": "For them,isValidElementreturnsfalse:"
                },
                {
                    "type": "code",
                    "code": "// ❌ These are *not* React elementsconsole.log(isValidElement(null));// falseconsole.log(isValidElement(25));// falseconsole.log(isValidElement('Hello'));// falseconsole.log(isValidElement({age:42}));// falseconsole.log(isValidElement([<div/>,<div/>]));// falseconsole.log(isValidElement(MyComponent));// false"
                },
                {
                    "type": "p",
                    "text": "It is very uncommon to needisValidElement. It’s mostly useful if you’re calling another API thatonlyaccepts elements (likecloneElementdoes) and you want to avoid an error when your argument is not a React element."
                },
                {
                    "type": "p",
                    "text": "Unless you have some very specific reason to add anisValidElementcheck, you probably don’t need it."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "React elements vs React nodes"
                },
                {
                    "type": "p",
                    "text": "When you write a component, you can return any kind ofReact nodefrom it:"
                },
                {
                    "type": "code",
                    "code": "functionMyComponent(){// ... you can return any React node ...}"
                },
                {
                    "type": "p",
                    "text": "A React node can be:"
                },
                {
                    "type": "list",
                    "items": [
                        "A React element created like<div />orcreateElement('div')",
                        "A portal created withcreatePortal",
                        "A string",
                        "A number",
                        "true,false,null, orundefined(which are not displayed)",
                        "An array of other React nodes"
                    ]
                },
                {
                    "type": "p",
                    "text": "NoteisValidElementchecks whether the argument is aReact element,not whether it’s a React node.For example,42is not a valid React element. However, it is a perfectly valid React node:"
                },
                {
                    "type": "code",
                    "code": "functionMyComponent(){return42;// It's ok to return a number from component}"
                },
                {
                    "type": "p",
                    "text": "This is why you shouldn’t useisValidElementas a way to check whether something can be rendered."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/lazy",
            "title": "lazy – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "lazy"
                },
                {
                    "type": "p",
                    "text": "lazylets you defer loading component’s code until it is rendered for the first time."
                },
                {
                    "type": "code",
                    "code": "constSomeComponent=lazy(load)"
                },
                {
                    "type": "list",
                    "items": [
                        "Referencelazy(load)loadfunction",
                        "lazy(load)",
                        "loadfunction",
                        "UsageLazy-loading components with Suspense",
                        "Lazy-loading components with Suspense",
                        "TroubleshootingMylazycomponent’s state gets reset unexpectedly",
                        "Mylazycomponent’s state gets reset unexpectedly"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "lazy(load)",
                        "loadfunction"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Lazy-loading components with Suspense"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Mylazycomponent’s state gets reset unexpectedly"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "lazy(load)"
                },
                {
                    "type": "p",
                    "text": "Calllazyoutside your components to declare a lazy-loaded React component:"
                },
                {
                    "type": "code",
                    "code": "import{lazy}from'react';constMarkdownPreview=lazy(()=>import('./MarkdownPreview.js'));"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "load: A function that returns aPromiseor anotherthenable(a Promise-like object with athenmethod). React will not callloaduntil the first time you attempt to render the returned component. After React first callsload, it will wait for it to resolve, and then render the resolved value’s.defaultas a React component. Both the returned Promise and the Promise’s resolved value will be cached, so React will not callloadmore than once. If the Promise rejects, React willthrowthe rejection reason for the nearest Error Boundary to handle."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "lazyreturns a React component you can render in your tree. While the code for the lazy component is still loading, attempting to render it willsuspend.Use<Suspense>to display a loading indicator while it’s loading."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "loadfunction"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "p",
                    "text": "loadreceives no parameters."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "You need to return aPromiseor some otherthenable(a Promise-like object with athenmethod). It needs to eventually resolve to an object whose.defaultproperty is a valid React component type, such as a function,memo, or aforwardRefcomponent."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Lazy-loading components with Suspense"
                },
                {
                    "type": "p",
                    "text": "Usually, you import components with the staticimportdeclaration:"
                },
                {
                    "type": "code",
                    "code": "importMarkdownPreviewfrom'./MarkdownPreview.js';"
                },
                {
                    "type": "p",
                    "text": "To defer loading this component’s code until it’s rendered for the first time, replace this import with:"
                },
                {
                    "type": "code",
                    "code": "import{lazy}from'react';constMarkdownPreview=lazy(()=>import('./MarkdownPreview.js'));"
                },
                {
                    "type": "p",
                    "text": "This code relies ondynamicimport(),which might require support from your bundler or framework. Using this pattern requires that the lazy component you’re importing was exported as thedefaultexport."
                },
                {
                    "type": "p",
                    "text": "Now that your component’s code loads on demand, you also need to specify what should be displayed while it is loading. You can do this by wrapping the lazy component or any of its parents into a<Suspense>boundary:"
                },
                {
                    "type": "code",
                    "code": "<Suspensefallback={<Loading/>}><h2>Preview</h2><MarkdownPreview/></Suspense>"
                },
                {
                    "type": "p",
                    "text": "In this example, the code forMarkdownPreviewwon’t be loaded until you attempt to render it. IfMarkdownPreviewhasn’t loaded yet,Loadingwill be shown in its place. Try ticking the checkbox:"
                },
                {
                    "type": "code",
                    "code": "import{useState,Suspense,lazy}from'react';importLoadingfrom'./Loading.js';constMarkdownPreview=lazy(()=>delayForDemo(import('./MarkdownPreview.js')));exportdefaultfunctionMarkdownEditor(){const[showPreview,setShowPreview]=useState(false);const[markdown,setMarkdown]=useState('Hello, **world**!');return(<><textareavalue={markdown}onChange={e=>setMarkdown(e.target.value)}/><label><inputtype=\"checkbox\"checked={showPreview}onChange={e=>setShowPreview(e.target.checked)}/>Show preview</label><hr/>{showPreview&&(<Suspensefallback={<Loading/>}><h2>Preview</h2><MarkdownPreviewmarkdown={markdown}/></Suspense>)}</>);}// Add a fixed delay so you can see the loading statefunctiondelayForDemo(promise){returnnewPromise(resolve=>{setTimeout(resolve,2000);}).then(()=>promise);}"
                },
                {
                    "type": "p",
                    "text": "This demo loads with an artificial delay. The next time you untick and tick the checkbox,Previewwill be cached, so there will be no loading state. To see the loading state again, click “Reset” on the sandbox."
                },
                {
                    "type": "p",
                    "text": "Learn more about managing loading states with Suspense."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Mylazycomponent’s state gets reset unexpectedly"
                },
                {
                    "type": "p",
                    "text": "Do not declarelazycomponentsinsideother components:"
                },
                {
                    "type": "code",
                    "code": "import{lazy}from'react';functionEditor(){// 🔴 Bad: This will cause all state to be reset on re-rendersconstMarkdownPreview=lazy(()=>import('./MarkdownPreview.js'));// ...}"
                },
                {
                    "type": "p",
                    "text": "Instead, always declare them at the top level of your module:"
                },
                {
                    "type": "code",
                    "code": "import{lazy}from'react';// ✅ Good: Declare lazy components outside of your componentsconstMarkdownPreview=lazy(()=>import('./MarkdownPreview.js'));functionEditor(){// ...}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/legacy",
            "title": "Legacy React APIs – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Legacy React APIs"
                },
                {
                    "type": "p",
                    "text": "These APIs are exported from thereactpackage, but they are not recommended for use in newly written code. See the linked individual API pages for the suggested alternatives."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Legacy APIs"
                },
                {
                    "type": "list",
                    "items": [
                        "Childrenlets you manipulate and transform the JSX received as thechildrenprop.See alternatives.",
                        "cloneElementlets you create a React element using another element as a starting point.See alternatives.",
                        "Componentlets you define a React component as a JavaScript class.See alternatives.",
                        "createElementlets you create a React element. Typically, you’ll use JSX instead.",
                        "createRefcreates a ref object which can contain arbitrary value.See alternatives.",
                        "isValidElementchecks whether a value is a React element. Typically used withcloneElement.",
                        "PureComponentis similar toComponent,but it skip re-renders with same props.See alternatives."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Deprecated APIs"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Deprecated"
                },
                {
                    "type": "p",
                    "text": "These APIs will be removed in a future major version of React."
                },
                {
                    "type": "list",
                    "items": [
                        "createFactorylets you create a function that produces React elements of a certain type."
                    ]
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/memo",
            "title": "memo – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "memo"
                },
                {
                    "type": "p",
                    "text": "memolets you skip re-rendering a component when its props are unchanged."
                },
                {
                    "type": "code",
                    "code": "constMemoizedComponent=memo(SomeComponent,arePropsEqual?)"
                },
                {
                    "type": "list",
                    "items": [
                        "Referencememo(Component, arePropsEqual?)",
                        "memo(Component, arePropsEqual?)",
                        "UsageSkipping re-rendering when props are unchangedUpdating a memoized component using stateUpdating a memoized component using a contextMinimizing props changesSpecifying a custom comparison function",
                        "Skipping re-rendering when props are unchanged",
                        "Updating a memoized component using state",
                        "Updating a memoized component using a context",
                        "Minimizing props changes",
                        "Specifying a custom comparison function",
                        "TroubleshootingMy component re-renders when a prop is an object, array, or function",
                        "My component re-renders when a prop is an object, array, or function"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "memo(Component, arePropsEqual?)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Skipping re-rendering when props are unchanged",
                        "Updating a memoized component using state",
                        "Updating a memoized component using a context",
                        "Minimizing props changes",
                        "Specifying a custom comparison function"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "My component re-renders when a prop is an object, array, or function"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "memo(Component, arePropsEqual?)"
                },
                {
                    "type": "p",
                    "text": "Wrap a component inmemoto get amemoizedversion of that component. This memoized version of your component will usually not be re-rendered when its parent component is re-rendered as long as its props have not changed. But React may still re-render it: memoization is a performance optimization, not a guarantee."
                },
                {
                    "type": "code",
                    "code": "import{memo}from'react';constSomeComponent=memo(functionSomeComponent(props){// ...});"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "Component: The component that you want to memoize. Thememodoes not modify this component, but returns a new, memoized component instead. Any valid React component, including functions andforwardRefcomponents, is accepted.",
                        "optionalarePropsEqual: A function that accepts two arguments: the component’s previous props, and its new props. It should returntrueif the old and new props are equal: that is, if the component will render the same output and behave in the same way with the new props as with the old. Otherwise it should returnfalse. Usually, you will not specify this function. By default, React will compare each prop withObject.is."
                    ]
                },
                {
                    "type": "p",
                    "text": "Component: The component that you want to memoize. Thememodoes not modify this component, but returns a new, memoized component instead. Any valid React component, including functions andforwardRefcomponents, is accepted."
                },
                {
                    "type": "p",
                    "text": "optionalarePropsEqual: A function that accepts two arguments: the component’s previous props, and its new props. It should returntrueif the old and new props are equal: that is, if the component will render the same output and behave in the same way with the new props as with the old. Otherwise it should returnfalse. Usually, you will not specify this function. By default, React will compare each prop withObject.is."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "memoreturns a new React component. It behaves the same as the component provided tomemoexcept that React will not always re-render it when its parent is being re-rendered unless its props have changed."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Skipping re-rendering when props are unchanged"
                },
                {
                    "type": "p",
                    "text": "React normally re-renders a component whenever its parent re-renders. Withmemo, you can create a component that React will not re-render when its parent re-renders so long as its new props are the same as the old props. Such a component is said to bememoized."
                },
                {
                    "type": "p",
                    "text": "To memoize a component, wrap it inmemoand use the value that it returns in place of your original component:"
                },
                {
                    "type": "code",
                    "code": "constGreeting=memo(functionGreeting({name}){return<h1>Hello,{name}!</h1>;});exportdefaultGreeting;"
                },
                {
                    "type": "p",
                    "text": "A React component should always havepure rendering logic.This means that it must return the same output if its props, state, and context haven’t changed. By usingmemo, you are telling React that your component complies with this requirement, so React doesn’t need to re-render as long as its props haven’t changed. Even withmemo, your component will re-render if its own state changes or if a context that it’s using changes."
                },
                {
                    "type": "p",
                    "text": "In this example, notice that theGreetingcomponent re-renders whenevernameis changed (because that’s one of its props), but not whenaddressis changed (because it’s not passed toGreetingas a prop):"
                },
                {
                    "type": "code",
                    "code": "import{memo,useState}from'react';exportdefaultfunctionMyApp(){const[name,setName]=useState('');const[address,setAddress]=useState('');return(<><label>Name{': '}<inputvalue={name}onChange={e=>setName(e.target.value)}/></label><label>Address{': '}<inputvalue={address}onChange={e=>setAddress(e.target.value)}/></label><Greetingname={name}/></>);}constGreeting=memo(functionGreeting({name}){console.log(\"Greeting was rendered at\",newDate().toLocaleTimeString());return<h3>Hello{name&&', '}{name}!</h3>;});"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "You should only rely onmemoas a performance optimization.If your code doesn’t work without it, find the underlying problem and fix it first. Then you may addmemoto improve performance."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Should you add memo everywhere?"
                },
                {
                    "type": "p",
                    "text": "If your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful."
                },
                {
                    "type": "p",
                    "text": "Optimizing withmemois only valuable when your component re-renders often with the same exact props, and its re-rendering logic is expensive. If there is no perceptible lag when your component re-renders,memois unnecessary. Keep in mind thatmemois completely useless if the props passed to your component arealways different,such as if you pass an object or a plain function defined during rendering. This is why you will often needuseMemoanduseCallbacktogether withmemo."
                },
                {
                    "type": "p",
                    "text": "There is no benefit to wrapping a component inmemoin other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value that’s “always new” is enough to break memoization for an entire component."
                },
                {
                    "type": "p",
                    "text": "In practice, you can make a lot of memoization unnecessary by following a few principles:"
                },
                {
                    "type": "list",
                    "items": [
                        "When a component visually wraps other components, let itaccept JSX as children.This way, when the wrapper component updates its own state, React knows that its children don’t need to re-render.",
                        "Prefer local state and don’tlift state upany further than necessary. For example, don’t keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.",
                        "Keep yourrendering logic pure.If re-rendering a component causes a problem or produces some noticeable visual artifact, it’s a bug in your component! Fix the bug instead of adding memoization.",
                        "Avoidunnecessary Effects that update state.Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.",
                        "Try toremove unnecessary dependencies from your Effects.For example, instead of memoization, it’s often simpler to move some object or a function inside an Effect or outside the component."
                    ]
                },
                {
                    "type": "p",
                    "text": "If a specific interaction still feels laggy,use the React Developer Tools profilerto see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it’s good to follow them in any case. In the long term, we’re researchingdoing granular memoization automaticallyto solve this once and for all."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Updating a memoized component using state"
                },
                {
                    "type": "p",
                    "text": "Even when a component is memoized, it will still re-render when its own state changes. Memoization only has to do with props that are passed to the component from its parent."
                },
                {
                    "type": "code",
                    "code": "import{memo,useState}from'react';exportdefaultfunctionMyApp(){const[name,setName]=useState('');const[address,setAddress]=useState('');return(<><label>Name{': '}<inputvalue={name}onChange={e=>setName(e.target.value)}/></label><label>Address{': '}<inputvalue={address}onChange={e=>setAddress(e.target.value)}/></label><Greetingname={name}/></>);}constGreeting=memo(functionGreeting({name}){console.log('Greeting was rendered at',newDate().toLocaleTimeString());const[greeting,setGreeting]=useState('Hello');return(<><h3>{greeting}{name&&', '}{name}!</h3><GreetingSelectorvalue={greeting}onChange={setGreeting}/></>);});functionGreetingSelector({value,onChange}){return(<><label><inputtype=\"radio\"checked={value==='Hello'}onChange={e=>onChange('Hello')}/>Regular greeting</label><label><inputtype=\"radio\"checked={value==='Hello and welcome'}onChange={e=>onChange('Hello and welcome')}/>Enthusiastic greeting</label></>);}"
                },
                {
                    "type": "p",
                    "text": "If you set a state variable to its current value, React will skip re-rendering your component even withoutmemo. You may still see your component function being called an extra time, but the result will be discarded."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Updating a memoized component using a context"
                },
                {
                    "type": "p",
                    "text": "Even when a component is memoized, it will still re-render when a context that it’s using changes. Memoization only has to do with props that are passed to the component from its parent."
                },
                {
                    "type": "code",
                    "code": "import{createContext,memo,useContext,useState}from'react';constThemeContext=createContext(null);exportdefaultfunctionMyApp(){const[theme,setTheme]=useState('dark');functionhandleClick(){setTheme(theme==='dark'?'light':'dark');}return(<ThemeContext.Providervalue={theme}><buttononClick={handleClick}>Switch theme</button><Greetingname=\"Taylor\"/></ThemeContext.Provider>);}constGreeting=memo(functionGreeting({name}){console.log(\"Greeting was rendered at\",newDate().toLocaleTimeString());consttheme=useContext(ThemeContext);return(<h3className={theme}>Hello,{name}!</h3>);});"
                },
                {
                    "type": "p",
                    "text": "To make your component re-render only when apartof some context changes, split your component in two. Read what you need from the context in the outer component, and pass it down to a memoized child as a prop."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Minimizing props changes"
                },
                {
                    "type": "p",
                    "text": "When you usememo, your component re-renders whenever any prop is notshallowly equalto what it was previously. This means that React compares every prop in your component with its previous value using theObject.iscomparison. Note thatObject.is(3, 3)istrue, butObject.is({}, {})isfalse."
                },
                {
                    "type": "p",
                    "text": "To get the most out ofmemo, minimize the times that the props change. For example, if the prop is an object, prevent the parent component from re-creating that object every time by usinguseMemo:"
                },
                {
                    "type": "code",
                    "code": "functionPage(){const[name,setName]=useState('Taylor');const[age,setAge]=useState(42);constperson=useMemo(()=>({name,age}),[name,age]);return<Profileperson={person}/>;}constProfile=memo(functionProfile({person}){// ...});"
                },
                {
                    "type": "p",
                    "text": "A better way to minimize props changes is to make sure the component accepts the minimum necessary information in its props. For example, it could accept individual values instead of a whole object:"
                },
                {
                    "type": "code",
                    "code": "functionPage(){const[name,setName]=useState('Taylor');const[age,setAge]=useState(42);return<Profilename={name}age={age}/>;}constProfile=memo(functionProfile({name,age}){// ...});"
                },
                {
                    "type": "p",
                    "text": "Even individual values can sometimes be projected to ones that change less frequently. For example, here a component accepts a boolean indicating the presence of a value rather than the value itself:"
                },
                {
                    "type": "code",
                    "code": "functionGroupsLanding({person}){consthasGroups=person.groups!==null;return<CallToActionhasGroups={hasGroups}/>;}constCallToAction=memo(functionCallToAction({hasGroups}){// ...});"
                },
                {
                    "type": "p",
                    "text": "When you need to pass a function to memoized component, either declare it outside your component so that it never changes, oruseCallbackto cache its definition between re-renders."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Specifying a custom comparison function"
                },
                {
                    "type": "p",
                    "text": "In rare cases it may be infeasible to minimize the props changes of a memoized component. In that case, you can provide a custom comparison function, which React will use to compare the old and new props instead of using shallow equality. This function is passed as a second argument tomemo. It should returntrueonly if the new props would result in the same output as the old props; otherwise it should returnfalse."
                },
                {
                    "type": "code",
                    "code": "constChart=memo(functionChart({dataPoints}){// ...},arePropsEqual);functionarePropsEqual(oldProps,newProps){return(oldProps.dataPoints.length===newProps.dataPoints.length&&oldProps.dataPoints.every((oldPoint,index)=>{constnewPoint=newProps.dataPoints[index];returnoldPoint.x===newPoint.x&&oldPoint.y===newPoint.y;}));}"
                },
                {
                    "type": "p",
                    "text": "If you do this, use the Performance panel in your browser developer tools to make sure that your comparison function is actually faster than re-rendering the component. You might be surprised."
                },
                {
                    "type": "p",
                    "text": "When you do performance measurements, make sure that React is running in the production mode."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "If you provide a customarePropsEqualimplementation,you must compare every prop, including functions.Functions oftenclose overthe props and state of parent components. If you returntruewhenoldProps.onClick !== newProps.onClick, your component will keep “seeing” the props and state from a previous render inside itsonClickhandler, leading to very confusing bugs."
                },
                {
                    "type": "p",
                    "text": "Avoid doing deep equality checks insidearePropsEqualunless you are 100% sure that the data structure you’re working with has a known limited depth.Deep equality checks can become incredibly slowand can freeze your app for many seconds if someone changes the data structure later."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My component re-renders when a prop is an object, array, or function"
                },
                {
                    "type": "p",
                    "text": "React compares old and new props by shallow equality: that is, it considers whether each new prop is reference-equal to the old prop. If you create a new object or array each time the parent is re-rendered, even if the individual elements are each the same, React will still consider it to be changed. Similarly, if you create a new function when rendering the parent component, React will consider it to have changed even if the function has the same definition. To avoid this,simplify props or memoize props in the parent component."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/startTransition",
            "title": "startTransition – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "startTransition"
                },
                {
                    "type": "p",
                    "text": "startTransitionlets you update the state without blocking the UI."
                },
                {
                    "type": "code",
                    "code": "startTransition(scope)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferencestartTransition(scope)",
                        "startTransition(scope)",
                        "UsageMarking a state update as a non-blocking Transition",
                        "Marking a state update as a non-blocking Transition"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "startTransition(scope)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Marking a state update as a non-blocking Transition"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "startTransition(scope)"
                },
                {
                    "type": "p",
                    "text": "ThestartTransitionfunction lets you mark a state update as a Transition."
                },
                {
                    "type": "code",
                    "code": "import{startTransition}from'react';functionTabContainer(){const[tab,setTab]=useState('about');functionselectTab(nextTab){startTransition(()=>{setTab(nextTab);});}// ...}"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "scope: A function that updates some state by calling one or moresetfunctions.React immediately callsscopewith no arguments and marks all state updates scheduled synchronously during thescopefunction call as Transitions. They will benon-blockingandwill not display unwanted loading indicators."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "startTransitiondoes not return anything."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "startTransitiondoes not provide a way to track whether a Transition is pending. To show a pending indicator while the Transition is ongoing, you needuseTransitioninstead.",
                        "You can wrap an update into a Transition only if you have access to thesetfunction of that state. If you want to start a Transition in response to some prop or a custom Hook return value, tryuseDeferredValueinstead.",
                        "The function you pass tostartTransitionmust be synchronous. React immediately executes this function, marking all state updates that happen while it executes as Transitions. If you try to perform more state updates later (for example, in a timeout), they won’t be marked as Transitions.",
                        "A state update marked as a Transition will be interrupted by other state updates. For example, if you update a chart component inside a Transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input state update.",
                        "Transition updates can’t be used to control text inputs.",
                        "If there are multiple ongoing Transitions, React currently batches them together. This is a limitation that will likely be removed in a future release."
                    ]
                },
                {
                    "type": "p",
                    "text": "startTransitiondoes not provide a way to track whether a Transition is pending. To show a pending indicator while the Transition is ongoing, you needuseTransitioninstead."
                },
                {
                    "type": "p",
                    "text": "You can wrap an update into a Transition only if you have access to thesetfunction of that state. If you want to start a Transition in response to some prop or a custom Hook return value, tryuseDeferredValueinstead."
                },
                {
                    "type": "p",
                    "text": "The function you pass tostartTransitionmust be synchronous. React immediately executes this function, marking all state updates that happen while it executes as Transitions. If you try to perform more state updates later (for example, in a timeout), they won’t be marked as Transitions."
                },
                {
                    "type": "p",
                    "text": "A state update marked as a Transition will be interrupted by other state updates. For example, if you update a chart component inside a Transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input state update."
                },
                {
                    "type": "p",
                    "text": "Transition updates can’t be used to control text inputs."
                },
                {
                    "type": "p",
                    "text": "If there are multiple ongoing Transitions, React currently batches them together. This is a limitation that will likely be removed in a future release."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Marking a state update as a non-blocking Transition"
                },
                {
                    "type": "p",
                    "text": "You can mark a state update as aTransitionby wrapping it in astartTransitioncall:"
                },
                {
                    "type": "code",
                    "code": "import{startTransition}from'react';functionTabContainer(){const[tab,setTab]=useState('about');functionselectTab(nextTab){startTransition(()=>{setTab(nextTab);});}// ...}"
                },
                {
                    "type": "p",
                    "text": "Transitions let you keep the user interface updates responsive even on slow devices."
                },
                {
                    "type": "p",
                    "text": "With a Transition, your UI stays responsive in the middle of a re-render. For example, if the user clicks a tab but then change their mind and click another tab, they can do that without waiting for the first re-render to finish."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "startTransitionis very similar touseTransition, except that it does not provide theisPendingflag to track whether a Transition is ongoing. You can callstartTransitionwhenuseTransitionis not available. For example,startTransitionworks outside components, such as from a data library."
                },
                {
                    "type": "p",
                    "text": "Learn about Transitions and see examples on theuseTransitionpage."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/use",
            "title": "use – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "use- This feature is available in the latest Canary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "TheuseAPI is currently only available in React’s Canary and experimental channels. Learn more aboutReact’s release channels here."
                },
                {
                    "type": "p",
                    "text": "useis a React API that lets you read the value of a resource like aPromiseorcontext."
                },
                {
                    "type": "code",
                    "code": "constvalue=use(resource);"
                },
                {
                    "type": "list",
                    "items": [
                        "Referenceuse(resource)",
                        "use(resource)",
                        "UsageReading context withuseStreaming data from the server to the clientDealing with rejected Promises",
                        "Reading context withuse",
                        "Streaming data from the server to the client",
                        "Dealing with rejected Promises",
                        "Troubleshooting“Suspense Exception: This is not a real error!”",
                        "“Suspense Exception: This is not a real error!”"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "use(resource)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Reading context withuse",
                        "Streaming data from the server to the client",
                        "Dealing with rejected Promises"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "“Suspense Exception: This is not a real error!”"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "use(resource)"
                },
                {
                    "type": "p",
                    "text": "Callusein your component to read the value of a resource like aPromiseorcontext."
                },
                {
                    "type": "code",
                    "code": "import{use}from'react';functionMessageComponent({messagePromise}){constmessage=use(messagePromise);consttheme=use(ThemeContext);// ..."
                },
                {
                    "type": "p",
                    "text": "Unlike React Hooks,usecan be called within loops and conditional statements likeif. Like React Hooks, the function that callsusemust be a Component or Hook."
                },
                {
                    "type": "p",
                    "text": "When called with a Promise, theuseAPI integrates withSuspenseanderror boundaries. The component callingusesuspendswhile the Promise passed touseis pending. If the component that callsuseis wrapped in a Suspense boundary, the fallback will be displayed.  Once the Promise is resolved, the Suspense fallback is replaced by the rendered components using the data returned by theuseAPI. If the Promise passed touseis rejected, the fallback of the nearest Error Boundary will be displayed."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "resource: this is the source of the data you want to read a value from. A resource can be aPromiseor acontext."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "TheuseAPI returns the value that was read from the resource like the resolved value of aPromiseorcontext."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "TheuseAPI must be called inside a Component or a Hook.",
                        "When fetching data in aServer Component, preferasyncandawaitoveruse.asyncandawaitpick up rendering from the point whereawaitwas invoked, whereasusere-renders the component after the data is resolved.",
                        "Prefer creating Promises inServer Componentsand passing them toClient Componentsover creating Promises in Client Components. Promises created in Client Components are recreated on every render. Promises passed from a Server Component to a Client Component are stable across re-renders.See this example."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Reading context withuse"
                },
                {
                    "type": "p",
                    "text": "When acontextis passed touse, it works similarly touseContext. WhileuseContextmust be called at the top level of your component,usecan be called inside conditionals likeifand loops likefor.useis preferred overuseContextbecause it is more flexible."
                },
                {
                    "type": "code",
                    "code": "import{use}from'react';functionButton(){consttheme=use(ThemeContext);// ..."
                },
                {
                    "type": "p",
                    "text": "usereturns thecontext valuefor thecontextyou passed. To determine the context value, React searches the component tree and findsthe closest context provider abovefor that particular context."
                },
                {
                    "type": "p",
                    "text": "To pass context to aButton, wrap it or one of its parent components into the corresponding context provider."
                },
                {
                    "type": "code",
                    "code": "functionMyPage(){return(<ThemeContext.Providervalue=\"dark\"><Form/></ThemeContext.Provider>);}functionForm(){// ... renders buttons inside ...}"
                },
                {
                    "type": "p",
                    "text": "It doesn’t matter how many layers of components there are between the provider and theButton. When aButtonanywhereinside ofFormcallsuse(ThemeContext), it will receive\"dark\"as the value."
                },
                {
                    "type": "p",
                    "text": "UnlikeuseContext,usecan be called in conditionals and loops likeif."
                },
                {
                    "type": "code",
                    "code": "functionHorizontalRule({show}){if(show){consttheme=use(ThemeContext);return<hrclassName={theme}/>;}returnfalse;}"
                },
                {
                    "type": "p",
                    "text": "useis called from inside aifstatement, allowing you to conditionally read values from a Context."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "LikeuseContext,use(context)always looks for the closest context providerabovethe component that calls it. It searches upwards anddoes notconsider context providers in the component from which you’re callinguse(context)."
                },
                {
                    "type": "code",
                    "code": "import{createContext,use}from'react';constThemeContext=createContext(null);exportdefaultfunctionMyApp(){return(<ThemeContext.Providervalue=\"dark\"><Form/></ThemeContext.Provider>)}functionForm(){return(<Paneltitle=\"Welcome\"><Buttonshow={true}>Sign up</Button><Buttonshow={false}>Log in</Button></Panel>);}functionPanel({title,children}){consttheme=use(ThemeContext);constclassName='panel-'+theme;return(<sectionclassName={className}><h1>{title}</h1>{children}</section>)}functionButton({show,children}){if(show){consttheme=use(ThemeContext);constclassName='button-'+theme;return(<buttonclassName={className}>{children}</button>);}returnfalse}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Streaming data from the server to the client"
                },
                {
                    "type": "p",
                    "text": "Data can be streamed from the server to the client by passing a Promise as a prop from aServer Componentto aClient Component."
                },
                {
                    "type": "code",
                    "code": "import{fetchMessage}from'./lib.js';import{Message}from'./message.js';exportdefaultfunctionApp(){constmessagePromise=fetchMessage();return(<Suspensefallback={<p>waiting for message...</p>}><MessagemessagePromise={messagePromise}/></Suspense>);}"
                },
                {
                    "type": "p",
                    "text": "TheClient Componentthen takesthe Promise it received as a propand passes it to theuseAPI. This allows theClient Componentto read the value fromthe Promisethat was initially created by the Server Component."
                },
                {
                    "type": "code",
                    "code": "// message.js'use client';import{use}from'react';exportfunctionMessage({messagePromise}){constmessageContent=use(messagePromise);return<p>Here is the message:{messageContent}</p>;}"
                },
                {
                    "type": "p",
                    "text": "BecauseMessageis wrapped inSuspense, the fallback will be displayed until the Promise is resolved. When the Promise is resolved, the value will be read by theuseAPI and theMessagecomponent will replace the Suspense fallback."
                },
                {
                    "type": "code",
                    "code": "\"use client\";import{use,Suspense}from\"react\";functionMessage({messagePromise}){constmessageContent=use(messagePromise);return<p>Here is the message:{messageContent}</p>;}exportfunctionMessageContainer({messagePromise}){return(<Suspensefallback={<p>⌛Downloading message...</p>}><MessagemessagePromise={messagePromise}/></Suspense>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "When passing a Promise from a Server Component to a Client Component, its resolved value must be serializable to pass between server and client. Data types like functions aren’t serializable and cannot be the resolved value of such a Promise."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Should I resolve a Promise in a Server or Client Component?"
                },
                {
                    "type": "p",
                    "text": "A Promise can be passed from a Server Component to a Client Component and resolved in the Client Component with theuseAPI. You can also resolve the Promise in a Server Component withawaitand pass the required data to the Client Component as a prop."
                },
                {
                    "type": "code",
                    "code": "exportdefaultasyncfunctionApp(){constmessageContent=awaitfetchMessage();return<MessagemessageContent={messageContent}/>}"
                },
                {
                    "type": "p",
                    "text": "But usingawaitin aServer Componentwill block its rendering until theawaitstatement is finished. Passing a Promise from a Server Component to a Client Component prevents the Promise from blocking the rendering of the Server Component."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Dealing with rejected Promises"
                },
                {
                    "type": "p",
                    "text": "In some cases a Promise passed tousecould be rejected. You can handle rejected Promises by either:"
                },
                {
                    "type": "list",
                    "items": [
                        "Displaying an error to users with an error boundary.",
                        "Providing an alternative value withPromise.catch"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "usecannot be called in a try-catch block. Instead of a try-catch blockwrap your component in an Error Boundary, orprovide an alternative value to use with the Promise’s.catchmethod."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Displaying an error to users with an error boundary"
                },
                {
                    "type": "p",
                    "text": "If you’d like to display an error to your users when a Promise is rejected, you can use anerror boundary. To use an error boundary, wrap the component where you are calling theuseAPI in an error boundary. If the Promise passed touseis rejected the fallback for the error boundary will be displayed."
                },
                {
                    "type": "code",
                    "code": "\"use client\";import{use,Suspense}from\"react\";import{ErrorBoundary}from\"react-error-boundary\";exportfunctionMessageContainer({messagePromise}){return(<ErrorBoundaryfallback={<p>⚠️Something went wrong</p>}><Suspensefallback={<p>⌛Downloading message...</p>}><MessagemessagePromise={messagePromise}/></Suspense></ErrorBoundary>);}functionMessage({messagePromise}){constcontent=use(messagePromise);return<p>Here is the message:{content}</p>;}"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Providing an alternative value withPromise.catch"
                },
                {
                    "type": "p",
                    "text": "If you’d like to provide an alternative value when the Promise passed touseis rejected you can use the Promise’scatchmethod."
                },
                {
                    "type": "code",
                    "code": "import{Message}from'./message.js';exportdefaultfunctionApp(){constmessagePromise=newPromise((resolve,reject)=>{reject();}).catch(()=>{return\"no new message found.\";});return(<Suspensefallback={<p>waiting for message...</p>}><MessagemessagePromise={messagePromise}/></Suspense>);}"
                },
                {
                    "type": "p",
                    "text": "To use the Promise’scatchmethod, callcatchon the Promise object.catchtakes a single argument: a function that takes an error message as an argument. Whatever isreturnedby the function passed tocatchwill be used as the resolved value of the Promise."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "“Suspense Exception: This is not a real error!”"
                },
                {
                    "type": "p",
                    "text": "You are either callinguseoutside of a React Component or Hook function, or callingusein a try–catch block. If you are callinguseinside a try–catch block, wrap your component in an error boundary, or call the Promise’scatchto catch the error and resolve the Promise with another value.See these examples."
                },
                {
                    "type": "p",
                    "text": "If you are callinguseoutside a React Component or Hook function, move theusecall to a React Component or Hook function."
                },
                {
                    "type": "code",
                    "code": "functionMessageComponent({messagePromise}){functiondownload(){// ❌ the function calling `use` is not a Component or Hookconstmessage=use(messagePromise);// ..."
                },
                {
                    "type": "p",
                    "text": "Instead, calluseoutside any component closures, where the function that callsuseis a Component or Hook."
                },
                {
                    "type": "code",
                    "code": "functionMessageComponent({messagePromise}){// ✅ `use` is being called from a component.constmessage=use(messagePromise);// ..."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/useActionState",
            "title": "useActionState – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "useActionState- This feature is available in the latest Canary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "TheuseActionStateHook is currently only available in React’s Canary and experimental channels. Learn more aboutrelease channels here. In addition, you need to use a framework that supportsReact Server Componentsto get the full benefit ofuseActionState."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "In earlier React Canary versions, this API was part of React DOM and calleduseFormState."
                },
                {
                    "type": "p",
                    "text": "useActionStateis a Hook that allows you to update state based on the result of a form action."
                },
                {
                    "type": "code",
                    "code": "const[state,formAction,isPending]=useActionState(fn,initialState,permalink?);"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceuseActionState(action, initialState, permalink?)",
                        "useActionState(action, initialState, permalink?)",
                        "UsageUsing information returned by a form action",
                        "Using information returned by a form action",
                        "TroubleshootingMy action can no longer read the submitted form data",
                        "My action can no longer read the submitted form data"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "useActionState(action, initialState, permalink?)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Using information returned by a form action"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "My action can no longer read the submitted form data"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useActionState(action, initialState, permalink?)"
                },
                {
                    "type": "p",
                    "text": "CalluseActionStateat the top level of your component to create component state that is updatedwhen a form action is invoked. You passuseActionStatean existing form action function as well as an initial state, and it returns a new action that you use in your form, along with the latest form state and whether the Action is still pending. The latest form state is also passed to the function that you provided."
                },
                {
                    "type": "code",
                    "code": "import{useActionState}from\"react\";asyncfunctionincrement(previousState,formData){returnpreviousState+1;}functionStatefulForm({}){const[state,formAction]=useActionState(increment,0);return(<form>{state}<buttonformAction={formAction}>Increment</button></form>)}"
                },
                {
                    "type": "p",
                    "text": "The form state is the value returned by the action when the form was last submitted. If the form has not yet been submitted, it is the initial state that you pass."
                },
                {
                    "type": "p",
                    "text": "If used with a Server Action,useActionStateallows the server’s response from submitting the form to be shown even before hydration has completed."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "fn: The function to be called when the form is submitted or button pressed. When the function is called, it will receive the previous state of the form (initially theinitialStatethat you pass, subsequently its previous return value) as its initial argument, followed by the arguments that a form action normally receives.",
                        "initialState: The value you want the state to be initially. It can be any serializable value. This argument is ignored after the action is first invoked.",
                        "optionalpermalink: A string containing the unique page URL that this form modifies. For use on pages with dynamic content (eg: feeds) in conjunction with progressive enhancement: iffnis aserver actionand the form is submitted before the JavaScript bundle loads, the browser will navigate to the specified permalink URL, rather than the current page’s URL. Ensure that the same form component is rendered on the destination page (including the same actionfnandpermalink) so that React knows how to pass the state through. Once the form has been hydrated, this parameter has no effect."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "useActionStatereturns an array with the following values:"
                },
                {
                    "type": "list",
                    "items": [
                        "The current state. During the first render, it will match theinitialStateyou have passed. After the action is invoked, it will match the value returned by the action.",
                        "A new action that you can pass as theactionprop to yourformcomponent orformActionprop to anybuttoncomponent within the form.",
                        "TheisPendingflag that tells you whether there is a pending Transition."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "When used with a framework that supports React Server Components,useActionStatelets you make forms interactive before JavaScript has executed on the client. When used without Server Components, it is equivalent to component local state.",
                        "The function passed touseActionStatereceives an extra argument, the previous or initial state, as its first argument. This makes its signature different than if it were used directly as a form action without usinguseActionState."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Using information returned by a form action"
                },
                {
                    "type": "p",
                    "text": "CalluseActionStateat the top level of your component to access the return value of an action from the last time a form was submitted."
                },
                {
                    "type": "code",
                    "code": "import{useActionState}from'react';import{action}from'./actions.js';functionMyComponent(){const[state,formAction]=useActionState(action,null);// ...return(<formaction={formAction}>{/* ... */}</form>);}"
                },
                {
                    "type": "p",
                    "text": "useActionStatereturns an array with the following items:"
                },
                {
                    "type": "list",
                    "items": [
                        "Thecurrent stateof the form, which is initially set to theinitial stateyou provided, and after the form is submitted is set to the return value of theactionyou provided.",
                        "Anew actionthat you pass to<form>as itsactionprop.",
                        "Apending statethat you can utilise whilst your action is processing."
                    ]
                },
                {
                    "type": "p",
                    "text": "When the form is submitted, theactionfunction that you provided will be called. Its return value will become the newcurrent stateof the form."
                },
                {
                    "type": "p",
                    "text": "Theactionthat you provide will also receive a new first argument, namely thecurrent stateof the form. The first time the form is submitted, this will be theinitial stateyou provided, while with subsequent submissions, it will be the return value from the last time the action was called. The rest of the arguments are the same as ifuseActionStatehad not been used."
                },
                {
                    "type": "code",
                    "code": "functionaction(currentState,formData){// ...return'next state';}"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Display information after submitting a form"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of2:Display form errors"
                },
                {
                    "type": "p",
                    "text": "To display messages such as an error message or toast that’s returned by a Server Action, wrap the action in a call touseActionState."
                },
                {
                    "type": "code",
                    "code": "import{useActionState,useState}from\"react\";import{addToCart}from\"./actions.js\";functionAddToCartForm({itemID,itemTitle}){const[message,formAction,isPending]=useActionState(addToCart,null);return(<formaction={formAction}><h2>{itemTitle}</h2><inputtype=\"hidden\"name=\"itemID\"value={itemID}/><buttontype=\"submit\">Add to Cart</button>{isPending?\"Loading...\":message}</form>);}exportdefaultfunctionApp(){return(<><AddToCartFormitemID=\"1\"itemTitle=\"JavaScript: The Definitive Guide\"/><AddToCartFormitemID=\"2\"itemTitle=\"JavaScript: The Good Parts\"/></>)}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My action can no longer read the submitted form data"
                },
                {
                    "type": "p",
                    "text": "When you wrap an action withuseActionState, it gets an extra argumentas its first argument. The submitted form data is therefore itssecondargument instead of its first as it would usually be. The new first argument that gets added is the current state of the form."
                },
                {
                    "type": "code",
                    "code": "functionaction(currentState,formData){// ...}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/useCallback",
            "title": "useCallback – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "useCallback"
                },
                {
                    "type": "p",
                    "text": "useCallbackis a React Hook that lets you cache a function definition between re-renders."
                },
                {
                    "type": "code",
                    "code": "constcachedFn=useCallback(fn,dependencies)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceuseCallback(fn, dependencies)",
                        "useCallback(fn, dependencies)",
                        "UsageSkipping re-rendering of componentsUpdating state from a memoized callbackPreventing an Effect from firing too oftenOptimizing a custom Hook",
                        "Skipping re-rendering of components",
                        "Updating state from a memoized callback",
                        "Preventing an Effect from firing too often",
                        "Optimizing a custom Hook",
                        "TroubleshootingEvery time my component renders,useCallbackreturns a different functionI need to calluseCallbackfor each list item in a loop, but it’s not allowed",
                        "Every time my component renders,useCallbackreturns a different function",
                        "I need to calluseCallbackfor each list item in a loop, but it’s not allowed"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "useCallback(fn, dependencies)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Skipping re-rendering of components",
                        "Updating state from a memoized callback",
                        "Preventing an Effect from firing too often",
                        "Optimizing a custom Hook"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Every time my component renders,useCallbackreturns a different function",
                        "I need to calluseCallbackfor each list item in a loop, but it’s not allowed"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useCallback(fn, dependencies)"
                },
                {
                    "type": "p",
                    "text": "CalluseCallbackat the top level of your component to cache a function definition between re-renders:"
                },
                {
                    "type": "code",
                    "code": "import{useCallback}from'react';exportdefaultfunctionProductPage({productId,referrer,theme}){consthandleSubmit=useCallback((orderDetails)=>{post('/product/'+productId+'/buy',{referrer,orderDetails,});},[productId,referrer]);"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if thedependencieshave not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it.",
                        "dependencies: The list of all reactive values referenced inside of thefncode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison algorithm."
                    ]
                },
                {
                    "type": "p",
                    "text": "fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if thedependencieshave not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it."
                },
                {
                    "type": "p",
                    "text": "dependencies: The list of all reactive values referenced inside of thefncode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison algorithm."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "On the initial render,useCallbackreturns thefnfunction you have passed."
                },
                {
                    "type": "p",
                    "text": "During subsequent renders, it will either return an already storedfnfunction from the last render (if the dependencies haven’t changed), or return thefnfunction you have passed during this render."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "useCallbackis a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.",
                        "Reactwill not throw away the cached function unless there is a specific reason to do that.For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache—for example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should match your expectations if you rely onuseCallbackas a performance optimization. Otherwise, astate variableor arefmay be more appropriate."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Skipping re-rendering of components"
                },
                {
                    "type": "p",
                    "text": "When you optimize rendering performance, you will sometimes need to cache the functions that you pass to child components. Let’s first look at the syntax for how to do this, and then see in which cases it’s useful."
                },
                {
                    "type": "p",
                    "text": "To cache a function between re-renders of your component, wrap its definition into theuseCallbackHook:"
                },
                {
                    "type": "code",
                    "code": "import{useCallback}from'react';functionProductPage({productId,referrer,theme}){consthandleSubmit=useCallback((orderDetails)=>{post('/product/'+productId+'/buy',{referrer,orderDetails,});},[productId, referrer]);// ..."
                },
                {
                    "type": "p",
                    "text": "You need to pass two things touseCallback:"
                },
                {
                    "type": "list",
                    "items": [
                        "A function definition that you want to cache between re-renders.",
                        "Alist of dependenciesincluding every value within your component that’s used inside your function."
                    ]
                },
                {
                    "type": "p",
                    "text": "On the initial render, thereturned functionyou’ll get fromuseCallbackwill be the function you passed."
                },
                {
                    "type": "p",
                    "text": "On the following renders, React will compare thedependencieswith the dependencies you passed during the previous render. If none of the dependencies have changed (compared withObject.is),useCallbackwill return the same function as before. Otherwise,useCallbackwill return the function you passed onthisrender."
                },
                {
                    "type": "p",
                    "text": "In other words,useCallbackcaches a function between re-renders until its dependencies change."
                },
                {
                    "type": "p",
                    "text": "Let’s walk through an example to see when this is useful."
                },
                {
                    "type": "p",
                    "text": "Say you’re passing ahandleSubmitfunction down from theProductPageto theShippingFormcomponent:"
                },
                {
                    "type": "code",
                    "code": "functionProductPage({productId,referrer,theme}){// ...return(<divclassName={theme}><ShippingFormonSubmit={handleSubmit}/></div>);"
                },
                {
                    "type": "p",
                    "text": "You’ve noticed that toggling thethemeprop freezes the app for a moment, but if you remove<ShippingForm />from your JSX, it feels fast. This tells you that it’s worth trying to optimize theShippingFormcomponent."
                },
                {
                    "type": "p",
                    "text": "By default, when a component re-renders, React re-renders all of its children recursively.This is why, whenProductPagere-renders with a differenttheme, theShippingFormcomponentalsore-renders. This is fine for components that don’t require much calculation to re-render. But if you verified a re-render is slow, you can tellShippingFormto skip re-rendering when its props are the same as on last render by wrapping it inmemo:"
                },
                {
                    "type": "code",
                    "code": "import{memo}from'react';constShippingForm=memo(functionShippingForm({onSubmit}){// ...});"
                },
                {
                    "type": "p",
                    "text": "With this change,ShippingFormwill skip re-rendering if all of its props are thesameas on the last render.This is when caching a function becomes important! Let’s say you definedhandleSubmitwithoutuseCallback:"
                },
                {
                    "type": "code",
                    "code": "functionProductPage({productId,referrer,theme}){// Every time the theme changes, this will be a different function...functionhandleSubmit(orderDetails){post('/product/'+productId+'/buy',{referrer,orderDetails,});}return(<divclassName={theme}>{/* ... so ShippingForm's props will never be the same, and it will re-render every time */}<ShippingFormonSubmit={handleSubmit}/></div>);}"
                },
                {
                    "type": "p",
                    "text": "In JavaScript, afunction () {}or() => {}always creates adifferentfunction,similar to how the{}object literal always creates a new object. Normally, this wouldn’t be a problem, but it means thatShippingFormprops will never be the same, and yourmemooptimization won’t work. This is whereuseCallbackcomes in handy:"
                },
                {
                    "type": "code",
                    "code": "functionProductPage({productId,referrer,theme}){// Tell React to cache your function between re-renders...consthandleSubmit=useCallback((orderDetails)=>{post('/product/'+productId+'/buy',{referrer,orderDetails,});},[productId,referrer]);// ...so as long as these dependencies don't change...return(<divclassName={theme}>{/* ...ShippingForm will receive the same props and can skip re-rendering */}<ShippingFormonSubmit={handleSubmit}/></div>);}"
                },
                {
                    "type": "p",
                    "text": "By wrappinghandleSubmitinuseCallback, you ensure that it’s thesamefunction between the re-renders(until dependencies change). You don’thave towrap a function inuseCallbackunless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped inmemo,and this lets it skip re-rendering. There are other reasons you might needuseCallbackwhich are described further on this page."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "You should only rely onuseCallbackas a performance optimization.If your code doesn’t work without it, find the underlying problem and fix it first. Then you may adduseCallbackback."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "How is useCallback related to useMemo?"
                },
                {
                    "type": "p",
                    "text": "You will often seeuseMemoalongsideuseCallback. They are both useful when you’re trying to optimize a child component. They let youmemoize(or, in other words, cache) something you’re passing down:"
                },
                {
                    "type": "code",
                    "code": "import{useMemo,useCallback}from'react';functionProductPage({productId,referrer}){constproduct=useData('/product/'+productId);constrequirements=useMemo(()=>{// Calls your function and caches its resultreturncomputeRequirements(product);},[product]);consthandleSubmit=useCallback((orderDetails)=>{// Caches your function itselfpost('/product/'+productId+'/buy',{referrer,orderDetails,});},[productId,referrer]);return(<divclassName={theme}><ShippingFormrequirements={requirements}onSubmit={handleSubmit}/></div>);}"
                },
                {
                    "type": "p",
                    "text": "The difference is inwhatthey’re letting you cache:"
                },
                {
                    "type": "list",
                    "items": [
                        "useMemocaches theresultof calling your function.In this example, it caches the result of callingcomputeRequirements(product)so that it doesn’t change unlessproducthas changed. This lets you pass therequirementsobject down without unnecessarily re-renderingShippingForm. When necessary, React will call the function you’ve passed during rendering to calculate the result.",
                        "useCallbackcachesthe function itself.UnlikeuseMemo, it does not call the function you provide. Instead, it caches the function you provided so thathandleSubmititselfdoesn’t change unlessproductIdorreferrerhas changed. This lets you pass thehandleSubmitfunction down without unnecessarily re-renderingShippingForm. Your code won’t run until the user submits the form."
                    ]
                },
                {
                    "type": "p",
                    "text": "If you’re already familiar withuseMemo,you might find it helpful to think ofuseCallbackas this:"
                },
                {
                    "type": "code",
                    "code": "// Simplified implementation (inside React)functionuseCallback(fn,dependencies){returnuseMemo(()=>fn,dependencies);}"
                },
                {
                    "type": "p",
                    "text": "Read more about the difference betweenuseMemoanduseCallback."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Should you add useCallback everywhere?"
                },
                {
                    "type": "p",
                    "text": "If your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful."
                },
                {
                    "type": "p",
                    "text": "Caching a function withuseCallbackis only valuable in a few cases:"
                },
                {
                    "type": "list",
                    "items": [
                        "You pass it as a prop to a component wrapped inmemo.You want to skip re-rendering if the value hasn’t changed. Memoization lets your component re-render only if dependencies changed.",
                        "The function you’re passing is later used as a dependency of some Hook. For example, another function wrapped inuseCallbackdepends on it, or you depend on this function fromuseEffect."
                    ]
                },
                {
                    "type": "p",
                    "text": "There is no benefit to wrapping a function inuseCallbackin other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside is that code becomes less readable. Also, not all memoization is effective: a single value that’s “always new” is enough to break memoization for an entire component."
                },
                {
                    "type": "p",
                    "text": "Note thatuseCallbackdoes not preventcreatingthe function. You’re always creating a function (and that’s fine!), but React ignores it and gives you back a cached function if nothing changed."
                },
                {
                    "type": "p",
                    "text": "In practice, you can make a lot of memoization unnecessary by following a few principles:"
                },
                {
                    "type": "list",
                    "items": [
                        "When a component visually wraps other components, let itaccept JSX as children.Then, if the wrapper component updates its own state, React knows that its children don’t need to re-render.",
                        "Prefer local state and don’tlift state upany further than necessary. Don’t keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.",
                        "Keep yourrendering logic pure.If re-rendering a component causes a problem or produces some noticeable visual artifact, it’s a bug in your component! Fix the bug instead of adding memoization.",
                        "Avoidunnecessary Effects that update state.Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.",
                        "Try toremove unnecessary dependencies from your Effects.For example, instead of memoization, it’s often simpler to move some object or a function inside an Effect or outside the component."
                    ]
                },
                {
                    "type": "p",
                    "text": "If a specific interaction still feels laggy,use the React Developer Tools profilerto see which components benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it’s good to follow them in any case. In long term, we’re researchingdoing memoization automaticallyto solve this once and for all."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "The difference between useCallback and declaring a function directly"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of2:Skipping re-rendering withuseCallbackandmemo"
                },
                {
                    "type": "p",
                    "text": "In this example, theShippingFormcomponent isartificially slowed downso that you can see what happens when a React component you’re rendering is genuinely slow. Try incrementing the counter and toggling the theme."
                },
                {
                    "type": "p",
                    "text": "Incrementing the counter feels slow because it forces the slowed downShippingFormto re-render. That’s expected because the counter has changed, and so you need to reflect the user’s new choice on the screen."
                },
                {
                    "type": "p",
                    "text": "Next, try toggling the theme.Thanks touseCallbacktogether withmemo, it’s fast despite the artificial slowdown!ShippingFormskipped re-rendering because thehandleSubmitfunction has not changed. ThehandleSubmitfunction has not changed because bothproductIdandreferrer(youruseCallbackdependencies) haven’t changed since last render."
                },
                {
                    "type": "code",
                    "code": "import{useCallback}from'react';importShippingFormfrom'./ShippingForm.js';exportdefaultfunctionProductPage({productId,referrer,theme}){consthandleSubmit=useCallback((orderDetails)=>{post('/product/'+productId+'/buy',{referrer,orderDetails,});},[productId,referrer]);return(<divclassName={theme}><ShippingFormonSubmit={handleSubmit}/></div>);}functionpost(url,data){// Imagine this sends a request...console.log('POST /'+url);console.log(data);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Updating state from a memoized callback"
                },
                {
                    "type": "p",
                    "text": "Sometimes, you might need to update state based on previous state from a memoized callback."
                },
                {
                    "type": "p",
                    "text": "ThishandleAddTodofunction specifiestodosas a dependency because it computes the next todos from it:"
                },
                {
                    "type": "code",
                    "code": "functionTodoList(){const[todos,setTodos]=useState([]);consthandleAddTodo=useCallback((text)=>{constnewTodo={id:nextId++,text};setTodos([...todos,newTodo]);},[todos]);// ..."
                },
                {
                    "type": "p",
                    "text": "You’ll usually want memoized functions to have as few dependencies as possible. When you read some state only to calculate the next state, you can remove that dependency by passing anupdater functioninstead:"
                },
                {
                    "type": "code",
                    "code": "functionTodoList(){const[todos,setTodos]=useState([]);consthandleAddTodo=useCallback((text)=>{constnewTodo={id:nextId++,text};setTodos(todos=>[...todos,newTodo]);},[]);// ✅ No need for the todos dependency// ..."
                },
                {
                    "type": "p",
                    "text": "Here, instead of makingtodosa dependency and reading it inside, you pass an instruction abouthowto update the state (todos => [...todos, newTodo]) to React.Read more about updater functions."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Preventing an Effect from firing too often"
                },
                {
                    "type": "p",
                    "text": "Sometimes, you might want to call a function from inside anEffect:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){const[message,setMessage]=useState('');functioncreateOptions(){return{serverUrl:'https://localhost:1234',roomId:roomId};}useEffect(()=>{constoptions=createOptions();constconnection=createConnection(options);connection.connect();// ..."
                },
                {
                    "type": "p",
                    "text": "This creates a problem.Every reactive value must be declared as a dependency of your Effect.However, if you declarecreateOptionsas a dependency, it will cause your Effect to constantly reconnect to the chat room:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{constoptions=createOptions();constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[createOptions]);// 🔴 Problem: This dependency changes on every render// ..."
                },
                {
                    "type": "p",
                    "text": "To solve this, you can wrap the function you need to call from an Effect intouseCallback:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){const[message,setMessage]=useState('');constcreateOptions=useCallback(()=>{return{serverUrl:'https://localhost:1234',roomId:roomId};},[roomId]);// ✅ Only changes when roomId changesuseEffect(()=>{constoptions=createOptions();constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[createOptions]);// ✅ Only changes when createOptions changes// ..."
                },
                {
                    "type": "p",
                    "text": "This ensures that thecreateOptionsfunction is the same between re-renders if theroomIdis the same.However, it’s even better to remove the need for a function dependency.Move your functioninsidethe Effect:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){const[message,setMessage]=useState('');useEffect(()=>{functioncreateOptions(){// ✅ No need for useCallback or function dependencies!return{serverUrl:'https://localhost:1234',roomId:roomId};}constoptions=createOptions();constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[roomId]);// ✅ Only changes when roomId changes// ..."
                },
                {
                    "type": "p",
                    "text": "Now your code is simpler and doesn’t needuseCallback.Learn more about removing Effect dependencies."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Optimizing a custom Hook"
                },
                {
                    "type": "p",
                    "text": "If you’re writing acustom Hook,it’s recommended to wrap any functions that it returns intouseCallback:"
                },
                {
                    "type": "code",
                    "code": "functionuseRouter(){const{dispatch}=useContext(RouterStateContext);constnavigate=useCallback((url)=>{dispatch({type:'navigate',url});},[dispatch]);constgoBack=useCallback(()=>{dispatch({type:'back'});},[dispatch]);return{navigate,goBack,};}"
                },
                {
                    "type": "p",
                    "text": "This ensures that the consumers of your Hook can optimize their own code when needed."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Every time my component renders,useCallbackreturns a different function"
                },
                {
                    "type": "p",
                    "text": "Make sure you’ve specified the dependency array as a second argument!"
                },
                {
                    "type": "p",
                    "text": "If you forget the dependency array,useCallbackwill return a new function every time:"
                },
                {
                    "type": "code",
                    "code": "functionProductPage({productId,referrer}){consthandleSubmit=useCallback((orderDetails)=>{post('/product/'+productId+'/buy',{referrer,orderDetails,});});// 🔴 Returns a new function every time: no dependency array// ..."
                },
                {
                    "type": "p",
                    "text": "This is the corrected version passing the dependency array as a second argument:"
                },
                {
                    "type": "code",
                    "code": "functionProductPage({productId,referrer}){consthandleSubmit=useCallback((orderDetails)=>{post('/product/'+productId+'/buy',{referrer,orderDetails,});},[productId,referrer]);// ✅ Does not return a new function unnecessarily// ..."
                },
                {
                    "type": "p",
                    "text": "If this doesn’t help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:"
                },
                {
                    "type": "code",
                    "code": "consthandleSubmit=useCallback((orderDetails)=>{// ..},[productId,referrer]);console.log([productId,referrer]);"
                },
                {
                    "type": "p",
                    "text": "You can then right-click on the arrays from different re-renders in the console and select “Store as a global variable” for both of them. Assuming the first one got saved astemp1and the second one got saved astemp2, you can then use the browser console to check whether each dependency in both arrays is the same:"
                },
                {
                    "type": "code",
                    "code": "Object.is(temp1[0],temp2[0]);// Is the first dependency the same between the arrays?Object.is(temp1[1],temp2[1]);// Is the second dependency the same between the arrays?Object.is(temp1[2],temp2[2]);// ... and so on for every dependency ..."
                },
                {
                    "type": "p",
                    "text": "When you find which dependency is breaking memoization, either find a way to remove it, ormemoize it as well."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I need to calluseCallbackfor each list item in a loop, but it’s not allowed"
                },
                {
                    "type": "p",
                    "text": "Suppose theChartcomponent is wrapped inmemo. You want to skip re-rendering everyChartin the list when theReportListcomponent re-renders. However, you can’t calluseCallbackin a loop:"
                },
                {
                    "type": "code",
                    "code": "functionReportList({items}){return(<article>{items.map(item=>{// 🔴 You can't call useCallback in a loop like this:consthandleClick=useCallback(()=>{sendReport(item)},[item]);return(<figurekey={item.id}><ChartonClick={handleClick}/></figure>);})}</article>);}"
                },
                {
                    "type": "p",
                    "text": "Instead, extract a component for an individual item, and putuseCallbackthere:"
                },
                {
                    "type": "code",
                    "code": "functionReportList({items}){return(<article>{items.map(item=><Reportkey={item.id}item={item}/>)}</article>);}functionReport({item}){// ✅ Call useCallback at the top level:consthandleClick=useCallback(()=>{sendReport(item)},[item]);return(<figure><ChartonClick={handleClick}/></figure>);}"
                },
                {
                    "type": "p",
                    "text": "Alternatively, you could removeuseCallbackin the last snippet and instead wrapReportitself inmemo.If theitemprop does not change,Reportwill skip re-rendering, soChartwill skip re-rendering too:"
                },
                {
                    "type": "code",
                    "code": "functionReportList({items}){// ...}constReport=memo(functionReport({item}){functionhandleClick(){sendReport(item);}return(<figure><ChartonClick={handleClick}/></figure>);});"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/useContext",
            "title": "useContext – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "useContext"
                },
                {
                    "type": "p",
                    "text": "useContextis a React Hook that lets you read and subscribe tocontextfrom your component."
                },
                {
                    "type": "code",
                    "code": "constvalue=useContext(SomeContext)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceuseContext(SomeContext)",
                        "useContext(SomeContext)",
                        "UsagePassing data deeply into the treeUpdating data passed via contextSpecifying a fallback default valueOverriding context for a part of the treeOptimizing re-renders when passing objects and functions",
                        "Passing data deeply into the tree",
                        "Updating data passed via context",
                        "Specifying a fallback default value",
                        "Overriding context for a part of the tree",
                        "Optimizing re-renders when passing objects and functions",
                        "TroubleshootingMy component doesn’t see the value from my providerI am always gettingundefinedfrom my context although the default value is different",
                        "My component doesn’t see the value from my provider",
                        "I am always gettingundefinedfrom my context although the default value is different"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "useContext(SomeContext)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Passing data deeply into the tree",
                        "Updating data passed via context",
                        "Specifying a fallback default value",
                        "Overriding context for a part of the tree",
                        "Optimizing re-renders when passing objects and functions"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "My component doesn’t see the value from my provider",
                        "I am always gettingundefinedfrom my context although the default value is different"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useContext(SomeContext)"
                },
                {
                    "type": "p",
                    "text": "CalluseContextat the top level of your component to read and subscribe tocontext."
                },
                {
                    "type": "code",
                    "code": "import{useContext}from'react';functionMyComponent(){consttheme=useContext(ThemeContext);// ..."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "SomeContext: The context that you’ve previously created withcreateContext. The context itself does not hold the information, it only represents the kind of information you can provide or read from components."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "useContextreturns the context value for the calling component. It is determined as thevaluepassed to the closestSomeContext.Providerabove the calling component in the tree. If there is no such provider, then the returned value will be thedefaultValueyou have passed tocreateContextfor that context. The returned value is always up-to-date. React automatically re-renders components that read some context if it changes."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "useContext()call in a component is not affected by providers returned from thesamecomponent. The corresponding<Context.Provider>needs to beabovethe component doing theuseContext()call.",
                        "Reactautomatically re-rendersall the children that use a particular context starting from the provider that receives a differentvalue. The previous and the next values are compared with theObject.iscomparison. Skipping re-renders withmemodoes not prevent the children receiving fresh context values.",
                        "If your build system produces duplicates modules in the output (which can happen with symlinks), this can break context. Passing something via context only works ifSomeContextthat you use to provide context andSomeContextthat you use to read it areexactlythe same object, as determined by a===comparison."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Passing data deeply into the tree"
                },
                {
                    "type": "p",
                    "text": "CalluseContextat the top level of your component to read and subscribe tocontext."
                },
                {
                    "type": "code",
                    "code": "import{useContext}from'react';functionButton(){consttheme=useContext(ThemeContext);// ..."
                },
                {
                    "type": "p",
                    "text": "useContextreturns thecontext valuefor thecontextyou passed. To determine the context value, React searches the component tree and findsthe closest context provider abovefor that particular context."
                },
                {
                    "type": "p",
                    "text": "To pass context to aButton, wrap it or one of its parent components into the corresponding context provider:"
                },
                {
                    "type": "code",
                    "code": "functionMyPage(){return(<ThemeContext.Providervalue=\"dark\"><Form/></ThemeContext.Provider>);}functionForm(){// ... renders buttons inside ...}"
                },
                {
                    "type": "p",
                    "text": "It doesn’t matter how many layers of components there are between the provider and theButton. When aButtonanywhereinside ofFormcallsuseContext(ThemeContext), it will receive\"dark\"as the value."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "useContext()always looks for the closest providerabovethe component that calls it. It searches upwards anddoes notconsider providers in the component from which you’re callinguseContext()."
                },
                {
                    "type": "code",
                    "code": "import{createContext,useContext}from'react';constThemeContext=createContext(null);exportdefaultfunctionMyApp(){return(<ThemeContext.Providervalue=\"dark\"><Form/></ThemeContext.Provider>)}functionForm(){return(<Paneltitle=\"Welcome\"><Button>Sign up</Button><Button>Log in</Button></Panel>);}functionPanel({title,children}){consttheme=useContext(ThemeContext);constclassName='panel-'+theme;return(<sectionclassName={className}><h1>{title}</h1>{children}</section>)}functionButton({children}){consttheme=useContext(ThemeContext);constclassName='button-'+theme;return(<buttonclassName={className}>{children}</button>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Updating data passed via context"
                },
                {
                    "type": "p",
                    "text": "Often, you’ll want the context to change over time. To update context, combine it withstate.Declare a state variable in the parent component, and pass the current state down as thecontext valueto the provider."
                },
                {
                    "type": "code",
                    "code": "functionMyPage(){const[theme,setTheme]=useState('dark');return(<ThemeContext.Providervalue={theme}><Form/><ButtononClick={()=>{setTheme('light');}}>Switch to light theme</Button></ThemeContext.Provider>);}"
                },
                {
                    "type": "p",
                    "text": "Now anyButtoninside of the provider will receive the currentthemevalue. If you callsetThemeto update thethemevalue that you pass to the provider, allButtoncomponents will re-render with the new'light'value."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Examples of updating context"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of5:Updating a value via context"
                },
                {
                    "type": "p",
                    "text": "In this example, theMyAppcomponent holds a state variable which is then passed to theThemeContextprovider. Checking the “Dark mode” checkbox updates the state. Changing the provided value re-renders all the components using that context."
                },
                {
                    "type": "code",
                    "code": "import{createContext,useContext,useState}from'react';constThemeContext=createContext(null);exportdefaultfunctionMyApp(){const[theme,setTheme]=useState('light');return(<ThemeContext.Providervalue={theme}><Form/><label><inputtype=\"checkbox\"checked={theme==='dark'}onChange={(e)=>{setTheme(e.target.checked?'dark':'light')}}/>Use dark mode</label></ThemeContext.Provider>)}functionForm({children}){return(<Paneltitle=\"Welcome\"><Button>Sign up</Button><Button>Log in</Button></Panel>);}functionPanel({title,children}){consttheme=useContext(ThemeContext);constclassName='panel-'+theme;return(<sectionclassName={className}><h1>{title}</h1>{children}</section>)}functionButton({children}){consttheme=useContext(ThemeContext);constclassName='button-'+theme;return(<buttonclassName={className}>{children}</button>);}"
                },
                {
                    "type": "p",
                    "text": "Note thatvalue=\"dark\"passes the\"dark\"string, butvalue={theme}passes the value of the JavaScriptthemevariable withJSX curly braces.Curly braces also let you pass context values that aren’t strings."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Specifying a fallback default value"
                },
                {
                    "type": "p",
                    "text": "If React can’t find any providers of that particularcontextin the parent tree, the context value returned byuseContext()will be equal to thedefault valuethat you specified when youcreated that context:"
                },
                {
                    "type": "code",
                    "code": "constThemeContext=createContext(null);"
                },
                {
                    "type": "p",
                    "text": "The default valuenever changes. If you want to update context, use it with state asdescribed above."
                },
                {
                    "type": "p",
                    "text": "Often, instead ofnull, there is some more meaningful value you can use as a default, for example:"
                },
                {
                    "type": "code",
                    "code": "constThemeContext=createContext('light');"
                },
                {
                    "type": "p",
                    "text": "This way, if you accidentally render some component without a corresponding provider, it won’t break. This also helps your components work well in a test environment without setting up a lot of providers in the tests."
                },
                {
                    "type": "p",
                    "text": "In the example below, the “Toggle theme” button is always light because it’soutside any theme context providerand the default context theme value is'light'. Try editing the default theme to be'dark'."
                },
                {
                    "type": "code",
                    "code": "import{createContext,useContext,useState}from'react';constThemeContext=createContext('light');exportdefaultfunctionMyApp(){const[theme,setTheme]=useState('light');return(<><ThemeContext.Providervalue={theme}><Form/></ThemeContext.Provider><ButtononClick={()=>{setTheme(theme==='dark'?'light':'dark');}}>Toggle theme</Button></>)}functionForm({children}){return(<Paneltitle=\"Welcome\"><Button>Sign up</Button><Button>Log in</Button></Panel>);}functionPanel({title,children}){consttheme=useContext(ThemeContext);constclassName='panel-'+theme;return(<sectionclassName={className}><h1>{title}</h1>{children}</section>)}functionButton({children,onClick}){consttheme=useContext(ThemeContext);constclassName='button-'+theme;return(<buttonclassName={className}onClick={onClick}>{children}</button>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Overriding context for a part of the tree"
                },
                {
                    "type": "p",
                    "text": "You can override the context for a part of the tree by wrapping that part in a provider with a different value."
                },
                {
                    "type": "code",
                    "code": "<ThemeContext.Providervalue=\"dark\">...<ThemeContext.Providervalue=\"light\"><Footer/></ThemeContext.Provider>...</ThemeContext.Provider>"
                },
                {
                    "type": "p",
                    "text": "You can nest and override providers as many times as you need."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Examples of overriding context"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of2:Overriding a theme"
                },
                {
                    "type": "p",
                    "text": "Here, the buttoninsidetheFooterreceives a different context value (\"light\") than the buttons outside (\"dark\")."
                },
                {
                    "type": "code",
                    "code": "import{createContext,useContext}from'react';constThemeContext=createContext(null);exportdefaultfunctionMyApp(){return(<ThemeContext.Providervalue=\"dark\"><Form/></ThemeContext.Provider>)}functionForm(){return(<Paneltitle=\"Welcome\"><Button>Sign up</Button><Button>Log in</Button><ThemeContext.Providervalue=\"light\"><Footer/></ThemeContext.Provider></Panel>);}functionFooter(){return(<footer><Button>Settings</Button></footer>);}functionPanel({title,children}){consttheme=useContext(ThemeContext);constclassName='panel-'+theme;return(<sectionclassName={className}>{title&&<h1>{title}</h1>}{children}</section>)}functionButton({children}){consttheme=useContext(ThemeContext);constclassName='button-'+theme;return(<buttonclassName={className}>{children}</button>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Optimizing re-renders when passing objects and functions"
                },
                {
                    "type": "p",
                    "text": "You can pass any values via context, including objects and functions."
                },
                {
                    "type": "code",
                    "code": "functionMyApp(){const[currentUser,setCurrentUser]=useState(null);functionlogin(response){storeCredentials(response.credentials);setCurrentUser(response.user);}return(<AuthContext.Providervalue={{ currentUser, login }}><Page/></AuthContext.Provider>);}"
                },
                {
                    "type": "p",
                    "text": "Here, thecontext valueis a JavaScript object with two properties, one of which is a function. WheneverMyAppre-renders (for example, on a route update), this will be adifferentobject pointing at adifferentfunction, so React will also have to re-render all components deep in the tree that calluseContext(AuthContext)."
                },
                {
                    "type": "p",
                    "text": "In smaller apps, this is not a problem. However, there is no need to re-render them if the underlying data, likecurrentUser, has not changed. To help React take advantage of that fact, you may wrap theloginfunction withuseCallbackand wrap the object creation intouseMemo. This is a performance optimization:"
                },
                {
                    "type": "code",
                    "code": "import{useCallback,useMemo}from'react';functionMyApp(){const[currentUser,setCurrentUser]=useState(null);constlogin=useCallback((response)=>{storeCredentials(response.credentials);setCurrentUser(response.user);},[]);constcontextValue=useMemo(()=>({currentUser,login}),[currentUser,login]);return(<AuthContext.Providervalue={contextValue}><Page/></AuthContext.Provider>);}"
                },
                {
                    "type": "p",
                    "text": "As a result of this change, even ifMyAppneeds to re-render, the components callinguseContext(AuthContext)won’t need to re-render unlesscurrentUserhas changed."
                },
                {
                    "type": "p",
                    "text": "Read more aboutuseMemoanduseCallback."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My component doesn’t see the value from my provider"
                },
                {
                    "type": "p",
                    "text": "There are a few common ways that this can happen:"
                },
                {
                    "type": "list",
                    "items": [
                        "You’re rendering<SomeContext.Provider>in the same component (or below) as where you’re callinguseContext(). Move<SomeContext.Provider>above and outsidethe component callinguseContext().",
                        "You may have forgotten to wrap your component with<SomeContext.Provider>, or you might have put it in a different part of the tree than you thought. Check whether the hierarchy is right usingReact DevTools.",
                        "You might be running into some build issue with your tooling that causesSomeContextas seen from the providing component andSomeContextas seen by the reading component to be two different objects. This can happen if you use symlinks, for example. You can verify this by assigning them to globals likewindow.SomeContext1andwindow.SomeContext2and then checking whetherwindow.SomeContext1 === window.SomeContext2in the console. If they’re not the same, fix that issue on the build tool level."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I am always gettingundefinedfrom my context although the default value is different"
                },
                {
                    "type": "p",
                    "text": "You might have a provider without avaluein the tree:"
                },
                {
                    "type": "code",
                    "code": "// 🚩 Doesn't work: no value prop<ThemeContext.Provider><Button/></ThemeContext.Provider>"
                },
                {
                    "type": "p",
                    "text": "If you forget to specifyvalue, it’s like passingvalue={undefined}."
                },
                {
                    "type": "p",
                    "text": "You may have also mistakingly used a different prop name by mistake:"
                },
                {
                    "type": "code",
                    "code": "// 🚩 Doesn't work: prop should be called \"value\"<ThemeContext.Providertheme={theme}><Button/></ThemeContext.Provider>"
                },
                {
                    "type": "p",
                    "text": "In both of these cases you should see a warning from React in the console. To fix them, call the propvalue:"
                },
                {
                    "type": "code",
                    "code": "// ✅ Passing the value prop<ThemeContext.Providervalue={theme}><Button/></ThemeContext.Provider>"
                },
                {
                    "type": "p",
                    "text": "Note that thedefault value from yourcreateContext(defaultValue)callis only usedif there is no matching provider above at all.If there is a<SomeContext.Provider value={undefined}>component somewhere in the parent tree, the component callinguseContext(SomeContext)willreceiveundefinedas the context value."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/useDebugValue",
            "title": "useDebugValue – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "useDebugValue"
                },
                {
                    "type": "p",
                    "text": "useDebugValueis a React Hook that lets you add a label to a custom Hook inReact DevTools."
                },
                {
                    "type": "code",
                    "code": "useDebugValue(value,format?)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceuseDebugValue(value, format?)",
                        "useDebugValue(value, format?)",
                        "UsageAdding a label to a custom HookDeferring formatting of a debug value",
                        "Adding a label to a custom Hook",
                        "Deferring formatting of a debug value"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "useDebugValue(value, format?)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Adding a label to a custom Hook",
                        "Deferring formatting of a debug value"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useDebugValue(value, format?)"
                },
                {
                    "type": "p",
                    "text": "CalluseDebugValueat the top level of yourcustom Hookto display a readable debug value:"
                },
                {
                    "type": "code",
                    "code": "import{useDebugValue}from'react';functionuseOnlineStatus(){// ...useDebugValue(isOnline?'Online':'Offline');// ...}"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "value: The value you want to display in React DevTools. It can have any type.",
                        "optionalformat: A formatting function. When the component is inspected, React DevTools will call the formatting function with thevalueas the argument, and then display the returned formatted value (which may have any type). If you don’t specify the formatting function, the originalvalueitself will be displayed."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "useDebugValuedoes not return anything."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Adding a label to a custom Hook"
                },
                {
                    "type": "p",
                    "text": "CalluseDebugValueat the top level of yourcustom Hookto display a readabledebug valueforReact DevTools."
                },
                {
                    "type": "code",
                    "code": "import{useDebugValue}from'react';functionuseOnlineStatus(){// ...useDebugValue(isOnline ? 'Online' : 'Offline');// ...}"
                },
                {
                    "type": "p",
                    "text": "This gives components callinguseOnlineStatusa label likeOnlineStatus: \"Online\"when you inspect them:"
                },
                {
                    "type": "p",
                    "text": "Without theuseDebugValuecall, only the underlying data (in this example,true) would be displayed."
                },
                {
                    "type": "code",
                    "code": "import{useSyncExternalStore,useDebugValue}from'react';exportfunctionuseOnlineStatus(){constisOnline=useSyncExternalStore(subscribe,()=>navigator.onLine,()=>true);useDebugValue(isOnline?'Online':'Offline');returnisOnline;}functionsubscribe(callback){window.addEventListener('online',callback);window.addEventListener('offline',callback);return()=>{window.removeEventListener('online',callback);window.removeEventListener('offline',callback);};}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Don’t add debug values to every custom Hook. It’s most valuable for custom Hooks that are part of shared libraries and that have a complex internal data structure that’s difficult to inspect."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Deferring formatting of a debug value"
                },
                {
                    "type": "p",
                    "text": "You can also pass a formatting function as the second argument touseDebugValue:"
                },
                {
                    "type": "code",
                    "code": "useDebugValue(date,date=>date.toDateString());"
                },
                {
                    "type": "p",
                    "text": "Your formatting function will receive thedebug valueas a parameter and should return aformatted display value. When your component is inspected, React DevTools will call this function and display its result."
                },
                {
                    "type": "p",
                    "text": "This lets you avoid running potentially expensive formatting logic unless the component is actually inspected. For example, ifdateis a Date value, this avoids callingtoDateString()on it for every render."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/useDeferredValue",
            "title": "useDeferredValue – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "useDeferredValue"
                },
                {
                    "type": "p",
                    "text": "useDeferredValueis a React Hook that lets you defer updating a part of the UI."
                },
                {
                    "type": "code",
                    "code": "constdeferredValue=useDeferredValue(value)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceuseDeferredValue(value, initialValue?)",
                        "useDeferredValue(value, initialValue?)",
                        "UsageShowing stale content while fresh content is loadingIndicating that the content is staleDeferring re-rendering for a part of the UI",
                        "Showing stale content while fresh content is loading",
                        "Indicating that the content is stale",
                        "Deferring re-rendering for a part of the UI"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "useDeferredValue(value, initialValue?)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Showing stale content while fresh content is loading",
                        "Indicating that the content is stale",
                        "Deferring re-rendering for a part of the UI"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useDeferredValue(value, initialValue?)"
                },
                {
                    "type": "p",
                    "text": "CalluseDeferredValueat the top level of your component to get a deferred version of that value."
                },
                {
                    "type": "code",
                    "code": "import{useState,useDeferredValue}from'react';functionSearchPage(){const[query,setQuery]=useState('');constdeferredQuery=useDeferredValue(query);// ...}"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "value: The value you want to defer. It can have any type.",
                        "Canary onlyoptionalinitialValue: A value to use during the initial render of a component. If this option is omitted,useDeferredValuewill not defer during the initial render, because there’s no previous version ofvaluethat it can render instead."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "list",
                    "items": [
                        "currentValue: During the initial render, the returned deferred value will be the same as the value you provided. During updates, React will first attempt a re-render with the old value (so it will return the old value), and then try another re-render in the background with the new value (so it will return the updated value)."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "In the latest React Canary versions,useDeferredValuereturns theinitialValueon initial render, and schedules a re-render in the background with thevaluereturned."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "When an update is inside a Transition,useDeferredValuealways returns the newvalueand does not spawn a deferred render, since the update is already deferred.",
                        "The values you pass touseDeferredValueshould either be primitive values (like strings and numbers) or objects created outside of rendering. If you create a new object during rendering and immediately pass it touseDeferredValue, it will be different on every render, causing unnecessary background re-renders.",
                        "WhenuseDeferredValuereceives a different value (compared withObject.is), in addition to the current render (when it still uses the previous value), it schedules a re-render in the background with the new value. The background re-render is interruptible: if there’s another update to thevalue, React will restart the background re-render from scratch. For example, if the user is typing into an input faster than a chart receiving its deferred value can re-render, the chart will only re-render after the user stops typing.",
                        "useDeferredValueis integrated with<Suspense>.If the background update caused by a new value suspends the UI, the user will not see the fallback. They will see the old deferred value until the data loads.",
                        "useDeferredValuedoes not by itself prevent extra network requests.",
                        "There is no fixed delay caused byuseDeferredValueitself. As soon as React finishes the original re-render, React will immediately start working on the background re-render with the new deferred value. Any updates caused by events (like typing) will interrupt the background re-render and get prioritized over it.",
                        "The background re-render caused byuseDeferredValuedoes not fire Effects until it’s committed to the screen. If the background re-render suspends, its Effects will run after the data loads and the UI updates."
                    ]
                },
                {
                    "type": "p",
                    "text": "When an update is inside a Transition,useDeferredValuealways returns the newvalueand does not spawn a deferred render, since the update is already deferred."
                },
                {
                    "type": "p",
                    "text": "The values you pass touseDeferredValueshould either be primitive values (like strings and numbers) or objects created outside of rendering. If you create a new object during rendering and immediately pass it touseDeferredValue, it will be different on every render, causing unnecessary background re-renders."
                },
                {
                    "type": "p",
                    "text": "WhenuseDeferredValuereceives a different value (compared withObject.is), in addition to the current render (when it still uses the previous value), it schedules a re-render in the background with the new value. The background re-render is interruptible: if there’s another update to thevalue, React will restart the background re-render from scratch. For example, if the user is typing into an input faster than a chart receiving its deferred value can re-render, the chart will only re-render after the user stops typing."
                },
                {
                    "type": "p",
                    "text": "useDeferredValueis integrated with<Suspense>.If the background update caused by a new value suspends the UI, the user will not see the fallback. They will see the old deferred value until the data loads."
                },
                {
                    "type": "p",
                    "text": "useDeferredValuedoes not by itself prevent extra network requests."
                },
                {
                    "type": "p",
                    "text": "There is no fixed delay caused byuseDeferredValueitself. As soon as React finishes the original re-render, React will immediately start working on the background re-render with the new deferred value. Any updates caused by events (like typing) will interrupt the background re-render and get prioritized over it."
                },
                {
                    "type": "p",
                    "text": "The background re-render caused byuseDeferredValuedoes not fire Effects until it’s committed to the screen. If the background re-render suspends, its Effects will run after the data loads and the UI updates."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Showing stale content while fresh content is loading"
                },
                {
                    "type": "p",
                    "text": "CalluseDeferredValueat the top level of your component to defer updating some part of your UI."
                },
                {
                    "type": "code",
                    "code": "import{useState,useDeferredValue}from'react';functionSearchPage(){const[query,setQuery]=useState('');constdeferredQuery=useDeferredValue(query);// ...}"
                },
                {
                    "type": "p",
                    "text": "During the initial render, thedeferred valuewill be the same as thevalueyou provided."
                },
                {
                    "type": "p",
                    "text": "During updates, thedeferred valuewill “lag behind” the latestvalue. In particular, React will first re-renderwithoutupdating the deferred value, and then try to re-render with the newly received value in the background."
                },
                {
                    "type": "p",
                    "text": "Let’s walk through an example to see when this is useful."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "This example assumes you use a Suspense-enabled data source:"
                },
                {
                    "type": "list",
                    "items": [
                        "Data fetching with Suspense-enabled frameworks likeRelayandNext.js",
                        "Lazy-loading component code withlazy",
                        "Reading the value of a Promise withuse"
                    ]
                },
                {
                    "type": "p",
                    "text": "Learn more about Suspense and its limitations."
                },
                {
                    "type": "p",
                    "text": "In this example, theSearchResultscomponentsuspendswhile fetching the search results. Try typing\"a\", waiting for the results, and then editing it to\"ab\". The results for\"a\"get replaced by the loading fallback."
                },
                {
                    "type": "code",
                    "code": "import{Suspense,useState}from'react';importSearchResultsfrom'./SearchResults.js';exportdefaultfunctionApp(){const[query,setQuery]=useState('');return(<><label>Search albums:<inputvalue={query}onChange={e=>setQuery(e.target.value)}/></label><Suspensefallback={<h2>Loading...</h2>}><SearchResultsquery={query}/></Suspense></>);}"
                },
                {
                    "type": "p",
                    "text": "A common alternative UI pattern is todeferupdating the list of results and to keep showing the previous results until the new results are ready. CalluseDeferredValueto pass a deferred version of the query down:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionApp(){const[query,setQuery]=useState('');constdeferredQuery=useDeferredValue(query);return(<><label>Search albums:<inputvalue={query}onChange={e=>setQuery(e.target.value)}/></label><Suspensefallback={<h2>Loading...</h2>}><SearchResultsquery={deferredQuery}/></Suspense></>);}"
                },
                {
                    "type": "p",
                    "text": "Thequerywill update immediately, so the input will display the new value. However, thedeferredQuerywill keep its previous value until the data has loaded, soSearchResultswill show the stale results for a bit."
                },
                {
                    "type": "p",
                    "text": "Enter\"a\"in the example below, wait for the results to load, and then edit the input to\"ab\". Notice how instead of the Suspense fallback, you now see the stale result list until the new results have loaded:"
                },
                {
                    "type": "code",
                    "code": "import{Suspense,useState,useDeferredValue}from'react';importSearchResultsfrom'./SearchResults.js';exportdefaultfunctionApp(){const[query,setQuery]=useState('');constdeferredQuery=useDeferredValue(query);return(<><label>Search albums:<inputvalue={query}onChange={e=>setQuery(e.target.value)}/></label><Suspensefallback={<h2>Loading...</h2>}><SearchResultsquery={deferredQuery}/></Suspense></>);}"
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "How does deferring a value work under the hood?"
                },
                {
                    "type": "p",
                    "text": "You can think of it as happening in two steps:"
                },
                {
                    "type": "list",
                    "items": [
                        "First, React re-renders with the newquery(\"ab\") but with the olddeferredQuery(still\"a\").ThedeferredQueryvalue, which you pass to the result list, isdeferred:it “lags behind” thequeryvalue.",
                        "In the background, React tries to re-render withbothqueryanddeferredQueryupdated to\"ab\".If this re-render completes, React will show it on the screen. However, if it suspends (the results for\"ab\"have not loaded yet), React will abandon this rendering attempt, and retry this re-render again after the data has loaded. The user will keep seeing the stale deferred value until the data is ready."
                    ]
                },
                {
                    "type": "p",
                    "text": "First, React re-renders with the newquery(\"ab\") but with the olddeferredQuery(still\"a\").ThedeferredQueryvalue, which you pass to the result list, isdeferred:it “lags behind” thequeryvalue."
                },
                {
                    "type": "p",
                    "text": "In the background, React tries to re-render withbothqueryanddeferredQueryupdated to\"ab\".If this re-render completes, React will show it on the screen. However, if it suspends (the results for\"ab\"have not loaded yet), React will abandon this rendering attempt, and retry this re-render again after the data has loaded. The user will keep seeing the stale deferred value until the data is ready."
                },
                {
                    "type": "p",
                    "text": "The deferred “background” rendering is interruptible. For example, if you type into the input again, React will abandon it and restart with the new value. React will always use the latest provided value."
                },
                {
                    "type": "p",
                    "text": "Note that there is still a network request per each keystroke. What’s being deferred here is displaying results (until they’re ready), not the network requests themselves. Even if the user continues typing, responses for each keystroke get cached, so pressing Backspace is instant and doesn’t fetch again."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Indicating that the content is stale"
                },
                {
                    "type": "p",
                    "text": "In the example above, there is no indication that the result list for the latest query is still loading. This can be confusing to the user if the new results take a while to load. To make it more obvious to the user that the result list does not match the latest query, you can add a visual indication when the stale result list is displayed:"
                },
                {
                    "type": "code",
                    "code": "<divstyle={{opacity:query!==deferredQuery?0.5:1,}}><SearchResultsquery={deferredQuery}/></div>"
                },
                {
                    "type": "p",
                    "text": "With this change, as soon as you start typing, the stale result list gets slightly dimmed until the new result list loads. You can also add a CSS transition to delay dimming so that it feels gradual, like in the example below:"
                },
                {
                    "type": "code",
                    "code": "import{Suspense,useState,useDeferredValue}from'react';importSearchResultsfrom'./SearchResults.js';exportdefaultfunctionApp(){const[query,setQuery]=useState('');constdeferredQuery=useDeferredValue(query);constisStale=query!==deferredQuery;return(<><label>Search albums:<inputvalue={query}onChange={e=>setQuery(e.target.value)}/></label><Suspensefallback={<h2>Loading...</h2>}><divstyle={{opacity:isStale?0.5:1,transition:isStale?'opacity 0.2s 0.2s linear':'opacity 0s 0s linear'}}><SearchResultsquery={deferredQuery}/></div></Suspense></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Deferring re-rendering for a part of the UI"
                },
                {
                    "type": "p",
                    "text": "You can also applyuseDeferredValueas a performance optimization. It is useful when a part of your UI is slow to re-render, there’s no easy way to optimize it, and you want to prevent it from blocking the rest of the UI."
                },
                {
                    "type": "p",
                    "text": "Imagine you have a text field and a component (like a chart or a long list) that re-renders on every keystroke:"
                },
                {
                    "type": "code",
                    "code": "functionApp(){const[text,setText]=useState('');return(<><inputvalue={text}onChange={e=>setText(e.target.value)}/><SlowListtext={text}/></>);}"
                },
                {
                    "type": "p",
                    "text": "First, optimizeSlowListto skip re-rendering when its props are the same. To do this,wrap it inmemo:"
                },
                {
                    "type": "code",
                    "code": "constSlowList=memo(functionSlowList({text}){// ...});"
                },
                {
                    "type": "p",
                    "text": "However, this only helps if theSlowListprops arethe sameas during the previous render. The problem you’re facing now is that it’s slow when they’redifferent,and when you actually need to show different visual output."
                },
                {
                    "type": "p",
                    "text": "Concretely, the main performance problem is that whenever you type into the input, theSlowListreceives new props, and re-rendering its entire tree makes the typing feel janky. In this case,useDeferredValuelets you prioritize updating the input (which must be fast) over updating the result list (which is allowed to be slower):"
                },
                {
                    "type": "code",
                    "code": "functionApp(){const[text,setText]=useState('');constdeferredText=useDeferredValue(text);return(<><inputvalue={text}onChange={e=>setText(e.target.value)}/><SlowListtext={deferredText}/></>);}"
                },
                {
                    "type": "p",
                    "text": "This does not make re-rendering of theSlowListfaster. However, it tells React that re-rendering the list can be deprioritized so that it doesn’t block the keystrokes. The list will “lag behind” the input and then “catch up”. Like before, React will attempt to update the list as soon as possible, but will not block the user from typing."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "The difference between useDeferredValue and unoptimized re-rendering"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of2:Deferred re-rendering of the list"
                },
                {
                    "type": "p",
                    "text": "In this example, each item in theSlowListcomponent isartificially slowed downso that you can see howuseDeferredValuelets you keep the input responsive. Type into the input and notice that typing feels snappy while the list “lags behind” it."
                },
                {
                    "type": "code",
                    "code": "import{useState,useDeferredValue}from'react';importSlowListfrom'./SlowList.js';exportdefaultfunctionApp(){const[text,setText]=useState('');constdeferredText=useDeferredValue(text);return(<><inputvalue={text}onChange={e=>setText(e.target.value)}/><SlowListtext={deferredText}/></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "This optimization requiresSlowListto be wrapped inmemo.This is because whenever thetextchanges, React needs to be able to re-render the parent component quickly. During that re-render,deferredTextstill has its previous value, soSlowListis able to skip re-rendering (its props have not changed). Withoutmemo,it would have to re-render anyway, defeating the point of the optimization."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "How is deferring a value different from debouncing and throttling?"
                },
                {
                    "type": "p",
                    "text": "There are two common optimization techniques you might have used before in this scenario:"
                },
                {
                    "type": "list",
                    "items": [
                        "Debouncingmeans you’d wait for the user to stop typing (e.g. for a second) before updating the list.",
                        "Throttlingmeans you’d update the list every once in a while (e.g. at most once a second)."
                    ]
                },
                {
                    "type": "p",
                    "text": "While these techniques are helpful in some cases,useDeferredValueis better suited to optimizing rendering because it is deeply integrated with React itself and adapts to the user’s device."
                },
                {
                    "type": "p",
                    "text": "Unlike debouncing or throttling, it doesn’t require choosing any fixed delay. If the user’s device is fast (e.g. powerful laptop), the deferred re-render would happen almost immediately and wouldn’t be noticeable. If the user’s device is slow, the list would “lag behind” the input proportionally to how slow the device is."
                },
                {
                    "type": "p",
                    "text": "Also, unlike with debouncing or throttling, deferred re-renders done byuseDeferredValueare interruptible by default. This means that if React is in the middle of re-rendering a large list, but the user makes another keystroke, React will abandon that re-render, handle the keystroke, and then start rendering in the background again. By contrast, debouncing and throttling still produce a janky experience because they’reblocking:they merely postpone the moment when rendering blocks the keystroke."
                },
                {
                    "type": "p",
                    "text": "If the work you’re optimizing doesn’t happen during rendering, debouncing and throttling are still useful. For example, they can let you fire fewer network requests. You can also use these techniques together."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/useEffect",
            "title": "useEffect – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "useEffect"
                },
                {
                    "type": "p",
                    "text": "useEffectis a React Hook that lets yousynchronize a component with an external system."
                },
                {
                    "type": "code",
                    "code": "useEffect(setup,dependencies?)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceuseEffect(setup, dependencies?)",
                        "useEffect(setup, dependencies?)",
                        "UsageConnecting to an external systemWrapping Effects in custom HooksControlling a non-React widgetFetching data with EffectsSpecifying reactive dependenciesUpdating state based on previous state from an EffectRemoving unnecessary object dependenciesRemoving unnecessary function dependenciesReading the latest props and state from an EffectDisplaying different content on the server and the client",
                        "Connecting to an external system",
                        "Wrapping Effects in custom Hooks",
                        "Controlling a non-React widget",
                        "Fetching data with Effects",
                        "Specifying reactive dependencies",
                        "Updating state based on previous state from an Effect",
                        "Removing unnecessary object dependencies",
                        "Removing unnecessary function dependencies",
                        "Reading the latest props and state from an Effect",
                        "Displaying different content on the server and the client",
                        "TroubleshootingMy Effect runs twice when the component mountsMy Effect runs after every re-renderMy Effect keeps re-running in an infinite cycleMy cleanup logic runs even though my component didn’t unmountMy Effect does something visual, and I see a flicker before it runs",
                        "My Effect runs twice when the component mounts",
                        "My Effect runs after every re-render",
                        "My Effect keeps re-running in an infinite cycle",
                        "My cleanup logic runs even though my component didn’t unmount",
                        "My Effect does something visual, and I see a flicker before it runs"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "useEffect(setup, dependencies?)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Connecting to an external system",
                        "Wrapping Effects in custom Hooks",
                        "Controlling a non-React widget",
                        "Fetching data with Effects",
                        "Specifying reactive dependencies",
                        "Updating state based on previous state from an Effect",
                        "Removing unnecessary object dependencies",
                        "Removing unnecessary function dependencies",
                        "Reading the latest props and state from an Effect",
                        "Displaying different content on the server and the client"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "My Effect runs twice when the component mounts",
                        "My Effect runs after every re-render",
                        "My Effect keeps re-running in an infinite cycle",
                        "My cleanup logic runs even though my component didn’t unmount",
                        "My Effect does something visual, and I see a flicker before it runs"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useEffect(setup, dependencies?)"
                },
                {
                    "type": "p",
                    "text": "CalluseEffectat the top level of your component to declare an Effect:"
                },
                {
                    "type": "code",
                    "code": "import{useEffect}from'react';import{createConnection}from'./chat.js';functionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{connection.disconnect();};},[serverUrl,roomId]);// ...}"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "setup: The function with your Effect’s logic. Your setup function may also optionally return acleanupfunction. When your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. After your component is removed from the DOM, React will run your cleanup function.",
                        "optionaldependencies: The list of all reactive values referenced inside of thesetupcode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison. If you omit this argument, your Effect will re-run after every re-render of the component.See the difference between passing an array of dependencies, an empty array, and no dependencies at all."
                    ]
                },
                {
                    "type": "p",
                    "text": "setup: The function with your Effect’s logic. Your setup function may also optionally return acleanupfunction. When your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. After your component is removed from the DOM, React will run your cleanup function."
                },
                {
                    "type": "p",
                    "text": "optionaldependencies: The list of all reactive values referenced inside of thesetupcode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison. If you omit this argument, your Effect will re-run after every re-render of the component.See the difference between passing an array of dependencies, an empty array, and no dependencies at all."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "useEffectreturnsundefined."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "useEffectis a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.",
                        "If you’renot trying to synchronize with some external system,you probably don’t need an Effect.",
                        "When Strict Mode is on, React willrun one extra development-only setup+cleanup cyclebefore the first real setup. This is a stress-test that ensures that your cleanup logic “mirrors” your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem,implement the cleanup function.",
                        "If some of your dependencies are objects or functions defined inside the component, there is a risk that they willcause the Effect to re-run more often than needed.To fix this, remove unnecessaryobjectandfunctiondependencies. You can alsoextract state updatesandnon-reactive logicoutside of your Effect.",
                        "If your Effect wasn’t caused by an interaction (like a click), React will generally let the browserpaint the updated screen first before running your Effect.If your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), replaceuseEffectwithuseLayoutEffect.",
                        "If your Effect is caused by an interaction (like a click),React may run your Effect before the browser paints the updated screen. This ensures that the result of the Effect can be observed by the event system. Usually, this works as expected. However, if you must defer the work until after paint, such as analert(), you can usesetTimeout. Seereactwg/react-18/128for more information.",
                        "Even if your Effect was caused by an interaction (like a click),React may allow the browser to repaint the screen before processing the state updates inside your Effect.Usually, this works as expected. However, if you must block the browser from repainting the screen, you need to replaceuseEffectwithuseLayoutEffect.",
                        "Effectsonly run on the client.They don’t run during server rendering."
                    ]
                },
                {
                    "type": "p",
                    "text": "useEffectis a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it."
                },
                {
                    "type": "p",
                    "text": "If you’renot trying to synchronize with some external system,you probably don’t need an Effect."
                },
                {
                    "type": "p",
                    "text": "When Strict Mode is on, React willrun one extra development-only setup+cleanup cyclebefore the first real setup. This is a stress-test that ensures that your cleanup logic “mirrors” your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem,implement the cleanup function."
                },
                {
                    "type": "p",
                    "text": "If some of your dependencies are objects or functions defined inside the component, there is a risk that they willcause the Effect to re-run more often than needed.To fix this, remove unnecessaryobjectandfunctiondependencies. You can alsoextract state updatesandnon-reactive logicoutside of your Effect."
                },
                {
                    "type": "p",
                    "text": "If your Effect wasn’t caused by an interaction (like a click), React will generally let the browserpaint the updated screen first before running your Effect.If your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), replaceuseEffectwithuseLayoutEffect."
                },
                {
                    "type": "p",
                    "text": "If your Effect is caused by an interaction (like a click),React may run your Effect before the browser paints the updated screen. This ensures that the result of the Effect can be observed by the event system. Usually, this works as expected. However, if you must defer the work until after paint, such as analert(), you can usesetTimeout. Seereactwg/react-18/128for more information."
                },
                {
                    "type": "p",
                    "text": "Even if your Effect was caused by an interaction (like a click),React may allow the browser to repaint the screen before processing the state updates inside your Effect.Usually, this works as expected. However, if you must block the browser from repainting the screen, you need to replaceuseEffectwithuseLayoutEffect."
                },
                {
                    "type": "p",
                    "text": "Effectsonly run on the client.They don’t run during server rendering."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Connecting to an external system"
                },
                {
                    "type": "p",
                    "text": "Some components need to stay connected to the network, some browser API, or a third-party library, while they are displayed on the page. These systems aren’t controlled by React, so they are calledexternal."
                },
                {
                    "type": "p",
                    "text": "Toconnect your component to some external system,calluseEffectat the top level of your component:"
                },
                {
                    "type": "code",
                    "code": "import{useEffect}from'react';import{createConnection}from'./chat.js';functionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useEffect(()=>{const connection = createConnection(serverUrl, roomId);connection.connect();return()=>{connection.disconnect();};},[serverUrl, roomId]);// ...}"
                },
                {
                    "type": "p",
                    "text": "You need to pass two arguments touseEffect:"
                },
                {
                    "type": "list",
                    "items": [
                        "Asetup functionwithsetup codethat connects to that system.It should return acleanup functionwithcleanup codethat disconnects from that system.",
                        "It should return acleanup functionwithcleanup codethat disconnects from that system.",
                        "Alist of dependenciesincluding every value from your component used inside of those functions."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "It should return acleanup functionwithcleanup codethat disconnects from that system."
                    ]
                },
                {
                    "type": "p",
                    "text": "React calls your setup and cleanup functions whenever it’s necessary, which may happen multiple times:"
                },
                {
                    "type": "list",
                    "items": [
                        "Yoursetup coderuns when your component is added to the page(mounts).",
                        "After every re-render of your component where thedependencieshave changed:First, yourcleanup coderuns with the old props and state.Then, yoursetup coderuns with the new props and state.",
                        "First, yourcleanup coderuns with the old props and state.",
                        "Then, yoursetup coderuns with the new props and state.",
                        "Yourcleanup coderuns one final time after your component is removed from the page(unmounts)."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "First, yourcleanup coderuns with the old props and state.",
                        "Then, yoursetup coderuns with the new props and state."
                    ]
                },
                {
                    "type": "p",
                    "text": "Let’s illustrate this sequence for the example above."
                },
                {
                    "type": "p",
                    "text": "When theChatRoomcomponent above gets added to the page, it will connect to the chat room with the initialserverUrlandroomId. If eitherserverUrlorroomIdchange as a result of a re-render (say, if the user picks a different chat room in a dropdown), your Effect willdisconnect from the previous room, and connect to the next one.When theChatRoomcomponent is removed from the page, your Effect will disconnect one last time."
                },
                {
                    "type": "p",
                    "text": "Tohelp you find bugs,in development React runssetupandcleanupone extra time before thesetup.This is a stress-test that verifies your Effect’s logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn’t be able to distinguish between the setup being called once (as in production) and asetup→cleanup→setupsequence (as in development).See common solutions."
                },
                {
                    "type": "p",
                    "text": "Try towrite every Effect as an independent processandthink about a single setup/cleanup cycle at a time.It shouldn’t matter whether your component is mounting, updating, or unmounting. When your cleanup logic correctly “mirrors” the setup logic, your Effect is resilient to running setup and cleanup as often as needed."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "An Effect lets youkeep your component synchronizedwith some external system (like a chat service). Here,external systemmeans any piece of code that’s not controlled by React, such as:"
                },
                {
                    "type": "list",
                    "items": [
                        "A timer managed withsetInterval()andclearInterval().",
                        "An event subscription usingwindow.addEventListener()andwindow.removeEventListener().",
                        "A third-party animation library with an API likeanimation.start()andanimation.reset()."
                    ]
                },
                {
                    "type": "p",
                    "text": "If you’re not connecting to any external system,you probably don’t need an Effect."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Examples of connecting to an external system"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of5:Connecting to a chat server"
                },
                {
                    "type": "p",
                    "text": "In this example, theChatRoomcomponent uses an Effect to stay connected to an external system defined inchat.js. Press “Open chat” to make theChatRoomcomponent appear. This sandbox runs in development mode, so there is an extra connect-and-disconnect cycle, asexplained here.Try changing theroomIdandserverUrlusing the dropdown and the input, and see how the Effect re-connects to the chat. Press “Close chat” to see the Effect disconnect one last time."
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection}from'./chat.js';functionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{connection.disconnect();};},[roomId,serverUrl]);return(<><label>Server URL:{' '}<inputvalue={serverUrl}onChange={e=>setServerUrl(e.target.value)}/></label><h1>Welcome to the{roomId}room!</h1></>);}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');const[show,setShow]=useState(false);return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><buttononClick={()=>setShow(!show)}>{show?'Close chat':'Open chat'}</button>{show&&<hr/>}{show&&<ChatRoomroomId={roomId}/>}</>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Wrapping Effects in custom Hooks"
                },
                {
                    "type": "p",
                    "text": "Effects are an“escape hatch”:you use them when you need to “step outside React” and when there is no better built-in solution for your use case. If you find yourself often needing to manually write Effects, it’s usually a sign that you need to extract somecustom Hooksfor common behaviors your components rely on."
                },
                {
                    "type": "p",
                    "text": "For example, thisuseChatRoomcustom Hook “hides” the logic of your Effect behind a more declarative API:"
                },
                {
                    "type": "code",
                    "code": "functionuseChatRoom({serverUrl,roomId}){useEffect(()=>{constoptions={serverUrl:serverUrl,roomId:roomId};constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[roomId,serverUrl]);}"
                },
                {
                    "type": "p",
                    "text": "Then you can use it from any component like this:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useChatRoom({roomId:roomId,serverUrl:serverUrl});// ..."
                },
                {
                    "type": "p",
                    "text": "There are also many excellent custom Hooks for every purpose available in the React ecosystem."
                },
                {
                    "type": "p",
                    "text": "Learn more about wrapping Effects in custom Hooks."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Examples of wrapping Effects in custom Hooks"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of3:CustomuseChatRoomHook"
                },
                {
                    "type": "p",
                    "text": "This example is identical to one of theearlier examples,but the logic is extracted to a custom Hook."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';import{useChatRoom}from'./useChatRoom.js';functionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useChatRoom({roomId:roomId,serverUrl:serverUrl});return(<><label>Server URL:{' '}<inputvalue={serverUrl}onChange={e=>setServerUrl(e.target.value)}/></label><h1>Welcome to the{roomId}room!</h1></>);}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');const[show,setShow]=useState(false);return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><buttononClick={()=>setShow(!show)}>{show?'Close chat':'Open chat'}</button>{show&&<hr/>}{show&&<ChatRoomroomId={roomId}/>}</>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Controlling a non-React widget"
                },
                {
                    "type": "p",
                    "text": "Sometimes, you want to keep an external system synchronized to some prop or state of your component."
                },
                {
                    "type": "p",
                    "text": "For example, if you have a third-party map widget or a video player component written without React, you can use an Effect to call methods on it that make its state match the current state of your React component. This Effect creates an instance of aMapWidgetclass defined inmap-widget.js. When you change thezoomLevelprop of theMapcomponent, the Effect calls thesetZoom()on the class instance to keep it synchronized:"
                },
                {
                    "type": "code",
                    "code": "import{useRef,useEffect}from'react';import{MapWidget}from'./map-widget.js';exportdefaultfunctionMap({zoomLevel}){constcontainerRef=useRef(null);constmapRef=useRef(null);useEffect(()=>{if(mapRef.current===null){mapRef.current=newMapWidget(containerRef.current);}constmap=mapRef.current;map.setZoom(zoomLevel);},[zoomLevel]);return(<divstyle={{width:200,height:200}}ref={containerRef}/>);}"
                },
                {
                    "type": "p",
                    "text": "In this example, a cleanup function is not needed because theMapWidgetclass manages only the DOM node that was passed to it. After theMapReact component is removed from the tree, both the DOM node and theMapWidgetclass instance will be automatically garbage-collected by the browser JavaScript engine."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Fetching data with Effects"
                },
                {
                    "type": "p",
                    "text": "You can use an Effect to fetch data for your component. Note thatif you use a framework,using your framework’s data fetching mechanism will be a lot more efficient than writing Effects manually."
                },
                {
                    "type": "p",
                    "text": "If you want to fetch data from an Effect manually, your code might look like this:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{fetchBio}from'./api.js';exportdefaultfunctionPage(){const[person,setPerson]=useState('Alice');const[bio,setBio]=useState(null);useEffect(()=>{letignore=false;setBio(null);fetchBio(person).then(result=>{if(!ignore){setBio(result);}});return()=>{ignore=true;};},[person]);// ..."
                },
                {
                    "type": "p",
                    "text": "Note theignorevariable which is initialized tofalse, and is set totrueduring cleanup. This ensuresyour code doesn’t suffer from “race conditions”:network responses may arrive in a different order than you sent them."
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{fetchBio}from'./api.js';exportdefaultfunctionPage(){const[person,setPerson]=useState('Alice');const[bio,setBio]=useState(null);useEffect(()=>{letignore=false;setBio(null);fetchBio(person).then(result=>{if(!ignore){setBio(result);}});return()=>{ignore=true;}},[person]);return(<><selectvalue={person}onChange={e=>{setPerson(e.target.value);}}><optionvalue=\"Alice\">Alice</option><optionvalue=\"Bob\">Bob</option><optionvalue=\"Taylor\">Taylor</option></select><hr/><p><i>{bio??'Loading...'}</i></p></>);}"
                },
                {
                    "type": "p",
                    "text": "You can also rewrite using theasync/awaitsyntax, but you still need to provide a cleanup function:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{fetchBio}from'./api.js';exportdefaultfunctionPage(){const[person,setPerson]=useState('Alice');const[bio,setBio]=useState(null);useEffect(()=>{asyncfunctionstartFetching(){setBio(null);constresult=awaitfetchBio(person);if(!ignore){setBio(result);}}letignore=false;startFetching();return()=>{ignore=true;}},[person]);return(<><selectvalue={person}onChange={e=>{setPerson(e.target.value);}}><optionvalue=\"Alice\">Alice</option><optionvalue=\"Bob\">Bob</option><optionvalue=\"Taylor\">Taylor</option></select><hr/><p><i>{bio??'Loading...'}</i></p></>);}"
                },
                {
                    "type": "p",
                    "text": "Writing data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later.It’s easier to use a custom Hook—either your own or maintained by the community."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "What are good alternatives to data fetching in Effects?"
                },
                {
                    "type": "p",
                    "text": "Writingfetchcalls inside Effects is apopular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:"
                },
                {
                    "type": "list",
                    "items": [
                        "Effects don’t run on the server.This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.",
                        "Fetching directly in Effects makes it easy to create “network waterfalls”.You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.",
                        "Fetching directly in Effects usually means you don’t preload or cache data.For example, if the component unmounts and then mounts again, it would have to fetch the data again.",
                        "It’s not very ergonomic.There’s quite a bit of boilerplate code involved when writingfetchcalls in a way that doesn’t suffer from bugs likerace conditions."
                    ]
                },
                {
                    "type": "p",
                    "text": "This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:"
                },
                {
                    "type": "list",
                    "items": [
                        "If you use aframework, use its built-in data fetching mechanism.Modern React frameworks have integrated data fetching mechanisms that are efficient and don’t suffer from the above pitfalls.",
                        "Otherwise, consider using or building a client-side cache.Popular open source solutions includeReact Query,useSWR, andReact Router 6.4+.You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes)."
                    ]
                },
                {
                    "type": "p",
                    "text": "You can continue fetching data directly in Effects if neither of these approaches suit you."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Specifying reactive dependencies"
                },
                {
                    "type": "p",
                    "text": "Notice that you can’t “choose” the dependencies of your Effect.Everyreactive valueused by your Effect’s code must be declared as a dependency. Your Effect’s dependency list is determined by the surrounding code:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){// This is a reactive valueconst[serverUrl,setServerUrl]=useState('https://localhost:1234');// This is a reactive value toouseEffect(()=>{constconnection=createConnection(serverUrl,roomId);// This Effect reads these reactive valuesconnection.connect();return()=>connection.disconnect();},[serverUrl,roomId]);// ✅ So you must specify them as dependencies of your Effect// ...}"
                },
                {
                    "type": "p",
                    "text": "If eitherserverUrlorroomIdchange, your Effect will reconnect to the chat using the new values."
                },
                {
                    "type": "p",
                    "text": "Reactive valuesinclude props and all variables and functions declared directly inside of your component.SinceroomIdandserverUrlare reactive values, you can’t remove them from the dependencies. If you try to omit them andyour linter is correctly configured for React,the linter will flag this as a mistake you need to fix:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>connection.disconnect();},[]);// 🔴 React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl'// ...}"
                },
                {
                    "type": "p",
                    "text": "To remove a dependency, you need to“prove” to the linter that itdoesn’t needto be a dependency.For example, you can moveserverUrlout of your component to prove that it’s not reactive and won’t change on re-renders:"
                },
                {
                    "type": "code",
                    "code": "constserverUrl='https://localhost:1234';// Not a reactive value anymorefunctionChatRoom({roomId}){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>connection.disconnect();},[roomId]);// ✅ All dependencies declared// ...}"
                },
                {
                    "type": "p",
                    "text": "Now thatserverUrlis not a reactive value (and can’t change on a re-render), it doesn’t need to be a dependency.If your Effect’s code doesn’t use any reactive values, its dependency list should be empty ([]):"
                },
                {
                    "type": "code",
                    "code": "constserverUrl='https://localhost:1234';// Not a reactive value anymoreconstroomId='music';// Not a reactive value anymorefunctionChatRoom(){useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>connection.disconnect();},[]);// ✅ All dependencies declared// ...}"
                },
                {
                    "type": "p",
                    "text": "An Effect with empty dependenciesdoesn’t re-run when any of your component’s props or state change."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "If you have an existing codebase, you might have some Effects that suppress the linter like this:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{// ...// 🔴 Avoid suppressing the linter like this:// eslint-ignore-next-line react-hooks/exhaustive-deps},[]);"
                },
                {
                    "type": "p",
                    "text": "When dependencies don’t match the code, there is a high risk of introducing bugs.By suppressing the linter, you “lie” to React about the values your Effect depends on.Instead, prove they’re unnecessary."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Examples of passing reactive dependencies"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of3:Passing a dependency array"
                },
                {
                    "type": "p",
                    "text": "If you specify the dependencies, your Effect runsafter the initial renderandafter re-renders with changed dependencies."
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{// ...},[a,b]);// Runs again if a or b are different"
                },
                {
                    "type": "p",
                    "text": "In the below example,serverUrlandroomIdarereactive values,so they both must be specified as dependencies. As a result, selecting a different room in the dropdown or editing the server URL input causes the chat to re-connect. However, sincemessageisn’t used in the Effect (and so it isn’t a dependency), editing the message doesn’t re-connect to the chat."
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection}from'./chat.js';functionChatRoom({roomId}){const[serverUrl,setServerUrl]=useState('https://localhost:1234');const[message,setMessage]=useState('');useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{connection.disconnect();};},[serverUrl,roomId]);return(<><label>Server URL:{' '}<inputvalue={serverUrl}onChange={e=>setServerUrl(e.target.value)}/></label><h1>Welcome to the{roomId}room!</h1><label>Your message:{' '}<inputvalue={message}onChange={e=>setMessage(e.target.value)}/></label></>);}exportdefaultfunctionApp(){const[show,setShow]=useState(false);const[roomId,setRoomId]=useState('general');return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select><buttononClick={()=>setShow(!show)}>{show?'Close chat':'Open chat'}</button></label>{show&&<hr/>}{show&&<ChatRoomroomId={roomId}/>}</>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Updating state based on previous state from an Effect"
                },
                {
                    "type": "p",
                    "text": "When you want to update state based on previous state from an Effect, you might run into a problem:"
                },
                {
                    "type": "code",
                    "code": "functionCounter(){const[count,setCount]=useState(0);useEffect(()=>{constintervalId=setInterval(()=>{setCount(count+1);// You want to increment the counter every second...},1000)return()=>clearInterval(intervalId);},[count]);// 🚩 ... but specifying `count` as a dependency always resets the interval.// ...}"
                },
                {
                    "type": "p",
                    "text": "Sincecountis a reactive value, it must be specified in the list of dependencies. However, that causes the Effect to cleanup and setup again every time thecountchanges. This is not ideal."
                },
                {
                    "type": "p",
                    "text": "To fix this,pass thec => c + 1state updatertosetCount:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';exportdefaultfunctionCounter(){const[count,setCount]=useState(0);useEffect(()=>{constintervalId=setInterval(()=>{setCount(c=>c+1);// ✅ Pass a state updater},1000);return()=>clearInterval(intervalId);},[]);// ✅ Now count is not a dependencyreturn<h1>{count}</h1>;}"
                },
                {
                    "type": "p",
                    "text": "Now that you’re passingc => c + 1instead ofcount + 1,your Effect no longer needs to depend oncount.As a result of this fix, it won’t need to cleanup and setup the interval again every time thecountchanges."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Removing unnecessary object dependencies"
                },
                {
                    "type": "p",
                    "text": "If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because theoptionsobject isdifferent for every render:"
                },
                {
                    "type": "code",
                    "code": "constserverUrl='https://localhost:1234';functionChatRoom({roomId}){const[message,setMessage]=useState('');constoptions={// 🚩 This object is created from scratch on every re-renderserverUrl:serverUrl,roomId:roomId};useEffect(()=>{constconnection=createConnection(options);// It's used inside the Effectconnection.connect();return()=>connection.disconnect();},[options]);// 🚩 As a result, these dependencies are always different on a re-render// ..."
                },
                {
                    "type": "p",
                    "text": "Avoid using an object created during rendering as a dependency. Instead, create the object inside the Effect:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection}from'./chat.js';constserverUrl='https://localhost:1234';functionChatRoom({roomId}){const[message,setMessage]=useState('');useEffect(()=>{constoptions={serverUrl:serverUrl,roomId:roomId};constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[roomId]);return(<><h1>Welcome to the{roomId}room!</h1><inputvalue={message}onChange={e=>setMessage(e.target.value)}/></>);}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><hr/><ChatRoomroomId={roomId}/></>);}"
                },
                {
                    "type": "p",
                    "text": "Now that you create theoptionsobject inside the Effect, the Effect itself only depends on theroomIdstring."
                },
                {
                    "type": "p",
                    "text": "With this fix, typing into the input doesn’t reconnect the chat. Unlike an object which gets re-created, a string likeroomIddoesn’t change unless you set it to another value.Read more about removing dependencies."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Removing unnecessary function dependencies"
                },
                {
                    "type": "p",
                    "text": "If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because thecreateOptionsfunction isdifferent for every render:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){const[message,setMessage]=useState('');functioncreateOptions(){// 🚩 This function is created from scratch on every re-renderreturn{serverUrl:serverUrl,roomId:roomId};}useEffect(()=>{constoptions=createOptions();// It's used inside the Effectconstconnection=createConnection();connection.connect();return()=>connection.disconnect();},[createOptions]);// 🚩 As a result, these dependencies are always different on a re-render// ..."
                },
                {
                    "type": "p",
                    "text": "By itself, creating a function from scratch on every re-render is not a problem. You don’t need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render."
                },
                {
                    "type": "p",
                    "text": "Avoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';import{createConnection}from'./chat.js';constserverUrl='https://localhost:1234';functionChatRoom({roomId}){const[message,setMessage]=useState('');useEffect(()=>{functioncreateOptions(){return{serverUrl:serverUrl,roomId:roomId};}constoptions=createOptions();constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[roomId]);return(<><h1>Welcome to the{roomId}room!</h1><inputvalue={message}onChange={e=>setMessage(e.target.value)}/></>);}exportdefaultfunctionApp(){const[roomId,setRoomId]=useState('general');return(<><label>Choose the chat room:{' '}<selectvalue={roomId}onChange={e=>setRoomId(e.target.value)}><optionvalue=\"general\">general</option><optionvalue=\"travel\">travel</option><optionvalue=\"music\">music</option></select></label><hr/><ChatRoomroomId={roomId}/></>);}"
                },
                {
                    "type": "p",
                    "text": "Now that you define thecreateOptionsfunction inside the Effect, the Effect itself only depends on theroomIdstring. With this fix, typing into the input doesn’t reconnect the chat. Unlike a function which gets re-created, a string likeroomIddoesn’t change unless you set it to another value.Read more about removing dependencies."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Reading the latest props and state from an Effect"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Under Construction"
                },
                {
                    "type": "p",
                    "text": "This section describes anexperimental API that has not yet been releasedin a stable version of React."
                },
                {
                    "type": "p",
                    "text": "By default, when you read a reactive value from an Effect, you have to add it as a dependency. This ensures that your Effect “reacts” to every change of that value. For most dependencies, that’s the behavior you want."
                },
                {
                    "type": "p",
                    "text": "However, sometimes you’ll want to read thelatestprops and state from an Effect without “reacting” to them.For example, imagine you want to log the number of the items in the shopping cart for every page visit:"
                },
                {
                    "type": "code",
                    "code": "functionPage({url,shoppingCart}){useEffect(()=>{logVisit(url,shoppingCart.length);},[url,shoppingCart]);// ✅ All dependencies declared// ...}"
                },
                {
                    "type": "p",
                    "text": "What if you want to log a new page visit after everyurlchange, butnotif only theshoppingCartchanges?You can’t excludeshoppingCartfrom dependencies without breaking thereactivity rules.However, you can express that youdon’t wanta piece of code to “react” to changes even though it is called from inside an Effect.Declare anEffect Eventwith theuseEffectEventHook, and move the code readingshoppingCartinside of it:"
                },
                {
                    "type": "code",
                    "code": "functionPage({url,shoppingCart}){constonVisit=useEffectEvent(visitedUrl=>{logVisit(visitedUrl,shoppingCart.length)});useEffect(()=>{onVisit(url);},[url]);// ✅ All dependencies declared// ...}"
                },
                {
                    "type": "p",
                    "text": "Effect Events are not reactive and must always be omitted from dependencies of your Effect.This is what lets you put non-reactive code (where you can read the latest value of some props and state) inside of them. By readingshoppingCartinside ofonVisit, you ensure thatshoppingCartwon’t re-run your Effect."
                },
                {
                    "type": "p",
                    "text": "Read more about how Effect Events let you separate reactive and non-reactive code."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Displaying different content on the server and the client"
                },
                {
                    "type": "p",
                    "text": "If your app uses server rendering (eitherdirectlyor via aframework), your component will render in two different environments. On the server, it will render to produce the initial HTML. On the client, React will run the rendering code again so that it can attach your event handlers to that HTML. This is why, forhydrationto work, your initial render output must be identical on the client and the server."
                },
                {
                    "type": "p",
                    "text": "In rare cases, you might need to display different content on the client. For example, if your app reads some data fromlocalStorage, it can’t possibly do that on the server. Here is how you could implement this:"
                },
                {
                    "type": "code",
                    "code": "functionMyComponent(){const[didMount,setDidMount]=useState(false);useEffect(()=>{setDidMount(true);},[]);if(didMount){// ... return client-only JSX ...}else{// ... return initial JSX ...}}"
                },
                {
                    "type": "p",
                    "text": "While the app is loading, the user will see the initial render output. Then, when it’s loaded and hydrated, your Effect will run and setdidMounttotrue, triggering a re-render. This will switch to the client-only render output. Effects don’t run on the server, so this is whydidMountwasfalseduring the initial server render."
                },
                {
                    "type": "p",
                    "text": "Use this pattern sparingly. Keep in mind that users with a slow connection will see the initial content for quite a bit of time—potentially, many seconds—so you don’t want to make jarring changes to your component’s appearance. In many cases, you can avoid the need for this by conditionally showing different things with CSS."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My Effect runs twice when the component mounts"
                },
                {
                    "type": "p",
                    "text": "When Strict Mode is on, in development, React runs setup and cleanup one extra time before the actual setup."
                },
                {
                    "type": "p",
                    "text": "This is a stress-test that verifies your Effect’s logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn’t be able to distinguish between the setup being called once (as in production) and a setup → cleanup → setup sequence (as in development)."
                },
                {
                    "type": "p",
                    "text": "Read more abouthow this helps find bugsandhow to fix your logic."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My Effect runs after every re-render"
                },
                {
                    "type": "p",
                    "text": "First, check that you haven’t forgotten to specify the dependency array:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{// ...});// 🚩 No dependency array: re-runs after every render!"
                },
                {
                    "type": "p",
                    "text": "If you’ve specified the dependency array but your Effect still re-runs in a loop, it’s because one of your dependencies is different on every re-render."
                },
                {
                    "type": "p",
                    "text": "You can debug this problem by manually logging your dependencies to the console:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{// ..},[serverUrl,roomId]);console.log([serverUrl,roomId]);"
                },
                {
                    "type": "p",
                    "text": "You can then right-click on the arrays from different re-renders in the console and select “Store as a global variable” for both of them. Assuming the first one got saved astemp1and the second one got saved astemp2, you can then use the browser console to check whether each dependency in both arrays is the same:"
                },
                {
                    "type": "code",
                    "code": "Object.is(temp1[0],temp2[0]);// Is the first dependency the same between the arrays?Object.is(temp1[1],temp2[1]);// Is the second dependency the same between the arrays?Object.is(temp1[2],temp2[2]);// ... and so on for every dependency ..."
                },
                {
                    "type": "p",
                    "text": "When you find the dependency that is different on every re-render, you can usually fix it in one of these ways:"
                },
                {
                    "type": "list",
                    "items": [
                        "Updating state based on previous state from an Effect",
                        "Removing unnecessary object dependencies",
                        "Removing unnecessary function dependencies",
                        "Reading the latest props and state from an Effect"
                    ]
                },
                {
                    "type": "p",
                    "text": "As a last resort (if these methods didn’t help), wrap its creation withuseMemooruseCallback(for functions)."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My Effect keeps re-running in an infinite cycle"
                },
                {
                    "type": "p",
                    "text": "If your Effect runs in an infinite cycle, these two things must be true:"
                },
                {
                    "type": "list",
                    "items": [
                        "Your Effect is updating some state.",
                        "That state leads to a re-render, which causes the Effect’s dependencies to change."
                    ]
                },
                {
                    "type": "p",
                    "text": "Before you start fixing the problem, ask yourself whether your Effect is connecting to some external system (like DOM, network, a third-party widget, and so on). Why does your Effect need to set state? Does it synchronize with that external system? Or are you trying to manage your application’s data flow with it?"
                },
                {
                    "type": "p",
                    "text": "If there is no external system, consider whetherremoving the Effect altogetherwould simplify your logic."
                },
                {
                    "type": "p",
                    "text": "If you’re genuinely synchronizing with some external system, think about why and under what conditions your Effect should update the state. Has something changed that affects your component’s visual output? If you need to keep track of some data that isn’t used by rendering, aref(which doesn’t trigger re-renders) might be more appropriate. Verify your Effect doesn’t update the state (and trigger re-renders) more than needed."
                },
                {
                    "type": "p",
                    "text": "Finally, if your Effect is updating the state at the right time, but there is still a loop, it’s because that state update leads to one of the Effect’s dependencies changing.Read how to debug dependency changes."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My cleanup logic runs even though my component didn’t unmount"
                },
                {
                    "type": "p",
                    "text": "The cleanup function runs not only during unmount, but before every re-render with changed dependencies. Additionally, in development, Reactruns setup+cleanup one extra time immediately after component mounts."
                },
                {
                    "type": "p",
                    "text": "If you have cleanup code without corresponding setup code, it’s usually a code smell:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{// 🔴 Avoid: Cleanup logic without corresponding setup logicreturn()=>{doSomething();};},[]);"
                },
                {
                    "type": "p",
                    "text": "Your cleanup logic should be “symmetrical” to the setup logic, and should stop or undo whatever setup did:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{constconnection=createConnection(serverUrl,roomId);connection.connect();return()=>{connection.disconnect();};},[serverUrl,roomId]);"
                },
                {
                    "type": "p",
                    "text": "Learn how the Effect lifecycle is different from the component’s lifecycle."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My Effect does something visual, and I see a flicker before it runs"
                },
                {
                    "type": "p",
                    "text": "If your Effect must block the browser frompainting the screen,replaceuseEffectwithuseLayoutEffect. Note thatthis shouldn’t be needed for the vast majority of Effects.You’ll only need this if it’s crucial to run your Effect before the browser paint: for example, to measure and position a tooltip before the user sees it."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/useId",
            "title": "useId – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "useId"
                },
                {
                    "type": "p",
                    "text": "useIdis a React Hook for generating unique IDs that can be passed to accessibility attributes."
                },
                {
                    "type": "code",
                    "code": "constid=useId()"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceuseId()",
                        "useId()",
                        "UsageGenerating unique IDs for accessibility attributesGenerating IDs for several related elementsSpecifying a shared prefix for all generated IDsUsing the same ID prefix on the client and the server",
                        "Generating unique IDs for accessibility attributes",
                        "Generating IDs for several related elements",
                        "Specifying a shared prefix for all generated IDs",
                        "Using the same ID prefix on the client and the server"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "useId()"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Generating unique IDs for accessibility attributes",
                        "Generating IDs for several related elements",
                        "Specifying a shared prefix for all generated IDs",
                        "Using the same ID prefix on the client and the server"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useId()"
                },
                {
                    "type": "p",
                    "text": "CalluseIdat the top level of your component to generate a unique ID:"
                },
                {
                    "type": "code",
                    "code": "import{useId}from'react';functionPasswordField(){constpasswordHintId=useId();// ..."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "p",
                    "text": "useIddoes not take any parameters."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "useIdreturns a unique ID string associated with this particularuseIdcall in this particular component."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "useIdis a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.",
                        "useIdshould not be used to generate keysin a list.Keys should be generated from your data."
                    ]
                },
                {
                    "type": "p",
                    "text": "useIdis a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it."
                },
                {
                    "type": "p",
                    "text": "useIdshould not be used to generate keysin a list.Keys should be generated from your data."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Do not calluseIdto generate keys in a list.Keys should be generated from your data."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Generating unique IDs for accessibility attributes"
                },
                {
                    "type": "p",
                    "text": "CalluseIdat the top level of your component to generate a unique ID:"
                },
                {
                    "type": "code",
                    "code": "import{useId}from'react';functionPasswordField(){constpasswordHintId=useId();// ..."
                },
                {
                    "type": "p",
                    "text": "You can then pass thegenerated IDto different attributes:"
                },
                {
                    "type": "code",
                    "code": "<><inputtype=\"password\"aria-describedby={passwordHintId}/><pid={passwordHintId}></>"
                },
                {
                    "type": "p",
                    "text": "Let’s walk through an example to see when this is useful."
                },
                {
                    "type": "p",
                    "text": "HTML accessibility attributeslikearia-describedbylet you specify that two tags are related to each other. For example, you can specify that an element (like an input) is described by another element (like a paragraph)."
                },
                {
                    "type": "p",
                    "text": "In regular HTML, you would write it like this:"
                },
                {
                    "type": "code",
                    "code": "<label>Password:<inputtype=\"password\"aria-describedby=\"password-hint\"/></label><pid=\"password-hint\">The password should contain at least 18 characters</p>"
                },
                {
                    "type": "p",
                    "text": "However, hardcoding IDs like this is not a good practice in React. A component may be rendered more than once on the page—but IDs have to be unique! Instead of hardcoding an ID, generate a unique ID withuseId:"
                },
                {
                    "type": "code",
                    "code": "import{useId}from'react';functionPasswordField(){constpasswordHintId=useId();return(<><label>Password:<inputtype=\"password\"aria-describedby={passwordHintId}/></label><pid={passwordHintId}>The password should contain at least 18 characters</p></>);}"
                },
                {
                    "type": "p",
                    "text": "Now, even ifPasswordFieldappears multiple times on the screen, the generated IDs won’t clash."
                },
                {
                    "type": "code",
                    "code": "import{useId}from'react';functionPasswordField(){constpasswordHintId=useId();return(<><label>Password:<inputtype=\"password\"aria-describedby={passwordHintId}/></label><pid={passwordHintId}>The password should contain at least 18 characters</p></>);}exportdefaultfunctionApp(){return(<><h2>Choose password</h2><PasswordField/><h2>Confirm password</h2><PasswordField/></>);}"
                },
                {
                    "type": "p",
                    "text": "Watch this videoto see the difference in the user experience with assistive technologies."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Withserver rendering,useIdrequires an identical component tree on the server and the client. If the trees you render on the server and the client don’t match exactly, the generated IDs won’t match."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Why is useId better than an incrementing counter?"
                },
                {
                    "type": "p",
                    "text": "You might be wondering whyuseIdis better than incrementing a global variable likenextId++."
                },
                {
                    "type": "p",
                    "text": "The primary benefit ofuseIdis that React ensures that it works withserver rendering.During server rendering, your components generate HTML output. Later, on the client,hydrationattaches your event handlers to the generated HTML. For hydration to work, the client output must match the server HTML."
                },
                {
                    "type": "p",
                    "text": "This is very difficult to guarantee with an incrementing counter because the order in which the Client Components are hydrated may not match the order in which the server HTML was emitted. By callinguseId, you ensure that hydration will work, and the output will match between the server and the client."
                },
                {
                    "type": "p",
                    "text": "Inside React,useIdis generated from the “parent path” of the calling component. This is why, if the client and the server tree are the same, the “parent path” will match up regardless of rendering order."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Generating IDs for several related elements"
                },
                {
                    "type": "p",
                    "text": "If you need to give IDs to multiple related elements, you can calluseIdto generate a shared prefix for them:"
                },
                {
                    "type": "code",
                    "code": "import{useId}from'react';exportdefaultfunctionForm(){constid=useId();return(<form><labelhtmlFor={id+'-firstName'}>First Name:</label><inputid={id+'-firstName'}type=\"text\"/><hr/><labelhtmlFor={id+'-lastName'}>Last Name:</label><inputid={id+'-lastName'}type=\"text\"/></form>);}"
                },
                {
                    "type": "p",
                    "text": "This lets you avoid callinguseIdfor every single element that needs a unique ID."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Specifying a shared prefix for all generated IDs"
                },
                {
                    "type": "p",
                    "text": "If you render multiple independent React applications on a single page, passidentifierPrefixas an option to yourcreateRootorhydrateRootcalls. This ensures that the IDs generated by the two different apps never clash because every identifier generated withuseIdwill start with the distinct prefix you’ve specified."
                },
                {
                    "type": "code",
                    "code": "import{createRoot}from'react-dom/client';importAppfrom'./App.js';import'./styles.css';constroot1=createRoot(document.getElementById('root1'),{identifierPrefix:'my-first-app-'});root1.render(<App/>);constroot2=createRoot(document.getElementById('root2'),{identifierPrefix:'my-second-app-'});root2.render(<App/>);"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Using the same ID prefix on the client and the server"
                },
                {
                    "type": "p",
                    "text": "If yourender multiple independent React apps on the same page, and some of these apps are server-rendered, make sure that theidentifierPrefixyou pass to thehydrateRootcall on the client side is the same as theidentifierPrefixyou pass to theserver APIssuch asrenderToPipeableStream."
                },
                {
                    "type": "code",
                    "code": "// Serverimport{renderToPipeableStream}from'react-dom/server';const{pipe}=renderToPipeableStream(<App/>,{identifierPrefix:'react-app1'});"
                },
                {
                    "type": "code",
                    "code": "// Clientimport{hydrateRoot}from'react-dom/client';constdomNode=document.getElementById('root');constroot=hydrateRoot(domNode,reactNode,{identifierPrefix:'react-app1'});"
                },
                {
                    "type": "p",
                    "text": "You do not need to passidentifierPrefixif you only have one React app on the page."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/useImperativeHandle",
            "title": "useImperativeHandle – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "useImperativeHandle"
                },
                {
                    "type": "p",
                    "text": "useImperativeHandleis a React Hook that lets you customize the handle exposed as aref."
                },
                {
                    "type": "code",
                    "code": "useImperativeHandle(ref,createHandle,dependencies?)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceuseImperativeHandle(ref, createHandle, dependencies?)",
                        "useImperativeHandle(ref, createHandle, dependencies?)",
                        "UsageExposing a custom ref handle to the parent componentExposing your own imperative methods",
                        "Exposing a custom ref handle to the parent component",
                        "Exposing your own imperative methods"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "useImperativeHandle(ref, createHandle, dependencies?)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Exposing a custom ref handle to the parent component",
                        "Exposing your own imperative methods"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useImperativeHandle(ref, createHandle, dependencies?)"
                },
                {
                    "type": "p",
                    "text": "CalluseImperativeHandleat the top level of your component to customize the ref handle it exposes:"
                },
                {
                    "type": "code",
                    "code": "import{forwardRef,useImperativeHandle}from'react';constMyInput=forwardRef(functionMyInput(props,ref){useImperativeHandle(ref,()=>{return{// ... your methods ...};},[]);// ..."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "ref: Therefyou received as the second argument from theforwardRefrender function.",
                        "createHandle: A function that takes no arguments and returns the ref handle you want to expose. That ref handle can have any type. Usually, you will return an object with the methods you want to expose.",
                        "optionaldependencies: The list of all reactive values referenced inside of thecreateHandlecode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison. If a re-render resulted in a change to some dependency, or if you omitted this argument, yourcreateHandlefunction will re-execute, and the newly created handle will be assigned to the ref."
                    ]
                },
                {
                    "type": "p",
                    "text": "ref: Therefyou received as the second argument from theforwardRefrender function."
                },
                {
                    "type": "p",
                    "text": "createHandle: A function that takes no arguments and returns the ref handle you want to expose. That ref handle can have any type. Usually, you will return an object with the methods you want to expose."
                },
                {
                    "type": "p",
                    "text": "optionaldependencies: The list of all reactive values referenced inside of thecreateHandlecode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison. If a re-render resulted in a change to some dependency, or if you omitted this argument, yourcreateHandlefunction will re-execute, and the newly created handle will be assigned to the ref."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "useImperativeHandlereturnsundefined."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Exposing a custom ref handle to the parent component"
                },
                {
                    "type": "p",
                    "text": "By default, components don’t expose their DOM nodes to parent components. For example, if you want the parent component ofMyInputtohave accessto the<input>DOM node, you have to opt in withforwardRef:"
                },
                {
                    "type": "code",
                    "code": "import{forwardRef}from'react';constMyInput=forwardRef(functionMyInput(props,ref){return<input{...props}ref={ref}/>;});"
                },
                {
                    "type": "p",
                    "text": "With the code above,a ref toMyInputwill receive the<input>DOM node.However, you can expose a custom value instead. To customize the exposed handle, calluseImperativeHandleat the top level of your component:"
                },
                {
                    "type": "code",
                    "code": "import{forwardRef,useImperativeHandle}from'react';constMyInput=forwardRef(functionMyInput(props,ref){useImperativeHandle(ref,()=>{return{// ... your methods ...};},[]);return<input{...props}/>;});"
                },
                {
                    "type": "p",
                    "text": "Note that in the code above, therefis no longer forwarded to the<input>."
                },
                {
                    "type": "p",
                    "text": "For example, suppose you don’t want to expose the entire<input>DOM node, but you want to expose two of its methods:focusandscrollIntoView. To do this, keep the real browser DOM in a separate ref. Then useuseImperativeHandleto expose a handle with only the methods that you want the parent component to call:"
                },
                {
                    "type": "code",
                    "code": "import{forwardRef,useRef,useImperativeHandle}from'react';constMyInput=forwardRef(functionMyInput(props,ref){constinputRef=useRef(null);useImperativeHandle(ref,()=>{return{focus(){inputRef.current.focus();},scrollIntoView(){inputRef.current.scrollIntoView();},};},[]);return<input{...props}ref={inputRef}/>;});"
                },
                {
                    "type": "p",
                    "text": "Now, if the parent component gets a ref toMyInput, it will be able to call thefocusandscrollIntoViewmethods on it. However, it will not have full access to the underlying<input>DOM node."
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';importMyInputfrom'./MyInput.js';exportdefaultfunctionForm(){constref=useRef(null);functionhandleClick(){ref.current.focus();// This won't work because the DOM node isn't exposed:// ref.current.style.opacity = 0.5;}return(<form><MyInputplaceholder=\"Enter your name\"ref={ref}/><buttontype=\"button\"onClick={handleClick}>Edit</button></form>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Exposing your own imperative methods"
                },
                {
                    "type": "p",
                    "text": "The methods you expose via an imperative handle don’t have to match the DOM methods exactly. For example, thisPostcomponent exposes ascrollAndFocusAddCommentmethod via an imperative handle. This lets the parentPagescroll the list of commentsandfocus the input field when you click the button:"
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';importPostfrom'./Post.js';exportdefaultfunctionPage(){constpostRef=useRef(null);functionhandleClick(){postRef.current.scrollAndFocusAddComment();}return(<><buttononClick={handleClick}>Write a comment</button><Postref={postRef}/></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Do not overuse refs.You should only use refs forimperativebehaviors that you can’t express as props: for example, scrolling to a node, focusing a node, triggering an animation, selecting text, and so on."
                },
                {
                    "type": "p",
                    "text": "If you can express something as a prop, you should not use a ref.For example, instead of exposing an imperative handle like{ open, close }from aModalcomponent, it is better to takeisOpenas a prop like<Modal isOpen={isOpen} />.Effectscan help you expose imperative behaviors via props."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/useInsertionEffect",
            "title": "useInsertionEffect – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "useInsertionEffect"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "useInsertionEffectis for CSS-in-JS library authors. Unless you are working on a CSS-in-JS library and need a place to inject the styles, you probably wantuseEffectoruseLayoutEffectinstead."
                },
                {
                    "type": "p",
                    "text": "useInsertionEffectallows inserting elements into the DOM before any layout Effects fire."
                },
                {
                    "type": "code",
                    "code": "useInsertionEffect(setup,dependencies?)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceuseInsertionEffect(setup, dependencies?)",
                        "useInsertionEffect(setup, dependencies?)",
                        "UsageInjecting dynamic styles from CSS-in-JS libraries",
                        "Injecting dynamic styles from CSS-in-JS libraries"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "useInsertionEffect(setup, dependencies?)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Injecting dynamic styles from CSS-in-JS libraries"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useInsertionEffect(setup, dependencies?)"
                },
                {
                    "type": "p",
                    "text": "CalluseInsertionEffectto insert styles before any Effects fire that may need to read layout:"
                },
                {
                    "type": "code",
                    "code": "import{useInsertionEffect}from'react';// Inside your CSS-in-JS libraryfunctionuseCSS(rule){useInsertionEffect(()=>{// ... inject <style> tags here ...});returnrule;}"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "setup: The function with your Effect’s logic. Your setup function may also optionally return acleanupfunction. When your component is added to the DOM, but before any layout Effects fire, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. When your component is removed from the DOM, React will run your cleanup function.",
                        "optionaldependencies: The list of all reactive values referenced inside of thesetupcode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison algorithm. If you don’t specify the dependencies at all, your Effect will re-run after every re-render of the component."
                    ]
                },
                {
                    "type": "p",
                    "text": "setup: The function with your Effect’s logic. Your setup function may also optionally return acleanupfunction. When your component is added to the DOM, but before any layout Effects fire, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. When your component is removed from the DOM, React will run your cleanup function."
                },
                {
                    "type": "p",
                    "text": "optionaldependencies: The list of all reactive values referenced inside of thesetupcode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison algorithm. If you don’t specify the dependencies at all, your Effect will re-run after every re-render of the component."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "useInsertionEffectreturnsundefined."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Effects only run on the client. They don’t run during server rendering.",
                        "You can’t update state from insideuseInsertionEffect.",
                        "By the timeuseInsertionEffectruns, refs are not attached yet.",
                        "useInsertionEffectmay run either before or after the DOM has been updated. You shouldn’t rely on the DOM being updated at any particular time.",
                        "Unlike other types of Effects, which fire cleanup for every Effect and then setup for every Effect,useInsertionEffectwill fire both cleanup and setup one component at a time. This results in an “interleaving” of the cleanup and setup functions."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Injecting dynamic styles from CSS-in-JS libraries"
                },
                {
                    "type": "p",
                    "text": "Traditionally, you would style React components using plain CSS."
                },
                {
                    "type": "code",
                    "code": "// In your JS file:<buttonclassName=\"success\"/>// In your CSS file:.success{color:green;}"
                },
                {
                    "type": "p",
                    "text": "Some teams prefer to author styles directly in JavaScript code instead of writing CSS files. This usually requires using a CSS-in-JS library or a tool. There are three common approaches to CSS-in-JS:"
                },
                {
                    "type": "list",
                    "items": [
                        "Static extraction to CSS files with a compiler",
                        "Inline styles, e.g.<div style={{ opacity: 1 }}>",
                        "Runtime injection of<style>tags"
                    ]
                },
                {
                    "type": "p",
                    "text": "If you use CSS-in-JS, we recommend a combination of the first two approaches (CSS files for static styles, inline styles for dynamic styles).We don’t recommend runtime<style>tag injection for two reasons:"
                },
                {
                    "type": "list",
                    "items": [
                        "Runtime injection forces the browser to recalculate the styles a lot more often.",
                        "Runtime injection can be very slow if it happens at the wrong time in the React lifecycle."
                    ]
                },
                {
                    "type": "p",
                    "text": "The first problem is not solvable, butuseInsertionEffecthelps you solve the second problem."
                },
                {
                    "type": "p",
                    "text": "CalluseInsertionEffectto insert the styles before any layout Effects fire:"
                },
                {
                    "type": "code",
                    "code": "// Inside your CSS-in-JS libraryletisInserted=newSet();functionuseCSS(rule){useInsertionEffect(()=>{// As explained earlier, we don't recommend runtime injection of <style> tags.// But if you have to do it, then it's important to do in useInsertionEffect.if(!isInserted.has(rule)){isInserted.add(rule);document.head.appendChild(getStyleForRule(rule));}});returnrule;}functionButton(){constclassName=useCSS('...');return<divclassName={className}/>;}"
                },
                {
                    "type": "p",
                    "text": "Similarly touseEffect,useInsertionEffectdoes not run on the server. If you need to collect which CSS rules have been used on the server, you can do it during rendering:"
                },
                {
                    "type": "code",
                    "code": "letcollectedRulesSet=newSet();functionuseCSS(rule){if(typeofwindow==='undefined'){collectedRulesSet.add(rule);}useInsertionEffect(()=>{// ...});returnrule;}"
                },
                {
                    "type": "p",
                    "text": "Read more about upgrading CSS-in-JS libraries with runtime injection touseInsertionEffect."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "How is this better than injecting styles during rendering or useLayoutEffect?"
                },
                {
                    "type": "p",
                    "text": "If you insert styles during rendering and React is processing anon-blocking update,the browser will recalculate the styles every single frame while rendering a component tree, which can beextremely slow."
                },
                {
                    "type": "p",
                    "text": "useInsertionEffectis better than inserting styles duringuseLayoutEffectoruseEffectbecause it ensures that by the time other Effects run in your components, the<style>tags have already been inserted. Otherwise, layout calculations in regular Effects would be wrong due to outdated styles."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/useLayoutEffect",
            "title": "useLayoutEffect – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "useLayoutEffect"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "useLayoutEffectcan hurt performance. PreferuseEffectwhen possible."
                },
                {
                    "type": "p",
                    "text": "useLayoutEffectis a version ofuseEffectthat fires before the browser repaints the screen."
                },
                {
                    "type": "code",
                    "code": "useLayoutEffect(setup,dependencies?)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceuseLayoutEffect(setup, dependencies?)",
                        "useLayoutEffect(setup, dependencies?)",
                        "UsageMeasuring layout before the browser repaints the screen",
                        "Measuring layout before the browser repaints the screen",
                        "TroubleshootingI’m getting an error: “useLayoutEffectdoes nothing on the server”",
                        "I’m getting an error: “useLayoutEffectdoes nothing on the server”"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "useLayoutEffect(setup, dependencies?)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Measuring layout before the browser repaints the screen"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "I’m getting an error: “useLayoutEffectdoes nothing on the server”"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useLayoutEffect(setup, dependencies?)"
                },
                {
                    "type": "p",
                    "text": "CalluseLayoutEffectto perform the layout measurements before the browser repaints the screen:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useRef,useLayoutEffect}from'react';functionTooltip(){constref=useRef(null);const[tooltipHeight,setTooltipHeight]=useState(0);useLayoutEffect(()=>{const{height}=ref.current.getBoundingClientRect();setTooltipHeight(height);},[]);// ..."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "setup: The function with your Effect’s logic. Your setup function may also optionally return acleanupfunction. Before your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. Before your component is removed from the DOM, React will run your cleanup function.",
                        "optionaldependencies: The list of all reactive values referenced inside of thesetupcode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison. If you omit this argument, your Effect will re-run after every re-render of the component."
                    ]
                },
                {
                    "type": "p",
                    "text": "setup: The function with your Effect’s logic. Your setup function may also optionally return acleanupfunction. Before your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. Before your component is removed from the DOM, React will run your cleanup function."
                },
                {
                    "type": "p",
                    "text": "optionaldependencies: The list of all reactive values referenced inside of thesetupcode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison. If you omit this argument, your Effect will re-run after every re-render of the component."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "useLayoutEffectreturnsundefined."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "useLayoutEffectis a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a component and move the Effect there.",
                        "When Strict Mode is on, React willrun one extra development-only setup+cleanup cyclebefore the first real setup. This is a stress-test that ensures that your cleanup logic “mirrors” your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem,implement the cleanup function.",
                        "If some of your dependencies are objects or functions defined inside the component, there is a risk that they willcause the Effect to re-run more often than needed.To fix this, remove unnecessaryobjectandfunctiondependencies. You can alsoextract state updatesandnon-reactive logicoutside of your Effect.",
                        "Effectsonly run on the client.They don’t run during server rendering.",
                        "The code insideuseLayoutEffectand all state updates scheduled from itblock the browser from repainting the screen.When used excessively, this makes your app slow. When possible, preferuseEffect.",
                        "If you trigger a state update insideuseLayoutEffect, React will execute all remaining Effects immediately includinguseEffect."
                    ]
                },
                {
                    "type": "p",
                    "text": "useLayoutEffectis a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a component and move the Effect there."
                },
                {
                    "type": "p",
                    "text": "When Strict Mode is on, React willrun one extra development-only setup+cleanup cyclebefore the first real setup. This is a stress-test that ensures that your cleanup logic “mirrors” your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem,implement the cleanup function."
                },
                {
                    "type": "p",
                    "text": "If some of your dependencies are objects or functions defined inside the component, there is a risk that they willcause the Effect to re-run more often than needed.To fix this, remove unnecessaryobjectandfunctiondependencies. You can alsoextract state updatesandnon-reactive logicoutside of your Effect."
                },
                {
                    "type": "p",
                    "text": "Effectsonly run on the client.They don’t run during server rendering."
                },
                {
                    "type": "p",
                    "text": "The code insideuseLayoutEffectand all state updates scheduled from itblock the browser from repainting the screen.When used excessively, this makes your app slow. When possible, preferuseEffect."
                },
                {
                    "type": "p",
                    "text": "If you trigger a state update insideuseLayoutEffect, React will execute all remaining Effects immediately includinguseEffect."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Measuring layout before the browser repaints the screen"
                },
                {
                    "type": "p",
                    "text": "Most components don’t need to know their position and size on the screen to decide what to render. They only return some JSX. Then the browser calculates theirlayout(position and size) and repaints the screen."
                },
                {
                    "type": "p",
                    "text": "Sometimes, that’s not enough. Imagine a tooltip that appears next to some element on hover. If there’s enough space, the tooltip should appear above the element, but if it doesn’t fit, it should appear below. In order to render the tooltip at the right final position, you need to know its height (i.e. whether it fits at the top)."
                },
                {
                    "type": "p",
                    "text": "To do this, you need to render in two passes:"
                },
                {
                    "type": "list",
                    "items": [
                        "Render the tooltip anywhere (even with a wrong position).",
                        "Measure its height and decide where to place the tooltip.",
                        "Render the tooltipagainin the correct place."
                    ]
                },
                {
                    "type": "p",
                    "text": "All of this needs to happen before the browser repaints the screen.You don’t want the user to see the tooltip moving. CalluseLayoutEffectto perform the layout measurements before the browser repaints the screen:"
                },
                {
                    "type": "code",
                    "code": "functionTooltip(){constref=useRef(null);const[tooltipHeight,setTooltipHeight]=useState(0);// You don't know real height yetuseLayoutEffect(()=>{const{height}=ref.current.getBoundingClientRect();setTooltipHeight(height);// Re-render now that you know the real height},[]);// ...use tooltipHeight in the rendering logic below...}"
                },
                {
                    "type": "p",
                    "text": "Here’s how this works step by step:"
                },
                {
                    "type": "list",
                    "items": [
                        "Tooltiprenders with the initialtooltipHeight = 0(so the tooltip may be wrongly positioned).",
                        "React places it in the DOM and runs the code inuseLayoutEffect.",
                        "YouruseLayoutEffectmeasures the heightof the tooltip content and triggers an immediate re-render.",
                        "Tooltiprenders again with the realtooltipHeight(so the tooltip is correctly positioned).",
                        "React updates it in the DOM, and the browser finally displays the tooltip."
                    ]
                },
                {
                    "type": "p",
                    "text": "Hover over the buttons below and see how the tooltip adjusts its position depending on whether it fits:"
                },
                {
                    "type": "code",
                    "code": "import{useRef,useLayoutEffect,useState}from'react';import{createPortal}from'react-dom';importTooltipContainerfrom'./TooltipContainer.js';exportdefaultfunctionTooltip({children,targetRect}){constref=useRef(null);const[tooltipHeight,setTooltipHeight]=useState(0);useLayoutEffect(()=>{const{height}=ref.current.getBoundingClientRect();setTooltipHeight(height);console.log('Measured tooltip height: '+height);},[]);lettooltipX=0;lettooltipY=0;if(targetRect!==null){tooltipX=targetRect.left;tooltipY=targetRect.top-tooltipHeight;if(tooltipY<0){// It doesn't fit above, so place below.tooltipY=targetRect.bottom;}}returncreatePortal(<TooltipContainerx={tooltipX}y={tooltipY}contentRef={ref}>{children}</TooltipContainer>,document.body);}"
                },
                {
                    "type": "p",
                    "text": "Notice that even though theTooltipcomponent has to render in two passes (first, withtooltipHeightinitialized to0and then with the real measured height), you only see the final result. This is why you needuseLayoutEffectinstead ofuseEffectfor this example. Let’s look at the difference in detail below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "useLayoutEffect vs useEffect"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of2:useLayoutEffectblocks the browser from repainting"
                },
                {
                    "type": "p",
                    "text": "React guarantees that the code insideuseLayoutEffectand any state updates scheduled inside it will be processedbefore the browser repaints the screen.This lets you render the tooltip, measure it, and re-render the tooltip again without the user noticing the first extra render. In other words,useLayoutEffectblocks the browser from painting."
                },
                {
                    "type": "code",
                    "code": "import{useRef,useLayoutEffect,useState}from'react';import{createPortal}from'react-dom';importTooltipContainerfrom'./TooltipContainer.js';exportdefaultfunctionTooltip({children,targetRect}){constref=useRef(null);const[tooltipHeight,setTooltipHeight]=useState(0);useLayoutEffect(()=>{const{height}=ref.current.getBoundingClientRect();setTooltipHeight(height);},[]);lettooltipX=0;lettooltipY=0;if(targetRect!==null){tooltipX=targetRect.left;tooltipY=targetRect.top-tooltipHeight;if(tooltipY<0){// It doesn't fit above, so place below.tooltipY=targetRect.bottom;}}returncreatePortal(<TooltipContainerx={tooltipX}y={tooltipY}contentRef={ref}>{children}</TooltipContainer>,document.body);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Rendering in two passes and blocking the browser hurts performance. Try to avoid this when you can."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’m getting an error: “useLayoutEffectdoes nothing on the server”"
                },
                {
                    "type": "p",
                    "text": "The purpose ofuseLayoutEffectis to let your componentuse layout information for rendering:"
                },
                {
                    "type": "list",
                    "items": [
                        "Render the initial content.",
                        "Measure the layoutbefore the browser repaints the screen.",
                        "Render the final content using the layout information you’ve read."
                    ]
                },
                {
                    "type": "p",
                    "text": "When you or your framework usesserver rendering, your React app renders to HTML on the server for the initial render. This lets you show the initial HTML before the JavaScript code loads."
                },
                {
                    "type": "p",
                    "text": "The problem is that on the server, there is no layout information."
                },
                {
                    "type": "p",
                    "text": "In theearlier example, theuseLayoutEffectcall in theTooltipcomponent lets it position itself correctly (either above or below content) depending on the content height. If you tried to renderTooltipas a part of the initial server HTML, this would be impossible to determine. On the server, there is no layout yet! So, even if you rendered it on the server, its position would “jump” on the client after the JavaScript loads and runs."
                },
                {
                    "type": "p",
                    "text": "Usually, components that rely on layout information don’t need to render on the server anyway. For example, it probably doesn’t make sense to show aTooltipduring the initial render. It is triggered by a client interaction."
                },
                {
                    "type": "p",
                    "text": "However, if you’re running into this problem, you have a few different options:"
                },
                {
                    "type": "list",
                    "items": [
                        "ReplaceuseLayoutEffectwithuseEffect.This tells React that it’s okay to display the initial render result without blocking the paint (because the original HTML will become visible before your Effect runs).",
                        "Alternatively,mark your component as client-only.This tells React to replace its content up to the closest<Suspense>boundary with a loading fallback (for example, a spinner or a glimmer) during server rendering.",
                        "Alternatively, you can render a component withuseLayoutEffectonly after hydration. Keep a booleanisMountedstate that’s initialized tofalse, and set it totrueinside auseEffectcall. Your rendering logic can then be likereturn isMounted ? <RealContent /> : <FallbackContent />. On the server and during the hydration, the user will seeFallbackContentwhich should not calluseLayoutEffect. Then React will replace it withRealContentwhich runs on the client only and can includeuseLayoutEffectcalls.",
                        "If you synchronize your component with an external data store and rely onuseLayoutEffectfor different reasons than measuring layout, consideruseSyncExternalStoreinstead whichsupports server rendering."
                    ]
                },
                {
                    "type": "p",
                    "text": "ReplaceuseLayoutEffectwithuseEffect.This tells React that it’s okay to display the initial render result without blocking the paint (because the original HTML will become visible before your Effect runs)."
                },
                {
                    "type": "p",
                    "text": "Alternatively,mark your component as client-only.This tells React to replace its content up to the closest<Suspense>boundary with a loading fallback (for example, a spinner or a glimmer) during server rendering."
                },
                {
                    "type": "p",
                    "text": "Alternatively, you can render a component withuseLayoutEffectonly after hydration. Keep a booleanisMountedstate that’s initialized tofalse, and set it totrueinside auseEffectcall. Your rendering logic can then be likereturn isMounted ? <RealContent /> : <FallbackContent />. On the server and during the hydration, the user will seeFallbackContentwhich should not calluseLayoutEffect. Then React will replace it withRealContentwhich runs on the client only and can includeuseLayoutEffectcalls."
                },
                {
                    "type": "p",
                    "text": "If you synchronize your component with an external data store and rely onuseLayoutEffectfor different reasons than measuring layout, consideruseSyncExternalStoreinstead whichsupports server rendering."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/useMemo",
            "title": "useMemo – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "useMemo"
                },
                {
                    "type": "p",
                    "text": "useMemois a React Hook that lets you cache the result of a calculation between re-renders."
                },
                {
                    "type": "code",
                    "code": "constcachedValue=useMemo(calculateValue,dependencies)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceuseMemo(calculateValue, dependencies)",
                        "useMemo(calculateValue, dependencies)",
                        "UsageSkipping expensive recalculationsSkipping re-rendering of componentsPreventing an Effect from firing too oftenMemoizing a dependency of another HookMemoizing a function",
                        "Skipping expensive recalculations",
                        "Skipping re-rendering of components",
                        "Preventing an Effect from firing too often",
                        "Memoizing a dependency of another Hook",
                        "Memoizing a function",
                        "TroubleshootingMy calculation runs twice on every re-renderMyuseMemocall is supposed to return an object, but returns undefinedEvery time my component renders, the calculation inuseMemore-runsI need to calluseMemofor each list item in a loop, but it’s not allowed",
                        "My calculation runs twice on every re-render",
                        "MyuseMemocall is supposed to return an object, but returns undefined",
                        "Every time my component renders, the calculation inuseMemore-runs",
                        "I need to calluseMemofor each list item in a loop, but it’s not allowed"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "useMemo(calculateValue, dependencies)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Skipping expensive recalculations",
                        "Skipping re-rendering of components",
                        "Preventing an Effect from firing too often",
                        "Memoizing a dependency of another Hook",
                        "Memoizing a function"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "My calculation runs twice on every re-render",
                        "MyuseMemocall is supposed to return an object, but returns undefined",
                        "Every time my component renders, the calculation inuseMemore-runs",
                        "I need to calluseMemofor each list item in a loop, but it’s not allowed"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useMemo(calculateValue, dependencies)"
                },
                {
                    "type": "p",
                    "text": "CalluseMemoat the top level of your component to cache a calculation between re-renders:"
                },
                {
                    "type": "code",
                    "code": "import{useMemo}from'react';functionTodoList({todos,tab}){constvisibleTodos=useMemo(()=>filterTodos(todos,tab),[todos,tab]);// ...}"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if thedependencieshave not changed since the last render. Otherwise, it will callcalculateValue, return its result, and store it so it can be reused later.",
                        "dependencies: The list of all reactive values referenced inside of thecalculateValuecode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison."
                    ]
                },
                {
                    "type": "p",
                    "text": "calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if thedependencieshave not changed since the last render. Otherwise, it will callcalculateValue, return its result, and store it so it can be reused later."
                },
                {
                    "type": "p",
                    "text": "dependencies: The list of all reactive values referenced inside of thecalculateValuecode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "On the initial render,useMemoreturns the result of callingcalculateValuewith no arguments."
                },
                {
                    "type": "p",
                    "text": "During next renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or callcalculateValueagain, and return the result thatcalculateValuehas returned."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "useMemois a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.",
                        "In Strict Mode, React willcall your calculation function twicein order tohelp you find accidental impurities.This is development-only behavior and does not affect production. If your calculation function is pure (as it should be), this should not affect your logic. The result from one of the calls will be ignored.",
                        "Reactwill not throw away the cached value unless there is a specific reason to do that.For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache—for example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should be fine if you rely onuseMemosolely as a performance optimization. Otherwise, astate variableor arefmay be more appropriate."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Caching return values like this is also known asmemoization,which is why this Hook is calleduseMemo."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Skipping expensive recalculations"
                },
                {
                    "type": "p",
                    "text": "To cache a calculation between re-renders, wrap it in auseMemocall at the top level of your component:"
                },
                {
                    "type": "code",
                    "code": "import{useMemo}from'react';functionTodoList({todos,tab,theme}){constvisibleTodos=useMemo(() => filterTodos(todos, tab),[todos, tab]);// ...}"
                },
                {
                    "type": "p",
                    "text": "You need to pass two things touseMemo:"
                },
                {
                    "type": "list",
                    "items": [
                        "Acalculation functionthat takes no arguments, like() =>, and returns what you wanted to calculate.",
                        "Alist of dependenciesincluding every value within your component that’s used inside your calculation."
                    ]
                },
                {
                    "type": "p",
                    "text": "On the initial render, thevalueyou’ll get fromuseMemowill be the result of calling yourcalculation."
                },
                {
                    "type": "p",
                    "text": "On every subsequent render, React will compare thedependencieswith the dependencies you passed during the last render. If none of the dependencies have changed (compared withObject.is),useMemowill return the value you already calculated before. Otherwise, React will re-run your calculation and return the new value."
                },
                {
                    "type": "p",
                    "text": "In other words,useMemocaches a calculation result between re-renders until its dependencies change."
                },
                {
                    "type": "p",
                    "text": "Let’s walk through an example to see when this is useful."
                },
                {
                    "type": "p",
                    "text": "By default, React will re-run the entire body of your component every time that it re-renders. For example, if thisTodoListupdates its state or receives new props from its parent, thefilterTodosfunction will re-run:"
                },
                {
                    "type": "code",
                    "code": "functionTodoList({todos,tab,theme}){constvisibleTodos=filterTodos(todos,tab);// ...}"
                },
                {
                    "type": "p",
                    "text": "Usually, this isn’t a problem because most calculations are very fast. However, if you’re filtering or transforming a large array, or doing some expensive computation, you might want to skip doing it again if data hasn’t changed. If bothtodosandtabare the same as they were during the last render, wrapping the calculation inuseMemolike earlier lets you reusevisibleTodosyou’ve already calculated before."
                },
                {
                    "type": "p",
                    "text": "This type of caching is calledmemoization."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "You should only rely onuseMemoas a performance optimization.If your code doesn’t work without it, find the underlying problem and fix it first. Then you may adduseMemoto improve performance."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "How to tell if a calculation is expensive?"
                },
                {
                    "type": "p",
                    "text": "In general, unless you’re creating or looping over thousands of objects, it’s probably not expensive. If you want to get more confidence, you can add a console log to measure the time spent in a piece of code:"
                },
                {
                    "type": "code",
                    "code": "console.time('filter array');constvisibleTodos=filterTodos(todos,tab);console.timeEnd('filter array');"
                },
                {
                    "type": "p",
                    "text": "Perform the interaction you’re measuring (for example, typing into the input). You will then see logs likefilter array: 0.15msin your console. If the overall logged time adds up to a significant amount (say,1msor more), it might make sense to memoize that calculation. As an experiment, you can then wrap the calculation inuseMemoto verify whether the total logged time has decreased for that interaction or not:"
                },
                {
                    "type": "code",
                    "code": "console.time('filter array');constvisibleTodos=useMemo(()=>{returnfilterTodos(todos,tab);// Skipped if todos and tab haven't changed},[todos,tab]);console.timeEnd('filter array');"
                },
                {
                    "type": "p",
                    "text": "useMemowon’t make thefirstrender faster. It only helps you skip unnecessary work on updates."
                },
                {
                    "type": "p",
                    "text": "Keep in mind that your machine is probably faster than your users’ so it’s a good idea to test the performance with an artificial slowdown. For example, Chrome offers aCPU Throttlingoption for this."
                },
                {
                    "type": "p",
                    "text": "Also note that measuring performance in development will not give you the most accurate results. (For example, whenStrict Modeis on, you will see each component render twice rather than once.) To get the most accurate timings, build your app for production and test it on a device like your users have."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Should you add useMemo everywhere?"
                },
                {
                    "type": "p",
                    "text": "If your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful."
                },
                {
                    "type": "p",
                    "text": "Optimizing withuseMemois only valuable in a few cases:"
                },
                {
                    "type": "list",
                    "items": [
                        "The calculation you’re putting inuseMemois noticeably slow, and its dependencies rarely change.",
                        "You pass it as a prop to a component wrapped inmemo.You want to skip re-rendering if the value hasn’t changed. Memoization lets your component re-render only when dependencies aren’t the same.",
                        "The value you’re passing is later used as a dependency of some Hook. For example, maybe anotheruseMemocalculation value depends on it. Or maybe you are depending on this value fromuseEffect."
                    ]
                },
                {
                    "type": "p",
                    "text": "There is no benefit to wrapping a calculation inuseMemoin other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value that’s “always new” is enough to break memoization for an entire component."
                },
                {
                    "type": "p",
                    "text": "In practice, you can make a lot of memoization unnecessary by following a few principles:"
                },
                {
                    "type": "list",
                    "items": [
                        "When a component visually wraps other components, let itaccept JSX as children.This way, when the wrapper component updates its own state, React knows that its children don’t need to re-render.",
                        "Prefer local state and don’tlift state upany further than necessary. For example, don’t keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.",
                        "Keep yourrendering logic pure.If re-rendering a component causes a problem or produces some noticeable visual artifact, it’s a bug in your component! Fix the bug instead of adding memoization.",
                        "Avoidunnecessary Effects that update state.Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.",
                        "Try toremove unnecessary dependencies from your Effects.For example, instead of memoization, it’s often simpler to move some object or a function inside an Effect or outside the component."
                    ]
                },
                {
                    "type": "p",
                    "text": "If a specific interaction still feels laggy,use the React Developer Tools profilerto see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it’s good to follow them in any case. In the long term, we’re researchingdoing granular memoization automaticallyto solve this once and for all."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "The difference between useMemo and calculating a value directly"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of2:Skipping recalculation withuseMemo"
                },
                {
                    "type": "p",
                    "text": "In this example, thefilterTodosimplementation isartificially slowed downso that you can see what happens when some JavaScript function you’re calling during rendering is genuinely slow. Try switching the tabs and toggling the theme."
                },
                {
                    "type": "p",
                    "text": "Switching the tabs feels slow because it forces the slowed downfilterTodosto re-execute. That’s expected because thetabhas changed, and so the entire calculationneedsto re-run. (If you’re curious why it runs twice, it’s explainedhere.)"
                },
                {
                    "type": "p",
                    "text": "Toggle the theme.Thanks touseMemo, it’s fast despite the artificial slowdown!The slowfilterTodoscall was skipped because bothtodosandtab(which you pass as dependencies touseMemo) haven’t changed since the last render."
                },
                {
                    "type": "code",
                    "code": "import{useMemo}from'react';import{filterTodos}from'./utils.js'exportdefaultfunctionTodoList({todos,theme,tab}){constvisibleTodos=useMemo(()=>filterTodos(todos,tab),[todos,tab]);return(<divclassName={theme}><p><b>Note:<code>filterTodos</code>is artificially slowed down!</b></p><ul>{visibleTodos.map(todo=>(<likey={todo.id}>{todo.completed?<s>{todo.text}</s>:todo.text}</li>))}</ul></div>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Skipping re-rendering of components"
                },
                {
                    "type": "p",
                    "text": "In some cases,useMemocan also help you optimize performance of re-rendering child components. To illustrate this, let’s say thisTodoListcomponent passes thevisibleTodosas a prop to the childListcomponent:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionTodoList({todos,tab,theme}){// ...return(<divclassName={theme}><Listitems={visibleTodos}/></div>);}"
                },
                {
                    "type": "p",
                    "text": "You’ve noticed that toggling thethemeprop freezes the app for a moment, but if you remove<List />from your JSX, it feels fast. This tells you that it’s worth trying to optimize theListcomponent."
                },
                {
                    "type": "p",
                    "text": "By default, when a component re-renders, React re-renders all of its children recursively.This is why, whenTodoListre-renders with a differenttheme, theListcomponentalsore-renders. This is fine for components that don’t require much calculation to re-render. But if you’ve verified that a re-render is slow, you can tellListto skip re-rendering when its props are the same as on last render by wrapping it inmemo:"
                },
                {
                    "type": "code",
                    "code": "import{memo}from'react';constList=memo(functionList({items}){// ...});"
                },
                {
                    "type": "p",
                    "text": "With this change,Listwill skip re-rendering if all of its props are thesameas on the last render.This is where caching the calculation becomes important! Imagine that you calculatedvisibleTodoswithoutuseMemo:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionTodoList({todos,tab,theme}){// Every time the theme changes, this will be a different array...constvisibleTodos=filterTodos(todos,tab);return(<divclassName={theme}>{/* ... so List's props will never be the same, and it will re-render every time */}<Listitems={visibleTodos}/></div>);}"
                },
                {
                    "type": "p",
                    "text": "In the above example, thefilterTodosfunction always creates adifferentarray,similar to how the{}object literal always creates a new object. Normally, this wouldn’t be a problem, but it means thatListprops will never be the same, and yourmemooptimization won’t work. This is whereuseMemocomes in handy:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionTodoList({todos,tab,theme}){// Tell React to cache your calculation between re-renders...constvisibleTodos=useMemo(()=>filterTodos(todos,tab),[todos,tab]// ...so as long as these dependencies don't change...);return(<divclassName={theme}>{/* ...List will receive the same props and can skip re-rendering */}<Listitems={visibleTodos}/></div>);}"
                },
                {
                    "type": "p",
                    "text": "By wrapping thevisibleTodoscalculation inuseMemo, you ensure that it has thesamevalue between the re-renders(until dependencies change). You don’thave towrap a calculation inuseMemounless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped inmemo,and this lets it skip re-rendering. There are a few other reasons to adduseMemowhich are described further on this page."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Memoizing individual JSX nodes"
                },
                {
                    "type": "p",
                    "text": "Instead of wrappingListinmemo, you could wrap the<List />JSX node itself inuseMemo:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionTodoList({todos,tab,theme}){constvisibleTodos=useMemo(()=>filterTodos(todos,tab),[todos,tab]);constchildren=useMemo(()=><Listitems={visibleTodos}/>,[visibleTodos]);return(<divclassName={theme}>{children}</div>);}"
                },
                {
                    "type": "p",
                    "text": "The behavior would be the same. If thevisibleTodoshaven’t changed,Listwon’t be re-rendered."
                },
                {
                    "type": "p",
                    "text": "A JSX node like<List items={visibleTodos} />is an object like{ type: List, props: { items: visibleTodos } }. Creating this object is very cheap, but React doesn’t know whether its contents is the same as last time or not. This is why by default, React will re-render theListcomponent."
                },
                {
                    "type": "p",
                    "text": "However, if React sees the same exact JSX as during the previous render, it won’t try to re-render your component. This is because JSX nodes areimmutable.A JSX node object could not have changed over time, so React knows it’s safe to skip a re-render. However, for this to work, the node has toactually be the same object, not merely look the same in code. This is whatuseMemodoes in this example."
                },
                {
                    "type": "p",
                    "text": "Manually wrapping JSX nodes intouseMemois not convenient. For example, you can’t do this conditionally. This is usually why you would wrap components withmemoinstead of wrapping JSX nodes."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "The difference between skipping re-renders and always re-rendering"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of2:Skipping re-rendering withuseMemoandmemo"
                },
                {
                    "type": "p",
                    "text": "In this example, theListcomponent isartificially slowed downso that you can see what happens when a React component you’re rendering is genuinely slow. Try switching the tabs and toggling the theme."
                },
                {
                    "type": "p",
                    "text": "Switching the tabs feels slow because it forces the slowed downListto re-render. That’s expected because thetabhas changed, and so you need to reflect the user’s new choice on the screen."
                },
                {
                    "type": "p",
                    "text": "Next, try toggling the theme.Thanks touseMemotogether withmemo, it’s fast despite the artificial slowdown!TheListskipped re-rendering because thevisibleTodosarray has not changed since the last render. ThevisibleTodosarray has not changed because bothtodosandtab(which you pass as dependencies touseMemo) haven’t changed since the last render."
                },
                {
                    "type": "code",
                    "code": "import{useMemo}from'react';importListfrom'./List.js';import{filterTodos}from'./utils.js'exportdefaultfunctionTodoList({todos,theme,tab}){constvisibleTodos=useMemo(()=>filterTodos(todos,tab),[todos,tab]);return(<divclassName={theme}><p><b>Note:<code>List</code>is artificially slowed down!</b></p><Listitems={visibleTodos}/></div>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Preventing an Effect from firing too often"
                },
                {
                    "type": "p",
                    "text": "Sometimes, you might want to use a value inside anEffect:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){const[message,setMessage]=useState('');constoptions={serverUrl:'https://localhost:1234',roomId:roomId}useEffect(()=>{constconnection=createConnection(options);connection.connect();// ..."
                },
                {
                    "type": "p",
                    "text": "This creates a problem.Every reactive value must be declared as a dependency of your Effect.However, if you declareoptionsas a dependency, it will cause your Effect to constantly reconnect to the chat room:"
                },
                {
                    "type": "code",
                    "code": "useEffect(()=>{constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[options]);// 🔴 Problem: This dependency changes on every render// ..."
                },
                {
                    "type": "p",
                    "text": "To solve this, you can wrap the object you need to call from an Effect inuseMemo:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){const[message,setMessage]=useState('');constoptions=useMemo(()=>{return{serverUrl:'https://localhost:1234',roomId:roomId};},[roomId]);// ✅ Only changes when roomId changesuseEffect(()=>{constoptions=createOptions();constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[options]);// ✅ Only changes when createOptions changes// ..."
                },
                {
                    "type": "p",
                    "text": "This ensures that theoptionsobject is the same between re-renders ifuseMemoreturns the cached object."
                },
                {
                    "type": "p",
                    "text": "However, sinceuseMemois performance optimization, not a semantic guarantee, React may throw away the cached value ifthere is a specific reason to do that. This will also cause the effect to re-fire,so it’s even better to remove the need for a function dependencyby moving your objectinsidethe Effect:"
                },
                {
                    "type": "code",
                    "code": "functionChatRoom({roomId}){const[message,setMessage]=useState('');useEffect(()=>{constoptions={// ✅ No need for useMemo or object dependencies!serverUrl:'https://localhost:1234',roomId:roomId}constconnection=createConnection(options);connection.connect();return()=>connection.disconnect();},[roomId]);// ✅ Only changes when roomId changes// ..."
                },
                {
                    "type": "p",
                    "text": "Now your code is simpler and doesn’t needuseMemo.Learn more about removing Effect dependencies."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Memoizing a dependency of another Hook"
                },
                {
                    "type": "p",
                    "text": "Suppose you have a calculation that depends on an object created directly in the component body:"
                },
                {
                    "type": "code",
                    "code": "functionDropdown({allItems,text}){constsearchOptions={matchMode:'whole-word',text};constvisibleItems=useMemo(()=>{returnsearchItems(allItems,searchOptions);},[allItems,searchOptions]);// 🚩 Caution: Dependency on an object created in the component body// ..."
                },
                {
                    "type": "p",
                    "text": "Depending on an object like this defeats the point of memoization. When a component re-renders, all of the code directly inside the component body runs again.The lines of code creating thesearchOptionsobject will also run on every re-render.SincesearchOptionsis a dependency of youruseMemocall, and it’s different every time, React knows the dependencies are different, and recalculatesearchItemsevery time."
                },
                {
                    "type": "p",
                    "text": "To fix this, you could memoize thesearchOptionsobjectitselfbefore passing it as a dependency:"
                },
                {
                    "type": "code",
                    "code": "functionDropdown({allItems,text}){constsearchOptions=useMemo(()=>{return{matchMode:'whole-word',text};},[text]);// ✅ Only changes when text changesconstvisibleItems=useMemo(()=>{returnsearchItems(allItems,searchOptions);},[allItems,searchOptions]);// ✅ Only changes when allItems or searchOptions changes// ..."
                },
                {
                    "type": "p",
                    "text": "In the example above, if thetextdid not change, thesearchOptionsobject also won’t change. However, an even better fix is to move thesearchOptionsobject declarationinsideof theuseMemocalculation function:"
                },
                {
                    "type": "code",
                    "code": "functionDropdown({allItems,text}){constvisibleItems=useMemo(()=>{constsearchOptions={matchMode:'whole-word',text};returnsearchItems(allItems,searchOptions);},[allItems,text]);// ✅ Only changes when allItems or text changes// ..."
                },
                {
                    "type": "p",
                    "text": "Now your calculation depends ontextdirectly (which is a string and can’t “accidentally” become different)."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Memoizing a function"
                },
                {
                    "type": "p",
                    "text": "Suppose theFormcomponent is wrapped inmemo.You want to pass a function to it as a prop:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionProductPage({productId,referrer}){functionhandleSubmit(orderDetails){post('/product/'+productId+'/buy',{referrer,orderDetails});}return<FormonSubmit={handleSubmit}/>;}"
                },
                {
                    "type": "p",
                    "text": "Just as{}creates a different object, function declarations likefunction() {}and expressions like() => {}produce adifferentfunction on every re-render. By itself, creating a new function is not a problem. This is not something to avoid! However, if theFormcomponent is memoized, presumably you want to skip re-rendering it when no props have changed. A prop that isalwaysdifferent would defeat the point of memoization."
                },
                {
                    "type": "p",
                    "text": "To memoize a function withuseMemo, your calculation function would have to return another function:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionPage({productId,referrer}){consthandleSubmit=useMemo(()=>{return(orderDetails)=>{post('/product/'+productId+'/buy',{referrer,orderDetails});};},[productId,referrer]);return<FormonSubmit={handleSubmit}/>;}"
                },
                {
                    "type": "p",
                    "text": "This looks clunky!Memoizing functions is common enough that React has a built-in Hook specifically for that. Wrap your functions intouseCallbackinstead ofuseMemoto avoid having to write an extra nested function:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionPage({productId,referrer}){consthandleSubmit=useCallback((orderDetails)=>{post('/product/'+productId+'/buy',{referrer,orderDetails});},[productId,referrer]);return<FormonSubmit={handleSubmit}/>;}"
                },
                {
                    "type": "p",
                    "text": "The two examples above are completely equivalent. The only benefit touseCallbackis that it lets you avoid writing an extra nested function inside. It doesn’t do anything else.Read more aboutuseCallback."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My calculation runs twice on every re-render"
                },
                {
                    "type": "p",
                    "text": "InStrict Mode, React will call some of your functions twice instead of once:"
                },
                {
                    "type": "code",
                    "code": "functionTodoList({todos,tab}){// This component function will run twice for every render.constvisibleTodos=useMemo(()=>{// This calculation will run twice if any of the dependencies change.returnfilterTodos(todos,tab);},[todos,tab]);// ..."
                },
                {
                    "type": "p",
                    "text": "This is expected and shouldn’t break your code."
                },
                {
                    "type": "p",
                    "text": "Thisdevelopment-onlybehavior helps youkeep components pure.React uses the result of one of the calls, and ignores the result of the other call. As long as your component and calculation functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice and fix the mistake."
                },
                {
                    "type": "p",
                    "text": "For example, this impure calculation function mutates an array you received as a prop:"
                },
                {
                    "type": "code",
                    "code": "constvisibleTodos=useMemo(()=>{// 🚩 Mistake: mutating a proptodos.push({id:'last',text:'Go for a walk!'});constfiltered=filterTodos(todos,tab);returnfiltered;},[todos,tab]);"
                },
                {
                    "type": "p",
                    "text": "React calls your function twice, so you’d notice the todo is added twice. Your calculation shouldn’t change any existing objects, but it’s okay to change anynewobjects you created during the calculation. For example, if thefilterTodosfunction always returns adifferentarray, you can mutatethatarray instead:"
                },
                {
                    "type": "code",
                    "code": "constvisibleTodos=useMemo(()=>{constfiltered=filterTodos(todos,tab);// ✅ Correct: mutating an object you created during the calculationfiltered.push({id:'last',text:'Go for a walk!'});returnfiltered;},[todos,tab]);"
                },
                {
                    "type": "p",
                    "text": "Readkeeping components pureto learn more about purity."
                },
                {
                    "type": "p",
                    "text": "Also, check out the guides onupdating objectsandupdating arrayswithout mutation."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "MyuseMemocall is supposed to return an object, but returns undefined"
                },
                {
                    "type": "p",
                    "text": "This code doesn’t work:"
                },
                {
                    "type": "code",
                    "code": "// 🔴 You can't return an object from an arrow function with () => {constsearchOptions=useMemo(()=>{matchMode:'whole-word',text:text},[text]);"
                },
                {
                    "type": "p",
                    "text": "In JavaScript,() => {starts the arrow function body, so the{brace is not a part of your object. This is why it doesn’t return an object, and leads to mistakes. You could fix it by adding parentheses like({and}):"
                },
                {
                    "type": "code",
                    "code": "// This works, but is easy for someone to break againconstsearchOptions=useMemo(()=>({matchMode:'whole-word',text:text}),[text]);"
                },
                {
                    "type": "p",
                    "text": "However, this is still confusing and too easy for someone to break by removing the parentheses."
                },
                {
                    "type": "p",
                    "text": "To avoid this mistake, write areturnstatement explicitly:"
                },
                {
                    "type": "code",
                    "code": "// ✅ This works and is explicitconstsearchOptions=useMemo(()=>{return{matchMode:'whole-word',text:text};},[text]);"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Every time my component renders, the calculation inuseMemore-runs"
                },
                {
                    "type": "p",
                    "text": "Make sure you’ve specified the dependency array as a second argument!"
                },
                {
                    "type": "p",
                    "text": "If you forget the dependency array,useMemowill re-run the calculation every time:"
                },
                {
                    "type": "code",
                    "code": "functionTodoList({todos,tab}){// 🔴 Recalculates every time: no dependency arrayconstvisibleTodos=useMemo(()=>filterTodos(todos,tab));// ..."
                },
                {
                    "type": "p",
                    "text": "This is the corrected version passing the dependency array as a second argument:"
                },
                {
                    "type": "code",
                    "code": "functionTodoList({todos,tab}){// ✅ Does not recalculate unnecessarilyconstvisibleTodos=useMemo(()=>filterTodos(todos,tab),[todos,tab]);// ..."
                },
                {
                    "type": "p",
                    "text": "If this doesn’t help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:"
                },
                {
                    "type": "code",
                    "code": "constvisibleTodos=useMemo(()=>filterTodos(todos,tab),[todos,tab]);console.log([todos,tab]);"
                },
                {
                    "type": "p",
                    "text": "You can then right-click on the arrays from different re-renders in the console and select “Store as a global variable” for both of them. Assuming the first one got saved astemp1and the second one got saved astemp2, you can then use the browser console to check whether each dependency in both arrays is the same:"
                },
                {
                    "type": "code",
                    "code": "Object.is(temp1[0],temp2[0]);// Is the first dependency the same between the arrays?Object.is(temp1[1],temp2[1]);// Is the second dependency the same between the arrays?Object.is(temp1[2],temp2[2]);// ... and so on for every dependency ..."
                },
                {
                    "type": "p",
                    "text": "When you find which dependency breaks memoization, either find a way to remove it, ormemoize it as well."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I need to calluseMemofor each list item in a loop, but it’s not allowed"
                },
                {
                    "type": "p",
                    "text": "Suppose theChartcomponent is wrapped inmemo. You want to skip re-rendering everyChartin the list when theReportListcomponent re-renders. However, you can’t calluseMemoin a loop:"
                },
                {
                    "type": "code",
                    "code": "functionReportList({items}){return(<article>{items.map(item=>{// 🔴 You can't call useMemo in a loop like this:constdata=useMemo(()=>calculateReport(item),[item]);return(<figurekey={item.id}><Chartdata={data}/></figure>);})}</article>);}"
                },
                {
                    "type": "p",
                    "text": "Instead, extract a component for each item and memoize data for individual items:"
                },
                {
                    "type": "code",
                    "code": "functionReportList({items}){return(<article>{items.map(item=><Reportkey={item.id}item={item}/>)}</article>);}functionReport({item}){// ✅ Call useMemo at the top level:constdata=useMemo(()=>calculateReport(item),[item]);return(<figure><Chartdata={data}/></figure>);}"
                },
                {
                    "type": "p",
                    "text": "Alternatively, you could removeuseMemoand instead wrapReportitself inmemo.If theitemprop does not change,Reportwill skip re-rendering, soChartwill skip re-rendering too:"
                },
                {
                    "type": "code",
                    "code": "functionReportList({items}){// ...}constReport=memo(functionReport({item}){constdata=calculateReport(item);return(<figure><Chartdata={data}/></figure>);});"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/useOptimistic",
            "title": "useOptimistic – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "useOptimistic- This feature is available in the latest Canary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "TheuseOptimisticHook is currently only available in React’s Canary and experimental channels. Learn more aboutReact’s release channels here."
                },
                {
                    "type": "p",
                    "text": "useOptimisticis a React Hook that lets you optimistically update the UI."
                },
                {
                    "type": "code",
                    "code": "const[optimisticState,addOptimistic]=useOptimistic(state,updateFn);"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceuseOptimistic(state, updateFn)",
                        "useOptimistic(state, updateFn)",
                        "UsageOptimistically updating forms",
                        "Optimistically updating forms"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "useOptimistic(state, updateFn)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Optimistically updating forms"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useOptimistic(state, updateFn)"
                },
                {
                    "type": "p",
                    "text": "useOptimisticis a React Hook that lets you show a different state while an async action is underway. It accepts some state as an argument and returns a copy of that state that can be different during the duration of an async action such as a network request. You provide a function that takes the current state and the input to the action, and returns the optimistic state to be used while the action is pending."
                },
                {
                    "type": "p",
                    "text": "This state is called the “optimistic” state because it is usually used to immediately present the user with the result of performing an action, even though the action actually takes time to complete."
                },
                {
                    "type": "code",
                    "code": "import{useOptimistic}from'react';functionAppContainer(){const[optimisticState,addOptimistic]=useOptimistic(state,// updateFn(currentState,optimisticValue)=>{// merge and return new state// with optimistic value});}"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "state: the value to be returned initially and whenever no action is pending.",
                        "updateFn(currentState, optimisticValue): a function that takes the current state and the optimistic value passed toaddOptimisticand returns the resulting optimistic state. It must be a pure function.updateFntakes in two parameters. ThecurrentStateand theoptimisticValue. The return value will be the merged value of thecurrentStateandoptimisticValue."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "list",
                    "items": [
                        "optimisticState: The resulting optimistic state. It is equal tostateunless an action is pending, in which case it is equal to the value returned byupdateFn.",
                        "addOptimistic:addOptimisticis the dispatching function to call when you have an optimistic update. It takes one argument,optimisticValue, of any type and will call theupdateFnwithstateandoptimisticValue."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Optimistically updating forms"
                },
                {
                    "type": "p",
                    "text": "TheuseOptimisticHook provides a way to optimistically update the user interface before a background operation, like a network request, completes. In the context of forms, this technique helps to make apps feel more responsive. When a user submits a form, instead of waiting for the server’s response to reflect the changes, the interface is immediately updated with the expected outcome."
                },
                {
                    "type": "p",
                    "text": "For example, when a user types a message into the form and hits the “Send” button, theuseOptimisticHook allows the message to immediately appear in the list with a “Sending…” label, even before the message is actually sent to a server. This “optimistic” approach gives the impression of speed and responsiveness. The form then attempts to truly send the message in the background. Once the server confirms the message has been received, the “Sending…” label is removed."
                },
                {
                    "type": "code",
                    "code": "import{useOptimistic,useState,useRef}from\"react\";import{deliverMessage}from\"./actions.js\";functionThread({messages,sendMessage}){constformRef=useRef();asyncfunctionformAction(formData){addOptimisticMessage(formData.get(\"message\"));formRef.current.reset();awaitsendMessage(formData);}const[optimisticMessages,addOptimisticMessage]=useOptimistic(messages,(state,newMessage)=>[...state,{text:newMessage,sending:true}]);return(<>{optimisticMessages.map((message,index)=>(<divkey={index}>{message.text}{!!message.sending&&<small>(Sending...)</small>}</div>))}<formaction={formAction}ref={formRef}><inputtype=\"text\"name=\"message\"placeholder=\"Hello!\"/><buttontype=\"submit\">Send</button></form></>);}exportdefaultfunctionApp(){const[messages,setMessages]=useState([{text:\"Hello there!\",sending:false,key:1}]);asyncfunctionsendMessage(formData){constsentMessage=awaitdeliverMessage(formData.get(\"message\"));setMessages((messages)=>[...messages,{text:sentMessage}]);}return<Threadmessages={messages}sendMessage={sendMessage}/>;}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/useReducer",
            "title": "useReducer – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "useReducer"
                },
                {
                    "type": "p",
                    "text": "useReduceris a React Hook that lets you add areducerto your component."
                },
                {
                    "type": "code",
                    "code": "const[state,dispatch]=useReducer(reducer,initialArg,init?)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceuseReducer(reducer, initialArg, init?)dispatchfunction",
                        "useReducer(reducer, initialArg, init?)",
                        "dispatchfunction",
                        "UsageAdding a reducer to a componentWriting the reducer functionAvoiding recreating the initial state",
                        "Adding a reducer to a component",
                        "Writing the reducer function",
                        "Avoiding recreating the initial state",
                        "TroubleshootingI’ve dispatched an action, but logging gives me the old state valueI’ve dispatched an action, but the screen doesn’t updateA part of my reducer state becomes undefined after dispatchingMy entire reducer state becomes undefined after dispatchingI’m getting an error: “Too many re-renders”My reducer or initializer function runs twice",
                        "I’ve dispatched an action, but logging gives me the old state value",
                        "I’ve dispatched an action, but the screen doesn’t update",
                        "A part of my reducer state becomes undefined after dispatching",
                        "My entire reducer state becomes undefined after dispatching",
                        "I’m getting an error: “Too many re-renders”",
                        "My reducer or initializer function runs twice"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "useReducer(reducer, initialArg, init?)",
                        "dispatchfunction"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Adding a reducer to a component",
                        "Writing the reducer function",
                        "Avoiding recreating the initial state"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "I’ve dispatched an action, but logging gives me the old state value",
                        "I’ve dispatched an action, but the screen doesn’t update",
                        "A part of my reducer state becomes undefined after dispatching",
                        "My entire reducer state becomes undefined after dispatching",
                        "I’m getting an error: “Too many re-renders”",
                        "My reducer or initializer function runs twice"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useReducer(reducer, initialArg, init?)"
                },
                {
                    "type": "p",
                    "text": "CalluseReducerat the top level of your component to manage its state with areducer."
                },
                {
                    "type": "code",
                    "code": "import{useReducer}from'react';functionreducer(state,action){// ...}functionMyComponent(){const[state,dispatch]=useReducer(reducer,{age:42});// ..."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "reducer: The reducer function that specifies how the state gets updated. It must be pure, should take the state and action as arguments, and should return the next state. State and action can be of any types.",
                        "initialArg: The value from which the initial state is calculated. It can be a value of any type. How the initial state is calculated from it depends on the nextinitargument.",
                        "optionalinit: The initializer function that should return the initial state. If it’s not specified, the initial state is set toinitialArg. Otherwise, the initial state is set to the result of callinginit(initialArg)."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "useReducerreturns an array with exactly two values:"
                },
                {
                    "type": "list",
                    "items": [
                        "The current state. During the first render, it’s set toinit(initialArg)orinitialArg(if there’s noinit).",
                        "Thedispatchfunctionthat lets you update the state to a different value and trigger a re-render."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "useReduceris a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.",
                        "Thedispatchfunction has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do.Learn more about removing Effect dependencies.",
                        "In Strict Mode, React willcall your reducer and initializer twicein order tohelp you find accidental impurities.This is development-only behavior and does not affect production. If your reducer and initializer are pure (as they should be), this should not affect your logic. The result from one of the calls is ignored."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "dispatchfunction"
                },
                {
                    "type": "p",
                    "text": "Thedispatchfunction returned byuseReducerlets you update the state to a different value and trigger a re-render. You need to pass the action as the only argument to thedispatchfunction:"
                },
                {
                    "type": "code",
                    "code": "const[state,dispatch]=useReducer(reducer,{age:42});functionhandleClick(){dispatch({type:'incremented_age'});// ..."
                },
                {
                    "type": "p",
                    "text": "React will set the next state to the result of calling thereducerfunction you’ve provided with the currentstateand the action you’ve passed todispatch."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "action: The action performed by the user. It can be a value of any type. By convention, an action is usually an object with atypeproperty identifying it and, optionally, other properties with additional information."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "dispatchfunctions do not have a return value."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Thedispatchfunctiononly updates the state variable for thenextrender. If you read the state variable after calling thedispatchfunction,you will still get the old valuethat was on the screen before your call.",
                        "If the new value you provide is identical to the currentstate, as determined by anObject.iscomparison, React willskip re-rendering the component and its children.This is an optimization. React may still need to call your component before ignoring the result, but it shouldn’t affect your code.",
                        "Reactbatches state updates.It updates the screenafter all the event handlers have runand have called theirsetfunctions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can useflushSync."
                    ]
                },
                {
                    "type": "p",
                    "text": "Thedispatchfunctiononly updates the state variable for thenextrender. If you read the state variable after calling thedispatchfunction,you will still get the old valuethat was on the screen before your call."
                },
                {
                    "type": "p",
                    "text": "If the new value you provide is identical to the currentstate, as determined by anObject.iscomparison, React willskip re-rendering the component and its children.This is an optimization. React may still need to call your component before ignoring the result, but it shouldn’t affect your code."
                },
                {
                    "type": "p",
                    "text": "Reactbatches state updates.It updates the screenafter all the event handlers have runand have called theirsetfunctions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can useflushSync."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Adding a reducer to a component"
                },
                {
                    "type": "p",
                    "text": "CalluseReducerat the top level of your component to manage state with areducer."
                },
                {
                    "type": "code",
                    "code": "import{useReducer}from'react';functionreducer(state,action){// ...}functionMyComponent(){const[state,dispatch]=useReducer(reducer,{ age: 42 });// ..."
                },
                {
                    "type": "p",
                    "text": "useReducerreturns an array with exactly two items:"
                },
                {
                    "type": "list",
                    "items": [
                        "Thecurrent stateof this state variable, initially set to theinitial stateyou provided.",
                        "Thedispatchfunctionthat lets you change it in response to interaction."
                    ]
                },
                {
                    "type": "p",
                    "text": "To update what’s on the screen, calldispatchwith an object representing what the user did, called anaction:"
                },
                {
                    "type": "code",
                    "code": "functionhandleClick(){dispatch({type:'incremented_age'});}"
                },
                {
                    "type": "p",
                    "text": "React will pass the current state and the action to yourreducer function. Your reducer will calculate and return the next state. React will store that next state, render your component with it, and update the UI."
                },
                {
                    "type": "code",
                    "code": "import{useReducer}from'react';functionreducer(state,action){if(action.type==='incremented_age'){return{age:state.age+1};}throwError('Unknown action.');}exportdefaultfunctionCounter(){const[state,dispatch]=useReducer(reducer,{age:42});return(<><buttononClick={()=>{dispatch({type:'incremented_age'})}}>Increment age</button><p>Hello! You are{state.age}.</p></>);}"
                },
                {
                    "type": "p",
                    "text": "useReduceris very similar touseState, but it lets you move the state update logic from event handlers into a single function outside of your component. Read more aboutchoosing betweenuseStateanduseReducer."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Writing the reducer function"
                },
                {
                    "type": "p",
                    "text": "A reducer function is declared like this:"
                },
                {
                    "type": "code",
                    "code": "functionreducer(state,action){// ...}"
                },
                {
                    "type": "p",
                    "text": "Then you need to fill in the code that will calculate and return the next state. By convention, it is common to write it as aswitchstatement.For eachcasein theswitch, calculate and return some next state."
                },
                {
                    "type": "code",
                    "code": "functionreducer(state,action){switch(action.type){case'incremented_age':{return{name:state.name,age:state.age+1};}case'changed_name':{return{name:action.nextName,age:state.age};}}throwError('Unknown action: '+action.type);}"
                },
                {
                    "type": "p",
                    "text": "Actions can have any shape. By convention, it’s common to pass objects with atypeproperty identifying the action. It should include the minimal necessary information that the reducer needs to compute the next state."
                },
                {
                    "type": "code",
                    "code": "functionForm(){const[state,dispatch]=useReducer(reducer,{name:'Taylor',age:42});functionhandleButtonClick(){dispatch({type:'incremented_age'});}functionhandleInputChange(e){dispatch({type:'changed_name',nextName:e.target.value});}// ..."
                },
                {
                    "type": "p",
                    "text": "The action type names are local to your component.Each action describes a single interaction, even if that leads to multiple changes in data.The shape of the state is arbitrary, but usually it’ll be an object or an array."
                },
                {
                    "type": "p",
                    "text": "Readextracting state logic into a reducerto learn more."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "State is read-only. Don’t modify any objects or arrays in state:"
                },
                {
                    "type": "code",
                    "code": "functionreducer(state,action){switch(action.type){case'incremented_age':{// 🚩 Don't mutate an object in state like this:state.age=state.age+1;returnstate;}"
                },
                {
                    "type": "p",
                    "text": "Instead, always return new objects from your reducer:"
                },
                {
                    "type": "code",
                    "code": "functionreducer(state,action){switch(action.type){case'incremented_age':{// ✅ Instead, return a new objectreturn{...state,age:state.age+1};}"
                },
                {
                    "type": "p",
                    "text": "Readupdating objects in stateandupdating arrays in stateto learn more."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Basic useReducer examples"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of3:Form (object)"
                },
                {
                    "type": "p",
                    "text": "In this example, the reducer manages a state object with two fields:nameandage."
                },
                {
                    "type": "code",
                    "code": "import{useReducer}from'react';functionreducer(state,action){switch(action.type){case'incremented_age':{return{name:state.name,age:state.age+1};}case'changed_name':{return{name:action.nextName,age:state.age};}}throwError('Unknown action: '+action.type);}constinitialState={name:'Taylor',age:42};exportdefaultfunctionForm(){const[state,dispatch]=useReducer(reducer,initialState);functionhandleButtonClick(){dispatch({type:'incremented_age'});}functionhandleInputChange(e){dispatch({type:'changed_name',nextName:e.target.value});}return(<><inputvalue={state.name}onChange={handleInputChange}/><buttononClick={handleButtonClick}>Increment age</button><p>Hello,{state.name}. You are{state.age}.</p></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Avoiding recreating the initial state"
                },
                {
                    "type": "p",
                    "text": "React saves the initial state once and ignores it on the next renders."
                },
                {
                    "type": "code",
                    "code": "functioncreateInitialState(username){// ...}functionTodoList({username}){const[state,dispatch]=useReducer(reducer,createInitialState(username));// ..."
                },
                {
                    "type": "p",
                    "text": "Although the result ofcreateInitialState(username)is only used for the initial render, you’re still calling this function on every render. This can be wasteful if it’s creating large arrays or performing expensive calculations."
                },
                {
                    "type": "p",
                    "text": "To solve this, you maypass it as aninitializerfunctiontouseReduceras the third argument instead:"
                },
                {
                    "type": "code",
                    "code": "functioncreateInitialState(username){// ...}functionTodoList({username}){const[state,dispatch]=useReducer(reducer,username,createInitialState);// ..."
                },
                {
                    "type": "p",
                    "text": "Notice that you’re passingcreateInitialState, which is thefunction itself, and notcreateInitialState(), which is the result of calling it. This way, the initial state does not get re-created after initialization."
                },
                {
                    "type": "p",
                    "text": "In the above example,createInitialStatetakes ausernameargument. If your initializer doesn’t need any information to compute the initial state, you may passnullas the second argument touseReducer."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "The difference between passing an initializer and passing the initial state directly"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of2:Passing the initializer function"
                },
                {
                    "type": "p",
                    "text": "This example passes the initializer function, so thecreateInitialStatefunction only runs during initialization. It does not run when component re-renders, such as when you type into the input."
                },
                {
                    "type": "code",
                    "code": "import{useReducer}from'react';functioncreateInitialState(username){constinitialTodos=[];for(leti=0;i<50;i++){initialTodos.push({id:i,text:username+\"'s task #\"+(i+1)});}return{draft:'',todos:initialTodos,};}functionreducer(state,action){switch(action.type){case'changed_draft':{return{draft:action.nextDraft,todos:state.todos,};};case'added_todo':{return{draft:'',todos:[{id:state.todos.length,text:state.draft},...state.todos]}}}throwError('Unknown action: '+action.type);}exportdefaultfunctionTodoList({username}){const[state,dispatch]=useReducer(reducer,username,createInitialState);return(<><inputvalue={state.draft}onChange={e=>{dispatch({type:'changed_draft',nextDraft:e.target.value})}}/><buttononClick={()=>{dispatch({type:'added_todo'});}}>Add</button><ul>{state.todos.map(item=>(<likey={item.id}>{item.text}</li>))}</ul></>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’ve dispatched an action, but logging gives me the old state value"
                },
                {
                    "type": "p",
                    "text": "Calling thedispatchfunctiondoes not change state in the running code:"
                },
                {
                    "type": "code",
                    "code": "functionhandleClick(){console.log(state.age);// 42dispatch({type:'incremented_age'});// Request a re-render with 43console.log(state.age);// Still 42!setTimeout(()=>{console.log(state.age);// Also 42!},5000);}"
                },
                {
                    "type": "p",
                    "text": "This is becausestates behaves like a snapshot.Updating state requests another render with the new state value, but does not affect thestateJavaScript variable in your already-running event handler."
                },
                {
                    "type": "p",
                    "text": "If you need to guess the next state value, you can calculate it manually by calling the reducer yourself:"
                },
                {
                    "type": "code",
                    "code": "constaction={type:'incremented_age'};dispatch(action);constnextState=reducer(state,action);console.log(state);// { age: 42 }console.log(nextState);// { age: 43 }"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’ve dispatched an action, but the screen doesn’t update"
                },
                {
                    "type": "p",
                    "text": "React willignore your update if the next state is equal to the previous state,as determined by anObject.iscomparison. This usually happens when you change an object or an array in state directly:"
                },
                {
                    "type": "code",
                    "code": "functionreducer(state,action){switch(action.type){case'incremented_age':{// 🚩 Wrong: mutating existing objectstate.age++;returnstate;}case'changed_name':{// 🚩 Wrong: mutating existing objectstate.name=action.nextName;returnstate;}// ...}}"
                },
                {
                    "type": "p",
                    "text": "You mutated an existingstateobject and returned it, so React ignored the update. To fix this, you need to ensure that you’re alwaysupdating objects in stateandupdating arrays in stateinstead of mutating them:"
                },
                {
                    "type": "code",
                    "code": "functionreducer(state,action){switch(action.type){case'incremented_age':{// ✅ Correct: creating a new objectreturn{...state,age:state.age+1};}case'changed_name':{// ✅ Correct: creating a new objectreturn{...state,name:action.nextName};}// ...}}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "A part of my reducer state becomes undefined after dispatching"
                },
                {
                    "type": "p",
                    "text": "Make sure that everycasebranchcopies all of the existing fieldswhen returning the new state:"
                },
                {
                    "type": "code",
                    "code": "functionreducer(state,action){switch(action.type){case'incremented_age':{return{...state,// Don't forget this!age:state.age+1};}// ..."
                },
                {
                    "type": "p",
                    "text": "Without...stateabove, the returned next state would only contain theagefield and nothing else."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My entire reducer state becomes undefined after dispatching"
                },
                {
                    "type": "p",
                    "text": "If your state unexpectedly becomesundefined, you’re likely forgetting toreturnstate in one of the cases, or your action type doesn’t match any of thecasestatements. To find why, throw an error outside theswitch:"
                },
                {
                    "type": "code",
                    "code": "functionreducer(state,action){switch(action.type){case'incremented_age':{// ...}case'edited_name':{// ...}}throwError('Unknown action: '+action.type);}"
                },
                {
                    "type": "p",
                    "text": "You can also use a static type checker like TypeScript to catch such mistakes."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’m getting an error: “Too many re-renders”"
                },
                {
                    "type": "p",
                    "text": "You might get an error that says:Too many re-renders. React limits the number of renders to prevent an infinite loop.Typically, this means that you’re unconditionally dispatching an actionduring render, so your component enters a loop: render, dispatch (which causes a render), render, dispatch (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:"
                },
                {
                    "type": "code",
                    "code": "// 🚩 Wrong: calls the handler during renderreturn<buttononClick={handleClick()}>Click me</button>// ✅ Correct: passes down the event handlerreturn<buttononClick={handleClick}>Click me</button>// ✅ Correct: passes down an inline functionreturn<buttononClick={(e)=>handleClick(e)}>Click me</button>"
                },
                {
                    "type": "p",
                    "text": "If you can’t find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specificdispatchfunction call responsible for the error."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My reducer or initializer function runs twice"
                },
                {
                    "type": "p",
                    "text": "InStrict Mode, React will call your reducer and initializer functions twice. This shouldn’t break your code."
                },
                {
                    "type": "p",
                    "text": "Thisdevelopment-onlybehavior helps youkeep components pure.React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and reducer functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice the mistakes."
                },
                {
                    "type": "p",
                    "text": "For example, this impure reducer function mutates an array in state:"
                },
                {
                    "type": "code",
                    "code": "functionreducer(state,action){switch(action.type){case'added_todo':{// 🚩 Mistake: mutating statestate.todos.push({id:nextId++,text:action.text});returnstate;}// ...}}"
                },
                {
                    "type": "p",
                    "text": "Because React calls your reducer function twice, you’ll see the todo was added twice, so you’ll know that there is a mistake. In this example, you can fix the mistake byreplacing the array instead of mutating it:"
                },
                {
                    "type": "code",
                    "code": "functionreducer(state,action){switch(action.type){case'added_todo':{// ✅ Correct: replacing with new statereturn{...state,todos:[...state.todos,{id:nextId++,text:action.text}]};}// ...}}"
                },
                {
                    "type": "p",
                    "text": "Now that this reducer function is pure, calling it an extra time doesn’t make a difference in behavior. This is why React calling it twice helps you find mistakes.Only component, initializer, and reducer functions need to be pure.Event handlers don’t need to be pure, so React will never call your event handlers twice."
                },
                {
                    "type": "p",
                    "text": "Readkeeping components pureto learn more."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/useRef",
            "title": "useRef – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "useRef"
                },
                {
                    "type": "p",
                    "text": "useRefis a React Hook that lets you reference a value that’s not needed for rendering."
                },
                {
                    "type": "code",
                    "code": "constref=useRef(initialValue)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceuseRef(initialValue)",
                        "useRef(initialValue)",
                        "UsageReferencing a value with a refManipulating the DOM with a refAvoiding recreating the ref contents",
                        "Referencing a value with a ref",
                        "Manipulating the DOM with a ref",
                        "Avoiding recreating the ref contents",
                        "TroubleshootingI can’t get a ref to a custom component",
                        "I can’t get a ref to a custom component"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "useRef(initialValue)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Referencing a value with a ref",
                        "Manipulating the DOM with a ref",
                        "Avoiding recreating the ref contents"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "I can’t get a ref to a custom component"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useRef(initialValue)"
                },
                {
                    "type": "p",
                    "text": "CalluseRefat the top level of your component to declare aref."
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';functionMyComponent(){constintervalRef=useRef(0);constinputRef=useRef(null);// ..."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "initialValue: The value you want the ref object’scurrentproperty to be initially. It can be a value of any type. This argument is ignored after the initial render."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "useRefreturns an object with a single property:"
                },
                {
                    "type": "list",
                    "items": [
                        "current: Initially, it’s set to theinitialValueyou have passed. You can later set it to something else. If you pass the ref object to React as arefattribute to a JSX node, React will set itscurrentproperty."
                    ]
                },
                {
                    "type": "p",
                    "text": "On the next renders,useRefwill return the same object."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "You can mutate theref.currentproperty. Unlike state, it is mutable. However, if it holds an object that is used for rendering (for example, a piece of your state), then you shouldn’t mutate that object.",
                        "When you change theref.currentproperty, React does not re-render your component. React is not aware of when you change it because a ref is a plain JavaScript object.",
                        "Do not writeor readref.currentduring rendering, except forinitialization.This makes your component’s behavior unpredictable.",
                        "In Strict Mode, React willcall your component function twicein order tohelp you find accidental impurities.This is development-only behavior and does not affect production. Each ref object will be created twice, but one of the versions will be discarded. If your component function is pure (as it should be), this should not affect the behavior."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Referencing a value with a ref"
                },
                {
                    "type": "p",
                    "text": "CalluseRefat the top level of your component to declare one or morerefs."
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';functionStopwatch(){constintervalRef=useRef(0);// ..."
                },
                {
                    "type": "p",
                    "text": "useRefreturns aref objectwith a singlecurrentpropertyinitially set to theinitial valueyou provided."
                },
                {
                    "type": "p",
                    "text": "On the next renders,useRefwill return the same object. You can change itscurrentproperty to store information and read it later. This might remind you ofstate, but there is an important difference."
                },
                {
                    "type": "p",
                    "text": "Changing a ref does not trigger a re-render.This means refs are perfect for storing information that doesn’t affect the visual output of your component. For example, if you need to store aninterval IDand retrieve it later, you can put it in a ref. To update the value inside the ref, you need to manually change itscurrentproperty:"
                },
                {
                    "type": "code",
                    "code": "functionhandleStartClick(){constintervalId=setInterval(()=>{// ...},1000);intervalRef.current=intervalId;}"
                },
                {
                    "type": "p",
                    "text": "Later, you can read that interval ID from the ref so that you can callclear that interval:"
                },
                {
                    "type": "code",
                    "code": "functionhandleStopClick(){constintervalId=intervalRef.current;clearInterval(intervalId);}"
                },
                {
                    "type": "p",
                    "text": "By using a ref, you ensure that:"
                },
                {
                    "type": "list",
                    "items": [
                        "You canstore informationbetween re-renders (unlike regular variables, which reset on every render).",
                        "Changing itdoes not trigger a re-render(unlike state variables, which trigger a re-render).",
                        "Theinformation is localto each copy of your component (unlike the variables outside, which are shared)."
                    ]
                },
                {
                    "type": "p",
                    "text": "Changing a ref does not trigger a re-render, so refs are not appropriate for storing information you want to display on the screen. Use state for that instead. Read more aboutchoosing betweenuseRefanduseState."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Examples of referencing a value with useRef"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of2:Click counter"
                },
                {
                    "type": "p",
                    "text": "This component uses a ref to keep track of how many times the button was clicked. Note that it’s okay to use a ref instead of state here because the click count is only read and written in an event handler."
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';exportdefaultfunctionCounter(){letref=useRef(0);functionhandleClick(){ref.current=ref.current+1;alert('You clicked '+ref.current+' times!');}return(<buttononClick={handleClick}>Click me!</button>);}"
                },
                {
                    "type": "p",
                    "text": "If you show{ref.current}in the JSX, the number won’t update on click. This is because settingref.currentdoes not trigger a re-render. Information that’s used for rendering should be state instead."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Do not writeor readref.currentduring rendering."
                },
                {
                    "type": "p",
                    "text": "React expects that the body of your componentbehaves like a pure function:"
                },
                {
                    "type": "list",
                    "items": [
                        "If the inputs (props,state, andcontext) are the same, it should return exactly the same JSX.",
                        "Calling it in a different order or with different arguments should not affect the results of other calls."
                    ]
                },
                {
                    "type": "p",
                    "text": "Reading or writing a refduring renderingbreaks these expectations."
                },
                {
                    "type": "code",
                    "code": "functionMyComponent(){// ...// 🚩 Don't write a ref during renderingmyRef.current=123;// ...// 🚩 Don't read a ref during renderingreturn<h1>{myOtherRef.current}</h1>;}"
                },
                {
                    "type": "p",
                    "text": "You can read or write refsfrom event handlers or effects instead."
                },
                {
                    "type": "code",
                    "code": "functionMyComponent(){// ...useEffect(()=>{// ✅ You can read or write refs in effectsmyRef.current=123;});// ...functionhandleClick(){// ✅ You can read or write refs in event handlersdoSomething(myOtherRef.current);}// ...}"
                },
                {
                    "type": "p",
                    "text": "If youhave toreador writesomething during rendering,use stateinstead."
                },
                {
                    "type": "p",
                    "text": "When you break these rules, your component might still work, but most of the newer features we’re adding to React will rely on these expectations. Read more aboutkeeping your components pure."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Manipulating the DOM with a ref"
                },
                {
                    "type": "p",
                    "text": "It’s particularly common to use a ref to manipulate theDOM.React has built-in support for this."
                },
                {
                    "type": "p",
                    "text": "First, declare aref objectwith aninitial valueofnull:"
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';functionMyComponent(){constinputRef=useRef(null);// ..."
                },
                {
                    "type": "p",
                    "text": "Then pass your ref object as therefattribute to the JSX of the DOM node you want to manipulate:"
                },
                {
                    "type": "code",
                    "code": "// ...return<inputref={inputRef}/>;"
                },
                {
                    "type": "p",
                    "text": "After React creates the DOM node and puts it on the screen, React will set thecurrentpropertyof your ref object to that DOM node. Now you can access the<input>’s DOM node and call methods likefocus():"
                },
                {
                    "type": "code",
                    "code": "functionhandleClick(){inputRef.current.focus();}"
                },
                {
                    "type": "p",
                    "text": "React will set thecurrentproperty back tonullwhen the node is removed from the screen."
                },
                {
                    "type": "p",
                    "text": "Read more aboutmanipulating the DOM with refs."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Examples of manipulating the DOM with useRef"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of4:Focusing a text input"
                },
                {
                    "type": "p",
                    "text": "In this example, clicking the button will focus the input:"
                },
                {
                    "type": "code",
                    "code": "import{useRef}from'react';exportdefaultfunctionForm(){constinputRef=useRef(null);functionhandleClick(){inputRef.current.focus();}return(<><inputref={inputRef}/><buttononClick={handleClick}>Focus the input</button></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Avoiding recreating the ref contents"
                },
                {
                    "type": "p",
                    "text": "React saves the initial ref value once and ignores it on the next renders."
                },
                {
                    "type": "code",
                    "code": "functionVideo(){constplayerRef=useRef(newVideoPlayer());// ..."
                },
                {
                    "type": "p",
                    "text": "Although the result ofnew VideoPlayer()is only used for the initial render, you’re still calling this function on every render. This can be wasteful if it’s creating expensive objects."
                },
                {
                    "type": "p",
                    "text": "To solve it, you may initialize the ref like this instead:"
                },
                {
                    "type": "code",
                    "code": "functionVideo(){constplayerRef=useRef(null);if(playerRef.current===null){playerRef.current=newVideoPlayer();}// ..."
                },
                {
                    "type": "p",
                    "text": "Normally, writing or readingref.currentduring render is not allowed. However, it’s fine in this case because the result is always the same, and the condition only executes during initialization so it’s fully predictable."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "How to avoid null checks when initializing useRef later"
                },
                {
                    "type": "p",
                    "text": "If you use a type checker and don’t want to always check fornull, you can try a pattern like this instead:"
                },
                {
                    "type": "code",
                    "code": "functionVideo(){constplayerRef=useRef(null);functiongetPlayer(){if(playerRef.current!==null){returnplayerRef.current;}constplayer=newVideoPlayer();playerRef.current=player;returnplayer;}// ..."
                },
                {
                    "type": "p",
                    "text": "Here, theplayerRefitself is nullable. However, you should be able to convince your type checker that there is no case in whichgetPlayer()returnsnull. Then usegetPlayer()in your event handlers."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I can’t get a ref to a custom component"
                },
                {
                    "type": "p",
                    "text": "If you try to pass arefto your own component like this:"
                },
                {
                    "type": "code",
                    "code": "constinputRef=useRef(null);return<MyInputref={inputRef}/>;"
                },
                {
                    "type": "p",
                    "text": "You might get an error in the console:"
                },
                {
                    "type": "p",
                    "text": "By default, your own components don’t expose refs to the DOM nodes inside them."
                },
                {
                    "type": "p",
                    "text": "To fix this, find the component that you want to get a ref to:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionMyInput({value,onChange}){return(<inputvalue={value}onChange={onChange}/>);}"
                },
                {
                    "type": "p",
                    "text": "And then wrap it inforwardReflike this:"
                },
                {
                    "type": "code",
                    "code": "import{forwardRef}from'react';constMyInput=forwardRef(({value,onChange},ref)=>{return(<inputvalue={value}onChange={onChange}ref={ref}/>);});exportdefaultMyInput;"
                },
                {
                    "type": "p",
                    "text": "Then the parent component can get a ref to it."
                },
                {
                    "type": "p",
                    "text": "Read more aboutaccessing another component’s DOM nodes."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/useState",
            "title": "useState – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "useState"
                },
                {
                    "type": "p",
                    "text": "useStateis a React Hook that lets you add astate variableto your component."
                },
                {
                    "type": "code",
                    "code": "const[state,setState]=useState(initialState)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceuseState(initialState)setfunctions, likesetSomething(nextState)",
                        "useState(initialState)",
                        "setfunctions, likesetSomething(nextState)",
                        "UsageAdding state to a componentUpdating state based on the previous stateUpdating objects and arrays in stateAvoiding recreating the initial stateResetting state with a keyStoring information from previous renders",
                        "Adding state to a component",
                        "Updating state based on the previous state",
                        "Updating objects and arrays in state",
                        "Avoiding recreating the initial state",
                        "Resetting state with a key",
                        "Storing information from previous renders",
                        "TroubleshootingI’ve updated the state, but logging gives me the old valueI’ve updated the state, but the screen doesn’t updateI’m getting an error: “Too many re-renders”My initializer or updater function runs twiceI’m trying to set state to a function, but it gets called instead",
                        "I’ve updated the state, but logging gives me the old value",
                        "I’ve updated the state, but the screen doesn’t update",
                        "I’m getting an error: “Too many re-renders”",
                        "My initializer or updater function runs twice",
                        "I’m trying to set state to a function, but it gets called instead"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "useState(initialState)",
                        "setfunctions, likesetSomething(nextState)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Adding state to a component",
                        "Updating state based on the previous state",
                        "Updating objects and arrays in state",
                        "Avoiding recreating the initial state",
                        "Resetting state with a key",
                        "Storing information from previous renders"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "I’ve updated the state, but logging gives me the old value",
                        "I’ve updated the state, but the screen doesn’t update",
                        "I’m getting an error: “Too many re-renders”",
                        "My initializer or updater function runs twice",
                        "I’m trying to set state to a function, but it gets called instead"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useState(initialState)"
                },
                {
                    "type": "p",
                    "text": "CalluseStateat the top level of your component to declare astate variable."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';functionMyComponent(){const[age,setAge]=useState(28);const[name,setName]=useState('Taylor');const[todos,setTodos]=useState(()=>createTodos());// ..."
                },
                {
                    "type": "p",
                    "text": "The convention is to name state variables like[something, setSomething]usingarray destructuring."
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "initialState: The value you want the state to be initially. It can be a value of any type, but there is a special behavior for functions. This argument is ignored after the initial render.If you pass a function asinitialState, it will be treated as aninitializer function. It should be pure, should take no arguments, and should return a value of any type. React will call your initializer function when initializing the component, and store its return value as the initial state.See an example below.",
                        "If you pass a function asinitialState, it will be treated as aninitializer function. It should be pure, should take no arguments, and should return a value of any type. React will call your initializer function when initializing the component, and store its return value as the initial state.See an example below."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "If you pass a function asinitialState, it will be treated as aninitializer function. It should be pure, should take no arguments, and should return a value of any type. React will call your initializer function when initializing the component, and store its return value as the initial state.See an example below."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "useStatereturns an array with exactly two values:"
                },
                {
                    "type": "list",
                    "items": [
                        "The current state. During the first render, it will match theinitialStateyou have passed.",
                        "Thesetfunctionthat lets you update the state to a different value and trigger a re-render."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "useStateis a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.",
                        "In Strict Mode, React willcall your initializer function twicein order tohelp you find accidental impurities.This is development-only behavior and does not affect production. If your initializer function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "setfunctions, likesetSomething(nextState)"
                },
                {
                    "type": "p",
                    "text": "Thesetfunction returned byuseStatelets you update the state to a different value and trigger a re-render. You can pass the next state directly, or a function that calculates it from the previous state:"
                },
                {
                    "type": "code",
                    "code": "const[name,setName]=useState('Edward');functionhandleClick(){setName('Taylor');setAge(a=>a+1);// ..."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "nextState: The value that you want the state to be. It can be a value of any type, but there is a special behavior for functions.If you pass a function asnextState, it will be treated as anupdater function. It must be pure, should take the pending state as its only argument, and should return the next state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state.See an example below.",
                        "If you pass a function asnextState, it will be treated as anupdater function. It must be pure, should take the pending state as its only argument, and should return the next state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state.See an example below."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "If you pass a function asnextState, it will be treated as anupdater function. It must be pure, should take the pending state as its only argument, and should return the next state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state.See an example below."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "setfunctions do not have a return value."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "Thesetfunctiononly updates the state variable for thenextrender. If you read the state variable after calling thesetfunction,you will still get the old valuethat was on the screen before your call.",
                        "If the new value you provide is identical to the currentstate, as determined by anObject.iscomparison, React willskip re-rendering the component and its children.This is an optimization. Although in some cases React may still need to call your component before skipping the children, it shouldn’t affect your code.",
                        "Reactbatches state updates.It updates the screenafter all the event handlers have runand have called theirsetfunctions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can useflushSync.",
                        "Thesetfunction has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do.Learn more about removing Effect dependencies.",
                        "Calling thesetfunctionduring renderingis only allowed from within the currently rendering component. React will discard its output and immediately attempt to render it again with the new state. This pattern is rarely needed, but you can use it tostore information from the previous renders.See an example below.",
                        "In Strict Mode, React willcall your updater function twicein order tohelp you find accidental impurities.This is development-only behavior and does not affect production. If your updater function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored."
                    ]
                },
                {
                    "type": "p",
                    "text": "Thesetfunctiononly updates the state variable for thenextrender. If you read the state variable after calling thesetfunction,you will still get the old valuethat was on the screen before your call."
                },
                {
                    "type": "p",
                    "text": "If the new value you provide is identical to the currentstate, as determined by anObject.iscomparison, React willskip re-rendering the component and its children.This is an optimization. Although in some cases React may still need to call your component before skipping the children, it shouldn’t affect your code."
                },
                {
                    "type": "p",
                    "text": "Reactbatches state updates.It updates the screenafter all the event handlers have runand have called theirsetfunctions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can useflushSync."
                },
                {
                    "type": "p",
                    "text": "Thesetfunction has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do.Learn more about removing Effect dependencies."
                },
                {
                    "type": "p",
                    "text": "Calling thesetfunctionduring renderingis only allowed from within the currently rendering component. React will discard its output and immediately attempt to render it again with the new state. This pattern is rarely needed, but you can use it tostore information from the previous renders.See an example below."
                },
                {
                    "type": "p",
                    "text": "In Strict Mode, React willcall your updater function twicein order tohelp you find accidental impurities.This is development-only behavior and does not affect production. If your updater function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Adding state to a component"
                },
                {
                    "type": "p",
                    "text": "CalluseStateat the top level of your component to declare one or morestate variables."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';functionMyComponent(){const[age,setAge]=useState(42);const[name,setName]=useState('Taylor');// ..."
                },
                {
                    "type": "p",
                    "text": "The convention is to name state variables like[something, setSomething]usingarray destructuring."
                },
                {
                    "type": "p",
                    "text": "useStatereturns an array with exactly two items:"
                },
                {
                    "type": "list",
                    "items": [
                        "Thecurrent stateof this state variable, initially set to theinitial stateyou provided.",
                        "Thesetfunctionthat lets you change it to any other value in response to interaction."
                    ]
                },
                {
                    "type": "p",
                    "text": "To update what’s on the screen, call thesetfunction with some next state:"
                },
                {
                    "type": "code",
                    "code": "functionhandleClick(){setName('Robin');}"
                },
                {
                    "type": "p",
                    "text": "React will store the next state, render your component again with the new values, and update the UI."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Pitfall"
                },
                {
                    "type": "p",
                    "text": "Calling thesetfunctiondoes notchange the current state in the already executing code:"
                },
                {
                    "type": "code",
                    "code": "functionhandleClick(){setName('Robin');console.log(name);// Still \"Taylor\"!}"
                },
                {
                    "type": "p",
                    "text": "It only affects whatuseStatewill return starting from thenextrender."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Basic useState examples"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of4:Counter (number)"
                },
                {
                    "type": "p",
                    "text": "In this example, thecountstate variable holds a number. Clicking the button increments it."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionCounter(){const[count,setCount]=useState(0);functionhandleClick(){setCount(count+1);}return(<buttononClick={handleClick}>You pressed me{count}times</button>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Updating state based on the previous state"
                },
                {
                    "type": "p",
                    "text": "Suppose theageis42. This handler callssetAge(age + 1)three times:"
                },
                {
                    "type": "code",
                    "code": "functionhandleClick(){setAge(age+1);// setAge(42 + 1)setAge(age+1);// setAge(42 + 1)setAge(age+1);// setAge(42 + 1)}"
                },
                {
                    "type": "p",
                    "text": "However, after one click,agewill only be43rather than45! This is because calling thesetfunctiondoes not updatetheagestate variable in the already running code. So eachsetAge(age + 1)call becomessetAge(43)."
                },
                {
                    "type": "p",
                    "text": "To solve this problem,you may pass anupdater functiontosetAgeinstead of the next state:"
                },
                {
                    "type": "code",
                    "code": "functionhandleClick(){setAge(a=>a + 1);// setAge(42 => 43)setAge(a=>a + 1);// setAge(43 => 44)setAge(a=>a + 1);// setAge(44 => 45)}"
                },
                {
                    "type": "p",
                    "text": "Here,a => a + 1is your updater function. It takes thepending stateand calculates thenext statefrom it."
                },
                {
                    "type": "p",
                    "text": "React puts your updater functions in aqueue.Then, during the next render, it will call them in the same order:"
                },
                {
                    "type": "list",
                    "items": [
                        "a => a + 1will receive42as the pending state and return43as the next state.",
                        "a => a + 1will receive43as the pending state and return44as the next state.",
                        "a => a + 1will receive44as the pending state and return45as the next state."
                    ]
                },
                {
                    "type": "p",
                    "text": "There are no other queued updates, so React will store45as the current state in the end."
                },
                {
                    "type": "p",
                    "text": "By convention, it’s common to name the pending state argument for the first letter of the state variable name, likeaforage. However, you may also call it likeprevAgeor something else that you find clearer."
                },
                {
                    "type": "p",
                    "text": "React maycall your updaters twicein development to verify that they arepure."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Is using an updater always preferred?"
                },
                {
                    "type": "p",
                    "text": "You might hear a recommendation to always write code likesetAge(a => a + 1)if the state you’re setting is calculated from the previous state. There is no harm in it, but it is also not always necessary."
                },
                {
                    "type": "p",
                    "text": "In most cases, there is no difference between these two approaches. React always makes sure that for intentional user actions, like clicks, theagestate variable would be updated before the next click. This means there is no risk of a click handler seeing a “stale”ageat the beginning of the event handler."
                },
                {
                    "type": "p",
                    "text": "However, if you do multiple updates within the same event, updaters can be helpful. They’re also helpful if accessing the state variable itself is inconvenient (you might run into this when optimizing re-renders)."
                },
                {
                    "type": "p",
                    "text": "If you prefer consistency over slightly more verbose syntax, it’s reasonable to always write an updater if the state you’re setting is calculated from the previous state. If it’s calculated from the previous state of someotherstate variable, you might want to combine them into one object anduse a reducer."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "The difference between passing an updater and passing the next state directly"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of2:Passing the updater function"
                },
                {
                    "type": "p",
                    "text": "This example passes the updater function, so the “+3” button works."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionCounter(){const[age,setAge]=useState(42);functionincrement(){setAge(a=>a+1);}return(<><h1>Your age:{age}</h1><buttononClick={()=>{increment();increment();increment();}}>+3</button><buttononClick={()=>{increment();}}>+1</button></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Updating objects and arrays in state"
                },
                {
                    "type": "p",
                    "text": "You can put objects and arrays into state. In React, state is considered read-only, soyou shouldreplaceit rather thanmutateyour existing objects. For example, if you have aformobject in state, don’t mutate it:"
                },
                {
                    "type": "code",
                    "code": "// 🚩 Don't mutate an object in state like this:form.firstName='Taylor';"
                },
                {
                    "type": "p",
                    "text": "Instead, replace the whole object by creating a new one:"
                },
                {
                    "type": "code",
                    "code": "// ✅ Replace state with a new objectsetForm({...form,firstName:'Taylor'});"
                },
                {
                    "type": "p",
                    "text": "Readupdating objects in stateandupdating arrays in stateto learn more."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Examples of objects and arrays in state"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of4:Form (object)"
                },
                {
                    "type": "p",
                    "text": "In this example, theformstate variable holds an object. Each input has a change handler that callssetFormwith the next state of the entire form. The{ ...form }spread syntax ensures that the state object is replaced rather than mutated."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionForm(){const[form,setForm]=useState({firstName:'Barbara',lastName:'Hepworth',email:'bhepworth@sculpture.com',});return(<><label>First name:<inputvalue={form.firstName}onChange={e=>{setForm({...form,firstName:e.target.value});}}/></label><label>Last name:<inputvalue={form.lastName}onChange={e=>{setForm({...form,lastName:e.target.value});}}/></label><label>Email:<inputvalue={form.email}onChange={e=>{setForm({...form,email:e.target.value});}}/></label><p>{form.firstName}{' '}{form.lastName}{' '}({form.email})</p></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Avoiding recreating the initial state"
                },
                {
                    "type": "p",
                    "text": "React saves the initial state once and ignores it on the next renders."
                },
                {
                    "type": "code",
                    "code": "functionTodoList(){const[todos,setTodos]=useState(createInitialTodos());// ..."
                },
                {
                    "type": "p",
                    "text": "Although the result ofcreateInitialTodos()is only used for the initial render, you’re still calling this function on every render. This can be wasteful if it’s creating large arrays or performing expensive calculations."
                },
                {
                    "type": "p",
                    "text": "To solve this, you maypass it as aninitializerfunctiontouseStateinstead:"
                },
                {
                    "type": "code",
                    "code": "functionTodoList(){const[todos,setTodos]=useState(createInitialTodos);// ..."
                },
                {
                    "type": "p",
                    "text": "Notice that you’re passingcreateInitialTodos, which is thefunction itself, and notcreateInitialTodos(), which is the result of calling it. If you pass a function touseState, React will only call it during initialization."
                },
                {
                    "type": "p",
                    "text": "React maycall your initializers twicein development to verify that they arepure."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "The difference between passing an initializer and passing the initial state directly"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of2:Passing the initializer function"
                },
                {
                    "type": "p",
                    "text": "This example passes the initializer function, so thecreateInitialTodosfunction only runs during initialization. It does not run when component re-renders, such as when you type into the input."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';functioncreateInitialTodos(){constinitialTodos=[];for(leti=0;i<50;i++){initialTodos.push({id:i,text:'Item '+(i+1)});}returninitialTodos;}exportdefaultfunctionTodoList(){const[todos,setTodos]=useState(createInitialTodos);const[text,setText]=useState('');return(<><inputvalue={text}onChange={e=>setText(e.target.value)}/><buttononClick={()=>{setText('');setTodos([{id:todos.length,text:text},...todos]);}}>Add</button><ul>{todos.map(item=>(<likey={item.id}>{item.text}</li>))}</ul></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Resetting state with a key"
                },
                {
                    "type": "p",
                    "text": "You’ll often encounter thekeyattribute whenrendering lists.However, it also serves another purpose."
                },
                {
                    "type": "p",
                    "text": "You canreset a component’s state by passing a differentkeyto a component.In this example, the Reset button changes theversionstate variable, which we pass as akeyto theForm. When thekeychanges, React re-creates theFormcomponent (and all of its children) from scratch, so its state gets reset."
                },
                {
                    "type": "p",
                    "text": "Readpreserving and resetting stateto learn more."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionApp(){const[version,setVersion]=useState(0);functionhandleReset(){setVersion(version+1);}return(<><buttononClick={handleReset}>Reset</button><Formkey={version}/></>);}functionForm(){const[name,setName]=useState('Taylor');return(<><inputvalue={name}onChange={e=>setName(e.target.value)}/><p>Hello,{name}.</p></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Storing information from previous renders"
                },
                {
                    "type": "p",
                    "text": "Usually, you will update state in event handlers. However, in rare cases you might want to adjust state in response to rendering — for example, you might want to change a state variable when a prop changes."
                },
                {
                    "type": "p",
                    "text": "In most cases, you don’t need this:"
                },
                {
                    "type": "list",
                    "items": [
                        "If the value you need can be computed entirely from the current props or other state,remove that redundant state altogether.If you’re worried about recomputing too often, theuseMemoHookcan help.",
                        "If you want to reset the entire component tree’s state,pass a differentkeyto your component.",
                        "If you can, update all the relevant state in the event handlers."
                    ]
                },
                {
                    "type": "p",
                    "text": "In the rare case that none of these apply, there is a pattern you can use to update state based on the values that have been rendered so far, by calling asetfunction while your component is rendering."
                },
                {
                    "type": "p",
                    "text": "Here’s an example. ThisCountLabelcomponent displays thecountprop passed to it:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionCountLabel({count}){return<h1>{count}</h1>}"
                },
                {
                    "type": "p",
                    "text": "Say you want to show whether the counter hasincreased or decreasedsince the last change. Thecountprop doesn’t tell you this — you need to keep track of its previous value. Add theprevCountstate variable to track it. Add another state variable calledtrendto hold whether the count has increased or decreased. CompareprevCountwithcount, and if they’re not equal, update bothprevCountandtrend. Now you can show both the current count prop andhow it has changed since the last render."
                },
                {
                    "type": "code",
                    "code": "import{useState}from'react';exportdefaultfunctionCountLabel({count}){const[prevCount,setPrevCount]=useState(count);const[trend,setTrend]=useState(null);if(prevCount!==count){setPrevCount(count);setTrend(count>prevCount?'increasing':'decreasing');}return(<><h1>{count}</h1>{trend&&<p>The count is{trend}</p>}</>);}"
                },
                {
                    "type": "p",
                    "text": "Note that if you call asetfunction while rendering, it must be inside a condition likeprevCount !== count, and there must be a call likesetPrevCount(count)inside of the condition. Otherwise, your component would re-render in a loop until it crashes. Also, you can only update the state of thecurrently renderingcomponent like this. Calling thesetfunction ofanothercomponent during rendering is an error. Finally, yoursetcall should stillupdate state without mutation— this doesn’t mean you can break other rules ofpure functions."
                },
                {
                    "type": "p",
                    "text": "This pattern can be hard to understand and is usually best avoided. However, it’s better than updating state in an effect. When you call thesetfunction during render, React will re-render that component immediately after your component exits with areturnstatement, and before rendering the children. This way, children don’t need to render twice. The rest of your component function will still execute (and the result will be thrown away). If your condition is below all the Hook calls, you may add an earlyreturn;to restart rendering earlier."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’ve updated the state, but logging gives me the old value"
                },
                {
                    "type": "p",
                    "text": "Calling thesetfunctiondoes not change state in the running code:"
                },
                {
                    "type": "code",
                    "code": "functionhandleClick(){console.log(count);// 0setCount(count+1);// Request a re-render with 1console.log(count);// Still 0!setTimeout(()=>{console.log(count);// Also 0!},5000);}"
                },
                {
                    "type": "p",
                    "text": "This is becausestates behaves like a snapshot.Updating state requests another render with the new state value, but does not affect thecountJavaScript variable in your already-running event handler."
                },
                {
                    "type": "p",
                    "text": "If you need to use the next state, you can save it in a variable before passing it to thesetfunction:"
                },
                {
                    "type": "code",
                    "code": "constnextCount=count+1;setCount(nextCount);console.log(count);// 0console.log(nextCount);// 1"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’ve updated the state, but the screen doesn’t update"
                },
                {
                    "type": "p",
                    "text": "React willignore your update if the next state is equal to the previous state,as determined by anObject.iscomparison. This usually happens when you change an object or an array in state directly:"
                },
                {
                    "type": "code",
                    "code": "obj.x=10;// 🚩 Wrong: mutating existing objectsetObj(obj);// 🚩 Doesn't do anything"
                },
                {
                    "type": "p",
                    "text": "You mutated an existingobjobject and passed it back tosetObj, so React ignored the update. To fix this, you need to ensure that you’re alwaysreplacingobjects and arrays in state instead ofmutatingthem:"
                },
                {
                    "type": "code",
                    "code": "// ✅ Correct: creating a new objectsetObj({...obj,x:10});"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’m getting an error: “Too many re-renders”"
                },
                {
                    "type": "p",
                    "text": "You might get an error that says:Too many re-renders. React limits the number of renders to prevent an infinite loop.Typically, this means that you’re unconditionally setting stateduring render, so your component enters a loop: render, set state (which causes a render), render, set state (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:"
                },
                {
                    "type": "code",
                    "code": "// 🚩 Wrong: calls the handler during renderreturn<buttononClick={handleClick()}>Click me</button>// ✅ Correct: passes down the event handlerreturn<buttononClick={handleClick}>Click me</button>// ✅ Correct: passes down an inline functionreturn<buttononClick={(e)=>handleClick(e)}>Click me</button>"
                },
                {
                    "type": "p",
                    "text": "If you can’t find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specificsetfunction call responsible for the error."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "My initializer or updater function runs twice"
                },
                {
                    "type": "p",
                    "text": "InStrict Mode, React will call some of your functions twice instead of once:"
                },
                {
                    "type": "code",
                    "code": "functionTodoList(){// This component function will run twice for every render.const[todos,setTodos]=useState(()=>{// This initializer function will run twice during initialization.returncreateTodos();});functionhandleClick(){setTodos(prevTodos=>{// This updater function will run twice for every click.return[...prevTodos,createTodo()];});}// ..."
                },
                {
                    "type": "p",
                    "text": "This is expected and shouldn’t break your code."
                },
                {
                    "type": "p",
                    "text": "Thisdevelopment-onlybehavior helps youkeep components pure.React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and updater functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice the mistakes."
                },
                {
                    "type": "p",
                    "text": "For example, this impure updater function mutates an array in state:"
                },
                {
                    "type": "code",
                    "code": "setTodos(prevTodos=>{// 🚩 Mistake: mutating stateprevTodos.push(createTodo());});"
                },
                {
                    "type": "p",
                    "text": "Because React calls your updater function twice, you’ll see the todo was added twice, so you’ll know that there is a mistake. In this example, you can fix the mistake byreplacing the array instead of mutating it:"
                },
                {
                    "type": "code",
                    "code": "setTodos(prevTodos=>{// ✅ Correct: replacing with new statereturn[...prevTodos,createTodo()];});"
                },
                {
                    "type": "p",
                    "text": "Now that this updater function is pure, calling it an extra time doesn’t make a difference in behavior. This is why React calling it twice helps you find mistakes.Only component, initializer, and updater functions need to be pure.Event handlers don’t need to be pure, so React will never call your event handlers twice."
                },
                {
                    "type": "p",
                    "text": "Readkeeping components pureto learn more."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’m trying to set state to a function, but it gets called instead"
                },
                {
                    "type": "p",
                    "text": "You can’t put a function into state like this:"
                },
                {
                    "type": "code",
                    "code": "const[fn,setFn]=useState(someFunction);functionhandleClick(){setFn(someOtherFunction);}"
                },
                {
                    "type": "p",
                    "text": "Because you’re passing a function, React assumes thatsomeFunctionis aninitializer function, and thatsomeOtherFunctionis anupdater function, so it tries to call them and store the result. To actuallystorea function, you have to put() =>before them in both cases. Then React will store the functions you pass."
                },
                {
                    "type": "code",
                    "code": "const[fn,setFn]=useState(()=>someFunction);functionhandleClick(){setFn(()=>someOtherFunction);}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/useSyncExternalStore",
            "title": "useSyncExternalStore – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "useSyncExternalStore"
                },
                {
                    "type": "p",
                    "text": "useSyncExternalStoreis a React Hook that lets you subscribe to an external store."
                },
                {
                    "type": "code",
                    "code": "constsnapshot=useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot?)"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceuseSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)",
                        "useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)",
                        "UsageSubscribing to an external storeSubscribing to a browser APIExtracting the logic to a custom HookAdding support for server rendering",
                        "Subscribing to an external store",
                        "Subscribing to a browser API",
                        "Extracting the logic to a custom Hook",
                        "Adding support for server rendering",
                        "TroubleshootingI’m getting an error: “The result ofgetSnapshotshould be cached”Mysubscribefunction gets called after every re-render",
                        "I’m getting an error: “The result ofgetSnapshotshould be cached”",
                        "Mysubscribefunction gets called after every re-render"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Subscribing to an external store",
                        "Subscribing to a browser API",
                        "Extracting the logic to a custom Hook",
                        "Adding support for server rendering"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "I’m getting an error: “The result ofgetSnapshotshould be cached”",
                        "Mysubscribefunction gets called after every re-render"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)"
                },
                {
                    "type": "p",
                    "text": "CalluseSyncExternalStoreat the top level of your component to read a value from an external data store."
                },
                {
                    "type": "code",
                    "code": "import{useSyncExternalStore}from'react';import{todosStore}from'./todoStore.js';functionTodosApp(){consttodos=useSyncExternalStore(todosStore.subscribe,todosStore.getSnapshot);// ...}"
                },
                {
                    "type": "p",
                    "text": "It returns the snapshot of the data in the store. You need to pass two functions as arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "Thesubscribefunction should subscribe to the store and return a function that unsubscribes.",
                        "ThegetSnapshotfunction should read a snapshot of the data from the store."
                    ]
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "subscribe: A function that takes a singlecallbackargument and subscribes it to the store. When the store changes, it should invoke the providedcallback, which will cause React to re-callgetSnapshotand (if needed) re-render the component. Thesubscribefunction should return a function that cleans up the subscription.",
                        "getSnapshot: A function that returns a snapshot of the data in the store that’s needed by the component. While the store has not changed, repeated calls togetSnapshotmust return the same value. If the store changes and the returned value is different (as compared byObject.is), React re-renders the component.",
                        "optionalgetServerSnapshot: A function that returns the initial snapshot of the data in the store. It will be used only during server rendering and during hydration of server-rendered content on the client. The server snapshot must be the same between the client and the server, and is usually serialized and passed from the server to the client. If you omit this argument, rendering the component on the server will throw an error."
                    ]
                },
                {
                    "type": "p",
                    "text": "subscribe: A function that takes a singlecallbackargument and subscribes it to the store. When the store changes, it should invoke the providedcallback, which will cause React to re-callgetSnapshotand (if needed) re-render the component. Thesubscribefunction should return a function that cleans up the subscription."
                },
                {
                    "type": "p",
                    "text": "getSnapshot: A function that returns a snapshot of the data in the store that’s needed by the component. While the store has not changed, repeated calls togetSnapshotmust return the same value. If the store changes and the returned value is different (as compared byObject.is), React re-renders the component."
                },
                {
                    "type": "p",
                    "text": "optionalgetServerSnapshot: A function that returns the initial snapshot of the data in the store. It will be used only during server rendering and during hydration of server-rendered content on the client. The server snapshot must be the same between the client and the server, and is usually serialized and passed from the server to the client. If you omit this argument, rendering the component on the server will throw an error."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "The current snapshot of the store which you can use in your rendering logic."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "The store snapshot returned bygetSnapshotmust be immutable. If the underlying store has mutable data, return a new immutable snapshot if the data has changed. Otherwise, return a cached last snapshot.",
                        "If a differentsubscribefunction is passed during a re-render, React will re-subscribe to the store using the newly passedsubscribefunction. You can prevent this by declaringsubscribeoutside the component.",
                        "If the store is mutated during anon-blocking Transition update, React will fall back to performing that update as blocking. Specifically, for every Transition update, React will callgetSnapshota second time just before applying changes to the DOM. If it returns a different value than when it was called originally, React will restart the update from scratch, this time applying it as a blocking update, to ensure that every component on screen is reflecting the same version of the store.",
                        "It’s not recommended tosuspenda render based on a store value returned byuseSyncExternalStore. The reason is that mutations to the external store cannot be marked asnon-blocking Transition updates, so they will trigger the nearestSuspensefallback, replacing already-rendered content on screen with a loading spinner, which typically makes a poor UX.For example, the following are discouraged:constLazyProductDetailPage=lazy(()=>import('./ProductDetailPage.js'));functionShoppingApp(){constselectedProductId=useSyncExternalStore(...);// ❌ Calling `use` with a Promise dependent on `selectedProductId`constdata=use(fetchItem(selectedProductId))// ❌ Conditionally rendering a lazy component based on `selectedProductId`returnselectedProductId!=null?<LazyProductDetailPage/>:<FeaturedProducts/>;}"
                    ]
                },
                {
                    "type": "p",
                    "text": "The store snapshot returned bygetSnapshotmust be immutable. If the underlying store has mutable data, return a new immutable snapshot if the data has changed. Otherwise, return a cached last snapshot."
                },
                {
                    "type": "p",
                    "text": "If a differentsubscribefunction is passed during a re-render, React will re-subscribe to the store using the newly passedsubscribefunction. You can prevent this by declaringsubscribeoutside the component."
                },
                {
                    "type": "p",
                    "text": "If the store is mutated during anon-blocking Transition update, React will fall back to performing that update as blocking. Specifically, for every Transition update, React will callgetSnapshota second time just before applying changes to the DOM. If it returns a different value than when it was called originally, React will restart the update from scratch, this time applying it as a blocking update, to ensure that every component on screen is reflecting the same version of the store."
                },
                {
                    "type": "p",
                    "text": "It’s not recommended tosuspenda render based on a store value returned byuseSyncExternalStore. The reason is that mutations to the external store cannot be marked asnon-blocking Transition updates, so they will trigger the nearestSuspensefallback, replacing already-rendered content on screen with a loading spinner, which typically makes a poor UX."
                },
                {
                    "type": "p",
                    "text": "For example, the following are discouraged:"
                },
                {
                    "type": "code",
                    "code": "constLazyProductDetailPage=lazy(()=>import('./ProductDetailPage.js'));functionShoppingApp(){constselectedProductId=useSyncExternalStore(...);// ❌ Calling `use` with a Promise dependent on `selectedProductId`constdata=use(fetchItem(selectedProductId))// ❌ Conditionally rendering a lazy component based on `selectedProductId`returnselectedProductId!=null?<LazyProductDetailPage/>:<FeaturedProducts/>;}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Subscribing to an external store"
                },
                {
                    "type": "p",
                    "text": "Most of your React components will only read data from theirprops,state,andcontext.However, sometimes a component needs to read some data from some store outside of React that changes over time. This includes:"
                },
                {
                    "type": "list",
                    "items": [
                        "Third-party state management libraries that hold state outside of React.",
                        "Browser APIs that expose a mutable value and events to subscribe to its changes."
                    ]
                },
                {
                    "type": "p",
                    "text": "CalluseSyncExternalStoreat the top level of your component to read a value from an external data store."
                },
                {
                    "type": "code",
                    "code": "import{useSyncExternalStore}from'react';import{todosStore}from'./todoStore.js';functionTodosApp(){consttodos=useSyncExternalStore(todosStore.subscribe,todosStore.getSnapshot);// ...}"
                },
                {
                    "type": "p",
                    "text": "It returns thesnapshotof the data in the store. You need to pass two functions as arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "Thesubscribefunctionshould subscribe to the store and return a function that unsubscribes.",
                        "ThegetSnapshotfunctionshould read a snapshot of the data from the store."
                    ]
                },
                {
                    "type": "p",
                    "text": "React will use these functions to keep your component subscribed to the store and re-render it on changes."
                },
                {
                    "type": "p",
                    "text": "For example, in the sandbox below,todosStoreis implemented as an external store that stores data outside of React. TheTodosAppcomponent connects to that external store with theuseSyncExternalStoreHook."
                },
                {
                    "type": "code",
                    "code": "import{useSyncExternalStore}from'react';import{todosStore}from'./todoStore.js';exportdefaultfunctionTodosApp(){consttodos=useSyncExternalStore(todosStore.subscribe,todosStore.getSnapshot);return(<><buttononClick={()=>todosStore.addTodo()}>Add todo</button><hr/><ul>{todos.map(todo=>(<likey={todo.id}>{todo.text}</li>))}</ul></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "When possible, we recommend using built-in React state withuseStateanduseReducerinstead. TheuseSyncExternalStoreAPI is mostly useful if you need to integrate with existing non-React code."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Subscribing to a browser API"
                },
                {
                    "type": "p",
                    "text": "Another reason to adduseSyncExternalStoreis when you want to subscribe to some value exposed by the browser that changes over time. For example, suppose that you want your component to display whether the network connection is active. The browser exposes this information via a property callednavigator.onLine."
                },
                {
                    "type": "p",
                    "text": "This value can change without React’s knowledge, so you should read it withuseSyncExternalStore."
                },
                {
                    "type": "code",
                    "code": "import{useSyncExternalStore}from'react';functionChatIndicator(){constisOnline=useSyncExternalStore(subscribe,getSnapshot);// ...}"
                },
                {
                    "type": "p",
                    "text": "To implement thegetSnapshotfunction, read the current value from the browser API:"
                },
                {
                    "type": "code",
                    "code": "functiongetSnapshot(){returnnavigator.onLine;}"
                },
                {
                    "type": "p",
                    "text": "Next, you need to implement thesubscribefunction. For example, whennavigator.onLinechanges, the browser fires theonlineandofflineevents on thewindowobject. You need to subscribe thecallbackargument to the corresponding events, and then return a function that cleans up the subscriptions:"
                },
                {
                    "type": "code",
                    "code": "functionsubscribe(callback){window.addEventListener('online',callback);window.addEventListener('offline',callback);return()=>{window.removeEventListener('online',callback);window.removeEventListener('offline',callback);};}"
                },
                {
                    "type": "p",
                    "text": "Now React knows how to read the value from the externalnavigator.onLineAPI and how to subscribe to its changes. Disconnect your device from the network and notice that the component re-renders in response:"
                },
                {
                    "type": "code",
                    "code": "import{useSyncExternalStore}from'react';exportdefaultfunctionChatIndicator(){constisOnline=useSyncExternalStore(subscribe,getSnapshot);return<h1>{isOnline?'✅ Online':'❌ Disconnected'}</h1>;}functiongetSnapshot(){returnnavigator.onLine;}functionsubscribe(callback){window.addEventListener('online',callback);window.addEventListener('offline',callback);return()=>{window.removeEventListener('online',callback);window.removeEventListener('offline',callback);};}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Extracting the logic to a custom Hook"
                },
                {
                    "type": "p",
                    "text": "Usually you won’t writeuseSyncExternalStoredirectly in your components. Instead, you’ll typically call it from your own custom Hook. This lets you use the same external store from different components."
                },
                {
                    "type": "p",
                    "text": "For example, this customuseOnlineStatusHook tracks whether the network is online:"
                },
                {
                    "type": "code",
                    "code": "import{useSyncExternalStore}from'react';exportfunctionuseOnlineStatus(){constisOnline=useSyncExternalStore(subscribe,getSnapshot);returnisOnline;}functiongetSnapshot(){// ...}functionsubscribe(callback){// ...}"
                },
                {
                    "type": "p",
                    "text": "Now different components can calluseOnlineStatuswithout repeating the underlying implementation:"
                },
                {
                    "type": "code",
                    "code": "import{useOnlineStatus}from'./useOnlineStatus.js';functionStatusBar(){constisOnline=useOnlineStatus();return<h1>{isOnline?'✅ Online':'❌ Disconnected'}</h1>;}functionSaveButton(){constisOnline=useOnlineStatus();functionhandleSaveClick(){console.log('✅ Progress saved');}return(<buttondisabled={!isOnline}onClick={handleSaveClick}>{isOnline?'Save progress':'Reconnecting...'}</button>);}exportdefaultfunctionApp(){return(<><SaveButton/><StatusBar/></>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Adding support for server rendering"
                },
                {
                    "type": "p",
                    "text": "If your React app usesserver rendering,your React components will also run outside the browser environment to generate the initial HTML. This creates a few challenges when connecting to an external store:"
                },
                {
                    "type": "list",
                    "items": [
                        "If you’re connecting to a browser-only API, it won’t work because it does not exist on the server.",
                        "If you’re connecting to a third-party data store, you’ll need its data to match between the server and client."
                    ]
                },
                {
                    "type": "p",
                    "text": "To solve these issues, pass agetServerSnapshotfunction as the third argument touseSyncExternalStore:"
                },
                {
                    "type": "code",
                    "code": "import{useSyncExternalStore}from'react';exportfunctionuseOnlineStatus(){constisOnline=useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);returnisOnline;}functiongetSnapshot(){returnnavigator.onLine;}functiongetServerSnapshot(){returntrue;// Always show \"Online\" for server-generated HTML}functionsubscribe(callback){// ...}"
                },
                {
                    "type": "p",
                    "text": "ThegetServerSnapshotfunction is similar togetSnapshot, but it runs only in two situations:"
                },
                {
                    "type": "list",
                    "items": [
                        "It runs on the server when generating the HTML.",
                        "It runs on the client duringhydration, i.e. when React takes the server HTML and makes it interactive."
                    ]
                },
                {
                    "type": "p",
                    "text": "This lets you provide the initial snapshot value which will be used before the app becomes interactive. If there is no meaningful initial value for the server rendering, omit this argument toforce rendering on the client."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Make sure thatgetServerSnapshotreturns the same exact data on the initial client render as it returned on the server. For example, ifgetServerSnapshotreturned some prepopulated store content on the server, you need to transfer this content to the client. One way to do this is to emit a<script>tag during server rendering that sets a global likewindow.MY_STORE_DATA, and read from that global on the client ingetServerSnapshot. Your external store should provide instructions on how to do that."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I’m getting an error: “The result ofgetSnapshotshould be cached”"
                },
                {
                    "type": "p",
                    "text": "This error means yourgetSnapshotfunction returns a new object every time it’s called, for example:"
                },
                {
                    "type": "code",
                    "code": "functiongetSnapshot(){// 🔴 Do not return always different objects from getSnapshotreturn{todos:myStore.todos};}"
                },
                {
                    "type": "p",
                    "text": "React will re-render the component ifgetSnapshotreturn value is different from the last time. This is why, if you always return a different value, you will enter an infinite loop and get this error."
                },
                {
                    "type": "p",
                    "text": "YourgetSnapshotobject should only return a different object if something has actually changed. If your store contains immutable data, you can return that data directly:"
                },
                {
                    "type": "code",
                    "code": "functiongetSnapshot(){// ✅ You can return immutable datareturnmyStore.todos;}"
                },
                {
                    "type": "p",
                    "text": "If your store data is mutable, yourgetSnapshotfunction should return an immutable snapshot of it. This means itdoesneed to create new objects, but it shouldn’t do this for every single call. Instead, it should store the last calculated snapshot, and return the same snapshot as the last time if the data in the store has not changed. How you determine whether mutable data has changed depends on your mutable store."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Mysubscribefunction gets called after every re-render"
                },
                {
                    "type": "p",
                    "text": "Thissubscribefunction is definedinsidea component so it is different on every re-render:"
                },
                {
                    "type": "code",
                    "code": "functionChatIndicator(){constisOnline=useSyncExternalStore(subscribe,getSnapshot);// 🚩 Always a different function, so React will resubscribe on every re-renderfunctionsubscribe(){// ...}// ...}"
                },
                {
                    "type": "p",
                    "text": "React will resubscribe to your store if you pass a differentsubscribefunction between re-renders. If this causes performance issues and you’d like to avoid resubscribing, move thesubscribefunction outside:"
                },
                {
                    "type": "code",
                    "code": "functionChatIndicator(){constisOnline=useSyncExternalStore(subscribe,getSnapshot);// ...}// ✅ Always the same function, so React won't need to resubscribefunctionsubscribe(){// ...}"
                },
                {
                    "type": "p",
                    "text": "Alternatively, wrapsubscribeintouseCallbackto only resubscribe when some argument changes:"
                },
                {
                    "type": "code",
                    "code": "functionChatIndicator({userId}){constisOnline=useSyncExternalStore(subscribe,getSnapshot);// ✅ Same function as long as userId doesn't changeconstsubscribe=useCallback(()=>{// ...},[userId]);// ...}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/react/useTransition",
            "title": "useTransition – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "useTransition"
                },
                {
                    "type": "p",
                    "text": "useTransitionis a React Hook that lets you update the state without blocking the UI."
                },
                {
                    "type": "code",
                    "code": "const[isPending,startTransition]=useTransition()"
                },
                {
                    "type": "list",
                    "items": [
                        "ReferenceuseTransition()startTransitionfunction",
                        "useTransition()",
                        "startTransitionfunction",
                        "UsageMarking a state update as a non-blocking TransitionUpdating the parent component in a TransitionDisplaying a pending visual state during the TransitionPreventing unwanted loading indicatorsBuilding a Suspense-enabled routerDisplaying an error to users with an error boundary",
                        "Marking a state update as a non-blocking Transition",
                        "Updating the parent component in a Transition",
                        "Displaying a pending visual state during the Transition",
                        "Preventing unwanted loading indicators",
                        "Building a Suspense-enabled router",
                        "Displaying an error to users with an error boundary",
                        "TroubleshootingUpdating an input in a Transition doesn’t workReact doesn’t treat my state update as a TransitionI want to calluseTransitionfrom outside a componentThe function I pass tostartTransitionexecutes immediately",
                        "Updating an input in a Transition doesn’t work",
                        "React doesn’t treat my state update as a Transition",
                        "I want to calluseTransitionfrom outside a component",
                        "The function I pass tostartTransitionexecutes immediately"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "useTransition()",
                        "startTransitionfunction"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Marking a state update as a non-blocking Transition",
                        "Updating the parent component in a Transition",
                        "Displaying a pending visual state during the Transition",
                        "Preventing unwanted loading indicators",
                        "Building a Suspense-enabled router",
                        "Displaying an error to users with an error boundary"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Updating an input in a Transition doesn’t work",
                        "React doesn’t treat my state update as a Transition",
                        "I want to calluseTransitionfrom outside a component",
                        "The function I pass tostartTransitionexecutes immediately"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "useTransition()"
                },
                {
                    "type": "p",
                    "text": "CalluseTransitionat the top level of your component to mark some state updates as Transitions."
                },
                {
                    "type": "code",
                    "code": "import{useTransition}from'react';functionTabContainer(){const[isPending,startTransition]=useTransition();// ...}"
                },
                {
                    "type": "p",
                    "text": "See more examples below."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "p",
                    "text": "useTransitiondoes not take any parameters."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "useTransitionreturns an array with exactly two items:"
                },
                {
                    "type": "list",
                    "items": [
                        "TheisPendingflag that tells you whether there is a pending Transition.",
                        "ThestartTransitionfunctionthat lets you mark a state update as a Transition."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "startTransitionfunction"
                },
                {
                    "type": "p",
                    "text": "ThestartTransitionfunction returned byuseTransitionlets you mark a state update as a Transition."
                },
                {
                    "type": "code",
                    "code": "functionTabContainer(){const[isPending,startTransition]=useTransition();const[tab,setTab]=useState('about');functionselectTab(nextTab){startTransition(()=>{setTab(nextTab);});}// ...}"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Parameters"
                },
                {
                    "type": "list",
                    "items": [
                        "scope: A function that updates some state by calling one or moresetfunctions.React immediately callsscopewith no parameters and marks all state updates scheduled synchronously during thescopefunction call as Transitions. They will benon-blockingandwill not display unwanted loading indicators."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Returns"
                },
                {
                    "type": "p",
                    "text": "startTransitiondoes not return anything."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "useTransitionis a Hook, so it can only be called inside components or custom Hooks. If you need to start a Transition somewhere else (for example, from a data library), call the standalonestartTransitioninstead.",
                        "You can wrap an update into a Transition only if you have access to thesetfunction of that state. If you want to start a Transition in response to some prop or a custom Hook value, tryuseDeferredValueinstead.",
                        "The function you pass tostartTransitionmust be synchronous. React immediately executes this function, marking all state updates that happen while it executes as Transitions. If you try to perform more state updates later (for example, in a timeout), they won’t be marked as Transitions.",
                        "ThestartTransitionfunction has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do.Learn more about removing Effect dependencies.",
                        "A state update marked as a Transition will be interrupted by other state updates. For example, if you update a chart component inside a Transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input update.",
                        "Transition updates can’t be used to control text inputs.",
                        "If there are multiple ongoing Transitions, React currently batches them together. This is a limitation that will likely be removed in a future release."
                    ]
                },
                {
                    "type": "p",
                    "text": "useTransitionis a Hook, so it can only be called inside components or custom Hooks. If you need to start a Transition somewhere else (for example, from a data library), call the standalonestartTransitioninstead."
                },
                {
                    "type": "p",
                    "text": "You can wrap an update into a Transition only if you have access to thesetfunction of that state. If you want to start a Transition in response to some prop or a custom Hook value, tryuseDeferredValueinstead."
                },
                {
                    "type": "p",
                    "text": "The function you pass tostartTransitionmust be synchronous. React immediately executes this function, marking all state updates that happen while it executes as Transitions. If you try to perform more state updates later (for example, in a timeout), they won’t be marked as Transitions."
                },
                {
                    "type": "p",
                    "text": "ThestartTransitionfunction has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do.Learn more about removing Effect dependencies."
                },
                {
                    "type": "p",
                    "text": "A state update marked as a Transition will be interrupted by other state updates. For example, if you update a chart component inside a Transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input update."
                },
                {
                    "type": "p",
                    "text": "Transition updates can’t be used to control text inputs."
                },
                {
                    "type": "p",
                    "text": "If there are multiple ongoing Transitions, React currently batches them together. This is a limitation that will likely be removed in a future release."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Marking a state update as a non-blocking Transition"
                },
                {
                    "type": "p",
                    "text": "CalluseTransitionat the top level of your component to mark state updates as non-blockingTransitions."
                },
                {
                    "type": "code",
                    "code": "import{useState,useTransition}from'react';functionTabContainer(){const[isPending,startTransition]=useTransition();// ...}"
                },
                {
                    "type": "p",
                    "text": "useTransitionreturns an array with exactly two items:"
                },
                {
                    "type": "list",
                    "items": [
                        "TheisPendingflagthat tells you whether there is a pending Transition.",
                        "ThestartTransitionfunctionthat lets you mark a state update as a Transition."
                    ]
                },
                {
                    "type": "p",
                    "text": "You can then mark a state update as a Transition like this:"
                },
                {
                    "type": "code",
                    "code": "functionTabContainer(){const[isPending,startTransition]=useTransition();const[tab,setTab]=useState('about');functionselectTab(nextTab){startTransition(()=>{setTab(nextTab);});}// ...}"
                },
                {
                    "type": "p",
                    "text": "Transitions let you keep the user interface updates responsive even on slow devices."
                },
                {
                    "type": "p",
                    "text": "With a Transition, your UI stays responsive in the middle of a re-render. For example, if the user clicks a tab but then change their mind and click another tab, they can do that without waiting for the first re-render to finish."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "The difference between useTransition and regular state updates"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Example1of2:Updating the current tab in a Transition"
                },
                {
                    "type": "p",
                    "text": "In this example, the “Posts” tab isartificially slowed downso that it takes at least a second to render."
                },
                {
                    "type": "p",
                    "text": "Click “Posts” and then immediately click “Contact”. Notice that this interrupts the slow render of “Posts”. The “Contact” tab shows immediately. Because this state update is marked as a Transition, a slow re-render did not freeze the user interface."
                },
                {
                    "type": "code",
                    "code": "import{useState,useTransition}from'react';importTabButtonfrom'./TabButton.js';importAboutTabfrom'./AboutTab.js';importPostsTabfrom'./PostsTab.js';importContactTabfrom'./ContactTab.js';exportdefaultfunctionTabContainer(){const[isPending,startTransition]=useTransition();const[tab,setTab]=useState('about');functionselectTab(nextTab){startTransition(()=>{setTab(nextTab);});}return(<><TabButtonisActive={tab==='about'}onClick={()=>selectTab('about')}>About</TabButton><TabButtonisActive={tab==='posts'}onClick={()=>selectTab('posts')}>Posts (slow)</TabButton><TabButtonisActive={tab==='contact'}onClick={()=>selectTab('contact')}>Contact</TabButton><hr/>{tab==='about'&&<AboutTab/>}{tab==='posts'&&<PostsTab/>}{tab==='contact'&&<ContactTab/>}</>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Updating the parent component in a Transition"
                },
                {
                    "type": "p",
                    "text": "You can update a parent component’s state from theuseTransitioncall, too. For example, thisTabButtoncomponent wraps itsonClicklogic in a Transition:"
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionTabButton({children,isActive,onClick}){const[isPending,startTransition]=useTransition();if(isActive){return<b>{children}</b>}return(<buttononClick={()=>{startTransition(()=>{onClick();});}}>{children}</button>);}"
                },
                {
                    "type": "p",
                    "text": "Because the parent component updates its state inside theonClickevent handler, that state update gets marked as a Transition. This is why, like in the earlier example, you can click on “Posts” and then immediately click “Contact”. Updating the selected tab is marked as a Transition, so it does not block user interactions."
                },
                {
                    "type": "code",
                    "code": "import{useTransition}from'react';exportdefaultfunctionTabButton({children,isActive,onClick}){const[isPending,startTransition]=useTransition();if(isActive){return<b>{children}</b>}return(<buttononClick={()=>{startTransition(()=>{onClick();});}}>{children}</button>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Displaying a pending visual state during the Transition"
                },
                {
                    "type": "p",
                    "text": "You can use theisPendingboolean value returned byuseTransitionto indicate to the user that a Transition is in progress. For example, the tab button can have a special “pending” visual state:"
                },
                {
                    "type": "code",
                    "code": "functionTabButton({children,isActive,onClick}){const[isPending,startTransition]=useTransition();// ...if(isPending){return<bclassName=\"pending\">{children}</b>;}// ..."
                },
                {
                    "type": "p",
                    "text": "Notice how clicking “Posts” now feels more responsive because the tab button itself updates right away:"
                },
                {
                    "type": "code",
                    "code": "import{useTransition}from'react';exportdefaultfunctionTabButton({children,isActive,onClick}){const[isPending,startTransition]=useTransition();if(isActive){return<b>{children}</b>}if(isPending){return<bclassName=\"pending\">{children}</b>;}return(<buttononClick={()=>{startTransition(()=>{onClick();});}}>{children}</button>);}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Preventing unwanted loading indicators"
                },
                {
                    "type": "p",
                    "text": "In this example, thePostsTabcomponent fetches some data using aSuspense-enableddata source. When you click the “Posts” tab, thePostsTabcomponentsuspends, causing the closest loading fallback to appear:"
                },
                {
                    "type": "code",
                    "code": "import{Suspense,useState}from'react';importTabButtonfrom'./TabButton.js';importAboutTabfrom'./AboutTab.js';importPostsTabfrom'./PostsTab.js';importContactTabfrom'./ContactTab.js';exportdefaultfunctionTabContainer(){const[tab,setTab]=useState('about');return(<Suspensefallback={<h1>🌀 Loading...</h1>}><TabButtonisActive={tab==='about'}onClick={()=>setTab('about')}>About</TabButton><TabButtonisActive={tab==='posts'}onClick={()=>setTab('posts')}>Posts</TabButton><TabButtonisActive={tab==='contact'}onClick={()=>setTab('contact')}>Contact</TabButton><hr/>{tab==='about'&&<AboutTab/>}{tab==='posts'&&<PostsTab/>}{tab==='contact'&&<ContactTab/>}</Suspense>);}"
                },
                {
                    "type": "p",
                    "text": "Hiding the entire tab container to show a loading indicator leads to a jarring user experience. If you adduseTransitiontoTabButton, you can instead indicate display the pending state in the tab button instead."
                },
                {
                    "type": "p",
                    "text": "Notice that clicking “Posts” no longer replaces the entire tab container with a spinner:"
                },
                {
                    "type": "code",
                    "code": "import{useTransition}from'react';exportdefaultfunctionTabButton({children,isActive,onClick}){const[isPending,startTransition]=useTransition();if(isActive){return<b>{children}</b>}if(isPending){return<bclassName=\"pending\">{children}</b>;}return(<buttononClick={()=>{startTransition(()=>{onClick();});}}>{children}</button>);}"
                },
                {
                    "type": "p",
                    "text": "Read more about using Transitions with Suspense."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Transitions will only “wait” long enough to avoid hidingalready revealedcontent (like the tab container). If the Posts tab had anested<Suspense>boundary,the Transition would not “wait” for it."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Building a Suspense-enabled router"
                },
                {
                    "type": "p",
                    "text": "If you’re building a React framework or a router, we recommend marking page navigations as Transitions."
                },
                {
                    "type": "code",
                    "code": "functionRouter(){const[page,setPage]=useState('/');const[isPending,startTransition]=useTransition();functionnavigate(url){startTransition(()=>{setPage(url);});}// ..."
                },
                {
                    "type": "p",
                    "text": "This is recommended for two reasons:"
                },
                {
                    "type": "list",
                    "items": [
                        "Transitions are interruptible,which lets the user click away without waiting for the re-render to complete.",
                        "Transitions prevent unwanted loading indicators,which lets the user avoid jarring jumps on navigation."
                    ]
                },
                {
                    "type": "p",
                    "text": "Here is a tiny simplified router example using Transitions for navigations."
                },
                {
                    "type": "code",
                    "code": "import{Suspense,useState,useTransition}from'react';importIndexPagefrom'./IndexPage.js';importArtistPagefrom'./ArtistPage.js';importLayoutfrom'./Layout.js';exportdefaultfunctionApp(){return(<Suspensefallback={<BigSpinner/>}><Router/></Suspense>);}functionRouter(){const[page,setPage]=useState('/');const[isPending,startTransition]=useTransition();functionnavigate(url){startTransition(()=>{setPage(url);});}letcontent;if(page==='/'){content=(<IndexPagenavigate={navigate}/>);}elseif(page==='/the-beatles'){content=(<ArtistPageartist={{id:'the-beatles',name:'The Beatles',}}/>);}return(<LayoutisPending={isPending}>{content}</Layout>);}functionBigSpinner(){return<h2>🌀 Loading...</h2>;}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Suspense-enabledrouters are expected to wrap the navigation updates into Transitions by default."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Displaying an error to users with an error boundary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "Error Boundary for useTransition is currently only available in React’s canary and experimental channels. Learn more aboutReact’s release channels here."
                },
                {
                    "type": "p",
                    "text": "If a function passed tostartTransitionthrows an error, you can display an error to your user with anerror boundary. To use an error boundary, wrap the component where you are calling theuseTransitionin an error boundary. Once the function passed tostartTransitionerrors, the fallback for the error boundary will be displayed."
                },
                {
                    "type": "code",
                    "code": "import{useTransition}from\"react\";import{ErrorBoundary}from\"react-error-boundary\";exportfunctionAddCommentContainer(){return(<ErrorBoundaryfallback={<p>⚠️Something went wrong</p>}><AddCommentButton/></ErrorBoundary>);}functionaddComment(comment){// For demonstration purposes to show Error Boundaryif(comment==null){thrownewError(\"Example Error: An error thrown to trigger error boundary\");}}functionAddCommentButton(){const[pending,startTransition]=useTransition();return(<buttondisabled={pending}onClick={()=>{startTransition(()=>{// Intentionally not passing a comment// so error gets thrownaddComment();});}}>Add comment</button>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Troubleshooting"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Updating an input in a Transition doesn’t work"
                },
                {
                    "type": "p",
                    "text": "You can’t use a Transition for a state variable that controls an input:"
                },
                {
                    "type": "code",
                    "code": "const[text,setText]=useState('');// ...functionhandleChange(e){// ❌ Can't use Transitions for controlled input statestartTransition(()=>{setText(e.target.value);});}// ...return<inputvalue={text}onChange={handleChange}/>;"
                },
                {
                    "type": "p",
                    "text": "This is because Transitions are non-blocking, but updating an input in response to the change event should happen synchronously. If you want to run a Transition in response to typing, you have two options:"
                },
                {
                    "type": "list",
                    "items": [
                        "You can declare two separate state variables: one for the input state (which always updates synchronously), and one that you will update in a Transition. This lets you control the input using the synchronous state, and pass the Transition state variable (which will “lag behind” the input) to the rest of your rendering logic.",
                        "Alternatively, you can have one state variable, and adduseDeferredValuewhich will “lag behind” the real value. It will trigger non-blocking re-renders to “catch up” with the new value automatically."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "React doesn’t treat my state update as a Transition"
                },
                {
                    "type": "p",
                    "text": "When you wrap a state update in a Transition, make sure that it happensduringthestartTransitioncall:"
                },
                {
                    "type": "code",
                    "code": "startTransition(()=>{// ✅ Setting state *during* startTransition callsetPage('/about');});"
                },
                {
                    "type": "p",
                    "text": "The function you pass tostartTransitionmust be synchronous."
                },
                {
                    "type": "p",
                    "text": "You can’t mark an update as a Transition like this:"
                },
                {
                    "type": "code",
                    "code": "startTransition(()=>{// ❌ Setting state *after* startTransition callsetTimeout(()=>{setPage('/about');},1000);});"
                },
                {
                    "type": "p",
                    "text": "Instead, you could do this:"
                },
                {
                    "type": "code",
                    "code": "setTimeout(()=>{startTransition(()=>{// ✅ Setting state *during* startTransition callsetPage('/about');});},1000);"
                },
                {
                    "type": "p",
                    "text": "Similarly, you can’t mark an update as a Transition like this:"
                },
                {
                    "type": "code",
                    "code": "startTransition(async()=>{awaitsomeAsyncFunction();// ❌ Setting state *after* startTransition callsetPage('/about');});"
                },
                {
                    "type": "p",
                    "text": "However, this works instead:"
                },
                {
                    "type": "code",
                    "code": "awaitsomeAsyncFunction();startTransition(()=>{// ✅ Setting state *during* startTransition callsetPage('/about');});"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "I want to calluseTransitionfrom outside a component"
                },
                {
                    "type": "p",
                    "text": "You can’t calluseTransitionoutside a component because it’s a Hook. In this case, use the standalonestartTransitionmethod instead. It works the same way, but it doesn’t provide theisPendingindicator."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "The function I pass tostartTransitionexecutes immediately"
                },
                {
                    "type": "p",
                    "text": "If you run this code, it will print 1, 2, 3:"
                },
                {
                    "type": "code",
                    "code": "console.log(1);startTransition(()=>{console.log(2);setPage('/about');});console.log(3);"
                },
                {
                    "type": "p",
                    "text": "It is expected to print 1, 2, 3.The function you pass tostartTransitiondoes not get delayed. Unlike with the browsersetTimeout, it does not run the callback later. React executes your function immediately, but any state updates scheduledwhile it is runningare marked as Transitions. You can imagine that it works like this:"
                },
                {
                    "type": "code",
                    "code": "// A simplified version of how React worksletisInsideTransition=false;functionstartTransition(scope){isInsideTransition=true;scope();isInsideTransition=false;}functionsetState(){if(isInsideTransition){// ... schedule a Transition state update ...}else{// ... schedule an urgent state update ...}}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/rsc/directives",
            "title": "Directives – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Directives- This feature is available in the latest Canary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "These directives are needed only if you’reusing React Server Componentsor building a library compatible with them."
                },
                {
                    "type": "p",
                    "text": "Directives provide instructions tobundlers compatible with React Server Components."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Source code directives"
                },
                {
                    "type": "list",
                    "items": [
                        "'use client'lets you mark what code runs on the client.",
                        "'use server'marks server-side functions that can be called from client-side code."
                    ]
                }
            ]
        },
        {
            "url": "https://react.dev/reference/rsc/server-actions",
            "title": "Server Actions – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Server Actions- This feature is available in the latest Canary"
                },
                {
                    "type": "p",
                    "text": "Server Actions allow Client Components to call async functions executed on the server."
                },
                {
                    "type": "list",
                    "items": [
                        "Creating a Server Action from a Server Component",
                        "Importing Server Actions from Client Components",
                        "Composing Server Actions with Actions",
                        "Form Actions with Server Actions",
                        "Server Actions withuseActionState",
                        "Progressive enhancement withuseActionState"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "How do I build support for Server Actions?"
                },
                {
                    "type": "p",
                    "text": "While Server Actions in React 19 are stable and will not break between major versions, the underlying APIs used to implement Server Actions in a React Server Components bundler or framework do not follow semver and may break between minors in React 19.x."
                },
                {
                    "type": "p",
                    "text": "To support Server Actions as a bundler or framework, we recommend pinning to a specific React version, or using the Canary release. We will continue working with bundlers and frameworks to stabilize the APIs used to implement Server Actions in the future."
                },
                {
                    "type": "p",
                    "text": "When a Server Action is defined with the\"use server\"directive, your framework will automatically create a reference to the server function, and pass that reference to the Client Component. When that function is called on the client, React will send a request to the server to execute the function, and return the result."
                },
                {
                    "type": "p",
                    "text": "Server Actions can be created in Server Components and passed as props to Client Components, or they can be imported and used in Client Components."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Creating a Server Action from a Server Component"
                },
                {
                    "type": "p",
                    "text": "Server Components can define Server Actions with the\"use server\"directive:"
                },
                {
                    "type": "code",
                    "code": "// Server ComponentimportButtonfrom'./Button';functionEmptyNote(){asyncfunctioncreateNoteAction(){// Server Action'use server';awaitdb.notes.create();}return<ButtononClick={createNoteAction}/>;}"
                },
                {
                    "type": "p",
                    "text": "When React renders theEmptyNoteServer Component, it will create a reference to thecreateNoteActionfunction, and pass that reference to theButtonClient Component. When the button is clicked, React will send a request to the server to execute thecreateNoteActionfunction with the reference provided:"
                },
                {
                    "type": "code",
                    "code": "\"use client\";exportdefaultfunctionButton({onClick}){console.log(onClick);// {$$typeof: Symbol.for(\"react.server.reference\"), $$id: 'createNoteAction'}return<buttononClick={()=>onClick()}>Create Empty Note</button>}"
                },
                {
                    "type": "p",
                    "text": "For more, see the docs for\"use server\"."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Importing Server Actions from Client Components"
                },
                {
                    "type": "p",
                    "text": "Client Components can import Server Actions from files that use the\"use server\"directive:"
                },
                {
                    "type": "code",
                    "code": "\"use server\";exportasyncfunctioncreateNoteAction(){awaitdb.notes.create();}"
                },
                {
                    "type": "p",
                    "text": "When the bundler builds theEmptyNoteClient Component, it will create a reference to thecreateNoteActionfunction in the bundle. When thebuttonis clicked, React will send a request to the server to execute thecreateNoteActionfunction using the reference provided:"
                },
                {
                    "type": "code",
                    "code": "\"use client\";import{createNoteAction}from'./actions';functionEmptyNote(){console.log(createNoteAction);// {$$typeof: Symbol.for(\"react.server.reference\"), $$id: 'createNoteAction'}return<buttononClick={createNoteAction}/>}"
                },
                {
                    "type": "p",
                    "text": "For more, see the docs for\"use server\"."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Composing Server Actions with Actions"
                },
                {
                    "type": "p",
                    "text": "Server Actions can be composed with Actions on the client:"
                },
                {
                    "type": "code",
                    "code": "\"use server\";exportasyncfunctionupdateName(name){if(!name){return{error:'Name is required'};}awaitdb.users.updateName(name);}"
                },
                {
                    "type": "code",
                    "code": "\"use client\";import{updateName}from'./actions';functionUpdateName(){const[name,setName]=useState('');const[error,setError]=useState(null);const[isPending,startTransition]=useTransition();constsubmitAction=async()=>{startTransition(async()=>{const{error}=awaitupdateName(name);if(!error){setError(error);}else{setName('');}})}return(<formaction={submitAction}><inputtype=\"text\"name=\"name\"disabled={isPending}/>{state.error&&<span>Failed:{state.error}</span>}</form>)}"
                },
                {
                    "type": "p",
                    "text": "This allows you to access theisPendingstate of the Server Action by wrapping it in an Action on the client."
                },
                {
                    "type": "p",
                    "text": "For more, see the docs forCalling a Server Action outside of<form>"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Form Actions with Server Actions"
                },
                {
                    "type": "p",
                    "text": "Server Actions work with the new Form features in React 19."
                },
                {
                    "type": "p",
                    "text": "You can pass a Server Action to a Form to automatically submit the form to the server:"
                },
                {
                    "type": "code",
                    "code": "\"use client\";import{updateName}from'./actions';functionUpdateName(){return(<formaction={updateName}><inputtype=\"text\"name=\"name\"/></form>)}"
                },
                {
                    "type": "p",
                    "text": "When the Form submission succeeds, React will automatically reset the form. You can adduseActionStateto access the pending state, last response, or to support progressive enhancement."
                },
                {
                    "type": "p",
                    "text": "For more, see the docs forServer Actions in Forms."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Server Actions withuseActionState"
                },
                {
                    "type": "p",
                    "text": "You can compose Server Actions withuseActionStatefor the common case where you just need access to the action pending state and last returned response:"
                },
                {
                    "type": "code",
                    "code": "\"use client\";import{updateName}from'./actions';functionUpdateName(){const[state,submitAction,isPending]=useActionState(updateName,{error:null});return(<formaction={submitAction}><inputtype=\"text\"name=\"name\"disabled={isPending}/>{state.error&&<span>Failed:{state.error}</span>}</form>);}"
                },
                {
                    "type": "p",
                    "text": "When usinguseActionStatewith Server Actions, React will also automatically replay form submissions entered before hydration finishes. This means users can interact with your app even before the app has hydrated."
                },
                {
                    "type": "p",
                    "text": "For more, see the docs foruseActionState."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Progressive enhancement withuseActionState"
                },
                {
                    "type": "p",
                    "text": "Server Actions also support progressive enhancement with the third argument ofuseActionState."
                },
                {
                    "type": "code",
                    "code": "\"use client\";import{updateName}from'./actions';functionUpdateName(){const[,submitAction]=useActionState(updateName,null,`/name/update`);return(<formaction={submitAction}>...</form>);}"
                },
                {
                    "type": "p",
                    "text": "When thepermalinkis provided touseActionState, React will redirect to the provided URL if the form is submitted before the JavaScript bundle loads."
                },
                {
                    "type": "p",
                    "text": "For more, see the docs foruseActionState."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/rsc/server-components",
            "title": "React Server Components – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "React Server Components- This feature is available in the latest Canary"
                },
                {
                    "type": "p",
                    "text": "Server Components are a new type of Component that renders ahead of time, before bundling, in an environment separate from your client app or SSR server."
                },
                {
                    "type": "p",
                    "text": "This separate environment is the “server” in React Server Components. Server Components can run once at build time on your CI server, or they can be run for each request using a web server."
                },
                {
                    "type": "list",
                    "items": [
                        "Server Components without a Server",
                        "Server Components with a Server",
                        "Adding interactivity to Server Components",
                        "Async components with Server Components"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "How do I build support for Server Components?"
                },
                {
                    "type": "p",
                    "text": "While React Server Components in React 19 are stable and will not break between major versions, the underlying APIs used to implement a React Server Components bundler or framework do not follow semver and may break between minors in React 19.x."
                },
                {
                    "type": "p",
                    "text": "To support React Server Components as a bundler or framework, we recommend pinning to a specific React version, or using the Canary release. We will continue working with bundlers and frameworks to stabilize the APIs used to implement React Server Components in the future."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Server Components without a Server"
                },
                {
                    "type": "p",
                    "text": "Server components can run at build time to read from the filesystem or fetch static content, so a web server is not required. For example, you may want to read static data from a content management system."
                },
                {
                    "type": "p",
                    "text": "Without Server Components, it’s common to fetch static data on the client with an Effect:"
                },
                {
                    "type": "code",
                    "code": "// bundle.jsimportmarkedfrom'marked';// 35.9K (11.2K gzipped)importsanitizeHtmlfrom'sanitize-html';// 206K (63.3K gzipped)functionPage({page}){const[content,setContent]=useState('');// NOTE: loads *after* first page render.useEffect(()=>{fetch(`/api/content/${page}`).then((data)=>{setContent(data.content);});},[page]);return<div>{sanitizeHtml(marked(content))}</div>;}"
                },
                {
                    "type": "code",
                    "code": "// api.jsapp.get(`/api/content/:page`,async(req,res)=>{constpage=req.params.page;constcontent=awaitfile.readFile(`${page}.md`);res.send({content});});"
                },
                {
                    "type": "p",
                    "text": "This pattern means users need to download and parse an additional 75K (gzipped) of libraries, and wait for a second request to fetch the data after the page loads, just to render static content that will not change for the lifetime of the page."
                },
                {
                    "type": "p",
                    "text": "With Server Components, you can render these components once at build time:"
                },
                {
                    "type": "code",
                    "code": "importmarkedfrom'marked';// Not included in bundleimportsanitizeHtmlfrom'sanitize-html';// Not included in bundleasyncfunctionPage({page}){// NOTE: loads *during* render, when the app is built.constcontent=awaitfile.readFile(`${page}.md`);return<div>{sanitizeHtml(marked(content))}</div>;}"
                },
                {
                    "type": "p",
                    "text": "The rendered output can then be server-side rendered (SSR) to HTML and uploaded to a CDN. When the app loads, the client will not see the originalPagecomponent, or the expensive libraries for rendering the markdown. The client will only see the rendered output:"
                },
                {
                    "type": "code",
                    "code": "<div><!-- html for markdown --></div>"
                },
                {
                    "type": "p",
                    "text": "This means the content is visible during first page load, and the bundle does not include the expensive libraries needed to render the static content."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "You may notice that the Server Component above is an async function:"
                },
                {
                    "type": "code",
                    "code": "asyncfunctionPage({page}){//...}"
                },
                {
                    "type": "p",
                    "text": "Async Components are a new feature of Server Components that allow you toawaitin render."
                },
                {
                    "type": "p",
                    "text": "SeeAsync components with Server Componentsbelow."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Server Components with a Server"
                },
                {
                    "type": "p",
                    "text": "Server Components can also run on a web server during a request for a page, letting you access your data layer without having to build an API. They are rendered before your application is bundled, and can pass data and JSX as props to Client Components."
                },
                {
                    "type": "p",
                    "text": "Without Server Components, it’s common to fetch dynamic data on the client in an Effect:"
                },
                {
                    "type": "code",
                    "code": "// bundle.jsfunctionNote({id}){const[note,setNote]=useState('');// NOTE: loads *after* first render.useEffect(()=>{fetch(`/api/notes/${id}`).then(data=>{setNote(data.note);});},[id]);return(<div><Authorid={note.authorId}/><p>{note}</p></div>);}functionAuthor({id}){const[author,setAuthor]=useState('');// NOTE: loads *after* Note renders.// Causing an expensive client-server waterfall.useEffect(()=>{fetch(`/api/authors/${id}`).then(data=>{setAuthor(data.author);});},[id]);return<span>By:{author.name}</span>;}"
                },
                {
                    "type": "code",
                    "code": "// apiimportdbfrom'./database';app.get(`/api/notes/:id`,async(req,res)=>{constnote=awaitdb.notes.get(id);res.send({note});});app.get(`/api/authors/:id`,async(req,res)=>{constauthor=awaitdb.authors.get(id);res.send({author});});"
                },
                {
                    "type": "p",
                    "text": "With Server Components, you can read the data and render it in the component:"
                },
                {
                    "type": "code",
                    "code": "importdbfrom'./database';asyncfunctionNote({id}){// NOTE: loads *during* render.constnote=awaitdb.notes.get(id);return(<div><Authorid={note.authorId}/><p>{note}</p></div>);}asyncfunctionAuthor({id}){// NOTE: loads *after* Note,// but is fast if data is co-located.constauthor=awaitdb.authors.get(id);return<span>By:{author.name}</span>;}"
                },
                {
                    "type": "p",
                    "text": "The bundler then combines the data, rendered Server Components and dynamic Client Components into a bundle. Optionally, that bundle can then be server-side rendered (SSR) to create the initial HTML for the page. When the page loads, the browser does not see the originalNoteandAuthorcomponents; only the rendered output is sent to the client:"
                },
                {
                    "type": "code",
                    "code": "<div><span>By: The React Team</span><p>React 19 is...</p></div>"
                },
                {
                    "type": "p",
                    "text": "Server Components can be made dynamic by re-fetching them from a server, where they can access the data and render again. This new application architecture combines the simple “request/response” mental model of server-centric Multi-Page Apps with the seamless interactivity of client-centric Single-Page Apps, giving you the best of both worlds."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Adding interactivity to Server Components"
                },
                {
                    "type": "p",
                    "text": "Server Components are not sent to the browser, so they cannot use interactive APIs likeuseState. To add interactivity to Server Components, you can compose them with Client Component using the\"use client\"directive."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "There is no directive for Server Components."
                },
                {
                    "type": "p",
                    "text": "A common misunderstanding is that Server Components are denoted by\"use server\", but there is no directive for Server Components. The\"use server\"directive is used for Server Actions."
                },
                {
                    "type": "p",
                    "text": "For more info, see the docs forDirectives."
                },
                {
                    "type": "p",
                    "text": "In the following example, theNotesServer Component imports anExpandableClient Component that uses state to toggle itsexpandedstate:"
                },
                {
                    "type": "code",
                    "code": "// Server ComponentimportExpandablefrom'./Expandable';asyncfunctionNotes(){constnotes=awaitdb.notes.getAll();return(<div>{notes.map(note=>(<Expandablekey={note.id}><pnote={note}/></Expandable>))}</div>)}"
                },
                {
                    "type": "code",
                    "code": "// Client Component\"use client\"exportdefaultfunctionExpandable({children}){const[expanded,setExpanded]=useState(false);return(<div><buttononClick={()=>setExpanded(!expanded)}>Toggle</button>{expanded&&children}</div>)}"
                },
                {
                    "type": "p",
                    "text": "This works by first renderingNotesas a Server Component, and then instructing the bundler to create a bundle for the Client ComponentExpandable. In the browser, the Client Components will see output of the Server Components passed as props:"
                },
                {
                    "type": "code",
                    "code": "<head><!-- the bundle for Client Components --><scriptsrc=\"bundle.js\"/></head><body><div><Expandablekey={1}><p>this is the first note</p></Expandable><Expandablekey={2}><p>this is the second note</p></Expandable><!--...--></div></body>"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Async components with Server Components"
                },
                {
                    "type": "p",
                    "text": "Server Components introduce a new way to write Components using async/await. When youawaitin an async component, React will suspend and wait for the promise to resolve before resuming rendering. This works across server/client boundaries with streaming support for Suspense."
                },
                {
                    "type": "p",
                    "text": "You can even create a promise on the server, and await it on the client:"
                },
                {
                    "type": "code",
                    "code": "// Server Componentimportdbfrom'./database';asyncfunctionPage({id}){// Will suspend the Server Component.constnote=awaitdb.notes.get(id);// NOTE: not awaited, will start here and await on the client.constcommentsPromise=db.comments.get(note.id);return(<div>{note}<Suspensefallback={<p>Loading Comments...</p>}><CommentscommentsPromise={commentsPromise}/></Suspense></div>);}"
                },
                {
                    "type": "code",
                    "code": "// Client Component\"use client\";import{use}from'react';functionComments({commentsPromise}){// NOTE: this will resume the promise from the server.// It will suspend until the data is available.constcomments=use(commentsPromise);returncomments.map(commment=><p>{comment}</p>);}"
                },
                {
                    "type": "p",
                    "text": "Thenotecontent is important data for the page to render, so weawaitit on the server. The comments are below the fold and lower-priority, so we start the promise on the server, and wait for it on the client with theuseAPI. This will Suspend on the client, without blocking thenotecontent from rendering."
                },
                {
                    "type": "p",
                    "text": "Since async components arenot supported on the client, we await the promise withuse."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/rsc/use-client",
            "title": "'use client' directive – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "'use client'- This feature is available in the latest Canary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "'use client'is needed only if you’reusing React Server Componentsor building a library compatible with them."
                },
                {
                    "type": "p",
                    "text": "'use client'lets you mark what code runs on the client."
                },
                {
                    "type": "list",
                    "items": [
                        "Reference'use client'How'use client'marks client codeWhen to use'use client'Serializable types returned by Server Components",
                        "'use client'",
                        "How'use client'marks client code",
                        "When to use'use client'",
                        "Serializable types returned by Server Components",
                        "UsageBuilding with interactivity and stateUsing client APIsUsing third-party libraries",
                        "Building with interactivity and state",
                        "Using client APIs",
                        "Using third-party libraries"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "'use client'",
                        "How'use client'marks client code",
                        "When to use'use client'",
                        "Serializable types returned by Server Components"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Building with interactivity and state",
                        "Using client APIs",
                        "Using third-party libraries"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "'use client'"
                },
                {
                    "type": "p",
                    "text": "Add'use client'at the top of a file to mark the module and its transitive dependencies as client code."
                },
                {
                    "type": "code",
                    "code": "'use client';import{useState}from'react';import{formatDate}from'./formatters';importButtonfrom'./button';exportdefaultfunctionRichTextEditor({timestamp,text}){constdate=formatDate(timestamp);// ...consteditButton=<Button/>;// ...}"
                },
                {
                    "type": "p",
                    "text": "When a file marked with'use client'is imported from a Server Component,compatible bundlerswill treat the module import as a boundary between server-run and client-run code."
                },
                {
                    "type": "p",
                    "text": "As dependencies ofRichTextEditor,formatDateandButtonwill also be evaluated on the client regardless of whether their modules contain a'use client'directive. Note that a single module may be evaluated on the server when imported from server code and on the client when imported from client code."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "'use client'must be at the very beginning of a file, above any imports or other code (comments are OK). They must be written with single or double quotes, but not backticks.",
                        "When a'use client'module is imported from another client-rendered module, the directive has no effect.",
                        "When a component module contains a'use client'directive, any usage of that component is guaranteed to be a Client Component. However, a component can still be evaluated on the client even if it does not have a'use client'directive.A component usage is considered a Client Component if it is defined in module with'use client'directive or when it is a transitive dependency of a module that contains a'use client'directive. Otherwise, it is a Server Component.",
                        "A component usage is considered a Client Component if it is defined in module with'use client'directive or when it is a transitive dependency of a module that contains a'use client'directive. Otherwise, it is a Server Component.",
                        "Code that is marked for client evaluation is not limited to components. All code that is a part of the Client module sub-tree is sent to and run by the client.",
                        "When a server evaluated module imports values from a'use client'module, the values must either be a React component orsupported serializable prop valuesto be passed to a Client Component. Any other use case will throw an exception."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "A component usage is considered a Client Component if it is defined in module with'use client'directive or when it is a transitive dependency of a module that contains a'use client'directive. Otherwise, it is a Server Component."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "How'use client'marks client code"
                },
                {
                    "type": "p",
                    "text": "In a React app, components are often split into separate files, ormodules."
                },
                {
                    "type": "p",
                    "text": "For apps that use React Server Components, the app is server-rendered by default.'use client'introduces a server-client boundary in themodule dependency tree, effectively creating a subtree of Client modules."
                },
                {
                    "type": "p",
                    "text": "To better illustrate this, consider the following React Server Components app."
                },
                {
                    "type": "code",
                    "code": "importFancyTextfrom'./FancyText';importInspirationGeneratorfrom'./InspirationGenerator';importCopyrightfrom'./Copyright';exportdefaultfunctionApp(){return(<><FancyTexttitletext=\"Get Inspired App\"/><InspirationGenerator><Copyrightyear={2004}/></InspirationGenerator></>);}"
                },
                {
                    "type": "p",
                    "text": "In the module dependency tree of this example app, the'use client'directive inInspirationGenerator.jsmarks that module and all of its transitive dependencies as Client modules. The subtree starting atInspirationGenerator.jsis now marked as Client modules."
                },
                {
                    "type": "p",
                    "text": "'use client'segments the module dependency tree of the React Server Components app, markingInspirationGenerator.jsand all of its dependencies as client-rendered."
                },
                {
                    "type": "p",
                    "text": "During render, the framework will server-render the root component and continue through therender tree, opting-out of evaluating any code imported from client-marked code."
                },
                {
                    "type": "p",
                    "text": "The server-rendered portion of the render tree is then sent to the client. The client, with its client code downloaded, then completes rendering the rest of the tree."
                },
                {
                    "type": "p",
                    "text": "The render tree for the React Server Components app.InspirationGeneratorand its child componentFancyTextare components exported from client-marked code and considered Client Components."
                },
                {
                    "type": "p",
                    "text": "We introduce the following definitions:"
                },
                {
                    "type": "list",
                    "items": [
                        "Client Componentsare components in a render tree that are rendered on the client.",
                        "Server Componentsare components in a render tree that are rendered on the server."
                    ]
                },
                {
                    "type": "p",
                    "text": "Working through the example app,App,FancyTextandCopyrightare all server-rendered and considered Server Components. AsInspirationGenerator.jsand its transitive dependencies are marked as client code, the componentInspirationGeneratorand its child componentFancyTextare Client Components."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "How isFancyTextboth a Server and a Client Component?"
                },
                {
                    "type": "p",
                    "text": "By the above definitions, the componentFancyTextis both a Server and Client Component, how can that be?"
                },
                {
                    "type": "p",
                    "text": "First, let’s clarify that the term “component” is not very precise. Here are just two ways “component” can be understood:"
                },
                {
                    "type": "list",
                    "items": [
                        "A “component” can refer to acomponent definition. In most cases this will be a function."
                    ]
                },
                {
                    "type": "code",
                    "code": "// This is a definition of a componentfunctionMyComponent(){return<p>My Component</p>}"
                },
                {
                    "type": "list",
                    "items": [
                        "A “component” can also refer to acomponent usageof its definition."
                    ]
                },
                {
                    "type": "code",
                    "code": "importMyComponentfrom'./MyComponent';functionApp(){// This is a usage of a componentreturn<MyComponent/>;}"
                },
                {
                    "type": "p",
                    "text": "Often, the imprecision is not important when explaining concepts, but in this case it is."
                },
                {
                    "type": "p",
                    "text": "When we talk about Server or Client Components, we are referring to component usages."
                },
                {
                    "type": "list",
                    "items": [
                        "If the component is defined in a module with a'use client'directive, or the component is imported and called in a Client Component, then the component usage is a Client Component.",
                        "Otherwise, the component usage is a Server Component."
                    ]
                },
                {
                    "type": "p",
                    "text": "Back to the question ofFancyText, we see that the component definition doesnothave a'use client'directive and it has two usages."
                },
                {
                    "type": "p",
                    "text": "The usage ofFancyTextas a child ofApp, marks that usage as a Server Component. WhenFancyTextis imported and called underInspirationGenerator, that usage ofFancyTextis a Client Component asInspirationGeneratorcontains a'use client'directive."
                },
                {
                    "type": "p",
                    "text": "This means that the component definition forFancyTextwill both be evaluated on the server and also downloaded by the client to render its Client Component usage."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Why isCopyrighta Server Component?"
                },
                {
                    "type": "p",
                    "text": "BecauseCopyrightis rendered as a child of the Client ComponentInspirationGenerator, you might be surprised that it is a Server Component."
                },
                {
                    "type": "p",
                    "text": "Recall that'use client'defines the boundary between server and client code on themodule dependency tree, not the render tree."
                },
                {
                    "type": "p",
                    "text": "'use client'defines the boundary between server and client code on the module dependency tree."
                },
                {
                    "type": "p",
                    "text": "In the module dependency tree, we see thatApp.jsimports and callsCopyrightfrom theCopyright.jsmodule. AsCopyright.jsdoes not contain a'use client'directive, the component usage is rendered on the server.Appis rendered on the server as it is the root component."
                },
                {
                    "type": "p",
                    "text": "Client Components can render Server Components because you can pass JSX as props. In this case,InspirationGeneratorreceivesCopyrightaschildren. However, theInspirationGeneratormodule never directly imports theCopyrightmodule nor calls the component, all of that is done byApp. In fact, theCopyrightcomponent is fully executed beforeInspirationGeneratorstarts rendering."
                },
                {
                    "type": "p",
                    "text": "The takeaway is that a parent-child render relationship between components does not guarantee the same render environment."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "When to use'use client'"
                },
                {
                    "type": "p",
                    "text": "With'use client', you can determine when components are Client Components. As Server Components are default, here is a brief overview of the advantages and limitations to Server Components to determine when you need to mark something as client rendered."
                },
                {
                    "type": "p",
                    "text": "For simplicity, we talk about Server Components, but the same principles apply to all code in your app that is server run."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Advantages of Server Components"
                },
                {
                    "type": "list",
                    "items": [
                        "Server Components can reduce the amount of code sent and run by the client. Only Client modules are bundled and evaluated by the client.",
                        "Server Components benefit from running on the server. They can access the local filesystem and may experience low latency for data fetches and network requests."
                    ]
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Limitations of Server Components"
                },
                {
                    "type": "list",
                    "items": [
                        "Server Components cannot support interaction as event handlers must be registered and triggered by a client.For example, event handlers likeonClickcan only be defined in Client Components.",
                        "For example, event handlers likeonClickcan only be defined in Client Components.",
                        "Server Components cannot use most Hooks.When Server Components are rendered, their output is essentially a list of components for the client to render. Server Components do not persist in memory after render and cannot have their own state.",
                        "When Server Components are rendered, their output is essentially a list of components for the client to render. Server Components do not persist in memory after render and cannot have their own state."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "For example, event handlers likeonClickcan only be defined in Client Components."
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "When Server Components are rendered, their output is essentially a list of components for the client to render. Server Components do not persist in memory after render and cannot have their own state."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Serializable types returned by Server Components"
                },
                {
                    "type": "p",
                    "text": "As in any React app, parent components pass data to child components. As they are rendered in different environments, passing data from a Server Component to a Client Component requires extra consideration."
                },
                {
                    "type": "p",
                    "text": "Prop values passed from a Server Component to Client Component must be serializable."
                },
                {
                    "type": "p",
                    "text": "Serializable props include:"
                },
                {
                    "type": "list",
                    "items": [
                        "Primitivesstringnumberbigintbooleanundefinednullsymbol, only symbols registered in the global Symbol registry viaSymbol.for",
                        "string",
                        "number",
                        "bigint",
                        "boolean",
                        "undefined",
                        "null",
                        "symbol, only symbols registered in the global Symbol registry viaSymbol.for",
                        "Iterables containing serializable valuesStringArrayMapSetTypedArrayandArrayBuffer",
                        "String",
                        "Array",
                        "Map",
                        "Set",
                        "TypedArrayandArrayBuffer",
                        "Date",
                        "Plainobjects: those created withobject initializers, with serializable properties",
                        "Functions that areServer Actions",
                        "Client or Server Component elements (JSX)",
                        "Promises"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "string",
                        "number",
                        "bigint",
                        "boolean",
                        "undefined",
                        "null",
                        "symbol, only symbols registered in the global Symbol registry viaSymbol.for"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "String",
                        "Array",
                        "Map",
                        "Set",
                        "TypedArrayandArrayBuffer"
                    ]
                },
                {
                    "type": "p",
                    "text": "Notably, these are not supported:"
                },
                {
                    "type": "list",
                    "items": [
                        "Functionsthat are not exported from client-marked modules or marked with'use server'",
                        "Classes",
                        "Objects that are instances of any class (other than the built-ins mentioned) or objects witha null prototype",
                        "Symbols not registered globally, ex.Symbol('my new symbol')"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Building with interactivity and state"
                },
                {
                    "type": "code",
                    "code": "'use client';import{useState}from'react';exportdefaultfunctionCounter({initialValue=0}){const[countValue,setCountValue]=useState(initialValue);constincrement=()=>setCountValue(countValue+1);constdecrement=()=>setCountValue(countValue-1);return(<><h2>Count Value:{countValue}</h2><buttononClick={increment}>+1</button><buttononClick={decrement}>-1</button></>);}"
                },
                {
                    "type": "p",
                    "text": "AsCounterrequires both theuseStateHook and event handlers to increment or decrement the value, this component must be a Client Component and will require a'use client'directive at the top."
                },
                {
                    "type": "p",
                    "text": "In contrast, a component that renders UI without interaction will not need to be a Client Component."
                },
                {
                    "type": "code",
                    "code": "import{readFile}from'node:fs/promises';importCounterfrom'./Counter';exportdefaultasyncfunctionCounterContainer(){constinitialValue=awaitreadFile('/path/to/counter_value');return<CounterinitialValue={initialValue}/>}"
                },
                {
                    "type": "p",
                    "text": "For example,Counter’s parent component,CounterContainer, does not require'use client'as it is not interactive and does not use state. In addition,CounterContainermust be a Server Component as it reads from the local file system on the server, which is possible only in a Server Component."
                },
                {
                    "type": "p",
                    "text": "There are also components that don’t use any server or client-only features and can be agnostic to where they render. In our earlier example,FancyTextis one such component."
                },
                {
                    "type": "code",
                    "code": "exportdefaultfunctionFancyText({title,text}){returntitle?<h1className='fancy title'>{text}</h1>:<h3className='fancy cursive'>{text}</h3>}"
                },
                {
                    "type": "p",
                    "text": "In this case, we don’t add the'use client'directive, resulting inFancyText’soutput(rather than its source code) to be sent to the browser when referenced from a Server Component. As demonstrated in the earlier Inspirations app example,FancyTextis used as both a Server or Client Component, depending on where it is imported and used."
                },
                {
                    "type": "p",
                    "text": "But ifFancyText’s HTML output was large relative to its source code (including dependencies), it might be more efficient to force it to always be a Client Component. Components that return a long SVG path string are one case where it may be more efficient to force a component to be a Client Component."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Using client APIs"
                },
                {
                    "type": "p",
                    "text": "Your React app may use client-specific APIs, such as the browser’s APIs for web storage, audio and video manipulation, and device hardware, amongothers."
                },
                {
                    "type": "p",
                    "text": "In this example, the component usesDOM APIsto manipulate acanvaselement. Since those APIs are only available in the browser, it must be marked as a Client Component."
                },
                {
                    "type": "code",
                    "code": "'use client';import{useRef,useEffect}from'react';exportdefaultfunctionCircle(){constref=useRef(null);useLayoutEffect(()=>{constcanvas=ref.current;constcontext=canvas.getContext('2d');context.reset();context.beginPath();context.arc(100,75,50,0,2*Math.PI);context.stroke();});return<canvasref={ref}/>;}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Using third-party libraries"
                },
                {
                    "type": "p",
                    "text": "Often in a React app, you’ll leverage third-party libraries to handle common UI patterns or logic."
                },
                {
                    "type": "p",
                    "text": "These libraries may rely on component Hooks or client APIs. Third-party components that use any of the following React APIs must run on the client:"
                },
                {
                    "type": "list",
                    "items": [
                        "createContext",
                        "reactandreact-domHooks, excludinguseanduseId",
                        "forwardRef",
                        "memo",
                        "startTransition",
                        "If they use client APIs, ex. DOM insertion or native platform views"
                    ]
                },
                {
                    "type": "p",
                    "text": "If these libraries have been updated to be compatible with React Server Components, then they will already include'use client'markers of their own, allowing you to use them directly from your Server Components. If a library hasn’t been updated, or if a component needs props like event handlers that can only be specified on the client, you may need to add your own Client Component file in between the third-party Client Component and your Server Component where you’d like to use it."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/rsc/use-server",
            "title": "'use server' directive – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "'use server'- This feature is available in the latest Canary"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Canary"
                },
                {
                    "type": "p",
                    "text": "'use server'is needed only if you’reusing React Server Componentsor building a library compatible with them."
                },
                {
                    "type": "p",
                    "text": "'use server'marks server-side functions that can be called from client-side code."
                },
                {
                    "type": "list",
                    "items": [
                        "Reference'use server'Security considerationsSerializable arguments and return values",
                        "'use server'",
                        "Security considerations",
                        "Serializable arguments and return values",
                        "UsageServer Actions in formsCalling a Server Action outside of<form>",
                        "Server Actions in forms",
                        "Calling a Server Action outside of<form>"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "'use server'",
                        "Security considerations",
                        "Serializable arguments and return values"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Server Actions in forms",
                        "Calling a Server Action outside of<form>"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Reference"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "'use server'"
                },
                {
                    "type": "p",
                    "text": "Add'use server'at the top of an async function body to mark the function as callable by the client. We call these functionsServer Actions."
                },
                {
                    "type": "code",
                    "code": "asyncfunctionaddToCart(data){'use server';// ...}"
                },
                {
                    "type": "p",
                    "text": "When calling a Server Action on the client, it will make a network request to the server that includes a serialized copy of any arguments passed. If the Server Action returns a value, that value will be serialized and returned to the client."
                },
                {
                    "type": "p",
                    "text": "Instead of individually marking functions with'use server', you can add the directive to the top of a file to mark all exports within that file as Server Actions that can be used anywhere, including imported in client code."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Caveats"
                },
                {
                    "type": "list",
                    "items": [
                        "'use server'must be at the very beginning of their function or module; above any other code including imports (comments above directives are OK). They must be written with single or double quotes, not backticks.",
                        "'use server'can only be used in server-side files. The resulting Server Actions can be passed to Client Components through props. See supportedtypes for serialization.",
                        "To import a Server Action fromclient code, the directive must be used on a module level.",
                        "Because the underlying network calls are always asynchronous,'use server'can only be used on async functions.",
                        "Always treat arguments to Server Actions as untrusted input and authorize any mutations. Seesecurity considerations.",
                        "Server Actions should be called in aTransition. Server Actions passed to<form action>orformActionwill automatically be called in a transition.",
                        "Server Actions are designed for mutations that update server-side state; they are not recommended for data fetching. Accordingly, frameworks implementing Server Actions typically process one action at a time and do not have a way to cache the return value."
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Security considerations"
                },
                {
                    "type": "p",
                    "text": "Arguments to Server Actions are fully client-controlled. For security, always treat them as untrusted input, and make sure to validate and escape arguments as appropriate."
                },
                {
                    "type": "p",
                    "text": "In any Server Action, make sure to validate that the logged-in user is allowed to perform that action."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Under Construction"
                },
                {
                    "type": "p",
                    "text": "To prevent sending sensitive data from a Server Action, there are experimental taint APIs to prevent unique values and objects from being passed to client code."
                },
                {
                    "type": "p",
                    "text": "Seeexperimental_taintUniqueValueandexperimental_taintObjectReference."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Serializable arguments and return values"
                },
                {
                    "type": "p",
                    "text": "As client code calls the Server Action over the network, any arguments passed will need to be serializable."
                },
                {
                    "type": "p",
                    "text": "Here are supported types for Server Action arguments:"
                },
                {
                    "type": "list",
                    "items": [
                        "Primitivesstringnumberbigintbooleanundefinednullsymbol, only symbols registered in the global Symbol registry viaSymbol.for",
                        "string",
                        "number",
                        "bigint",
                        "boolean",
                        "undefined",
                        "null",
                        "symbol, only symbols registered in the global Symbol registry viaSymbol.for",
                        "Iterables containing serializable valuesStringArrayMapSetTypedArrayandArrayBuffer",
                        "String",
                        "Array",
                        "Map",
                        "Set",
                        "TypedArrayandArrayBuffer",
                        "Date",
                        "FormDatainstances",
                        "Plainobjects: those created withobject initializers, with serializable properties",
                        "Functions that are Server Actions",
                        "Promises"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "string",
                        "number",
                        "bigint",
                        "boolean",
                        "undefined",
                        "null",
                        "symbol, only symbols registered in the global Symbol registry viaSymbol.for"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "String",
                        "Array",
                        "Map",
                        "Set",
                        "TypedArrayandArrayBuffer"
                    ]
                },
                {
                    "type": "p",
                    "text": "Notably, these are not supported:"
                },
                {
                    "type": "list",
                    "items": [
                        "React elements, orJSX",
                        "Functions, including component functions or any other function that is not a Server Action",
                        "Classes",
                        "Objects that are instances of any class (other than the built-ins mentioned) or objects witha null prototype",
                        "Symbols not registered globally, ex.Symbol('my new symbol')"
                    ]
                },
                {
                    "type": "p",
                    "text": "Supported serializable return values are the same asserializable propsfor a boundary Client Component."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Usage"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Server Actions in forms"
                },
                {
                    "type": "p",
                    "text": "The most common use case of Server Actions will be calling server functions that mutate data. On the browser, theHTML form elementis the traditional approach for a user to submit a mutation. With React Server Components, React introduces first-class support for Server Actions informs."
                },
                {
                    "type": "p",
                    "text": "Here is a form that allows a user to request a username."
                },
                {
                    "type": "code",
                    "code": "// App.jsasyncfunctionrequestUsername(formData){'use server';constusername=formData.get('username');// ...}exportdefaultfunctionApp(){return(<formaction={requestUsername}><inputtype=\"text\"name=\"username\"/><buttontype=\"submit\">Request</button></form>);}"
                },
                {
                    "type": "p",
                    "text": "In this examplerequestUsernameis a Server Action passed to a<form>. When a user submits this form, there is a network request to the server functionrequestUsername. When calling a Server Action in a form, React will supply the form’sFormDataas the first argument to the Server Action."
                },
                {
                    "type": "p",
                    "text": "By passing a Server Action to the formaction, React canprogressively enhancethe form. This means that forms can be submitted before the JavaScript bundle is loaded."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Handling return values in forms"
                },
                {
                    "type": "p",
                    "text": "In the username request form, there might be the chance that a username is not available.requestUsernameshould tell us if it fails or not."
                },
                {
                    "type": "p",
                    "text": "To update the UI based on the result of a Server Action while supporting progressive enhancement, useuseActionState."
                },
                {
                    "type": "code",
                    "code": "// requestUsername.js'use server';exportdefaultasyncfunctionrequestUsername(formData){constusername=formData.get('username');if(canRequest(username)){// ...return'successful';}return'failed';}"
                },
                {
                    "type": "code",
                    "code": "// UsernameForm.js'use client';import{useActionState}from'react';importrequestUsernamefrom'./requestUsername';functionUsernameForm(){const[state,action]=useActionState(requestUsername,null,'n/a');return(<><formaction={action}><inputtype=\"text\"name=\"username\"/><buttontype=\"submit\">Request</button></form><p>Last submission request returned:{state}</p></>);}"
                },
                {
                    "type": "p",
                    "text": "Note that like most Hooks,useActionStatecan only be called inclient code."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Calling a Server Action outside of<form>"
                },
                {
                    "type": "p",
                    "text": "Server Actions are exposed server endpoints and can be called anywhere in client code."
                },
                {
                    "type": "p",
                    "text": "When using a Server Action outside of aform, call the Server Action in aTransition, which allows you to display a loading indicator, showoptimistic state updates, and handle unexpected errors. Forms will automatically wrap Server Actions in transitions."
                },
                {
                    "type": "code",
                    "code": "importincrementLikefrom'./actions';import{useState,useTransition}from'react';functionLikeButton(){const[isPending,startTransition]=useTransition();const[likeCount,setLikeCount]=useState(0);constonClick=()=>{startTransition(async()=>{constcurrentCount=awaitincrementLike();setLikeCount(currentCount);});};return(<><p>Total Likes:{likeCount}</p><buttononClick={onClick}disabled={isPending}>Like</button>;</>);}"
                },
                {
                    "type": "code",
                    "code": "// actions.js'use server';letlikeCount=0;exportdefaultasyncfunctionincrementLike(){likeCount++;returnlikeCount;}"
                },
                {
                    "type": "p",
                    "text": "To read a Server Action return value, you’ll need toawaitthe promise returned."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/rules",
            "title": "Rules of React – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Rules of React"
                },
                {
                    "type": "p",
                    "text": "Just as different programming languages have their own ways of expressing concepts, React has its own idioms — or rules — for how to express patterns in a way that is easy to understand and yields high-quality applications."
                },
                {
                    "type": "list",
                    "items": [
                        "Components and Hooks must be pure",
                        "React calls Components and Hooks",
                        "Rules of Hooks"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "To learn more about expressing UIs with React, we recommend readingThinking in React."
                },
                {
                    "type": "p",
                    "text": "This section describes the rules you need to follow to write idiomatic React code. Writing idiomatic React code can help you write well organized, safe, and composable applications. These properties make your app more resilient to changes and makes it easier to work with other developers, libraries, and tools."
                },
                {
                    "type": "p",
                    "text": "These rules are known as theRules of React. They are rules – and not just guidelines – in the sense that if they are broken, your app likely has bugs. Your code also becomes unidiomatic and harder to understand and reason about."
                },
                {
                    "type": "p",
                    "text": "We strongly recommend usingStrict Modealongside React’sESLint pluginto help your codebase follow the Rules of React. By following the Rules of React, you’ll be able to find and address these bugs and keep your application maintainable."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Components and Hooks must be pure"
                },
                {
                    "type": "p",
                    "text": "Purity in Components and Hooksis a key rule of React that makes your app predictable, easy to debug, and allows React to automatically optimize your code."
                },
                {
                    "type": "list",
                    "items": [
                        "Components must be idempotent– React components are assumed to always return the same output with respect to their inputs – props, state, and context.",
                        "Side effects must run outside of render– Side effects should not run in render, as React can render components multiple times to create the best possible user experience.",
                        "Props and state are immutable– A component’s props and state are immutable snapshots with respect to a single render. Never mutate them directly.",
                        "Return values and arguments to Hooks are immutable– Once values are passed to a Hook, you should not modify them. Like props in JSX, values become immutable when passed to a Hook.",
                        "Values are immutable after being passed to JSX– Don’t mutate values after they’ve been used in JSX. Move the mutation before the JSX is created."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "React calls Components and Hooks"
                },
                {
                    "type": "p",
                    "text": "React is responsible for rendering components and hooks when necessary to optimize the user experience.It is declarative: you tell React what to render in your component’s logic, and React will figure out how best to display it to your user."
                },
                {
                    "type": "list",
                    "items": [
                        "Never call component functions directly– Components should only be used in JSX. Don’t call them as regular functions.",
                        "Never pass around hooks as regular values– Hooks should only be called inside of components. Never pass it around as a regular value."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Rules of Hooks"
                },
                {
                    "type": "p",
                    "text": "Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called. You need to follow theRules of Hookswhen using them."
                },
                {
                    "type": "list",
                    "items": [
                        "Only call Hooks at the top level– Don’t call Hooks inside loops, conditions, or nested functions. Instead, always use Hooks at the top level of your React function, before any early returns.",
                        "Only call Hooks from React functions– Don’t call Hooks from regular JavaScript functions."
                    ]
                }
            ]
        },
        {
            "url": "https://react.dev/reference/rules/components-and-hooks-must-be-pure",
            "title": "Components and Hooks must be pure – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Components and Hooks must be pure"
                },
                {
                    "type": "p",
                    "text": "Pure functions only perform a calculation and nothing more. It makes your code easier to understand, debug, and allows React to automatically optimize your components and Hooks correctly."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "This reference page covers advanced topics and requires familiarity with the concepts covered in theKeeping Components Purepage."
                },
                {
                    "type": "list",
                    "items": [
                        "Why does purity matter?",
                        "Components and Hooks must be idempotent",
                        "Side effects must run outside of renderWhen is it okay to have mutation?",
                        "When is it okay to have mutation?",
                        "Props and state are immutableDon’t mutate PropsDon’t mutate State",
                        "Don’t mutate Props",
                        "Don’t mutate State",
                        "Return values and arguments to Hooks are immutable",
                        "Values are immutable after being passed to JSX"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "When is it okay to have mutation?"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Don’t mutate Props",
                        "Don’t mutate State"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Why does purity matter?"
                },
                {
                    "type": "p",
                    "text": "One of the key concepts that makes React,Reactispurity. A pure component or hook is one that is:"
                },
                {
                    "type": "list",
                    "items": [
                        "Idempotent– Youalways get the same result every timeyou run it with the same inputs – props, state, context for component inputs; and arguments for hook inputs.",
                        "Has no side effects in render– Code with side effects should runseparately from rendering. For example as anevent handler– where the user interacts with the UI and causes it to update; or as anEffect– which runs after render.",
                        "Does not mutate non-local values: Components and Hooks shouldnever modify values that aren’t created locallyin render."
                    ]
                },
                {
                    "type": "p",
                    "text": "When render is kept pure, React can understand how to prioritize which updates are most important for the user to see first. This is made possible because of render purity: since components don’t have side effectsin render, React can pause rendering components that aren’t as important to update, and only come back to them later when it’s needed."
                },
                {
                    "type": "p",
                    "text": "Concretely, this means that rendering logic can be run multiple times in a way that allows React to give your user a pleasant user experience. However, if your component has an untracked side effect – like modifying the value of a global variableduring render– when React runs your rendering code again, your side effects will be triggered in a way that won’t match what you want. This often leads to unexpected bugs that can degrade how your users experience your app. You can see anexample of this in the Keeping Components Pure page."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "How does React run your code?"
                },
                {
                    "type": "p",
                    "text": "React is declarative: you tell Reactwhatto render, and React will figure outhowbest to display it to your user. To do this, React has a few phases where it runs your code. You don’t need to know about all of these phases to use React well. But at a high level, you should know about what code runs inrender, and what runs outside of it."
                },
                {
                    "type": "p",
                    "text": "Renderingrefers to calculating what the next version of your UI should look like. After rendering,Effectsareflushed(meaning they are run until there are no more left) and may update the calculation if the Effects have impacts on layout. React takes this new calculation and compares it to the calculation used to create the previous version of your UI, thencommitsjust the minimum changes needed to theDOM(what your user actually sees) to catch it up to the latest version."
                },
                {
                    "type": "header",
                    "level": 5,
                    "text": "Deep Dive"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "How to tell if code runs in render"
                },
                {
                    "type": "p",
                    "text": "One quick heuristic to tell if code runs during render is to examine where it is: if it’s written at the top level like in the example below, there’s a good chance it runs during render."
                },
                {
                    "type": "code",
                    "code": "functionDropdown(){constselectedItems=newSet();// created during render// ...}"
                },
                {
                    "type": "p",
                    "text": "Event handlers and Effects don’t run in render:"
                },
                {
                    "type": "code",
                    "code": "functionDropdown(){constselectedItems=newSet();constonSelect=(item)=>{// this code is in an event handler, so it's only run when the user triggers thisselectedItems.add(item);}}"
                },
                {
                    "type": "code",
                    "code": "functionDropdown(){constselectedItems=newSet();useEffect(()=>{// this code is inside of an Effect, so it only runs after renderinglogForAnalytics(selectedItems);},[selectedItems]);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Components and Hooks must be idempotent"
                },
                {
                    "type": "p",
                    "text": "Components must always return the same output with respect to their inputs – props, state, and context. This is known asidempotency.Idempotencyis a term popularized in functional programming. It refers to the idea that youalways get the same result every timeyou run that piece of code with the same inputs."
                },
                {
                    "type": "p",
                    "text": "This means thatallcode that runsduring rendermust also be idempotent in order for this rule to hold. For example, this line of code is not idempotent (and therefore, neither is the component):"
                },
                {
                    "type": "code",
                    "code": "functionClock(){consttime=newDate();// 🔴 Bad: always returns a different result!return<span>{time.toLocaleString()}</span>}"
                },
                {
                    "type": "p",
                    "text": "new Date()is not idempotent as it always returns the current date and changes its result every time it’s called. When you render the above component, the time displayed on the screen will stay stuck on the time that the component was rendered. Similarly, functions likeMath.random()also aren’t idempotent, because they return different results every time they’re called, even when the inputs are the same."
                },
                {
                    "type": "p",
                    "text": "This doesn’t mean you shouldn’t use non-idempotent functions likenew Date()at all– you should just avoid using themduring render. In this case, we cansynchronizethe latest date to this component using anEffect:"
                },
                {
                    "type": "code",
                    "code": "import{useState,useEffect}from'react';functionuseTime(){// 1. Keep track of the current date's state. `useState` receives an initializer function as its//    initial state. It only runs once when the hook is called, so only the current date at the//    time the hook is called is set first.const[time,setTime]=useState(()=>newDate());useEffect(()=>{// 2. Update the current date every second using `setInterval`.constid=setInterval(()=>{setTime(newDate());// ✅ Good: non-idempotent code no longer runs in render},1000);// 3. Return a cleanup function so we don't leak the `setInterval` timer.return()=>clearInterval(id);},[]);returntime;}exportdefaultfunctionClock(){consttime=useTime();return<span>{time.toLocaleString()}</span>;}"
                },
                {
                    "type": "p",
                    "text": "By wrapping the non-idempotentnew Date()call in an Effect, it moves that calculationoutside of rendering."
                },
                {
                    "type": "p",
                    "text": "If you don’t need to synchronize some external state with React, you can also consider using anevent handlerif it only needs to be updated in response to a user interaction."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Side effects must run outside of render"
                },
                {
                    "type": "p",
                    "text": "Side effectsshould not runin render, as React can render components multiple times to create the best possible user experience."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Side effects are a broader term than Effects. Effects specifically refer to code that’s wrapped inuseEffect, while a side effect is a general term for code that has any observable effect other than its primary result of returning a value to the caller."
                },
                {
                    "type": "p",
                    "text": "Side effects are typically written inside ofevent handlersor Effects. But never during render."
                },
                {
                    "type": "p",
                    "text": "While render must be kept pure, side effects are necessary at some point in order for your app to do anything interesting, like showing something on the screen! The key point of this rule is that side effects should not runin render, as React can render components multiple times. In most cases, you’ll useevent handlersto handle side effects. Using an event handler explicitly tells React that this code doesn’t need to run during render, keeping render pure. If you’ve exhausted all options – and only as a last resort – you can also handle side effects usinguseEffect."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "When is it okay to have mutation?"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Local mutation"
                },
                {
                    "type": "p",
                    "text": "One common example of a side effect is mutation, which in JavaScript refers to changing the value of a non-primitivevalue. In general, while mutation is not idiomatic in React,localmutation is absolutely fine:"
                },
                {
                    "type": "code",
                    "code": "functionFriendList({friends}){constitems=[];// ✅ Good: locally createdfor(leti=0;i<friends.length;i++){constfriend=friends[i];items.push(<Friendkey={friend.id}friend={friend}/>);// ✅ Good: local mutation is okay}return<section>{items}</section>;}"
                },
                {
                    "type": "p",
                    "text": "There is no need to contort your code to avoid local mutation.Array.mapcould also be used here for brevity, but there is nothing wrong with creating a local array and then pushing items into itduring render."
                },
                {
                    "type": "p",
                    "text": "Even though it looks like we are mutatingitems, the key point to note is that this code only does solocally– the mutation isn’t “remembered” when the component is rendered again. In other words,itemsonly stays around as long as the component does. Becauseitemsis alwaysrecreatedevery time<FriendList />is rendered, the component will always return the same result."
                },
                {
                    "type": "p",
                    "text": "On the other hand, ifitemswas created outside of the component, it holds on to its previous values and remembers changes:"
                },
                {
                    "type": "code",
                    "code": "constitems=[];// 🔴 Bad: created outside of the componentfunctionFriendList({friends}){for(leti=0;i<friends.length;i++){constfriend=friends[i];items.push(<Friendkey={friend.id}friend={friend}/>);// 🔴 Bad: mutates a value created outside of render}return<section>{items}</section>;}"
                },
                {
                    "type": "p",
                    "text": "When<FriendList />runs again, we will continue appendingfriendstoitemsevery time that component is run, leading to multiple duplicated results. This version of<FriendList />has observable side effectsduring renderandbreaks the rule."
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Lazy initialization"
                },
                {
                    "type": "p",
                    "text": "Lazy initialization is also fine despite not being fully “pure”:"
                },
                {
                    "type": "code",
                    "code": "functionExpenseForm(){SuperCalculator.initializeIfNotReady();// ✅ Good: if it doesn't affect other components// Continue rendering...}"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Changing the DOM"
                },
                {
                    "type": "p",
                    "text": "Side effects that are directly visible to the user are not allowed in the render logic of React components. In other words, merely calling a component function shouldn’t by itself produce a change on the screen."
                },
                {
                    "type": "code",
                    "code": "functionProductDetailPage({product}){document.title=product.title;// 🔴 Bad: Changes the DOM}"
                },
                {
                    "type": "p",
                    "text": "One way to achieve the desired result of updatingwindow.titleoutside of render is tosynchronize the component withwindow."
                },
                {
                    "type": "p",
                    "text": "As long as calling a component multiple times is safe and doesn’t affect the rendering of other components, React doesn’t care if it’s 100% pure in the strict functional programming sense of the word. It is more important thatcomponents must be idempotent."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Props and state are immutable"
                },
                {
                    "type": "p",
                    "text": "A component’s props and state are immutablesnapshots. Never mutate them directly. Instead, pass new props down, and use the setter function fromuseState."
                },
                {
                    "type": "p",
                    "text": "You can think of the props and state values as snapshots that are updated after rendering. For this reason, you don’t modify the props or state variables directly: instead you pass new props, or use the setter function provided to you to tell React that state needs to update the next time the component is rendered."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Don’t mutate Props"
                },
                {
                    "type": "p",
                    "text": "Props are immutable because if you mutate them, the application will produce inconsistent output, which can be hard to debug since it may or may not work depending on the circumstance."
                },
                {
                    "type": "code",
                    "code": "functionPost({item}){item.url=newUrl(item.url,base);// 🔴 Bad: never mutate props directlyreturn<Linkurl={item.url}>{item.title}</Link>;}"
                },
                {
                    "type": "code",
                    "code": "functionPost({item}){consturl=newUrl(item.url,base);// ✅ Good: make a copy insteadreturn<Linkurl={url}>{item.title}</Link>;}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Don’t mutate State"
                },
                {
                    "type": "p",
                    "text": "useStatereturns the state variable and a setter to update that state."
                },
                {
                    "type": "code",
                    "code": "const[stateVariable,setter]=useState(0);"
                },
                {
                    "type": "p",
                    "text": "Rather than updating the state variable in-place, we need to update it using the setter function that is returned byuseState. Changing values on the state variable doesn’t cause the component to update, leaving your users with an outdated UI. Using the setter function informs React that the state has changed, and that we need to queue a re-render to update the UI."
                },
                {
                    "type": "code",
                    "code": "functionCounter(){const[count,setCount]=useState(0);functionhandleClick(){count=count+1;// 🔴 Bad: never mutate state directly}return(<buttononClick={handleClick}>You pressed me{count}times</button>);}"
                },
                {
                    "type": "code",
                    "code": "functionCounter(){const[count,setCount]=useState(0);functionhandleClick(){setCount(count+1);// ✅ Good: use the setter function returned by useState}return(<buttononClick={handleClick}>You pressed me{count}times</button>);}"
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Return values and arguments to Hooks are immutable"
                },
                {
                    "type": "p",
                    "text": "Once values are passed to a hook, you should not modify them. Like props in JSX, values become immutable when passed to a hook."
                },
                {
                    "type": "code",
                    "code": "functionuseIconStyle(icon){consttheme=useContext(ThemeContext);if(icon.enabled){icon.className=computeStyle(icon,theme);// 🔴 Bad: never mutate hook arguments directly}returnicon;}"
                },
                {
                    "type": "code",
                    "code": "functionuseIconStyle(icon){consttheme=useContext(ThemeContext);constnewIcon={...icon};// ✅ Good: make a copy insteadif(icon.enabled){newIcon.className=computeStyle(icon,theme);}returnnewIcon;}"
                },
                {
                    "type": "p",
                    "text": "One important principle in React islocal reasoning: the ability to understand what a component or hook does by looking at its code in isolation. Hooks should be treated like “black boxes” when they are called. For example, a custom hook might have used its arguments as dependencies to memoize values inside it:"
                },
                {
                    "type": "code",
                    "code": "functionuseIconStyle(icon){consttheme=useContext(ThemeContext);returnuseMemo(()=>{constnewIcon={...icon};if(icon.enabled){newIcon.className=computeStyle(icon,theme);}returnnewIcon;},[icon,theme]);}"
                },
                {
                    "type": "p",
                    "text": "If you were to mutate the Hooks arguments, the custom hook’s memoization will become incorrect,  so it’s important to avoid doing that."
                },
                {
                    "type": "code",
                    "code": "style=useIconStyle(icon);// `style` is memoized based on `icon`icon.enabled=false;// Bad: 🔴 never mutate hook arguments directlystyle=useIconStyle(icon);// previously memoized result is returned"
                },
                {
                    "type": "code",
                    "code": "style=useIconStyle(icon);// `style` is memoized based on `icon`icon={...icon,enabled:false};// Good: ✅ make a copy insteadstyle=useIconStyle(icon);// new value of `style` is calculated"
                },
                {
                    "type": "p",
                    "text": "Similarly, it’s important to not modify the return values of Hooks, as they may have been memoized."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Values are immutable after being passed to JSX"
                },
                {
                    "type": "p",
                    "text": "Don’t mutate values after they’ve been used in JSX. Move the mutation before the JSX is created."
                },
                {
                    "type": "p",
                    "text": "When you use JSX in an expression, React may eagerly evaluate the JSX before the component finishes rendering. This means that mutating values after they’ve been passed to JSX can lead to outdated UIs, as React won’t know to update the component’s output."
                },
                {
                    "type": "code",
                    "code": "functionPage({colour}){conststyles={colour,size:\"large\"};constheader=<Headerstyles={styles}/>;styles.size=\"small\";// 🔴 Bad: styles was already used in the JSX aboveconstfooter=<Footerstyles={styles}/>;return(<>{header}<Content/>{footer}</>);}"
                },
                {
                    "type": "code",
                    "code": "functionPage({colour}){constheaderStyles={colour,size:\"large\"};constheader=<Headerstyles={headerStyles}/>;constfooterStyles={colour,size:\"small\"};// ✅ Good: we created a new valueconstfooter=<Footerstyles={footerStyles}/>;return(<>{header}<Content/>{footer}</>);}"
                }
            ]
        },
        {
            "url": "https://react.dev/reference/rules/react-calls-components-and-hooks",
            "title": "React calls Components and Hooks – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "React calls Components and Hooks"
                },
                {
                    "type": "p",
                    "text": "React is responsible for rendering components and Hooks when necessary to optimize the user experience. It is declarative: you tell React what to render in your component’s logic, and React will figure out how best to display it to your user."
                },
                {
                    "type": "list",
                    "items": [
                        "Never call component functions directly",
                        "Never pass around Hooks as regular valuesDon’t dynamically mutate a HookDon’t dynamically use Hooks",
                        "Don’t dynamically mutate a Hook",
                        "Don’t dynamically use Hooks"
                    ]
                },
                {
                    "type": "list",
                    "items": [
                        "Don’t dynamically mutate a Hook",
                        "Don’t dynamically use Hooks"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Never call component functions directly"
                },
                {
                    "type": "p",
                    "text": "Components should only be used in JSX. Don’t call them as regular functions. React should call it."
                },
                {
                    "type": "p",
                    "text": "React must decide when your component function is calledduring rendering. In React, you do this using JSX."
                },
                {
                    "type": "code",
                    "code": "functionBlogPost(){return<Layout><Article/></Layout>;// ✅ Good: Only use components in JSX}"
                },
                {
                    "type": "code",
                    "code": "functionBlogPost(){return<Layout>{Article()}</Layout>;// 🔴 Bad: Never call them directly}"
                },
                {
                    "type": "p",
                    "text": "If a component contains Hooks, it’s easy to violate theRules of Hookswhen components are called directly in a loop or conditionally."
                },
                {
                    "type": "p",
                    "text": "Letting React orchestrate rendering also allows a number of benefits:"
                },
                {
                    "type": "list",
                    "items": [
                        "Components become more than functions.React can augment them with features likelocal statethrough Hooks that are tied to the component’s identity in the tree.",
                        "Component types participate in reconciliation.By letting React call your components, you also tell it more about the conceptual structure of your tree. For example, when you move from rendering<Feed>to the<Profile>page, React won’t attempt to re-use them.",
                        "React can enhance your user experience.For example, it can let the browser do some work between component calls so that re-rendering a large component tree doesn’t block the main thread.",
                        "A better debugging story.If components are first-class citizens that the library is aware of, we can build rich developer tools for introspection in development.",
                        "More efficient reconciliation.React can decide exactly which components in the tree need re-rendering and skip over the ones that don’t. That makes your app faster and more snappy."
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Never pass around Hooks as regular values"
                },
                {
                    "type": "p",
                    "text": "Hooks should only be called inside of components or Hooks. Never pass it around as a regular value."
                },
                {
                    "type": "p",
                    "text": "Hooks allow you to augment a component with React features. They should always be called as a function, and never passed around as a regular value. This enableslocal reasoning, or the ability for developers to understand everything a component can do by looking at that component in isolation."
                },
                {
                    "type": "p",
                    "text": "Breaking this rule will cause React to not automatically optimize your component."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Don’t dynamically mutate a Hook"
                },
                {
                    "type": "p",
                    "text": "Hooks should be as “static” as possible. This means you shouldn’t dynamically mutate them. For example, this means you shouldn’t write higher order Hooks:"
                },
                {
                    "type": "code",
                    "code": "functionChatInput(){constuseDataWithLogging=withLogging(useData);// 🔴 Bad: don't write higher order Hooksconstdata=useDataWithLogging();}"
                },
                {
                    "type": "p",
                    "text": "Hooks should be immutable and not be mutated. Instead of mutating a Hook dynamically, create a static version of the Hook with the desired functionality."
                },
                {
                    "type": "code",
                    "code": "functionChatInput(){constdata=useDataWithLogging();// ✅ Good: Create a new version of the Hook}functionuseDataWithLogging(){// ... Create a new version of the Hook and inline the logic here}"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Don’t dynamically use Hooks"
                },
                {
                    "type": "p",
                    "text": "Hooks should also not be dynamically used: for example, instead of doing dependency injection in a component by passing a Hook as a value:"
                },
                {
                    "type": "code",
                    "code": "functionChatInput(){return<ButtonuseData={useDataWithLogging}/>// 🔴 Bad: don't pass Hooks as props}"
                },
                {
                    "type": "p",
                    "text": "You should always inline the call of the Hook into that component and handle any logic in there."
                },
                {
                    "type": "code",
                    "code": "functionChatInput(){return<Button/>}functionButton(){constdata=useDataWithLogging();// ✅ Good: Use the Hook directly}functionuseDataWithLogging(){// If there's any conditional logic to change the Hook's behavior, it should be inlined into// the Hook}"
                },
                {
                    "type": "p",
                    "text": "This way,<Button />is much easier to understand and debug. When Hooks are used in dynamic ways, it increases the complexity of your app greatly and inhibits local reasoning, making your team less productive in the long term. It also makes it easier to accidentally break theRules of Hooksthat Hooks should not be called conditionally. If you find yourself needing to mock components for tests, it’s better to mock the server instead to respond with canned data. If possible, it’s also usually more effective to test your app with end-to-end tests."
                }
            ]
        },
        {
            "url": "https://react.dev/reference/rules/rules-of-hooks",
            "title": "Rules of Hooks – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "Rules of Hooks"
                },
                {
                    "type": "p",
                    "text": "Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called."
                },
                {
                    "type": "list",
                    "items": [
                        "Only call Hooks at the top level",
                        "Only call Hooks from React functions"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Only call Hooks at the top level"
                },
                {
                    "type": "p",
                    "text": "Functions whose names start withuseare calledHooksin React."
                },
                {
                    "type": "p",
                    "text": "Don’t call Hooks inside loops, conditions, nested functions, ortry/catch/finallyblocks.Instead, always use Hooks at the top level of your React function, before any early returns. You can only call Hooks while React is rendering a function component:"
                },
                {
                    "type": "list",
                    "items": [
                        "✅ Call them at the top level in the body of afunction component.",
                        "✅ Call them at the top level in the body of acustom Hook."
                    ]
                },
                {
                    "type": "code",
                    "code": "functionCounter(){// ✅ Good: top-level in a function componentconst[count,setCount]=useState(0);// ...}functionuseWindowWidth(){// ✅ Good: top-level in a custom Hookconst[width,setWidth]=useState(window.innerWidth);// ...}"
                },
                {
                    "type": "p",
                    "text": "It’snotsupported to call Hooks (functions starting withuse) in any other cases, for example:"
                },
                {
                    "type": "list",
                    "items": [
                        "🔴 Do not call Hooks inside conditions or loops.",
                        "🔴 Do not call Hooks after a conditionalreturnstatement.",
                        "🔴 Do not call Hooks in event handlers.",
                        "🔴 Do not call Hooks in class components.",
                        "🔴 Do not call Hooks inside functions passed touseMemo,useReducer, oruseEffect.",
                        "🔴 Do not call Hooks insidetry/catch/finallyblocks."
                    ]
                },
                {
                    "type": "p",
                    "text": "If you break these rules, you might see this error."
                },
                {
                    "type": "code",
                    "code": "functionBad({cond}){if(cond){// 🔴 Bad: inside a condition (to fix, move it outside!)consttheme=useContext(ThemeContext);}// ...}functionBad(){for(leti=0;i<10;i++){// 🔴 Bad: inside a loop (to fix, move it outside!)consttheme=useContext(ThemeContext);}// ...}functionBad({cond}){if(cond){return;}// 🔴 Bad: after a conditional return (to fix, move it before the return!)consttheme=useContext(ThemeContext);// ...}functionBad(){functionhandleClick(){// 🔴 Bad: inside an event handler (to fix, move it outside!)consttheme=useContext(ThemeContext);}// ...}functionBad(){conststyle=useMemo(()=>{// 🔴 Bad: inside useMemo (to fix, move it outside!)consttheme=useContext(ThemeContext);returncreateStyle(theme);});// ...}classBadextendsReact.Component{render(){// 🔴 Bad: inside a class component (to fix, write a function component instead of a class!)useEffect(()=>{})// ...}}functionBad(){try{// 🔴 Bad: inside try/catch/finally block (to fix, move it outside!)const[x,setX]=useState(0);}catch{const[x,setX]=useState(1);}}"
                },
                {
                    "type": "p",
                    "text": "You can use theeslint-plugin-react-hookspluginto catch these mistakes."
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "p",
                    "text": "Custom Hooksmaycall other Hooks (that’s their whole purpose). This works because custom Hooks are also supposed to only be called while a function component is rendering."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Only call Hooks from React functions"
                },
                {
                    "type": "p",
                    "text": "Don’t call Hooks from regular JavaScript functions. Instead, you can:"
                },
                {
                    "type": "p",
                    "text": "✅ Call Hooks from React function components.\n✅ Call Hooks fromcustom Hooks."
                },
                {
                    "type": "p",
                    "text": "By following this rule, you ensure that all stateful logic in a component is clearly visible from its source code."
                },
                {
                    "type": "code",
                    "code": "functionFriendList(){const[onlineStatus,setOnlineStatus]=useOnlineStatus();// ✅}functionsetOnlineStatus(){// ❌ Not a component or custom Hook!const[onlineStatus,setOnlineStatus]=useOnlineStatus();}"
                }
            ]
        },
        {
            "url": "https://react.dev/versions",
            "title": "React Versions – React",
            "content": [
                {
                    "type": "header",
                    "level": 1,
                    "text": "React Versions"
                },
                {
                    "type": "p",
                    "text": "The React docs atreact.devprovide documentation for the latest version of React."
                },
                {
                    "type": "p",
                    "text": "We aim to keep the docs updated within major versions, and do not publish versions for each minor or patch version. When a new major is released, we archive the docs for the previous version asx.react.dev. See ourversioning policyfor more info."
                },
                {
                    "type": "p",
                    "text": "You can find an archive of previous major versions below."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Future versions"
                },
                {
                    "type": "list",
                    "items": [
                        "19.react.dev"
                    ]
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Previous versions"
                },
                {
                    "type": "list",
                    "items": [
                        "18.react.dev",
                        "17.react.dev",
                        "16.react.dev",
                        "15.react.dev"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Note"
                },
                {
                    "type": "header",
                    "level": 4,
                    "text": "Legacy Docs"
                },
                {
                    "type": "p",
                    "text": "In 2023, welaunched our new docsfor React 18 asreact.dev. The legacy React 18 docs are available atlegacy.reactjs.org. Versions 17 and below are hosted on legacy sites."
                },
                {
                    "type": "p",
                    "text": "For versions older than React 15, see15.react.dev."
                },
                {
                    "type": "header",
                    "level": 2,
                    "text": "Changelog"
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "React 18"
                },
                {
                    "type": "p",
                    "text": "Blog Posts"
                },
                {
                    "type": "list",
                    "items": [
                        "React v18.0",
                        "How to Upgrade to React 18",
                        "The Plan for React 18"
                    ]
                },
                {
                    "type": "p",
                    "text": "Talks"
                },
                {
                    "type": "list",
                    "items": [
                        "React 18 Keynote",
                        "React 18 for app developers",
                        "Streaming Server Rendering with Suspense",
                        "React without memo",
                        "React Docs Keynote",
                        "React Developer Tooling",
                        "The first React Working Group",
                        "React 18 for External Store Libraries"
                    ]
                },
                {
                    "type": "p",
                    "text": "Releases"
                },
                {
                    "type": "list",
                    "items": [
                        "v18.3.1 (April, 2024)",
                        "v18.3.0 (April, 2024)",
                        "v18.2.0 (June, 2022)",
                        "v18.1.0 (April, 2022)",
                        "v18.0.0 (March 2022)"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "React 17"
                },
                {
                    "type": "p",
                    "text": "Blog Posts"
                },
                {
                    "type": "list",
                    "items": [
                        "React v17.0",
                        "Introducing the New JSX Transform",
                        "React v17.0 Release Candidate: No New Features"
                    ]
                },
                {
                    "type": "p",
                    "text": "Releases"
                },
                {
                    "type": "list",
                    "items": [
                        "v17.0.2 (March 2021)",
                        "v17.0.1 (October 2020)",
                        "v17.0.0 (October 2020)"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "React 16"
                },
                {
                    "type": "p",
                    "text": "Blog Posts"
                },
                {
                    "type": "list",
                    "items": [
                        "React v16.0",
                        "DOM Attributes in React 16",
                        "Error Handling in React 16",
                        "React v16.2.0: Improved Support for Fragments",
                        "React v16.4.0: Pointer Events",
                        "React v16.4.2: Server-side vulnerability fix",
                        "React v16.6.0: lazy, memo and contextType",
                        "React v16.7: No, This Is Not the One With Hooks",
                        "React v16.8: The One With Hooks",
                        "React v16.9.0 and the Roadmap Update",
                        "React v16.13.0"
                    ]
                },
                {
                    "type": "p",
                    "text": "Releases"
                },
                {
                    "type": "list",
                    "items": [
                        "v16.14.0 (October 2020)",
                        "v16.13.1 (March 2020)",
                        "v16.13.0 (February 2020)",
                        "v16.12.0 (November 2019)",
                        "v16.11.0 (October 2019)",
                        "v16.10.2 (October 2019)",
                        "v16.10.1 (September 2019)",
                        "v16.10.0 (September 2019)",
                        "v16.9.0 (August 2019)",
                        "v16.8.6 (March 2019)",
                        "v16.8.5 (March 2019)",
                        "v16.8.4 (March 2019)",
                        "v16.8.3 (February 2019)",
                        "v16.8.2 (February 2019)",
                        "v16.8.1 (February 2019)",
                        "v16.8.0 (February 2019)",
                        "v16.7.0 (December 2018)",
                        "v16.6.3 (November 2018)",
                        "v16.6.2 (November 2018)",
                        "v16.6.1 (November 2018)",
                        "v16.6.0 (October 2018)",
                        "v16.5.2 (September 2018)",
                        "v16.5.1 (September 2018)",
                        "v16.5.0 (September 2018)",
                        "v16.4.2 (August 2018)",
                        "v16.4.1 (June 2018)",
                        "v16.4.0 (May 2018)",
                        "v16.3.3 (August 2018)",
                        "v16.3.2 (April 2018)",
                        "v16.3.1 (April 2018)",
                        "v16.3.0 (March 2018)",
                        "v16.2.1 (August 2018)",
                        "v16.2.0 (November 2017)",
                        "v16.1.2 (August 2018)",
                        "v16.1.1 (November 2017)",
                        "v16.1.0 (November 2017)",
                        "v16.0.1 (August 2018)",
                        "v16.0 (September 2017)"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "React 15"
                },
                {
                    "type": "p",
                    "text": "Blog Posts"
                },
                {
                    "type": "list",
                    "items": [
                        "React v15.0",
                        "React v15.0 Release Candidate 2",
                        "React v15.0 Release Candidate",
                        "New Versioning Scheme",
                        "Discontinuing IE 8 Support in React DOM",
                        "Introducing React’s Error Code System",
                        "React v15.0.1",
                        "React v15.4.0",
                        "React v15.5.0",
                        "React v15.6.0",
                        "React v15.6.2"
                    ]
                },
                {
                    "type": "p",
                    "text": "Releases"
                },
                {
                    "type": "list",
                    "items": [
                        "v15.7.0 (October 2017)",
                        "v15.6.2 (September 2017)",
                        "v15.6.1 (June 2017)",
                        "v15.6.0 (June 2017)",
                        "v15.5.4 (April 2017)",
                        "v15.5.3 (April 2017)",
                        "v15.5.2 (April 2017)",
                        "v15.5.1 (April 2017)",
                        "v15.5.0 (April 2017)",
                        "v15.4.2 (January 2016)",
                        "v15.4.1 (November 2016)",
                        "v15.4.0 (November 2016)",
                        "v15.3.2 (September 2016)",
                        "v15.3.1 (August 2016)",
                        "v15.3.0 (July 2016)",
                        "v15.2.1 (July 2016)",
                        "v15.2.0 (July 2016)",
                        "v15.1.0 (May 2016)",
                        "v15.0.2 (April 2016)",
                        "v15.0.1 (April 2016)",
                        "v15.0.0 (April 2016)"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "React 0.14"
                },
                {
                    "type": "p",
                    "text": "Blog Posts"
                },
                {
                    "type": "list",
                    "items": [
                        "React v0.14",
                        "React v0.14 Release Candidate",
                        "React v0.14 Beta 1",
                        "New React Developer Tools",
                        "New React Devtools Beta",
                        "React v0.14.1",
                        "React v0.14.2",
                        "React v0.14.3",
                        "React v0.14.4",
                        "React v0.14.8"
                    ]
                },
                {
                    "type": "p",
                    "text": "Releases"
                },
                {
                    "type": "list",
                    "items": [
                        "v0.14.10 (October 2020)",
                        "v0.14.8 (March 2016)",
                        "v0.14.7 (January 2016)",
                        "v0.14.6 (January 2016)",
                        "v0.14.5 (December 2015)",
                        "v0.14.4 (December 2015)",
                        "v0.14.3 (November 2015)",
                        "v0.14.2 (November 2015)",
                        "v0.14.1 (October 2015)",
                        "v0.14.0 (October 2015)"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "React 0.13"
                },
                {
                    "type": "p",
                    "text": "Blog Posts"
                },
                {
                    "type": "list",
                    "items": [
                        "React Native v0.4",
                        "React v0.13",
                        "React v0.13 RC2",
                        "React v0.13 RC",
                        "React v0.13.0 Beta 1",
                        "Streamlining React Elements",
                        "Introducing Relay and GraphQL",
                        "Introducing React Native",
                        "React v0.13.1",
                        "React v0.13.2",
                        "React v0.13.3"
                    ]
                },
                {
                    "type": "p",
                    "text": "Releases"
                },
                {
                    "type": "list",
                    "items": [
                        "v0.13.3 (May 2015)",
                        "v0.13.2 (April 2015)",
                        "v0.13.1 (March 2015)",
                        "v0.13.0 (March 2015)"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "React 0.12"
                },
                {
                    "type": "p",
                    "text": "Blog Posts"
                },
                {
                    "type": "list",
                    "items": [
                        "React v0.12",
                        "React v0.12 RC",
                        "Introducing React Elements",
                        "React v0.12.2"
                    ]
                },
                {
                    "type": "p",
                    "text": "Releases"
                },
                {
                    "type": "list",
                    "items": [
                        "v0.12.2 (December 2014)",
                        "v0.12.1 (November 2014)",
                        "v0.12.0 (October 2014)"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "React 0.11"
                },
                {
                    "type": "p",
                    "text": "Blog Posts"
                },
                {
                    "type": "list",
                    "items": [
                        "React v0.11",
                        "React v0.11 RC",
                        "One Year of Open-Source React",
                        "The Road to 1.0",
                        "React v0.11.1",
                        "React v0.11.2",
                        "Introducing the JSX Specificaion"
                    ]
                },
                {
                    "type": "p",
                    "text": "Releases"
                },
                {
                    "type": "list",
                    "items": [
                        "v0.11.2 (September 2014)",
                        "v0.11.1 (July 2014)",
                        "v0.11.0 (July 2014)"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "React 0.10 and below"
                },
                {
                    "type": "p",
                    "text": "Blog Posts"
                },
                {
                    "type": "list",
                    "items": [
                        "React v0.10",
                        "React v0.10 RC",
                        "React v0.9",
                        "React v0.9 RC",
                        "React Chrome Developer Tools",
                        "React v0.8",
                        "React v0.5.2, v0.4.2",
                        "React v0.5.1",
                        "React v0.5",
                        "React v0.4.1",
                        "React v0.4.0",
                        "New in React v0.4: Prop Validation and Default Values",
                        "New in React v0.4: Autobind by Default",
                        "React v0.3.3"
                    ]
                },
                {
                    "type": "p",
                    "text": "Releases"
                },
                {
                    "type": "list",
                    "items": [
                        "v0.10.0 (March 2014)",
                        "v0.9.0 (February 2014)",
                        "v0.8.0 (December 2013)",
                        "v0.5.2 (December 2013)",
                        "v0.5.1 (October 2013)",
                        "v0.5.0 (October 2013)",
                        "v0.4.1 (July 2013)",
                        "v0.4.0 (July 2013)",
                        "v0.3.3 (June 2013)",
                        "v0.3.2 (May 2013)",
                        "v0.3.1 (May 2013)",
                        "v0.3.0 (May 2013)"
                    ]
                },
                {
                    "type": "header",
                    "level": 3,
                    "text": "Initial Commit"
                },
                {
                    "type": "p",
                    "text": "React was open-sourced on May 29, 2013. The initial commit is:75897c: Initial public release"
                },
                {
                    "type": "p",
                    "text": "See the first blog post:Why did we build React?"
                },
                {
                    "type": "p",
                    "text": "React was open sourced at Facebook Seattle in 2013:"
                }
            ]
        }
    ]
}