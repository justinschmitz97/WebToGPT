[{"source": "https://react.dev/reference/react", "title": "React Reference Overview \u2013 React", "text": "React Reference Overview section provides detailed reference documentation working React. introduction React, please visit Learn section. React reference documentation broken functional subsections: React Programmatic React features: - Hooks - Use different React features components. - Components - Built-in components use JSX. - APIs - APIs useful defining components. - Directives - Provide instructions bundlers compatible React Server Components. React DOM React-dom contains features supported web applications (which run browser DOM environment). section broken following: - Hooks - Hooks web applications run browser DOM environment. - Components - React supports browser built-in HTML SVG components. - APIs - react-dom package contains methods supported web applications. - Client APIs - react-dom/client APIs let render React components client (in browser). - Server APIs - react-dom/server APIs let render React components HTML server. Rules React React idioms \u2014 rules \u2014 express patterns way easy understand yields high-quality applications: - Components Hooks must pure \u2013 Purity makes code easier understand, debug, allows React automatically optimize components hooks correctly. - React calls Components Hooks \u2013 React responsible rendering components hooks necessary optimize user experience. - Rules Hooks \u2013 Hooks defined using JavaScript functions, represent special type reusable UI logic restrictions called. Legacy APIs - Legacy APIs - Exported react package, recommended use newly written code."},
{"source": "https://react.dev/reference/react", "title": "React Reference Overview \u2013 React", "text": "React Reference Overview section provides detailed reference documentation working React. introduction React, please visit Learn section. React reference documentation broken functional subsections: React Programmatic React features: - Hooks - Use different React features components. - Components - Built-in components use JSX. - APIs - APIs useful defining components. - Directives - Provide instructions bundlers compatible React Server Components. React DOM React-dom contains features supported web applications (which run browser DOM environment). section broken following: - Hooks - Hooks web applications run browser DOM environment. - Components - React supports browser built-in HTML SVG components. - APIs - react-dom package contains methods supported web applications. - Client APIs - react-dom/client APIs let render React components client (in browser). - Server APIs - react-dom/server APIs let render React components HTML server. Rules React React idioms \u2014 rules \u2014 express patterns way easy understand yields high-quality applications: - Components Hooks must pure \u2013 Purity makes code easier understand, debug, allows React automatically optimize components hooks correctly. - React calls Components Hooks \u2013 React responsible rendering components hooks necessary optimize user experience. - Rules Hooks \u2013 Hooks defined using JavaScript functions, represent special type reusable UI logic restrictions called. Legacy APIs - Legacy APIs - Exported react package, recommended use newly written code."},
{"source": "https://react.dev/reference/react-dom", "title": "React DOM APIs \u2013 React", "text": "React DOM APIs react-dom package contains methods supported web applications (which run browser DOM environment). supported React Native. APIs APIs imported components. rarely used: createPortal lets render child components different part DOM tree.flushSync lets force React flush state update update DOM synchronously. Resource Preloading APIs APIs used make apps faster pre-loading resources scripts, stylesheets, fonts soon know need them, example navigating another page resources used. React-based frameworks frequently handle resource loading you, might call APIs yourself. Consult framework\u2019s documentation details. prefetchDNS lets prefetch IP address DNS domain name expect connect to.preconnect lets connect server expect request resources from, even don\u2019t know resources you\u2019ll need yet.preload lets fetch stylesheet, font, image, external script expect use.preloadModule lets fetch ESM module expect use.preinit lets fetch evaluate external script fetch insert stylesheet.preinitModule lets fetch evaluate ESM module. Entry points react-dom package provides two additional entry points: react-dom/client contains APIs render React components client (in browser).react-dom/server contains APIs render React components server. Removed APIs APIs removed React 19: findDOMNode : see alternatives.hydrate : usehydrateRoot instead.render : usecreateRoot instead.unmountComponentAtNode : useroot.unmount() instead.renderToNodeStream : usereact-dom/server APIs instead.renderToStaticNodeStream : usereact-dom/server APIs instead."},
{"source": "https://react.dev/reference/react-dom/client", "title": "Client React DOM APIs \u2013 React", "text": "Client React DOM APIs react-dom/client APIs let render React components client (in browser). APIs typically used top level app initialize React tree. framework may call you. components don\u2019t need import use them. Client APIs createRoot lets create root display React components inside browser DOM node.hydrateRoot lets display React components inside browser DOM node whose HTML content previously generated byreact-dom/server . Browser support React supports popular browsers, including Internet Explorer 9 above. polyfills required older browsers IE 9 IE 10."},
{"source": "https://react.dev/reference/react-dom/client/createRoot", "title": "createRoot \u2013 React", "text": "createRoot createRoot lets create root display React components inside browser DOM node. const root = createRoot(domNode, options?) Reference createRoot(domNode, options?) Call createRoot create React root displaying content inside browser DOM element. import { createRoot } 'react-dom/client'; const domNode = document.getElementById('root'); const root = createRoot(domNode); React create root domNode , take managing DOM inside it. you\u2019ve created root, need call root.render display React component inside it: root.render(<App />); app fully built React usually one createRoot call root component. page uses \u201csprinkles\u201d React parts page may many separate roots needed. Parameters - domNode : DOM element. React create root DOM element allow call functions root, asrender display rendered React content. - optional options : object options React root.- optional onCaughtError : Callback called React catches error Error Boundary. Called theerror caught Error Boundary, anerrorInfo object containing thecomponentStack . - optional onUncaughtError : Callback called error thrown caught Error Boundary. Called theerror thrown, anerrorInfo object containing thecomponentStack . - optional onRecoverableError : Callback called React automatically recovers errors. Called anerror React throws, anerrorInfo object containing thecomponentStack . recoverable errors may include original error cause aserror.cause . - optional identifierPrefix : string prefix React uses IDs generated byuseId . Useful avoid conflicts using multiple roots page. - optional Returns createRoot returns object two methods: render unmount . Caveats - app server-rendered, using createRoot() supported. UsehydrateRoot() instead. - You\u2019ll likely one createRoot call app. use framework, might call you. - want render piece JSX different part DOM tree isn\u2019t child component (for example, modal tooltip), use createPortal instead ofcreateRoot . root.render(reactNode) Call root.render display piece JSX (\u201cReact node\u201d) React root\u2019s browser DOM node. root.render(<App />); React display <App /> root , take managing DOM inside it. Parameters reactNode : React node want display. usually piece JSX like<App /> , also pass React element constructed withcreateElement() , string, number,null , orundefined . Returns root.render returns undefined . Caveats - first time call root.render , React clear existing HTML content inside React root rendering React component it. - root\u2019s DOM node contains HTML generated React server build, use hydrateRoot() instead, attaches event handlers existing HTML. - call render root once, React update DOM necessary reflect latest JSX passed. React decide parts DOM reused need recreated \u201cmatching up\u201d previously rendered tree. Callingrender root similar calling theset function root component: React avoids unnecessary DOM updates. root.unmount() Call root.unmount destroy rendered tree inside React root. root.unmount(); app fully built React usually calls root.unmount . mostly useful React root\u2019s DOM node (or ancestors) may get removed DOM code. example, imagine jQuery tab panel removes inactive tabs DOM. tab gets removed, everything inside (including React roots inside) would get removed DOM well. case, need tell React \u201cstop\u201d managing removed root\u2019s content calling root.unmount . Otherwise, components inside removed root won\u2019t know clean free global resources like subscriptions. Calling root.unmount unmount components root \u201cdetach\u201d React root DOM node, including removing event handlers state tree. Parameters root.unmount accept parameters. Returns root.unmount returns undefined . Caveats - Calling root.unmount unmount components tree \u201cdetach\u201d React root DOM node. - call root.unmount cannot callroot.render root. Attempting callroot.render unmounted root throw \u201cCannot update unmounted root\u201d error. However, create new root DOM node previous root node unmounted. Usage Rendering app fully built React app fully built React, create single root entire app. import { createRoot } 'react-dom/client'; const root = createRoot(document.getElementById('root')); root.render(<App />); Usually, need run code startup. will: - Find browser DOM node defined HTML. - Display React component app inside. import { createRoot } 'react-dom/client'; import App './App.js'; import './styles.css'; const root = createRoot(document.getElementById('root')); root.render(<App />); app fully built React, shouldn\u2019t need create roots, call root.render again. point on, React manage DOM entire app. add components, nest inside App component. need update UI, components using state. need display extra content like modal tooltip outside DOM node, render portal. Rendering page partially built React page isn\u2019t fully built React, call createRoot multiple times create root top-level piece UI managed React. display different content root calling root.render . Here, two different React components rendered two DOM nodes defined index.html file: import './styles.css'; import { createRoot } 'react-dom/client'; import { Comments, Navigation } './Components.js'; const navDomNode = document.getElementById('navigation'); const navRoot = createRoot(navDomNode); navRoot.render(<Navigation />); const commentDomNode = document.getElementById('comments'); const commentRoot = createRoot(commentDomNode); commentRoot.render(<Comments />); could also create new DOM node document.createElement() add document manually. const domNode = document.createElement('div'); const root = createRoot(domNode); root.render(<Comment />); document.body.appendChild(domNode); // add anywhere document remove React tree DOM node clean resources used it, call root.unmount . root.unmount(); mostly useful React components inside app written different framework. Updating root component call render root. long component tree structure matches previously rendered, React preserve state. Notice type input, means updates repeated render calls every second example destructive: import { createRoot } 'react-dom/client'; import './styles.css'; import App './App.js'; const root = createRoot(document.getElementById('root')); let = 0; setInterval(() => { root.render(<App counter={i} />); i++; }, 1000); uncommon call render multiple times. Usually, components update state instead. Show dialog uncaught errors default, React log uncaught errors console. implement error reporting, provide optional onUncaughtError root option: import { createRoot } 'react-dom/client'; const root = createRoot( document.getElementById('root'), { onUncaughtError: (error, errorInfo) => { console.error( 'Uncaught error', error, errorInfo.componentStack ); } } ); root.render(<App />); onUncaughtError option function called two arguments: - error thrown. - errorInfo object contains componentStack error. use onUncaughtError root option display error dialogs: import { createRoot } \"react-dom/client\"; import App \"./App.js\"; import {reportUncaughtError} \"./reportError\"; import \"./styles.css\"; const container = document.getElementById(\"root\"); const root = createRoot(container, { onUncaughtError: (error, errorInfo) => { (error.message !== 'Known error') { reportUncaughtError({ error, componentStack: errorInfo.componentStack }); } } }); root.render(<App />); Displaying Error Boundary errors default, React log errors caught Error Boundary console.error . override behavior, provide optional onCaughtError root option handle errors caught Error Boundary: import { createRoot } 'react-dom/client'; const root = createRoot( document.getElementById('root'), { onCaughtError: (error, errorInfo) => { console.error( 'Caught error', error, errorInfo.componentStack ); } } ); root.render(<App />); onCaughtError option function called two arguments: - error caught boundary. - errorInfo object contains componentStack error. use onCaughtError root option display error dialogs filter known errors logging: import { createRoot } \"react-dom/client\"; import App \"./App.js\"; import {reportCaughtError} \"./reportError\"; import \"./styles.css\"; const container = document.getElementById(\"root\"); const root = createRoot(container, { onCaughtError: (error, errorInfo) => { (error.message !== 'Known error') { reportCaughtError({ error, componentStack: errorInfo.componentStack, }); } } }); root.render(<App />); Displaying dialog recoverable errors React may automatically render component second time attempt recover error thrown render. successful, React log recoverable error console notify developer. override behavior, provide optional onRecoverableError root option: import { createRoot } 'react-dom/client'; const root = createRoot( document.getElementById('root'), { onRecoverableError: (error, errorInfo) => { console.error( 'Recoverable error', error, error.cause, errorInfo.componentStack, ); } } ); root.render(<App />); onRecoverableError option function called two arguments: - error React throws. errors may include original cause error.cause. - errorInfo object contains componentStack error. use onRecoverableError root option display error dialogs: import { createRoot } \"react-dom/client\"; import App \"./App.js\"; import {reportRecoverableError} \"./reportError\"; import \"./styles.css\"; const container = document.getElementById(\"root\"); const root = createRoot(container, { onRecoverableError: (error, errorInfo) => { reportRecoverableError({ error, cause: error.cause, componentStack: errorInfo.componentStack, }); } }); root.render(<App />); Troubleshooting I\u2019ve created root, nothing displayed Make sure haven\u2019t forgotten actually render app root: import { createRoot } 'react-dom/client'; import App './App.js'; const root = createRoot(document.getElementById('root')); root.render(<App />); that, nothing displayed. I\u2019m getting error: \u201cYou passed second argument root.render\u201d common mistake pass options createRoot root.render(...) : fix, pass root options createRoot(...) , root.render(...) : // \ud83d\udea9 Wrong: root.render takes one argument. root.render(App, {onUncaughtError}); // \u2705 Correct: pass options createRoot. const root = createRoot(container, {onUncaughtError}); root.render(<App />); I\u2019m getting error: \u201cTarget container DOM element\u201d error means whatever you\u2019re passing createRoot DOM node. you\u2019re sure what\u2019s happening, try logging it: const domNode = document.getElementById('root'); console.log(domNode); // ??? const root = createRoot(domNode); root.render(<App />); example, domNode null , means getElementById returned null . happen node document given ID time call. may reasons it: - ID you\u2019re looking might differ ID used HTML file. Check typos! - bundle\u2019s <script> tag cannot \u201csee\u201d DOM nodes appear HTML. Another common way get error write createRoot(<App />) instead createRoot(domNode) . I\u2019m getting error: \u201cFunctions valid React child.\u201d error means whatever you\u2019re passing root.render React component. may happen call root.render Component instead <Component /> : // \ud83d\udea9 Wrong: App function, Component. root.render(App); // \u2705 Correct: <App /> component. root.render(<App />); pass function root.render , instead result calling it: // \ud83d\udea9 Wrong: createApp function, component. root.render(createApp); // \u2705 Correct: call createApp return component. root.render(createApp()); server-rendered HTML gets re-created scratch app server-rendered includes initial HTML generated React, might notice creating root calling root.render deletes HTML, re-creates DOM nodes scratch. slower, resets focus scroll positions, may lose user input. Server-rendered apps must use hydrateRoot instead createRoot : import { hydrateRoot } 'react-dom/client'; import App './App.js'; hydrateRoot( document.getElementById('root'), <App /> ); Note API different. particular, usually root.render call."},
{"source": "https://react.dev/reference/react-dom/client/hydrateRoot", "title": "hydrateRoot \u2013 React", "text": "hydrateRoot hydrateRoot lets display React components inside browser DOM node whose HTML content previously generated react-dom/server . const root = hydrateRoot(domNode, reactNode, options?) - Reference - Usage - Hydrating server-rendered HTML - Hydrating entire document - Suppressing unavoidable hydration mismatch errors - Handling different client server content - Updating hydrated root component - Show dialog uncaught errors - Displaying Error Boundary errors - Show dialog recoverable hydration mismatch errors - Troubleshooting Reference hydrateRoot(domNode, reactNode, options?) Call hydrateRoot \u201cattach\u201d React existing HTML already rendered React server environment. import { hydrateRoot } 'react-dom/client'; const domNode = document.getElementById('root'); const root = hydrateRoot(domNode, reactNode); React attach HTML exists inside domNode , take managing DOM inside it. app fully built React usually one hydrateRoot call root component. Parameters - domNode : DOM element rendered root element server. - reactNode : \u201cReact node\u201d used render existing HTML. usually piece JSX like<App /> rendered aReactDOM Server method asrenderToPipeableStream(<App />) . - optional options : object options React root.- optional onCaughtError : Callback called React catches error Error Boundary. Called theerror caught Error Boundary, anerrorInfo object containing thecomponentStack . - optional onUncaughtError : Callback called error thrown caught Error Boundary. Called theerror thrown anerrorInfo object containing thecomponentStack . - optional onRecoverableError : Callback called React automatically recovers errors. Called theerror React throws, anerrorInfo object containing thecomponentStack . recoverable errors may include original error cause aserror.cause . - optional identifierPrefix : string prefix React uses IDs generated byuseId . Useful avoid conflicts using multiple roots page. Must prefix used server. - optional Returns hydrateRoot returns object two methods: render unmount . Caveats hydrateRoot() expects rendered content identical server-rendered content. treat mismatches bugs fix them.- development mode, React warns mismatches hydration. guarantees attribute differences patched case mismatches. important performance reasons apps, mismatches rare, validating markup would prohibitively expensive. - You\u2019ll likely one hydrateRoot call app. use framework, might call you. - app client-rendered HTML rendered already, using hydrateRoot() supported. UsecreateRoot() instead. root.render(reactNode) Call root.render update React component inside hydrated React root browser DOM element. root.render(<App />); React update <App /> hydrated root . Parameters reactNode : \u201cReact node\u201d want update. usually piece JSX like<App /> , also pass React element constructed withcreateElement() , string, number,null , orundefined . Returns root.render returns undefined . Caveats - call root.render root finished hydrating, React clear existing server-rendered HTML content switch entire root client rendering. root.unmount() Call root.unmount destroy rendered tree inside React root. root.unmount(); app fully built React usually calls root.unmount . mostly useful React root\u2019s DOM node (or ancestors) may get removed DOM code. example, imagine jQuery tab panel removes inactive tabs DOM. tab gets removed, everything inside (including React roots inside) would get removed DOM well. need tell React \u201cstop\u201d managing removed root\u2019s content calling root.unmount . Otherwise, components inside removed root won\u2019t clean free resources like subscriptions. Calling root.unmount unmount components root \u201cdetach\u201d React root DOM node, including removing event handlers state tree. Parameters root.unmount accept parameters. Returns root.unmount returns undefined . Caveats - Calling root.unmount unmount components tree \u201cdetach\u201d React root DOM node. - call root.unmount cannot callroot.render root. Attempting callroot.render unmounted root throw \u201cCannot update unmounted root\u201d error. Usage Hydrating server-rendered HTML app\u2019s HTML generated react-dom/server , need hydrate client. import { hydrateRoot } 'react-dom/client'; hydrateRoot(document.getElementById('root'), <App />); hydrate server HTML inside browser DOM node React component app. Usually, startup. use framework, might behind scenes you. hydrate app, React \u201cattach\u201d components\u2019 logic initial generated HTML server. Hydration turns initial HTML snapshot server fully interactive app runs browser. import './styles.css'; import { hydrateRoot } 'react-dom/client'; import App './App.js'; hydrateRoot( document.getElementById('root'), <App /> ); shouldn\u2019t need call hydrateRoot call places. point on, React managing DOM application. update UI, components use state instead. Hydrating entire document Apps fully built React render entire document JSX, including <html> tag: function App() { return ( <html> <head> <meta charSet=\"utf-8\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> <link rel=\"stylesheet\" href=\"/styles.css\"></link> <title>My app</title> </head> <body> <Router /> </body> </html> ); } hydrate entire document, pass document global first argument hydrateRoot : import { hydrateRoot } 'react-dom/client'; import App './App.js'; hydrateRoot(document, <App />); Suppressing unavoidable hydration mismatch errors single element\u2019s attribute text content unavoidably different server client (for example, timestamp), may silence hydration mismatch warning. silence hydration warnings element, add suppressHydrationWarning={true} : export default function App() { return ( <h1 suppressHydrationWarning={true}> Current Date: {new Date().toLocaleDateString()} </h1> ); } works one level deep, intended escape hatch. Don\u2019t overuse it. Unless it\u2019s text content, React still won\u2019t attempt patch up, may remain inconsistent future updates. Handling different client server content intentionally need render something different server client, two-pass rendering. Components render something different client read state variable like isClient , set true Effect: import { useState, useEffect } \"react\"; export default function App() { const [isClient, setIsClient] = useState(false); useEffect(() => { setIsClient(true); }, []); return ( <h1> {isClient ? 'Is Client' : 'Is Server'} </h1> ); } way initial render pass render content server, avoiding mismatches, additional pass happen synchronously right hydration. Updating hydrated root component root finished hydrating, call root.render update root React component. Unlike createRoot , don\u2019t usually need initial content already rendered HTML. call root.render point hydration, component tree structure matches previously rendered, React preserve state. Notice type input, means updates repeated render calls every second example destructive: import { hydrateRoot } 'react-dom/client'; import './styles.css'; import App './App.js'; const root = hydrateRoot( document.getElementById('root'), <App counter={0} /> ); let = 0; setInterval(() => { root.render(<App counter={i} />); i++; }, 1000); uncommon call root.render hydrated root. Usually, you\u2019ll update state inside one components instead. Show dialog uncaught errors default, React log uncaught errors console. implement error reporting, provide optional onUncaughtError root option: import { hydrateRoot } 'react-dom/client'; const root = hydrateRoot( document.getElementById('root'), <App />, { onUncaughtError: (error, errorInfo) => { console.error( 'Uncaught error', error, errorInfo.componentStack ); } } ); root.render(<App />); onUncaughtError option function called two arguments: - error thrown. - errorInfo object contains componentStack error. use onUncaughtError root option display error dialogs: import { hydrateRoot } \"react-dom/client\"; import App \"./App.js\"; import {reportUncaughtError} \"./reportError\"; import \"./styles.css\"; import {renderToString} 'react-dom/server'; const container = document.getElementById(\"root\"); const root = hydrateRoot(container, <App />, { onUncaughtError: (error, errorInfo) => { (error.message !== 'Known error') { reportUncaughtError({ error, componentStack: errorInfo.componentStack }); } } }); Displaying Error Boundary errors default, React log errors caught Error Boundary console.error . override behavior, provide optional onCaughtError root option errors caught Error Boundary: import { hydrateRoot } 'react-dom/client'; const root = hydrateRoot( document.getElementById('root'), <App />, { onCaughtError: (error, errorInfo) => { console.error( 'Caught error', error, errorInfo.componentStack ); } } ); root.render(<App />); onCaughtError option function called two arguments: - error caught boundary. - errorInfo object contains componentStack error. use onCaughtError root option display error dialogs filter known errors logging: import { hydrateRoot } \"react-dom/client\"; import App \"./App.js\"; import {reportCaughtError} \"./reportError\"; import \"./styles.css\"; const container = document.getElementById(\"root\"); const root = hydrateRoot(container, <App />, { onCaughtError: (error, errorInfo) => { (error.message !== 'Known error') { reportCaughtError({ error, componentStack: errorInfo.componentStack }); } } }); Show dialog recoverable hydration mismatch errors React encounters hydration mismatch, automatically attempt recover rendering client. default, React log hydration mismatch errors console.error . override behavior, provide optional onRecoverableError root option: import { hydrateRoot } 'react-dom/client'; const root = hydrateRoot( document.getElementById('root'), <App />, { onRecoverableError: (error, errorInfo) => { console.error( 'Caught error', error, error.cause, errorInfo.componentStack ); } } ); onRecoverableError option function called two arguments: - error React throws. errors may include original cause error.cause. - errorInfo object contains componentStack error. use onRecoverableError root option display error dialogs hydration mismatches: import { hydrateRoot } \"react-dom/client\"; import App \"./App.js\"; import {reportRecoverableError} \"./reportError\"; import \"./styles.css\"; const container = document.getElementById(\"root\"); const root = hydrateRoot(container, <App />, { onRecoverableError: (error, errorInfo) => { reportRecoverableError({ error, cause: error.cause, componentStack: errorInfo.componentStack }); } }); Troubleshooting I\u2019m getting error: \u201cYou passed second argument root.render\u201d common mistake pass options hydrateRoot root.render(...) : fix, pass root options hydrateRoot(...) , root.render(...) : // \ud83d\udea9 Wrong: root.render takes one argument. root.render(App, {onUncaughtError}); // \u2705 Correct: pass options createRoot. const root = hydrateRoot(container, <App />, {onUncaughtError});"},
{"source": "https://react.dev/reference/react-dom/components", "title": "React DOM Components \u2013 React", "text": "React DOM Components Common components built-in browser components support props events. includes React-specific props like ref dangerouslySetInnerHTML . Form components built-in browser components accept user input: special React passing value prop makes controlled. Resource Metadata Components built-in browser components let load external resources annotate document metadata: special React React render document head, suspend resources loading, enact behaviors described reference page specific component. HTML components React supports built-in browser HTML components. includes: <aside> <audio> <b> <base> <bdi> <bdo> <blockquote> <body> <br> <button> <canvas> <caption> <cite> <code> <col> <colgroup> <data> <datalist> <dd> <del> <details> <dfn> <dialog> <div> <dl> <dt> <em> <embed> <fieldset> <figcaption> <figure> <footer> <form> <h1> <head> <header> <hgroup> <hr> <html> <i> <iframe> <img> <input> <ins> <kbd> <label> <legend> <li> <link> <main> <map> <mark> <menu> <meta> <meter> <nav> <noscript> <object> <ol> <optgroup> <option> <output> <p> <picture> <pre> <progress> <q> <rp> <rt> <ruby> <s> <samp> <script> <section> <select> <slot> <small> <source> <span> <strong> <style> <sub> <summary> <sup> <table> <tbody> <td> <template> <textarea> <tfoot> <th> <thead> <time> <title> <tr> <track> <u> <ul> <var> <video> <wbr> Custom HTML elements render tag dash, like <my-element> , React assume want render custom HTML element. React, rendering custom elements works differently rendering built-in browser tags: - custom element props serialized strings always set using attributes. - Custom elements accept class rather thanclassName , andfor rather thanhtmlFor . render built-in browser HTML element attribute, also treated custom element. SVG components React supports built-in browser SVG components. includes: <a> <animate> <animateMotion> <animateTransform> <circle> <clipPath> <defs> <desc> <discard> <ellipse> <feBlend> <feColorMatrix> <feComponentTransfer> <feComposite> <feConvolveMatrix> <feDiffuseLighting> <feDisplacementMap> <feDistantLight> <feDropShadow> <feFlood> <feFuncA> <feFuncB> <feFuncG> <feFuncR> <feGaussianBlur> <feImage> <feMerge> <feMergeNode> <feMorphology> <feOffset> <fePointLight> <feSpecularLighting> <feSpotLight> <feTile> <feTurbulence> <filter> <foreignObject> <g> <hatch> <hatchpath> <image> <line> <linearGradient> <marker> <mask> <metadata> <mpath> <path> <pattern> <polygon> <polyline> <radialGradient> <rect> <script> <set> <stop> <style> <svg> <switch> <symbol> <text> <textPath> <title> <tspan> <use> <view>"},
{"source": "https://react.dev/reference/react-dom/components/common", "title": "Common components (e.g. <div>) \u2013 React", "text": "Common components (e.g. <div>) built-in browser components, <div> , support common props events. - Reference - Common components (e.g. <div> ) ref callback function- React event object AnimationEvent handler functionClipboardEvent handler functionCompositionEvent handler functionDragEvent handler functionFocusEvent handler functionEvent handler functionInputEvent handler functionKeyboardEvent handler functionMouseEvent handler functionPointerEvent handler functionTouchEvent handler functionTransitionEvent handler functionUIEvent handler functionWheelEvent handler function - Common components (e.g. - Usage Reference Common components (e.g. <div> ) <div className=\"wrapper\">Some content</div> Props special React props supported built-in components: - children : React node (an element, string, number, portal, empty node likenull ,undefined booleans, array React nodes). Specifies content inside component. use JSX, usually specify thechildren prop implicitly nesting tags like<div><span /></div> . - dangerouslySetInnerHTML : object form{ __html: '<p>some html</p>' } raw HTML string inside. Overrides theinnerHTML property DOM node displays passed HTML inside. used extreme caution! HTML inside isn\u2019t trusted (for example, it\u2019s based user data), risk introducing XSS vulnerability. Read usingdangerouslySetInnerHTML . - ref : ref object fromuseRef orcreateRef , aref callback function, string legacy refs. ref filled DOM element node. Read manipulating DOM refs. - suppressContentEditableWarning : boolean. Iftrue , suppresses warning React shows elements havechildren andcontentEditable={true} (which normally work together). Use you\u2019re building text input library manages thecontentEditable content manually. - suppressHydrationWarning : boolean. use server rendering, normally warning server client render different content. rare cases (like timestamps), hard impossible guarantee exact match. setsuppressHydrationWarning totrue , React warn mismatches attributes content element. works one level deep, intended used escape hatch. Don\u2019t overuse it. Read suppressing hydration errors. - style : object CSS styles, example{ fontWeight: 'bold', margin: 20 } . Similarly DOMstyle property, CSS property names need written ascamelCase , examplefontWeight instead offont-weight . pass strings numbers values. pass number, likewidth: 100 , React automatically appendpx (\u201cpixels\u201d) value unless it\u2019s unitless property. recommend usingstyle dynamic styles don\u2019t know style values ahead time. cases, applying plain CSS classes withclassName efficient. Read aboutclassName andstyle . standard DOM props also supported built-in components: accessKey : string. Specifies keyboard shortcut element. generally recommended.aria-* : ARIA attributes let specify accessibility tree information element. See ARIA attributes complete reference. React, ARIA attribute names exactly HTML.autoCapitalize : string. Specifies whether user input capitalized.className : string. Specifies element\u2019s CSS class name. Read applying CSS styles.contentEditable : boolean. Iftrue , browser lets user edit rendered element directly. used implement rich text input libraries like Lexical. React warns try pass React children element withcontentEditable={true} React able update content user edits.data-* : Data attributes let attach string data element, exampledata-fruit=\"banana\" . React, commonly used would usually read data props state instead.dir : Either'ltr' or'rtl' . Specifies text direction element.draggable : boolean. Specifies whether element draggable. Part HTML Drag Drop API.enterKeyHint : string. Specifies action present enter key virtual keyboards.htmlFor : string. For<label> and<output> , lets associate label control. asfor HTML attribute. React uses standard DOM property names (htmlFor ) instead HTML attribute names.hidden : boolean string. Specifies whether element hidden.id : string. Specifies unique identifier element, used find later connect elements. Generate withuseId avoid clashes multiple instances component.is : string. specified, component behave like custom element.inputMode : string. Specifies kind keyboard display (for example, text, number telephone).itemProp : string. Specifies property element represents structured data crawlers.lang : string. Specifies language element.onAnimationEnd : AnAnimationEvent handler function. Fires CSS animation completes.onAnimationEndCapture : version ofonAnimationEnd fires capture phase.onAnimationIteration : AnAnimationEvent handler function. Fires iteration CSS animation ends, another one begins.onAnimationIterationCapture : version ofonAnimationIteration fires capture phase.onAnimationStart : AnAnimationEvent handler function. Fires CSS animation starts.onAnimationStartCapture :onAnimationStart , fires capture phase.onAuxClick : AMouseEvent handler function. Fires non-primary pointer button clicked.onAuxClickCapture : version ofonAuxClick fires capture phase.onBeforeInput : AnInputEvent handler function. Fires value editable element modified. React yet use nativebeforeinput event, instead attempts polyfill using events.onBeforeInputCapture : version ofonBeforeInput fires capture phase.onBlur : AFocusEvent handler function. Fires element lost focus. Unlike built-in browserblur event, React theonBlur event bubbles.onBlurCapture : version ofonBlur fires capture phase.onClick : AMouseEvent handler function. Fires primary button clicked pointing device.onClickCapture : version ofonClick fires capture phase.onCompositionStart : ACompositionEvent handler function. Fires input method editor starts new composition session.onCompositionStartCapture : version ofonCompositionStart fires capture phase.onCompositionEnd : ACompositionEvent handler function. Fires input method editor completes cancels composition session.onCompositionEndCapture : version ofonCompositionEnd fires capture phase.onCompositionUpdate : ACompositionEvent handler function. Fires input method editor receives new character.onCompositionUpdateCapture : version ofonCompositionUpdate fires capture phase.onContextMenu : AMouseEvent handler function. Fires user tries open context menu.onContextMenuCapture : version ofonContextMenu fires capture phase.onCopy : AClipboardEvent handler function. Fires user tries copy something clipboard.onCopyCapture : version ofonCopy fires capture phase.onCut : AClipboardEvent handler function. Fires user tries cut something clipboard.onCutCapture : version ofonCut fires capture phase.onDoubleClick : AMouseEvent handler function. Fires user clicks twice. Corresponds browserdblclick event.onDoubleClickCapture : version ofonDoubleClick fires capture phase.onDrag : ADragEvent handler function. Fires user dragging something.onDragCapture : version ofonDrag fires capture phase.onDragEnd : ADragEvent handler function. Fires user stops dragging something.onDragEndCapture : version ofonDragEnd fires capture phase.onDragEnter : ADragEvent handler function. Fires dragged content enters valid drop target.onDragEnterCapture : version ofonDragEnter fires capture phase.onDragOver : ADragEvent handler function. Fires valid drop target dragged content dragged it. must calle.preventDefault() allow dropping.onDragOverCapture : version ofonDragOver fires capture phase.onDragStart : ADragEvent handler function. Fires user starts dragging element.onDragStartCapture : version ofonDragStart fires capture phase.onDrop : ADragEvent handler function. Fires something dropped valid drop target.onDropCapture : version ofonDrop fires capture phase.onFocus : AFocusEvent handler function. Fires element receives focus. Unlike built-in browserfocus event, React theonFocus event bubbles.onFocusCapture : version ofonFocus fires capture phase.onGotPointerCapture : APointerEvent handler function. Fires element programmatically captures pointer.onGotPointerCaptureCapture : version ofonGotPointerCapture fires capture phase.onKeyDown : AKeyboardEvent handler function. Fires key pressed.onKeyDownCapture : version ofonKeyDown fires capture phase.onKeyPress : AKeyboardEvent handler function. Deprecated. UseonKeyDown oronBeforeInput instead.onKeyPressCapture : version ofonKeyPress fires capture phase.onKeyUp : AKeyboardEvent handler function. Fires key released.onKeyUpCapture : version ofonKeyUp fires capture phase.onLostPointerCapture : APointerEvent handler function. Fires element stops capturing pointer.onLostPointerCaptureCapture : version ofonLostPointerCapture fires capture phase.onMouseDown : AMouseEvent handler function. Fires pointer pressed down.onMouseDownCapture : version ofonMouseDown fires capture phase.onMouseEnter : AMouseEvent handler function. Fires pointer moves inside element. capture phase. Instead,onMouseLeave andonMouseEnter propagate element left one entered.onMouseLeave : AMouseEvent handler function. Fires pointer moves outside element. capture phase. Instead,onMouseLeave andonMouseEnter propagate element left one entered.onMouseMove : AMouseEvent handler function. Fires pointer changes coordinates.onMouseMoveCapture : version ofonMouseMove fires capture phase.onMouseOut : AMouseEvent handler function. Fires pointer moves outside element, moves child element.onMouseOutCapture : version ofonMouseOut fires capture phase.onMouseUp : AMouseEvent handler function. Fires pointer released.onMouseUpCapture : version ofonMouseUp fires capture phase.onPointerCancel : APointerEvent handler function. Fires browser cancels pointer interaction.onPointerCancelCapture : version ofonPointerCancel fires capture phase.onPointerDown : APointerEvent handler function. Fires pointer becomes active.onPointerDownCapture : version ofonPointerDown fires capture phase.onPointerEnter : APointerEvent handler function. Fires pointer moves inside element. capture phase. Instead,onPointerLeave andonPointerEnter propagate element left one entered.onPointerLeave : APointerEvent handler function. Fires pointer moves outside element. capture phase. Instead,onPointerLeave andonPointerEnter propagate element left one entered.onPointerMove : APointerEvent handler function. Fires pointer changes coordinates.onPointerMoveCapture : version ofonPointerMove fires capture phase.onPointerOut : APointerEvent handler function. Fires pointer moves outside element, pointer interaction cancelled, reasons.onPointerOutCapture : version ofonPointerOut fires capture phase.onPointerUp : APointerEvent handler function. Fires pointer longer active.onPointerUpCapture : version ofonPointerUp fires capture phase.onPaste : AClipboardEvent handler function. Fires user tries paste something clipboard.onPasteCapture : version ofonPaste fires capture phase.onScroll : AnEvent handler function. Fires element scrolled. event bubble.onScrollCapture : version ofonScroll fires capture phase.onSelect : AnEvent handler function. Fires selection inside editable element like input changes. React extends theonSelect event work forcontentEditable={true} elements well. addition, React extends fire empty selection edits (which may affect selection).onSelectCapture : version ofonSelect fires capture phase.onTouchCancel : ATouchEvent handler function. Fires browser cancels touch interaction.onTouchCancelCapture : version ofonTouchCancel fires capture phase.onTouchEnd : ATouchEvent handler function. Fires one touch points removed.onTouchEndCapture : version ofonTouchEnd fires capture phase.onTouchMove : ATouchEvent handler function. Fires one touch points moved.onTouchMoveCapture : version ofonTouchMove fires capture phase.onTouchStart : ATouchEvent handler function. Fires one touch points placed.onTouchStartCapture : version ofonTouchStart fires capture phase.onTransitionEnd : ATransitionEvent handler function. Fires CSS transition completes.onTransitionEndCapture : version ofonTransitionEnd fires capture phase.onWheel : AWheelEvent handler function. Fires user rotates wheel button.onWheelCapture : version ofonWheel fires capture phase.role : string. Specifies element role explicitly assistive technologies.slot : string. Specifies slot name using shadow DOM. React, equivalent pattern typically achieved passing JSX props, example<Layout left={<Sidebar />} right={<Content />} /> .spellCheck : boolean null. explicitly set totrue orfalse , enables disables spellchecking.tabIndex : number. Overrides default Tab button behavior. Avoid using values than-1 and0 .title : string. Specifies tooltip text element.translate : Either'yes' or'no' . Passing'no' excludes element content translated. also pass custom attributes props, example mycustomprop=\"someValue\" . useful integrating third-party libraries. custom attribute name must lowercase must start . value converted string. pass null undefined , custom attribute removed. events fire <form> elements: onReset : AnEvent handler function. Fires form gets reset.onResetCapture : version ofonReset fires capture phase.onSubmit : AnEvent handler function. Fires form gets submitted.onSubmitCapture : version ofonSubmit fires capture phase. events fire <dialog> elements. Unlike browser events, bubble React: onCancel : AnEvent handler function. Fires user tries dismiss dialog.onCancelCapture : version ofonCancel fires capture phase.onClose : AnEvent handler function. Fires dialog closed.onCloseCapture : version ofonClose fires capture phase. events fire <details> elements. Unlike browser events, bubble React: onToggle : AnEvent handler function. Fires user toggles details.onToggleCapture : version ofonToggle fires capture phase. events fire <img> , <iframe> , <object> , <embed> , <link> , SVG <image> elements. Unlike browser events, bubble React: onLoad : AnEvent handler function. Fires resource loaded.onLoadCapture : version ofonLoad fires capture phase.onError : AnEvent handler function. Fires resource could loaded.onErrorCapture : version ofonError fires capture phase. events fire resources like <audio> <video> . Unlike browser events, bubble React: onAbort : AnEvent handler function. Fires resource fully loaded, due error.onAbortCapture : version ofonAbort fires capture phase.onCanPlay : AnEvent handler function. Fires there\u2019s enough data start playing, enough play end without buffering.onCanPlayCapture : version ofonCanPlay fires capture phase.onCanPlayThrough : AnEvent handler function. Fires there\u2019s enough data it\u2019s likely possible start playing without buffering end.onCanPlayThroughCapture : version ofonCanPlayThrough fires capture phase.onDurationChange : AnEvent handler function. Fires media duration updated.onDurationChangeCapture : version ofonDurationChange fires capture phase.onEmptied : AnEvent handler function. Fires media become empty.onEmptiedCapture : version ofonEmptied fires capture phase.onEncrypted : AnEvent handler function. Fires browser encounters encrypted media.onEncryptedCapture : version ofonEncrypted fires capture phase.onEnded : AnEvent handler function. Fires playback stops there\u2019s nothing left play.onEndedCapture : version ofonEnded fires capture phase.onError : AnEvent handler function. Fires resource could loaded.onErrorCapture : version ofonError fires capture phase.onLoadedData : AnEvent handler function. Fires current playback frame loaded.onLoadedDataCapture : version ofonLoadedData fires capture phase.onLoadedMetadata : AnEvent handler function. Fires metadata loaded.onLoadedMetadataCapture : version ofonLoadedMetadata fires capture phase.onLoadStart : AnEvent handler function. Fires browser started loading resource.onLoadStartCapture : version ofonLoadStart fires capture phase.onPause : AnEvent handler function. Fires media paused.onPauseCapture : version ofonPause fires capture phase.onPlay : AnEvent handler function. Fires media longer paused.onPlayCapture : version ofonPlay fires capture phase.onPlaying : AnEvent handler function. Fires media starts restarts playing.onPlayingCapture : version ofonPlaying fires capture phase.onProgress : AnEvent handler function. Fires periodically resource loading.onProgressCapture : version ofonProgress fires capture phase.onRateChange : AnEvent handler function. Fires playback rate changes.onRateChangeCapture : version ofonRateChange fires capture phase.onResize : AnEvent handler function. Fires video changes size.onResizeCapture : version ofonResize fires capture phase.onSeeked : AnEvent handler function. Fires seek operation completes.onSeekedCapture : version ofonSeeked fires capture phase.onSeeking : AnEvent handler function. Fires seek operation starts.onSeekingCapture : version ofonSeeking fires capture phase.onStalled : AnEvent handler function. Fires browser waiting data keeps loading.onStalledCapture : version ofonStalled fires capture phase.onSuspend : AnEvent handler function. Fires loading resource suspended.onSuspendCapture : version ofonSuspend fires capture phase.onTimeUpdate : AnEvent handler function. Fires current playback time updates.onTimeUpdateCapture : version ofonTimeUpdate fires capture phase.onVolumeChange : AnEvent handler function. Fires volume changed.onVolumeChangeCapture : version ofonVolumeChange fires capture phase.onWaiting : AnEvent handler function. Fires playback stopped due temporary lack data.onWaitingCapture : version ofonWaiting fires capture phase. Caveats - cannot pass children anddangerouslySetInnerHTML time. - events (like onAbort andonLoad ) don\u2019t bubble browser, bubble React. ref callback function Instead ref object (like one returned useRef ), may pass function ref attribute. <div ref={(node) => { console.log('Attached', node); return () => { console.log('Clean up', node) } }}> See example using ref callback. <div> DOM node added screen, React call ref callback DOM node argument. <div> DOM node removed, React call cleanup function returned callback. React also call ref callback whenever pass different ref callback. example, (node) => { ... } different function every render. component re-renders, previous function called null argument, next function called DOM node. Parameters node : DOM node. React pass DOM node ref gets attached. Unless pass function reference theref callback every render, callback get temporarily cleanup re-create every re-render component. Returns - optional cleanup function : theref detached, React call cleanup function. function returned theref callback, React call callback withnull argument theref gets detached. behavior removed future version. Caveats - Strict Mode on, React run one extra development-only setup+cleanup cycle first real setup. stress-test ensures cleanup logic \u201cmirrors\u201d setup logic stops undoes whatever setup doing. causes problem, implement cleanup function. - pass different ref callback, React call previous callback\u2019s cleanup function provided. cleanup function defined, theref callback called withnull argument. next function called DOM node. React event object event handlers receive React event object. also sometimes known \u201csynthetic event\u201d. <button onClick={e => { console.log(e); // React event object }} /> conforms standard underlying DOM events, fixes browser inconsistencies. React events map directly browser\u2019s native events. example onMouseLeave , e.nativeEvent point mouseout event. specific mapping part public API may change future. need underlying browser event reason, read e.nativeEvent . Properties React event objects implement standard Event properties: bubbles : boolean. Returns whether event bubbles DOM.cancelable : boolean. Returns whether event canceled.currentTarget : DOM node. Returns node current handler attached React tree.defaultPrevented : boolean. Returns whetherpreventDefault called.eventPhase : number. Returns phase event currently in.isTrusted : boolean. Returns whether event initiated user.target : DOM node. Returns node event occurred (which could distant child).timeStamp : number. Returns time event occurred. Additionally, React event objects provide properties: nativeEvent : DOMEvent . original browser event object. Methods React event objects implement standard Event methods: preventDefault() : Prevents default browser action event.stopPropagation() : Stops event propagation React tree. Additionally, React event objects provide methods: isDefaultPrevented() : Returns boolean value indicating whetherpreventDefault called.isPropagationStopped() : Returns boolean value indicating whetherstopPropagation called.persist() : used React DOM. React Native, call read event\u2019s properties event.isPersistent() : used React DOM. React Native, returns whetherpersist called. Caveats - values currentTarget ,eventPhase ,target , andtype reflect values React code expects. hood, React attaches event handlers root, reflected React event objects. example,e.currentTarget may underlyinge.nativeEvent.currentTarget . polyfilled events,e.type (React event type) may differ frome.nativeEvent.type (underlying type). AnimationEvent handler function event handler type CSS animation events. <div onAnimationStart={e => console.log('onAnimationStart')} onAnimationIteration={e => console.log('onAnimationIteration')} onAnimationEnd={e => console.log('onAnimationEnd')} /> Parameters e : React event object extraAnimationEvent properties: ClipboardEvent handler function event handler type Clipboard API events. <input onCopy={e => console.log('onCopy')} onCut={e => console.log('onCut')} onPaste={e => console.log('onPaste')} /> Parameters - e : React event object extraClipboardEvent properties: CompositionEvent handler function event handler type input method editor (IME) events. <input onCompositionStart={e => console.log('onCompositionStart')} onCompositionUpdate={e => console.log('onCompositionUpdate')} onCompositionEnd={e => console.log('onCompositionEnd')} /> Parameters e : React event object extraCompositionEvent properties: DragEvent handler function event handler type HTML Drag Drop API events. <> <div draggable={true} onDragStart={e => console.log('onDragStart')} onDragEnd={e => console.log('onDragEnd')} > Drag source </div> <div onDragEnter={e => console.log('onDragEnter')} onDragLeave={e => console.log('onDragLeave')} onDragOver={e => { e.preventDefault(); console.log('onDragOver'); }} onDrop={e => console.log('onDrop')} > Drop target </div> </> Parameters - e : React event object extraDragEvent properties:It also includes inherited MouseEvent properties:altKey button buttons ctrlKey clientX clientY getModifierState(key) metaKey movementX movementY pageX pageY relatedTarget screenX screenY shiftKey also includes inherited UIEvent properties: FocusEvent handler function event handler type focus events. <input onFocus={e => console.log('onFocus')} onBlur={e => console.log('onBlur')} /> Parameters - e : React event object extraFocusEvent properties:It also includes inherited UIEvent properties: Event handler function event handler type generic events. Parameters e : React event object additional properties. InputEvent handler function event handler type onBeforeInput event. <input onBeforeInput={e => console.log('onBeforeInput')} /> Parameters e : React event object extraInputEvent properties: KeyboardEvent handler function event handler type keyboard events. <input onKeyDown={e => console.log('onKeyDown')} onKeyUp={e => console.log('onKeyUp')} /> Parameters - e : React event object extraKeyboardEvent properties:altKey charCode code ctrlKey getModifierState(key) key keyCode locale metaKey location repeat shiftKey also includes inherited UIEvent properties: MouseEvent handler function event handler type mouse events. <div onClick={e => console.log('onClick')} onMouseEnter={e => console.log('onMouseEnter')} onMouseOver={e => console.log('onMouseOver')} onMouseDown={e => console.log('onMouseDown')} onMouseUp={e => console.log('onMouseUp')} onMouseLeave={e => console.log('onMouseLeave')} /> Parameters - e : React event object extraMouseEvent properties:altKey button buttons ctrlKey clientX clientY getModifierState(key) metaKey movementX movementY pageX pageY relatedTarget screenX screenY shiftKey also includes inherited UIEvent properties: PointerEvent handler function event handler type pointer events. <div onPointerEnter={e => console.log('onPointerEnter')} onPointerMove={e => console.log('onPointerMove')} onPointerDown={e => console.log('onPointerDown')} onPointerUp={e => console.log('onPointerUp')} onPointerLeave={e => console.log('onPointerLeave')} /> Parameters - e : React event object extraPointerEvent properties:It also includes inherited MouseEvent properties:altKey button buttons ctrlKey clientX clientY getModifierState(key) metaKey movementX movementY pageX pageY relatedTarget screenX screenY shiftKey also includes inherited UIEvent properties: TouchEvent handler function event handler type touch events. <div onTouchStart={e => console.log('onTouchStart')} onTouchMove={e => console.log('onTouchMove')} onTouchEnd={e => console.log('onTouchEnd')} onTouchCancel={e => console.log('onTouchCancel')} /> Parameters - e : React event object extraTouchEvent properties:It also includes inherited UIEvent properties: TransitionEvent handler function event handler type CSS transition events. <div onTransitionEnd={e => console.log('onTransitionEnd')} /> Parameters e : React event object extraTransitionEvent properties: UIEvent handler function event handler type generic UI events. <div onScroll={e => console.log('onScroll')} /> Parameters e : React event object extraUIEvent properties: WheelEvent handler function event handler type onWheel event. <div onWheel={e => console.log('onWheel')} /> Parameters - e : React event object extraWheelEvent properties:It also includes inherited MouseEvent properties:altKey button buttons ctrlKey clientX clientY getModifierState(key) metaKey movementX movementY pageX pageY relatedTarget screenX screenY shiftKey also includes inherited UIEvent properties: Usage Applying CSS styles React, specify CSS class className . works like class attribute HTML: <img className=\"avatar\" /> write CSS rules separate CSS file: /* CSS */ .avatar { border-radius: 50%; } React prescribe add CSS files. simplest case, you\u2019ll add <link> tag HTML. use build tool framework, consult documentation learn add CSS file project. Sometimes, style values depend data. Use style attribute pass styles dynamically: <img className=\"avatar\" style={{ width: user.imageSize, height: user.imageSize }} /> example, style={{}} special syntax, regular {} object inside style={ } JSX curly braces. recommend using style attribute styles depend JavaScript variables. export default function Avatar({ user }) { return ( <img src={user.imageUrl} alt={'Photo ' + user.name} className=\"avatar\" style={{ width: user.imageSize, height: user.imageSize }} /> ); } Deep Dive apply CSS classes conditionally, need produce className string using JavaScript. example, className={'row ' + (isSelected ? 'selected': '')} produce either className=\"row\" className=\"row selected\" depending whether isSelected true . make readable, use tiny helper library like classnames : import cn 'classnames'; function Row({ isSelected }) { return ( <div className={cn('row', isSelected && 'selected')}> ... </div> ); } especially convenient multiple conditional classes: import cn 'classnames'; function Row({ isSelected, size }) { return ( <div className={cn('row', { selected: isSelected, large: size === 'large', small: size === 'small', })}> ... </div> ); } Manipulating DOM node ref Sometimes, you\u2019ll need get browser DOM node associated tag JSX. example, want focus <input> button clicked, need call focus() browser <input> DOM node. obtain browser DOM node tag, declare ref pass ref attribute tag: import { useRef } 'react'; export default function Form() { const inputRef = useRef(null); // ... return ( <input ref={inputRef} /> // ... React put DOM node inputRef.current it\u2019s rendered screen. import { useRef } 'react'; export default function Form() { const inputRef = useRef(null); function handleClick() { inputRef.current.focus(); } return ( <> <input ref={inputRef} /> <button onClick={handleClick}> Focus input </button> </> ); } Read manipulating DOM refs check examples. advanced use cases, ref attribute also accepts callback function. Dangerously setting inner HTML pass raw HTML string element like so: const markup = { __html: '<p>some raw html</p>' }; return <div dangerouslySetInnerHTML={markup} />; dangerous. underlying DOM innerHTML property, must exercise extreme caution! Unless markup coming completely trusted source, trivial introduce XSS vulnerability way. example, use Markdown library converts Markdown HTML, trust parser doesn\u2019t contain bugs, user sees input, display resulting HTML like this: import { Remarkable } 'remarkable'; const md = new Remarkable(); function renderMarkdownToHTML(markdown) { // safe output HTML // shown user, // trust Markdown parser bugs. const renderedHTML = md.render(markdown); return {__html: renderedHTML}; } export default function MarkdownPreview({ markdown }) { const markup = renderMarkdownToHTML(markdown); return <div dangerouslySetInnerHTML={markup} />; } {__html} object created close HTML generated possible, like example renderMarkdownToHTML function. ensures raw HTML used code explicitly marked such, variables expect contain HTML passed dangerouslySetInnerHTML . recommended create object inline like <div dangerouslySetInnerHTML={{__html: markup}} /> . see rendering arbitrary HTML dangerous, replace code this: const post = { // Imagine content stored database. content: `<img src=\"\" onerror='alert(\"you hacked\")'>` }; export default function MarkdownPreview() { // \ud83d\udd34 SECURITY HOLE: passing untrusted input dangerouslySetInnerHTML const markup = { __html: post.content }; return <div dangerouslySetInnerHTML={markup} />; } code embedded HTML run. hacker could use security hole steal user information perform actions behalf. use dangerouslySetInnerHTML trusted sanitized data. Handling mouse events example shows common mouse events fire. export default function MouseExample() { return ( <div onMouseEnter={e => console.log('onMouseEnter (parent)')} onMouseLeave={e => console.log('onMouseLeave (parent)')} > <button onClick={e => console.log('onClick (first button)')} onMouseDown={e => console.log('onMouseDown (first button)')} onMouseEnter={e => console.log('onMouseEnter (first button)')} onMouseLeave={e => console.log('onMouseLeave (first button)')} onMouseOver={e => console.log('onMouseOver (first button)')} onMouseUp={e => console.log('onMouseUp (first button)')} > First button </button> <button onClick={e => console.log('onClick (second button)')} onMouseDown={e => console.log('onMouseDown (second button)')} onMouseEnter={e => console.log('onMouseEnter (second button)')} onMouseLeave={e => console.log('onMouseLeave (second button)')} onMouseOver={e => console.log('onMouseOver (second button)')} onMouseUp={e => console.log('onMouseUp (second button)')} > Second button </button> </div> ); } export default function PointerExample() { return ( <div onPointerEnter={e => console.log('onPointerEnter (parent)')} onPointerLeave={e => console.log('onPointerLeave (parent)')} style={{ padding: 20, backgroundColor: '#ddd' }} > <div onPointerDown={e => console.log('onPointerDown (first child)')} onPointerEnter={e => console.log('onPointerEnter (first child)')} onPointerLeave={e => console.log('onPointerLeave (first child)')} onPointerMove={e => console.log('onPointerMove (first child)')} onPointerUp={e => console.log('onPointerUp (first child)')} style={{ padding: 20, backgroundColor: 'lightyellow' }} > First child </div> <div onPointerDown={e => console.log('onPointerDown (second child)')} onPointerEnter={e => console.log('onPointerEnter (second child)')} onPointerLeave={e => console.log('onPointerLeave (second child)')} onPointerMove={e => console.log('onPointerMove (second child)')} onPointerUp={e => console.log('onPointerUp (second child)')} style={{ padding: 20, backgroundColor: 'lightblue' }} > Second child </div> </div> ); } Handling focus events React, focus events bubble. use currentTarget relatedTarget differentiate focusing blurring events originated outside parent element. example shows detect focusing child, focusing parent element, detect focus entering leaving whole subtree. export default function FocusExample() { return ( <div tabIndex={1} onFocus={(e) => { (e.currentTarget === e.target) { console.log('focused parent'); } else { console.log('focused child', e.target.name); } (!e.currentTarget.contains(e.relatedTarget)) { // triggered swapping focus children console.log('focus entered parent'); } }} onBlur={(e) => { (e.currentTarget === e.target) { console.log('unfocused parent'); } else { console.log('unfocused child', e.target.name); } (!e.currentTarget.contains(e.relatedTarget)) { // triggered swapping focus children console.log('focus left parent'); } }} > <label> First name: <input name=\"firstName\" /> </label> <label> Last name: <input name=\"lastName\" /> </label> </div> ); } export default function KeyboardExample() { return ( <label> First name: <input name=\"firstName\" onKeyDown={e => console.log('onKeyDown:', e.key, e.code)} onKeyUp={e => console.log('onKeyUp:', e.key, e.code)} /> </label> ); }"},
{"source": "https://react.dev/reference/react-dom/components/form", "title": "<form> \u2013 React", "text": "<form> built-in browser <form> component lets create interactive controls submitting information. <form action={search}> <input name=\"query\" /> <button type=\"submit\">Search</button> </form> Reference <form> create interactive controls submitting information, render built-in browser <form> component. <form action={search}> <input name=\"query\" /> <button type=\"submit\">Search</button> </form> Props <form> supports common element props. action : URL function. URL passed action form behave like HTML form component. function passed action function handle form submission. function passed action may async called single argument containing form data submitted form. action prop overridden formAction attribute <button> , <input type=\"submit\"> , <input type=\"image\"> component. Caveats - function passed action orformAction HTTP method POST regardless value themethod prop. Usage Handle form submission client Pass function action prop form run function form submitted. formData passed function argument access data submitted form. differs conventional HTML action, accepts URLs. action function succeeds, uncontrolled field elements form reset. export default function Search() { function search(formData) { const query = formData.get(\"query\"); alert(`You searched '${query}'`); } return ( <form action={search}> <input name=\"query\" /> <button type=\"submit\">Search</button> </form> ); } Handle form submission Server Function Render <form> input submit button. Pass Server Function (a function marked 'use server' ) action prop form run function form submitted. Passing Server Function <form action> allow users submit forms without JavaScript enabled code loaded. beneficial users slow connection, device, JavaScript disabled similar way forms work URL passed action prop. use hidden form fields provide data <form> \u2019s action. Server Function called hidden form field data instance FormData . import { updateCart } './lib.js'; function AddToCart({productId}) { async function addToCart(formData) { 'use server' const productId = formData.get('productId') await updateCart(productId) } return ( <form action={addToCart}> <input type=\"hidden\" name=\"productId\" value={productId} /> <button type=\"submit\">Add Cart</button> </form> ); } lieu using hidden form fields provide data <form> \u2019s action, call bind method supply extra arguments. bind new argument (productId ) function addition formData passed argument function. import { updateCart } './lib.js'; function AddToCart({productId}) { async function addToCart(productId, formData) { \"use server\"; await updateCart(productId) } const addProductToCart = addToCart.bind(null, productId); return ( <form action={addProductToCart}> <button type=\"submit\">Add Cart</button> </form> ); } <form> rendered Server Component, Server Function passed <form> \u2019s action prop, form progressively enhanced. Display pending state form submission display pending state form submitted, call useFormStatus Hook component rendered <form> read pending property returned. Here, use pending property indicate form submitting. import { useFormStatus } \"react-dom\"; import { submitForm } \"./actions.js\"; function Submit() { const { pending } = useFormStatus(); return ( <button type=\"submit\" disabled={pending}> {pending ? \"Submitting...\" : \"Submit\"} </button> ); } function Form({ action }) { return ( <form action={action}> <Submit /> </form> ); } export default function App() { return <Form action={submitForm} />; } learn useFormStatus Hook see reference documentation. Optimistically updating form data useOptimistic Hook provides way optimistically update user interface background operation, like network request, completes. context forms, technique helps make apps feel responsive. user submits form, instead waiting server\u2019s response reflect changes, interface immediately updated expected outcome. example, user types message form hits \u201cSend\u201d button, useOptimistic Hook allows message immediately appear list \u201cSending\u2026\u201d label, even message actually sent server. \u201coptimistic\u201d approach gives impression speed responsiveness. form attempts truly send message background. server confirms message received, \u201cSending\u2026\u201d label removed. import { useOptimistic, useState, useRef } \"react\"; import { deliverMessage } \"./actions.js\"; function Thread({ messages, sendMessage }) { const formRef = useRef(); async function formAction(formData) { addOptimisticMessage(formData.get(\"message\")); formRef.current.reset(); await sendMessage(formData); } const [optimisticMessages, addOptimisticMessage] = useOptimistic( messages, (state, newMessage) => [ ...state, { text: newMessage, sending: true } ] ); return ( <> {optimisticMessages.map((message, index) => ( <div key={index}> {message.text} {!!message.sending && <small> (Sending...)</small>} </div> ))} <form action={formAction} ref={formRef}> <input type=\"text\" name=\"message\" placeholder=\"Hello!\" /> <button type=\"submit\">Send</button> </form> </> ); } export default function App() { const [messages, setMessages] = useState([ { text: \"Hello there!\", sending: false, key: 1 } ]); async function sendMessage(formData) { const sentMessage = await deliverMessage(formData.get(\"message\")); setMessages([...messages, { text: sentMessage }]); } return <Thread messages={messages} sendMessage={sendMessage} />; } Handling form submission errors cases function called <form> \u2019s action prop throws error. handle errors wrapping <form> Error Boundary. function called <form> \u2019s action prop throws error, fallback error boundary displayed. import { ErrorBoundary } \"react-error-boundary\"; export default function Search() { function search() { throw new Error(\"search error\"); } return ( <ErrorBoundary fallback={<p>There error submitting form</p>} > <form action={search}> <input name=\"query\" /> <button type=\"submit\">Search</button> </form> </ErrorBoundary> ); } Display form submission error without JavaScript Displaying form submission error message JavaScript bundle loads progressive enhancement requires that: <form> rendered Server Component- function passed <form> \u2019saction prop Server Function - useActionState Hook used display error message useActionState takes two parameters: Server Function initial state. useActionState returns two values, state variable action. action returned useActionState passed action prop form. state variable returned useActionState used display error message. value returned Server Function passed useActionState used update state variable. import { useActionState } \"react\"; import { signUpNewUser } \"./api\"; export default function Page() { async function signup(prevState, formData) { \"use server\"; const email = formData.get(\"email\"); try { await signUpNewUser(email); alert(`Added \"${email}\"`); } catch (err) { return err.toString(); } } const [message, signupAction] = useActionState(signup, null); return ( <> <h1>Signup newsletter</h1> <p>Signup email twice see error</p> <form action={signupAction} id=\"signup-form\"> <label htmlFor=\"email\">Email: </label> <input name=\"email\" id=\"email\" placeholder=\"react@example.com\" /> <button>Sign up</button> {!!message && <p>{message}</p>} </form> </> ); } Learn updating state form action useActionState docs Handling multiple submission types Forms designed handle multiple submission actions based button pressed user. button inside form associated distinct action behavior setting formAction prop. user taps specific button, form submitted, corresponding action, defined button\u2019s attributes action, executed. instance, form might submit article review default separate button formAction set save article draft. export default function Search() { function publish(formData) { const content = formData.get(\"content\"); const button = formData.get(\"button\"); alert(`'${content}' published '${button}' button`); } function save(formData) { const content = formData.get(\"content\"); alert(`Your draft '${content}' saved!`); } return ( <form action={publish}> <textarea name=\"content\" rows={4} cols={40} /> <br /> <button type=\"submit\" name=\"button\" value=\"submit\">Publish</button> <button formAction={save}>Save draft</button> </form> ); }"},
{"source": "https://react.dev/reference/react-dom/components/input", "title": "<input> \u2013 React", "text": "<input> built-in browser <input> component lets render different kinds form inputs. <input /> Reference <input> display input, render built-in browser <input> component. <input name=\"myInput\" /> Props <input> supports common element props. formAction : string function. Overrides parent<form action> fortype=\"submit\" andtype=\"image\" . URL passed toaction form behave like standard HTML form. function passed toformAction function handle form submission. See<form action> . make input controlled passing one props: checked : boolean. checkbox input radio button, controls whether selected.value : string. text input, controls text. (For radio button, specifies form data.) pass either them, must also pass onChange handler updates passed value. <input> props relevant uncontrolled inputs: defaultChecked : boolean. Specifies initial value fortype=\"checkbox\" andtype=\"radio\" inputs.defaultValue : string. Specifies initial value text input. <input> props relevant uncontrolled controlled inputs: accept : string. Specifies filetypes accepted atype=\"file\" input.alt : string. Specifies alternative image text atype=\"image\" input.capture : string. Specifies media (microphone, video, camera) captured atype=\"file\" input.autoComplete : string. Specifies one possible autocomplete behaviors.autoFocus : boolean. Iftrue , React focus element mount.dirname : string. Specifies form field name element\u2019s directionality.disabled : boolean. Iftrue , input interactive appear dimmed.children :<input> accept children.form : string. Specifies theid the<form> input belongs to. omitted, it\u2019s closest parent form.formAction : string. Overrides parent<form action> fortype=\"submit\" andtype=\"image\" .formEnctype : string. Overrides parent<form enctype> fortype=\"submit\" andtype=\"image\" .formMethod : string. Overrides parent<form method> fortype=\"submit\" andtype=\"image\" .formNoValidate : string. Overrides parent<form noValidate> fortype=\"submit\" andtype=\"image\" .formTarget : string. Overrides parent<form target> fortype=\"submit\" andtype=\"image\" .height : string. Specifies image height fortype=\"image\" .list : string. Specifies theid the<datalist> autocomplete options.max : number. Specifies maximum value numerical datetime inputs.maxLength : number. Specifies maximum length text inputs.min : number. Specifies minimum value numerical datetime inputs.minLength : number. Specifies minimum length text inputs.multiple : boolean. Specifies whether multiple values allowed for<type=\"file\" andtype=\"email\" .name : string. Specifies name input that\u2019s submitted form.onChange : AnEvent handler function. Required controlled inputs. Fires immediately input\u2019s value changed user (for example, fires every keystroke). Behaves like browserinput event.onChangeCapture : version ofonChange fires capture phase.onInput : AnEvent handler function. Fires immediately value changed user. historical reasons, React idiomatic useonChange instead works similarly.onInputCapture : version ofonInput fires capture phase.onInvalid : AnEvent handler function. Fires input fails validation form submit. Unlike built-ininvalid event, ReactonInvalid event bubbles.onInvalidCapture : version ofonInvalid fires capture phase.onSelect : AnEvent handler function. Fires selection inside the<input> changes. React extends theonSelect event also fire empty selection edits (which may affect selection).onSelectCapture : version ofonSelect fires capture phase.pattern : string. Specifies pattern thevalue must match.placeholder : string. Displayed dimmed color input value empty.readOnly : boolean. Iftrue , input editable user.required : boolean. Iftrue , value must provided form submit.size : number. Similar setting width, unit depends control.src : string. Specifies image source atype=\"image\" input.step : positive number an'any' string. Specifies distance valid values.type : string. One input types.width : string. Specifies image width atype=\"image\" input. Caveats - Checkboxes need checked (ordefaultChecked ), notvalue (ordefaultValue ). - text input receives string value prop, treated controlled. - checkbox radio button receives boolean checked prop, treated controlled. - input can\u2019t controlled uncontrolled time. - input cannot switch controlled uncontrolled lifetime. - Every controlled input needs onChange event handler synchronously updates backing value. Usage Displaying inputs different types display input, render <input> component. default, text input. pass type=\"checkbox\" checkbox, type=\"radio\" radio button, one input types. export default function MyForm() { return ( <> <label> Text input: <input name=\"myInput\" /> </label> <hr /> <label> Checkbox: <input type=\"checkbox\" name=\"myCheckbox\" /> </label> <hr /> <p> Radio buttons: <label> <input type=\"radio\" name=\"myRadio\" value=\"option1\" /> Option 1 </label> <label> <input type=\"radio\" name=\"myRadio\" value=\"option2\" /> Option 2 </label> <label> <input type=\"radio\" name=\"myRadio\" value=\"option3\" /> Option 3 </label> </p> </> ); } Providing label input Typically, place every <input> inside <label> tag. tells browser label associated input. user clicks label, browser automatically focus input. It\u2019s also essential accessibility: screen reader announce label caption user focuses associated input. can\u2019t nest <input> <label> , associate passing ID <input id> <label htmlFor> . avoid conflicts multiple instances one component, generate ID useId . import { useId } 'react'; export default function Form() { const ageInputId = useId(); return ( <> <label> first name: <input name=\"firstName\" /> </label> <hr /> <label htmlFor={ageInputId}>Your age:</label> <input id={ageInputId} name=\"age\" type=\"number\" /> </> ); } Providing initial value input optionally specify initial value input. Pass defaultValue string text inputs. Checkboxes radio buttons specify initial value defaultChecked boolean instead. export default function MyForm() { return ( <> <label> Text input: <input name=\"myInput\" defaultValue=\"Some initial value\" /> </label> <hr /> <label> Checkbox: <input type=\"checkbox\" name=\"myCheckbox\" defaultChecked={true} /> </label> <hr /> <p> Radio buttons: <label> <input type=\"radio\" name=\"myRadio\" value=\"option1\" /> Option 1 </label> <label> <input type=\"radio\" name=\"myRadio\" value=\"option2\" defaultChecked={true} /> Option 2 </label> <label> <input type=\"radio\" name=\"myRadio\" value=\"option3\" /> Option 3 </label> </p> </> ); } Reading input values submitting form Add <form> around inputs <button type=\"submit\"> inside. call <form onSubmit> event handler. default, browser send form data current URL refresh page. override behavior calling e.preventDefault() . Read form data new FormData(e.target) . export default function MyForm() { function handleSubmit(e) { // Prevent browser reloading page e.preventDefault(); // Read form data const form = e.target; const formData = new FormData(form); // pass formData fetch body directly: fetch('/some-api', { method: form.method, body: formData }); // work plain object: const formJson = Object.fromEntries(formData.entries()); console.log(formJson); } return ( <form method=\"post\" onSubmit={handleSubmit}> <label> Text input: <input name=\"myInput\" defaultValue=\"Some initial value\" /> </label> <hr /> <label> Checkbox: <input type=\"checkbox\" name=\"myCheckbox\" defaultChecked={true} /> </label> <hr /> <p> Radio buttons: <label><input type=\"radio\" name=\"myRadio\" value=\"option1\" /> Option 1</label> <label><input type=\"radio\" name=\"myRadio\" value=\"option2\" defaultChecked={true} /> Option 2</label> <label><input type=\"radio\" name=\"myRadio\" value=\"option3\" /> Option 3</label> </p> <hr /> <button type=\"reset\">Reset form</button> <button type=\"submit\">Submit form</button> </form> ); } Controlling input state variable input like <input /> uncontrolled. Even pass initial value like <input defaultValue=\"Initial text\" /> , JSX specifies initial value. control value right now. render controlled input, pass value prop (or checked checkboxes radios). React force input always value passed. Usually, would declaring state variable: function Form() { const [firstName, setFirstName] = useState(''); // Declare state variable... // ... return ( <input value={firstName} // ...force input's value match state variable... onChange={e => setFirstName(e.target.value)} // ... update state variable edits! /> ); } controlled input makes sense needed state anyway\u2014for example, re-render UI every edit: function Form() { const [firstName, setFirstName] = useState(''); return ( <> <label> First name: <input value={firstName} onChange={e => setFirstName(e.target.value)} /> </label> {firstName !== '' && <p>Your name {firstName}.</p>} ... It\u2019s also useful want offer multiple ways adjust input state (for example, clicking button): function Form() { // ... const [age, setAge] = useState(''); const ageAsNumber = Number(age); return ( <> <label> Age: <input value={age} onChange={e => setAge(e.target.value)} type=\"number\" /> <button onClick={() => setAge(ageAsNumber + 10)}> Add 10 years </button> value pass controlled components undefined null . need initial value empty (such firstName field below), initialize state variable empty string ('' ). import { useState } 'react'; export default function Form() { const [firstName, setFirstName] = useState(''); const [age, setAge] = useState('20'); const ageAsNumber = Number(age); return ( <> <label> First name: <input value={firstName} onChange={e => setFirstName(e.target.value)} /> </label> <label> Age: <input value={age} onChange={e => setAge(e.target.value)} type=\"number\" /> <button onClick={() => setAge(ageAsNumber + 10)}> Add 10 years </button> </label> {firstName !== '' && <p>Your name {firstName}.</p> } {ageAsNumber > 0 && <p>Your age {ageAsNumber}.</p> } </> ); } Optimizing re-rendering every keystroke use controlled input, set state every keystroke. component containing state re-renders large tree, get slow. There\u2019s ways optimize re-rendering performance. example, suppose start form re-renders page content every keystroke: function App() { const [firstName, setFirstName] = useState(''); return ( <> <form> <input value={firstName} onChange={e => setFirstName(e.target.value)} /> </form> <PageContent /> </> ); } Since <PageContent /> doesn\u2019t rely input state, move input state component: function App() { return ( <> <SignupForm /> <PageContent /> </> ); } function SignupForm() { const [firstName, setFirstName] = useState(''); return ( <form> <input value={firstName} onChange={e => setFirstName(e.target.value)} /> </form> ); } significantly improves performance SignupForm re-renders every keystroke. way avoid re-rendering (for example, PageContent depends search input\u2019s value), useDeferredValue lets keep controlled input responsive even middle large re-render. Troubleshooting text input doesn\u2019t update type render input value onChange , see error console: // \ud83d\udd34 Bug: controlled text input onChange handler <input value={something} /> value prop form field without onChange handler. render read-only field. field mutable use defaultValue . Otherwise, set either onChange readOnly .As error message suggests, wanted specify initial value, pass defaultValue instead: // \u2705 Good: uncontrolled input initial value <input defaultValue={something} /> want control input state variable, specify onChange handler: // \u2705 Good: controlled input onChange <input value={something} onChange={e => setSomething(e.target.value)} /> value intentionally read-only, add readOnly prop suppress error: // \u2705 Good: readonly controlled input without change <input value={something} readOnly={true} /> checkbox doesn\u2019t update click render checkbox checked onChange , see error console: // \ud83d\udd34 Bug: controlled checkbox onChange handler <input type=\"checkbox\" checked={something} /> checked prop form field without onChange handler. render read-only field. field mutable use defaultChecked . Otherwise, set either onChange readOnly .As error message suggests, wanted specify initial value, pass defaultChecked instead: // \u2705 Good: uncontrolled checkbox initial value <input type=\"checkbox\" defaultChecked={something} /> want control checkbox state variable, specify onChange handler: // \u2705 Good: controlled checkbox onChange <input type=\"checkbox\" checked={something} onChange={e => setSomething(e.target.checked)} /> checkbox intentionally read-only, add readOnly prop suppress error: // \u2705 Good: readonly controlled input without change <input type=\"checkbox\" checked={something} readOnly={true} /> input caret jumps beginning every keystroke control input, must update state variable input\u2019s value DOM onChange . can\u2019t update something e.target.value (or e.target.checked checkboxes): function handleChange(e) { // \ud83d\udd34 Bug: updating input something e.target.value setFirstName(e.target.value.toUpperCase()); } also can\u2019t update asynchronously: function handleChange(e) { // \ud83d\udd34 Bug: updating input asynchronously setTimeout(() => { setFirstName(e.target.value); }, 100); } fix code, update synchronously e.target.value : function handleChange(e) { // \u2705 Updating controlled input e.target.value synchronously setFirstName(e.target.value); } doesn\u2019t fix problem, it\u2019s possible input gets removed re-added DOM every keystroke. happen you\u2019re accidentally resetting state every re-render, example input one parents always receives different key attribute, nest component function definitions (which supported causes \u201cinner\u201d component always considered different tree). I\u2019m getting error: \u201cA component changing uncontrolled input controlled\u201d provide value component, must remain string throughout lifetime. cannot pass value={undefined} first later pass value=\"some string\" React won\u2019t know whether want component uncontrolled controlled. controlled component always receive string value , null undefined . value coming API state variable, might initialized null undefined . case, either set empty string ('' ) initially, pass value={someValue ?? ''} ensure value string. Similarly, pass checked checkbox, ensure it\u2019s always boolean."},
{"source": "https://react.dev/reference/react-dom/components/link", "title": "<link> \u2013 React", "text": "<link> built-in browser <link> component lets use external resources stylesheets annotate document link metadata. <link rel=\"icon\" href=\"favicon.ico\" /> Reference <link> link external resources stylesheets, fonts, icons, annotate document link metadata, render built-in browser <link> component. render <link> component React cases place corresponding DOM element document head. <link rel=\"icon\" href=\"favicon.ico\" /> Props <link> supports common element props. rel : string, required. Specifies relationship resource. React treats links withrel=\"stylesheet\" differently links. props apply rel=\"stylesheet\" : precedence : string. Tells React rank the<link> DOM node relative others document<head> , determines stylesheet override other. React infer precedence values discovers first \u201clower\u201d precedence values discovers later \u201chigher\u201d. Many style systems work fine using single precedence value style rules atomic. Stylesheets precedence go together whether are<link> inline<style> tags loaded usingpreinit functions.media : string. Restricts stylesheet certain media query.title : string. Specifies name alternative stylesheet. props apply rel=\"stylesheet\" disable React\u2019s special treatment stylesheets: disabled : boolean. Disables stylesheet.onError : function. Called stylesheet fails load.onLoad : function. Called stylesheet finishes loaded. props apply rel=\"preload\" rel=\"modulepreload\" : : string. type resource. possible values areaudio ,document ,embed ,fetch ,font ,image ,object ,script ,style ,track ,video ,worker .imageSrcSet : string. Applicable whenas=\"image\" . Specifies source set image.imageSizes : string. Applicable whenas=\"image\" . Specifies sizes image. props apply rel=\"icon\" rel=\"apple-touch-icon\" : sizes : string. sizes icon. props apply cases: href : string. URL linked resource.crossOrigin : string. CORS policy use. possible values areanonymous anduse-credentials . required whenas set to\"fetch\" .referrerPolicy : string. Referrer header send fetching. possible values areno-referrer-when-downgrade (the default),no-referrer ,origin ,origin-when-cross-origin , andunsafe-url .fetchPriority : string. Suggests relative priority fetching resource. possible values areauto (the default),high , andlow .hrefLang : string. language linked resource.integrity : string. cryptographic hash resource, verify authenticity.type : string. MIME type linked resource. Props recommended use React: blocking : string. set to\"render\" , instructs browser render page stylesheet loaded. React provides fine-grained control using Suspense. Special rendering behavior React always place DOM element corresponding <link> component within document\u2019s <head> , regardless React tree rendered. <head> valid place <link> exist within DOM, yet it\u2019s convenient keeps things composable component representing specific page render <link> components itself. exceptions this: - <link> arel=\"stylesheet\" prop, also aprecedence prop get special behavior. order stylesheets within document significant, React needs know order stylesheet relative others, specify using theprecedence prop. theprecedence prop omitted, special behavior. - <link> anitemProp prop, special behavior, case doesn\u2019t apply document instead represents metadata specific part page. - <link> anonLoad oronError prop, case managing loading linked resource manually within React component. Special behavior stylesheets addition, <link> stylesheet (namely, rel=\"stylesheet\" props), React treats specially following ways: - component renders <link> suspend stylesheet loading. - multiple components render links stylesheet, React de-duplicate put single link DOM. Two links considered href prop. two exception special behavior: - link doesn\u2019t precedence prop, special behavior, order stylesheets within document significant, React needs know order stylesheet relative others, specify using theprecedence prop. - supply onLoad ,onError , ordisabled props, special behavior, props indicate managing loading stylesheet manually within component. special treatment comes two caveats: - React ignore changes props link rendered. (React issue warning development happens.) - React may leave link DOM even component rendered unmounted. Usage Linking related resources annotate document links related resources icon, canonical URL, pingback. React place metadata within document <head> regardless React tree rendered. import ShowRenderedHTML './ShowRenderedHTML.js'; export default function BlogPage() { return ( <ShowRenderedHTML> <link rel=\"icon\" href=\"favicon.ico\" /> <link rel=\"pingback\" href=\"http://www.example.com/xmlrpc.php\" /> <h1>My Blog</h1> <p>...</p> </ShowRenderedHTML> ); } Linking stylesheet component depends certain stylesheet order displayed correctly, render link stylesheet within component. component suspend stylesheet loading. must supply precedence prop, tells React place stylesheet relative others \u2014 stylesheets higher precedence override lower precedence. import ShowRenderedHTML './ShowRenderedHTML.js'; export default function SiteMapPage() { return ( <ShowRenderedHTML> <link rel=\"stylesheet\" href=\"sitemap.css\" precedence=\"medium\" /> <p>...</p> </ShowRenderedHTML> ); } Controlling stylesheet precedence Stylesheets conflict other, do, browser goes one comes later document. React lets control order stylesheets precedence prop. example, three components render stylesheets, ones precedence grouped together <head> . import ShowRenderedHTML './ShowRenderedHTML.js'; export default function HomePage() { return ( <ShowRenderedHTML> <FirstComponent /> <SecondComponent /> <ThirdComponent/> ... </ShowRenderedHTML> ); } function FirstComponent() { return <link rel=\"stylesheet\" href=\"first.css\" precedence=\"first\" />; } function SecondComponent() { return <link rel=\"stylesheet\" href=\"second.css\" precedence=\"second\" />; } function ThirdComponent() { return <link rel=\"stylesheet\" href=\"third.css\" precedence=\"first\" />; } Note precedence values arbitrary naming you. React infer precedence values discovers first \u201clower\u201d precedence values discovers later \u201chigher\u201d. Deduplicated stylesheet rendering render stylesheet multiple components, React place single <link> document head. import ShowRenderedHTML './ShowRenderedHTML.js'; export default function HomePage() { return ( <ShowRenderedHTML> <Component /> <Component /> ... </ShowRenderedHTML> ); } function Component() { return <link rel=\"stylesheet\" href=\"styles.css\" precedence=\"medium\" />; } Annotating specific items within document links use <link> component itemProp prop annotate specific items within document links related resources. case, React place annotations within document <head> place like React component. <section itemScope> <h3>Annotating specific items</h3> <link itemProp=\"author\" href=\"http://example.com/\" /> <p>...</p> </section>"},
{"source": "https://react.dev/reference/react-dom/components/meta", "title": "<meta> \u2013 React", "text": "<meta> built-in browser <meta> component lets add metadata document. <meta name=\"keywords\" content=\"React, JavaScript, semantic markup, html\" /> Reference <meta> add document metadata, render built-in browser <meta> component. render <meta> component React always place corresponding DOM element document head. <meta name=\"keywords\" content=\"React, JavaScript, semantic markup, html\" /> Props <meta> supports common element props. exactly one following props: name , httpEquiv , charset , itemProp . <meta> component something different depending props specified. name : string. Specifies kind metadata attached document.charset : string. Specifies character set used document. valid value is\"utf-8\" .httpEquiv : string. Specifies directive processing document.itemProp : string. Specifies metadata particular item within document rather document whole.content : string. Specifies metadata attached used thename oritemProp props behavior directive used thehttpEquiv prop. Special rendering behavior React always place DOM element corresponding <meta> component within document\u2019s <head> , regardless React tree rendered. <head> valid place <meta> exist within DOM, yet it\u2019s convenient keeps things composable component representing specific page render <meta> components itself. one exception this: <meta> itemProp prop, special behavior, case doesn\u2019t represent metadata document rather metadata specific part page. Usage Annotating document metadata annotate document metadata keywords, summary, author\u2019s name. React place metadata within document <head> regardless React tree rendered. <meta name=\"author\" content=\"John Smith\" /> <meta name=\"keywords\" content=\"React, JavaScript, semantic markup, html\" /> <meta name=\"description\" content=\"API reference <meta> component React DOM\" /> render <meta> component component. React put <meta> DOM node document <head> . import ShowRenderedHTML './ShowRenderedHTML.js'; export default function SiteMapPage() { return ( <ShowRenderedHTML> <meta name=\"keywords\" content=\"React\" /> <meta name=\"description\" content=\"A site map React website\" /> <h1>Site Map</h1> <p>...</p> </ShowRenderedHTML> ); } Annotating specific items within document metadata use <meta> component itemProp prop annotate specific items within document metadata. case, React place annotations within document <head> place like React component. <section itemScope> <h3>Annotating specific items</h3> <meta itemProp=\"description\" content=\"API reference using <meta> itemProp\" /> <p>...</p> </section>"},
{"source": "https://react.dev/reference/react-dom/components/option", "title": "<option> \u2013 React", "text": "<option> built-in browser <option> component lets render option inside <select> box. <select> <option value=\"someOption\">Some option</option> <option value=\"otherOption\">Other option</option> </select> Reference <option> built-in browser <option> component lets render option inside <select> box. <select> <option value=\"someOption\">Some option</option> <option value=\"otherOption\">Other option</option> </select> Props <option> supports common element props. Additionally, <option> supports props: disabled : boolean. Iftrue , option selectable appear dimmed.label : string. Specifies meaning option. specified, text inside option used.value : value used submitting parent<select> form option selected. Caveats - React support selected attribute on<option> . Instead, pass option\u2019svalue parent<select defaultValue> uncontrolled select box, or<select value> controlled select. Usage Displaying select box options Render <select> list <option> components inside display select box. Give <option> value representing data submitted form. Read displaying <select> list <option> components. export default function FruitPicker() { return ( <label> Pick fruit: <select name=\"selectedFruit\"> <option value=\"apple\">Apple</option> <option value=\"banana\">Banana</option> <option value=\"orange\">Orange</option> </select> </label> ); }"},
{"source": "https://react.dev/reference/react-dom/components/progress", "title": "<progress> \u2013 React", "text": "<progress> built-in browser <progress> component lets render progress indicator. <progress value={0.5} /> Reference <progress> display progress indicator, render built-in browser <progress> component. <progress value={0.5} /> Props <progress> supports common element props. Additionally, <progress> supports props: max : number. Specifies maximumvalue . Defaults to1 .value : number between0 andmax , ornull indeterminate progress. Specifies much done. Usage Controlling progress indicator display progress indicator, render <progress> component. pass number value 0 max value specify. don\u2019t pass max value, assumed 1 default. operation ongoing, pass value={null} put progress indicator indeterminate state. export default function App() { return ( <> <progress value={0} /> <progress value={0.5} /> <progress value={0.7} /> <progress value={75} max={100} /> <progress value={1} /> <progress value={null} /> </> ); }"},
{"source": "https://react.dev/reference/react-dom/components/script", "title": "<script> \u2013 React", "text": "<script> built-in browser <script> component lets add script document. <script> alert(\"hi!\") </script> Reference <script> add inline external scripts document, render built-in browser <script> component. render <script> component React certain cases place corresponding DOM element document head de-duplicate identical scripts. <script> alert(\"hi!\") </script> <script src=\"script.js\" /> Props <script> supports common element props. either children src prop. children : string. source code inline script.src : string. URL external script. supported props: async : boolean. Allows browser defer execution script rest document processed \u2014 preferred behavior performance.crossOrigin : string. CORS policy use. possible values areanonymous anduse-credentials .fetchPriority : string. Lets browser rank scripts priority fetching multiple scripts time. be\"high\" ,\"low\" , or\"auto\" (the default).integrity : string. cryptographic hash script, verify authenticity.noModule : boolean. Disables script browsers support ES modules \u2014 allowing fallback script browsers not.nonce : string. cryptographic nonce allow resource using strict Content Security Policy.referrer : string. Says Referer header send fetching script resources script fetches turn.type : string. Says whether script classic script, ES module, import map. Props disable React\u2019s special treatment scripts: onError : function. Called script fails load.onLoad : function. Called script finishes loaded. Props recommended use React: blocking : string. set to\"render\" , instructs browser render page scriptsheet loaded. React provides fine-grained control using Suspense.defer : string. Prevents browser executing script document done loading. compatible streaming server-rendered components. Use theasync prop instead. Special rendering behavior React move <script> components document\u2019s <head> de-duplicate identical scripts. opt behavior, provide src async={true} props. React de-duplicate scripts src . async prop must true allow scripts safely moved. special treatment comes two caveats: - React ignore changes props script rendered. (React issue warning development happens.) - React may leave script DOM even component rendered unmounted. (This effect scripts execute inserted DOM.) Usage Rendering external script component depends certain scripts order displayed correctly, render <script> within component. However, component might committed script finished loading. start depending script content load event fired e.g. using onLoad prop. React de-duplicate scripts src , inserting one DOM even multiple components render it. import ShowRenderedHTML './ShowRenderedHTML.js'; function Map({lat, long}) { return ( <> <script async src=\"map-api.js\" onLoad={() => console.log('script loaded')} /> <div id=\"map\" data-lat={lat} data-long={long} /> </> ); } export default function Page() { return ( <ShowRenderedHTML> <Map /> </ShowRenderedHTML> ); } Rendering inline script include inline script, render <script> component script source code children. Inline scripts de-duplicated moved document <head> . import ShowRenderedHTML './ShowRenderedHTML.js'; function Tracking() { return ( <script> ga('send', 'pageview'); </script> ); } export default function Page() { return ( <ShowRenderedHTML> <h1>My Website</h1> <Tracking /> <p>Welcome</p> </ShowRenderedHTML> ); }"},
{"source": "https://react.dev/reference/react-dom/components/select", "title": "<select> \u2013 React", "text": "<select> built-in browser <select> component lets render select box options. <select> <option value=\"someOption\">Some option</option> <option value=\"otherOption\">Other option</option> </select> Reference <select> display select box, render built-in browser <select> component. <select> <option value=\"someOption\">Some option</option> <option value=\"otherOption\">Other option</option> </select> Props <select> supports common element props. make select box controlled passing value prop: value : string (or array strings formultiple={true} ). Controls option selected. Every value string match thevalue some<option> nested inside the<select> . pass value , must also pass onChange handler updates passed value. <select> uncontrolled, may pass defaultValue prop instead: defaultValue : string (or array strings formultiple={true} ). Specifies initially selected option. <select> props relevant uncontrolled controlled select boxes: autoComplete : string. Specifies one possible autocomplete behaviors.autoFocus : boolean. Iftrue , React focus element mount.children :<select> accepts<option> ,<optgroup> , and<datalist> components children. also pass components long eventually render one allowed components. pass components eventually render<option> tags, each<option> render must avalue .disabled : boolean. Iftrue , select box interactive appear dimmed.form : string. Specifies theid the<form> select box belongs to. omitted, it\u2019s closest parent form.multiple : boolean. Iftrue , browser allows multiple selection.name : string. Specifies name select box that\u2019s submitted form.onChange : AnEvent handler function. Required controlled select boxes. Fires immediately user picks different option. Behaves like browserinput event.onChangeCapture : version ofonChange fires capture phase.onInput : AnEvent handler function. Fires immediately value changed user. historical reasons, React idiomatic useonChange instead works similarly.onInputCapture : version ofonInput fires capture phase.onInvalid : AnEvent handler function. Fires input fails validation form submit. Unlike built-ininvalid event, ReactonInvalid event bubbles.onInvalidCapture : version ofonInvalid fires capture phase.required : boolean. Iftrue , value must provided form submit.size : number. Formultiple={true} selects, specifies preferred number initially visible items. Caveats - Unlike HTML, passing selected attribute to<option> supported. Instead, use<select defaultValue> uncontrolled select boxes and<select value> controlled select boxes. - select box receives value prop, treated controlled. - select box can\u2019t controlled uncontrolled time. - select box cannot switch controlled uncontrolled lifetime. - Every controlled select box needs onChange event handler synchronously updates backing value. Usage Displaying select box options Render <select> list <option> components inside display select box. Give <option> value representing data submitted form. export default function FruitPicker() { return ( <label> Pick fruit: <select name=\"selectedFruit\"> <option value=\"apple\">Apple</option> <option value=\"banana\">Banana</option> <option value=\"orange\">Orange</option> </select> </label> ); } Providing label select box Typically, place every <select> inside <label> tag. tells browser label associated select box. user clicks label, browser automatically focus select box. It\u2019s also essential accessibility: screen reader announce label caption user focuses select box. can\u2019t nest <select> <label> , associate passing ID <select id> <label htmlFor> . avoid conflicts multiple instances one component, generate ID useId . import { useId } 'react'; export default function Form() { const vegetableSelectId = useId(); return ( <> <label> Pick fruit: <select name=\"selectedFruit\"> <option value=\"apple\">Apple</option> <option value=\"banana\">Banana</option> <option value=\"orange\">Orange</option> </select> </label> <hr /> <label htmlFor={vegetableSelectId}> Pick vegetable: </label> <select id={vegetableSelectId} name=\"selectedVegetable\"> <option value=\"cucumber\">Cucumber</option> <option value=\"corn\">Corn</option> <option value=\"tomato\">Tomato</option> </select> </> ); } Providing initially selected option default, browser select first <option> list. select different option default, pass <option> \u2019s value defaultValue <select> element. export default function FruitPicker() { return ( <label> Pick fruit: <select name=\"selectedFruit\" defaultValue=\"orange\"> <option value=\"apple\">Apple</option> <option value=\"banana\">Banana</option> <option value=\"orange\">Orange</option> </select> </label> ); } Enabling multiple selection Pass multiple={true} <select> let user select multiple options. case, also specify defaultValue choose initially selected options, must array. export default function FruitPicker() { return ( <label> Pick fruits: <select name=\"selectedFruit\" defaultValue={['orange', 'banana']} multiple={true} > <option value=\"apple\">Apple</option> <option value=\"banana\">Banana</option> <option value=\"orange\">Orange</option> </select> </label> ); } Reading select box value submitting form Add <form> around select box <button type=\"submit\"> inside. call <form onSubmit> event handler. default, browser send form data current URL refresh page. override behavior calling e.preventDefault() . Read form data new FormData(e.target) . export default function EditPost() { function handleSubmit(e) { // Prevent browser reloading page e.preventDefault(); // Read form data const form = e.target; const formData = new FormData(form); // pass formData fetch body directly: fetch('/some-api', { method: form.method, body: formData }); // generate URL it, browser default: console.log(new URLSearchParams(formData).toString()); // work plain object. const formJson = Object.fromEntries(formData.entries()); console.log(formJson); // (!) include multiple select values // get array name-value pairs. console.log([...formData.entries()]); } return ( <form method=\"post\" onSubmit={handleSubmit}> <label> Pick favorite fruit: <select name=\"selectedFruit\" defaultValue=\"orange\"> <option value=\"apple\">Apple</option> <option value=\"banana\">Banana</option> <option value=\"orange\">Orange</option> </select> </label> <label> Pick favorite vegetables: <select name=\"selectedVegetables\" multiple={true} defaultValue={['corn', 'tomato']} > <option value=\"cucumber\">Cucumber</option> <option value=\"corn\">Corn</option> <option value=\"tomato\">Tomato</option> </select> </label> <hr /> <button type=\"reset\">Reset</button> <button type=\"submit\">Submit</button> </form> ); } Controlling select box state variable select box like <select /> uncontrolled. Even pass initially selected value like <select defaultValue=\"orange\" /> , JSX specifies initial value, value right now. render controlled select box, pass value prop it. React force select box always value passed. Typically, control select box declaring state variable: function FruitPicker() { const [selectedFruit, setSelectedFruit] = useState('orange'); // Declare state variable... // ... return ( <select value={selectedFruit} // ...force select's value match state variable... onChange={e => setSelectedFruit(e.target.value)} // ... update state variable change! > <option value=\"apple\">Apple</option> <option value=\"banana\">Banana</option> <option value=\"orange\">Orange</option> </select> ); } useful want re-render part UI response every selection. import { useState } 'react'; export default function FruitPicker() { const [selectedFruit, setSelectedFruit] = useState('orange'); const [selectedVegs, setSelectedVegs] = useState(['corn', 'tomato']); return ( <> <label> Pick fruit: <select value={selectedFruit} onChange={e => setSelectedFruit(e.target.value)} > <option value=\"apple\">Apple</option> <option value=\"banana\">Banana</option> <option value=\"orange\">Orange</option> </select> </label> <hr /> <label> Pick favorite vegetables: <select multiple={true} value={selectedVegs} onChange={e => { const options = [...e.target.selectedOptions]; const values = options.map(option => option.value); setSelectedVegs(values); }} > <option value=\"cucumber\">Cucumber</option> <option value=\"corn\">Corn</option> <option value=\"tomato\">Tomato</option> </select> </label> <hr /> <p>Your favorite fruit: {selectedFruit}</p> <p>Your favorite vegetables: {selectedVegs.join(', ')}</p> </> ); }"},
{"source": "https://react.dev/reference/react-dom/components/style", "title": "<style> \u2013 React", "text": "<style> built-in browser <style> component lets add inline CSS stylesheets document. <style>{` p { color: red; } `}</style> Reference <style> add inline styles document, render built-in browser <style> component. render <style> component React certain cases place corresponding DOM element document head de-duplicate identical styles. <style>{` p { color: red; } `}</style> Props <style> supports common element props. children : string, required. contents stylesheet.precedence : string. Tells React rank the<style> DOM node relative others document<head> , determines stylesheet override other. React infer precedence values discovers first \u201clower\u201d precedence values discovers later \u201chigher\u201d. Many style systems work fine using single precedence value style rules atomic. Stylesheets precedence go together whether are<link> inline<style> tags loaded usingpreinit functions.href : string. Allows React de-duplicate styles samehref .media : string. Restricts stylesheet certain media query.nonce : string. cryptographic nonce allow resource using strict Content Security Policy.title : string. Specifies name alternative stylesheet. Props recommended use React: blocking : string. set to\"render\" , instructs browser render page stylesheet loaded. React provides fine-grained control using Suspense. Special rendering behavior React move <style> components document\u2019s <head> , de-duplicate identical stylesheets, suspend stylesheet loading. opt behavior, provide href precedence props. React de-duplicate styles href . precedence prop tells React rank <style> DOM node relative others document <head> , determines stylesheet override other. special treatment comes two caveats: - React ignore changes props style rendered. (React issue warning development happens.) - React may leave style DOM even component rendered unmounted. Usage Rendering inline CSS stylesheet component depends certain CSS styles order displayed correctly, render inline stylesheet within component. href prop uniquely identify stylesheet, React de-duplicate stylesheets href . supply precedence prop, React reorder inline stylesheets based order values appear component tree. Inline stylesheets trigger Suspense boundaries they\u2019re loading. Even load async resources like fonts images. import ShowRenderedHTML './ShowRenderedHTML.js'; import { useId } 'react'; function PieChart({data, colors}) { const id = useId(); const stylesheet = colors.map((color, index) => `#${id} .color-${index}: \\{ color: \"${color}\"; \\}` ).join(); return ( <> <style href={\"PieChart-\" + JSON.stringify(colors)} precedence=\"medium\"> {stylesheet} </style> <svg id={id}> \u2026 </svg> </> ); } export default function App() { return ( <ShowRenderedHTML> <PieChart data=\"...\" colors={['red', 'green', 'blue']} /> </ShowRenderedHTML> ); }"},
{"source": "https://react.dev/reference/react-dom/components/textarea", "title": "<textarea> \u2013 React", "text": "<textarea> built-in browser <textarea> component lets render multiline text input. <textarea /> Reference <textarea> display text area, render built-in browser <textarea> component. <textarea name=\"postContent\" /> Props <textarea> supports common element props. make text area controlled passing value prop: value : string. Controls text inside text area. pass value , must also pass onChange handler updates passed value. <textarea> uncontrolled, may pass defaultValue prop instead: defaultValue : string. Specifies initial value text area. <textarea> props relevant uncontrolled controlled text areas: autoComplete : Either'on' or'off' . Specifies autocomplete behavior.autoFocus : boolean. Iftrue , React focus element mount.children :<textarea> accept children. set initial value, usedefaultValue .cols : number. Specifies default width average character widths. Defaults to20 .disabled : boolean. Iftrue , input interactive appear dimmed.form : string. Specifies theid the<form> input belongs to. omitted, it\u2019s closest parent form.maxLength : number. Specifies maximum length text.minLength : number. Specifies minimum length text.name : string. Specifies name input that\u2019s submitted form.onChange : AnEvent handler function. Required controlled text areas. Fires immediately input\u2019s value changed user (for example, fires every keystroke). Behaves like browserinput event.onChangeCapture : version ofonChange fires capture phase.onInput : AnEvent handler function. Fires immediately value changed user. historical reasons, React idiomatic useonChange instead works similarly.onInputCapture : version ofonInput fires capture phase.onInvalid : AnEvent handler function. Fires input fails validation form submit. Unlike built-ininvalid event, ReactonInvalid event bubbles.onInvalidCapture : version ofonInvalid fires capture phase.onSelect : AnEvent handler function. Fires selection inside the<textarea> changes. React extends theonSelect event also fire empty selection edits (which may affect selection).onSelectCapture : version ofonSelect fires capture phase.placeholder : string. Displayed dimmed color text area value empty.readOnly : boolean. Iftrue , text area editable user.required : boolean. Iftrue , value must provided form submit.rows : number. Specifies default height average character heights. Defaults to2 .wrap : Either'hard' ,'soft' , or'off' . Specifies text wrapped submitting form. Caveats - Passing children like <textarea>something</textarea> allowed. UsedefaultValue initial content. - text area receives string value prop, treated controlled. - text area can\u2019t controlled uncontrolled time. - text area cannot switch controlled uncontrolled lifetime. - Every controlled text area needs onChange event handler synchronously updates backing value. Usage Displaying text area Render <textarea> display text area. specify default size rows cols attributes, default user able resize it. disable resizing, specify resize: none CSS. export default function NewPost() { return ( <label> Write post: <textarea name=\"postContent\" rows={4} cols={40} /> </label> ); } Providing label text area Typically, place every <textarea> inside <label> tag. tells browser label associated text area. user clicks label, browser focus text area. It\u2019s also essential accessibility: screen reader announce label caption user focuses text area. can\u2019t nest <textarea> <label> , associate passing ID <textarea id> <label htmlFor> . avoid conflicts instances one component, generate ID useId . import { useId } 'react'; export default function Form() { const postTextAreaId = useId(); return ( <> <label htmlFor={postTextAreaId}> Write post: </label> <textarea id={postTextAreaId} name=\"postContent\" rows={4} cols={40} /> </> ); } Providing initial value text area optionally specify initial value text area. Pass defaultValue string. export default function EditPost() { return ( <label> Edit post: <textarea name=\"postContent\" defaultValue=\"I really enjoyed biking yesterday!\" rows={4} cols={40} /> </label> ); } Reading text area value submitting form Add <form> around textarea <button type=\"submit\"> inside. call <form onSubmit> event handler. default, browser send form data current URL refresh page. override behavior calling e.preventDefault() . Read form data new FormData(e.target) . export default function EditPost() { function handleSubmit(e) { // Prevent browser reloading page e.preventDefault(); // Read form data const form = e.target; const formData = new FormData(form); // pass formData fetch body directly: fetch('/some-api', { method: form.method, body: formData }); // work plain object: const formJson = Object.fromEntries(formData.entries()); console.log(formJson); } return ( <form method=\"post\" onSubmit={handleSubmit}> <label> Post title: <input name=\"postTitle\" defaultValue=\"Biking\" /> </label> <label> Edit post: <textarea name=\"postContent\" defaultValue=\"I really enjoyed biking yesterday!\" rows={4} cols={40} /> </label> <hr /> <button type=\"reset\">Reset edits</button> <button type=\"submit\">Save post</button> </form> ); } Controlling text area state variable text area like <textarea /> uncontrolled. Even pass initial value like <textarea defaultValue=\"Initial text\" /> , JSX specifies initial value, value right now. render controlled text area, pass value prop it. React force text area always value passed. Typically, control text area declaring state variable: function NewPost() { const [postContent, setPostContent] = useState(''); // Declare state variable... // ... return ( <textarea value={postContent} // ...force input's value match state variable... onChange={e => setPostContent(e.target.value)} // ... update state variable edits! /> ); } useful want re-render part UI response every keystroke. { \"dependencies\": { \"react\": \"latest\", \"react-dom\": \"latest\", \"react-scripts\": \"latest\", \"remarkable\": \"2.0.1\" }, \"scripts\": { \"start\": \"react-scripts start\", \"build\": \"react-scripts build\", \"test\": \"react-scripts test --env=jsdom\", \"eject\": \"react-scripts eject\" }, \"devDependencies\": {} } Troubleshooting text area doesn\u2019t update type render text area value onChange , see error console: // \ud83d\udd34 Bug: controlled text area onChange handler <textarea value={something} /> value prop form field without onChange handler. render read-only field. field mutable use defaultValue . Otherwise, set either onChange readOnly .As error message suggests, wanted specify initial value, pass defaultValue instead: // \u2705 Good: uncontrolled text area initial value <textarea defaultValue={something} /> want control text area state variable, specify onChange handler: // \u2705 Good: controlled text area onChange <textarea value={something} onChange={e => setSomething(e.target.value)} /> value intentionally read-only, add readOnly prop suppress error: // \u2705 Good: readonly controlled text area without change <textarea value={something} readOnly={true} /> text area caret jumps beginning every keystroke control text area, must update state variable text area\u2019s value DOM onChange . can\u2019t update something e.target.value : function handleChange(e) { // \ud83d\udd34 Bug: updating input something e.target.value setFirstName(e.target.value.toUpperCase()); } also can\u2019t update asynchronously: function handleChange(e) { // \ud83d\udd34 Bug: updating input asynchronously setTimeout(() => { setFirstName(e.target.value); }, 100); } fix code, update synchronously e.target.value : function handleChange(e) { // \u2705 Updating controlled input e.target.value synchronously setFirstName(e.target.value); } doesn\u2019t fix problem, it\u2019s possible text area gets removed re-added DOM every keystroke. happen you\u2019re accidentally resetting state every re-render. example, happen text area one parents always receives different key attribute, nest component definitions (which allowed React causes \u201cinner\u201d component remount every render). I\u2019m getting error: \u201cA component changing uncontrolled input controlled\u201d provide value component, must remain string throughout lifetime. cannot pass value={undefined} first later pass value=\"some string\" React won\u2019t know whether want component uncontrolled controlled. controlled component always receive string value , null undefined . value coming API state variable, might initialized null undefined . case, either set empty string ('' ) initially, pass value={someValue ?? ''} ensure value string."},
{"source": "https://react.dev/reference/react-dom/components/title", "title": "<title> \u2013 React", "text": "<title> built-in browser <title> component lets specify title document. <title>My Blog</title> Reference <title> specify title document, render built-in browser <title> component. render <title> component React always place corresponding DOM element document head. <title>My Blog</title> Props <title> supports common element props. children :<title> accepts text child. text become title document. also pass components long render text. Special rendering behavior React always place DOM element corresponding <title> component within document\u2019s <head> , regardless React tree rendered. <head> valid place <title> exist within DOM, yet it\u2019s convenient keeps things composable component representing specific page render <title> itself. two exception this: - <title> within an<svg> component, special behavior, context doesn\u2019t represent document\u2019s title rather accessibility annotation SVG graphic. - <title> anitemProp prop, special behavior, case doesn\u2019t represent document\u2019s title rather metadata specific part page. Usage Set document title Render <title> component component text children. React put <title> DOM node document <head> . import ShowRenderedHTML './ShowRenderedHTML.js'; export default function ContactUsPage() { return ( <ShowRenderedHTML> <title>My Site: Contact Us</title> <h1>Contact Us</h1> <p>Email us support@example.com</p> </ShowRenderedHTML> ); } Use variables title children <title> component must single string text. (Or single number single object toString method.) might obvious, using JSX curly braces like this: <title>Results page {pageNumber}</title> // \ud83d\udd34 Problem: single string \u2026 actually causes <title> component get two-element array children (the string \"Results page\" value pageNumber ). cause error. Instead, use string interpolation pass <title> single string: <title>{`Results page ${pageNumber}`}</title>"},
{"source": "https://react.dev/reference/react-dom/createPortal", "title": "createPortal \u2013 React", "text": "createPortal createPortal lets render children different part DOM. <div> <SomeComponent /> {createPortal(children, domNode, key?)} </div> Reference createPortal(children, domNode, key?) create portal, call createPortal , passing JSX, DOM node rendered: import { createPortal } 'react-dom'; // ... <div> <p>This child placed parent div.</p> {createPortal( <p>This child placed document body.</p>, document.body )} </div> portal changes physical placement DOM node. every way, JSX render portal acts child node React component renders it. example, child access context provided parent tree, events bubble children parents according React tree. Parameters - children : Anything rendered React, piece JSX (e.g.<div /> or<SomeComponent /> ), Fragment (<>...</> ), string number, array these. - domNode : DOM node, returned bydocument.getElementById() . node must already exist. Passing different DOM node update cause portal content recreated. - optional key : unique string number used portal\u2019s key. Returns createPortal returns React node included JSX returned React component. React encounters render output, place provided children inside provided domNode . Caveats - Events portals propagate according React tree rather DOM tree. example, click inside portal, portal wrapped <div onClick> , thatonClick handler fire. causes issues, either stop event propagation inside portal, move portal React tree. Usage Rendering different part DOM Portals let components render children different place DOM. lets part component \u201cescape\u201d whatever containers may in. example, component display modal dialog tooltip appears outside rest page. create portal, render result createPortal JSX DOM node go: import { createPortal } 'react-dom'; function MyComponent() { return ( <div style={{ border: '2px solid black' }}> <p>This child placed parent div.</p> {createPortal( <p>This child placed document body.</p>, document.body )} </div> ); } React put DOM nodes JSX passed inside DOM node provided. Without portal, second <p> would placed inside parent <div> , portal \u201cteleported\u201d document.body : import { createPortal } 'react-dom'; export default function MyComponent() { return ( <div style={{ border: '2px solid black' }}> <p>This child placed parent div.</p> {createPortal( <p>This child placed document body.</p>, document.body )} </div> ); } Notice second paragraph visually appears outside parent <div> border. inspect DOM structure developer tools, you\u2019ll see second <p> got placed directly <body> : <body> <div id=\"root\"> ... <div style=\"border: 2px solid black\"> <p>This child placed inside parent div.</p> </div> ... </div> <p>This child placed document body.</p> </body> portal changes physical placement DOM node. every way, JSX render portal acts child node React component renders it. example, child access context provided parent tree, events still bubble children parents according React tree. Rendering modal dialog portal use portal create modal dialog floats rest page, even component summons dialog inside container overflow: hidden styles interfere dialog. example, two containers styles disrupt modal dialog, one rendered portal unaffected because, DOM, modal contained within parent JSX elements. import NoPortalExample './NoPortalExample'; import PortalExample './PortalExample'; export default function App() { return ( <> <div className=\"clipping-container\"> <NoPortalExample /> </div> <div className=\"clipping-container\"> <PortalExample /> </div> </> ); } Rendering React components non-React server markup Portals useful React root part static server-rendered page isn\u2019t built React. example, page built server framework like Rails, create areas interactivity within static areas sidebars. Compared multiple separate React roots, portals let treat app single React tree shared state even though parts render different parts DOM. import { createPortal } 'react-dom'; const sidebarContentEl = document.getElementById('sidebar-content'); export default function App() { return ( <> <MainContent /> {createPortal( <SidebarContent />, sidebarContentEl )} </> ); } function MainContent() { return <p>This part rendered React</p>; } function SidebarContent() { return <p>This part also rendered React!</p>; } Rendering React components non-React DOM nodes also use portal manage content DOM node that\u2019s managed outside React. example, suppose you\u2019re integrating non-React map widget want render React content inside popup. this, declare popupContainer state variable store DOM node you\u2019re going render into: const [popupContainer, setPopupContainer] = useState(null); create third-party widget, store DOM node returned widget render it: useEffect(() => { (mapRef.current === null) { const map = createMapWidget(containerRef.current); mapRef.current = map; const popupDiv = addPopupToMapWidget(map); setPopupContainer(popupDiv); } }, []); lets use createPortal render React content popupContainer becomes available: return ( <div style={{ width: 250, height: 250 }} ref={containerRef}> {popupContainer !== null && createPortal( <p>Hello React!</p>, popupContainer )} </div> ); complete example play with: import { useRef, useEffect, useState } 'react'; import { createPortal } 'react-dom'; import { createMapWidget, addPopupToMapWidget } './map-widget.js'; export default function Map() { const containerRef = useRef(null); const mapRef = useRef(null); const [popupContainer, setPopupContainer] = useState(null); useEffect(() => { (mapRef.current === null) { const map = createMapWidget(containerRef.current); mapRef.current = map; const popupDiv = addPopupToMapWidget(map); setPopupContainer(popupDiv); } }, []); return ( <div style={{ width: 250, height: 250 }} ref={containerRef}> {popupContainer !== null && createPortal( <p>Hello React!</p>, popupContainer )} </div> ); }"},
{"source": "https://react.dev/reference/react-dom/findDOMNode", "title": "findDOMNode \u2013 React", "text": "findDOMNode findDOMNode finds browser DOM node React class component instance. const domNode = findDOMNode(componentInstance) Reference findDOMNode(componentInstance) Call findDOMNode find browser DOM node given React class component instance. import { findDOMNode } 'react-dom'; const domNode = findDOMNode(componentInstance); Parameters componentInstance : instance theComponent subclass. example,this inside class component. Returns findDOMNode returns first closest browser DOM node within given componentInstance . component renders null , renders false , findDOMNode returns null . component renders string, findDOMNode returns text DOM node containing value. Caveats - component may return array Fragment multiple children. case findDOMNode , return DOM node corresponding first non-empty child. - findDOMNode works mounted components (that is, components placed DOM). try call component mounted yet (like callingfindDOMNode() inrender() component yet created), exception thrown. - findDOMNode returns result time call. child component renders different node later, way notified change. - findDOMNode accepts class component instance, can\u2019t used function components. Usage Finding root DOM node class component Call findDOMNode class component instance (usually, ) find DOM node rendered. class AutoselectingInput extends Component { componentDidMount() { const input = findDOMNode(this); input.select() } render() { return <input defaultValue=\"Hello\" /> } } Here, input variable set <input> DOM element. lets something it. example, clicking \u201cShow example\u201d mounts input, input.select() selects text input: import { Component } 'react'; import { findDOMNode } 'react-dom'; class AutoselectingInput extends Component { componentDidMount() { const input = findDOMNode(this); input.select() } render() { return <input defaultValue=\"Hello\" /> } } export default AutoselectingInput; Alternatives Reading component\u2019s DOM node ref Code using findDOMNode fragile connection JSX node code manipulating corresponding DOM node explicit. example, try wrapping <input /> <div> : import { Component } 'react'; import { findDOMNode } 'react-dom'; class AutoselectingInput extends Component { componentDidMount() { const input = findDOMNode(this); input.select() } render() { return <input defaultValue=\"Hello\" /> } } export default AutoselectingInput; break code now, findDOMNode(this) finds <div> DOM node, code expects <input> DOM node. avoid kinds problems, use createRef manage specific DOM node. example, findDOMNode longer used. Instead, inputRef = createRef(null) defined instance field class. read DOM node it, use this.inputRef.current . attach JSX, render <input ref={this.inputRef} /> . connects code using DOM node JSX: import { createRef, Component } 'react'; class AutoselectingInput extends Component { inputRef = createRef(null); componentDidMount() { const input = this.inputRef.current; input.select() } render() { return ( <input ref={this.inputRef} defaultValue=\"Hello\" /> ); } } export default AutoselectingInput; modern React without class components, equivalent code would call useRef instead: import { useRef, useEffect } 'react'; export default function AutoselectingInput() { const inputRef = useRef(null); useEffect(() => { const input = inputRef.current; input.select(); }, []); return <input ref={inputRef} defaultValue=\"Hello\" /> } Read manipulating DOM refs. Reading child component\u2019s DOM node forwarded ref example, findDOMNode(this) finds DOM node belongs another component. AutoselectingInput renders MyInput , component renders browser <input> . import { Component } 'react'; import { findDOMNode } 'react-dom'; import MyInput './MyInput.js'; class AutoselectingInput extends Component { componentDidMount() { const input = findDOMNode(this); input.select() } render() { return <MyInput />; } } export default AutoselectingInput; Notice calling findDOMNode(this) inside AutoselectingInput still gives DOM <input> \u2014even though JSX <input> hidden inside MyInput component. seems convenient example, leads fragile code. Imagine wanted edit MyInput later add wrapper <div> around it. would break code AutoselectingInput (which expects find <input> ). replace findDOMNode example, two components need coordinate: AutoSelectingInput declare ref, like earlier example, pass to<MyInput> .MyInput declared withforwardRef take ref forward the<input> node. version that, longer needs findDOMNode : import { createRef, Component } 'react'; import MyInput './MyInput.js'; class AutoselectingInput extends Component { inputRef = createRef(null); componentDidMount() { const input = this.inputRef.current; input.select() } render() { return ( <MyInput ref={this.inputRef} /> ); } } export default AutoselectingInput; code would look like function components instead classes: import { useRef, useEffect } 'react'; import MyInput './MyInput.js'; export default function AutoselectingInput() { const inputRef = useRef(null); useEffect(() => { const input = inputRef.current; input.select(); }, []); return <MyInput ref={inputRef} defaultValue=\"Hello\" /> } Adding wrapper <div> element Sometimes component needs know position size children. makes tempting find children findDOMNode(this) , use DOM methods like getBoundingClientRect measurements. currently direct equivalent use case, findDOMNode deprecated yet removed completely React. meantime, try rendering wrapper <div> node around content workaround, getting ref node. However, extra wrappers break styling. <div ref={someRef}> {children} </div> also applies focusing scrolling arbitrary children."},
{"source": "https://react.dev/reference/react-dom/flushSync", "title": "flushSync \u2013 React", "text": "flushSync flushSync lets force React flush updates inside provided callback synchronously. ensures DOM updated immediately. flushSync(callback) Reference flushSync(callback) Call flushSync force React flush pending work update DOM synchronously. import { flushSync } 'react-dom'; flushSync(() => { setSomething(123); }); time, flushSync avoided. Use flushSync last resort. Parameters callback : function. React immediately call callback flush updates contains synchronously. may also flush pending updates, Effects, updates inside Effects. update suspends result thisflushSync call, fallbacks may re-shown. Returns flushSync returns undefined . Caveats flushSync significantly hurt performance. Use sparingly.flushSync may force pending Suspense boundaries show theirfallback state.flushSync may run pending Effects synchronously apply updates contain returning.flushSync may flush updates outside callback necessary flush updates inside callback. example, pending updates click, React may flush flushing updates inside callback. Usage Flushing updates third-party integrations integrating third-party code browser APIs UI libraries, may necessary force React flush updates. Use flushSync force React flush state updates inside callback synchronously: flushSync(() => { setSomething(123); }); // line, DOM updated. ensures that, time next line code runs, React already updated DOM. Using flushSync uncommon, using often significantly hurt performance app. app uses React APIs, integrate third-party libraries, flushSync unnecessary. However, helpful integrating third-party code like browser APIs. browser APIs expect results inside callbacks written DOM synchronously, end callback, browser something rendered DOM. cases, React handles automatically. cases may necessary force synchronous update. example, browser onbeforeprint API allows change page immediately print dialog opens. useful applying custom print styles allow document display better printing. example below, use flushSync inside onbeforeprint callback immediately \u201cflush\u201d React state DOM. Then, time print dialog opens, isPrinting displays \u201cyes\u201d: import { useState, useEffect } 'react'; import { flushSync } 'react-dom'; export default function PrintApp() { const [isPrinting, setIsPrinting] = useState(false); useEffect(() => { function handleBeforePrint() { flushSync(() => { setIsPrinting(true); }) } function handleAfterPrint() { setIsPrinting(false); } window.addEventListener('beforeprint', handleBeforePrint); window.addEventListener('afterprint', handleAfterPrint); return () => { window.removeEventListener('beforeprint', handleBeforePrint); window.removeEventListener('afterprint', handleAfterPrint); } }, []); return ( <> <h1>isPrinting: {isPrinting ? 'yes' : 'no'}</h1> <button onClick={() => window.print()}> Print </button> </> ); } Without flushSync , print dialog display isPrinting \u201cno\u201d. React batches updates asynchronously print dialog displayed state updated."},
{"source": "https://react.dev/reference/react-dom/hooks", "title": "Built-in React DOM Hooks \u2013 React", "text": "Built-in React DOM Hooks react-dom package contains Hooks supported web applications (which run browser DOM environment). Hooks supported non-browser environments like iOS, Android, Windows applications. looking Hooks supported web browsers environments see React Hooks page. page lists Hooks react-dom package. Form Hooks Forms let create interactive controls submitting information. manage forms components, use one Hooks: useFormStatus allows make updates UI based status form. function Form({ action }) { async function increment(n) { return n + 1; } const [count, incrementFormAction] = useActionState(increment, 0); return ( <form action={action}> <button formAction={incrementFormAction}>Count: {count}</button> <Button /> </form> ); } function Button() { const { pending } = useFormStatus(); return ( <button disabled={pending} type=\"submit\"> Submit </button> ); }"},
{"source": "https://react.dev/reference/react/useActionState", "title": "useActionState \u2013 React", "text": "useActionState useActionState Hook allows update state based result form action. const [state, formAction, isPending] = useActionState(fn, initialState, permalink?); Reference useActionState(action, initialState, permalink?) Call useActionState top level component create component state updated form action invoked. pass useActionState existing form action function well initial state, returns new action use form, along latest form state whether Action still pending. latest form state also passed function provided. import { useActionState } \"react\"; async function increment(previousState, formData) { return previousState + 1; } function StatefulForm({}) { const [state, formAction] = useActionState(increment, 0); return ( <form> {state} <button formAction={formAction}>Increment</button> </form> ) } form state value returned action form last submitted. form yet submitted, initial state pass. used Server Function, useActionState allows server\u2019s response submitting form shown even hydration completed. Parameters fn : function called form submitted button pressed. function called, receive previous state form (initially theinitialState pass, subsequently previous return value) initial argument, followed arguments form action normally receives.initialState : value want state initially. serializable value. argument ignored action first invoked.- optional permalink : string containing unique page URL form modifies. use pages dynamic content (eg: feeds) conjunction progressive enhancement: iffn server function form submitted JavaScript bundle loads, browser navigate specified permalink URL, rather current page\u2019s URL. Ensure form component rendered destination page (including actionfn andpermalink ) React knows pass state through. form hydrated, parameter effect. Returns useActionState returns array following values: - current state. first render, match initialState passed. action invoked, match value returned action. - new action pass action prop yourform component orformAction prop anybutton component within form. - isPending flag tells whether pending Transition. Caveats - used framework supports React Server Components, useActionState lets make forms interactive JavaScript executed client. used without Server Components, equivalent component local state. - function passed useActionState receives extra argument, previous initial state, first argument. makes signature different used directly form action without usinguseActionState . Usage Using information returned form action Call useActionState top level component access return value action last time form submitted. import { useActionState } 'react'; import { action } './actions.js'; function MyComponent() { const [state, formAction] = useActionState(action, null); // ... return ( <form action={formAction}> {/* ... */} </form> ); } useActionState returns array following items: - current state form, initially set initial state provided, form submitted set return value action provided. - new action pass <form> itsaction prop. - pending state utilise whilst action processing. form submitted, action function provided called. return value become new current state form. action provide also receive new first argument, namely current state form. first time form submitted, initial state provided, subsequent submissions, return value last time action called. rest arguments useActionState used. function action(currentState, formData) { // ... return 'next state'; } Example 1 2: Display form errors display messages error message toast that\u2019s returned Server Function, wrap action call useActionState . import { useActionState, useState } \"react\"; import { addToCart } \"./actions.js\"; function AddToCartForm({itemID, itemTitle}) { const [message, formAction, isPending] = useActionState(addToCart, null); return ( <form action={formAction}> <h2>{itemTitle}</h2> <input type=\"hidden\" name=\"itemID\" value={itemID} /> <button type=\"submit\">Add Cart</button> {isPending ? \"Loading...\" : message} </form> ); } export default function App() { return ( <> <AddToCartForm itemID=\"1\" itemTitle=\"JavaScript: Definitive Guide\" /> <AddToCartForm itemID=\"2\" itemTitle=\"JavaScript: Good Parts\" /> </> ) } Troubleshooting action longer read submitted form data wrap action useActionState , gets extra argument first argument. submitted form data therefore second argument instead first would usually be. new first argument gets added current state form. function action(currentState, formData) { // ... }"},
{"source": "https://react.dev/reference/react-dom/hooks/useFormStatus", "title": "useFormStatus \u2013 React", "text": "useFormStatus useFormStatus Hook gives status information last form submission. const { pending, data, method, action } = useFormStatus(); Reference useFormStatus() useFormStatus Hook provides status information last form submission. import { useFormStatus } \"react-dom\"; import action './actions'; function Submit() { const status = useFormStatus(); return <button disabled={status.pending}>Submit</button> } export default function App() { return ( <form action={action}> <Submit /> </form> ); } get status information, Submit component must rendered within <form> . Hook returns information like pending property tells form actively submitting. example, Submit uses information disable <button> presses form submitting. Parameters useFormStatus take parameters. Returns status object following properties: - pending : boolean. Iftrue , means parent<form> pending submission. Otherwise,false . - data : object implementing theFormData interface contains data parent<form> submitting. active submission parent<form> , benull . - method : string value either'get' or'post' . represents whether parent<form> submitting either aGET orPOST HTTP method. default, a<form> use theGET method specified themethod property. action : reference function passed theaction prop parent<form> . parent<form> , property isnull . URI value provided theaction prop, noaction prop specified,status.action benull . Caveats - useFormStatus Hook must called component rendered inside a<form> . useFormStatus return status information parent<form> . return status information any<form> rendered component children components. Usage Display pending state form submission display pending state form submitting, call useFormStatus Hook component rendered <form> read pending property returned. Here, use pending property indicate form submitting. import { useFormStatus } \"react-dom\"; import { submitForm } \"./actions.js\"; function Submit() { const { pending } = useFormStatus(); return ( <button type=\"submit\" disabled={pending}> {pending ? \"Submitting...\" : \"Submit\"} </button> ); } function Form({ action }) { return ( <form action={action}> <Submit /> </form> ); } export default function App() { return <Form action={submitForm} />; } Read form data submitted use data property status information returned useFormStatus display data submitted user. Here, form users request username. use useFormStatus display temporary status message confirming username requested. import {useState, useMemo, useRef} 'react'; import {useFormStatus} 'react-dom'; export default function UsernameForm() { const {pending, data} = useFormStatus(); return ( <div> <h3>Request Username: </h3> <input type=\"text\" name=\"username\" disabled={pending}/> <button type=\"submit\" disabled={pending}> Submit </button> <br /> <p>{data ? `Requesting ${data?.get(\"username\")}...`: ''}</p> </div> ); } Troubleshooting status.pending never true useFormStatus return status information parent <form> . component calls useFormStatus nested <form> , status.pending always return false . Verify useFormStatus called component child <form> element. useFormStatus track status <form> rendered component. See Pitfall details."},
{"source": "https://react.dev/reference/react-dom/hydrate", "title": "hydrate \u2013 React", "text": "hydrate hydrate lets display React components inside browser DOM node whose HTML content previously generated react-dom/server React 17 below. hydrate(reactNode, domNode, callback?) Reference hydrate(reactNode, domNode, callback?) Call hydrate React 17 \u201cattach\u201d React existing HTML already rendered React server environment. import { hydrate } 'react-dom'; hydrate(reactNode, domNode); React attach HTML exists inside domNode , take managing DOM inside it. app fully built React usually one hydrate call root component. Parameters - reactNode : \u201cReact node\u201d used render existing HTML. usually piece JSX like<App /> rendered aReactDOM Server method asrenderToString(<App />) React 17. - domNode : DOM element rendered root element server. - optional: callback : function. passed, React call component hydrated. Returns hydrate returns null. Caveats hydrate expects rendered content identical server-rendered content. React patch differences text content, treat mismatches bugs fix them.- development mode, React warns mismatches hydration. guarantees attribute differences patched case mismatches. important performance reasons apps, mismatches rare, validating markup would prohibitively expensive. - You\u2019ll likely one hydrate call app. use framework, might call you. - app client-rendered HTML rendered already, using hydrate() supported. Use render() (for React 17 below) createRoot() (for React 18+) instead. Usage Call hydrate attach React component server-rendered browser DOM node. import { hydrate } 'react-dom'; hydrate(<App />, document.getElementById('root')); Using hydrate() render client-only app (an app without server-rendered HTML) supported. Use render() (in React 17 below) createRoot() (in React 18+) instead. Hydrating server-rendered HTML React, \u201chydration\u201d React \u201cattaches\u201d existing HTML already rendered React server environment. hydration, React attempt attach event listeners existing markup take rendering app client. apps fully built React, usually hydrate one \u201croot\u201d, startup entire app. import './styles.css'; import { hydrate } 'react-dom'; import App './App.js'; hydrate(<App />, document.getElementById('root')); Usually shouldn\u2019t need call hydrate call places. point on, React managing DOM application. update UI, components use state. information hydration, see docs hydrateRoot . Suppressing unavoidable hydration mismatch errors single element\u2019s attribute text content unavoidably different server client (for example, timestamp), may silence hydration mismatch warning. silence hydration warnings element, add suppressHydrationWarning={true} : export default function App() { return ( <h1 suppressHydrationWarning={true}> Current Date: {new Date().toLocaleDateString()} </h1> ); } works one level deep, intended escape hatch. Don\u2019t overuse it. Unless it\u2019s text content, React still won\u2019t attempt patch up, may remain inconsistent future updates. Handling different client server content intentionally need render something different server client, two-pass rendering. Components render something different client read state variable like isClient , set true Effect: import { useState, useEffect } \"react\"; export default function App() { const [isClient, setIsClient] = useState(false); useEffect(() => { setIsClient(true); }, []); return ( <h1> {isClient ? 'Is Client' : 'Is Server'} </h1> ); } way initial render pass render content server, avoiding mismatches, additional pass happen synchronously right hydration."},
{"source": "https://react.dev/reference/react-dom/preconnect", "title": "preconnect \u2013 React", "text": "preconnect preconnect lets eagerly connect server expect load resources from. preconnect(\"https://example.com\"); Reference preconnect(href) preconnect host, call preconnect function react-dom . import { preconnect } 'react-dom'; function AppRoot() { preconnect(\"https://example.com\"); // ... } preconnect function provides browser hint open connection given server. browser chooses so, speed loading resources server. Parameters href : string. URL server want connect to. Returns preconnect returns nothing. Caveats - Multiple calls preconnect server effect single call. - browser, call preconnect situation: rendering component, Effect, event handler, on. - server-side rendering rendering Server Components, preconnect effect call rendering component async context originating rendering component. calls ignored. - know specific resources you\u2019ll need, call functions instead start loading resources right away. - benefit preconnecting server webpage hosted it\u2019s already connected time hint would given. Usage Preconnecting rendering Call preconnect rendering component know children load external resources host. import { preconnect } 'react-dom'; function AppRoot() { preconnect(\"https://example.com\"); return ...; } Preconnecting event handler Call preconnect event handler transitioning page state external resources needed. gets process started earlier call rendering new page state. import { preconnect } 'react-dom'; function CallToAction() { const onClick = () => { preconnect('http://example.com'); startWizard(); } return ( <button onClick={onClick}>Start Wizard</button> ); }"},
{"source": "https://react.dev/reference/react-dom/prefetchDNS", "title": "prefetchDNS \u2013 React", "text": "prefetchDNS prefetchDNS lets eagerly look IP server expect load resources from. prefetchDNS(\"https://example.com\"); Reference prefetchDNS(href) look host, call prefetchDNS function react-dom . import { prefetchDNS } 'react-dom'; function AppRoot() { prefetchDNS(\"https://example.com\"); // ... } prefetchDNS function provides browser hint look IP address given server. browser chooses so, speed loading resources server. Parameters href : string. URL server want connect to. Returns prefetchDNS returns nothing. Caveats - Multiple calls prefetchDNS server effect single call. - browser, call prefetchDNS situation: rendering component, Effect, event handler, on. - server-side rendering rendering Server Components, prefetchDNS effect call rendering component async context originating rendering component. calls ignored. - know specific resources you\u2019ll need, call functions instead start loading resources right away. - benefit prefetching server webpage hosted it\u2019s already looked time hint would given. - Compared preconnect ,prefetchDNS may better speculatively connecting large number domains, case overhead preconnections might outweigh benefit. Usage Prefetching DNS rendering Call prefetchDNS rendering component know children load external resources host. import { prefetchDNS } 'react-dom'; function AppRoot() { prefetchDNS(\"https://example.com\"); return ...; } Prefetching DNS event handler Call prefetchDNS event handler transitioning page state external resources needed. gets process started earlier call rendering new page state. import { prefetchDNS } 'react-dom'; function CallToAction() { const onClick = () => { prefetchDNS('http://example.com'); startWizard(); } return ( <button onClick={onClick}>Start Wizard</button> ); }"},
{"source": "https://react.dev/reference/react-dom/preinit", "title": "preinit \u2013 React", "text": "preinit preinit lets eagerly fetch evaluate stylesheet external script. preinit(\"https://example.com/script.js\", {as: \"script\"}); Reference preinit(href, options) preinit script stylesheet, call preinit function react-dom . import { preinit } 'react-dom'; function AppRoot() { preinit(\"https://example.com/script.js\", {as: \"script\"}); // ... } preinit function provides browser hint start downloading executing given resource, save time. Scripts preinit executed finish downloading. Stylesheets preinit inserted document, causes go effect right away. Parameters href : string. URL resource want download execute.options : object. contains following properties:as : required string. type resource. possible values arescript andstyle .precedence : string. Required stylesheets. Says insert stylesheet relative others. Stylesheets higher precedence override lower precedence. possible values arereset ,low ,medium ,high .crossOrigin : string. CORS policy use. possible values areanonymous anduse-credentials . required whenas set to\"fetch\" .integrity : string. cryptographic hash resource, verify authenticity.nonce : string. cryptographic nonce allow resource using strict Content Security Policy.fetchPriority : string. Suggests relative priority fetching resource. possible values areauto (the default),high , andlow . Returns preinit returns nothing. Caveats - Multiple calls preinit samehref effect single call. - browser, call preinit situation: rendering component, Effect, event handler, on. - server-side rendering rendering Server Components, preinit effect call rendering component async context originating rendering component. calls ignored. Usage Preiniting rendering Call preinit rendering component know children use specific resource, you\u2019re OK resource evaluated thereby taking effect immediately upon downloaded. Example 1 2: Preiniting external script import { preinit } 'react-dom'; function AppRoot() { preinit(\"https://example.com/script.js\", {as: \"script\"}); return ...; } want browser download script execute right away, use preload instead. want load ESM module, use preinitModule . Preiniting event handler Call preinit event handler transitioning page state external resources needed. gets process started earlier call rendering new page state. import { preinit } 'react-dom'; function CallToAction() { const onClick = () => { preinit(\"https://example.com/wizardStyles.css\", {as: \"style\"}); startWizard(); } return ( <button onClick={onClick}>Start Wizard</button> ); }"},
{"source": "https://react.dev/reference/react-dom/preinitModule", "title": "preinitModule \u2013 React", "text": "preinitModule preinitModule lets eagerly fetch evaluate ESM module. preinitModule(\"https://example.com/module.js\", {as: \"script\"}); Reference preinitModule(href, options) preinit ESM module, call preinitModule function react-dom . import { preinitModule } 'react-dom'; function AppRoot() { preinitModule(\"https://example.com/module.js\", {as: \"script\"}); // ... } preinitModule function provides browser hint start downloading executing given module, save time. Modules preinit executed finish downloading. Parameters href : string. URL module want download execute.options : object. contains following properties:as : required string. must be'script' .crossOrigin : string. CORS policy use. possible values areanonymous anduse-credentials .integrity : string. cryptographic hash module, verify authenticity.nonce : string. cryptographic nonce allow module using strict Content Security Policy. Returns preinitModule returns nothing. Caveats - Multiple calls preinitModule samehref effect single call. - browser, call preinitModule situation: rendering component, Effect, event handler, on. - server-side rendering rendering Server Components, preinitModule effect call rendering component async context originating rendering component. calls ignored. Usage Preloading rendering Call preinitModule rendering component know children use specific module you\u2019re OK module evaluated thereby taking effect immediately upon downloaded. import { preinitModule } 'react-dom'; function AppRoot() { preinitModule(\"https://example.com/module.js\", {as: \"script\"}); return ...; } want browser download module execute right away, use preloadModule instead. want preinit script isn\u2019t ESM module, use preinit . Preloading event handler Call preinitModule event handler transitioning page state module needed. gets process started earlier call rendering new page state. import { preinitModule } 'react-dom'; function CallToAction() { const onClick = () => { preinitModule(\"https://example.com/module.js\", {as: \"script\"}); startWizard(); } return ( <button onClick={onClick}>Start Wizard</button> ); }"},
{"source": "https://react.dev/reference/react-dom/preload", "title": "preload \u2013 React", "text": "preload preload lets eagerly fetch resource stylesheet, font, external script expect use. preload(\"https://example.com/font.woff2\", {as: \"font\"}); Reference preload(href, options) preload resource, call preload function react-dom . import { preload } 'react-dom'; function AppRoot() { preload(\"https://example.com/font.woff2\", {as: \"font\"}); // ... } preload function provides browser hint start downloading given resource, save time. Parameters href : string. URL resource want download.options : object. contains following properties:as : required string. type resource. possible values areaudio ,document ,embed ,fetch ,font ,image ,object ,script ,style ,track ,video ,worker .crossOrigin : string. CORS policy use. possible values areanonymous anduse-credentials . required whenas set to\"fetch\" .referrerPolicy : string. Referrer header send fetching. possible values areno-referrer-when-downgrade (the default),no-referrer ,origin ,origin-when-cross-origin , andunsafe-url .integrity : string. cryptographic hash resource, verify authenticity.type : string. MIME type resource.nonce : string. cryptographic nonce allow resource using strict Content Security Policy.fetchPriority : string. Suggests relative priority fetching resource. possible values areauto (the default),high , andlow .imageSrcSet : string. use withas: \"image\" . Specifies source set image.imageSizes : string. use withas: \"image\" . Specifies sizes image. Returns preload returns nothing. Caveats - Multiple equivalent calls preload effect single call. Calls topreload considered equivalent according following rules:- Two calls equivalent href , except: - set toimage , two calls equivalent samehref ,imageSrcSet , andimageSizes . - Two calls equivalent - browser, call preload situation: rendering component, Effect, event handler, on. - server-side rendering rendering Server Components, preload effect call rendering component async context originating rendering component. calls ignored. Usage Preloading rendering Call preload rendering component know children use specific resource. Example 1 4: Preloading external script import { preload } 'react-dom'; function AppRoot() { preload(\"https://example.com/script.js\", {as: \"script\"}); return ...; } want browser start executing script immediately (rather downloading it), use preinit instead. want load ESM module, use preloadModule . Preloading event handler Call preload event handler transitioning page state external resources needed. gets process started earlier call rendering new page state. import { preload } 'react-dom'; function CallToAction() { const onClick = () => { preload(\"https://example.com/wizardStyles.css\", {as: \"style\"}); startWizard(); } return ( <button onClick={onClick}>Start Wizard</button> ); }"},
{"source": "https://react.dev/reference/react-dom/preloadModule", "title": "preloadModule \u2013 React", "text": "preloadModule preloadModule lets eagerly fetch ESM module expect use. preloadModule(\"https://example.com/module.js\", {as: \"script\"}); Reference preloadModule(href, options) preload ESM module, call preloadModule function react-dom . import { preloadModule } 'react-dom'; function AppRoot() { preloadModule(\"https://example.com/module.js\", {as: \"script\"}); // ... } preloadModule function provides browser hint start downloading given module, save time. Parameters href : string. URL module want download.options : object. contains following properties:as : required string. must be'script' .crossOrigin : string. CORS policy use. possible values areanonymous anduse-credentials .integrity : string. cryptographic hash module, verify authenticity.nonce : string. cryptographic nonce allow module using strict Content Security Policy. Returns preloadModule returns nothing. Caveats - Multiple calls preloadModule samehref effect single call. - browser, call preloadModule situation: rendering component, Effect, event handler, on. - server-side rendering rendering Server Components, preloadModule effect call rendering component async context originating rendering component. calls ignored. Usage Preloading rendering Call preloadModule rendering component know children use specific module. import { preloadModule } 'react-dom'; function AppRoot() { preloadModule(\"https://example.com/module.js\", {as: \"script\"}); return ...; } want browser start executing module immediately (rather downloading it), use preinitModule instead. want load script isn\u2019t ESM module, use preload . Preloading event handler Call preloadModule event handler transitioning page state module needed. gets process started earlier call rendering new page state. import { preloadModule } 'react-dom'; function CallToAction() { const onClick = () => { preloadModule(\"https://example.com/module.js\", {as: \"script\"}); startWizard(); } return ( <button onClick={onClick}>Start Wizard</button> ); }"},
{"source": "https://react.dev/reference/react-dom/render", "title": "render \u2013 React", "text": "render render renders piece JSX (\u201cReact node\u201d) browser DOM node. render(reactNode, domNode, callback?) Reference render(reactNode, domNode, callback?) Call render display React component inside browser DOM element. import { render } 'react-dom'; const domNode = document.getElementById('root'); render(<App />, domNode); React display <App /> domNode , take managing DOM inside it. app fully built React usually one render call root component. page uses \u201csprinkles\u201d React parts page may many render calls needed. Parameters - reactNode : React node want display. usually piece JSX like<App /> , also pass React element constructed withcreateElement() , string, number,null , orundefined . - domNode : DOM element. React display thereactNode pass inside DOM element. moment, React manage DOM inside thedomNode update React tree changes. - optional callback : function. passed, React call component placed DOM. Returns render usually returns null . However, reactNode pass class component, return instance component. Caveats - React 18, render replaced bycreateRoot . Please usecreateRoot React 18 beyond. - first time call render , React clear existing HTML content inside thedomNode rendering React component it. yourdomNode contains HTML generated React server build, usehydrate() instead, attaches event handlers existing HTML. - call render samedomNode once, React update DOM necessary reflect latest JSX passed. React decide parts DOM reused need recreated \u201cmatching up\u201d previously rendered tree. Callingrender samedomNode similar calling theset function root component: React avoids unnecessary DOM updates. - app fully built React, you\u2019ll likely one render call app. (If use framework, might call you.) want render piece JSX different part DOM tree isn\u2019t child component (for example, modal tooltip), usecreatePortal instead ofrender . Usage Call render display React component inside browser DOM node. import { render } 'react-dom'; import App './App.js'; render(<App />, document.getElementById('root')); Rendering root component apps fully built React, usually startup\u2014to render \u201croot\u201d component. import './styles.css'; import { render } 'react-dom'; import App './App.js'; render(<App />, document.getElementById('root')); Usually shouldn\u2019t need call render call places. point on, React managing DOM application. update UI, components use state. Rendering multiple roots page isn\u2019t fully built React, call render top-level piece UI managed React. import './styles.css'; import { render } 'react-dom'; import { Comments, Navigation } './Components.js'; render( <Navigation />, document.getElementById('navigation') ); render( <Comments />, document.getElementById('comments') ); destroy rendered trees unmountComponentAtNode() . Updating rendered tree call render DOM node. long component tree structure matches previously rendered, React preserve state. Notice type input, means updates repeated render calls every second destructive: import { render } 'react-dom'; import './styles.css'; import App './App.js'; let = 0; setInterval(() => { render( <App counter={i} />, document.getElementById('root') ); i++; }, 1000); uncommon call render multiple times. Usually, you\u2019ll update state inside components instead."},
{"source": "https://react.dev/reference/react-dom/server", "title": "Server React DOM APIs \u2013 React", "text": "Server React DOM APIs react-dom/server APIs let server-side render React components HTML. APIs used server top level app generate initial HTML. framework may call you. components don\u2019t need import use them. Server APIs Node.js Streams methods available environments Node.js Streams: renderToPipeableStream renders React tree pipeable Node.js Stream. Server APIs Web Streams methods available environments Web Streams, includes browsers, Deno, modern edge runtimes: renderToReadableStream renders React tree Readable Web Stream. Legacy Server APIs non-streaming environments methods used environments don\u2019t support streams: renderToString renders React tree string.renderToStaticMarkup renders non-interactive React tree string. limited functionality compared streaming APIs."},
{"source": "https://react.dev/reference/react-dom/server/renderToNodeStream", "title": "renderToNodeStream \u2013 React", "text": "renderToNodeStream renderToNodeStream renders React tree Node.js Readable Stream. const stream = renderToNodeStream(reactNode, options?) Reference renderToNodeStream(reactNode, options?) server, call renderToNodeStream get Node.js Readable Stream pipe response. import { renderToNodeStream } 'react-dom/server'; const stream = renderToNodeStream(<App />); stream.pipe(response); client, call hydrateRoot make server-generated HTML interactive. Parameters - reactNode : React node want render HTML. example, JSX element like<App /> . - optional options : object server render.- optional identifierPrefix : string prefix React uses IDs generated byuseId . Useful avoid conflicts using multiple roots page. Must prefix passed tohydrateRoot . - optional Returns Node.js Readable Stream outputs HTML string. Caveats - method wait Suspense boundaries complete returning output. - React 18, method buffers output, doesn\u2019t actually provide streaming benefits. it\u2019s recommended migrate renderToPipeableStream instead. - returned stream byte stream encoded utf-8. need stream another encoding, take look project like iconv-lite, provides transform streams transcoding text. Usage Rendering React tree HTML Node.js Readable Stream Call renderToNodeStream get Node.js Readable Stream pipe server response: import { renderToNodeStream } 'react-dom/server'; // route handler syntax depends backend framework app.use('/', (request, response) => { const stream = renderToNodeStream(<App />); stream.pipe(response); }); stream produce initial non-interactive HTML output React components. client, need call hydrateRoot hydrate server-generated HTML make interactive."},
{"source": "https://react.dev/reference/react-dom/server/renderToPipeableStream", "title": "renderToPipeableStream \u2013 React", "text": "renderToPipeableStream renderToPipeableStream renders React tree pipeable Node.js Stream. const { pipe, abort } = renderToPipeableStream(reactNode, options?) - Reference - Usage - Rendering React tree HTML Node.js Stream - Streaming content loads - Specifying goes shell - Logging crashes server - Recovering errors inside shell - Recovering errors outside shell - Setting status code - Handling different errors different ways - Waiting content load crawlers static generation - Aborting server rendering Reference renderToPipeableStream(reactNode, options?) Call renderToPipeableStream render React tree HTML Node.js Stream. import { renderToPipeableStream } 'react-dom/server'; const { pipe } = renderToPipeableStream(<App />, { bootstrapScripts: ['/main.js'], onShellReady() { response.setHeader('content-type', 'text/html'); pipe(response); } }); client, call hydrateRoot make server-generated HTML interactive. Parameters - reactNode : React node want render HTML. example, JSX element like<App /> . expected represent entire document, theApp component render the<html> tag. - optional options : object streaming options.- optional bootstrapScriptContent : specified, string placed inline<script> tag. - optional bootstrapScripts : array string URLs the<script> tags emit page. Use include the<script> callshydrateRoot . Omit don\u2019t want run React client all. - optional bootstrapModules : LikebootstrapScripts , emits<script type=\"module\"> instead. - optional identifierPrefix : string prefix React uses IDs generated byuseId . Useful avoid conflicts using multiple roots page. Must prefix passed tohydrateRoot . - optional namespaceURI : string root namespace URI stream. Defaults regular HTML. Pass'http://www.w3.org/2000/svg' SVG or'http://www.w3.org/1998/Math/MathML' MathML. - optional nonce : Anonce string allow scripts forscript-src Content-Security-Policy. - optional onAllReady : callback fires rendering complete, including shell additional content. use instead ofonShellReady crawlers static generation. start streaming here, won\u2019t get progressive loading. stream contain final HTML. - optional onError : callback fires whenever server error, whether recoverable not. default, callsconsole.error . override log crash reports, make sure still callconsole.error . also use adjust status code shell emitted. - optional onShellReady : callback fires right initial shell rendered. set status code callpipe start streaming. React stream additional content shell along inline<script> tags replace HTML loading fallbacks content. - optional onShellError : callback fires error rendering initial shell. receives error argument. bytes emitted stream yet, neitheronShellReady noronAllReady get called, output fallback HTML shell. - optional progressiveChunkSize : number bytes chunk. Read default heuristic. - optional Returns renderToPipeableStream returns object two methods: pipe outputs HTML provided Writable Node.js Stream. Callpipe inonShellReady want enable streaming, inonAllReady crawlers static generation.abort lets abort server rendering render rest client. Usage Rendering React tree HTML Node.js Stream Call renderToPipeableStream render React tree HTML Node.js Stream: import { renderToPipeableStream } 'react-dom/server'; // route handler syntax depends backend framework app.use('/', (request, response) => { const { pipe } = renderToPipeableStream(<App />, { bootstrapScripts: ['/main.js'], onShellReady() { response.setHeader('content-type', 'text/html'); pipe(response); } }); }); Along root component, need provide list bootstrap <script> paths. root component return entire document including root <html> tag. example, might look like this: export default function App() { return ( <html> <head> <meta charSet=\"utf-8\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> <link rel=\"stylesheet\" href=\"/styles.css\"></link> <title>My app</title> </head> <body> <Router /> </body> </html> ); } React inject doctype bootstrap <script> tags resulting HTML stream: <!DOCTYPE html> <html> <!-- ... HTML components ... --> </html> <script src=\"/main.js\" async=\"\"></script> client, bootstrap script hydrate entire document call hydrateRoot : import { hydrateRoot } 'react-dom/client'; import App './App.js'; hydrateRoot(document, <App />); attach event listeners server-generated HTML make interactive. Deep Dive final asset URLs (like JavaScript CSS files) often hashed build. example, instead styles.css might end styles.123456.css . Hashing static asset filenames guarantees every distinct build asset different filename. useful lets safely enable long-term caching static assets: file certain name would never change content. However, don\u2019t know asset URLs build, there\u2019s way put source code. example, hardcoding \"/styles.css\" JSX like earlier wouldn\u2019t work. keep source code, root component read real filenames map passed prop: export default function App({ assetMap }) { return ( <html> <head> ... <link rel=\"stylesheet\" href={assetMap['styles.css']}></link> ... </head> ... </html> ); } server, render <App assetMap={assetMap} /> pass assetMap asset URLs: // need get JSON build tooling, e.g. read build output. const assetMap = { 'styles.css': '/styles.123456.css', 'main.js': '/main.123456.js' }; app.use('/', (request, response) => { const { pipe } = renderToPipeableStream(<App assetMap={assetMap} />, { bootstrapScripts: [assetMap['main.js']], onShellReady() { response.setHeader('content-type', 'text/html'); pipe(response); } }); }); Since server rendering <App assetMap={assetMap} /> , need render assetMap client avoid hydration errors. serialize pass assetMap client like this: // need get JSON build tooling. const assetMap = { 'styles.css': '/styles.123456.css', 'main.js': '/main.123456.js' }; app.use('/', (request, response) => { const { pipe } = renderToPipeableStream(<App assetMap={assetMap} />, { // Careful: safe stringify() data user-generated. bootstrapScriptContent: `window.assetMap = ${JSON.stringify(assetMap)};`, bootstrapScripts: [assetMap['main.js']], onShellReady() { response.setHeader('content-type', 'text/html'); pipe(response); } }); }); example above, bootstrapScriptContent option adds extra inline <script> tag sets global window.assetMap variable client. lets client code read assetMap : import { hydrateRoot } 'react-dom/client'; import App './App.js'; hydrateRoot(document, <App assetMap={window.assetMap} />); client server render App assetMap prop, hydration errors. Streaming content loads Streaming allows user start seeing content even data loaded server. example, consider profile page shows cover, sidebar friends photos, list posts: function ProfilePage() { return ( <ProfileLayout> <ProfileCover /> <Sidebar> <Friends /> <Photos /> </Sidebar> <Posts /> </ProfileLayout> ); } Imagine loading data <Posts /> takes time. Ideally, you\u2019d want show rest profile page content user without waiting posts. this, wrap Posts <Suspense> boundary: function ProfilePage() { return ( <ProfileLayout> <ProfileCover /> <Sidebar> <Friends /> <Photos /> </Sidebar> <Suspense fallback={<PostsGlimmer />}> <Posts /> </Suspense> </ProfileLayout> ); } tells React start streaming HTML Posts loads data. React send HTML loading fallback (PostsGlimmer ) first, then, Posts finishes loading data, React send remaining HTML along inline <script> tag replaces loading fallback HTML. user\u2019s perspective, page first appear PostsGlimmer , later replaced Posts . nest <Suspense> boundaries create granular loading sequence: function ProfilePage() { return ( <ProfileLayout> <ProfileCover /> <Suspense fallback={<BigSpinner />}> <Sidebar> <Friends /> <Photos /> </Sidebar> <Suspense fallback={<PostsGlimmer />}> <Posts /> </Suspense> </Suspense> </ProfileLayout> ); } example, React start streaming page even earlier. ProfileLayout ProfileCover must finish rendering first wrapped <Suspense> boundary. However, Sidebar , Friends , Photos need load data, React send HTML BigSpinner fallback instead. Then, data becomes available, content continue revealed becomes visible. Streaming need wait React load browser, app become interactive. HTML content server get progressively revealed <script> tags load. Read streaming HTML works. Specifying goes shell part app outside <Suspense> boundaries called shell: function ProfilePage() { return ( <ProfileLayout> <ProfileCover /> <Suspense fallback={<BigSpinner />}> <Sidebar> <Friends /> <Photos /> </Sidebar> <Suspense fallback={<PostsGlimmer />}> <Posts /> </Suspense> </Suspense> </ProfileLayout> ); } determines earliest loading state user may see: <ProfileLayout> <ProfileCover /> <BigSpinner /> </ProfileLayout> wrap whole app <Suspense> boundary root, shell contain spinner. However, that\u2019s pleasant user experience seeing big spinner screen feel slower annoying waiting bit seeing real layout. usually you\u2019ll want place <Suspense> boundaries shell feels minimal complete\u2014like skeleton entire page layout. onShellReady callback fires entire shell rendered. Usually, you\u2019ll start streaming then: const { pipe } = renderToPipeableStream(<App />, { bootstrapScripts: ['/main.js'], onShellReady() { response.setHeader('content-type', 'text/html'); pipe(response); } }); time onShellReady fires, components nested <Suspense> boundaries might still loading data. Logging crashes server default, errors server logged console. override behavior log crash reports: const { pipe } = renderToPipeableStream(<App />, { bootstrapScripts: ['/main.js'], onShellReady() { response.setHeader('content-type', 'text/html'); pipe(response); }, onError(error) { console.error(error); logServerCrashReport(error); } }); provide custom onError implementation, don\u2019t forget also log errors console like above. Recovering errors inside shell example, shell contains ProfileLayout , ProfileCover , PostsGlimmer : function ProfilePage() { return ( <ProfileLayout> <ProfileCover /> <Suspense fallback={<PostsGlimmer />}> <Posts /> </Suspense> </ProfileLayout> ); } error occurs rendering components, React won\u2019t meaningful HTML send client. Override onShellError send fallback HTML doesn\u2019t rely server rendering last resort: const { pipe } = renderToPipeableStream(<App />, { bootstrapScripts: ['/main.js'], onShellReady() { response.setHeader('content-type', 'text/html'); pipe(response); }, onShellError(error) { response.statusCode = 500; response.setHeader('content-type', 'text/html'); response.send('<h1>Something went wrong</h1>'); }, onError(error) { console.error(error); logServerCrashReport(error); } }); error generating shell, onError onShellError fire. Use onError error reporting use onShellError send fallback HTML document. fallback HTML error page. Instead, may include alternative shell renders app client only. Recovering errors outside shell example, <Posts /> component wrapped <Suspense> part shell: function ProfilePage() { return ( <ProfileLayout> <ProfileCover /> <Suspense fallback={<PostsGlimmer />}> <Posts /> </Suspense> </ProfileLayout> ); } error happens Posts component somewhere inside it, React try recover it: - emit loading fallback closest <Suspense> boundary (PostsGlimmer ) HTML. - \u201cgive up\u201d trying render Posts content server anymore. - JavaScript code loads client, React retry rendering Posts client. retrying rendering Posts client also fails, React throw error client. errors thrown rendering, closest parent error boundary determines present error user. practice, means user see loading indicator certain error recoverable. retrying rendering Posts client succeeds, loading fallback server replaced client rendering output. user know server error. However, server onError callback client onRecoverableError callbacks fire get notified error. Setting status code Streaming introduces tradeoff. want start streaming page early possible user see content sooner. However, start streaming, longer set response status code. dividing app shell (above <Suspense> boundaries) rest content, you\u2019ve already solved part problem. shell errors, you\u2019ll get onShellError callback lets set error status code. Otherwise, know app may recover client, send \u201cOK\u201d. const { pipe } = renderToPipeableStream(<App />, { bootstrapScripts: ['/main.js'], onShellReady() { response.statusCode = 200; response.setHeader('content-type', 'text/html'); pipe(response); }, onShellError(error) { response.statusCode = 500; response.setHeader('content-type', 'text/html'); response.send('<h1>Something went wrong</h1>'); }, onError(error) { console.error(error); logServerCrashReport(error); } }); component outside shell (i.e. inside <Suspense> boundary) throws error, React stop rendering. means onError callback fire, still get onShellReady instead onShellError . React try recover error client, described above. However, you\u2019d like, use fact something errored set status code: let didError = false; const { pipe } = renderToPipeableStream(<App />, { bootstrapScripts: ['/main.js'], onShellReady() { response.statusCode = didError ? 500 : 200; response.setHeader('content-type', 'text/html'); pipe(response); }, onShellError(error) { response.statusCode = 500; response.setHeader('content-type', 'text/html'); response.send('<h1>Something went wrong</h1>'); }, onError(error) { didError = true; console.error(error); logServerCrashReport(error); } }); catch errors outside shell happened generating initial shell content, it\u2019s exhaustive. knowing whether error occurred content critical, move shell. Handling different errors different ways create Error subclasses use instanceof operator check error thrown. example, define custom NotFoundError throw component. onError , onShellReady , onShellError callbacks something different depending error type: let didError = false; let caughtError = null; function getStatusCode() { (didError) { (caughtError instanceof NotFoundError) { return 404; } else { return 500; } } else { return 200; } } const { pipe } = renderToPipeableStream(<App />, { bootstrapScripts: ['/main.js'], onShellReady() { response.statusCode = getStatusCode(); response.setHeader('content-type', 'text/html'); pipe(response); }, onShellError(error) { response.statusCode = getStatusCode(); response.setHeader('content-type', 'text/html'); response.send('<h1>Something went wrong</h1>'); }, onError(error) { didError = true; caughtError = error; console.error(error); logServerCrashReport(error); } }); Keep mind emit shell start streaming, can\u2019t change status code. Waiting content load crawlers static generation Streaming offers better user experience user see content becomes available. However, crawler visits page, you\u2019re generating pages build time, might want let content load first produce final HTML output instead revealing progressively. wait content load using onAllReady callback: let didError = false; let isCrawler = // ... depends bot detection strategy ... const { pipe } = renderToPipeableStream(<App />, { bootstrapScripts: ['/main.js'], onShellReady() { (!isCrawler) { response.statusCode = didError ? 500 : 200; response.setHeader('content-type', 'text/html'); pipe(response); } }, onShellError(error) { response.statusCode = 500; response.setHeader('content-type', 'text/html'); response.send('<h1>Something went wrong</h1>'); }, onAllReady() { (isCrawler) { response.statusCode = didError ? 500 : 200; response.setHeader('content-type', 'text/html'); pipe(response); } }, onError(error) { didError = true; console.error(error); logServerCrashReport(error); } }); regular visitor get stream progressively loaded content. crawler receive final HTML output data loads. However, also means crawler wait data, might slow load error. Depending app, could choose send shell crawlers too. Aborting server rendering force server rendering \u201cgive up\u201d timeout: const { pipe, abort } = renderToPipeableStream(<App />, { // ... }); setTimeout(() => { abort(); }, 10000); React flush remaining loading fallbacks HTML, attempt render rest client."},
{"source": "https://react.dev/reference/react-dom/server/renderToReadableStream", "title": "renderToReadableStream \u2013 React", "text": "renderToReadableStream renderToReadableStream renders React tree Readable Web Stream. const stream = await renderToReadableStream(reactNode, options?) - Reference - Usage - Rendering React tree HTML Readable Web Stream - Streaming content loads - Specifying goes shell - Logging crashes server - Recovering errors inside shell - Recovering errors outside shell - Setting status code - Handling different errors different ways - Waiting content load crawlers static generation - Aborting server rendering Reference renderToReadableStream(reactNode, options?) Call renderToReadableStream render React tree HTML Readable Web Stream. import { renderToReadableStream } 'react-dom/server'; async function handler(request) { const stream = await renderToReadableStream(<App />, { bootstrapScripts: ['/main.js'] }); return new Response(stream, { headers: { 'content-type': 'text/html' }, }); } client, call hydrateRoot make server-generated HTML interactive. Parameters - reactNode : React node want render HTML. example, JSX element like<App /> . expected represent entire document, theApp component render the<html> tag. - optional options : object streaming options.- optional bootstrapScriptContent : specified, string placed inline<script> tag. - optional bootstrapScripts : array string URLs the<script> tags emit page. Use include the<script> callshydrateRoot . Omit don\u2019t want run React client all. - optional bootstrapModules : LikebootstrapScripts , emits<script type=\"module\"> instead. - optional identifierPrefix : string prefix React uses IDs generated byuseId . Useful avoid conflicts using multiple roots page. Must prefix passed tohydrateRoot . - optional namespaceURI : string root namespace URI stream. Defaults regular HTML. Pass'http://www.w3.org/2000/svg' SVG or'http://www.w3.org/1998/Math/MathML' MathML. - optional nonce : Anonce string allow scripts forscript-src Content-Security-Policy. - optional onError : callback fires whenever server error, whether recoverable not. default, callsconsole.error . override log crash reports, make sure still callconsole.error . also use adjust status code shell emitted. - optional progressiveChunkSize : number bytes chunk. Read default heuristic. - optional signal : abort signal lets abort server rendering render rest client. - optional Returns renderToReadableStream returns Promise: - rendering shell successful, Promise resolve Readable Web Stream. - rendering shell fails, Promise rejected. Use output fallback shell. returned stream additional property: allReady : Promise resolves rendering complete, including shell additional content. canawait stream.allReady returning response crawlers static generation. that, won\u2019t get progressive loading. stream contain final HTML. Usage Rendering React tree HTML Readable Web Stream Call renderToReadableStream render React tree HTML Readable Web Stream: import { renderToReadableStream } 'react-dom/server'; async function handler(request) { const stream = await renderToReadableStream(<App />, { bootstrapScripts: ['/main.js'] }); return new Response(stream, { headers: { 'content-type': 'text/html' }, }); } Along root component, need provide list bootstrap <script> paths. root component return entire document including root <html> tag. example, might look like this: export default function App() { return ( <html> <head> <meta charSet=\"utf-8\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> <link rel=\"stylesheet\" href=\"/styles.css\"></link> <title>My app</title> </head> <body> <Router /> </body> </html> ); } React inject doctype bootstrap <script> tags resulting HTML stream: <!DOCTYPE html> <html> <!-- ... HTML components ... --> </html> <script src=\"/main.js\" async=\"\"></script> client, bootstrap script hydrate entire document call hydrateRoot : import { hydrateRoot } 'react-dom/client'; import App './App.js'; hydrateRoot(document, <App />); attach event listeners server-generated HTML make interactive. Deep Dive final asset URLs (like JavaScript CSS files) often hashed build. example, instead styles.css might end styles.123456.css . Hashing static asset filenames guarantees every distinct build asset different filename. useful lets safely enable long-term caching static assets: file certain name would never change content. However, don\u2019t know asset URLs build, there\u2019s way put source code. example, hardcoding \"/styles.css\" JSX like earlier wouldn\u2019t work. keep source code, root component read real filenames map passed prop: export default function App({ assetMap }) { return ( <html> <head> <title>My app</title> <link rel=\"stylesheet\" href={assetMap['styles.css']}></link> </head> ... </html> ); } server, render <App assetMap={assetMap} /> pass assetMap asset URLs: // need get JSON build tooling, e.g. read build output. const assetMap = { 'styles.css': '/styles.123456.css', 'main.js': '/main.123456.js' }; async function handler(request) { const stream = await renderToReadableStream(<App assetMap={assetMap} />, { bootstrapScripts: [assetMap['/main.js']] }); return new Response(stream, { headers: { 'content-type': 'text/html' }, }); } Since server rendering <App assetMap={assetMap} /> , need render assetMap client avoid hydration errors. serialize pass assetMap client like this: // need get JSON build tooling. const assetMap = { 'styles.css': '/styles.123456.css', 'main.js': '/main.123456.js' }; async function handler(request) { const stream = await renderToReadableStream(<App assetMap={assetMap} />, { // Careful: safe stringify() data user-generated. bootstrapScriptContent: `window.assetMap = ${JSON.stringify(assetMap)};`, bootstrapScripts: [assetMap['/main.js']], }); return new Response(stream, { headers: { 'content-type': 'text/html' }, }); } example above, bootstrapScriptContent option adds extra inline <script> tag sets global window.assetMap variable client. lets client code read assetMap : import { hydrateRoot } 'react-dom/client'; import App './App.js'; hydrateRoot(document, <App assetMap={window.assetMap} />); client server render App assetMap prop, hydration errors. Streaming content loads Streaming allows user start seeing content even data loaded server. example, consider profile page shows cover, sidebar friends photos, list posts: function ProfilePage() { return ( <ProfileLayout> <ProfileCover /> <Sidebar> <Friends /> <Photos /> </Sidebar> <Posts /> </ProfileLayout> ); } Imagine loading data <Posts /> takes time. Ideally, you\u2019d want show rest profile page content user without waiting posts. this, wrap Posts <Suspense> boundary: function ProfilePage() { return ( <ProfileLayout> <ProfileCover /> <Sidebar> <Friends /> <Photos /> </Sidebar> <Suspense fallback={<PostsGlimmer />}> <Posts /> </Suspense> </ProfileLayout> ); } tells React start streaming HTML Posts loads data. React send HTML loading fallback (PostsGlimmer ) first, then, Posts finishes loading data, React send remaining HTML along inline <script> tag replaces loading fallback HTML. user\u2019s perspective, page first appear PostsGlimmer , later replaced Posts . nest <Suspense> boundaries create granular loading sequence: function ProfilePage() { return ( <ProfileLayout> <ProfileCover /> <Suspense fallback={<BigSpinner />}> <Sidebar> <Friends /> <Photos /> </Sidebar> <Suspense fallback={<PostsGlimmer />}> <Posts /> </Suspense> </Suspense> </ProfileLayout> ); } example, React start streaming page even earlier. ProfileLayout ProfileCover must finish rendering first wrapped <Suspense> boundary. However, Sidebar , Friends , Photos need load data, React send HTML BigSpinner fallback instead. Then, data becomes available, content continue revealed becomes visible. Streaming need wait React load browser, app become interactive. HTML content server get progressively revealed <script> tags load. Read streaming HTML works. Specifying goes shell part app outside <Suspense> boundaries called shell: function ProfilePage() { return ( <ProfileLayout> <ProfileCover /> <Suspense fallback={<BigSpinner />}> <Sidebar> <Friends /> <Photos /> </Sidebar> <Suspense fallback={<PostsGlimmer />}> <Posts /> </Suspense> </Suspense> </ProfileLayout> ); } determines earliest loading state user may see: <ProfileLayout> <ProfileCover /> <BigSpinner /> </ProfileLayout> wrap whole app <Suspense> boundary root, shell contain spinner. However, that\u2019s pleasant user experience seeing big spinner screen feel slower annoying waiting bit seeing real layout. usually you\u2019ll want place <Suspense> boundaries shell feels minimal complete\u2014like skeleton entire page layout. async call renderToReadableStream resolve stream soon entire shell rendered. Usually, you\u2019ll start streaming creating returning response stream : async function handler(request) { const stream = await renderToReadableStream(<App />, { bootstrapScripts: ['/main.js'] }); return new Response(stream, { headers: { 'content-type': 'text/html' }, }); } time stream returned, components nested <Suspense> boundaries might still loading data. Logging crashes server default, errors server logged console. override behavior log crash reports: async function handler(request) { const stream = await renderToReadableStream(<App />, { bootstrapScripts: ['/main.js'], onError(error) { console.error(error); logServerCrashReport(error); } }); return new Response(stream, { headers: { 'content-type': 'text/html' }, }); } provide custom onError implementation, don\u2019t forget also log errors console like above. Recovering errors inside shell example, shell contains ProfileLayout , ProfileCover , PostsGlimmer : function ProfilePage() { return ( <ProfileLayout> <ProfileCover /> <Suspense fallback={<PostsGlimmer />}> <Posts /> </Suspense> </ProfileLayout> ); } error occurs rendering components, React won\u2019t meaningful HTML send client. Wrap renderToReadableStream call try...catch send fallback HTML doesn\u2019t rely server rendering last resort: async function handler(request) { try { const stream = await renderToReadableStream(<App />, { bootstrapScripts: ['/main.js'], onError(error) { console.error(error); logServerCrashReport(error); } }); return new Response(stream, { headers: { 'content-type': 'text/html' }, }); } catch (error) { return new Response('<h1>Something went wrong</h1>', { status: 500, headers: { 'content-type': 'text/html' }, }); } } error generating shell, onError catch block fire. Use onError error reporting use catch block send fallback HTML document. fallback HTML error page. Instead, may include alternative shell renders app client only. Recovering errors outside shell example, <Posts /> component wrapped <Suspense> part shell: function ProfilePage() { return ( <ProfileLayout> <ProfileCover /> <Suspense fallback={<PostsGlimmer />}> <Posts /> </Suspense> </ProfileLayout> ); } error happens Posts component somewhere inside it, React try recover it: - emit loading fallback closest <Suspense> boundary (PostsGlimmer ) HTML. - \u201cgive up\u201d trying render Posts content server anymore. - JavaScript code loads client, React retry rendering Posts client. retrying rendering Posts client also fails, React throw error client. errors thrown rendering, closest parent error boundary determines present error user. practice, means user see loading indicator certain error recoverable. retrying rendering Posts client succeeds, loading fallback server replaced client rendering output. user know server error. However, server onError callback client onRecoverableError callbacks fire get notified error. Setting status code Streaming introduces tradeoff. want start streaming page early possible user see content sooner. However, start streaming, longer set response status code. dividing app shell (above <Suspense> boundaries) rest content, you\u2019ve already solved part problem. shell errors, catch block run lets set error status code. Otherwise, know app may recover client, send \u201cOK\u201d. async function handler(request) { try { const stream = await renderToReadableStream(<App />, { bootstrapScripts: ['/main.js'], onError(error) { console.error(error); logServerCrashReport(error); } }); return new Response(stream, { status: 200, headers: { 'content-type': 'text/html' }, }); } catch (error) { return new Response('<h1>Something went wrong</h1>', { status: 500, headers: { 'content-type': 'text/html' }, }); } } component outside shell (i.e. inside <Suspense> boundary) throws error, React stop rendering. means onError callback fire, code continue running without getting catch block. React try recover error client, described above. However, you\u2019d like, use fact something errored set status code: async function handler(request) { try { let didError = false; const stream = await renderToReadableStream(<App />, { bootstrapScripts: ['/main.js'], onError(error) { didError = true; console.error(error); logServerCrashReport(error); } }); return new Response(stream, { status: didError ? 500 : 200, headers: { 'content-type': 'text/html' }, }); } catch (error) { return new Response('<h1>Something went wrong</h1>', { status: 500, headers: { 'content-type': 'text/html' }, }); } } catch errors outside shell happened generating initial shell content, it\u2019s exhaustive. knowing whether error occurred content critical, move shell. Handling different errors different ways create Error subclasses use instanceof operator check error thrown. example, define custom NotFoundError throw component. save error onError something different returning response depending error type: async function handler(request) { let didError = false; let caughtError = null; function getStatusCode() { (didError) { (caughtError instanceof NotFoundError) { return 404; } else { return 500; } } else { return 200; } } try { const stream = await renderToReadableStream(<App />, { bootstrapScripts: ['/main.js'], onError(error) { didError = true; caughtError = error; console.error(error); logServerCrashReport(error); } }); return new Response(stream, { status: getStatusCode(), headers: { 'content-type': 'text/html' }, }); } catch (error) { return new Response('<h1>Something went wrong</h1>', { status: getStatusCode(), headers: { 'content-type': 'text/html' }, }); } } Keep mind emit shell start streaming, can\u2019t change status code. Waiting content load crawlers static generation Streaming offers better user experience user see content becomes available. However, crawler visits page, you\u2019re generating pages build time, might want let content load first produce final HTML output instead revealing progressively. wait content load awaiting stream.allReady Promise: async function handler(request) { try { let didError = false; const stream = await renderToReadableStream(<App />, { bootstrapScripts: ['/main.js'], onError(error) { didError = true; console.error(error); logServerCrashReport(error); } }); let isCrawler = // ... depends bot detection strategy ... (isCrawler) { await stream.allReady; } return new Response(stream, { status: didError ? 500 : 200, headers: { 'content-type': 'text/html' }, }); } catch (error) { return new Response('<h1>Something went wrong</h1>', { status: 500, headers: { 'content-type': 'text/html' }, }); } } regular visitor get stream progressively loaded content. crawler receive final HTML output data loads. However, also means crawler wait data, might slow load error. Depending app, could choose send shell crawlers too. Aborting server rendering force server rendering \u201cgive up\u201d timeout: async function handler(request) { try { const controller = new AbortController(); setTimeout(() => { controller.abort(); }, 10000); const stream = await renderToReadableStream(<App />, { signal: controller.signal, bootstrapScripts: ['/main.js'], onError(error) { didError = true; console.error(error); logServerCrashReport(error); } }); // ... React flush remaining loading fallbacks HTML, attempt render rest client."},
{"source": "https://react.dev/reference/react-dom/server/renderToStaticMarkup", "title": "renderToStaticMarkup \u2013 React", "text": "renderToStaticMarkup renderToStaticMarkup renders non-interactive React tree HTML string. const html = renderToStaticMarkup(reactNode, options?) Reference renderToStaticMarkup(reactNode, options?) server, call renderToStaticMarkup render app HTML. import { renderToStaticMarkup } 'react-dom/server'; const html = renderToStaticMarkup(<Page />); produce non-interactive HTML output React components. Parameters reactNode : React node want render HTML. example, JSX node like<Page /> .- optional options : object server render.- optional identifierPrefix : string prefix React uses IDs generated byuseId . Useful avoid conflicts using multiple roots page. - optional Returns HTML string. Caveats - renderToStaticMarkup output cannot hydrated. - renderToStaticMarkup limited Suspense support. component suspends,renderToStaticMarkup immediately sends fallback HTML. - renderToStaticMarkup works browser, using client code recommended. need render component HTML browser, get HTML rendering DOM node. Usage Rendering non-interactive React tree HTML string Call renderToStaticMarkup render app HTML string send server response: import { renderToStaticMarkup } 'react-dom/server'; // route handler syntax depends backend framework app.use('/', (request, response) => { const html = renderToStaticMarkup(<Page />); response.send(html); }); produce initial non-interactive HTML output React components."},
{"source": "https://react.dev/reference/react-dom/server/renderToStaticNodeStream", "title": "renderToStaticNodeStream \u2013 React", "text": "renderToStaticNodeStream renderToStaticNodeStream renders non-interactive React tree Node.js Readable Stream. const stream = renderToStaticNodeStream(reactNode, options?) Reference renderToStaticNodeStream(reactNode, options?) server, call renderToStaticNodeStream get Node.js Readable Stream. import { renderToStaticNodeStream } 'react-dom/server'; const stream = renderToStaticNodeStream(<Page />); stream.pipe(response); stream produce non-interactive HTML output React components. Parameters - reactNode : React node want render HTML. example, JSX element like<Page /> . - optional options : object server render.- optional identifierPrefix : string prefix React uses IDs generated byuseId . Useful avoid conflicts using multiple roots page. - optional Returns Node.js Readable Stream outputs HTML string. resulting HTML can\u2019t hydrated client. Caveats - renderToStaticNodeStream output cannot hydrated. - method wait Suspense boundaries complete returning output. - React 18, method buffers output, doesn\u2019t actually provide streaming benefits. - returned stream byte stream encoded utf-8. need stream another encoding, take look project like iconv-lite, provides transform streams transcoding text. Usage Rendering React tree static HTML Node.js Readable Stream Call renderToStaticNodeStream get Node.js Readable Stream pipe server response: import { renderToStaticNodeStream } 'react-dom/server'; // route handler syntax depends backend framework app.use('/', (request, response) => { const stream = renderToStaticNodeStream(<Page />); stream.pipe(response); }); stream produce initial non-interactive HTML output React components."},
{"source": "https://react.dev/reference/react-dom/server/renderToString", "title": "renderToString \u2013 React", "text": "renderToString renderToString renders React tree HTML string. const html = renderToString(reactNode, options?) Reference renderToString(reactNode, options?) server, call renderToString render app HTML. import { renderToString } 'react-dom/server'; const html = renderToString(<App />); client, call hydrateRoot make server-generated HTML interactive. Parameters - reactNode : React node want render HTML. example, JSX node like<App /> . - optional options : object server render.- optional identifierPrefix : string prefix React uses IDs generated byuseId . Useful avoid conflicts using multiple roots page. Must prefix passed tohydrateRoot . - optional Returns HTML string. Caveats - renderToString limited Suspense support. component suspends,renderToString immediately sends fallback HTML. - renderToString works browser, using client code recommended. Usage Rendering React tree HTML string Call renderToString render app HTML string send server response: import { renderToString } 'react-dom/server'; // route handler syntax depends backend framework app.use('/', (request, response) => { const html = renderToString(<App />); response.send(html); }); produce initial non-interactive HTML output React components. client, need call hydrateRoot hydrate server-generated HTML make interactive. Alternatives Migrating renderToString streaming render server renderToString returns string immediately, support streaming content loads. possible, recommend using fully-featured alternatives: - use Node.js, use renderToPipeableStream . - use Deno modern edge runtime Web Streams, use renderToReadableStream . continue using renderToString server environment support streams. Migrating renderToString static prerender server renderToString returns string immediately, support waiting data load static HTML generation. recommend using fully-featured alternatives: - use Node.js, use prerenderToNodeStream . - use Deno modern edge runtime Web Streams, use prerender . continue using renderToString static site generation environment support streams. Removing renderToString client code Sometimes, renderToString used client convert component HTML. // \ud83d\udea9 Unnecessary: using renderToString client import { renderToString } 'react-dom/server'; const html = renderToString(<MyIcon />); console.log(html); // example, \"<svg>...</svg>\" Importing react-dom/server client unnecessarily increases bundle size avoided. need render component HTML browser, use createRoot read HTML DOM: import { createRoot } 'react-dom/client'; import { flushSync } 'react-dom'; const div = document.createElement('div'); const root = createRoot(div); flushSync(() => { root.render(<MyIcon />); }); console.log(div.innerHTML); // example, \"<svg>...</svg>\" flushSync call necessary DOM updated reading innerHTML property. Troubleshooting component suspends, HTML always contains fallback renderToString fully support Suspense. component suspends (for example, it\u2019s defined lazy fetches data), renderToString wait content resolve. Instead, renderToString find closest <Suspense> boundary render fallback prop HTML. content appear client code loads. solve this, use one recommended streaming solutions. server side rendering, stream content chunks resolves server user sees page progressively filled client code loads. static site generation, wait content resolve generating static HTML."},
{"source": "https://react.dev/reference/react-dom/static", "title": "Static React DOM APIs \u2013 React", "text": "Static React DOM APIs react-dom/static APIs let generate static HTML React components. limited functionality compared streaming APIs. framework may call you. components don\u2019t need import use them. Static APIs Web Streams methods available environments Web Streams, includes browsers, Deno, modern edge runtimes: prerender renders React tree static HTML Readable Web Stream. Static APIs Node.js Streams methods available environments Node.js Streams: prerenderToNodeStream renders React tree static HTML Node.js Stream."},
{"source": "https://react.dev/reference/react-dom/static/prerender", "title": "prerender \u2013 React", "text": "prerender prerender renders React tree static HTML string using Web Stream. const {prelude} = await prerender(reactNode, options?) Reference prerender(reactNode, options?) Call prerender render app static HTML. import { prerender } 'react-dom/static'; async function handler(request) { const {prelude} = await prerender(<App />, { bootstrapScripts: ['/main.js'] }); return new Response(prelude, { headers: { 'content-type': 'text/html' }, }); } client, call hydrateRoot make server-generated HTML interactive. Parameters - reactNode : React node want render HTML. example, JSX node like<App /> . expected represent entire document, App component render the<html> tag. - optional options : object static generation options.- optional bootstrapScriptContent : specified, string placed inline<script> tag. - optional bootstrapScripts : array string URLs the<script> tags emit page. Use include the<script> callshydrateRoot . Omit don\u2019t want run React client all. - optional bootstrapModules : LikebootstrapScripts , emits<script type=\"module\"> instead. - optional identifierPrefix : string prefix React uses IDs generated byuseId . Useful avoid conflicts using multiple roots page. Must prefix passed tohydrateRoot . - optional namespaceURI : string root namespace URI stream. Defaults regular HTML. Pass'http://www.w3.org/2000/svg' SVG or'http://www.w3.org/1998/Math/MathML' MathML. - optional onError : callback fires whenever server error, whether recoverable not. default, callsconsole.error . override log crash reports, make sure still callconsole.error . also use adjust status code shell emitted. - optional progressiveChunkSize : number bytes chunk. Read default heuristic. - optional signal : abort signal lets abort server rendering render rest client. - optional Returns prerender returns Promise: - rendering successful, Promise resolve object containing: prelude : Web Stream HTML. use stream send response chunks, read entire stream string. - rendering fails, Promise rejected. Use output fallback shell. Usage Rendering React tree stream static HTML Call prerender render React tree static HTML Readable Web Stream:: import { prerender } 'react-dom/static'; async function handler(request) { const {prelude} = await prerender(<App />, { bootstrapScripts: ['/main.js'] }); return new Response(prelude, { headers: { 'content-type': 'text/html' }, }); } Along root component, need provide list bootstrap <script> paths. root component return entire document including root <html> tag. example, might look like this: export default function App() { return ( <html> <head> <meta charSet=\"utf-8\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> <link rel=\"stylesheet\" href=\"/styles.css\"></link> <title>My app</title> </head> <body> <Router /> </body> </html> ); } React inject doctype bootstrap <script> tags resulting HTML stream: <!DOCTYPE html> <html> <!-- ... HTML components ... --> </html> <script src=\"/main.js\" async=\"\"></script> client, bootstrap script hydrate entire document call hydrateRoot : import { hydrateRoot } 'react-dom/client'; import App './App.js'; hydrateRoot(document, <App />); attach event listeners static server-generated HTML make interactive. Deep Dive final asset URLs (like JavaScript CSS files) often hashed build. example, instead styles.css might end styles.123456.css . Hashing static asset filenames guarantees every distinct build asset different filename. useful lets safely enable long-term caching static assets: file certain name would never change content. However, don\u2019t know asset URLs build, there\u2019s way put source code. example, hardcoding \"/styles.css\" JSX like earlier wouldn\u2019t work. keep source code, root component read real filenames map passed prop: export default function App({ assetMap }) { return ( <html> <head> <title>My app</title> <link rel=\"stylesheet\" href={assetMap['styles.css']}></link> </head> ... </html> ); } server, render <App assetMap={assetMap} /> pass assetMap asset URLs: // need get JSON build tooling, e.g. read build output. const assetMap = { 'styles.css': '/styles.123456.css', 'main.js': '/main.123456.js' }; async function handler(request) { const {prelude} = await prerender(<App assetMap={assetMap} />, { bootstrapScripts: [assetMap['/main.js']] }); return new Response(prelude, { headers: { 'content-type': 'text/html' }, }); } Since server rendering <App assetMap={assetMap} /> , need render assetMap client avoid hydration errors. serialize pass assetMap client like this: // need get JSON build tooling. const assetMap = { 'styles.css': '/styles.123456.css', 'main.js': '/main.123456.js' }; async function handler(request) { const {prelude} = await prerender(<App assetMap={assetMap} />, { // Careful: safe stringify() data user-generated. bootstrapScriptContent: `window.assetMap = ${JSON.stringify(assetMap)};`, bootstrapScripts: [assetMap['/main.js']], }); return new Response(prelude, { headers: { 'content-type': 'text/html' }, }); } example above, bootstrapScriptContent option adds extra inline <script> tag sets global window.assetMap variable client. lets client code read assetMap : import { hydrateRoot } 'react-dom/client'; import App './App.js'; hydrateRoot(document, <App assetMap={window.assetMap} />); client server render App assetMap prop, hydration errors. Rendering React tree string static HTML Call prerender render app static HTML string: import { prerender } 'react-dom/static'; async function renderToString() { const {prelude} = await prerender(<App />, { bootstrapScripts: ['/main.js'] }); const reader = stream.getReader(); let content = ''; (true) { const {done, value} = await reader.read(); (done) { return content; } content += Buffer.from(value).toString('utf8'); } } produce initial non-interactive HTML output React components. client, need call hydrateRoot hydrate server-generated HTML make interactive. Waiting data load prerender waits data load finishing static HTML generation resolving. example, consider profile page shows cover, sidebar friends photos, list posts: function ProfilePage() { return ( <ProfileLayout> <ProfileCover /> <Sidebar> <Friends /> <Photos /> </Sidebar> <Suspense fallback={<PostsGlimmer />}> <Posts /> </Suspense> </ProfileLayout> ); } Imagine <Posts /> needs load data, takes time. Ideally, you\u2019d want wait posts finish it\u2019s included HTML. this, use Suspense suspend data, prerender wait suspended content finish resolving static HTML. Troubleshooting stream doesn\u2019t start entire app rendered prerender response waits entire app finish rendering, including waiting suspense boundaries resolve, resolving. designed static site generation (SSG) ahead time support streaming content loads. stream content loads, use streaming server render API like renderToReadableStream."},
{"source": "https://react.dev/reference/react-dom/static/prerenderToNodeStream", "title": "prerenderToNodeStream \u2013 React", "text": "prerenderToNodeStream prerenderToNodeStream renders React tree static HTML string using Node.js Stream.. const {prelude} = await prerenderToNodeStream(reactNode, options?) Reference prerenderToNodeStream(reactNode, options?) Call prerenderToNodeStream render app static HTML. import { prerenderToNodeStream } 'react-dom/static'; // route handler syntax depends backend framework app.use('/', async (request, response) => { const { prelude } = await prerenderToNodeStream(<App />, { bootstrapScripts: ['/main.js'], }); response.setHeader('Content-Type', 'text/plain'); prelude.pipe(response); }); client, call hydrateRoot make server-generated HTML interactive. Parameters - reactNode : React node want render HTML. example, JSX node like<App /> . expected represent entire document, App component render the<html> tag. - optional options : object static generation options.- optional bootstrapScriptContent : specified, string placed inline<script> tag. - optional bootstrapScripts : array string URLs the<script> tags emit page. Use include the<script> callshydrateRoot . Omit don\u2019t want run React client all. - optional bootstrapModules : LikebootstrapScripts , emits<script type=\"module\"> instead. - optional identifierPrefix : string prefix React uses IDs generated byuseId . Useful avoid conflicts using multiple roots page. Must prefix passed tohydrateRoot . - optional namespaceURI : string root namespace URI stream. Defaults regular HTML. Pass'http://www.w3.org/2000/svg' SVG or'http://www.w3.org/1998/Math/MathML' MathML. - optional onError : callback fires whenever server error, whether recoverable not. default, callsconsole.error . override log crash reports, make sure still callconsole.error . also use adjust status code shell emitted. - optional progressiveChunkSize : number bytes chunk. Read default heuristic. - optional signal : abort signal lets abort server rendering render rest client. - optional Returns prerenderToNodeStream returns Promise: - rendering successful, Promise resolve object containing: prelude : Node.js Stream. HTML. use stream send response chunks, read entire stream string. - rendering fails, Promise rejected. Use output fallback shell. Usage Rendering React tree stream static HTML Call prerenderToNodeStream render React tree static HTML Node.js Stream.: import { prerenderToNodeStream } 'react-dom/static'; // route handler syntax depends backend framework app.use('/', async (request, response) => { const { prelude } = await prerenderToNodeStream(<App />, { bootstrapScripts: ['/main.js'], }); response.setHeader('Content-Type', 'text/plain'); prelude.pipe(response); }); Along root component, need provide list bootstrap <script> paths. root component return entire document including root <html> tag. example, might look like this: export default function App() { return ( <html> <head> <meta charSet=\"utf-8\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> <link rel=\"stylesheet\" href=\"/styles.css\"></link> <title>My app</title> </head> <body> <Router /> </body> </html> ); } React inject doctype bootstrap <script> tags resulting HTML stream: <!DOCTYPE html> <html> <!-- ... HTML components ... --> </html> <script src=\"/main.js\" async=\"\"></script> client, bootstrap script hydrate entire document call hydrateRoot : import { hydrateRoot } 'react-dom/client'; import App './App.js'; hydrateRoot(document, <App />); attach event listeners static server-generated HTML make interactive. Deep Dive final asset URLs (like JavaScript CSS files) often hashed build. example, instead styles.css might end styles.123456.css . Hashing static asset filenames guarantees every distinct build asset different filename. useful lets safely enable long-term caching static assets: file certain name would never change content. However, don\u2019t know asset URLs build, there\u2019s way put source code. example, hardcoding \"/styles.css\" JSX like earlier wouldn\u2019t work. keep source code, root component read real filenames map passed prop: export default function App({ assetMap }) { return ( <html> <head> <title>My app</title> <link rel=\"stylesheet\" href={assetMap['styles.css']}></link> </head> ... </html> ); } server, render <App assetMap={assetMap} /> pass assetMap asset URLs: // need get JSON build tooling, e.g. read build output. const assetMap = { 'styles.css': '/styles.123456.css', 'main.js': '/main.123456.js' }; app.use('/', async (request, response) => { const { prelude } = await prerenderToNodeStream(<App />, { bootstrapScripts: [assetMap['/main.js']] }); response.setHeader('Content-Type', 'text/html'); prelude.pipe(response); }); Since server rendering <App assetMap={assetMap} /> , need render assetMap client avoid hydration errors. serialize pass assetMap client like this: // need get JSON build tooling. const assetMap = { 'styles.css': '/styles.123456.css', 'main.js': '/main.123456.js' }; app.use('/', async (request, response) => { const { prelude } = await prerenderToNodeStream(<App />, { // Careful: safe stringify() data user-generated. bootstrapScriptContent: `window.assetMap = ${JSON.stringify(assetMap)};`, bootstrapScripts: [assetMap['/main.js']], }); response.setHeader('Content-Type', 'text/html'); prelude.pipe(response); }); example above, bootstrapScriptContent option adds extra inline <script> tag sets global window.assetMap variable client. lets client code read assetMap : import { hydrateRoot } 'react-dom/client'; import App './App.js'; hydrateRoot(document, <App assetMap={window.assetMap} />); client server render App assetMap prop, hydration errors. Rendering React tree string static HTML Call prerenderToNodeStream render app static HTML string: import { prerenderToNodeStream } 'react-dom/static'; async function renderToString() { const {prelude} = await prerenderToNodeStream(<App />, { bootstrapScripts: ['/main.js'] }); return new Promise((resolve, reject) => { let data = ''; prelude.on('data', chunk => { data += chunk; }); prelude.on('end', () => resolve(data)); prelude.on('error', reject); }); } produce initial non-interactive HTML output React components. client, need call hydrateRoot hydrate server-generated HTML make interactive. Waiting data load prerenderToNodeStream waits data load finishing static HTML generation resolving. example, consider profile page shows cover, sidebar friends photos, list posts: function ProfilePage() { return ( <ProfileLayout> <ProfileCover /> <Sidebar> <Friends /> <Photos /> </Sidebar> <Suspense fallback={<PostsGlimmer />}> <Posts /> </Suspense> </ProfileLayout> ); } Imagine <Posts /> needs load data, takes time. Ideally, you\u2019d want wait posts finish it\u2019s included HTML. this, use Suspense suspend data, prerenderToNodeStream wait suspended content finish resolving static HTML. Troubleshooting stream doesn\u2019t start entire app rendered prerenderToNodeStream response waits entire app finish rendering, including waiting suspense boundaries resolve, resolving. designed static site generation (SSG) ahead time support streaming content loads. stream content loads, use streaming server render API like renderToPipeableStream."},
{"source": "https://react.dev/reference/react-dom/unmountComponentAtNode", "title": "unmountComponentAtNode \u2013 React", "text": "unmountComponentAtNode unmountComponentAtNode removes mounted React component DOM. unmountComponentAtNode(domNode) Reference unmountComponentAtNode(domNode) Call unmountComponentAtNode remove mounted React component DOM clean event handlers state. import { unmountComponentAtNode } 'react-dom'; const domNode = document.getElementById('root'); render(<App />, domNode); unmountComponentAtNode(domNode); Parameters domNode : DOM element. React remove mounted React component element. Returns unmountComponentAtNode returns true component unmounted false otherwise. Usage Call unmountComponentAtNode remove mounted React component browser DOM node clean event handlers state. import { render, unmountComponentAtNode } 'react-dom'; import App './App.js'; const rootNode = document.getElementById('root'); render(<App />, rootNode); // ... unmountComponentAtNode(rootNode); Removing React app DOM element Occasionally, may want \u201csprinkle\u201d React existing page, page fully written React. cases, may need \u201cstop\u201d React app, removing UI, state, listeners DOM node rendered to. example, clicking \u201cRender React App\u201d render React app. Click \u201cUnmount React App\u201d destroy it: import './styles.css'; import { render, unmountComponentAtNode } 'react-dom'; import App './App.js'; const domNode = document.getElementById('root'); document.getElementById('render').addEventListener('click', () => { render(<App />, domNode); }); document.getElementById('unmount').addEventListener('click', () => { unmountComponentAtNode(domNode); });"},
{"source": "https://react.dev/reference/react/Children", "title": "Children \u2013 React", "text": "Children Children lets manipulate transform JSX received children prop. const mappedChildren = Children.map(children, child => <div className=\"Row\"> {child} </div> ); Reference Children.count(children) Call Children.count(children) count number children children data structure. import { Children } 'react'; function RowList({ children }) { return ( <> <h1>Total rows: {Children.count(children)}</h1> ... </> ); } Parameters children : value thechildren prop received component. Returns number nodes inside children . Caveats - Empty nodes ( null ,undefined , Booleans), strings, numbers, React elements count individual nodes. Arrays don\u2019t count individual nodes, children do. traversal go deeper React elements: don\u2019t get rendered, children aren\u2019t traversed. Fragments don\u2019t get traversed. Children.forEach(children, fn, thisArg?) Call Children.forEach(children, fn, thisArg?) run code child children data structure. import { Children } 'react'; function SeparatorList({ children }) { const result = []; Children.forEach(children, (child, index) => { result.push(child); result.push(<hr key={index} />); }); // ... Parameters children : value thechildren prop received component.fn : function want run child, similar arrayforEach method callback. called child first argument index second argument. index starts at0 increments call.- optional thisArg : Thethis value thefn function called. omitted, it\u2019sundefined . Returns Children.forEach returns undefined . Caveats - Empty nodes ( null ,undefined , Booleans), strings, numbers, React elements count individual nodes. Arrays don\u2019t count individual nodes, children do. traversal go deeper React elements: don\u2019t get rendered, children aren\u2019t traversed. Fragments don\u2019t get traversed. Children.map(children, fn, thisArg?) Call Children.map(children, fn, thisArg?) map transform child children data structure. import { Children } 'react'; function RowList({ children }) { return ( <div className=\"RowList\"> {Children.map(children, child => <div className=\"Row\"> {child} </div> )} </div> ); } Parameters children : value thechildren prop received component.fn : mapping function, similar arraymap method callback. called child first argument index second argument. index starts at0 increments call. need return React node function. may empty node (null ,undefined , Boolean), string, number, React element, array React nodes.- optional thisArg : Thethis value thefn function called. omitted, it\u2019sundefined . Returns children null undefined , returns value. Otherwise, returns flat array consisting nodes you\u2019ve returned fn function. returned array contain nodes returned except null undefined . Caveats - Empty nodes ( null ,undefined , Booleans), strings, numbers, React elements count individual nodes. Arrays don\u2019t count individual nodes, children do. traversal go deeper React elements: don\u2019t get rendered, children aren\u2019t traversed. Fragments don\u2019t get traversed. - return element array elements keys fn , returned elements\u2019 keys automatically combined key corresponding original item fromchildren . return multiple elements fromfn array, keys need unique locally amongst other. Children.only(children) Call Children.only(children) assert children represent single React element. function Box({ children }) { const element = Children.only(children); // ... Parameters children : value thechildren prop received component. Returns children valid element, returns element. Otherwise, throws error. Caveats - method always throws pass array (such return value Children.map ) aschildren . words, enforces thatchildren single React element, it\u2019s array single element. Children.toArray(children) Call Children.toArray(children) create array children data structure. import { Children } 'react'; export default function ReversedList({ children }) { const result = Children.toArray(children); result.reverse(); // ... Parameters children : value thechildren prop received component. Returns Returns flat array elements children . Caveats - Empty nodes ( null ,undefined , Booleans) omitted returned array. returned elements\u2019 keys calculated original elements\u2019 keys level nesting position. ensures flattening array introduce changes behavior. Usage Transforming children transform children JSX component receives children prop, call Children.map : import { Children } 'react'; function RowList({ children }) { return ( <div className=\"RowList\"> {Children.map(children, child => <div className=\"Row\"> {child} </div> )} </div> ); } example above, RowList wraps every child receives <div className=\"Row\"> container. example, let\u2019s say parent component passes three <p> tags children prop RowList : <RowList> <p>This first item.</p> <p>This second item.</p> <p>This third item.</p> </RowList> Then, RowList implementation above, final rendered result look like this: <div className=\"RowList\"> <div className=\"Row\"> <p>This first item.</p> </div> <div className=\"Row\"> <p>This second item.</p> </div> <div className=\"Row\"> <p>This third item.</p> </div> </div> Children.map similar transforming arrays map() . difference children data structure considered opaque. means even it\u2019s sometimes array, assume it\u2019s array particular data type. use Children.map need transform it. import { Children } 'react'; export default function RowList({ children }) { return ( <div className=\"RowList\"> {Children.map(children, child => <div className=\"Row\"> {child} </div> )} </div> ); } Deep Dive React, children prop considered opaque data structure. means shouldn\u2019t rely structured. transform, filter, count children, use Children methods. practice, children data structure often represented array internally. However, single child, React won\u2019t create extra array since would lead unnecessary memory overhead. long use Children methods instead directly introspecting children prop, code break even React changes data structure actually implemented. Even children array, Children.map useful special behavior. example, Children.map combines keys returned elements keys children you\u2019ve passed it. ensures original JSX children don\u2019t \u201close\u201d keys even get wrapped like example above. Running code child Call Children.forEach iterate child children data structure. return value similar array forEach method. use run custom logic like constructing array. import { Children } 'react'; export default function SeparatorList({ children }) { const result = []; Children.forEach(children, (child, index) => { result.push(child); result.push(<hr key={index} />); }); result.pop(); // Remove last separator return result; } import { Children } 'react'; export default function RowList({ children }) { return ( <div className=\"RowList\"> <h1 className=\"RowListHeader\"> Total rows: {Children.count(children)} </h1> {Children.map(children, child => <div className=\"Row\"> {child} </div> )} </div> ); } Converting children array Call Children.toArray(children) turn children data structure regular JavaScript array. lets manipulate array built-in array methods like filter , sort , reverse . import { Children } 'react'; export default function ReversedList({ children }) { const result = Children.toArray(children); result.reverse(); return result; } Alternatives Exposing multiple components Manipulating children Children methods often leads fragile code. pass children component JSX, don\u2019t usually expect component manipulate transform individual children. can, try avoid using Children methods. example, want every child RowList wrapped <div className=\"Row\"> , export Row component, manually wrap every row like this: import { RowList, Row } './RowList.js'; export default function App() { return ( <RowList> <Row> <p>This first item.</p> </Row> <Row> <p>This second item.</p> </Row> <Row> <p>This third item.</p> </Row> </RowList> ); } Unlike using Children.map , approach wrap every child automatically. However, approach significant benefit compared earlier example Children.map works even keep extracting components. example, still works extract MoreRows component: import { RowList, Row } './RowList.js'; export default function App() { return ( <RowList> <Row> <p>This first item.</p> </Row> <MoreRows /> </RowList> ); } function MoreRows() { return ( <> <Row> <p>This second item.</p> </Row> <Row> <p>This third item.</p> </Row> </> ); } wouldn\u2019t work Children.map would \u201csee\u201d <MoreRows /> single child (and single row). Accepting array objects prop also explicitly pass array prop. example, RowList accepts rows array prop: import { RowList, Row } './RowList.js'; export default function App() { return ( <RowList rows={[ { id: 'first', content: <p>This first item.</p> }, { id: 'second', content: <p>This second item.</p> }, { id: 'third', content: <p>This third item.</p> } ]} /> ); } Since rows regular JavaScript array, RowList component use built-in array methods like map it. pattern especially useful want able pass information structured data together children. example, TabSwitcher component receives array objects tabs prop: import TabSwitcher './TabSwitcher.js'; export default function App() { return ( <TabSwitcher tabs={[ { id: 'first', header: 'First', content: <p>This first item.</p> }, { id: 'second', header: 'Second', content: <p>This second item.</p> }, { id: 'third', header: 'Third', content: <p>This third item.</p> } ]} /> ); } Unlike passing children JSX, approach lets associate extra data like header item. working tabs directly, array, need Children methods. Calling render prop customize rendering Instead producing JSX every single item, also pass function returns JSX, call function necessary. example, App component passes renderContent function TabSwitcher component. TabSwitcher component calls renderContent selected tab: import TabSwitcher './TabSwitcher.js'; export default function App() { return ( <TabSwitcher tabIds={['first', 'second', 'third']} getHeader={tabId => { return tabId[0].toUpperCase() + tabId.slice(1); }} renderContent={tabId => { return <p>This {tabId} item.</p>; }} /> ); } prop like renderContent called render prop prop specifies render piece user interface. However, nothing special it: regular prop happens function. Render props functions, pass information them. example, RowList component passes id index row renderRow render prop, uses index highlight even rows: import { RowList, Row } './RowList.js'; export default function App() { return ( <RowList rowIds={['first', 'second', 'third']} renderRow={(id, index) => { return ( <Row isHighlighted={index % 2 === 0}> <p>This {id} item.</p> </Row> ); }} /> ); } another example parent child components cooperate without manipulating children. Troubleshooting pass custom component, Children methods don\u2019t show render result Suppose pass two children RowList like this: <RowList> <p>First item</p> <MoreRows /> </RowList> Children.count(children) inside RowList , get 2 . Even MoreRows renders 10 different items, returns null , Children.count(children) still 2 . RowList \u2019s perspective, \u201csees\u201d JSX received. \u201csee\u201d internals MoreRows component. limitation makes hard extract component. alternatives preferred using Children ."},
{"source": "https://react.dev/reference/react/Component", "title": "Component \u2013 React", "text": "Component Component base class React components defined JavaScript classes. Class components still supported React, don\u2019t recommend using new code. class Greeting extends Component { render() { return <h1>Hello, {this.props.name}!</h1>; } } - Reference Component context props state constructor(props) componentDidCatch(error, info) componentDidMount() componentDidUpdate(prevProps, prevState, snapshot?) componentWillMount() componentWillReceiveProps(nextProps) componentWillUpdate(nextProps, nextState) componentWillUnmount() forceUpdate(callback?) getSnapshotBeforeUpdate(prevProps, prevState) render() setState(nextState, callback?) shouldComponentUpdate(nextProps, nextState, nextContext) UNSAFE_componentWillMount() UNSAFE_componentWillReceiveProps(nextProps, nextContext) UNSAFE_componentWillUpdate(nextProps, nextState) static contextType static defaultProps static getDerivedStateFromError(error) static getDerivedStateFromProps(props, state) - Usage - Alternatives Reference Component define React component class, extend built-in Component class define render method: import { Component } 'react'; class Greeting extends Component { render() { return <h1>Hello, {this.props.name}!</h1>; } } render method required, methods optional. context context class component available this.context . available specify context want receive using static contextType . class component read one context time. class Button extends Component { static contextType = ThemeContext; render() { const theme = this.context; const className = 'button-' + theme; return ( <button className={className}> {this.props.children} </button> ); } } props props passed class component available this.props . class Greeting extends Component { render() { return <h1>Hello, {this.props.name}!</h1>; } } <Greeting name=\"Taylor\" /> state state class component available this.state . state field must object. mutate state directly. wish change state, call setState new state. class Counter extends Component { state = { age: 42, }; handleAgeChange = () => { this.setState({ age: this.state.age + 1 }); }; render() { return ( <> <button onClick={this.handleAgeChange}> Increment age </button> <p>You {this.state.age}.</p> </> ); } } constructor(props) constructor runs class component mounts (gets added screen). Typically, constructor used two purposes React. lets declare state bind class methods class instance: class Counter extends Component { constructor(props) { super(props); this.state = { counter: 0 }; this.handleClick = this.handleClick.bind(this); } handleClick() { // ... } use modern JavaScript syntax, constructors rarely needed. Instead, rewrite code using public class field syntax supported modern browsers tools like Babel: class Counter extends Component { state = { counter: 0 }; handleClick = () => { // ... } constructor contain side effects subscriptions. Parameters props : component\u2019s initial props. Returns constructor return anything. Caveats - run side effects subscriptions constructor. Instead, use componentDidMount that. - Inside constructor, need call super(props) statement. don\u2019t that,this.props beundefined constructor runs, confusing cause bugs. - Constructor place assign this.state directly. methods, need usethis.setState() instead. callsetState constructor. - use server rendering, constructor run server too, followed render method. However, lifecycle methods likecomponentDidMount orcomponentWillUnmount run server. - Strict Mode on, React call constructor twice development throw away one instances. helps notice accidental side effects need moved theconstructor . componentDidCatch(error, info) define componentDidCatch , React call child component (including distant children) throws error rendering. lets log error error reporting service production. Typically, used together static getDerivedStateFromError lets update state response error display error message user. component methods called error boundary. Parameters - error : error thrown. practice, usually instance ofError guaranteed JavaScript allows tothrow value, including strings evennull . - info : object containing additional information error. ItscomponentStack field contains stack trace component threw, well names source locations parent components. production, component names minified. set production error reporting, decode component stack using sourcemaps way would regular JavaScript error stacks. Returns componentDidCatch return anything. Caveats - past, common call setState insidecomponentDidCatch order update UI display fallback error message. deprecated favor definingstatic getDerivedStateFromError . - Production development builds React slightly differ way componentDidCatch handles errors. development, errors bubble towindow , means anywindow.onerror orwindow.addEventListener('error', callback) intercept errors caught bycomponentDidCatch . production, instead, errors bubble up, means ancestor error handler receive errors explicitly caught bycomponentDidCatch . componentDidMount() define componentDidMount method, React call component added (mounted) screen. common place start data fetching, set subscriptions, manipulate DOM nodes. implement componentDidMount , usually need implement lifecycle methods avoid bugs. example, componentDidMount reads state props, also implement componentDidUpdate handle changes, componentWillUnmount clean whatever componentDidMount doing. class ChatRoom extends Component { state = { serverUrl: 'https://localhost:1234' }; componentDidMount() { this.setupConnection(); } componentDidUpdate(prevProps, prevState) { ( this.props.roomId !== prevProps.roomId || this.state.serverUrl !== prevState.serverUrl ) { this.destroyConnection(); this.setupConnection(); } } componentWillUnmount() { this.destroyConnection(); } // ... } Parameters componentDidMount take parameters. Returns componentDidMount return anything. Caveats - Strict Mode on, development React call componentDidMount , immediately callcomponentWillUnmount , callcomponentDidMount again. helps notice forgot implementcomponentWillUnmount logic doesn\u2019t fully \u201cmirror\u201d whatcomponentDidMount does. - Although may call setState immediately incomponentDidMount , it\u2019s best avoid can. trigger extra rendering, happen browser updates screen. guarantees even though therender called twice case, user won\u2019t see intermediate state. Use pattern caution often causes performance issues. cases, able assign initial state theconstructor instead. can, however, necessary cases like modals tooltips need measure DOM node rendering something depends size position. componentDidUpdate(prevProps, prevState, snapshot?) define componentDidUpdate method, React call immediately component re-rendered updated props state. method called initial render. use manipulate DOM update. also common place network requests long compare current props previous props (e.g. network request may necessary props changed). Typically, you\u2019d use together componentDidMount componentWillUnmount : class ChatRoom extends Component { state = { serverUrl: 'https://localhost:1234' }; componentDidMount() { this.setupConnection(); } componentDidUpdate(prevProps, prevState) { ( this.props.roomId !== prevProps.roomId || this.state.serverUrl !== prevState.serverUrl ) { this.destroyConnection(); this.setupConnection(); } } componentWillUnmount() { this.destroyConnection(); } // ... } Parameters - prevProps : Props update. CompareprevProps tothis.props determine changed. - prevState : State update. CompareprevState tothis.state determine changed. - snapshot : implementedgetSnapshotBeforeUpdate ,snapshot contain value returned method. Otherwise, beundefined . Returns componentDidUpdate return anything. Caveats - componentDidUpdate get called ifshouldComponentUpdate defined returnsfalse . - logic inside componentDidUpdate usually wrapped conditions comparingthis.props withprevProps , andthis.state withprevState . Otherwise, there\u2019s risk creating infinite loops. - Although may call setState immediately incomponentDidUpdate , it\u2019s best avoid can. trigger extra rendering, happen browser updates screen. guarantees even though therender called twice case, user won\u2019t see intermediate state. pattern often causes performance issues, may necessary rare cases like modals tooltips need measure DOM node rendering something depends size position. componentWillMount() componentWillReceiveProps(nextProps) componentWillUpdate(nextProps, nextState) componentWillUnmount() define componentWillUnmount method, React call component removed (unmounted) screen. common place cancel data fetching remove subscriptions. logic inside componentWillUnmount \u201cmirror\u201d logic inside componentDidMount . example, componentDidMount sets subscription, componentWillUnmount clean subscription. cleanup logic componentWillUnmount reads props state, usually also need implement componentDidUpdate clean resources (such subscriptions) corresponding old props state. class ChatRoom extends Component { state = { serverUrl: 'https://localhost:1234' }; componentDidMount() { this.setupConnection(); } componentDidUpdate(prevProps, prevState) { ( this.props.roomId !== prevProps.roomId || this.state.serverUrl !== prevState.serverUrl ) { this.destroyConnection(); this.setupConnection(); } } componentWillUnmount() { this.destroyConnection(); } // ... } Parameters componentWillUnmount take parameters. Returns componentWillUnmount return anything. Caveats - Strict Mode on, development React call componentDidMount , immediately callcomponentWillUnmount , callcomponentDidMount again. helps notice forgot implementcomponentWillUnmount logic doesn\u2019t fully \u201cmirror\u201d whatcomponentDidMount does. forceUpdate(callback?) Forces component re-render. Usually, necessary. component\u2019s render method reads this.props , this.state , this.context , re-render automatically call setState inside component one parents. However, component\u2019s render method reads directly external data source, tell React update user interface data source changes. That\u2019s forceUpdate lets do. Try avoid uses forceUpdate read this.props this.state render . Parameters - optional callback specified, React call thecallback you\u2019ve provided update committed. Returns forceUpdate return anything. Caveats - call forceUpdate , React re-render without callingshouldComponentUpdate . getSnapshotBeforeUpdate(prevProps, prevState) implement getSnapshotBeforeUpdate , React call immediately React updates DOM. enables component capture information DOM (e.g. scroll position) potentially changed. value returned lifecycle method passed parameter componentDidUpdate . example, use UI like chat thread needs preserve scroll position updates: class ScrollingList extends React.Component { constructor(props) { super(props); this.listRef = React.createRef(); } getSnapshotBeforeUpdate(prevProps, prevState) { // adding new items list? // Capture scroll position adjust scroll later. (prevProps.list.length < this.props.list.length) { const list = this.listRef.current; return list.scrollHeight - list.scrollTop; } return null; } componentDidUpdate(prevProps, prevState, snapshot) { // snapshot value, we've added new items. // Adjust scroll new items push old ones view. // (snapshot value returned getSnapshotBeforeUpdate) (snapshot !== null) { const list = this.listRef.current; list.scrollTop = list.scrollHeight - snapshot; } } render() { return ( <div ref={this.listRef}>{/* ...contents... */}</div> ); } } example, important read scrollHeight property directly getSnapshotBeforeUpdate . safe read render , UNSAFE_componentWillReceiveProps , UNSAFE_componentWillUpdate potential time gap methods getting called React updating DOM. Parameters - prevProps : Props update. CompareprevProps tothis.props determine changed. - prevState : State update. CompareprevState tothis.state determine changed. Returns return snapshot value type you\u2019d like, null . value returned passed third argument componentDidUpdate . Caveats getSnapshotBeforeUpdate get called ifshouldComponentUpdate defined returnsfalse . render() render method required method class component. render method specify want appear screen, example: import { Component } 'react'; class Greeting extends Component { render() { return <h1>Hello, {this.props.name}!</h1>; } } React may call render moment, shouldn\u2019t assume runs particular time. Usually, render method return piece JSX, return types (like strings) supported. calculate returned JSX, render method read this.props , this.state , this.context . write render method pure function, meaning return result props, state, context same. also shouldn\u2019t contain side effects (like setting subscriptions) interact browser APIs. Side effects happen either event handlers methods like componentDidMount . Parameters render take parameters. Returns render return valid React node. includes React elements <div /> , strings, numbers, portals, empty nodes (null , undefined , true , false ), arrays React nodes. Caveats - render written pure function props, state, context. side effects. - render get called ifshouldComponentUpdate defined returnsfalse . - Strict Mode on, React call render twice development throw away one results. helps notice accidental side effects need moved therender method. - one-to-one correspondence render call subsequentcomponentDidMount orcomponentDidUpdate call. therender call results may discarded React it\u2019s beneficial. setState(nextState, callback?) Call setState update state React component. class Form extends Component { state = { name: 'Taylor', }; handleNameChange = (e) => { const newName = e.target.value; this.setState({ name: newName }); } render() { return ( <> <input value={this.state.name} onChange={this.handleNameChange} /> <p>Hello, {this.state.name}.</p> </> ); } } setState enqueues changes component state. tells React component children need re-render new state. main way you\u2019ll update user interface response interactions. also pass function setState . lets update state based previous state: handleIncreaseAge = () => { this.setState(prevState => { return { age: prevState.age + 1 }; }); } don\u2019t this, it\u2019s handy want update state multiple times event. Parameters - nextState : Either object function.- pass object nextState , shallowly merged intothis.state . - pass function nextState , treated updater function. must pure, take pending state props arguments, return object shallowly merged intothis.state . React put updater function queue re-render component. next render, React calculate next state applying queued updaters previous state. - pass object - optional callback : specified, React call thecallback you\u2019ve provided update committed. Returns setState return anything. Caveats - Think setState request rather immediate command update component. multiple components update state response event, React batch updates re-render together single pass end event. rare case need force particular state update applied synchronously, may wrap influshSync , may hurt performance. - setState updatethis.state immediately. makes readingthis.state right callingsetState potential pitfall. Instead, usecomponentDidUpdate setStatecallback argument, either guaranteed fire update applied. need set state based previous state, pass function tonextState described above. shouldComponentUpdate(nextProps, nextState, nextContext) define shouldComponentUpdate , React call determine whether re-render skipped. confident want write hand, may compare this.props nextProps this.state nextState return false tell React update skipped. class Rectangle extends Component { state = { isHovered: false }; shouldComponentUpdate(nextProps, nextState) { ( nextProps.position.x === this.props.position.x && nextProps.position.y === this.props.position.y && nextProps.size.width === this.props.size.width && nextProps.size.height === this.props.size.height && nextState.isHovered === this.state.isHovered ) { // Nothing changed, re-render unnecessary return false; } return true; } // ... } React calls shouldComponentUpdate rendering new props state received. Defaults true . method called initial render forceUpdate used. Parameters nextProps : next props component render with. ComparenextProps tothis.props determine changed.nextState : next state component render with. ComparenextState tothis.state determine changed.nextContext : next context component render with. ComparenextContext tothis.context determine changed. available specifystatic contextType . Returns Return true want component re-render. That\u2019s default behavior. Return false tell React re-rendering skipped. Caveats - method exists performance optimization. component breaks without it, fix first. - Consider using PureComponent instead writingshouldComponentUpdate hand.PureComponent shallowly compares props state, reduces chance you\u2019ll skip necessary update. - recommend deep equality checks using JSON.stringify inshouldComponentUpdate . makes performance unpredictable dependent data structure every prop state. best case, risk introducing multi-second stalls application, worst case risk crashing it. - Returning false prevent child components re-rendering state changes. - Returning false guarantee component re-render. React use return value hint may still choose re-render component makes sense reasons. UNSAFE_componentWillMount() define UNSAFE_componentWillMount , React call immediately constructor . exists historical reasons used new code. Instead, use one alternatives: - initialize state, declare state class field setthis.state inside theconstructor . - need run side effect set subscription, move logic componentDidMount instead. See examples migrating away unsafe lifecycles. Parameters UNSAFE_componentWillMount take parameters. Returns UNSAFE_componentWillMount return anything. Caveats - UNSAFE_componentWillMount get called component implementsstatic getDerivedStateFromProps orgetSnapshotBeforeUpdate . - Despite naming, UNSAFE_componentWillMount guarantee component get mounted app uses modern React features likeSuspense . render attempt suspended (for example, code child component loaded yet), React throw in-progress tree away attempt construct component scratch next attempt. method \u201cunsafe\u201d. Code relies mounting (like adding subscription) go intocomponentDidMount . - UNSAFE_componentWillMount lifecycle method runs server rendering. practical purposes, identical toconstructor , use theconstructor type logic instead. UNSAFE_componentWillReceiveProps(nextProps, nextContext) define UNSAFE_componentWillReceiveProps , React call component receives new props. exists historical reasons used new code. Instead, use one alternatives: - need run side effect (for example, fetch data, run animation, reinitialize subscription) response prop changes, move logic componentDidUpdate instead. - need avoid re-computing data prop changes, use memoization helper instead. - need \u201creset\u201d state prop changes, consider either making component fully controlled fully uncontrolled key instead. - need \u201cadjust\u201d state prop changes, check whether compute necessary information props alone rendering. can\u2019t, use static getDerivedStateFromProps instead. See examples migrating away unsafe lifecycles. Parameters nextProps : next props component receive parent component. ComparenextProps tothis.props determine changed.nextContext : next context component receive closest provider. ComparenextContext tothis.context determine changed. available specifystatic contextType . Returns UNSAFE_componentWillReceiveProps return anything. Caveats - UNSAFE_componentWillReceiveProps get called component implementsstatic getDerivedStateFromProps orgetSnapshotBeforeUpdate . - Despite naming, UNSAFE_componentWillReceiveProps guarantee component receive props app uses modern React features likeSuspense . render attempt suspended (for example, code child component loaded yet), React throw in-progress tree away attempt construct component scratch next attempt. time next render attempt, props might different. method \u201cunsafe\u201d. Code run committed updates (like resetting subscription) go intocomponentDidUpdate . - UNSAFE_componentWillReceiveProps mean component received different props last time. need comparenextProps andthis.props check something changed. - React doesn\u2019t call UNSAFE_componentWillReceiveProps initial props mounting. calls method component\u2019s props going updated. example, callingsetState doesn\u2019t generally triggerUNSAFE_componentWillReceiveProps inside component. UNSAFE_componentWillUpdate(nextProps, nextState) define UNSAFE_componentWillUpdate , React call rendering new props state. exists historical reasons used new code. Instead, use one alternatives: - need run side effect (for example, fetch data, run animation, reinitialize subscription) response prop state changes, move logic componentDidUpdate instead. - need read information DOM (for example, save current scroll position) use componentDidUpdate later, read insidegetSnapshotBeforeUpdate instead. See examples migrating away unsafe lifecycles. Parameters nextProps : next props component render with. ComparenextProps tothis.props determine changed.nextState : next state component render with. ComparenextState tothis.state determine changed. Returns UNSAFE_componentWillUpdate return anything. Caveats - UNSAFE_componentWillUpdate get called ifshouldComponentUpdate defined returnsfalse . - UNSAFE_componentWillUpdate get called component implementsstatic getDerivedStateFromProps orgetSnapshotBeforeUpdate . - It\u2019s supported call setState (or method leads tosetState called, like dispatching Redux action) duringcomponentWillUpdate . - Despite naming, UNSAFE_componentWillUpdate guarantee component update app uses modern React features likeSuspense . render attempt suspended (for example, code child component loaded yet), React throw in-progress tree away attempt construct component scratch next attempt. time next render attempt, props state might different. method \u201cunsafe\u201d. Code run committed updates (like resetting subscription) go intocomponentDidUpdate . - UNSAFE_componentWillUpdate mean component received different props state last time. need comparenextProps withthis.props andnextState withthis.state check something changed. - React doesn\u2019t call UNSAFE_componentWillUpdate initial props state mounting. static contextType want read this.context class component, must specify context needs read. context specify static contextType must value previously created createContext . class Button extends Component { static contextType = ThemeContext; render() { const theme = this.context; const className = 'button-' + theme; return ( <button className={className}> {this.props.children} </button> ); } } static defaultProps define static defaultProps set default props class. used undefined missing props, null props. example, define color prop default 'blue' : class Button extends Component { static defaultProps = { color: 'blue' }; render() { return <button className={this.props.color}>click me</button>; } } color prop provided undefined , set default 'blue' : <> {/* this.props.color \"blue\" */} <Button /> {/* this.props.color \"blue\" */} <Button color={undefined} /> {/* this.props.color null */} <Button color={null} /> {/* this.props.color \"red\" */} <Button color=\"red\" /> </> static getDerivedStateFromError(error) define static getDerivedStateFromError , React call child component (including distant children) throws error rendering. lets display error message instead clearing UI. Typically, used together componentDidCatch lets send error report analytics service. component methods called error boundary. Parameters error : error thrown. practice, usually instance ofError guaranteed JavaScript allows tothrow value, including strings evennull . Returns static getDerivedStateFromError return state telling component display error message. Caveats static getDerivedStateFromError pure function. want perform side effect (for example, call analytics service), need also implementcomponentDidCatch . static getDerivedStateFromProps(props, state) define static getDerivedStateFromProps , React call right calling render , initial mount subsequent updates. return object update state, null update nothing. method exists rare use cases state depends changes props time. example, Form component resets email state userID prop changes: class Form extends Component { state = { email: this.props.defaultEmail, prevUserID: this.props.userID }; static getDerivedStateFromProps(props, state) { // time current user changes, // Reset parts state tied user. // simple example, that's email. (props.userID !== state.prevUserID) { return { prevUserID: props.userID, email: props.defaultEmail }; } return null; } // ... } Note pattern requires keep previous value prop (like userID ) state (like prevUserID ). Parameters props : next props component render with.state : next state component render with. Returns static getDerivedStateFromProps return object update state, null update nothing. Caveats - method fired every render, regardless cause. different UNSAFE_componentWillReceiveProps , fires parent causes re-render result localsetState . - method doesn\u2019t access component instance. you\u2019d like, reuse code static getDerivedStateFromProps class methods extracting pure functions component props state outside class definition. Usage Defining class component define React component class, extend built-in Component class define render method: import { Component } 'react'; class Greeting extends Component { render() { return <h1>Hello, {this.props.name}!</h1>; } } React call render method whenever needs figure display screen. Usually, return JSX it. render method pure function: calculate JSX. Similarly function components, class component receive information props parent component. However, syntax reading props different. example, parent component renders <Greeting name=\"Taylor\" /> , read name prop this.props , like this.props.name : import { Component } 'react'; class Greeting extends Component { render() { return <h1>Hello, {this.props.name}!</h1>; } } export default function App() { return ( <> <Greeting name=\"Sara\" /> <Greeting name=\"Cahal\" /> <Greeting name=\"Edite\" /> </> ); } Note Hooks (functions starting use , like useState ) supported inside class components. Adding state class component add state class, assign object property called state . update state, call this.setState . import { Component } 'react'; export default class Counter extends Component { state = { name: 'Taylor', age: 42, }; handleNameChange = (e) => { this.setState({ name: e.target.value }); } handleAgeChange = () => { this.setState({ age: this.state.age + 1 }); }; render() { return ( <> <input value={this.state.name} onChange={this.handleNameChange} /> <button onClick={this.handleAgeChange}> Increment age </button> <p>Hello, {this.state.name}. {this.state.age}.</p> </> ); } } Adding lifecycle methods class component special methods define class. define componentDidMount method, React call component added (mounted) screen. React call componentDidUpdate component re-renders due changed props state. React call componentWillUnmount component removed (unmounted) screen. implement componentDidMount , usually need implement three lifecycles avoid bugs. example, componentDidMount reads state props, also implement componentDidUpdate handle changes, componentWillUnmount clean whatever componentDidMount doing. example, ChatRoom component keeps chat connection synchronized props state: import { Component } 'react'; import { createConnection } './chat.js'; export default class ChatRoom extends Component { state = { serverUrl: 'https://localhost:1234' }; componentDidMount() { this.setupConnection(); } componentDidUpdate(prevProps, prevState) { ( this.props.roomId !== prevProps.roomId || this.state.serverUrl !== prevState.serverUrl ) { this.destroyConnection(); this.setupConnection(); } } componentWillUnmount() { this.destroyConnection(); } setupConnection() { this.connection = createConnection( this.state.serverUrl, this.props.roomId ); this.connection.connect(); } destroyConnection() { this.connection.disconnect(); this.connection = null; } render() { return ( <> <label> Server URL:{' '} <input value={this.state.serverUrl} onChange={e => { this.setState({ serverUrl: e.target.value }); }} /> </label> <h1>Welcome {this.props.roomId} room!</h1> </> ); } } Note development Strict Mode on, React call componentDidMount , immediately call componentWillUnmount , call componentDidMount again. helps notice forgot implement componentWillUnmount logic doesn\u2019t fully \u201cmirror\u201d componentDidMount does. Catching rendering errors error boundary default, application throws error rendering, React remove UI screen. prevent this, wrap part UI error boundary. error boundary special component lets display fallback UI instead part crashed\u2014for example, error message. implement error boundary component, need provide static getDerivedStateFromError lets update state response error display error message user. also optionally implement componentDidCatch add extra logic, example, log error analytics service. class ErrorBoundary extends React.Component { constructor(props) { super(props); this.state = { hasError: false }; } static getDerivedStateFromError(error) { // Update state next render show fallback UI. return { hasError: true }; } componentDidCatch(error, info) { // Example \"componentStack\": // ComponentThatThrows (created App) // ErrorBoundary (created App) // div (created App) // App logErrorToMyService(error, info.componentStack); } render() { (this.state.hasError) { // render custom fallback UI return this.props.fallback; } return this.props.children; } } wrap part component tree it: <ErrorBoundary fallback={<p>Something went wrong</p>}> <Profile /> </ErrorBoundary> Profile child component throws error, ErrorBoundary \u201ccatch\u201d error, display fallback UI error message you\u2019ve provided, send production error report error reporting service. don\u2019t need wrap every component separate error boundary. think granularity error boundaries, consider makes sense display error message. example, messaging app, makes sense place error boundary around list conversations. also makes sense place one around every individual message. However, wouldn\u2019t make sense place boundary around every avatar. Alternatives Migrating simple component class function Typically, define components functions instead. example, suppose you\u2019re converting Greeting class component function: import { Component } 'react'; class Greeting extends Component { render() { return <h1>Hello, {this.props.name}!</h1>; } } export default function App() { return ( <> <Greeting name=\"Sara\" /> <Greeting name=\"Cahal\" /> <Greeting name=\"Edite\" /> </> ); } Define function called Greeting . move body render function. function Greeting() { // ... move code render method ... } Instead this.props.name , define name prop using destructuring syntax read directly: function Greeting({ name }) { return <h1>Hello, {name}!</h1>; } complete example: function Greeting({ name }) { return <h1>Hello, {name}!</h1>; } export default function App() { return ( <> <Greeting name=\"Sara\" /> <Greeting name=\"Cahal\" /> <Greeting name=\"Edite\" /> </> ); } Migrating component state class function Suppose you\u2019re converting Counter class component function: import { Component } 'react'; export default class Counter extends Component { state = { name: 'Taylor', age: 42, }; handleNameChange = (e) => { this.setState({ name: e.target.value }); } handleAgeChange = (e) => { this.setState({ age: this.state.age + 1 }); }; render() { return ( <> <input value={this.state.name} onChange={this.handleNameChange} /> <button onClick={this.handleAgeChange}> Increment age </button> <p>Hello, {this.state.name}. {this.state.age}.</p> </> ); } } Start declaring function necessary state variables: import { useState } 'react'; function Counter() { const [name, setName] = useState('Taylor'); const [age, setAge] = useState(42); // ... Next, convert event handlers: function Counter() { const [name, setName] = useState('Taylor'); const [age, setAge] = useState(42); function handleNameChange(e) { setName(e.target.value); } function handleAgeChange() { setAge(age + 1); } // ... Finally, replace references starting variables functions defined component. example, replace this.state.age age , replace this.handleNameChange handleNameChange . fully converted component: import { useState } 'react'; export default function Counter() { const [name, setName] = useState('Taylor'); const [age, setAge] = useState(42); function handleNameChange(e) { setName(e.target.value); } function handleAgeChange() { setAge(age + 1); } return ( <> <input value={name} onChange={handleNameChange} /> <button onClick={handleAgeChange}> Increment age </button> <p>Hello, {name}. {age}.</p> </> ) } Migrating component lifecycle methods class function Suppose you\u2019re converting ChatRoom class component lifecycle methods function: import { Component } 'react'; import { createConnection } './chat.js'; export default class ChatRoom extends Component { state = { serverUrl: 'https://localhost:1234' }; componentDidMount() { this.setupConnection(); } componentDidUpdate(prevProps, prevState) { ( this.props.roomId !== prevProps.roomId || this.state.serverUrl !== prevState.serverUrl ) { this.destroyConnection(); this.setupConnection(); } } componentWillUnmount() { this.destroyConnection(); } setupConnection() { this.connection = createConnection( this.state.serverUrl, this.props.roomId ); this.connection.connect(); } destroyConnection() { this.connection.disconnect(); this.connection = null; } render() { return ( <> <label> Server URL:{' '} <input value={this.state.serverUrl} onChange={e => { this.setState({ serverUrl: e.target.value }); }} /> </label> <h1>Welcome {this.props.roomId} room!</h1> </> ); } } First, verify componentWillUnmount opposite componentDidMount . example, that\u2019s true: disconnects connection componentDidMount sets up. logic missing, add first. Next, verify componentDidUpdate method handles changes props state you\u2019re using componentDidMount . example, componentDidMount calls setupConnection reads this.state.serverUrl this.props.roomId . componentDidUpdate checks whether this.state.serverUrl this.props.roomId changed, resets connection did. componentDidUpdate logic missing doesn\u2019t handle changes relevant props state, fix first. example, logic inside lifecycle methods connects component system outside React (a chat server). connect component external system, describe logic single Effect: import { useState, useEffect } 'react'; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => { connection.disconnect(); }; }, [serverUrl, roomId]); // ... } useEffect call equivalent logic lifecycle methods above. lifecycle methods multiple unrelated things, split multiple independent Effects. complete example play with: import { useState, useEffect } 'react'; import { createConnection } './chat.js'; export default function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => { connection.disconnect(); }; }, [roomId, serverUrl]); return ( <> <label> Server URL:{' '} <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} /> </label> <h1>Welcome {roomId} room!</h1> </> ); } Migrating component context class function example, Panel Button class components read context this.context : import { createContext, Component } 'react'; const ThemeContext = createContext(null); class Panel extends Component { static contextType = ThemeContext; render() { const theme = this.context; const className = 'panel-' + theme; return ( <section className={className}> <h1>{this.props.title}</h1> {this.props.children} </section> ); } } class Button extends Component { static contextType = ThemeContext; render() { const theme = this.context; const className = 'button-' + theme; return ( <button className={className}> {this.props.children} </button> ); } } function Form() { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> </Panel> ); } export default function MyApp() { return ( <ThemeContext.Provider value=\"dark\"> <Form /> </ThemeContext.Provider> ) } convert function components, replace this.context useContext calls: import { createContext, useContext } 'react'; const ThemeContext = createContext(null); function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> <h1>{title}</h1> {children} </section> ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className}> {children} </button> ); } function Form() { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> </Panel> ); } export default function MyApp() { return ( <ThemeContext.Provider value=\"dark\"> <Form /> </ThemeContext.Provider> ) }"},
{"source": "https://react.dev/reference/react/Fragment", "title": "<Fragment> (<>...</>) \u2013 React", "text": "<Fragment> (<>...</>) <Fragment> , often used via <>...</> syntax, lets group elements without wrapper node. <> <OneChild /> <AnotherChild /> </> Reference <Fragment> Wrap elements <Fragment> group together situations need single element. Grouping elements Fragment effect resulting DOM; elements grouped. empty JSX tag <></> shorthand <Fragment></Fragment> cases. Props - optional key : Fragments declared explicit<Fragment> syntax may keys. Caveats - want pass key Fragment, can\u2019t use the<>...</> syntax. explicitly importFragment from'react' render<Fragment key={yourKey}>...</Fragment> . - React reset state go rendering <><Child /></> to[<Child />] back, go rendering<><Child /></> to<Child /> back. works single level deep: example, going from<><><Child /></></> to<Child /> resets state. See precise semantics here. Usage Returning multiple elements Use Fragment , equivalent <>...</> syntax, group multiple elements together. use put multiple elements place single element go. example, component return one element, using Fragment group multiple elements together return group: function Post() { return ( <> <PostTitle /> <PostBody /> </> ); } Fragments useful grouping elements Fragment effect layout styles, unlike wrapped elements another container like DOM element. inspect example browser tools, you\u2019ll see <h1> <article> DOM nodes appear siblings without wrappers around them: export default function Blog() { return ( <> <Post title=\"An update\" body=\"It's since posted...\" /> <Post title=\"My new blog\" body=\"I starting new blog!\" /> </> ) } function Post({ title, body }) { return ( <> <PostTitle title={title} /> <PostBody body={body} /> </> ); } function PostTitle({ title }) { return <h1>{title}</h1> } function PostBody({ body }) { return ( <article> <p>{body}</p> </article> ); } Deep Dive example equivalent importing Fragment React: import { Fragment } 'react'; function Post() { return ( <Fragment> <PostTitle /> <PostBody /> </Fragment> ); } Usually won\u2019t need unless need pass key Fragment . Assigning multiple elements variable Like element, assign Fragment elements variables, pass props, on: function CloseDialog() { const buttons = ( <> <OKButton /> <CancelButton /> </> ); return ( <AlertDialog buttons={buttons}> sure want leave page? </AlertDialog> ); } Grouping elements text use Fragment group text together components: function DateRangePicker({ start, end }) { return ( <> <DatePicker date={start} /> <DatePicker date={end} /> </> ); } Rendering list Fragments Here\u2019s situation need write Fragment explicitly instead using <></> syntax. render multiple elements loop, need assign key element. elements within loop Fragments, need use normal JSX element syntax order provide key attribute: function Blog() { return posts.map(post => <Fragment key={post.id}> <PostTitle title={post.title} /> <PostBody body={post.body} /> </Fragment> ); } inspect DOM verify wrapper elements around Fragment children: import { Fragment } 'react'; const posts = [ { id: 1, title: 'An update', body: \"It's since posted...\" }, { id: 2, title: 'My new blog', body: 'I starting new blog!' } ]; export default function Blog() { return posts.map(post => <Fragment key={post.id}> <PostTitle title={post.title} /> <PostBody body={post.body} /> </Fragment> ); } function PostTitle({ title }) { return <h1>{title}</h1> } function PostBody({ body }) { return ( <article> <p>{body}</p> </article> ); }"},
{"source": "https://react.dev/reference/react/Profiler", "title": "<Profiler> \u2013 React", "text": "<Profiler> <Profiler> lets measure rendering performance React tree programmatically. <Profiler id=\"App\" onRender={onRender}> <App /> </Profiler> Reference <Profiler> Wrap component tree <Profiler> measure rendering performance. <Profiler id=\"App\" onRender={onRender}> <App /> </Profiler> Props id : string identifying part UI measuring.onRender : AnonRender callback React calls every time components within profiled tree update. receives information rendered much time took. Caveats - Profiling adds additional overhead, disabled production build default. opt production profiling, need enable special production build profiling enabled. onRender callback React call onRender callback information rendered. function onRender(id, phase, actualDuration, baseDuration, startTime, commitTime) { // Aggregate log render timings... } Parameters id : stringid prop the<Profiler> tree committed. lets identify part tree committed using multiple profilers.phase :\"mount\" ,\"update\" or\"nested-update\" . lets know whether tree mounted first time re-rendered due change props, state, Hooks.actualDuration : number milliseconds spent rendering the<Profiler> descendants current update. indicates well subtree makes use memoization (e.g.memo anduseMemo ). Ideally value decrease significantly initial mount many descendants need re-render specific props change.baseDuration : number milliseconds estimating much time would take re-render entire<Profiler> subtree without optimizations. calculated summing recent render durations component tree. value estimates worst-case cost rendering (e.g. initial mount tree memoization). CompareactualDuration see memoization working.startTime : numeric timestamp React began rendering current update.commitTime : numeric timestamp React committed current update. value shared profilers commit, enabling grouped desirable. Usage Measuring rendering performance programmatically Wrap <Profiler> component around React tree measure rendering performance. <App> <Profiler id=\"Sidebar\" onRender={onRender}> <Sidebar /> </Profiler> <PageContent /> </App> requires two props: id (string) onRender callback (function) React calls time component within tree \u201ccommits\u201d update. Measuring different parts application use multiple <Profiler> components measure different parts application: <App> <Profiler id=\"Sidebar\" onRender={onRender}> <Sidebar /> </Profiler> <Profiler id=\"Content\" onRender={onRender}> <Content /> </Profiler> </App> also nest <Profiler> components: <App> <Profiler id=\"Sidebar\" onRender={onRender}> <Sidebar /> </Profiler> <Profiler id=\"Content\" onRender={onRender}> <Content> <Profiler id=\"Editor\" onRender={onRender}> <Editor /> </Profiler> <Preview /> </Content> </Profiler> </App> Although <Profiler> lightweight component, used necessary. use adds CPU memory overhead application."},
{"source": "https://react.dev/reference/react/PureComponent", "title": "PureComponent \u2013 React", "text": "PureComponent PureComponent similar Component skips re-renders props state. Class components still supported React, don\u2019t recommend using new code. class Greeting extends PureComponent { render() { return <h1>Hello, {this.props.name}!</h1>; } } Reference PureComponent skip re-rendering class component props state, extend PureComponent instead Component : import { PureComponent } 'react'; class Greeting extends PureComponent { render() { return <h1>Hello, {this.props.name}!</h1>; } } PureComponent subclass Component supports Component APIs. Extending PureComponent equivalent defining custom shouldComponentUpdate method shallowly compares props state. Usage Skipping unnecessary re-renders class components React normally re-renders component whenever parent re-renders. optimization, create component React re-render parent re-renders long new props state old props state. Class components opt behavior extending PureComponent : class Greeting extends PureComponent { render() { return <h1>Hello, {this.props.name}!</h1>; } } React component always pure rendering logic. means must return output props, state, context haven\u2019t changed. using PureComponent , telling React component complies requirement, React doesn\u2019t need re-render long props state haven\u2019t changed. However, component still re-render context it\u2019s using changes. example, notice Greeting component re-renders whenever name changed (because that\u2019s one props), address changed (because it\u2019s passed Greeting prop): import { PureComponent, useState } 'react'; class Greeting extends PureComponent { render() { console.log(\"Greeting rendered at\", new Date().toLocaleTimeString()); return <h3>Hello{this.props.name && ', '}{this.props.name}!</h3>; } } export default function MyApp() { const [name, setName] = useState(''); const [address, setAddress] = useState(''); return ( <> <label> Name{': '} <input value={name} onChange={e => setName(e.target.value)} /> </label> <label> Address{': '} <input value={address} onChange={e => setAddress(e.target.value)} /> </label> <Greeting name={name} /> </> ); } Alternatives Migrating PureComponent class component function recommend using function components instead class components new code. existing class components using PureComponent , convert them. original code: import { PureComponent, useState } 'react'; class Greeting extends PureComponent { render() { console.log(\"Greeting rendered at\", new Date().toLocaleTimeString()); return <h3>Hello{this.props.name && ', '}{this.props.name}!</h3>; } } export default function MyApp() { const [name, setName] = useState(''); const [address, setAddress] = useState(''); return ( <> <label> Name{': '} <input value={name} onChange={e => setName(e.target.value)} /> </label> <label> Address{': '} <input value={address} onChange={e => setAddress(e.target.value)} /> </label> <Greeting name={name} /> </> ); } convert component class function, wrap memo : import { memo, useState } 'react'; const Greeting = memo(function Greeting({ name }) { console.log(\"Greeting rendered at\", new Date().toLocaleTimeString()); return <h3>Hello{name && ', '}{name}!</h3>; }); export default function MyApp() { const [name, setName] = useState(''); const [address, setAddress] = useState(''); return ( <> <label> Name{': '} <input value={name} onChange={e => setName(e.target.value)} /> </label> <label> Address{': '} <input value={address} onChange={e => setAddress(e.target.value)} /> </label> <Greeting name={name} /> </> ); }"},
{"source": "https://react.dev/reference/react/StrictMode", "title": "<StrictMode> \u2013 React", "text": "<StrictMode> <StrictMode> lets find common bugs components early development. <StrictMode> <App /> </StrictMode> Reference <StrictMode> Use StrictMode enable additional development behaviors warnings component tree inside: import { StrictMode } 'react'; import { createRoot } 'react-dom/client'; const root = createRoot(document.getElementById('root')); root.render( <StrictMode> <App /> </StrictMode> ); Strict Mode enables following development-only behaviors: - components re-render extra time find bugs caused impure rendering. - components re-run Effects extra time find bugs caused missing Effect cleanup. - components re-run refs callbacks extra time find bugs caused missing ref cleanup. - components checked usage deprecated APIs. Props StrictMode accepts props. Caveats - way opt Strict Mode inside tree wrapped <StrictMode> . gives confidence components inside<StrictMode> checked. two teams working product disagree whether find checks valuable, need either reach consensus move<StrictMode> tree. Usage Enabling Strict Mode entire app Strict Mode enables extra development-only checks entire component tree inside <StrictMode> component. checks help find common bugs components early development process. enable Strict Mode entire app, wrap root component <StrictMode> render it: import { StrictMode } 'react'; import { createRoot } 'react-dom/client'; const root = createRoot(document.getElementById('root')); root.render( <StrictMode> <App /> </StrictMode> ); recommend wrapping entire app Strict Mode, especially newly created apps. use framework calls createRoot you, check documentation enable Strict Mode. Although Strict Mode checks run development, help find bugs already exist code tricky reliably reproduce production. Strict Mode lets fix bugs users report them. Enabling Strict Mode part app also enable Strict Mode part application: import { StrictMode } 'react'; function App() { return ( <> <Header /> <StrictMode> <main> <Sidebar /> <Content /> </main> </StrictMode> <Footer /> </> ); } example, Strict Mode checks run Header Footer components. However, run Sidebar Content , well components inside them, matter deep. Fixing bugs found double rendering development React assumes every component write pure function. means React components write must always return JSX given inputs (props, state, context). Components breaking rule behave unpredictably cause bugs. help find accidentally impure code, Strict Mode calls functions (only ones pure) twice development. includes: - component function body (only top-level logic, doesn\u2019t include code inside event handlers) - Functions pass useState ,set functions,useMemo , oruseReducer - class component methods like constructor ,render ,shouldComponentUpdate (see whole list) function pure, running twice change behavior pure function produces result every time. However, function impure (for example, mutates data receives), running twice tends noticeable (that\u2019s makes impure!) helps spot fix bug early. example illustrate double rendering Strict Mode helps find bugs early. StoryTray component takes array stories adds one last \u201cCreate Story\u201d item end: export default function StoryTray({ stories }) { const items = stories; items.push({ id: 'create', label: 'Create Story' }); return ( <ul> {items.map(story => ( <li key={story.id}> {story.label} </li> ))} </ul> ); } mistake code above. However, easy miss initial output appears correct. mistake become noticeable StoryTray component re-renders multiple times. example, let\u2019s make StoryTray re-render different background color whenever hover it: import { useState } 'react'; export default function StoryTray({ stories }) { const [isHover, setIsHover] = useState(false); const items = stories; items.push({ id: 'create', label: 'Create Story' }); return ( <ul onPointerEnter={() => setIsHover(true)} onPointerLeave={() => setIsHover(false)} style={{ backgroundColor: isHover ? '#ddd' : '#fff' }} > {items.map(story => ( <li key={story.id}> {story.label} </li> ))} </ul> ); } Notice every time hover StoryTray component, \u201cCreate Story\u201d gets added list again. intention code add end. StoryTray directly modifies stories array props. Every time StoryTray renders, adds \u201cCreate Story\u201d end array. words, StoryTray pure function\u2014running multiple times produces different results. fix problem, make copy array, modify copy instead original one: export default function StoryTray({ stories }) { const items = stories.slice(); // Clone array // \u2705 Good: Pushing new array items.push({ id: 'create', label: 'Create Story' }); would make StoryTray function pure. time called, would modify new copy array, would affect external objects variables. solves bug, make component re-render often became obvious something wrong behavior. original example, bug wasn\u2019t obvious. let\u2019s wrap original (buggy) code <StrictMode> : export default function StoryTray({ stories }) { const items = stories; items.push({ id: 'create', label: 'Create Story' }); return ( <ul> {items.map(story => ( <li key={story.id}> {story.label} </li> ))} </ul> ); } Strict Mode always calls rendering function twice, see mistake right away (\u201cCreate Story\u201d appears twice). lets notice mistakes early process. fix component render Strict Mode, also fix many possible future production bugs like hover functionality before: import { useState } 'react'; export default function StoryTray({ stories }) { const [isHover, setIsHover] = useState(false); const items = stories.slice(); // Clone array items.push({ id: 'create', label: 'Create Story' }); return ( <ul onPointerEnter={() => setIsHover(true)} onPointerLeave={() => setIsHover(false)} style={{ backgroundColor: isHover ? '#ddd' : '#fff' }} > {items.map(story => ( <li key={story.id}> {story.label} </li> ))} </ul> ); } Without Strict Mode, easy miss bug added re-renders. Strict Mode made bug appear right away. Strict Mode helps find bugs push team users. Read keeping components pure. Fixing bugs found re-running Effects development Strict Mode also help find bugs Effects. Every Effect setup code may cleanup code. Normally, React calls setup component mounts (is added screen) calls cleanup component unmounts (is removed screen). React calls cleanup setup dependencies changed since last render. Strict Mode on, React also run one extra setup+cleanup cycle development every Effect. may feel surprising, helps reveal subtle bugs hard catch manually. example illustrate re-running Effects Strict Mode helps find bugs early. Consider example connects component chat: import { createRoot } 'react-dom/client'; import './styles.css'; import App './App'; const root = createRoot(document.getElementById(\"root\")); root.render(<App />); issue code, might immediately clear. make issue obvious, let\u2019s implement feature. example below, roomId hardcoded. Instead, user select roomId want connect dropdown. Click \u201cOpen chat\u201d select different chat rooms one one. Keep track number active connections console: import { createRoot } 'react-dom/client'; import './styles.css'; import App './App'; const root = createRoot(document.getElementById(\"root\")); root.render(<App />); You\u2019ll notice number open connections always keeps growing. real app, would cause performance network problems. issue Effect missing cleanup function: useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, [roomId]); Effect \u201ccleans up\u201d destroys outdated connections, leak solved. However, notice problem become visible you\u2019ve added features (the select box). original example, bug wasn\u2019t obvious. let\u2019s wrap original (buggy) code <StrictMode> : import { StrictMode } 'react'; import { createRoot } 'react-dom/client'; import './styles.css'; import App './App'; const root = createRoot(document.getElementById(\"root\")); root.render( <StrictMode> <App /> </StrictMode> ); Strict Mode, immediately see problem (the number active connections jumps 2). Strict Mode runs extra setup+cleanup cycle every Effect. Effect cleanup logic, creates extra connection doesn\u2019t destroy it. hint you\u2019re missing cleanup function. Strict Mode lets notice mistakes early process. fix Effect adding cleanup function Strict Mode, also fix many possible future production bugs like select box before: import { StrictMode } 'react'; import { createRoot } 'react-dom/client'; import './styles.css'; import App './App'; const root = createRoot(document.getElementById(\"root\")); root.render( <StrictMode> <App /> </StrictMode> ); Notice active connection count console doesn\u2019t keep growing anymore. Without Strict Mode, easy miss Effect needed cleanup. running setup \u2192 cleanup \u2192 setup instead setup Effect development, Strict Mode made missing cleanup logic noticeable. Read implementing Effect cleanup. Fixing bugs found re-running ref callbacks development Strict Mode also help find bugs callbacks refs. Every callback ref setup code may cleanup code. Normally, React calls setup element created (is added DOM) calls cleanup element removed (is removed DOM). Strict Mode on, React also run one extra setup+cleanup cycle development every callback ref . may feel surprising, helps reveal subtle bugs hard catch manually. Consider example, allows select animal scroll one them. Notice switch \u201cCats\u201d \u201cDogs\u201d, console logs show number animals list keeps growing, \u201cScroll to\u201d buttons stop working: import { useRef, useState } \"react\"; export default function AnimalFriends() { const itemsRef = useRef([]); const [animalList, setAnimalList] = useState(setupAnimalList); const [animal, setAnimal] = useState('cat'); function scrollToAnimal(index) { const list = itemsRef.current; const {node} = list[index]; node.scrollIntoView({ behavior: \"smooth\", block: \"nearest\", inline: \"center\", }); } const animals = animalList.filter(a => a.type === animal) return ( <> <nav> <button onClick={() => setAnimal('cat')}>Cats</button> <button onClick={() => setAnimal('dog')}>Dogs</button> </nav> <hr /> <nav> <span>Scroll to:</span>{animals.map((animal, index) => ( <button key={animal.src} onClick={() => scrollToAnimal(index)}> {index} </button> ))} </nav> <div> <ul> {animals.map((animal) => ( <li key={animal.src} ref={(node) => { const list = itemsRef.current; const item = {animal: animal, node}; list.push(item); console.log(`\u2705 Adding animal map. Total animals: ${list.length}`); (list.length > 10) { console.log('\u274c many animals list!'); } return () => { // \ud83d\udea9 cleanup, bug! } }} > <img src={animal.src} /> </li> ))} </ul> </div> </> ); } function setupAnimalList() { const animalList = []; (let = 0; < 10; i++) { animalList.push({type: 'cat', src: \"https://loremflickr.com/320/240/cat?lock=\" + i}); } (let = 0; < 10; i++) { animalList.push({type: 'dog', src: \"https://loremflickr.com/320/240/dog?lock=\" + i}); } return animalList; } production bug! Since ref callback doesn\u2019t remove animals list cleanup, list animals keeps growing. memory leak cause performance problems real app, breaks behavior app. issue ref callback doesn\u2019t cleanup itself: <li ref={node => { const list = itemsRef.current; const item = {animal, node}; list.push(item); return () => { // \ud83d\udea9 cleanup, bug! } }} </li> let\u2019s wrap original (buggy) code <StrictMode> : import { useRef, useState } \"react\"; export default function AnimalFriends() { const itemsRef = useRef([]); const [animalList, setAnimalList] = useState(setupAnimalList); const [animal, setAnimal] = useState('cat'); function scrollToAnimal(index) { const list = itemsRef.current; const {node} = list[index]; node.scrollIntoView({ behavior: \"smooth\", block: \"nearest\", inline: \"center\", }); } const animals = animalList.filter(a => a.type === animal) return ( <> <nav> <button onClick={() => setAnimal('cat')}>Cats</button> <button onClick={() => setAnimal('dog')}>Dogs</button> </nav> <hr /> <nav> <span>Scroll to:</span>{animals.map((animal, index) => ( <button key={animal.src} onClick={() => scrollToAnimal(index)}> {index} </button> ))} </nav> <div> <ul> {animals.map((animal) => ( <li key={animal.src} ref={(node) => { const list = itemsRef.current; const item = {animal: animal, node} list.push(item); console.log(`\u2705 Adding animal map. Total animals: ${list.length}`); (list.length > 10) { console.log('\u274c many animals list!'); } return () => { // \ud83d\udea9 cleanup, bug! } }} > <img src={animal.src} /> </li> ))} </ul> </div> </> ); } function setupAnimalList() { const animalList = []; (let = 0; < 10; i++) { animalList.push({type: 'cat', src: \"https://loremflickr.com/320/240/cat?lock=\" + i}); } (let = 0; < 10; i++) { animalList.push({type: 'dog', src: \"https://loremflickr.com/320/240/dog?lock=\" + i}); } return animalList; } Strict Mode, immediately see problem. Strict Mode runs extra setup+cleanup cycle every callback ref. callback ref cleanup logic, adds refs doesn\u2019t remove them. hint you\u2019re missing cleanup function. Strict Mode lets eagerly find mistakes callback refs. fix callback adding cleanup function Strict Mode, also fix many possible future production bugs like \u201cScroll to\u201d bug before: import { useRef, useState } \"react\"; export default function AnimalFriends() { const itemsRef = useRef([]); const [animalList, setAnimalList] = useState(setupAnimalList); const [animal, setAnimal] = useState('cat'); function scrollToAnimal(index) { const list = itemsRef.current; const {node} = list[index]; node.scrollIntoView({ behavior: \"smooth\", block: \"nearest\", inline: \"center\", }); } const animals = animalList.filter(a => a.type === animal) return ( <> <nav> <button onClick={() => setAnimal('cat')}>Cats</button> <button onClick={() => setAnimal('dog')}>Dogs</button> </nav> <hr /> <nav> <span>Scroll to:</span>{animals.map((animal, index) => ( <button key={animal.src} onClick={() => scrollToAnimal(index)}> {index} </button> ))} </nav> <div> <ul> {animals.map((animal) => ( <li key={animal.src} ref={(node) => { const list = itemsRef.current; const item = {animal, node}; list.push({animal: animal, node}); console.log(`\u2705 Adding animal map. Total animals: ${list.length}`); (list.length > 10) { console.log('\u274c many animals list!'); } return () => { list.splice(list.indexOf(item)); console.log(`\u274c Removing animal map. Total animals: ${itemsRef.current.length}`); } }} > <img src={animal.src} /> </li> ))} </ul> </div> </> ); } function setupAnimalList() { const animalList = []; (let = 0; < 10; i++) { animalList.push({type: 'cat', src: \"https://loremflickr.com/320/240/cat?lock=\" + i}); } (let = 0; < 10; i++) { animalList.push({type: 'dog', src: \"https://loremflickr.com/320/240/dog?lock=\" + i}); } return animalList; } inital mount StrictMode, ref callbacks setup, cleaned up, setup again: ... \u2705 Adding animal map. Total animals: 10 ... \u274c Removing animal map. Total animals: 0 ... \u2705 Adding animal map. Total animals: 10 expected. Strict Mode confirms ref callbacks cleaned correctly, size never grows expected amount. fix, memory leaks, features work expected. Without Strict Mode, easy miss bug clicked around app notice broken features. Strict Mode made bugs appear right away, push production. Fixing deprecation warnings enabled Strict Mode React warns component anywhere inside <StrictMode> tree uses one deprecated APIs: UNSAFE_ class lifecycle methods likeUNSAFE_componentWillMount . See alternatives. APIs primarily used older class components rarely appear modern apps."},
{"source": "https://react.dev/reference/react/Suspense", "title": "<Suspense> \u2013 React", "text": "<Suspense> <Suspense> lets display fallback children finished loading. <Suspense fallback={<Loading />}> <SomeComponent /> </Suspense> - Reference - Usage - Displaying fallback content loading - Revealing content together - Revealing nested content loads - Showing stale content fresh content loading - Preventing already revealed content hiding - Indicating Transition happening - Resetting Suspense boundaries navigation - Providing fallback server errors client-only content - Troubleshooting Reference <Suspense> Props children : actual UI intend render. Ifchildren suspends rendering, Suspense boundary switch renderingfallback .fallback : alternate UI render place actual UI finished loading. valid React node accepted, though practice, fallback lightweight placeholder view, loading spinner skeleton. Suspense automatically switch tofallback whenchildren suspends, back tochildren data ready. Iffallback suspends rendering, activate closest parent Suspense boundary. Caveats - React preserve state renders got suspended able mount first time. component loaded, React retry rendering suspended tree scratch. - Suspense displaying content tree, suspended again, fallback shown unless update causing caused bystartTransition oruseDeferredValue . - React needs hide already visible content suspended again, clean layout Effects content tree. content ready shown again, React fire layout Effects again. ensures Effects measuring DOM layout don\u2019t try content hidden. - React includes under-the-hood optimizations like Streaming Server Rendering Selective Hydration integrated Suspense. Read architectural overview watch technical talk learn more. Usage Displaying fallback content loading wrap part application Suspense boundary: <Suspense fallback={<Loading />}> <Albums /> </Suspense> React display loading fallback code data needed children loaded. example below, Albums component suspends fetching list albums. it\u2019s ready render, React switches closest Suspense boundary show fallback\u2014your Loading component. Then, data loads, React hides Loading fallback renders Albums component data. import { Suspense } 'react'; import Albums './Albums.js'; export default function ArtistPage({ artist }) { return ( <> <h1>{artist.name}</h1> <Suspense fallback={<Loading />}> <Albums artistId={artist.id} /> </Suspense> </> ); } function Loading() { return <h2>\ud83c\udf00 Loading...</h2>; } Revealing content together default, whole tree inside Suspense treated single unit. example, even one components suspends waiting data, together replaced loading indicator: <Suspense fallback={<Loading />}> <Biography /> <Panel> <Albums /> </Panel> </Suspense> Then, ready displayed, appear together once. example below, Biography Albums fetch data. However, grouped single Suspense boundary, components always \u201cpop in\u201d together time. import { Suspense } 'react'; import Albums './Albums.js'; import Biography './Biography.js'; import Panel './Panel.js'; export default function ArtistPage({ artist }) { return ( <> <h1>{artist.name}</h1> <Suspense fallback={<Loading />}> <Biography artistId={artist.id} /> <Panel> <Albums artistId={artist.id} /> </Panel> </Suspense> </> ); } function Loading() { return <h2>\ud83c\udf00 Loading...</h2>; } Components load data don\u2019t direct children Suspense boundary. example, move Biography Albums new Details component. doesn\u2019t change behavior. Biography Albums share closest parent Suspense boundary, reveal coordinated together. <Suspense fallback={<Loading />}> <Details artistId={artist.id} /> </Suspense> function Details({ artistId }) { return ( <> <Biography artistId={artistId} /> <Panel> <Albums artistId={artistId} /> </Panel> </> ); } Revealing nested content loads component suspends, closest parent Suspense component shows fallback. lets nest multiple Suspense components create loading sequence. Suspense boundary\u2019s fallback filled next level content becomes available. example, give album list fallback: <Suspense fallback={<BigSpinner />}> <Biography /> <Suspense fallback={<AlbumsGlimmer />}> <Panel> <Albums /> </Panel> </Suspense> </Suspense> change, displaying Biography doesn\u2019t need \u201cwait\u201d Albums load. sequence be: - Biography hasn\u2019t loaded yet,BigSpinner shown place entire content area. - Biography finishes loading,BigSpinner replaced content. - Albums hasn\u2019t loaded yet,AlbumsGlimmer shown place ofAlbums parentPanel . - Finally, Albums finishes loading, replacesAlbumsGlimmer . import { Suspense } 'react'; import Albums './Albums.js'; import Biography './Biography.js'; import Panel './Panel.js'; export default function ArtistPage({ artist }) { return ( <> <h1>{artist.name}</h1> <Suspense fallback={<BigSpinner />}> <Biography artistId={artist.id} /> <Suspense fallback={<AlbumsGlimmer />}> <Panel> <Albums artistId={artist.id} /> </Panel> </Suspense> </Suspense> </> ); } function BigSpinner() { return <h2>\ud83c\udf00 Loading...</h2>; } function AlbumsGlimmer() { return ( <div className=\"glimmer-panel\"> <div className=\"glimmer-line\" /> <div className=\"glimmer-line\" /> <div className=\"glimmer-line\" /> </div> ); } Suspense boundaries let coordinate parts UI always \u201cpop in\u201d together time, parts progressively reveal content sequence loading states. add, move, delete Suspense boundaries place tree without affecting rest app\u2019s behavior. Don\u2019t put Suspense boundary around every component. Suspense boundaries granular loading sequence want user experience. work designer, ask loading states placed\u2014it\u2019s likely they\u2019ve already included design wireframes. Showing stale content fresh content loading example, SearchResults component suspends fetching search results. Type \"a\" , wait results, edit \"ab\" . results \"a\" get replaced loading fallback. import { Suspense, useState } 'react'; import SearchResults './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); return ( <> <label> Search albums: <input value={query} onChange={e => setQuery(e.target.value)} /> </label> <Suspense fallback={<h2>Loading...</h2>}> <SearchResults query={query} /> </Suspense> </> ); } common alternative UI pattern defer updating list keep showing previous results new results ready. useDeferredValue Hook lets pass deferred version query down: export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); return ( <> <label> Search albums: <input value={query} onChange={e => setQuery(e.target.value)} /> </label> <Suspense fallback={<h2>Loading...</h2>}> <SearchResults query={deferredQuery} /> </Suspense> </> ); } query update immediately, input display new value. However, deferredQuery keep previous value data loaded, SearchResults show stale results bit. make obvious user, add visual indication stale result list displayed: <div style={{ opacity: query !== deferredQuery ? 0.5 : 1 }}> <SearchResults query={deferredQuery} /> </div> Enter \"a\" example below, wait results load, edit input \"ab\" . Notice instead Suspense fallback, see dimmed stale result list new results loaded: import { Suspense, useState, useDeferredValue } 'react'; import SearchResults './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); const isStale = query !== deferredQuery; return ( <> <label> Search albums: <input value={query} onChange={e => setQuery(e.target.value)} /> </label> <Suspense fallback={<h2>Loading...</h2>}> <div style={{ opacity: isStale ? 0.5 : 1 }}> <SearchResults query={deferredQuery} /> </div> </Suspense> </> ); } Preventing already revealed content hiding component suspends, closest parent Suspense boundary switches showing fallback. lead jarring user experience already displaying content. Try pressing button: import { Suspense, useState } 'react'; import IndexPage './IndexPage.js'; import ArtistPage './ArtistPage.js'; import Layout './Layout.js'; export default function App() { return ( <Suspense fallback={<BigSpinner />}> <Router /> </Suspense> ); } function Router() { const [page, setPage] = useState('/'); function navigate(url) { setPage(url); } let content; (page === '/') { content = ( <IndexPage navigate={navigate} /> ); } else (page === '/the-beatles') { content = ( <ArtistPage artist={{ id: 'the-beatles', name: 'The Beatles', }} /> ); } return ( <Layout> {content} </Layout> ); } function BigSpinner() { return <h2>\ud83c\udf00 Loading...</h2>; } pressed button, Router component rendered ArtistPage instead IndexPage . component inside ArtistPage suspended, closest Suspense boundary started showing fallback. closest Suspense boundary near root, whole site layout got replaced BigSpinner . prevent this, mark navigation state update Transition startTransition : function Router() { const [page, setPage] = useState('/'); function navigate(url) { startTransition(() => { setPage(url); }); } // ... tells React state transition urgent, it\u2019s better keep showing previous page instead hiding already revealed content. clicking button \u201cwaits\u201d Biography load: import { Suspense, startTransition, useState } 'react'; import IndexPage './IndexPage.js'; import ArtistPage './ArtistPage.js'; import Layout './Layout.js'; export default function App() { return ( <Suspense fallback={<BigSpinner />}> <Router /> </Suspense> ); } function Router() { const [page, setPage] = useState('/'); function navigate(url) { startTransition(() => { setPage(url); }); } let content; (page === '/') { content = ( <IndexPage navigate={navigate} /> ); } else (page === '/the-beatles') { content = ( <ArtistPage artist={{ id: 'the-beatles', name: 'The Beatles', }} /> ); } return ( <Layout> {content} </Layout> ); } function BigSpinner() { return <h2>\ud83c\udf00 Loading...</h2>; } Transition doesn\u2019t wait content load. waits long enough avoid hiding already revealed content. example, website Layout already revealed, would bad hide behind loading spinner. However, nested Suspense boundary around Albums new, Transition doesn\u2019t wait it. Indicating Transition happening example, click button, visual indication navigation progress. add indicator, replace startTransition useTransition gives boolean isPending value. example below, it\u2019s used change website header styling Transition happening: import { Suspense, useState, useTransition } 'react'; import IndexPage './IndexPage.js'; import ArtistPage './ArtistPage.js'; import Layout './Layout.js'; export default function App() { return ( <Suspense fallback={<BigSpinner />}> <Router /> </Suspense> ); } function Router() { const [page, setPage] = useState('/'); const [isPending, startTransition] = useTransition(); function navigate(url) { startTransition(() => { setPage(url); }); } let content; (page === '/') { content = ( <IndexPage navigate={navigate} /> ); } else (page === '/the-beatles') { content = ( <ArtistPage artist={{ id: 'the-beatles', name: 'The Beatles', }} /> ); } return ( <Layout isPending={isPending}> {content} </Layout> ); } function BigSpinner() { return <h2>\ud83c\udf00 Loading...</h2>; } Resetting Suspense boundaries navigation Transition, React avoid hiding already revealed content. However, navigate route different parameters, might want tell React different content. express key : <ProfilePage key={queryParams.id} /> Imagine you\u2019re navigating within user\u2019s profile page, something suspends. update wrapped Transition, trigger fallback already visible content. That\u2019s expected behavior. However, imagine you\u2019re navigating two different user profiles. case, makes sense show fallback. example, one user\u2019s timeline different content another user\u2019s timeline. specifying key , ensure React treats different users\u2019 profiles different components, resets Suspense boundaries navigation. Suspense-integrated routers automatically. Providing fallback server errors client-only content use one streaming server rendering APIs (or framework relies them), React also use <Suspense> boundaries handle errors server. component throws error server, React abort server render. Instead, find closest <Suspense> component include fallback (such spinner) generated server HTML. user see spinner first. client, React attempt render component again. errors client too, React throw error display closest error boundary. However, error client, React display error user since content eventually displayed successfully. use opt components rendering server. this, throw error server environment wrap <Suspense> boundary replace HTML fallbacks: <Suspense fallback={<Loading />}> <Chat /> </Suspense> function Chat() { (typeof window === 'undefined') { throw Error('Chat render client.'); } // ... } server HTML include loading indicator. replaced Chat component client. Troubleshooting prevent UI replaced fallback update? Replacing visible UI fallback creates jarring user experience. happen update causes component suspend, nearest Suspense boundary already showing content user. prevent happening, mark update non-urgent using startTransition . Transition, React wait enough data loaded prevent unwanted fallback appearing: function handleNextPageClick() { // update suspends, hide already displayed content startTransition(() => { setCurrentPage(currentPage + 1); }); } avoid hiding existing content. However, newly rendered Suspense boundaries still immediately display fallbacks avoid blocking UI let user see content becomes available. React prevent unwanted fallbacks non-urgent updates. delay render it\u2019s result urgent update. must opt API like startTransition useDeferredValue . router integrated Suspense, wrap updates startTransition automatically."},
{"source": "https://react.dev/reference/react/act", "title": "act \u2013 React", "text": "act test helper apply pending React updates making assertions. await act(async actFn) prepare component assertions, wrap code rendering performing updates inside await act() call. makes test run closer React works browser. Reference await act(async actFn) writing UI tests, tasks like rendering, user events, data fetching considered \u201cunits\u201d interaction user interface. React provides helper called act() makes sure updates related \u201cunits\u201d processed applied DOM make assertions. name act comes Arrange-Act-Assert pattern. ('renders button disabled', async () => { await act(async () => { root.render(<TestComponent />) }); expect(container.querySelector('button')).toBeDisabled(); }); Parameters async actFn : async function wrapping renders interactions components tested. updates triggered within theactFn , added internal act queue, flushed together process apply changes DOM. Since async, React also run code crosses async boundary, flush updates scheduled. Returns act return anything. Usage testing component, use act make assertions output. example, let\u2019s say Counter component, usage examples show test it: function Counter() { const [count, setCount] = useState(0); const handleClick = () => { setCount(prev => prev + 1); } useEffect(() => { document.title = `You clicked ${count} times`; }, [count]); return ( <div> <p>You clicked {count} times</p> <button onClick={handleClick}> Click </button> </div> ) } Rendering components tests test render output component, wrap render inside act() : import {act} 'react'; import ReactDOMClient 'react-dom/client'; import Counter './Counter'; it('can render update counter', async () => { container = document.createElement('div'); document.body.appendChild(container); // \u2705 Render component inside act(). await act(() => { ReactDOMClient.createRoot(container).render(<Counter />); }); const button = container.querySelector('button'); const label = container.querySelector('p'); expect(label.textContent).toBe('You clicked 0 times'); expect(document.title).toBe('You clicked 0 times'); }); Here, create container, append document, render Counter component inside act() . ensures component rendered effects applied making assertions. Using act ensures updates applied make assertions. Dispatching events tests test events, wrap event dispatch inside act() : import {act} 'react'; import ReactDOMClient 'react-dom/client'; import Counter './Counter'; it.only('can render update counter', async () => { const container = document.createElement('div'); document.body.appendChild(container); await act( async () => { ReactDOMClient.createRoot(container).render(<Counter />); }); // \u2705 Dispatch event inside act(). await act(async () => { button.dispatchEvent(new MouseEvent('click', { bubbles: true })); }); const button = container.querySelector('button'); const label = container.querySelector('p'); expect(label.textContent).toBe('You clicked 1 times'); expect(document.title).toBe('You clicked 1 times'); }); Here, render component act , dispatch event inside another act() . ensures updates event applied making assertions. Troubleshooting I\u2019m getting error: \u201cThe current testing environment configured support act\u201d(\u2026)\u201d Using act requires setting global.IS_REACT_ACT_ENVIRONMENT=true test environment. ensure act used correct environment. don\u2019t set global, see error like this: fix, add global setup file React tests: global.IS_REACT_ACT_ENVIRONMENT=true"},
{"source": "https://react.dev/reference/react/apis", "title": "Built-in React APIs \u2013 React", "text": "Built-in React APIs addition Hooks Components, react package exports APIs useful defining components. page lists remaining modern React APIs. createContext lets define provide context child components. Used withuseContext .forwardRef lets component expose DOM node ref parent. Used withuseRef .lazy lets defer loading component\u2019s code it\u2019s rendered first time.memo lets component skip re-renders props. Used withuseMemo anduseCallback .startTransition lets mark state update non-urgent. Similar touseTransition .act lets wrap renders interactions tests ensure updates processed making assertions. Resource APIs Resources accessed component without part state. example, component read message Promise read styling information context. read value resource, use API: function MessageComponent({ messagePromise }) { const message = use(messagePromise); const theme = use(ThemeContext); // ... }"},
{"source": "https://react.dev/reference/react/cache", "title": "cache \u2013 React", "text": "cache cache lets cache result data fetch computation. const cachedFn = cache(fn); Reference cache(fn) Call cache outside components create version function caching. import {cache} 'react'; import calculateMetrics 'lib/metrics'; const getMetrics = cache(calculateMetrics); function Chart({data}) { const report = getMetrics(data); // ... } getMetrics first called data , getMetrics call calculateMetrics(data) store result cache. getMetrics called data , return cached result instead calling calculateMetrics(data) again. Parameters fn : function want cache results for.fn take arguments return value. Returns cache returns cached version fn type signature. call fn process. calling cachedFn given arguments, first checks cached result exists cache. cached result exists, returns result. not, calls fn arguments, stores result cache, returns result. time fn called cache miss. Caveats - React invalidate cache memoized functions server request. - call cache creates new function. means callingcache function multiple times return different memoized functions share cache. cachedFn also cache errors. Iffn throws error certain arguments, cached, error re-thrown whencachedFn called arguments.cache use Server Components only. Usage Cache expensive computation Use cache skip duplicate work. import {cache} 'react'; import calculateUserMetrics 'lib/user'; const getUserMetrics = cache(calculateUserMetrics); function Profile({user}) { const metrics = getUserMetrics(user); // ... } function TeamReport({users}) { (let user users) { const metrics = getUserMetrics(user); // ... } // ... } user object rendered Profile TeamReport , two components share work call calculateUserMetrics user . Assume Profile rendered first. call getUserMetrics , check cached result. Since first time getUserMetrics called user , cache miss. getUserMetrics call calculateUserMetrics user write result cache. TeamReport renders list users reaches user object, call getUserMetrics read result cache. Share snapshot data share snapshot data components, call cache data-fetching function like fetch . multiple components make data fetch, one request made data returned cached shared across components. components refer snapshot data across server render. import {cache} 'react'; import {fetchTemperature} './api.js'; const getTemperature = cache(async (city) => { return await fetchTemperature(city); }); async function AnimatedWeatherCard({city}) { const temperature = await getTemperature(city); // ... } async function MinimalWeatherCard({city}) { const temperature = await getTemperature(city); // ... } AnimatedWeatherCard MinimalWeatherCard render city, receive snapshot data memoized function. AnimatedWeatherCard MinimalWeatherCard supply different city arguments getTemperature , fetchTemperature called twice call site receive different data. city acts cache key. Preload data caching long-running data fetch, kick asynchronous work prior rendering component. const getUser = cache(async (id) => { return await db.user.query(id); }); async function Profile({id}) { const user = await getUser(id); return ( <section> <img src={user.profilePic} /> <h2>{user.name}</h2> </section> ); } function Page({id}) { // \u2705 Good: start fetching user data getUser(id); // ... computational work return ( <> <Profile id={id} /> </> ); } rendering Page , component calls getUser note doesn\u2019t use returned data. early getUser call kicks asynchronous database query occurs Page computational work rendering children. rendering Profile , call getUser again. initial getUser call already returned cached user data, Profile asks waits data, simply read cache without requiring another remote procedure call. initial data request hasn\u2019t completed, preloading data pattern reduces delay data-fetching. Deep Dive evaluating asynchronous function, receive Promise work. promise holds state work (pending, fulfilled, failed) eventual settled result. example, asynchronous function fetchData returns promise awaiting fetch . async function fetchData() { return await fetch(`https://...`); } const getData = cache(fetchData); async function MyComponent() { getData(); // ... computational work await getData(); // ... } calling getData first time, promise returned fetchData cached. Subsequent look-ups return promise. Notice first getData call await whereas second does. await JavaScript operator wait return settled result promise. first getData call simply initiates fetch cache promise second getData look-up. second call promise still pending, await pause result. optimization wait fetch , React continue computational work, thus reducing wait time second call. promise already settled, either error fulfilled result, await return value immediately. outcomes, performance benefit. Deep Dive mentioned APIs offer memoization difference they\u2019re intended memoize, access cache, cache invalidated. useMemo general, use useMemo caching expensive computation Client Component across renders. example, memoize transformation data within component. 'use client'; function WeatherReport({record}) { const avgTemp = useMemo(() => calculateAvg(record), record); // ... } function App() { const record = getRecord(); return ( <> <WeatherReport record={record} /> <WeatherReport record={record} /> </> ); } example, App renders two WeatherReport record. Even though components work, cannot share work. useMemo \u2019s cache local component. However, useMemo ensure App re-renders record object doesn\u2019t change, component instance would skip work use memoized value avgTemp . useMemo cache last computation avgTemp given dependencies. cache general, use cache Server Components memoize work shared across components. const cachedFetchReport = cache(fetchReport); function WeatherReport({city}) { const report = cachedFetchReport(city); // ... } function App() { const city = \"Los Angeles\"; return ( <> <WeatherReport city={city} /> <WeatherReport city={city} /> </> ); } Re-writing previous example use cache , case second instance WeatherReport able skip duplicate work read cache first WeatherReport . Another difference previous example cache also recommended memoizing data fetches, unlike useMemo used computations. time, cache used Server Components cache invalidated across server requests. memo use memo prevent component re-rendering props unchanged. 'use client'; function WeatherReport({record}) { const avgTemp = calculateAvg(record); // ... } const MemoWeatherReport = memo(WeatherReport); function App() { const record = getRecord(); return ( <> <MemoWeatherReport record={record} /> <MemoWeatherReport record={record} /> </> ); } example, MemoWeatherReport components call calculateAvg first rendered. However, App re-renders, changes record , none props changed MemoWeatherReport re-render. Compared useMemo , memo memoizes component render based props vs. specific computations. Similar useMemo , memoized component caches last render last prop values. props change, cache invalidates component re-renders. Troubleshooting memoized function still runs even though I\u2019ve called arguments See prior mentioned pitfalls - Calling different memoized functions read different caches. - Calling memoized function outside component use cache. none apply, may problem React checks something exists cache. arguments primitives (ex. objects, functions, arrays), ensure you\u2019re passing object reference. calling memoized function, React look input arguments see result already cached. React use shallow equality arguments determine cache hit. import {cache} 'react'; const calculateNorm = cache((vector) => { // ... }); function MapMarker(props) { // \ud83d\udea9 Wrong: props object changes every render. const length = calculateNorm(props); // ... } function App() { return ( <> <MapMarker x={10} y={10} z={10} /> <MapMarker x={10} y={10} z={10} /> </> ); } case two MapMarker look like they\u2019re work calling calculateNorm value {x: 10, y: 10, z:10} . Even though objects contain values, object reference component creates props object. React call Object.is input verify cache hit. import {cache} 'react'; const calculateNorm = cache((x, y, z) => { // ... }); function MapMarker(props) { // \u2705 Good: Pass primitives memoized function const length = calculateNorm(props.x, props.y, props.z); // ... } function App() { return ( <> <MapMarker x={10} y={10} z={10} /> <MapMarker x={10} y={10} z={10} /> </> ); } One way address could pass vector dimensions calculateNorm . works dimensions primitives. Another solution may pass vector object prop component. We\u2019ll need pass object component instances. import {cache} 'react'; const calculateNorm = cache((vector) => { // ... }); function MapMarker(props) { // \u2705 Good: Pass `vector` object const length = calculateNorm(props.vector); // ... } function App() { const vector = [10, 10, 10]; return ( <> <MapMarker vector={vector} /> <MapMarker vector={vector} /> </> ); }"},
{"source": "https://react.dev/reference/react/cloneElement", "title": "cloneElement \u2013 React", "text": "cloneElement cloneElement lets create new React element using another element starting point. const clonedElement = cloneElement(element, props, ...children) Reference cloneElement(element, props, ...children) Call cloneElement create React element based element , different props children : import { cloneElement } 'react'; // ... const clonedElement = cloneElement( <Row title=\"Cabbage\"> Hello </Row>, { isHighlighted: true }, 'Goodbye' ); console.log(clonedElement); // <Row title=\"Cabbage\" isHighlighted={true}>Goodbye</Row> Parameters - element : Theelement argument must valid React element. example, could JSX node like<Something /> , result callingcreateElement , result anothercloneElement call. - props : Theprops argument must either object ornull . passnull , cloned element retain originalelement.props . Otherwise, every prop theprops object, returned element \u201cprefer\u201d value fromprops value fromelement.props . rest props filled originalelement.props . passprops.key orprops.ref , replace original ones. - optional ...children : Zero child nodes. React nodes, including React elements, strings, numbers, portals, empty nodes (null ,undefined ,true , andfalse ), arrays React nodes. don\u2019t pass any...children arguments, originalelement.props.children preserved. Returns cloneElement returns React element object properties: type : aselement.type .props : result shallowly mergingelement.props overridingprops passed.ref : originalelement.ref , unless overridden byprops.ref .key : originalelement.key , unless overridden byprops.key . Usually, you\u2019ll return element component make child another element. Although may read element\u2019s properties, it\u2019s best treat every element opaque it\u2019s created, render it. Caveats - Cloning element modify original element. - pass children multiple arguments cloneElement statically known, likecloneElement(element, null, child1, child2, child3) . children dynamic, pass entire array third argument:cloneElement(element, null, listItems) . ensures React warn missingkey dynamic lists. static lists necessary never reorder. - cloneElement makes harder trace data flow, try alternatives instead. Usage Overriding props element override props React element, pass cloneElement props want override: import { cloneElement } 'react'; // ... const clonedElement = cloneElement( <Row title=\"Cabbage\" />, { isHighlighted: true } ); Here, resulting cloned element <Row title=\"Cabbage\" isHighlighted={true} /> . Let\u2019s walk example see it\u2019s useful. Imagine List component renders children list selectable rows \u201cNext\u201d button changes row selected. List component needs render selected Row differently, clones every <Row> child received, adds extra isHighlighted: true isHighlighted: false prop: export default function List({ children }) { const [selectedIndex, setSelectedIndex] = useState(0); return ( <div className=\"List\"> {Children.map(children, (child, index) => cloneElement(child, { isHighlighted: index === selectedIndex }) )} Let\u2019s say original JSX received List looks like this: <List> <Row title=\"Cabbage\" /> <Row title=\"Garlic\" /> <Row title=\"Apple\" /> </List> cloning children, List pass extra information every Row inside. result looks like this: <List> <Row title=\"Cabbage\" isHighlighted={true} /> <Row title=\"Garlic\" isHighlighted={false} /> <Row title=\"Apple\" isHighlighted={false} /> </List> Notice pressing \u201cNext\u201d updates state List , highlights different row: import { Children, cloneElement, useState } 'react'; export default function List({ children }) { const [selectedIndex, setSelectedIndex] = useState(0); return ( <div className=\"List\"> {Children.map(children, (child, index) => cloneElement(child, { isHighlighted: index === selectedIndex }) )} <hr /> <button onClick={() => { setSelectedIndex(i => (i + 1) % Children.count(children) ); }}> Next </button> </div> ); } summarize, List cloned <Row /> elements received added extra prop them. Alternatives Passing data render prop Instead using cloneElement , consider accepting render prop like renderItem . Here, List receives renderItem prop. List calls renderItem every item passes isHighlighted argument: export default function List({ items, renderItem }) { const [selectedIndex, setSelectedIndex] = useState(0); return ( <div className=\"List\"> {items.map((item, index) => { const isHighlighted = index === selectedIndex; return renderItem(item, isHighlighted); })} renderItem prop called \u201crender prop\u201d it\u2019s prop specifies render something. example, pass renderItem implementation renders <Row> given isHighlighted value: <List items={products} renderItem={(product, isHighlighted) => <Row key={product.id} title={product.title} isHighlighted={isHighlighted} /> } /> end result cloneElement : <List> <Row title=\"Cabbage\" isHighlighted={true} /> <Row title=\"Garlic\" isHighlighted={false} /> <Row title=\"Apple\" isHighlighted={false} /> </List> However, clearly trace isHighlighted value coming from. import { useState } 'react'; export default function List({ items, renderItem }) { const [selectedIndex, setSelectedIndex] = useState(0); return ( <div className=\"List\"> {items.map((item, index) => { const isHighlighted = index === selectedIndex; return renderItem(item, isHighlighted); })} <hr /> <button onClick={() => { setSelectedIndex(i => (i + 1) % items.length ); }}> Next </button> </div> ); } pattern preferred cloneElement explicit. Passing data context Another alternative cloneElement pass data context. example, call createContext define HighlightContext : export const HighlightContext = createContext(false); List component wrap every item renders HighlightContext provider: export default function List({ items, renderItem }) { const [selectedIndex, setSelectedIndex] = useState(0); return ( <div className=\"List\"> {items.map((item, index) => { const isHighlighted = index === selectedIndex; return ( <HighlightContext.Provider key={item.id} value={isHighlighted}> {renderItem(item)} </HighlightContext.Provider> ); })} approach, Row need receive isHighlighted prop all. Instead, reads context: export default function Row({ title }) { const isHighlighted = useContext(HighlightContext); // ... allows calling component know worry passing isHighlighted <Row> : <List items={products} renderItem={product => <Row title={product.title} /> } /> Instead, List Row coordinate highlighting logic context. import { useState } 'react'; import { HighlightContext } './HighlightContext.js'; export default function List({ items, renderItem }) { const [selectedIndex, setSelectedIndex] = useState(0); return ( <div className=\"List\"> {items.map((item, index) => { const isHighlighted = index === selectedIndex; return ( <HighlightContext.Provider key={item.id} value={isHighlighted} > {renderItem(item)} </HighlightContext.Provider> ); })} <hr /> <button onClick={() => { setSelectedIndex(i => (i + 1) % items.length ); }}> Next </button> </div> ); } Learn passing data context. Extracting logic custom Hook Another approach try extract \u201cnon-visual\u201d logic Hook, use information returned Hook decide render. example, could write useList custom Hook like this: import { useState } 'react'; export default function useList(items) { const [selectedIndex, setSelectedIndex] = useState(0); function onNext() { setSelectedIndex(i => (i + 1) % items.length ); } const selected = items[selectedIndex]; return [selected, onNext]; } could use like this: export default function App() { const [selected, onNext] = useList(products); return ( <div className=\"List\"> {products.map(product => <Row key={product.id} title={product.title} isHighlighted={selected === product} /> )} <hr /> <button onClick={onNext}> Next </button> </div> ); } data flow explicit, state inside useList custom Hook use component: import Row './Row.js'; import useList './useList.js'; import { products } './data.js'; export default function App() { const [selected, onNext] = useList(products); return ( <div className=\"List\"> {products.map(product => <Row key={product.id} title={product.title} isHighlighted={selected === product} /> )} <hr /> <button onClick={onNext}> Next </button> </div> ); } approach particularly useful want reuse logic different components."},
{"source": "https://react.dev/reference/react/components", "title": "Built-in React Components \u2013 React", "text": "Built-in React Components React exposes built-in components use JSX. Built-in components <Fragment> , alternatively written as<>...</> , lets group multiple JSX nodes together.<Profiler> lets measure rendering performance React tree programmatically.<Suspense> lets display fallback child components loading.<StrictMode> enables extra development-only checks help find bugs early. components also define components JavaScript functions."},
{"source": "https://react.dev/reference/react/createContext", "title": "createContext \u2013 React", "text": "createContext createContext lets create context components provide read. const SomeContext = createContext(defaultValue) Reference createContext(defaultValue) Call createContext outside components create context. import { createContext } 'react'; const ThemeContext = createContext('light'); Parameters defaultValue : value want context matching context provider tree component reads context. don\u2019t meaningful default value, specifynull . default value meant \u201clast resort\u201d fallback. static never changes time. Returns createContext returns context object. context object hold information. represents context components read provide. Typically, use SomeContext.Provider components specify context value, call useContext(SomeContext) components read it. context object properties: SomeContext.Provider lets provide context value components.SomeContext.Consumer alternative rarely used way read context value. SomeContext.Provider Wrap components context provider specify value context components inside: function App() { const [theme, setTheme] = useState('light'); // ... return ( <ThemeContext.Provider value={theme}> <Page /> </ThemeContext.Provider> ); } Props value : value want pass components reading context inside provider, matter deep. context value type. component callinguseContext(SomeContext) inside provider receives thevalue innermost corresponding context provider it. SomeContext.Consumer useContext existed, older way read context: function Button() { // \ud83d\udfe1 Legacy way (not recommended) return ( <ThemeContext.Consumer> {theme => ( <button className={theme} /> )} </ThemeContext.Consumer> ); } Although older way still works, newly written code read context useContext() instead: function Button() { // \u2705 Recommended way const theme = useContext(ThemeContext); return <button className={theme} />; } Props children : function. React call function pass current context value determined algorithm asuseContext() does, render result return function. React also re-run function update UI whenever context parent components changes. Usage Creating context Context lets components pass information deep without explicitly passing props. Call createContext outside components create one contexts. import { createContext } 'react'; const ThemeContext = createContext('light'); const AuthContext = createContext(null); createContext returns context object. Components read context passing useContext() : function Button() { const theme = useContext(ThemeContext); // ... } function Profile() { const currentUser = useContext(AuthContext); // ... } default, values receive default values specified creating contexts. However, isn\u2019t useful default values never change. Context useful provide other, dynamic values components: function App() { const [theme, setTheme] = useState('dark'); const [currentUser, setCurrentUser] = useState({ name: 'Taylor' }); // ... return ( <ThemeContext.Provider value={theme}> <AuthContext.Provider value={currentUser}> <Page /> </AuthContext.Provider> </ThemeContext.Provider> ); } Page component components inside it, matter deep, \u201csee\u201d passed context values. passed context values change, React re-render components reading context well. Read reading providing context see examples. Importing exporting context file Often, components different files need access context. it\u2019s common declare contexts separate file. use export statement make context available files: // Contexts.js import { createContext } 'react'; export const ThemeContext = createContext('light'); export const AuthContext = createContext(null); Components declared files use import statement read provide context: // Button.js import { ThemeContext } './Contexts.js'; function Button() { const theme = useContext(ThemeContext); // ... } // App.js import { ThemeContext, AuthContext } './Contexts.js'; function App() { // ... return ( <ThemeContext.Provider value={theme}> <AuthContext.Provider value={currentUser}> <Page /> </AuthContext.Provider> </ThemeContext.Provider> ); } works similar importing exporting components. Troubleshooting can\u2019t find way change context value Code like specifies default context value: const ThemeContext = createContext('light'); value never changes. React uses value fallback can\u2019t find matching provider above. make context change time, add state wrap components context provider."},
{"source": "https://react.dev/reference/react/createElement", "title": "createElement \u2013 React", "text": "createElement createElement lets create React element. serves alternative writing JSX. const element = createElement(type, props, ...children) Reference createElement(type, props, ...children) Call createElement create React element given type , props , children . import { createElement } 'react'; function Greeting({ name }) { return createElement( 'h1', { className: 'greeting' }, 'Hello' ); } Parameters - type : Thetype argument must valid React component type. example, could tag name string (such as'div' or'span' ), React component (a function, class, special component likeFragment ). - props : Theprops argument must either object ornull . passnull , treated empty object. React create element props matching theprops passed. Note thatref andkey yourprops object special available aselement.props.ref andelement.props.key returnedelement . available aselement.ref andelement.key . - optional ...children : Zero child nodes. React nodes, including React elements, strings, numbers, portals, empty nodes (null ,undefined ,true , andfalse ), arrays React nodes. Returns createElement returns React element object properties: type : Thetype passed.props : Theprops passed except forref andkey .ref : Theref passed. missing,null .key : Thekey passed, coerced string. missing,null . Usually, you\u2019ll return element component make child another element. Although may read element\u2019s properties, it\u2019s best treat every element opaque it\u2019s created, render it. Caveats - must treat React elements props immutable never change contents creation. development, React freeze returned element props property shallowly enforce this. - use JSX, must start tag capital letter render custom component. words, <Something /> equivalent tocreateElement(Something) , but<something /> (lowercase) equivalent tocreateElement('something') (note it\u2019s string, treated built-in HTML tag). - pass children multiple arguments createElement statically known, likecreateElement('h1', {}, child1, child2, child3) . children dynamic, pass entire array third argument:createElement('ul', {}, listItems) . ensures React warn missingkey dynamic lists. static lists necessary never reorder. Usage Creating element without JSX don\u2019t like JSX can\u2019t use project, use createElement alternative. create element without JSX, call createElement type, props, children: import { createElement } 'react'; function Greeting({ name }) { return createElement( 'h1', { className: 'greeting' }, 'Hello ', createElement('i', null, name), '. Welcome!' ); } children optional, pass many need (the example three children). code display <h1> header greeting. comparison, example rewritten JSX: function Greeting({ name }) { return ( <h1 className=\"greeting\"> Hello <i>{name}</i>. Welcome! </h1> ); } render React component, pass function like Greeting type instead string like 'h1' : export default function App() { return createElement(Greeting, { name: 'Taylor' }); } JSX, would look like this: export default function App() { return <Greeting name=\"Taylor\" />; } complete example written createElement : import { createElement } 'react'; function Greeting({ name }) { return createElement( 'h1', { className: 'greeting' }, 'Hello ', createElement('i', null, name), '. Welcome!' ); } export default function App() { return createElement( Greeting, { name: 'Taylor' } ); } example written using JSX: function Greeting({ name }) { return ( <h1 className=\"greeting\"> Hello <i>{name}</i>. Welcome! </h1> ); } export default function App() { return <Greeting name=\"Taylor\" />; } coding styles fine, use whichever one prefer project. main benefit using JSX compared createElement it\u2019s easy see closing tag corresponds opening tag. Deep Dive element lightweight description piece user interface. example, <Greeting name=\"Taylor\" /> createElement(Greeting, { name: 'Taylor' }) produce object like this: // Slightly simplified { type: Greeting, props: { name: 'Taylor' }, key: null, ref: null, } Note creating object render Greeting component create DOM elements. React element like description\u2014an instruction React later render Greeting component. returning object App component, tell React next. Creating elements extremely cheap don\u2019t need try optimize avoid it."},
{"source": "https://react.dev/reference/react/createFactory", "title": "createFactory \u2013 React", "text": "createFactory createFactory lets create function produces React elements given type. const factory = createFactory(type) Reference createFactory(type) Call createFactory(type) create factory function produces React elements given type . import { createFactory } 'react'; const button = createFactory('button'); use create React elements without JSX: export default function App() { return button({ onClick: () => { alert('Clicked!') } }, 'Click me'); } Parameters type : Thetype argument must valid React component type. example, could tag name string (such as'div' or'span' ), React component (a function, class, special component likeFragment ). Returns Returns factory function. factory function receives props object first argument, followed list ...children arguments, returns React element given type , props children . Usage Creating React elements factory Although React projects use JSX describe user interface, JSX required. past, createFactory used one ways could describe user interface without JSX. Call createFactory create factory function specific element type like 'button' : import { createFactory } 'react'; const button = createFactory('button'); Calling factory function produce React elements props children provided: import { createFactory } 'react'; const button = createFactory('button'); export default function App() { return button({ onClick: () => { alert('Clicked!') } }, 'Click me'); } createFactory used alternative JSX. However, createFactory deprecated, call createFactory new code. See migrate away createFactory below. Alternatives Copying createFactory project project many createFactory calls, copy createFactory.js implementation project: import { createFactory } './createFactory.js'; const button = createFactory('button'); export default function App() { return button({ onClick: () => { alert('Clicked!') } }, 'Click me'); } lets keep code unchanged except imports. Replacing createFactory createElement createFactory calls don\u2019t mind porting manually, don\u2019t want use JSX, replace every call factory function createElement call. example, replace code: import { createFactory } 'react'; const button = createFactory('button'); export default function App() { return button({ onClick: () => { alert('Clicked!') } }, 'Click me'); } code: import { createElement } 'react'; export default function App() { return createElement('button', { onClick: () => { alert('Clicked!') } }, 'Click me'); } complete example using React without JSX: import { createElement } 'react'; export default function App() { return createElement('button', { onClick: () => { alert('Clicked!') } }, 'Click me'); } Replacing createFactory JSX Finally, use JSX instead createFactory . common way use React: export default function App() { return ( <button onClick={() => { alert('Clicked!'); }}> Click </button> ); };"},
{"source": "https://react.dev/reference/react/createRef", "title": "createRef \u2013 React", "text": "createRef createRef creates ref object contain arbitrary value. class MyInput extends Component { inputRef = createRef(); // ... } Reference createRef() Call createRef declare ref inside class component. import { createRef, Component } 'react'; class MyComponent extends Component { intervalRef = createRef(); inputRef = createRef(); // ... Parameters createRef takes parameters. Returns createRef returns object single property: current : Initially, it\u2019s set thenull . later set something else. pass ref object React aref attribute JSX node, React set itscurrent property. Caveats createRef always returns different object. It\u2019s equivalent writing{ current: null } yourself.- function component, probably want useRef instead always returns object. const ref = useRef() equivalent toconst [ref, _] = useState(() => createRef(null)) . Usage Declaring ref class component declare ref inside class component, call createRef assign result class field: import { Component, createRef } 'react'; class Form extends Component { inputRef = createRef(); // ... } pass ref={this.inputRef} <input> JSX, React populate this.inputRef.current input DOM node. example, make button focuses input: import { Component, createRef } 'react'; export default class Form extends Component { inputRef = createRef(); handleClick = () => { this.inputRef.current.focus(); } render() { return ( <> <input ref={this.inputRef} /> <button onClick={this.handleClick}> Focus input </button> </> ); } } Alternatives Migrating class createRef function useRef recommend using function components instead class components new code. existing class components using createRef , convert them. original code: import { Component, createRef } 'react'; export default class Form extends Component { inputRef = createRef(); handleClick = () => { this.inputRef.current.focus(); } render() { return ( <> <input ref={this.inputRef} /> <button onClick={this.handleClick}> Focus input </button> </> ); } } convert component class function, replace calls createRef calls useRef : import { useRef } 'react'; export default function Form() { const inputRef = useRef(null); function handleClick() { inputRef.current.focus(); } return ( <> <input ref={inputRef} /> <button onClick={handleClick}> Focus input </button> </> ); }"},
{"source": "https://react.dev/reference/react/experimental_taintObjectReference", "title": "experimental_taintObjectReference \u2013 React", "text": "experimental_taintObjectReference taintObjectReference lets prevent specific object instance passed Client Component like user object. experimental_taintObjectReference(message, object); prevent passing key, hash token, see taintUniqueValue . Reference taintObjectReference(message, object) Call taintObjectReference object register React something allowed passed Client is: import {experimental_taintObjectReference} 'react'; experimental_taintObjectReference( 'Do pass environment variables client.', process.env ); Parameters - message : message want display object gets passed Client Component. message displayed part Error thrown object gets passed Client Component. - object : object tainted. Functions class instances passed totaintObjectReference asobject . Functions classes already blocked passed Client Components React\u2019s default error message replaced defined inmessage . specific instance Typed Array passed totaintObjectReference asobject , copies Typed Array tainted. Returns experimental_taintObjectReference returns undefined . Caveats - Recreating cloning tainted object creates new untainted object may contain sensitive data. example, tainted user object,const userInfo = {name: user.name, ssn: user.ssn} or{...user} create new objects tainted.taintObjectReference protects simple mistakes object passed Client Component unchanged. Usage Prevent user data unintentionally reaching client Client Component never accept objects carry sensitive data. Ideally, data fetching functions expose data current user access to. Sometimes mistakes happen refactoring. protect mistakes happening line \u201ctaint\u201d user object data API. import {experimental_taintObjectReference} 'react'; export async function getUser(id) { const user = await db`SELECT * users id = ${id}`; experimental_taintObjectReference( 'Do pass entire user object client. ' + 'Instead, pick specific properties need use case.', user, ); return user; } whenever anyone tries pass object Client Component, error thrown passed error message instead. Deep Dive you\u2019re running Server Components environment access sensitive data, careful pass objects straight through: // api.js export async function getUser(id) { const user = await db`SELECT * users id = ${id}`; return user; } import { getUser } 'api.js'; import { InfoCard } 'components.js'; export async function Profile(props) { const user = await getUser(props.userId); // return <InfoCard user={user} />; } // components.js \"use client\"; export async function InfoCard({ user }) { return <div>{user.name}</div>; } Ideally, getUser expose data current user access to. prevent passing user object Client Component line \u201ctaint\u201d user object: // api.js import {experimental_taintObjectReference} 'react'; export async function getUser(id) { const user = await db`SELECT * users id = ${id}`; experimental_taintObjectReference( 'Do pass entire user object client. ' + 'Instead, pick specific properties need use case.', user, ); return user; } anyone tries pass user object Client Component, error thrown passed error message."},
{"source": "https://react.dev/reference/react/experimental_taintUniqueValue", "title": "experimental_taintUniqueValue \u2013 React", "text": "experimental_taintUniqueValue taintUniqueValue lets prevent unique values passed Client Components like passwords, keys, tokens. taintUniqueValue(errMessage, lifetime, value) prevent passing object containing sensitive data, see taintObjectReference . Reference taintUniqueValue(message, lifetime, value) Call taintUniqueValue password, token, key hash register React something allowed passed Client is: import {experimental_taintUniqueValue} 'react'; experimental_taintUniqueValue( 'Do pass secret keys client.', process, process.env.SECRET_KEY ); Parameters - message : message want display ifvalue passed Client Component. message displayed part Error thrown ifvalue passed Client Component. - lifetime : object indicates longvalue tainted.value blocked sent Client Component object still exists. example, passingglobalThis blocks value lifetime app.lifetime typically object whose properties containsvalue . - value : string, bigint TypedArray.value must unique sequence characters bytes high entropy cryptographic token, private key, hash, long password.value blocked sent Client Component. Returns experimental_taintUniqueValue returns undefined . Caveats - Deriving new values tainted values compromise tainting protection. New values created uppercasing tainted values, concatenating tainted string values larger string, converting tainted values base64, substringing tainted values, similar transformations tainted unless explicitly call taintUniqueValue newly created values. - use taintUniqueValue protect low-entropy values PIN codes phone numbers. value request controlled attacker, could infer value tainted enumerating possible values secret. Usage Prevent token passed Client Components ensure sensitive information passwords, session tokens, unique values inadvertently get passed Client Components, taintUniqueValue function provides layer protection. value tainted, attempt pass Client Component result error. lifetime argument defines duration value remains tainted. values remain tainted indefinitely, objects like globalThis process serve lifetime argument. objects lifespan spans entire duration app\u2019s execution. import {experimental_taintUniqueValue} 'react'; experimental_taintUniqueValue( 'Do pass user password client.', globalThis, process.env.SECRET_KEY ); tainted value\u2019s lifespan tied object, lifetime object encapsulates value. ensures tainted value remains protected lifetime encapsulating object. import {experimental_taintUniqueValue} 'react'; export async function getUser(id) { const user = await db`SELECT * users id = ${id}`; experimental_taintUniqueValue( 'Do pass user session token client.', user, user.session.token ); return user; } example, user object serves lifetime argument. object gets stored global cache accessible another request, session token remains tainted. Deep Dive you\u2019re running Server Components environment access private keys passwords database passwords, careful pass Client Component. export async function Dashboard(props) { // return <Overview password={process.env.API_PASSWORD} />; } \"use client\"; import {useEffect} '...' export async function Overview({ password }) { useEffect(() => { const headers = { Authorization: password }; fetch(url, { headers }).then(...); }, [password]); ... } example would leak secret API token client. API token used access data particular user shouldn\u2019t access to, could lead data breach. Ideally, secrets like abstracted single helper file imported trusted data utilities server. helper even tagged server-only ensure file isn\u2019t imported client. import \"server-only\"; export function fetchAPI(url) { const headers = { Authorization: process.env.API_PASSWORD }; return fetch(url, { headers }); } Sometimes mistakes happen refactoring colleagues might know this. protect mistakes happening line \u201ctaint\u201d actual password: import \"server-only\"; import {experimental_taintUniqueValue} 'react'; experimental_taintUniqueValue( 'Do pass API token password client. ' + 'Instead fetches server.' process, process.env.API_PASSWORD ); whenever anyone tries pass password Client Component, send password Client Component Server Function, error thrown message defined called taintUniqueValue ."},
{"source": "https://react.dev/reference/react/experimental_useEffectEvent", "title": "experimental_useEffectEvent \u2013 React", "text": "experimental_useEffectEvent useEffectEvent React Hook lets extract non-reactive logic Effect Event. const onSomething = useEffectEvent(callback) API experimental available stable version React yet. try upgrading React packages recent experimental version: react@experimental react-dom@experimental eslint-plugin-react-hooks@experimental Experimental versions React may contain bugs. Don\u2019t use production. useEffectEvent React Hook lets extract non-reactive logic Effect Event. const onSomething = useEffectEvent(callback)"},
{"source": "https://react.dev/reference/react/forwardRef", "title": "forwardRef \u2013 React", "text": "forwardRef forwardRef lets component expose DOM node parent component ref. const SomeComponent = forwardRef(render) Reference forwardRef(render) Call forwardRef() let component receive ref forward child component: import { forwardRef } 'react'; const MyInput = forwardRef(function MyInput(props, ref) { // ... }); Parameters render : render function component. React calls function props andref component received parent. JSX return output component. Returns forwardRef returns React component render JSX. Unlike React components defined plain functions, component returned forwardRef also able receive ref prop. Caveats - Strict Mode, React call render function twice order help find accidental impurities. development-only behavior affect production. render function pure (as be), affect logic component. result one calls ignored. render function forwardRef accepts render function argument. React calls function props ref : const MyInput = forwardRef(function MyInput(props, ref) { return ( <label> {props.label} <input ref={ref} /> </label> ); }); Parameters - props : props passed parent component. - ref : Theref attribute passed parent component. Theref object function. parent component passed ref, benull . either pass theref receive another component, pass touseImperativeHandle . Returns forwardRef returns React component render JSX. Unlike React components defined plain functions, component returned forwardRef able take ref prop. Usage Exposing DOM node parent component default, component\u2019s DOM nodes private. However, sometimes it\u2019s useful expose DOM node parent\u2014for example, allow focusing it. opt in, wrap component definition forwardRef() : import { forwardRef } 'react'; const MyInput = forwardRef(function MyInput(props, ref) { const { label, ...otherProps } = props; return ( <label> {label} <input {...otherProps} /> </label> ); }); receive ref second argument props. Pass DOM node want expose: import { forwardRef } 'react'; const MyInput = forwardRef(function MyInput(props, ref) { const { label, ...otherProps } = props; return ( <label> {label} <input {...otherProps} ref={ref} /> </label> ); }); lets parent Form component access <input> DOM node exposed MyInput : function Form() { const ref = useRef(null); function handleClick() { ref.current.focus(); } return ( <form> <MyInput label=\"Enter name:\" ref={ref} /> <button type=\"button\" onClick={handleClick}> Edit </button> </form> ); } Form component passes ref MyInput . MyInput component forwards ref <input> browser tag. result, Form component access <input> DOM node call focus() it. Keep mind exposing ref DOM node inside component makes harder change component\u2019s internals later. typically expose DOM nodes reusable low-level components like buttons text inputs, won\u2019t application-level components like avatar comment. Example 1 2: Focusing text input Clicking button focus input. Form component defines ref passes MyInput component. MyInput component forwards ref browser <input> . lets Form component focus <input> . import { useRef } 'react'; import MyInput './MyInput.js'; export default function Form() { const ref = useRef(null); function handleClick() { ref.current.focus(); } return ( <form> <MyInput label=\"Enter name:\" ref={ref} /> <button type=\"button\" onClick={handleClick}> Edit </button> </form> ); } Forwarding ref multiple components Instead forwarding ref DOM node, forward component like MyInput : const FormField = forwardRef(function FormField(props, ref) { // ... return ( <> <MyInput ref={ref} /> ... </> ); }); MyInput component forwards ref <input> , ref FormField give <input> : function Form() { const ref = useRef(null); function handleClick() { ref.current.focus(); } return ( <form> <FormField label=\"Enter name:\" ref={ref} isRequired={true} /> <button type=\"button\" onClick={handleClick}> Edit </button> </form> ); } Form component defines ref passes FormField . FormField component forwards ref MyInput , forwards browser <input> DOM node. Form accesses DOM node. import { useRef } 'react'; import FormField './FormField.js'; export default function Form() { const ref = useRef(null); function handleClick() { ref.current.focus(); } return ( <form> <FormField label=\"Enter name:\" ref={ref} isRequired={true} /> <button type=\"button\" onClick={handleClick}> Edit </button> </form> ); } Exposing imperative handle instead DOM node Instead exposing entire DOM node, expose custom object, called imperative handle, constrained set methods. this, you\u2019d need define separate ref hold DOM node: const MyInput = forwardRef(function MyInput(props, ref) { const inputRef = useRef(null); // ... return <input {...props} ref={inputRef} />; }); Pass ref received useImperativeHandle specify value want expose ref : import { forwardRef, useRef, useImperativeHandle } 'react'; const MyInput = forwardRef(function MyInput(props, ref) { const inputRef = useRef(null); useImperativeHandle(ref, () => { return { focus() { inputRef.current.focus(); }, scrollIntoView() { inputRef.current.scrollIntoView(); }, }; }, []); return <input {...props} ref={inputRef} />; }); component gets ref MyInput , receive { focus, scrollIntoView } object instead DOM node. lets limit information expose DOM node minimum. import { useRef } 'react'; import MyInput './MyInput.js'; export default function Form() { const ref = useRef(null); function handleClick() { ref.current.focus(); // work DOM node exposed: // ref.current.style.opacity = 0.5; } return ( <form> <MyInput placeholder=\"Enter name\" ref={ref} /> <button type=\"button\" onClick={handleClick}> Edit </button> </form> ); } Read using imperative handles. Troubleshooting component wrapped forwardRef , ref always null usually means forgot actually use ref received. example, component doesn\u2019t anything ref : const MyInput = forwardRef(function MyInput({ label }, ref) { return ( <label> {label} <input /> </label> ); }); fix it, pass ref DOM node another component accept ref: const MyInput = forwardRef(function MyInput({ label }, ref) { return ( <label> {label} <input ref={ref} /> </label> ); }); ref MyInput could also null logic conditional: const MyInput = forwardRef(function MyInput({ label, showInput }, ref) { return ( <label> {label} {showInput && <input ref={ref} />} </label> ); }); showInput false , ref won\u2019t forwarded node, ref MyInput remain empty. particularly easy miss condition hidden inside another component, like Panel example: const MyInput = forwardRef(function MyInput({ label, showInput }, ref) { return ( <label> {label} <Panel isExpanded={showInput}> <input ref={ref} /> </Panel> </label> ); });"},
{"source": "https://react.dev/reference/react/hooks", "title": "Built-in React Hooks \u2013 React", "text": "Built-in React Hooks Hooks let use different React features components. either use built-in Hooks combine build own. page lists built-in Hooks React. State Hooks State lets component \u201cremember\u201d information like user input. example, form component use state store input value, image gallery component use state store selected image index. add state component, use one Hooks: useState declares state variable update directly.useReducer declares state variable update logic inside reducer function. function ImageGallery() { const [index, setIndex] = useState(0); // ... Context Hooks Context lets component receive information distant parents without passing props. example, app\u2019s top-level component pass current UI theme components below, matter deep. useContext reads subscribes context. function Button() { const theme = useContext(ThemeContext); // ... Ref Hooks Refs let component hold information isn\u2019t used rendering, like DOM node timeout ID. Unlike state, updating ref re-render component. Refs \u201cescape hatch\u201d React paradigm. useful need work non-React systems, built-in browser APIs. useRef declares ref. hold value it, often it\u2019s used hold DOM node.useImperativeHandle lets customize ref exposed component. rarely used. function Form() { const inputRef = useRef(null); // ... Effect Hooks Effects let component connect synchronize external systems. includes dealing network, browser DOM, animations, widgets written using different UI library, non-React code. useEffect connects component external system. function ChatRoom({ roomId }) { useEffect(() => { const connection = createConnection(roomId); connection.connect(); return () => connection.disconnect(); }, [roomId]); // ... Effects \u201cescape hatch\u201d React paradigm. Don\u2019t use Effects orchestrate data flow application. you\u2019re interacting external system, might need Effect. two rarely used variations useEffect differences timing: useLayoutEffect fires browser repaints screen. measure layout here.useInsertionEffect fires React makes changes DOM. Libraries insert dynamic CSS here. Performance Hooks common way optimize re-rendering performance skip unnecessary work. example, tell React reuse cached calculation skip re-render data changed since previous render. skip calculations unnecessary re-rendering, use one Hooks: useMemo lets cache result expensive calculation.useCallback lets cache function definition passing optimized component. function TodoList({ todos, tab, theme }) { const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]); // ... } Sometimes, can\u2019t skip re-rendering screen actually needs update. case, improve performance separating blocking updates must synchronous (like typing input) non-blocking updates don\u2019t need block user interface (like updating chart). prioritize rendering, use one Hooks: useTransition lets mark state transition non-blocking allow updates interrupt it.useDeferredValue lets defer updating non-critical part UI let parts update first. Hooks Hooks mostly useful library authors aren\u2019t commonly used application code. useDebugValue lets customize label React DevTools displays custom Hook.useId lets component associate unique ID itself. Typically used accessibility APIs.useSyncExternalStore lets component subscribe external store. useActionState allows manage state actions. Hooks also define custom Hooks JavaScript functions."},
{"source": "https://react.dev/reference/react/isValidElement", "title": "isValidElement \u2013 React", "text": "isValidElement isValidElement checks whether value React element. const isElement = isValidElement(value) Reference isValidElement(value) Call isValidElement(value) check whether value React element. import { isValidElement, createElement } 'react'; // \u2705 React elements console.log(isValidElement(<p />)); // true console.log(isValidElement(createElement('p'))); // true // \u274c React elements console.log(isValidElement(25)); // false console.log(isValidElement('Hello')); // false console.log(isValidElement({ age: 42 })); // false Parameters value : Thevalue want check. value type. Returns isValidElement returns true value React element. Otherwise, returns false . Caveats - JSX tags objects returned createElement considered React elements. example, even though number like42 valid React node (and returned component), valid React element. Arrays portals created withcreatePortal also considered React elements. Usage Checking something React element Call isValidElement check value React element. React elements are: - Values produced writing JSX tag - Values produced calling createElement React elements, isValidElement returns true : import { isValidElement, createElement } 'react'; // \u2705 JSX tags React elements console.log(isValidElement(<p />)); // true console.log(isValidElement(<MyComponent />)); // true // \u2705 Values returned createElement React elements console.log(isValidElement(createElement('p'))); // true console.log(isValidElement(createElement(MyComponent))); // true values, strings, numbers, arbitrary objects arrays, React elements. them, isValidElement returns false : // \u274c *not* React elements console.log(isValidElement(null)); // false console.log(isValidElement(25)); // false console.log(isValidElement('Hello')); // false console.log(isValidElement({ age: 42 })); // false console.log(isValidElement([<div />, <div />])); // false console.log(isValidElement(MyComponent)); // false uncommon need isValidElement . It\u2019s mostly useful you\u2019re calling another API accepts elements (like cloneElement does) want avoid error argument React element. Unless specific reason add isValidElement check, probably don\u2019t need it. Deep Dive write component, return kind React node it: function MyComponent() { // ... return React node ... } React node be: - React element created like <div /> orcreateElement('div') - portal created createPortal - string - number true ,false ,null , orundefined (which displayed)- array React nodes Note isValidElement checks whether argument React element, whether it\u2019s React node. example, 42 valid React element. However, perfectly valid React node: function MyComponent() { return 42; // ok return number component } shouldn\u2019t use isValidElement way check whether something rendered."},
{"source": "https://react.dev/reference/react/lazy", "title": "lazy \u2013 React", "text": "lazy lets defer loading component\u2019s code rendered first time. const SomeComponent = lazy(load) Reference lazy(load) Call lazy outside components declare lazy-loaded React component: import { lazy } 'react'; const MarkdownPreview = lazy(() => import('./MarkdownPreview.js')); Parameters load : function returns Promise another thenable (a Promise-like object athen method). React callload first time attempt render returned component. React first callsload , wait resolve, render resolved value\u2019s.default React component. returned Promise Promise\u2019s resolved value cached, React callload once. Promise rejects, React willthrow rejection reason nearest Error Boundary handle. Returns lazy returns React component render tree. code lazy component still loading, attempting render suspend. Use <Suspense> display loading indicator it\u2019s loading. load function Parameters load receives parameters. Returns need return Promise thenable (a Promise-like object method). needs eventually resolve object whose .default property valid React component type, function, memo , forwardRef component. Usage Lazy-loading components Suspense Usually, import components static import declaration: import MarkdownPreview './MarkdownPreview.js'; defer loading component\u2019s code it\u2019s rendered first time, replace import with: import { lazy } 'react'; const MarkdownPreview = lazy(() => import('./MarkdownPreview.js')); code relies dynamic import() , might require support bundler framework. Using pattern requires lazy component you\u2019re importing exported default export. component\u2019s code loads demand, also need specify displayed loading. wrapping lazy component parents <Suspense> boundary: <Suspense fallback={<Loading />}> <h2>Preview</h2> <MarkdownPreview /> </Suspense> example, code MarkdownPreview won\u2019t loaded attempt render it. MarkdownPreview hasn\u2019t loaded yet, Loading shown place. Try ticking checkbox: import { useState, Suspense, lazy } 'react'; import Loading './Loading.js'; const MarkdownPreview = lazy(() => delayForDemo(import('./MarkdownPreview.js'))); export default function MarkdownEditor() { const [showPreview, setShowPreview] = useState(false); const [markdown, setMarkdown] = useState('Hello, **world**!'); return ( <> <textarea value={markdown} onChange={e => setMarkdown(e.target.value)} /> <label> <input type=\"checkbox\" checked={showPreview} onChange={e => setShowPreview(e.target.checked)} /> Show preview </label> <hr /> {showPreview && ( <Suspense fallback={<Loading />}> <h2>Preview</h2> <MarkdownPreview markdown={markdown} /> </Suspense> )} </> ); } // Add fixed delay see loading state function delayForDemo(promise) { return new Promise(resolve => { setTimeout(resolve, 2000); }).then(() => promise); } demo loads artificial delay. next time untick tick checkbox, Preview cached, loading state. see loading state again, click \u201cReset\u201d sandbox. Learn managing loading states Suspense. Troubleshooting lazy component\u2019s state gets reset unexpectedly declare lazy components inside components: import { lazy } 'react'; function Editor() { // \ud83d\udd34 Bad: cause state reset re-renders const MarkdownPreview = lazy(() => import('./MarkdownPreview.js')); // ... } Instead, always declare top level module: import { lazy } 'react'; // \u2705 Good: Declare lazy components outside components const MarkdownPreview = lazy(() => import('./MarkdownPreview.js')); function Editor() { // ... }"},
{"source": "https://react.dev/reference/react/legacy", "title": "Legacy React APIs \u2013 React", "text": "Legacy React APIs APIs exported react package, recommended use newly written code. See linked individual API pages suggested alternatives. Legacy APIs Children lets manipulate transform JSX received thechildren prop. See alternatives.cloneElement lets create React element using another element starting point. See alternatives.Component lets define React component JavaScript class. See alternatives.createElement lets create React element. Typically, you\u2019ll use JSX instead.createRef creates ref object contain arbitrary value. See alternatives.forwardRef lets component expose DOM node parent component ref.isValidElement checks whether value React element. Typically used withcloneElement .PureComponent similar toComponent , skip re-renders props. See alternatives. Removed APIs APIs removed React 19: createFactory : use JSX instead.- Class Components: static contextTypes : usestatic contextType instead. - Class Components: static childContextTypes : usestatic contextType instead. - Class Components: static getChildContext : useContext.Provider instead. - Class Components: static propTypes : use type system like TypeScript instead. - Class Components: this.refs : usecreateRef instead."},
{"source": "https://react.dev/reference/react/memo", "title": "memo \u2013 React", "text": "memo lets skip re-rendering component props unchanged. const MemoizedComponent = memo(SomeComponent, arePropsEqual?) Reference memo(Component, arePropsEqual?) Wrap component memo get memoized version component. memoized version component usually re-rendered parent component re-rendered long props changed. React may still re-render it: memoization performance optimization, guarantee. import { memo } 'react'; const SomeComponent = memo(function SomeComponent(props) { // ... }); Parameters - Component : component want memoize. Thememo modify component, returns new, memoized component instead. valid React component, including functions andforwardRef components, accepted. - optional arePropsEqual : function accepts two arguments: component\u2019s previous props, new props. returntrue old new props equal: is, component render output behave way new props old. Otherwise returnfalse . Usually, specify function. default, React compare prop withObject.is . Returns memo returns new React component. behaves component provided memo except React always re-render parent re-rendered unless props changed. Usage Skipping re-rendering props unchanged React normally re-renders component whenever parent re-renders. memo , create component React re-render parent re-renders long new props old props. component said memoized. memoize component, wrap memo use value returns place original component: const Greeting = memo(function Greeting({ name }) { return <h1>Hello, {name}!</h1>; }); export default Greeting; React component always pure rendering logic. means must return output props, state, context haven\u2019t changed. using memo , telling React component complies requirement, React doesn\u2019t need re-render long props haven\u2019t changed. Even memo , component re-render state changes context it\u2019s using changes. example, notice Greeting component re-renders whenever name changed (because that\u2019s one props), address changed (because it\u2019s passed Greeting prop): import { memo, useState } 'react'; export default function MyApp() { const [name, setName] = useState(''); const [address, setAddress] = useState(''); return ( <> <label> Name{': '} <input value={name} onChange={e => setName(e.target.value)} /> </label> <label> Address{': '} <input value={address} onChange={e => setAddress(e.target.value)} /> </label> <Greeting name={name} /> </> ); } const Greeting = memo(function Greeting({ name }) { console.log(\"Greeting rendered at\", new Date().toLocaleTimeString()); return <h3>Hello{name && ', '}{name}!</h3>; }); Deep Dive app like site, interactions coarse (like replacing page entire section), memoization usually unnecessary. hand, app like drawing editor, interactions granular (like moving shapes), might find memoization helpful. Optimizing memo valuable component re-renders often exact props, re-rendering logic expensive. perceptible lag component re-renders, memo unnecessary. Keep mind memo completely useless props passed component always different, pass object plain function defined rendering. often need useMemo useCallback together memo . benefit wrapping component memo cases. significant harm either, teams choose think individual cases, memoize much possible. downside approach code becomes less readable. Also, memoization effective: single value that\u2019s \u201calways new\u201d enough break memoization entire component. practice, make lot memoization unnecessary following principles: - component visually wraps components, let accept JSX children. way, wrapper component updates state, React knows children don\u2019t need re-render. - Prefer local state don\u2019t lift state necessary. example, don\u2019t keep transient state like forms whether item hovered top tree global state library. - Keep rendering logic pure. re-rendering component causes problem produces noticeable visual artifact, it\u2019s bug component! Fix bug instead adding memoization. - Avoid unnecessary Effects update state. performance problems React apps caused chains updates originating Effects cause components render over. - Try remove unnecessary dependencies Effects. example, instead memoization, it\u2019s often simpler move object function inside Effect outside component. specific interaction still feels laggy, use React Developer Tools profiler see components would benefit memoization, add memoization needed. principles make components easier debug understand, it\u2019s good follow case. long term, we\u2019re researching granular memoization automatically solve all. Updating memoized component using state Even component memoized, still re-render state changes. Memoization props passed component parent. import { memo, useState } 'react'; export default function MyApp() { const [name, setName] = useState(''); const [address, setAddress] = useState(''); return ( <> <label> Name{': '} <input value={name} onChange={e => setName(e.target.value)} /> </label> <label> Address{': '} <input value={address} onChange={e => setAddress(e.target.value)} /> </label> <Greeting name={name} /> </> ); } const Greeting = memo(function Greeting({ name }) { console.log('Greeting rendered at', new Date().toLocaleTimeString()); const [greeting, setGreeting] = useState('Hello'); return ( <> <h3>{greeting}{name && ', '}{name}!</h3> <GreetingSelector value={greeting} onChange={setGreeting} /> </> ); }); function GreetingSelector({ value, onChange }) { return ( <> <label> <input type=\"radio\" checked={value === 'Hello'} onChange={e => onChange('Hello')} /> Regular greeting </label> <label> <input type=\"radio\" checked={value === 'Hello welcome'} onChange={e => onChange('Hello welcome')} /> Enthusiastic greeting </label> </> ); } set state variable current value, React skip re-rendering component even without memo . may still see component function called extra time, result discarded. Updating memoized component using context Even component memoized, still re-render context it\u2019s using changes. Memoization props passed component parent. import { createContext, memo, useContext, useState } 'react'; const ThemeContext = createContext(null); export default function MyApp() { const [theme, setTheme] = useState('dark'); function handleClick() { setTheme(theme === 'dark' ? 'light' : 'dark'); } return ( <ThemeContext.Provider value={theme}> <button onClick={handleClick}> Switch theme </button> <Greeting name=\"Taylor\" /> </ThemeContext.Provider> ); } const Greeting = memo(function Greeting({ name }) { console.log(\"Greeting rendered at\", new Date().toLocaleTimeString()); const theme = useContext(ThemeContext); return ( <h3 className={theme}>Hello, {name}!</h3> ); }); make component re-render part context changes, split component two. Read need context outer component, pass memoized child prop. Minimizing props changes use memo , component re-renders whenever prop shallowly equal previously. means React compares every prop component previous value using Object.is comparison. Note Object.is(3, 3) true , Object.is({}, {}) false . get memo , minimize times props change. example, prop object, prevent parent component re-creating object every time using useMemo : function Page() { const [name, setName] = useState('Taylor'); const [age, setAge] = useState(42); const person = useMemo( () => ({ name, age }), [name, age] ); return <Profile person={person} />; } const Profile = memo(function Profile({ person }) { // ... }); better way minimize props changes make sure component accepts minimum necessary information props. example, could accept individual values instead whole object: function Page() { const [name, setName] = useState('Taylor'); const [age, setAge] = useState(42); return <Profile name={name} age={age} />; } const Profile = memo(function Profile({ name, age }) { // ... }); Even individual values sometimes projected ones change less frequently. example, component accepts boolean indicating presence value rather value itself: function GroupsLanding({ person }) { const hasGroups = person.groups !== null; return <CallToAction hasGroups={hasGroups} />; } const CallToAction = memo(function CallToAction({ hasGroups }) { // ... }); need pass function memoized component, either declare outside component never changes, useCallback cache definition re-renders. Specifying custom comparison function rare cases may infeasible minimize props changes memoized component. case, provide custom comparison function, React use compare old new props instead using shallow equality. function passed second argument memo . return true new props would result output old props; otherwise return false . const Chart = memo(function Chart({ dataPoints }) { // ... }, arePropsEqual); function arePropsEqual(oldProps, newProps) { return ( oldProps.dataPoints.length === newProps.dataPoints.length && oldProps.dataPoints.every((oldPoint, index) => { const newPoint = newProps.dataPoints[index]; return oldPoint.x === newPoint.x && oldPoint.y === newPoint.y; }) ); } this, use Performance panel browser developer tools make sure comparison function actually faster re-rendering component. might surprised. performance measurements, make sure React running production mode. Troubleshooting component re-renders prop object, array, function React compares old new props shallow equality: is, considers whether new prop reference-equal old prop. create new object array time parent re-rendered, even individual elements same, React still consider changed. Similarly, create new function rendering parent component, React consider changed even function definition. avoid this, simplify props memoize props parent component."},
{"source": "https://react.dev/reference/react/startTransition", "title": "startTransition \u2013 React", "text": "startTransition startTransition lets render part UI background. startTransition(action) Reference startTransition(action) startTransition function lets mark state update Transition. import { startTransition } 'react'; function TabContainer() { const [tab, setTab] = useState('about'); function selectTab(nextTab) { startTransition(() => { setTab(nextTab); }); } // ... } Parameters action : function updates state calling one moreset functions. React callsaction immediately parameters marks state updates scheduled synchronously theaction function call Transitions. async calls awaited theaction included transition, currently require wrapping anyset functions theawait additionalstartTransition (see Troubleshooting). State updates marked Transitions non-blocking display unwanted loading indicators.. Returns startTransition return anything. Caveats - startTransition provide way track whether Transition pending. show pending indicator Transition ongoing, needuseTransition instead. - wrap update Transition access set function state. want start Transition response prop custom Hook return value, tryuseDeferredValue instead. - function pass startTransition called immediately, marking state updates happen executes Transitions. try perform state updates asetTimeout , example, won\u2019t marked Transitions. - must wrap state updates async requests another startTransition mark Transitions. known limitation fix future (see Troubleshooting). - state update marked Transition interrupted state updates. example, update chart component inside Transition, start typing input chart middle re-render, React restart rendering work chart component handling input state update. - Transition updates can\u2019t used control text inputs. - multiple ongoing Transitions, React currently batches together. limitation may removed future release. Usage Marking state update non-blocking Transition mark state update Transition wrapping startTransition call: import { startTransition } 'react'; function TabContainer() { const [tab, setTab] = useState('about'); function selectTab(nextTab) { startTransition(() => { setTab(nextTab); }); } // ... } Transitions let keep user interface updates responsive even slow devices. Transition, UI stays responsive middle re-render. example, user clicks tab change mind click another tab, without waiting first re-render finish."},
{"source": "https://react.dev/reference/react/use", "title": "use \u2013 React", "text": "use React API lets read value resource like Promise context. const value = use(resource); Reference use(resource) Call use component read value resource like Promise context. import { use } 'react'; function MessageComponent({ messagePromise }) { const message = use(messagePromise); const theme = use(ThemeContext); // ... Unlike React Hooks, use called within loops conditional statements like . Like React Hooks, function calls use must Component Hook. called Promise, use API integrates Suspense error boundaries. component calling use suspends Promise passed use pending. component calls use wrapped Suspense boundary, fallback displayed. Promise resolved, Suspense fallback replaced rendered components using data returned use API. Promise passed use rejected, fallback nearest Error Boundary displayed. Parameters resource : source data want read value from. resource Promise context. Returns use API returns value read resource like resolved value Promise context. Caveats - use API must called inside Component Hook. - fetching data Server Component, prefer async andawait overuse .async andawait pick rendering point whereawait invoked, whereasuse re-renders component data resolved. - Prefer creating Promises Server Components passing Client Components creating Promises Client Components. Promises created Client Components recreated every render. Promises passed Server Component Client Component stable across re-renders. See example. Usage Reading context use context passed use , works similarly useContext . useContext must called top level component, use called inside conditionals like loops like . use preferred useContext flexible. import { use } 'react'; function Button() { const theme = use(ThemeContext); // ... use returns context value context passed. determine context value, React searches component tree finds closest context provider particular context. pass context Button , wrap one parent components corresponding context provider. function MyPage() { return ( <ThemeContext.Provider value=\"dark\"> <Form /> </ThemeContext.Provider> ); } function Form() { // ... renders buttons inside ... } doesn\u2019t matter many layers components provider Button . Button anywhere inside Form calls use(ThemeContext) , receive \"dark\" value. Unlike useContext , use called conditionals loops like . function HorizontalRule({ show }) { (show) { const theme = use(ThemeContext); return <hr className={theme} />; } return false; } use called inside statement, allowing conditionally read values Context. import { createContext, use } 'react'; const ThemeContext = createContext(null); export default function MyApp() { return ( <ThemeContext.Provider value=\"dark\"> <Form /> </ThemeContext.Provider> ) } function Form() { return ( <Panel title=\"Welcome\"> <Button show={true}>Sign up</Button> <Button show={false}>Log in</Button> </Panel> ); } function Panel({ title, children }) { const theme = use(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> <h1>{title}</h1> {children} </section> ) } function Button({ show, children }) { (show) { const theme = use(ThemeContext); const className = 'button-' + theme; return ( <button className={className}> {children} </button> ); } return false } Streaming data server client Data streamed server client passing Promise prop Server Component Client Component. import { fetchMessage } './lib.js'; import { Message } './message.js'; export default function App() { const messagePromise = fetchMessage(); return ( <Suspense fallback={<p>waiting message...</p>}> <Message messagePromise={messagePromise} /> </Suspense> ); } Client Component takes Promise received prop passes use API. allows Client Component read value Promise initially created Server Component. // message.js 'use client'; import { use } 'react'; export function Message({ messagePromise }) { const messageContent = use(messagePromise); return <p>Here message: {messageContent}</p>; } Message wrapped Suspense , fallback displayed Promise resolved. Promise resolved, value read use API Message component replace Suspense fallback. \"use client\"; import { use, Suspense } \"react\"; function Message({ messagePromise }) { const messageContent = use(messagePromise); return <p>Here message: {messageContent}</p>; } export function MessageContainer({ messagePromise }) { return ( <Suspense fallback={<p>\u231bDownloading message...</p>}> <Message messagePromise={messagePromise} /> </Suspense> ); } Deep Dive Promise passed Server Component Client Component resolved Client Component use API. also resolve Promise Server Component await pass required data Client Component prop. export default async function App() { const messageContent = await fetchMessage(); return <Message messageContent={messageContent} /> } using await Server Component block rendering await statement finished. Passing Promise Server Component Client Component prevents Promise blocking rendering Server Component. Dealing rejected Promises cases Promise passed use could rejected. handle rejected Promises either: - Displaying error users error boundary. - Providing alternative value Promise.catch Displaying error users error boundary you\u2019d like display error users Promise rejected, use error boundary. use error boundary, wrap component calling use API error boundary. Promise passed use rejected fallback error boundary displayed. \"use client\"; import { use, Suspense } \"react\"; import { ErrorBoundary } \"react-error-boundary\"; export function MessageContainer({ messagePromise }) { return ( <ErrorBoundary fallback={<p>\u26a0\ufe0fSomething went wrong</p>}> <Suspense fallback={<p>\u231bDownloading message...</p>}> <Message messagePromise={messagePromise} /> </Suspense> </ErrorBoundary> ); } function Message({ messagePromise }) { const content = use(messagePromise); return <p>Here message: {content}</p>; } Providing alternative value Promise.catch you\u2019d like provide alternative value Promise passed use rejected use Promise\u2019s catch method. import { Message } './message.js'; export default function App() { const messagePromise = new Promise((resolve, reject) => { reject(); }).catch(() => { return \"no new message found.\"; }); return ( <Suspense fallback={<p>waiting message...</p>}> <Message messagePromise={messagePromise} /> </Suspense> ); } use Promise\u2019s catch method, call catch Promise object. catch takes single argument: function takes error message argument. Whatever returned function passed catch used resolved value Promise. Troubleshooting \u201cSuspense Exception: real error!\u201d either calling use outside React Component Hook function, calling use try\u2013catch block. calling use inside try\u2013catch block, wrap component error boundary, call Promise\u2019s catch catch error resolve Promise another value. See examples. calling use outside React Component Hook function, move use call React Component Hook function. function MessageComponent({messagePromise}) { function download() { // \u274c function calling `use` Component Hook const message = use(messagePromise); // ... Instead, call use outside component closures, function calls use Component Hook. function MessageComponent({messagePromise}) { // \u2705 `use` called component. const message = use(messagePromise); // ..."},
{"source": "https://react.dev/reference/react/useActionState", "title": "useActionState \u2013 React", "text": "useActionState useActionState Hook allows update state based result form action. const [state, formAction, isPending] = useActionState(fn, initialState, permalink?); Reference useActionState(action, initialState, permalink?) Call useActionState top level component create component state updated form action invoked. pass useActionState existing form action function well initial state, returns new action use form, along latest form state whether Action still pending. latest form state also passed function provided. import { useActionState } \"react\"; async function increment(previousState, formData) { return previousState + 1; } function StatefulForm({}) { const [state, formAction] = useActionState(increment, 0); return ( <form> {state} <button formAction={formAction}>Increment</button> </form> ) } form state value returned action form last submitted. form yet submitted, initial state pass. used Server Function, useActionState allows server\u2019s response submitting form shown even hydration completed. Parameters fn : function called form submitted button pressed. function called, receive previous state form (initially theinitialState pass, subsequently previous return value) initial argument, followed arguments form action normally receives.initialState : value want state initially. serializable value. argument ignored action first invoked.- optional permalink : string containing unique page URL form modifies. use pages dynamic content (eg: feeds) conjunction progressive enhancement: iffn server function form submitted JavaScript bundle loads, browser navigate specified permalink URL, rather current page\u2019s URL. Ensure form component rendered destination page (including actionfn andpermalink ) React knows pass state through. form hydrated, parameter effect. Returns useActionState returns array following values: - current state. first render, match initialState passed. action invoked, match value returned action. - new action pass action prop yourform component orformAction prop anybutton component within form. - isPending flag tells whether pending Transition. Caveats - used framework supports React Server Components, useActionState lets make forms interactive JavaScript executed client. used without Server Components, equivalent component local state. - function passed useActionState receives extra argument, previous initial state, first argument. makes signature different used directly form action without usinguseActionState . Usage Using information returned form action Call useActionState top level component access return value action last time form submitted. import { useActionState } 'react'; import { action } './actions.js'; function MyComponent() { const [state, formAction] = useActionState(action, null); // ... return ( <form action={formAction}> {/* ... */} </form> ); } useActionState returns array following items: - current state form, initially set initial state provided, form submitted set return value action provided. - new action pass <form> itsaction prop. - pending state utilise whilst action processing. form submitted, action function provided called. return value become new current state form. action provide also receive new first argument, namely current state form. first time form submitted, initial state provided, subsequent submissions, return value last time action called. rest arguments useActionState used. function action(currentState, formData) { // ... return 'next state'; } Example 1 2: Display form errors display messages error message toast that\u2019s returned Server Function, wrap action call useActionState . import { useActionState, useState } \"react\"; import { addToCart } \"./actions.js\"; function AddToCartForm({itemID, itemTitle}) { const [message, formAction, isPending] = useActionState(addToCart, null); return ( <form action={formAction}> <h2>{itemTitle}</h2> <input type=\"hidden\" name=\"itemID\" value={itemID} /> <button type=\"submit\">Add Cart</button> {isPending ? \"Loading...\" : message} </form> ); } export default function App() { return ( <> <AddToCartForm itemID=\"1\" itemTitle=\"JavaScript: Definitive Guide\" /> <AddToCartForm itemID=\"2\" itemTitle=\"JavaScript: Good Parts\" /> </> ) } Troubleshooting action longer read submitted form data wrap action useActionState , gets extra argument first argument. submitted form data therefore second argument instead first would usually be. new first argument gets added current state form. function action(currentState, formData) { // ... }"},
{"source": "https://react.dev/reference/react/useCallback", "title": "useCallback \u2013 React", "text": "useCallback useCallback React Hook lets cache function definition re-renders. const cachedFn = useCallback(fn, dependencies) Reference useCallback(fn, dependencies) Call useCallback top level component cache function definition re-renders: import { useCallback } 'react'; export default function ProductPage({ productId, referrer, theme }) { const handleSubmit = useCallback((orderDetails) => { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); Parameters - fn : function value want cache. take arguments return values. React return (not call!) function back initial render. next renders, React give function thedependencies changed since last render. Otherwise, give function passed current render, store case reused later. React call function. function returned decide whether call it. - dependencies : list reactive values referenced inside thefn code. Reactive values include props, state, variables functions declared directly inside component body. linter configured React, verify every reactive value correctly specified dependency. list dependencies must constant number items written inline like[dep1, dep2, dep3] . React compare dependency previous value using theObject.is comparison algorithm. Returns initial render, useCallback returns fn function passed. subsequent renders, either return already stored fn function last render (if dependencies haven\u2019t changed), return fn function passed render. Caveats useCallback Hook, call top level component Hooks. can\u2019t call inside loops conditions. need that, extract new component move state it.- React throw away cached function unless specific reason that. example, development, React throws away cache edit file component. development production, React throw away cache component suspends initial mount. future, React may add features take advantage throwing away cache\u2014for example, React adds built-in support virtualized lists future, would make sense throw away cache items scroll virtualized table viewport. match expectations rely useCallback performance optimization. Otherwise, state variable ref may appropriate. Usage Skipping re-rendering components optimize rendering performance, sometimes need cache functions pass child components. Let\u2019s first look syntax this, see cases it\u2019s useful. cache function re-renders component, wrap definition useCallback Hook: import { useCallback } 'react'; function ProductPage({ productId, referrer, theme }) { const handleSubmit = useCallback((orderDetails) => { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); // ... need pass two things useCallback : - function definition want cache re-renders. - list dependencies including every value within component that\u2019s used inside function. initial render, returned function you\u2019ll get useCallback function passed. following renders, React compare dependencies dependencies passed previous render. none dependencies changed (compared Object.is ), useCallback return function before. Otherwise, useCallback return function passed render. words, useCallback caches function re-renders dependencies change. Let\u2019s walk example see useful. Say you\u2019re passing handleSubmit function ProductPage ShippingForm component: function ProductPage({ productId, referrer, theme }) { // ... return ( <div className={theme}> <ShippingForm onSubmit={handleSubmit} /> </div> ); You\u2019ve noticed toggling theme prop freezes app moment, remove <ShippingForm /> JSX, feels fast. tells it\u2019s worth trying optimize ShippingForm component. default, component re-renders, React re-renders children recursively. why, ProductPage re-renders different theme , ShippingForm component also re-renders. fine components don\u2019t require much calculation re-render. verified re-render slow, tell ShippingForm skip re-rendering props last render wrapping memo : import { memo } 'react'; const ShippingForm = memo(function ShippingForm({ onSubmit }) { // ... }); change, ShippingForm skip re-rendering props last render. caching function becomes important! Let\u2019s say defined handleSubmit without useCallback : function ProductPage({ productId, referrer, theme }) { // Every time theme changes, different function... function handleSubmit(orderDetails) { post('/product/' + productId + '/buy', { referrer, orderDetails, }); } return ( <div className={theme}> {/* ... ShippingForm's props never same, re-render every time */} <ShippingForm onSubmit={handleSubmit} /> </div> ); } JavaScript, function () {} () => {} always creates different function, similar {} object literal always creates new object. Normally, wouldn\u2019t problem, means ShippingForm props never same, memo optimization won\u2019t work. useCallback comes handy: function ProductPage({ productId, referrer, theme }) { // Tell React cache function re-renders... const handleSubmit = useCallback((orderDetails) => { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); // ...so long dependencies change... return ( <div className={theme}> {/* ...ShippingForm receive props skip re-rendering */} <ShippingForm onSubmit={handleSubmit} /> </div> ); } wrapping handleSubmit useCallback , ensure it\u2019s function re-renders (until dependencies change). don\u2019t wrap function useCallback unless specific reason. example, reason pass component wrapped memo , lets skip re-rendering. reasons might need useCallback described page. Deep Dive often see useMemo alongside useCallback . useful you\u2019re trying optimize child component. let memoize (or, words, cache) something you\u2019re passing down: import { useMemo, useCallback } 'react'; function ProductPage({ productId, referrer }) { const product = useData('/product/' + productId); const requirements = useMemo(() => { // Calls function caches result return computeRequirements(product); }, [product]); const handleSubmit = useCallback((orderDetails) => { // Caches function post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); return ( <div className={theme}> <ShippingForm requirements={requirements} onSubmit={handleSubmit} /> </div> ); } difference they\u2019re letting cache: useMemo caches result calling function. example, caches result callingcomputeRequirements(product) doesn\u2019t change unlessproduct changed. lets pass therequirements object without unnecessarily re-renderingShippingForm . necessary, React call function you\u2019ve passed rendering calculate result.useCallback caches function itself. UnlikeuseMemo , call function provide. Instead, caches function provided thathandleSubmit doesn\u2019t change unlessproductId orreferrer changed. lets pass thehandleSubmit function without unnecessarily re-renderingShippingForm . code won\u2019t run user submits form. you\u2019re already familiar useMemo , might find helpful think useCallback this: // Simplified implementation (inside React) function useCallback(fn, dependencies) { return useMemo(() => fn, dependencies); } Read difference useMemo useCallback . Deep Dive app like site, interactions coarse (like replacing page entire section), memoization usually unnecessary. hand, app like drawing editor, interactions granular (like moving shapes), might find memoization helpful. Caching function useCallback valuable cases: - pass prop component wrapped memo . want skip re-rendering value hasn\u2019t changed. Memoization lets component re-render dependencies changed. - function you\u2019re passing later used dependency Hook. example, another function wrapped useCallback depends it, depend function fromuseEffect. benefit wrapping function useCallback cases. significant harm either, teams choose think individual cases, memoize much possible. downside code becomes less readable. Also, memoization effective: single value that\u2019s \u201calways new\u201d enough break memoization entire component. Note useCallback prevent creating function. You\u2019re always creating function (and that\u2019s fine!), React ignores gives back cached function nothing changed. practice, make lot memoization unnecessary following principles: - component visually wraps components, let accept JSX children. Then, wrapper component updates state, React knows children don\u2019t need re-render. - Prefer local state don\u2019t lift state necessary. Don\u2019t keep transient state like forms whether item hovered top tree global state library. - Keep rendering logic pure. re-rendering component causes problem produces noticeable visual artifact, it\u2019s bug component! Fix bug instead adding memoization. - Avoid unnecessary Effects update state. performance problems React apps caused chains updates originating Effects cause components render over. - Try remove unnecessary dependencies Effects. example, instead memoization, it\u2019s often simpler move object function inside Effect outside component. specific interaction still feels laggy, use React Developer Tools profiler see components benefit memoization, add memoization needed. principles make components easier debug understand, it\u2019s good follow case. long term, we\u2019re researching memoization automatically solve all. Example 1 2: Skipping re-rendering useCallback memo example, ShippingForm component artificially slowed see happens React component you\u2019re rendering genuinely slow. Try incrementing counter toggling theme. Incrementing counter feels slow forces slowed ShippingForm re-render. That\u2019s expected counter changed, need reflect user\u2019s new choice screen. Next, try toggling theme. Thanks useCallback together memo , it\u2019s fast despite artificial slowdown! ShippingForm skipped re-rendering handleSubmit function changed. handleSubmit function changed productId referrer (your useCallback dependencies) haven\u2019t changed since last render. import { useCallback } 'react'; import ShippingForm './ShippingForm.js'; export default function ProductPage({ productId, referrer, theme }) { const handleSubmit = useCallback((orderDetails) => { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); return ( <div className={theme}> <ShippingForm onSubmit={handleSubmit} /> </div> ); } function post(url, data) { // Imagine sends request... console.log('POST /' + url); console.log(data); } Updating state memoized callback Sometimes, might need update state based previous state memoized callback. handleAddTodo function specifies todos dependency computes next todos it: function TodoList() { const [todos, setTodos] = useState([]); const handleAddTodo = useCallback((text) => { const newTodo = { id: nextId++, text }; setTodos([...todos, newTodo]); }, [todos]); // ... You\u2019ll usually want memoized functions dependencies possible. read state calculate next state, remove dependency passing updater function instead: function TodoList() { const [todos, setTodos] = useState([]); const handleAddTodo = useCallback((text) => { const newTodo = { id: nextId++, text }; setTodos(todos => [...todos, newTodo]); }, []); // \u2705 need todos dependency // ... Here, instead making todos dependency reading inside, pass instruction update state (todos => [...todos, newTodo] ) React. Read updater functions. Preventing Effect firing often Sometimes, might want call function inside Effect: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); function createOptions() { return { serverUrl: 'https://localhost:1234', roomId: roomId }; } useEffect(() => { const options = createOptions(); const connection = createConnection(options); connection.connect(); // ... creates problem. Every reactive value must declared dependency Effect. However, declare createOptions dependency, cause Effect constantly reconnect chat room: useEffect(() => { const options = createOptions(); const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [createOptions]); // \ud83d\udd34 Problem: dependency changes every render // ... solve this, wrap function need call Effect useCallback : function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); const createOptions = useCallback(() => { return { serverUrl: 'https://localhost:1234', roomId: roomId }; }, [roomId]); // \u2705 changes roomId changes useEffect(() => { const options = createOptions(); const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [createOptions]); // \u2705 changes createOptions changes // ... ensures createOptions function re-renders roomId same. However, it\u2019s even better remove need function dependency. Move function inside Effect: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() => { function createOptions() { // \u2705 need useCallback function dependencies! return { serverUrl: 'https://localhost:1234', roomId: roomId }; } const options = createOptions(); const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [roomId]); // \u2705 changes roomId changes // ... code simpler doesn\u2019t need useCallback . Learn removing Effect dependencies. Optimizing custom Hook you\u2019re writing custom Hook, it\u2019s recommended wrap functions returns useCallback : function useRouter() { const { dispatch } = useContext(RouterStateContext); const navigate = useCallback((url) => { dispatch({ type: 'navigate', url }); }, [dispatch]); const goBack = useCallback(() => { dispatch({ type: 'back' }); }, [dispatch]); return { navigate, goBack, }; } ensures consumers Hook optimize code needed. Troubleshooting Every time component renders, useCallback returns different function Make sure you\u2019ve specified dependency array second argument! forget dependency array, useCallback return new function every time: function ProductPage({ productId, referrer }) { const handleSubmit = useCallback((orderDetails) => { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }); // \ud83d\udd34 Returns new function every time: dependency array // ... corrected version passing dependency array second argument: function ProductPage({ productId, referrer }) { const handleSubmit = useCallback((orderDetails) => { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); // \u2705 return new function unnecessarily // ... doesn\u2019t help, problem least one dependencies different previous render. debug problem manually logging dependencies console: const handleSubmit = useCallback((orderDetails) => { // .. }, [productId, referrer]); console.log([productId, referrer]); right-click arrays different re-renders console select \u201cStore global variable\u201d them. Assuming first one got saved temp1 second one got saved temp2 , use browser console check whether dependency arrays same: Object.is(temp1[0], temp2[0]); // first dependency arrays? Object.is(temp1[1], temp2[1]); // second dependency arrays? Object.is(temp1[2], temp2[2]); // ... every dependency ... find dependency breaking memoization, either find way remove it, memoize well. need call useCallback list item loop, it\u2019s allowed Suppose Chart component wrapped memo . want skip re-rendering every Chart list ReportList component re-renders. However, can\u2019t call useCallback loop: function ReportList({ items }) { return ( <article> {items.map(item => { // \ud83d\udd34 can't call useCallback loop like this: const handleClick = useCallback(() => { sendReport(item) }, [item]); return ( <figure key={item.id}> <Chart onClick={handleClick} /> </figure> ); })} </article> ); } Instead, extract component individual item, put useCallback there: function ReportList({ items }) { return ( <article> {items.map(item => <Report key={item.id} item={item} /> )} </article> ); } function Report({ item }) { // \u2705 Call useCallback top level: const handleClick = useCallback(() => { sendReport(item) }, [item]); return ( <figure> <Chart onClick={handleClick} /> </figure> ); } Alternatively, could remove useCallback last snippet instead wrap Report memo . item prop change, Report skip re-rendering, Chart skip re-rendering too: function ReportList({ items }) { // ... } const Report = memo(function Report({ item }) { function handleClick() { sendReport(item); } return ( <figure> <Chart onClick={handleClick} /> </figure> ); });"},
{"source": "https://react.dev/reference/react/useContext", "title": "useContext \u2013 React", "text": "useContext useContext React Hook lets read subscribe context component. const value = useContext(SomeContext) Reference useContext(SomeContext) Call useContext top level component read subscribe context. import { useContext } 'react'; function MyComponent() { const theme = useContext(ThemeContext); // ... Parameters SomeContext : context you\u2019ve previously created withcreateContext . context hold information, represents kind information provide read components. Returns useContext returns context value calling component. determined value passed closest SomeContext.Provider calling component tree. provider, returned value defaultValue passed createContext context. returned value always up-to-date. React automatically re-renders components read context changes. Caveats useContext() call component affected providers returned component. corresponding<Context.Provider> needs component theuseContext() call.- React automatically re-renders children use particular context starting provider receives different value . previous next values compared theObject.is comparison. Skipping re-renders withmemo prevent children receiving fresh context values. - build system produces duplicates modules output (which happen symlinks), break context. Passing something via context works SomeContext use provide context andSomeContext use read exactly object, determined a=== comparison. Usage Passing data deeply tree Call useContext top level component read subscribe context. import { useContext } 'react'; function Button() { const theme = useContext(ThemeContext); // ... useContext returns context value context passed. determine context value, React searches component tree finds closest context provider particular context. pass context Button , wrap one parent components corresponding context provider: function MyPage() { return ( <ThemeContext.Provider value=\"dark\"> <Form /> </ThemeContext.Provider> ); } function Form() { // ... renders buttons inside ... } doesn\u2019t matter many layers components provider Button . Button anywhere inside Form calls useContext(ThemeContext) , receive \"dark\" value. import { createContext, useContext } 'react'; const ThemeContext = createContext(null); export default function MyApp() { return ( <ThemeContext.Provider value=\"dark\"> <Form /> </ThemeContext.Provider> ) } function Form() { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> </Panel> ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> <h1>{title}</h1> {children} </section> ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className}> {children} </button> ); } Updating data passed via context Often, you\u2019ll want context change time. update context, combine state. Declare state variable parent component, pass current state context value provider. function MyPage() { const [theme, setTheme] = useState('dark'); return ( <ThemeContext.Provider value={theme}> <Form /> <Button onClick={() => { setTheme('light'); }}> Switch light theme </Button> </ThemeContext.Provider> ); } Button inside provider receive current theme value. call setTheme update theme value pass provider, Button components re-render new 'light' value. Example 1 5: Updating value via context example, MyApp component holds state variable passed ThemeContext provider. Checking \u201cDark mode\u201d checkbox updates state. Changing provided value re-renders components using context. import { createContext, useContext, useState } 'react'; const ThemeContext = createContext(null); export default function MyApp() { const [theme, setTheme] = useState('light'); return ( <ThemeContext.Provider value={theme}> <Form /> <label> <input type=\"checkbox\" checked={theme === 'dark'} onChange={(e) => { setTheme(e.target.checked ? 'dark' : 'light') }} /> Use dark mode </label> </ThemeContext.Provider> ) } function Form({ children }) { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> </Panel> ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> <h1>{title}</h1> {children} </section> ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className}> {children} </button> ); } Note value=\"dark\" passes \"dark\" string, value={theme} passes value JavaScript theme variable JSX curly braces. Curly braces also let pass context values aren\u2019t strings. Specifying fallback default value React can\u2019t find providers particular context parent tree, context value returned useContext() equal default value specified created context: const ThemeContext = createContext(null); default value never changes. want update context, use state described above. Often, instead null , meaningful value use default, example: const ThemeContext = createContext('light'); way, accidentally render component without corresponding provider, won\u2019t break. also helps components work well test environment without setting lot providers tests. example below, \u201cToggle theme\u201d button always light it\u2019s outside theme context provider default context theme value 'light' . Try editing default theme 'dark' . import { createContext, useContext, useState } 'react'; const ThemeContext = createContext('light'); export default function MyApp() { const [theme, setTheme] = useState('light'); return ( <> <ThemeContext.Provider value={theme}> <Form /> </ThemeContext.Provider> <Button onClick={() => { setTheme(theme === 'dark' ? 'light' : 'dark'); }}> Toggle theme </Button> </> ) } function Form({ children }) { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> </Panel> ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> <h1>{title}</h1> {children} </section> ) } function Button({ children, onClick }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className} onClick={onClick}> {children} </button> ); } Overriding context part tree override context part tree wrapping part provider different value. <ThemeContext.Provider value=\"dark\"> ... <ThemeContext.Provider value=\"light\"> <Footer /> </ThemeContext.Provider> ... </ThemeContext.Provider> nest override providers many times need. Example 1 2: Overriding theme Here, button inside Footer receives different context value (\"light\" ) buttons outside (\"dark\" ). import { createContext, useContext } 'react'; const ThemeContext = createContext(null); export default function MyApp() { return ( <ThemeContext.Provider value=\"dark\"> <Form /> </ThemeContext.Provider> ) } function Form() { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> <ThemeContext.Provider value=\"light\"> <Footer /> </ThemeContext.Provider> </Panel> ); } function Footer() { return ( <footer> <Button>Settings</Button> </footer> ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> {title && <h1>{title}</h1>} {children} </section> ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className}> {children} </button> ); } Optimizing re-renders passing objects functions pass values via context, including objects functions. function MyApp() { const [currentUser, setCurrentUser] = useState(null); function login(response) { storeCredentials(response.credentials); setCurrentUser(response.user); } return ( <AuthContext.Provider value={{ currentUser, login }}> <Page /> </AuthContext.Provider> ); } Here, context value JavaScript object two properties, one function. Whenever MyApp re-renders (for example, route update), different object pointing different function, React also re-render components deep tree call useContext(AuthContext) . smaller apps, problem. However, need re-render underlying data, like currentUser , changed. help React take advantage fact, may wrap login function useCallback wrap object creation useMemo . performance optimization: import { useCallback, useMemo } 'react'; function MyApp() { const [currentUser, setCurrentUser] = useState(null); const login = useCallback((response) => { storeCredentials(response.credentials); setCurrentUser(response.user); }, []); const contextValue = useMemo(() => ({ currentUser, login }), [currentUser, login]); return ( <AuthContext.Provider value={contextValue}> <Page /> </AuthContext.Provider> ); } result change, even MyApp needs re-render, components calling useContext(AuthContext) won\u2019t need re-render unless currentUser changed. Read useMemo useCallback . Troubleshooting component doesn\u2019t see value provider common ways happen: - You\u2019re rendering <SomeContext.Provider> component (or below) you\u2019re callinguseContext() . Move<SomeContext.Provider> outside component callinguseContext() . - may forgotten wrap component <SomeContext.Provider> , might put different part tree thought. Check whether hierarchy right using React DevTools. - might running build issue tooling causes SomeContext seen providing component andSomeContext seen reading component two different objects. happen use symlinks, example. verify assigning globals likewindow.SomeContext1 andwindow.SomeContext2 checking whetherwindow.SomeContext1 === window.SomeContext2 console. they\u2019re same, fix issue build tool level. always getting undefined context although default value different might provider without value tree: // \ud83d\udea9 work: value prop <ThemeContext.Provider> <Button /> </ThemeContext.Provider> forget specify value , it\u2019s like passing value={undefined} . may also mistakingly used different prop name mistake: // \ud83d\udea9 work: prop called \"value\" <ThemeContext.Provider theme={theme}> <Button /> </ThemeContext.Provider> cases see warning React console. fix them, call prop value : // \u2705 Passing value prop <ThemeContext.Provider value={theme}> <Button /> </ThemeContext.Provider> Note default value createContext(defaultValue) call used matching provider all. <SomeContext.Provider value={undefined}> component somewhere parent tree, component calling useContext(SomeContext) receive undefined context value."},
{"source": "https://react.dev/reference/react/useDebugValue", "title": "useDebugValue \u2013 React", "text": "useDebugValue useDebugValue React Hook lets add label custom Hook React DevTools. useDebugValue(value, format?) Reference useDebugValue(value, format?) Call useDebugValue top level custom Hook display readable debug value: import { useDebugValue } 'react'; function useOnlineStatus() { // ... useDebugValue(isOnline ? 'Online' : 'Offline'); // ... } Parameters value : value want display React DevTools. type.- optional format : formatting function. component inspected, React DevTools call formatting function thevalue argument, display returned formatted value (which may type). don\u2019t specify formatting function, originalvalue displayed. Returns useDebugValue return anything. Usage Adding label custom Hook Call useDebugValue top level custom Hook display readable debug value React DevTools. import { useDebugValue } 'react'; function useOnlineStatus() { // ... useDebugValue(isOnline ? 'Online' : 'Offline'); // ... } gives components calling useOnlineStatus label like OnlineStatus: \"Online\" inspect them: Without useDebugValue call, underlying data (in example, true ) would displayed. import { useSyncExternalStore, useDebugValue } 'react'; export function useOnlineStatus() { const isOnline = useSyncExternalStore(subscribe, () => navigator.onLine, () => true); useDebugValue(isOnline ? 'Online' : 'Offline'); return isOnline; } function subscribe(callback) { window.addEventListener('online', callback); window.addEventListener('offline', callback); return () => { window.removeEventListener('online', callback); window.removeEventListener('offline', callback); }; } Deferring formatting debug value also pass formatting function second argument useDebugValue : useDebugValue(date, date => date.toDateString()); formatting function receive debug value parameter return formatted display value. component inspected, React DevTools call function display result. lets avoid running potentially expensive formatting logic unless component actually inspected. example, date Date value, avoids calling toDateString() every render."},
{"source": "https://react.dev/reference/react/useDeferredValue", "title": "useDeferredValue \u2013 React", "text": "useDeferredValue useDeferredValue React Hook lets defer updating part UI. const deferredValue = useDeferredValue(value) Reference useDeferredValue(value, initialValue?) Call useDeferredValue top level component get deferred version value. import { useState, useDeferredValue } 'react'; function SearchPage() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); // ... } Parameters value : value want defer. type.- optional initialValue : value use initial render component. option omitted,useDeferredValue defer initial render, there\u2019s previous version ofvalue render instead. Returns currentValue : initial render, returned deferred value theinitialValue , value provided. updates, React first attempt re-render old value (so return old value), try another re-render background new value (so return updated value). Caveats - update inside Transition, useDeferredValue always returns newvalue spawn deferred render, since update already deferred. - values pass useDeferredValue either primitive values (like strings numbers) objects created outside rendering. create new object rendering immediately pass touseDeferredValue , different every render, causing unnecessary background re-renders. - useDeferredValue receives different value (compared withObject.is ), addition current render (when still uses previous value), schedules re-render background new value. background re-render interruptible: there\u2019s another update thevalue , React restart background re-render scratch. example, user typing input faster chart receiving deferred value re-render, chart re-render user stops typing. - useDeferredValue integrated with<Suspense> . background update caused new value suspends UI, user see fallback. see old deferred value data loads. - useDeferredValue prevent extra network requests. - fixed delay caused useDeferredValue itself. soon React finishes original re-render, React immediately start working background re-render new deferred value. updates caused events (like typing) interrupt background re-render get prioritized it. - background re-render caused useDeferredValue fire Effects it\u2019s committed screen. background re-render suspends, Effects run data loads UI updates. Usage Showing stale content fresh content loading Call useDeferredValue top level component defer updating part UI. import { useState, useDeferredValue } 'react'; function SearchPage() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); // ... } initial render, deferred value value provided. updates, deferred value \u201clag behind\u201d latest value. particular, React first re-render without updating deferred value, try re-render newly received value background. Let\u2019s walk example see useful. example, SearchResults component suspends fetching search results. Try typing \"a\" , waiting results, editing \"ab\" . results \"a\" get replaced loading fallback. import { Suspense, useState } 'react'; import SearchResults './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); return ( <> <label> Search albums: <input value={query} onChange={e => setQuery(e.target.value)} /> </label> <Suspense fallback={<h2>Loading...</h2>}> <SearchResults query={query} /> </Suspense> </> ); } common alternative UI pattern defer updating list results keep showing previous results new results ready. Call useDeferredValue pass deferred version query down: export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); return ( <> <label> Search albums: <input value={query} onChange={e => setQuery(e.target.value)} /> </label> <Suspense fallback={<h2>Loading...</h2>}> <SearchResults query={deferredQuery} /> </Suspense> </> ); } query update immediately, input display new value. However, deferredQuery keep previous value data loaded, SearchResults show stale results bit. Enter \"a\" example below, wait results load, edit input \"ab\" . Notice instead Suspense fallback, see stale result list new results loaded: import { Suspense, useState, useDeferredValue } 'react'; import SearchResults './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); return ( <> <label> Search albums: <input value={query} onChange={e => setQuery(e.target.value)} /> </label> <Suspense fallback={<h2>Loading...</h2>}> <SearchResults query={deferredQuery} /> </Suspense> </> ); } Deep Dive think happening two steps: - First, React re-renders new query (\"ab\" ) olddeferredQuery (still\"a\") . ThedeferredQuery value, pass result list, deferred: \u201clags behind\u201d thequery value. - background, React tries re-render query anddeferredQuery updated to\"ab\" . re-render completes, React show screen. However, suspends (the results for\"ab\" loaded yet), React abandon rendering attempt, retry re-render data loaded. user keep seeing stale deferred value data ready. deferred \u201cbackground\u201d rendering interruptible. example, type input again, React abandon restart new value. React always use latest provided value. Note still network request per keystroke. What\u2019s deferred displaying results (until they\u2019re ready), network requests themselves. Even user continues typing, responses keystroke get cached, pressing Backspace instant doesn\u2019t fetch again. Indicating content stale example above, indication result list latest query still loading. confusing user new results take load. make obvious user result list match latest query, add visual indication stale result list displayed: <div style={{ opacity: query !== deferredQuery ? 0.5 : 1, }}> <SearchResults query={deferredQuery} /> </div> change, soon start typing, stale result list gets slightly dimmed new result list loads. also add CSS transition delay dimming feels gradual, like example below: import { Suspense, useState, useDeferredValue } 'react'; import SearchResults './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); const isStale = query !== deferredQuery; return ( <> <label> Search albums: <input value={query} onChange={e => setQuery(e.target.value)} /> </label> <Suspense fallback={<h2>Loading...</h2>}> <div style={{ opacity: isStale ? 0.5 : 1, transition: isStale ? 'opacity 0.2s 0.2s linear' : 'opacity 0s 0s linear' }}> <SearchResults query={deferredQuery} /> </div> </Suspense> </> ); } Deferring re-rendering part UI also apply useDeferredValue performance optimization. useful part UI slow re-render, there\u2019s easy way optimize it, want prevent blocking rest UI. Imagine text field component (like chart long list) re-renders every keystroke: function App() { const [text, setText] = useState(''); return ( <> <input value={text} onChange={e => setText(e.target.value)} /> <SlowList text={text} /> </> ); } First, optimize SlowList skip re-rendering props same. this, wrap memo : const SlowList = memo(function SlowList({ text }) { // ... }); However, helps SlowList props previous render. problem you\u2019re facing it\u2019s slow they\u2019re different, actually need show different visual output. Concretely, main performance problem whenever type input, SlowList receives new props, re-rendering entire tree makes typing feel janky. case, useDeferredValue lets prioritize updating input (which must fast) updating result list (which allowed slower): function App() { const [text, setText] = useState(''); const deferredText = useDeferredValue(text); return ( <> <input value={text} onChange={e => setText(e.target.value)} /> <SlowList text={deferredText} /> </> ); } make re-rendering SlowList faster. However, tells React re-rendering list deprioritized doesn\u2019t block keystrokes. list \u201clag behind\u201d input \u201ccatch up\u201d. Like before, React attempt update list soon possible, block user typing. Example 1 2: Deferred re-rendering list example, item SlowList component artificially slowed see useDeferredValue lets keep input responsive. Type input notice typing feels snappy list \u201clags behind\u201d it. import { useState, useDeferredValue } 'react'; import SlowList './SlowList.js'; export default function App() { const [text, setText] = useState(''); const deferredText = useDeferredValue(text); return ( <> <input value={text} onChange={e => setText(e.target.value)} /> <SlowList text={deferredText} /> </> ); } Deep Dive two common optimization techniques might used scenario: - Debouncing means you\u2019d wait user stop typing (e.g. second) updating list. - Throttling means you\u2019d update list every (e.g. second). techniques helpful cases, useDeferredValue better suited optimizing rendering deeply integrated React adapts user\u2019s device. Unlike debouncing throttling, doesn\u2019t require choosing fixed delay. user\u2019s device fast (e.g. powerful laptop), deferred re-render would happen almost immediately wouldn\u2019t noticeable. user\u2019s device slow, list would \u201clag behind\u201d input proportionally slow device is. Also, unlike debouncing throttling, deferred re-renders done useDeferredValue interruptible default. means React middle re-rendering large list, user makes another keystroke, React abandon re-render, handle keystroke, start rendering background again. contrast, debouncing throttling still produce janky experience they\u2019re blocking: merely postpone moment rendering blocks keystroke. work you\u2019re optimizing doesn\u2019t happen rendering, debouncing throttling still useful. example, let fire fewer network requests. also use techniques together."},
{"source": "https://react.dev/reference/react/useEffect", "title": "useEffect \u2013 React", "text": "useEffect useEffect React Hook lets synchronize component external system. useEffect(setup, dependencies?) - Reference - Usage - Connecting external system - Wrapping Effects custom Hooks - Controlling non-React widget - Fetching data Effects - Specifying reactive dependencies - Updating state based previous state Effect - Removing unnecessary object dependencies - Removing unnecessary function dependencies - Reading latest props state Effect - Displaying different content server client - Troubleshooting Reference useEffect(setup, dependencies?) Call useEffect top level component declare Effect: import { useEffect } 'react'; import { createConnection } './chat.js'; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => { connection.disconnect(); }; }, [serverUrl, roomId]); // ... } Parameters - setup : function Effect\u2019s logic. setup function may also optionally return cleanup function. component added DOM, React run setup function. every re-render changed dependencies, React first run cleanup function (if provided it) old values, run setup function new values. component removed DOM, React run cleanup function. - optional dependencies : list reactive values referenced inside thesetup code. Reactive values include props, state, variables functions declared directly inside component body. linter configured React, verify every reactive value correctly specified dependency. list dependencies must constant number items written inline like[dep1, dep2, dep3] . React compare dependency previous value using theObject.is comparison. omit argument, Effect re-run every re-render component. See difference passing array dependencies, empty array, dependencies all. Returns useEffect returns undefined . Caveats - useEffect Hook, call top level component Hooks. can\u2019t call inside loops conditions. need that, extract new component move state it. - you\u2019re trying synchronize external system, probably don\u2019t need Effect. - Strict Mode on, React run one extra development-only setup+cleanup cycle first real setup. stress-test ensures cleanup logic \u201cmirrors\u201d setup logic stops undoes whatever setup doing. causes problem, implement cleanup function. - dependencies objects functions defined inside component, risk cause Effect re-run often needed. fix this, remove unnecessary object function dependencies. also extract state updates non-reactive logic outside Effect. - Effect wasn\u2019t caused interaction (like click), React generally let browser paint updated screen first running Effect. Effect something visual (for example, positioning tooltip), delay noticeable (for example, flickers), replace useEffect withuseLayoutEffect . - Effect caused interaction (like click), React may run Effect browser paints updated screen. ensures result Effect observed event system. Usually, works expected. However, must defer work paint, alert() , usesetTimeout . See reactwg/react-18/128 information. - Even Effect caused interaction (like click), React may allow browser repaint screen processing state updates inside Effect. Usually, works expected. However, must block browser repainting screen, need replace useEffect withuseLayoutEffect . - Effects run client. don\u2019t run server rendering. Usage Connecting external system components need stay connected network, browser API, third-party library, displayed page. systems aren\u2019t controlled React, called external. connect component external system, call useEffect top level component: import { useEffect } 'react'; import { createConnection } './chat.js'; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => { connection.disconnect(); }; }, [serverUrl, roomId]); // ... } need pass two arguments useEffect : - setup function setup code connects system. - return cleanup function cleanup code disconnects system. - list dependencies including every value component used inside functions. React calls setup cleanup functions whenever it\u2019s necessary, may happen multiple times: - setup code runs component added page (mounts). - every re-render component dependencies changed: - First, cleanup code runs old props state. - Then, setup code runs new props state. - cleanup code runs one final time component removed page (unmounts). Let\u2019s illustrate sequence example above. ChatRoom component gets added page, connect chat room initial serverUrl roomId . either serverUrl roomId change result re-render (say, user picks different chat room dropdown), Effect disconnect previous room, connect next one. ChatRoom component removed page, Effect disconnect one last time. help find bugs, development React runs setup cleanup one extra time setup. stress-test verifies Effect\u2019s logic implemented correctly. causes visible issues, cleanup function missing logic. cleanup function stop undo whatever setup function doing. rule thumb user shouldn\u2019t able distinguish setup called (as production) setup \u2192 cleanup \u2192 setup sequence (as development). See common solutions. Try write every Effect independent process think single setup/cleanup cycle time. shouldn\u2019t matter whether component mounting, updating, unmounting. cleanup logic correctly \u201cmirrors\u201d setup logic, Effect resilient running setup cleanup often needed. Example 1 5: Connecting chat server example, ChatRoom component uses Effect stay connected external system defined chat.js . Press \u201cOpen chat\u201d make ChatRoom component appear. sandbox runs development mode, extra connect-and-disconnect cycle, explained here. Try changing roomId serverUrl using dropdown input, see Effect re-connects chat. Press \u201cClose chat\u201d see Effect disconnect one last time. import { useState, useEffect } 'react'; import { createConnection } './chat.js'; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => { connection.disconnect(); }; }, [roomId, serverUrl]); return ( <> <label> Server URL:{' '} <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} /> </label> <h1>Welcome {roomId} room!</h1> </> ); } export default function App() { const [roomId, setRoomId] = useState('general'); const [show, setShow] = useState(false); return ( <> <label> Choose chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> </label> <button onClick={() => setShow(!show)}> {show ? 'Close chat' : 'Open chat'} </button> {show && <hr />} {show && <ChatRoom roomId={roomId} />} </> ); } Wrapping Effects custom Hooks Effects \u201cescape hatch\u201d: use need \u201cstep outside React\u201d better built-in solution use case. find often needing manually write Effects, it\u2019s usually sign need extract custom Hooks common behaviors components rely on. example, useChatRoom custom Hook \u201chides\u201d logic Effect behind declarative API: function useChatRoom({ serverUrl, roomId }) { useEffect(() => { const options = { serverUrl: serverUrl, roomId: roomId }; const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [roomId, serverUrl]); } use component like this: function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useChatRoom({ roomId: roomId, serverUrl: serverUrl }); // ... also many excellent custom Hooks every purpose available React ecosystem. Example 1 3: Custom useChatRoom Hook example identical one earlier examples, logic extracted custom Hook. import { useState } 'react'; import { useChatRoom } './useChatRoom.js'; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useChatRoom({ roomId: roomId, serverUrl: serverUrl }); return ( <> <label> Server URL:{' '} <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} /> </label> <h1>Welcome {roomId} room!</h1> </> ); } export default function App() { const [roomId, setRoomId] = useState('general'); const [show, setShow] = useState(false); return ( <> <label> Choose chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> </label> <button onClick={() => setShow(!show)}> {show ? 'Close chat' : 'Open chat'} </button> {show && <hr />} {show && <ChatRoom roomId={roomId} />} </> ); } Controlling non-React widget Sometimes, want keep external system synchronized prop state component. example, third-party map widget video player component written without React, use Effect call methods make state match current state React component. Effect creates instance MapWidget class defined map-widget.js . change zoomLevel prop Map component, Effect calls setZoom() class instance keep synchronized: import { useRef, useEffect } 'react'; import { MapWidget } './map-widget.js'; export default function Map({ zoomLevel }) { const containerRef = useRef(null); const mapRef = useRef(null); useEffect(() => { (mapRef.current === null) { mapRef.current = new MapWidget(containerRef.current); } const map = mapRef.current; map.setZoom(zoomLevel); }, [zoomLevel]); return ( <div style={{ width: 200, height: 200 }} ref={containerRef} /> ); } example, cleanup function needed MapWidget class manages DOM node passed it. Map React component removed tree, DOM node MapWidget class instance automatically garbage-collected browser JavaScript engine. Fetching data Effects use Effect fetch data component. Note use framework, using framework\u2019s data fetching mechanism lot efficient writing Effects manually. want fetch data Effect manually, code might look like this: import { useState, useEffect } 'react'; import { fetchBio } './api.js'; export default function Page() { const [person, setPerson] = useState('Alice'); const [bio, setBio] = useState(null); useEffect(() => { let ignore = false; setBio(null); fetchBio(person).then(result => { (!ignore) { setBio(result); } }); return () => { ignore = true; }; }, [person]); // ... Note ignore variable initialized false , set true cleanup. ensures code doesn\u2019t suffer \u201crace conditions\u201d: network responses may arrive different order sent them. import { useState, useEffect } 'react'; import { fetchBio } './api.js'; export default function Page() { const [person, setPerson] = useState('Alice'); const [bio, setBio] = useState(null); useEffect(() => { let ignore = false; setBio(null); fetchBio(person).then(result => { (!ignore) { setBio(result); } }); return () => { ignore = true; } }, [person]); return ( <> <select value={person} onChange={e => { setPerson(e.target.value); }}> <option value=\"Alice\">Alice</option> <option value=\"Bob\">Bob</option> <option value=\"Taylor\">Taylor</option> </select> <hr /> <p><i>{bio ?? 'Loading...'}</i></p> </> ); } also rewrite using async / await syntax, still need provide cleanup function: import { useState, useEffect } 'react'; import { fetchBio } './api.js'; export default function Page() { const [person, setPerson] = useState('Alice'); const [bio, setBio] = useState(null); useEffect(() => { async function startFetching() { setBio(null); const result = await fetchBio(person); (!ignore) { setBio(result); } } let ignore = false; startFetching(); return () => { ignore = true; } }, [person]); return ( <> <select value={person} onChange={e => { setPerson(e.target.value); }}> <option value=\"Alice\">Alice</option> <option value=\"Bob\">Bob</option> <option value=\"Taylor\">Taylor</option> </select> <hr /> <p><i>{bio ?? 'Loading...'}</i></p> </> ); } Writing data fetching directly Effects gets repetitive makes difficult add optimizations like caching server rendering later. It\u2019s easier use custom Hook\u2014either maintained community. Deep Dive Writing fetch calls inside Effects popular way fetch data, especially fully client-side apps. is, however, manual approach significant downsides: - Effects don\u2019t run server. means initial server-rendered HTML include loading state data. client computer download JavaScript render app discover needs load data. efficient. - Fetching directly Effects makes easy create \u201cnetwork waterfalls\u201d. render parent component, fetches data, renders child components, start fetching data. network fast, significantly slower fetching data parallel. - Fetching directly Effects usually means don\u2019t preload cache data. example, component unmounts mounts again, would fetch data again. - It\u2019s ergonomic. There\u2019s quite bit boilerplate code involved writing fetch calls way doesn\u2019t suffer bugs like race conditions. list downsides specific React. applies fetching data mount library. Like routing, data fetching trivial well, recommend following approaches: - use framework, use built-in data fetching mechanism. Modern React frameworks integrated data fetching mechanisms efficient don\u2019t suffer pitfalls. - Otherwise, consider using building client-side cache. Popular open source solutions include React Query, useSWR, React Router 6.4+. build solution too, case would use Effects hood also add logic deduplicating requests, caching responses, avoiding network waterfalls (by preloading data hoisting data requirements routes). continue fetching data directly Effects neither approaches suit you. Specifying reactive dependencies Notice can\u2019t \u201cchoose\u201d dependencies Effect. Every reactive value used Effect\u2019s code must declared dependency. Effect\u2019s dependency list determined surrounding code: function ChatRoom({ roomId }) { // reactive value const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // reactive value useEffect(() => { const connection = createConnection(serverUrl, roomId); // Effect reads reactive values connection.connect(); return () => connection.disconnect(); }, [serverUrl, roomId]); // \u2705 must specify dependencies Effect // ... } either serverUrl roomId change, Effect reconnect chat using new values. Reactive values include props variables functions declared directly inside component. Since roomId serverUrl reactive values, can\u2019t remove dependencies. try omit linter correctly configured React, linter flag mistake need fix: function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, []); // \ud83d\udd34 React Hook useEffect missing dependencies: 'roomId' 'serverUrl' // ... } remove dependency, need \u201cprove\u201d linter doesn\u2019t need dependency. example, move serverUrl component prove it\u2019s reactive won\u2019t change re-renders: const serverUrl = 'https://localhost:1234'; // reactive value anymore function ChatRoom({ roomId }) { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, [roomId]); // \u2705 dependencies declared // ... } serverUrl reactive value (and can\u2019t change re-render), doesn\u2019t need dependency. Effect\u2019s code doesn\u2019t use reactive values, dependency list empty ([] ): const serverUrl = 'https://localhost:1234'; // reactive value anymore const roomId = 'music'; // reactive value anymore function ChatRoom() { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => connection.disconnect(); }, []); // \u2705 dependencies declared // ... } Effect empty dependencies doesn\u2019t re-run component\u2019s props state change. Example 1 3: Passing dependency array specify dependencies, Effect runs initial render re-renders changed dependencies. useEffect(() => { // ... }, [a, b]); // Runs b different example, serverUrl roomId reactive values, must specified dependencies. result, selecting different room dropdown editing server URL input causes chat re-connect. However, since message isn\u2019t used Effect (and isn\u2019t dependency), editing message doesn\u2019t re-connect chat. import { useState, useEffect } 'react'; import { createConnection } './chat.js'; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); const [message, setMessage] = useState(''); useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => { connection.disconnect(); }; }, [serverUrl, roomId]); return ( <> <label> Server URL:{' '} <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} /> </label> <h1>Welcome {roomId} room!</h1> <label> message:{' '} <input value={message} onChange={e => setMessage(e.target.value)} /> </label> </> ); } export default function App() { const [show, setShow] = useState(false); const [roomId, setRoomId] = useState('general'); return ( <> <label> Choose chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> <button onClick={() => setShow(!show)}> {show ? 'Close chat' : 'Open chat'} </button> </label> {show && <hr />} {show && <ChatRoom roomId={roomId}/>} </> ); } Updating state based previous state Effect want update state based previous state Effect, might run problem: function Counter() { const [count, setCount] = useState(0); useEffect(() => { const intervalId = setInterval(() => { setCount(count + 1); // want increment counter every second... }, 1000) return () => clearInterval(intervalId); }, [count]); // \ud83d\udea9 ... specifying `count` dependency always resets interval. // ... } Since count reactive value, must specified list dependencies. However, causes Effect cleanup setup every time count changes. ideal. fix this, pass c => c + 1 state updater setCount : import { useState, useEffect } 'react'; export default function Counter() { const [count, setCount] = useState(0); useEffect(() => { const intervalId = setInterval(() => { setCount(c => c + 1); // \u2705 Pass state updater }, 1000); return () => clearInterval(intervalId); }, []); // \u2705 count dependency return <h1>{count}</h1>; } you\u2019re passing c => c + 1 instead count + 1 , Effect longer needs depend count . result fix, won\u2019t need cleanup setup interval every time count changes. Removing unnecessary object dependencies Effect depends object function created rendering, might run often. example, Effect re-connects every render options object different every render: const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); const options = { // \ud83d\udea9 object created scratch every re-render serverUrl: serverUrl, roomId: roomId }; useEffect(() => { const connection = createConnection(options); // used inside Effect connection.connect(); return () => connection.disconnect(); }, [options]); // \ud83d\udea9 result, dependencies always different re-render // ... Avoid using object created rendering dependency. Instead, create object inside Effect: import { useState, useEffect } 'react'; import { createConnection } './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() => { const options = { serverUrl: serverUrl, roomId: roomId }; const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [roomId]); return ( <> <h1>Welcome {roomId} room!</h1> <input value={message} onChange={e => setMessage(e.target.value)} /> </> ); } export default function App() { const [roomId, setRoomId] = useState('general'); return ( <> <label> Choose chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> </label> <hr /> <ChatRoom roomId={roomId} /> </> ); } create options object inside Effect, Effect depends roomId string. fix, typing input doesn\u2019t reconnect chat. Unlike object gets re-created, string like roomId doesn\u2019t change unless set another value. Read removing dependencies. Removing unnecessary function dependencies Effect depends object function created rendering, might run often. example, Effect re-connects every render createOptions function different every render: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); function createOptions() { // \ud83d\udea9 function created scratch every re-render return { serverUrl: serverUrl, roomId: roomId }; } useEffect(() => { const options = createOptions(); // used inside Effect const connection = createConnection(); connection.connect(); return () => connection.disconnect(); }, [createOptions]); // \ud83d\udea9 result, dependencies always different re-render // ... itself, creating function scratch every re-render problem. don\u2019t need optimize that. However, use dependency Effect, cause Effect re-run every re-render. Avoid using function created rendering dependency. Instead, declare inside Effect: import { useState, useEffect } 'react'; import { createConnection } './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() => { function createOptions() { return { serverUrl: serverUrl, roomId: roomId }; } const options = createOptions(); const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [roomId]); return ( <> <h1>Welcome {roomId} room!</h1> <input value={message} onChange={e => setMessage(e.target.value)} /> </> ); } export default function App() { const [roomId, setRoomId] = useState('general'); return ( <> <label> Choose chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> </label> <hr /> <ChatRoom roomId={roomId} /> </> ); } define createOptions function inside Effect, Effect depends roomId string. fix, typing input doesn\u2019t reconnect chat. Unlike function gets re-created, string like roomId doesn\u2019t change unless set another value. Read removing dependencies. Reading latest props state Effect default, read reactive value Effect, add dependency. ensures Effect \u201creacts\u201d every change value. dependencies, that\u2019s behavior want. However, sometimes you\u2019ll want read latest props state Effect without \u201creacting\u201d them. example, imagine want log number items shopping cart every page visit: function Page({ url, shoppingCart }) { useEffect(() => { logVisit(url, shoppingCart.length); }, [url, shoppingCart]); // \u2705 dependencies declared // ... } want log new page visit every url change, shoppingCart changes? can\u2019t exclude shoppingCart dependencies without breaking reactivity rules. However, express don\u2019t want piece code \u201creact\u201d changes even though called inside Effect. Declare Effect Event useEffectEvent Hook, move code reading shoppingCart inside it: function Page({ url, shoppingCart }) { const onVisit = useEffectEvent(visitedUrl => { logVisit(visitedUrl, shoppingCart.length) }); useEffect(() => { onVisit(url); }, [url]); // \u2705 dependencies declared // ... } Effect Events reactive must always omitted dependencies Effect. lets put non-reactive code (where read latest value props state) inside them. reading shoppingCart inside onVisit , ensure shoppingCart won\u2019t re-run Effect. Read Effect Events let separate reactive non-reactive code. Displaying different content server client app uses server rendering (either directly via framework), component render two different environments. server, render produce initial HTML. client, React run rendering code attach event handlers HTML. why, hydration work, initial render output must identical client server. rare cases, might need display different content client. example, app reads data localStorage , can\u2019t possibly server. could implement this: function MyComponent() { const [didMount, setDidMount] = useState(false); useEffect(() => { setDidMount(true); }, []); (didMount) { // ... return client-only JSX ... } else { // ... return initial JSX ... } } app loading, user see initial render output. Then, it\u2019s loaded hydrated, Effect run set didMount true , triggering re-render. switch client-only render output. Effects don\u2019t run server, didMount false initial server render. Use pattern sparingly. Keep mind users slow connection see initial content quite bit time\u2014potentially, many seconds\u2014so don\u2019t want make jarring changes component\u2019s appearance. many cases, avoid need conditionally showing different things CSS. Troubleshooting Effect runs twice component mounts Strict Mode on, development, React runs setup cleanup one extra time actual setup. stress-test verifies Effect\u2019s logic implemented correctly. causes visible issues, cleanup function missing logic. cleanup function stop undo whatever setup function doing. rule thumb user shouldn\u2019t able distinguish setup called (as production) setup \u2192 cleanup \u2192 setup sequence (as development). Read helps find bugs fix logic. Effect runs every re-render First, check haven\u2019t forgotten specify dependency array: useEffect(() => { // ... }); // \ud83d\udea9 dependency array: re-runs every render! you\u2019ve specified dependency array Effect still re-runs loop, it\u2019s one dependencies different every re-render. debug problem manually logging dependencies console: useEffect(() => { // .. }, [serverUrl, roomId]); console.log([serverUrl, roomId]); right-click arrays different re-renders console select \u201cStore global variable\u201d them. Assuming first one got saved temp1 second one got saved temp2 , use browser console check whether dependency arrays same: Object.is(temp1[0], temp2[0]); // first dependency arrays? Object.is(temp1[1], temp2[1]); // second dependency arrays? Object.is(temp1[2], temp2[2]); // ... every dependency ... find dependency different every re-render, usually fix one ways: - Updating state based previous state Effect - Removing unnecessary object dependencies - Removing unnecessary function dependencies - Reading latest props state Effect last resort (if methods didn\u2019t help), wrap creation useMemo useCallback (for functions). Effect keeps re-running infinite cycle Effect runs infinite cycle, two things must true: - Effect updating state. - state leads re-render, causes Effect\u2019s dependencies change. start fixing problem, ask whether Effect connecting external system (like DOM, network, third-party widget, on). Effect need set state? synchronize external system? trying manage application\u2019s data flow it? external system, consider whether removing Effect altogether would simplify logic. you\u2019re genuinely synchronizing external system, think conditions Effect update state. something changed affects component\u2019s visual output? need keep track data isn\u2019t used rendering, ref (which doesn\u2019t trigger re-renders) might appropriate. Verify Effect doesn\u2019t update state (and trigger re-renders) needed. Finally, Effect updating state right time, still loop, it\u2019s state update leads one Effect\u2019s dependencies changing. Read debug dependency changes. cleanup logic runs even though component didn\u2019t unmount cleanup function runs unmount, every re-render changed dependencies. Additionally, development, React runs setup+cleanup one extra time immediately component mounts. cleanup code without corresponding setup code, it\u2019s usually code smell: useEffect(() => { // \ud83d\udd34 Avoid: Cleanup logic without corresponding setup logic return () => { doSomething(); }; }, []); cleanup logic \u201csymmetrical\u201d setup logic, stop undo whatever setup did: useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => { connection.disconnect(); }; }, [serverUrl, roomId]); Learn Effect lifecycle different component\u2019s lifecycle. Effect something visual, see flicker runs Effect must block browser painting screen, replace useEffect useLayoutEffect . Note shouldn\u2019t needed vast majority Effects. You\u2019ll need it\u2019s crucial run Effect browser paint: example, measure position tooltip user sees it."},
{"source": "https://react.dev/reference/react/useId", "title": "useId \u2013 React", "text": "useId useId React Hook generating unique IDs passed accessibility attributes. const id = useId() Reference useId() Call useId top level component generate unique ID: import { useId } 'react'; function PasswordField() { const passwordHintId = useId(); // ... Parameters useId take parameters. Returns useId returns unique ID string associated particular useId call particular component. Caveats - useId Hook, call top level component Hooks. can\u2019t call inside loops conditions. need that, extract new component move state it. - useId used generate keys list. Keys generated data. Usage Generating unique IDs accessibility attributes Call useId top level component generate unique ID: import { useId } 'react'; function PasswordField() { const passwordHintId = useId(); // ... pass generated ID different attributes: <> <input type=\"password\" aria-describedby={passwordHintId} /> <p id={passwordHintId}> </> Let\u2019s walk example see useful. HTML accessibility attributes like aria-describedby let specify two tags related other. example, specify element (like input) described another element (like paragraph). regular HTML, would write like this: <label> Password: <input type=\"password\" aria-describedby=\"password-hint\" /> </label> <p id=\"password-hint\"> password contain least 18 characters </p> However, hardcoding IDs like good practice React. component may rendered page\u2014but IDs unique! Instead hardcoding ID, generate unique ID useId : import { useId } 'react'; function PasswordField() { const passwordHintId = useId(); return ( <> <label> Password: <input type=\"password\" aria-describedby={passwordHintId} /> </label> <p id={passwordHintId}> password contain least 18 characters </p> </> ); } Now, even PasswordField appears multiple times screen, generated IDs won\u2019t clash. import { useId } 'react'; function PasswordField() { const passwordHintId = useId(); return ( <> <label> Password: <input type=\"password\" aria-describedby={passwordHintId} /> </label> <p id={passwordHintId}> password contain least 18 characters </p> </> ); } export default function App() { return ( <> <h2>Choose password</h2> <PasswordField /> <h2>Confirm password</h2> <PasswordField /> </> ); } Watch video see difference user experience assistive technologies. Deep Dive might wondering useId better incrementing global variable like nextId++ . primary benefit useId React ensures works server rendering. server rendering, components generate HTML output. Later, client, hydration attaches event handlers generated HTML. hydration work, client output must match server HTML. difficult guarantee incrementing counter order Client Components hydrated may match order server HTML emitted. calling useId , ensure hydration work, output match server client. Inside React, useId generated \u201cparent path\u201d calling component. why, client server tree same, \u201cparent path\u201d match regardless rendering order. Generating IDs several related elements need give IDs multiple related elements, call useId generate shared prefix them: import { useId } 'react'; export default function Form() { const id = useId(); return ( <form> <label htmlFor={id + '-firstName'}>First Name:</label> <input id={id + '-firstName'} type=\"text\" /> <hr /> <label htmlFor={id + '-lastName'}>Last Name:</label> <input id={id + '-lastName'} type=\"text\" /> </form> ); } lets avoid calling useId every single element needs unique ID. Specifying shared prefix generated IDs render multiple independent React applications single page, pass identifierPrefix option createRoot hydrateRoot calls. ensures IDs generated two different apps never clash every identifier generated useId start distinct prefix you\u2019ve specified. import { createRoot } 'react-dom/client'; import App './App.js'; import './styles.css'; const root1 = createRoot(document.getElementById('root1'), { identifierPrefix: 'my-first-app-' }); root1.render(<App />); const root2 = createRoot(document.getElementById('root2'), { identifierPrefix: 'my-second-app-' }); root2.render(<App />); Using ID prefix client server render multiple independent React apps page, apps server-rendered, make sure identifierPrefix pass hydrateRoot call client side identifierPrefix pass server APIs renderToPipeableStream . // Server import { renderToPipeableStream } 'react-dom/server'; const { pipe } = renderToPipeableStream( <App />, { identifierPrefix: 'react-app1' } ); // Client import { hydrateRoot } 'react-dom/client'; const domNode = document.getElementById('root'); const root = hydrateRoot( domNode, reactNode, { identifierPrefix: 'react-app1' } ); need pass identifierPrefix one React app page."},
{"source": "https://react.dev/reference/react/useImperativeHandle", "title": "useImperativeHandle \u2013 React", "text": "useImperativeHandle useImperativeHandle React Hook lets customize handle exposed ref. useImperativeHandle(ref, createHandle, dependencies?) Reference useImperativeHandle(ref, createHandle, dependencies?) Call useImperativeHandle top level component customize ref handle exposes: import { useImperativeHandle } 'react'; function MyInput({ ref }) { useImperativeHandle(ref, () => { return { // ... methods ... }; }, []); // ... Parameters - ref : Theref received prop theMyInput component. - createHandle : function takes arguments returns ref handle want expose. ref handle type. Usually, return object methods want expose. - optional dependencies : list reactive values referenced inside thecreateHandle code. Reactive values include props, state, variables functions declared directly inside component body. linter configured React, verify every reactive value correctly specified dependency. list dependencies must constant number items written inline like[dep1, dep2, dep3] . React compare dependency previous value using theObject.is comparison. re-render resulted change dependency, omitted argument, yourcreateHandle function re-execute, newly created handle assigned ref. Returns useImperativeHandle returns undefined . Usage Exposing custom ref handle parent component expose DOM node parent element, pass ref prop node. function MyInput({ ref }) { return <input ref={ref} />; }; code above, ref MyInput receive <input> DOM node. However, expose custom value instead. customize exposed handle, call useImperativeHandle top level component: import { useImperativeHandle } 'react'; function MyInput({ ref }) { useImperativeHandle(ref, () => { return { // ... methods ... }; }, []); return <input />; }; Note code above, ref longer passed <input> . example, suppose don\u2019t want expose entire <input> DOM node, want expose two methods: focus scrollIntoView . this, keep real browser DOM separate ref. use useImperativeHandle expose handle methods want parent component call: import { useRef, useImperativeHandle } 'react'; function MyInput({ ref }) { const inputRef = useRef(null); useImperativeHandle(ref, () => { return { focus() { inputRef.current.focus(); }, scrollIntoView() { inputRef.current.scrollIntoView(); }, }; }, []); return <input ref={inputRef} />; }; Now, parent component gets ref MyInput , able call focus scrollIntoView methods it. However, full access underlying <input> DOM node. import { useRef } 'react'; import MyInput './MyInput.js'; export default function Form() { const ref = useRef(null); function handleClick() { ref.current.focus(); // work DOM node exposed: // ref.current.style.opacity = 0.5; } return ( <form> <MyInput placeholder=\"Enter name\" ref={ref} /> <button type=\"button\" onClick={handleClick}> Edit </button> </form> ); } Exposing imperative methods methods expose via imperative handle don\u2019t match DOM methods exactly. example, Post component exposes scrollAndFocusAddComment method via imperative handle. lets parent Page scroll list comments focus input field click button: import { useRef } 'react'; import Post './Post.js'; export default function Page() { const postRef = useRef(null); function handleClick() { postRef.current.scrollAndFocusAddComment(); } return ( <> <button onClick={handleClick}> Write comment </button> <Post ref={postRef} /> </> ); }"},
{"source": "https://react.dev/reference/react/useInsertionEffect", "title": "useInsertionEffect \u2013 React", "text": "useInsertionEffect useInsertionEffect allows inserting elements DOM layout Effects fire. useInsertionEffect(setup, dependencies?) Reference useInsertionEffect(setup, dependencies?) Call useInsertionEffect insert styles Effects fire may need read layout: import { useInsertionEffect } 'react'; // Inside CSS-in-JS library function useCSS(rule) { useInsertionEffect(() => { // ... inject <style> tags ... }); return rule; } Parameters - setup : function Effect\u2019s logic. setup function may also optionally return cleanup function. component added DOM, layout Effects fire, React run setup function. every re-render changed dependencies, React first run cleanup function (if provided it) old values, run setup function new values. component removed DOM, React run cleanup function. - optional dependencies : list reactive values referenced inside thesetup code. Reactive values include props, state, variables functions declared directly inside component body. linter configured React, verify every reactive value correctly specified dependency. list dependencies must constant number items written inline like[dep1, dep2, dep3] . React compare dependency previous value using theObject.is comparison algorithm. don\u2019t specify dependencies all, Effect re-run every re-render component. Returns useInsertionEffect returns undefined . Caveats - Effects run client. don\u2019t run server rendering. - can\u2019t update state inside useInsertionEffect . - time useInsertionEffect runs, refs attached yet. useInsertionEffect may run either DOM updated. shouldn\u2019t rely DOM updated particular time.- Unlike types Effects, fire cleanup every Effect setup every Effect, useInsertionEffect fire cleanup setup one component time. results \u201cinterleaving\u201d cleanup setup functions. Usage Injecting dynamic styles CSS-in-JS libraries Traditionally, would style React components using plain CSS. // JS file: <button className=\"success\" /> // CSS file: .success { color: green; } teams prefer author styles directly JavaScript code instead writing CSS files. usually requires using CSS-in-JS library tool. three common approaches CSS-in-JS: - Static extraction CSS files compiler - Inline styles, e.g. <div style={{ opacity: 1 }}> - Runtime injection <style> tags use CSS-in-JS, recommend combination first two approaches (CSS files static styles, inline styles dynamic styles). don\u2019t recommend runtime <style> tag injection two reasons: - Runtime injection forces browser recalculate styles lot often. - Runtime injection slow happens wrong time React lifecycle. first problem solvable, useInsertionEffect helps solve second problem. Call useInsertionEffect insert styles layout Effects fire: // Inside CSS-in-JS library let isInserted = new Set(); function useCSS(rule) { useInsertionEffect(() => { // explained earlier, recommend runtime injection <style> tags. // it, important useInsertionEffect. (!isInserted.has(rule)) { isInserted.add(rule); document.head.appendChild(getStyleForRule(rule)); } }); return rule; } function Button() { const className = useCSS('...'); return <div className={className} />; } Similarly useEffect , useInsertionEffect run server. need collect CSS rules used server, rendering: let collectedRulesSet = new Set(); function useCSS(rule) { (typeof window === 'undefined') { collectedRulesSet.add(rule); } useInsertionEffect(() => { // ... }); return rule; } Read upgrading CSS-in-JS libraries runtime injection useInsertionEffect . Deep Dive insert styles rendering React processing non-blocking update, browser recalculate styles every single frame rendering component tree, extremely slow. useInsertionEffect better inserting styles useLayoutEffect useEffect ensures time Effects run components, <style> tags already inserted. Otherwise, layout calculations regular Effects would wrong due outdated styles."},
{"source": "https://react.dev/reference/react/useLayoutEffect", "title": "useLayoutEffect \u2013 React", "text": "useLayoutEffect useLayoutEffect version useEffect fires browser repaints screen. useLayoutEffect(setup, dependencies?) Reference useLayoutEffect(setup, dependencies?) Call useLayoutEffect perform layout measurements browser repaints screen: import { useState, useRef, useLayoutEffect } 'react'; function Tooltip() { const ref = useRef(null); const [tooltipHeight, setTooltipHeight] = useState(0); useLayoutEffect(() => { const { height } = ref.current.getBoundingClientRect(); setTooltipHeight(height); }, []); // ... Parameters - setup : function Effect\u2019s logic. setup function may also optionally return cleanup function. component added DOM, React run setup function. every re-render changed dependencies, React first run cleanup function (if provided it) old values, run setup function new values. component removed DOM, React run cleanup function. - optional dependencies : list reactive values referenced inside thesetup code. Reactive values include props, state, variables functions declared directly inside component body. linter configured React, verify every reactive value correctly specified dependency. list dependencies must constant number items written inline like[dep1, dep2, dep3] . React compare dependency previous value using theObject.is comparison. omit argument, Effect re-run every re-render component. Returns useLayoutEffect returns undefined . Caveats - useLayoutEffect Hook, call top level component Hooks. can\u2019t call inside loops conditions. need that, extract component move Effect there. - Strict Mode on, React run one extra development-only setup+cleanup cycle first real setup. stress-test ensures cleanup logic \u201cmirrors\u201d setup logic stops undoes whatever setup doing. causes problem, implement cleanup function. - dependencies objects functions defined inside component, risk cause Effect re-run often needed. fix this, remove unnecessary object function dependencies. also extract state updates non-reactive logic outside Effect. - Effects run client. don\u2019t run server rendering. - code inside useLayoutEffect state updates scheduled block browser repainting screen. used excessively, makes app slow. possible, preferuseEffect . - trigger state update inside useLayoutEffect , React execute remaining Effects immediately includinguseEffect . Usage Measuring layout browser repaints screen components don\u2019t need know position size screen decide render. return JSX. browser calculates layout (position size) repaints screen. Sometimes, that\u2019s enough. Imagine tooltip appears next element hover. there\u2019s enough space, tooltip appear element, doesn\u2019t fit, appear below. order render tooltip right final position, need know height (i.e. whether fits top). this, need render two passes: - Render tooltip anywhere (even wrong position). - Measure height decide place tooltip. - Render tooltip correct place. needs happen browser repaints screen. don\u2019t want user see tooltip moving. Call useLayoutEffect perform layout measurements browser repaints screen: function Tooltip() { const ref = useRef(null); const [tooltipHeight, setTooltipHeight] = useState(0); // know real height yet useLayoutEffect(() => { const { height } = ref.current.getBoundingClientRect(); setTooltipHeight(height); // Re-render know real height }, []); // ...use tooltipHeight rendering logic below... } Here\u2019s works step step: Tooltip renders initialtooltipHeight = 0 (so tooltip may wrongly positioned).- React places DOM runs code useLayoutEffect . - useLayoutEffect measures height tooltip content triggers immediate re-render. Tooltip renders realtooltipHeight (so tooltip correctly positioned).- React updates DOM, browser finally displays tooltip. Hover buttons see tooltip adjusts position depending whether fits: import { useRef, useLayoutEffect, useState } 'react'; import { createPortal } 'react-dom'; import TooltipContainer './TooltipContainer.js'; export default function Tooltip({ children, targetRect }) { const ref = useRef(null); const [tooltipHeight, setTooltipHeight] = useState(0); useLayoutEffect(() => { const { height } = ref.current.getBoundingClientRect(); setTooltipHeight(height); console.log('Measured tooltip height: ' + height); }, []); let tooltipX = 0; let tooltipY = 0; (targetRect !== null) { tooltipX = targetRect.left; tooltipY = targetRect.top - tooltipHeight; (tooltipY < 0) { // fit above, place below. tooltipY = targetRect.bottom; } } return createPortal( <TooltipContainer x={tooltipX} y={tooltipY} contentRef={ref}> {children} </TooltipContainer>, document.body ); } Notice even though Tooltip component render two passes (first, tooltipHeight initialized 0 real measured height), see final result. need useLayoutEffect instead useEffect example. Let\u2019s look difference detail below. Example 1 2: useLayoutEffect blocks browser repainting React guarantees code inside useLayoutEffect state updates scheduled inside processed browser repaints screen. lets render tooltip, measure it, re-render tooltip without user noticing first extra render. words, useLayoutEffect blocks browser painting. import { useRef, useLayoutEffect, useState } 'react'; import { createPortal } 'react-dom'; import TooltipContainer './TooltipContainer.js'; export default function Tooltip({ children, targetRect }) { const ref = useRef(null); const [tooltipHeight, setTooltipHeight] = useState(0); useLayoutEffect(() => { const { height } = ref.current.getBoundingClientRect(); setTooltipHeight(height); }, []); let tooltipX = 0; let tooltipY = 0; (targetRect !== null) { tooltipX = targetRect.left; tooltipY = targetRect.top - tooltipHeight; (tooltipY < 0) { // fit above, place below. tooltipY = targetRect.bottom; } } return createPortal( <TooltipContainer x={tooltipX} y={tooltipY} contentRef={ref}> {children} </TooltipContainer>, document.body ); } Troubleshooting I\u2019m getting error: \u201cuseLayoutEffect nothing server\u201d purpose useLayoutEffect let component use layout information rendering: - Render initial content. - Measure layout browser repaints screen. - Render final content using layout information you\u2019ve read. framework uses server rendering, React app renders HTML server initial render. lets show initial HTML JavaScript code loads. problem server, layout information. earlier example, useLayoutEffect call Tooltip component lets position correctly (either content) depending content height. tried render Tooltip part initial server HTML, would impossible determine. server, layout yet! So, even rendered server, position would \u201cjump\u201d client JavaScript loads runs. Usually, components rely layout information don\u2019t need render server anyway. example, probably doesn\u2019t make sense show Tooltip initial render. triggered client interaction. However, you\u2019re running problem, different options: - Replace useLayoutEffect withuseEffect . tells React it\u2019s okay display initial render result without blocking paint (because original HTML become visible Effect runs). - Alternatively, mark component client-only. tells React replace content closest <Suspense> boundary loading fallback (for example, spinner glimmer) server rendering. - Alternatively, render component useLayoutEffect hydration. Keep booleanisMounted state that\u2019s initialized tofalse , set totrue inside auseEffect call. rendering logic likereturn isMounted ? <RealContent /> : <FallbackContent /> . server hydration, user seeFallbackContent calluseLayoutEffect . React replace withRealContent runs client includeuseLayoutEffect calls. - synchronize component external data store rely useLayoutEffect different reasons measuring layout, consideruseSyncExternalStore instead supports server rendering."},
{"source": "https://react.dev/reference/react/useMemo", "title": "useMemo \u2013 React", "text": "useMemo useMemo React Hook lets cache result calculation re-renders. const cachedValue = useMemo(calculateValue, dependencies) Reference useMemo(calculateValue, dependencies) Call useMemo top level component cache calculation re-renders: import { useMemo } 'react'; function TodoList({ todos, tab }) { const visibleTodos = useMemo( () => filterTodos(todos, tab), [todos, tab] ); // ... } Parameters - calculateValue : function calculating value want cache. pure, take arguments, return value type. React call function initial render. next renders, React return value thedependencies changed since last render. Otherwise, callcalculateValue , return result, store reused later. - dependencies : list reactive values referenced inside thecalculateValue code. Reactive values include props, state, variables functions declared directly inside component body. linter configured React, verify every reactive value correctly specified dependency. list dependencies must constant number items written inline like[dep1, dep2, dep3] . React compare dependency previous value using theObject.is comparison. Returns initial render, useMemo returns result calling calculateValue arguments. next renders, either return already stored value last render (if dependencies haven\u2019t changed), call calculateValue again, return result calculateValue returned. Caveats useMemo Hook, call top level component Hooks. can\u2019t call inside loops conditions. need that, extract new component move state it.- Strict Mode, React call calculation function twice order help find accidental impurities. development-only behavior affect production. calculation function pure (as be), affect logic. result one calls ignored. - React throw away cached value unless specific reason that. example, development, React throws away cache edit file component. development production, React throw away cache component suspends initial mount. future, React may add features take advantage throwing away cache\u2014for example, React adds built-in support virtualized lists future, would make sense throw away cache items scroll virtualized table viewport. fine rely useMemo solely performance optimization. Otherwise, state variable ref may appropriate. Usage Skipping expensive recalculations cache calculation re-renders, wrap useMemo call top level component: import { useMemo } 'react'; function TodoList({ todos, tab, theme }) { const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]); // ... } need pass two things useMemo : - calculation function takes arguments, like () => , returns wanted calculate. - list dependencies including every value within component that\u2019s used inside calculation. initial render, value you\u2019ll get useMemo result calling calculation. every subsequent render, React compare dependencies dependencies passed last render. none dependencies changed (compared Object.is ), useMemo return value already calculated before. Otherwise, React re-run calculation return new value. words, useMemo caches calculation result re-renders dependencies change. Let\u2019s walk example see useful. default, React re-run entire body component every time re-renders. example, TodoList updates state receives new props parent, filterTodos function re-run: function TodoList({ todos, tab, theme }) { const visibleTodos = filterTodos(todos, tab); // ... } Usually, isn\u2019t problem calculations fast. However, you\u2019re filtering transforming large array, expensive computation, might want skip data hasn\u2019t changed. todos tab last render, wrapping calculation useMemo like earlier lets reuse visibleTodos you\u2019ve already calculated before. type caching called memoization. Deep Dive general, unless you\u2019re creating looping thousands objects, it\u2019s probably expensive. want get confidence, add console log measure time spent piece code: console.time('filter array'); const visibleTodos = filterTodos(todos, tab); console.timeEnd('filter array'); Perform interaction you\u2019re measuring (for example, typing input). see logs like filter array: 0.15ms console. overall logged time adds significant amount (say, 1ms more), might make sense memoize calculation. experiment, wrap calculation useMemo verify whether total logged time decreased interaction not: console.time('filter array'); const visibleTodos = useMemo(() => { return filterTodos(todos, tab); // Skipped todos tab changed }, [todos, tab]); console.timeEnd('filter array'); useMemo won\u2019t make first render faster. helps skip unnecessary work updates. Keep mind machine probably faster users\u2019 it\u2019s good idea test performance artificial slowdown. example, Chrome offers CPU Throttling option this. Also note measuring performance development give accurate results. (For example, Strict Mode on, see component render twice rather once.) get accurate timings, build app production test device like users have. Deep Dive app like site, interactions coarse (like replacing page entire section), memoization usually unnecessary. hand, app like drawing editor, interactions granular (like moving shapes), might find memoization helpful. Optimizing useMemo valuable cases: - calculation you\u2019re putting useMemo noticeably slow, dependencies rarely change. - pass prop component wrapped memo . want skip re-rendering value hasn\u2019t changed. Memoization lets component re-render dependencies aren\u2019t same. - value you\u2019re passing later used dependency Hook. example, maybe another useMemo calculation value depends it. maybe depending value fromuseEffect. benefit wrapping calculation useMemo cases. significant harm either, teams choose think individual cases, memoize much possible. downside approach code becomes less readable. Also, memoization effective: single value that\u2019s \u201calways new\u201d enough break memoization entire component. practice, make lot memoization unnecessary following principles: - component visually wraps components, let accept JSX children. way, wrapper component updates state, React knows children don\u2019t need re-render. - Prefer local state don\u2019t lift state necessary. example, don\u2019t keep transient state like forms whether item hovered top tree global state library. - Keep rendering logic pure. re-rendering component causes problem produces noticeable visual artifact, it\u2019s bug component! Fix bug instead adding memoization. - Avoid unnecessary Effects update state. performance problems React apps caused chains updates originating Effects cause components render over. - Try remove unnecessary dependencies Effects. example, instead memoization, it\u2019s often simpler move object function inside Effect outside component. specific interaction still feels laggy, use React Developer Tools profiler see components would benefit memoization, add memoization needed. principles make components easier debug understand, it\u2019s good follow case. long term, we\u2019re researching granular memoization automatically solve all. Example 1 2: Skipping recalculation useMemo example, filterTodos implementation artificially slowed see happens JavaScript function you\u2019re calling rendering genuinely slow. Try switching tabs toggling theme. Switching tabs feels slow forces slowed filterTodos re-execute. That\u2019s expected tab changed, entire calculation needs re-run. (If you\u2019re curious runs twice, it\u2019s explained here.) Toggle theme. Thanks useMemo , it\u2019s fast despite artificial slowdown! slow filterTodos call skipped todos tab (which pass dependencies useMemo ) haven\u2019t changed since last render. import { useMemo } 'react'; import { filterTodos } './utils.js' export default function TodoList({ todos, theme, tab }) { const visibleTodos = useMemo( () => filterTodos(todos, tab), [todos, tab] ); return ( <div className={theme}> <p><b>Note: <code>filterTodos</code> artificially slowed down!</b></p> <ul> {visibleTodos.map(todo => ( <li key={todo.id}> {todo.completed ? <s>{todo.text}</s> : todo.text } </li> ))} </ul> </div> ); } Skipping re-rendering components cases, useMemo also help optimize performance re-rendering child components. illustrate this, let\u2019s say TodoList component passes visibleTodos prop child List component: export default function TodoList({ todos, tab, theme }) { // ... return ( <div className={theme}> <List items={visibleTodos} /> </div> ); } You\u2019ve noticed toggling theme prop freezes app moment, remove <List /> JSX, feels fast. tells it\u2019s worth trying optimize List component. default, component re-renders, React re-renders children recursively. why, TodoList re-renders different theme , List component also re-renders. fine components don\u2019t require much calculation re-render. you\u2019ve verified re-render slow, tell List skip re-rendering props last render wrapping memo : import { memo } 'react'; const List = memo(function List({ items }) { // ... }); change, List skip re-rendering props last render. caching calculation becomes important! Imagine calculated visibleTodos without useMemo : export default function TodoList({ todos, tab, theme }) { // Every time theme changes, different array... const visibleTodos = filterTodos(todos, tab); return ( <div className={theme}> {/* ... List's props never same, re-render every time */} <List items={visibleTodos} /> </div> ); } example, filterTodos function always creates different array, similar {} object literal always creates new object. Normally, wouldn\u2019t problem, means List props never same, memo optimization won\u2019t work. useMemo comes handy: export default function TodoList({ todos, tab, theme }) { // Tell React cache calculation re-renders... const visibleTodos = useMemo( () => filterTodos(todos, tab), [todos, tab] // ...so long dependencies change... ); return ( <div className={theme}> {/* ...List receive props skip re-rendering */} <List items={visibleTodos} /> </div> ); } wrapping visibleTodos calculation useMemo , ensure value re-renders (until dependencies change). don\u2019t wrap calculation useMemo unless specific reason. example, reason pass component wrapped memo , lets skip re-rendering. reasons add useMemo described page. Deep Dive Instead wrapping List memo , could wrap <List /> JSX node useMemo : export default function TodoList({ todos, tab, theme }) { const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]); const children = useMemo(() => <List items={visibleTodos} />, [visibleTodos]); return ( <div className={theme}> {children} </div> ); } behavior would same. visibleTodos haven\u2019t changed, List won\u2019t re-rendered. JSX node like <List items={visibleTodos} /> object like { type: List, props: { items: visibleTodos } } . Creating object cheap, React doesn\u2019t know whether contents last time not. default, React re-render List component. However, React sees exact JSX previous render, won\u2019t try re-render component. JSX nodes immutable. JSX node object could changed time, React knows it\u2019s safe skip re-render. However, work, node actually object, merely look code. useMemo example. Manually wrapping JSX nodes useMemo convenient. example, can\u2019t conditionally. usually would wrap components memo instead wrapping JSX nodes. Example 1 2: Skipping re-rendering useMemo memo example, List component artificially slowed see happens React component you\u2019re rendering genuinely slow. Try switching tabs toggling theme. Switching tabs feels slow forces slowed List re-render. That\u2019s expected tab changed, need reflect user\u2019s new choice screen. Next, try toggling theme. Thanks useMemo together memo , it\u2019s fast despite artificial slowdown! List skipped re-rendering visibleTodos array changed since last render. visibleTodos array changed todos tab (which pass dependencies useMemo ) haven\u2019t changed since last render. import { useMemo } 'react'; import List './List.js'; import { filterTodos } './utils.js' export default function TodoList({ todos, theme, tab }) { const visibleTodos = useMemo( () => filterTodos(todos, tab), [todos, tab] ); return ( <div className={theme}> <p><b>Note: <code>List</code> artificially slowed down!</b></p> <List items={visibleTodos} /> </div> ); } Preventing Effect firing often Sometimes, might want use value inside Effect: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); const options = { serverUrl: 'https://localhost:1234', roomId: roomId } useEffect(() => { const connection = createConnection(options); connection.connect(); // ... creates problem. Every reactive value must declared dependency Effect. However, declare options dependency, cause Effect constantly reconnect chat room: useEffect(() => { const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [options]); // \ud83d\udd34 Problem: dependency changes every render // ... solve this, wrap object need call Effect useMemo : function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); const options = useMemo(() => { return { serverUrl: 'https://localhost:1234', roomId: roomId }; }, [roomId]); // \u2705 changes roomId changes useEffect(() => { const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [options]); // \u2705 changes options changes // ... ensures options object re-renders useMemo returns cached object. However, since useMemo performance optimization, semantic guarantee, React may throw away cached value specific reason that. also cause effect re-fire, it\u2019s even better remove need function dependency moving object inside Effect: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() => { const options = { // \u2705 need useMemo object dependencies! serverUrl: 'https://localhost:1234', roomId: roomId } const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [roomId]); // \u2705 changes roomId changes // ... code simpler doesn\u2019t need useMemo . Learn removing Effect dependencies. Memoizing dependency another Hook Suppose calculation depends object created directly component body: function Dropdown({ allItems, text }) { const searchOptions = { matchMode: 'whole-word', text }; const visibleItems = useMemo(() => { return searchItems(allItems, searchOptions); }, [allItems, searchOptions]); // \ud83d\udea9 Caution: Dependency object created component body // ... Depending object like defeats point memoization. component re-renders, code directly inside component body runs again. lines code creating searchOptions object also run every re-render. Since searchOptions dependency useMemo call, it\u2019s different every time, React knows dependencies different, recalculate searchItems every time. fix this, could memoize searchOptions object passing dependency: function Dropdown({ allItems, text }) { const searchOptions = useMemo(() => { return { matchMode: 'whole-word', text }; }, [text]); // \u2705 changes text changes const visibleItems = useMemo(() => { return searchItems(allItems, searchOptions); }, [allItems, searchOptions]); // \u2705 changes allItems searchOptions changes // ... example above, text change, searchOptions object also won\u2019t change. However, even better fix move searchOptions object declaration inside useMemo calculation function: function Dropdown({ allItems, text }) { const visibleItems = useMemo(() => { const searchOptions = { matchMode: 'whole-word', text }; return searchItems(allItems, searchOptions); }, [allItems, text]); // \u2705 changes allItems text changes // ... calculation depends text directly (which string can\u2019t \u201caccidentally\u201d become different). Memoizing function Suppose Form component wrapped memo . want pass function prop: export default function ProductPage({ productId, referrer }) { function handleSubmit(orderDetails) { post('/product/' + productId + '/buy', { referrer, orderDetails }); } return <Form onSubmit={handleSubmit} />; } {} creates different object, function declarations like function() {} expressions like () => {} produce different function every re-render. itself, creating new function problem. something avoid! However, Form component memoized, presumably want skip re-rendering props changed. prop always different would defeat point memoization. memoize function useMemo , calculation function would return another function: export default function Page({ productId, referrer }) { const handleSubmit = useMemo(() => { return (orderDetails) => { post('/product/' + productId + '/buy', { referrer, orderDetails }); }; }, [productId, referrer]); return <Form onSubmit={handleSubmit} />; } looks clunky! Memoizing functions common enough React built-in Hook specifically that. Wrap functions useCallback instead useMemo avoid write extra nested function: export default function Page({ productId, referrer }) { const handleSubmit = useCallback((orderDetails) => { post('/product/' + productId + '/buy', { referrer, orderDetails }); }, [productId, referrer]); return <Form onSubmit={handleSubmit} />; } two examples completely equivalent. benefit useCallback lets avoid writing extra nested function inside. doesn\u2019t anything else. Read useCallback . Troubleshooting calculation runs twice every re-render Strict Mode, React call functions twice instead once: function TodoList({ todos, tab }) { // component function run twice every render. const visibleTodos = useMemo(() => { // calculation run twice dependencies change. return filterTodos(todos, tab); }, [todos, tab]); // ... expected shouldn\u2019t break code. development-only behavior helps keep components pure. React uses result one calls, ignores result call. long component calculation functions pure, shouldn\u2019t affect logic. However, accidentally impure, helps notice fix mistake. example, impure calculation function mutates array received prop: const visibleTodos = useMemo(() => { // \ud83d\udea9 Mistake: mutating prop todos.push({ id: 'last', text: 'Go walk!' }); const filtered = filterTodos(todos, tab); return filtered; }, [todos, tab]); React calls function twice, you\u2019d notice todo added twice. calculation shouldn\u2019t change existing objects, it\u2019s okay change new objects created calculation. example, filterTodos function always returns different array, mutate array instead: const visibleTodos = useMemo(() => { const filtered = filterTodos(todos, tab); // \u2705 Correct: mutating object created calculation filtered.push({ id: 'last', text: 'Go walk!' }); return filtered; }, [todos, tab]); Read keeping components pure learn purity. Also, check guides updating objects updating arrays without mutation. useMemo call supposed return object, returns undefined code doesn\u2019t work: // \ud83d\udd34 can't return object arrow function () => { const searchOptions = useMemo(() => { matchMode: 'whole-word', text: text }, [text]); JavaScript, () => { starts arrow function body, { brace part object. doesn\u2019t return object, leads mistakes. could fix adding parentheses like ({ }) : // works, easy someone break const searchOptions = useMemo(() => ({ matchMode: 'whole-word', text: text }), [text]); However, still confusing easy someone break removing parentheses. avoid mistake, write return statement explicitly: // \u2705 works explicit const searchOptions = useMemo(() => { return { matchMode: 'whole-word', text: text }; }, [text]); Every time component renders, calculation useMemo re-runs Make sure you\u2019ve specified dependency array second argument! forget dependency array, useMemo re-run calculation every time: function TodoList({ todos, tab }) { // \ud83d\udd34 Recalculates every time: dependency array const visibleTodos = useMemo(() => filterTodos(todos, tab)); // ... corrected version passing dependency array second argument: function TodoList({ todos, tab }) { // \u2705 recalculate unnecessarily const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]); // ... doesn\u2019t help, problem least one dependencies different previous render. debug problem manually logging dependencies console: const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]); console.log([todos, tab]); right-click arrays different re-renders console select \u201cStore global variable\u201d them. Assuming first one got saved temp1 second one got saved temp2 , use browser console check whether dependency arrays same: Object.is(temp1[0], temp2[0]); // first dependency arrays? Object.is(temp1[1], temp2[1]); // second dependency arrays? Object.is(temp1[2], temp2[2]); // ... every dependency ... find dependency breaks memoization, either find way remove it, memoize well. need call useMemo list item loop, it\u2019s allowed Suppose Chart component wrapped memo . want skip re-rendering every Chart list ReportList component re-renders. However, can\u2019t call useMemo loop: function ReportList({ items }) { return ( <article> {items.map(item => { // \ud83d\udd34 can't call useMemo loop like this: const data = useMemo(() => calculateReport(item), [item]); return ( <figure key={item.id}> <Chart data={data} /> </figure> ); })} </article> ); } Instead, extract component item memoize data individual items: function ReportList({ items }) { return ( <article> {items.map(item => <Report key={item.id} item={item} /> )} </article> ); } function Report({ item }) { // \u2705 Call useMemo top level: const data = useMemo(() => calculateReport(item), [item]); return ( <figure> <Chart data={data} /> </figure> ); } Alternatively, could remove useMemo instead wrap Report memo . item prop change, Report skip re-rendering, Chart skip re-rendering too: function ReportList({ items }) { // ... } const Report = memo(function Report({ item }) { const data = calculateReport(item); return ( <figure> <Chart data={data} /> </figure> ); });"},
{"source": "https://react.dev/reference/react/useOptimistic", "title": "useOptimistic \u2013 React", "text": "useOptimistic useOptimistic React Hook lets optimistically update UI. const [optimisticState, addOptimistic] = useOptimistic(state, updateFn); Reference useOptimistic(state, updateFn) useOptimistic React Hook lets show different state async action underway. accepts state argument returns copy state different duration async action network request. provide function takes current state input action, returns optimistic state used action pending. state called \u201coptimistic\u201d state usually used immediately present user result performing action, even though action actually takes time complete. import { useOptimistic } 'react'; function AppContainer() { const [optimisticState, addOptimistic] = useOptimistic( state, // updateFn (currentState, optimisticValue) => { // merge return new state // optimistic value } ); } Parameters state : value returned initially whenever action pending.updateFn(currentState, optimisticValue) : function takes current state optimistic value passed toaddOptimistic returns resulting optimistic state. must pure function.updateFn takes two parameters. ThecurrentState theoptimisticValue . return value merged value thecurrentState andoptimisticValue . Returns optimisticState : resulting optimistic state. equal tostate unless action pending, case equal value returned byupdateFn .addOptimistic :addOptimistic dispatching function call optimistic update. takes one argument,optimisticValue , type call theupdateFn withstate andoptimisticValue . Usage Optimistically updating forms useOptimistic Hook provides way optimistically update user interface background operation, like network request, completes. context forms, technique helps make apps feel responsive. user submits form, instead waiting server\u2019s response reflect changes, interface immediately updated expected outcome. example, user types message form hits \u201cSend\u201d button, useOptimistic Hook allows message immediately appear list \u201cSending\u2026\u201d label, even message actually sent server. \u201coptimistic\u201d approach gives impression speed responsiveness. form attempts truly send message background. server confirms message received, \u201cSending\u2026\u201d label removed. import { useOptimistic, useState, useRef } \"react\"; import { deliverMessage } \"./actions.js\"; function Thread({ messages, sendMessage }) { const formRef = useRef(); async function formAction(formData) { addOptimisticMessage(formData.get(\"message\")); formRef.current.reset(); await sendMessage(formData); } const [optimisticMessages, addOptimisticMessage] = useOptimistic( messages, (state, newMessage) => [ ...state, { text: newMessage, sending: true } ] ); return ( <> {optimisticMessages.map((message, index) => ( <div key={index}> {message.text} {!!message.sending && <small> (Sending...)</small>} </div> ))} <form action={formAction} ref={formRef}> <input type=\"text\" name=\"message\" placeholder=\"Hello!\" /> <button type=\"submit\">Send</button> </form> </> ); } export default function App() { const [messages, setMessages] = useState([ { text: \"Hello there!\", sending: false, key: 1 } ]); async function sendMessage(formData) { const sentMessage = await deliverMessage(formData.get(\"message\")); setMessages((messages) => [...messages, { text: sentMessage }]); } return <Thread messages={messages} sendMessage={sendMessage} />; }"},
{"source": "https://react.dev/reference/react/useReducer", "title": "useReducer \u2013 React", "text": "useReducer useReducer React Hook lets add reducer component. const [state, dispatch] = useReducer(reducer, initialArg, init?) - Reference - Usage - Troubleshooting - I\u2019ve dispatched action, logging gives old state value - I\u2019ve dispatched action, screen doesn\u2019t update - part reducer state becomes undefined dispatching - entire reducer state becomes undefined dispatching - I\u2019m getting error: \u201cToo many re-renders\u201d - reducer initializer function runs twice Reference useReducer(reducer, initialArg, init?) Call useReducer top level component manage state reducer. import { useReducer } 'react'; function reducer(state, action) { // ... } function MyComponent() { const [state, dispatch] = useReducer(reducer, { age: 42 }); // ... Parameters reducer : reducer function specifies state gets updated. must pure, take state action arguments, return next state. State action types.initialArg : value initial state calculated. value type. initial state calculated depends nextinit argument.- optional init : initializer function return initial state. it\u2019s specified, initial state set toinitialArg . Otherwise, initial state set result callinginit(initialArg) . Returns useReducer returns array exactly two values: - current state. first render, it\u2019s set init(initialArg) orinitialArg (if there\u2019s noinit ). - dispatch function lets update state different value trigger re-render. Caveats useReducer Hook, call top level component Hooks. can\u2019t call inside loops conditions. need that, extract new component move state it.- dispatch function stable identity, often see omitted Effect dependencies, including cause Effect fire. linter lets omit dependency without errors, safe do. Learn removing Effect dependencies. - Strict Mode, React call reducer initializer twice order help find accidental impurities. development-only behavior affect production. reducer initializer pure (as be), affect logic. result one calls ignored. dispatch function dispatch function returned useReducer lets update state different value trigger re-render. need pass action argument dispatch function: const [state, dispatch] = useReducer(reducer, { age: 42 }); function handleClick() { dispatch({ type: 'incremented_age' }); // ... React set next state result calling reducer function you\u2019ve provided current state action you\u2019ve passed dispatch . Parameters action : action performed user. value type. convention, action usually object atype property identifying and, optionally, properties additional information. Returns dispatch functions return value. Caveats - dispatch function updates state variable next render. read state variable calling thedispatch function, still get old value screen call. - new value provide identical current state , determined anObject.is comparison, React skip re-rendering component children. optimization. React may still need call component ignoring result, shouldn\u2019t affect code. - React batches state updates. updates screen event handlers run called set functions. prevents multiple re-renders single event. rare case need force React update screen earlier, example access DOM, useflushSync . Usage Adding reducer component Call useReducer top level component manage state reducer. import { useReducer } 'react'; function reducer(state, action) { // ... } function MyComponent() { const [state, dispatch] = useReducer(reducer, { age: 42 }); // ... useReducer returns array exactly two items: - current state state variable, initially set initial state provided. - dispatch function lets change response interaction. update what\u2019s screen, call dispatch object representing user did, called action: function handleClick() { dispatch({ type: 'incremented_age' }); } React pass current state action reducer function. reducer calculate return next state. React store next state, render component it, update UI. import { useReducer } 'react'; function reducer(state, action) { (action.type === 'incremented_age') { return { age: state.age + 1 }; } throw Error('Unknown action.'); } export default function Counter() { const [state, dispatch] = useReducer(reducer, { age: 42 }); return ( <> <button onClick={() => { dispatch({ type: 'incremented_age' }) }}> Increment age </button> <p>Hello! {state.age}.</p> </> ); } useReducer similar useState , lets move state update logic event handlers single function outside component. Read choosing useState useReducer . Writing reducer function reducer function declared like this: function reducer(state, action) { // ... } need fill code calculate return next state. convention, common write switch statement. case switch , calculate return next state. function reducer(state, action) { switch (action.type) { case 'incremented_age': { return { name: state.name, age: state.age + 1 }; } case 'changed_name': { return { name: action.nextName, age: state.age }; } } throw Error('Unknown action: ' + action.type); } Actions shape. convention, it\u2019s common pass objects type property identifying action. include minimal necessary information reducer needs compute next state. function Form() { const [state, dispatch] = useReducer(reducer, { name: 'Taylor', age: 42 }); function handleButtonClick() { dispatch({ type: 'incremented_age' }); } function handleInputChange(e) { dispatch({ type: 'changed_name', nextName: e.target.value }); } // ... action type names local component. action describes single interaction, even leads multiple changes data. shape state arbitrary, usually it\u2019ll object array. Read extracting state logic reducer learn more. Example 1 3: Form (object) example, reducer manages state object two fields: name age . import { useReducer } 'react'; function reducer(state, action) { switch (action.type) { case 'incremented_age': { return { name: state.name, age: state.age + 1 }; } case 'changed_name': { return { name: action.nextName, age: state.age }; } } throw Error('Unknown action: ' + action.type); } const initialState = { name: 'Taylor', age: 42 }; export default function Form() { const [state, dispatch] = useReducer(reducer, initialState); function handleButtonClick() { dispatch({ type: 'incremented_age' }); } function handleInputChange(e) { dispatch({ type: 'changed_name', nextName: e.target.value }); } return ( <> <input value={state.name} onChange={handleInputChange} /> <button onClick={handleButtonClick}> Increment age </button> <p>Hello, {state.name}. {state.age}.</p> </> ); } Avoiding recreating initial state React saves initial state ignores next renders. function createInitialState(username) { // ... } function TodoList({ username }) { const [state, dispatch] = useReducer(reducer, createInitialState(username)); // ... Although result createInitialState(username) used initial render, you\u2019re still calling function every render. wasteful it\u2019s creating large arrays performing expensive calculations. solve this, may pass initializer function useReducer third argument instead: function createInitialState(username) { // ... } function TodoList({ username }) { const [state, dispatch] = useReducer(reducer, username, createInitialState); // ... Notice you\u2019re passing createInitialState , function itself, createInitialState() , result calling it. way, initial state get re-created initialization. example, createInitialState takes username argument. initializer doesn\u2019t need information compute initial state, may pass null second argument useReducer . Example 1 2: Passing initializer function example passes initializer function, createInitialState function runs initialization. run component re-renders, type input. import { useReducer } 'react'; function createInitialState(username) { const initialTodos = []; (let = 0; < 50; i++) { initialTodos.push({ id: i, text: username + \"'s task #\" + (i + 1) }); } return { draft: '', todos: initialTodos, }; } function reducer(state, action) { switch (action.type) { case 'changed_draft': { return { draft: action.nextDraft, todos: state.todos, }; }; case 'added_todo': { return { draft: '', todos: [{ id: state.todos.length, text: state.draft }, ...state.todos] } } } throw Error('Unknown action: ' + action.type); } export default function TodoList({ username }) { const [state, dispatch] = useReducer( reducer, username, createInitialState ); return ( <> <input value={state.draft} onChange={e => { dispatch({ type: 'changed_draft', nextDraft: e.target.value }) }} /> <button onClick={() => { dispatch({ type: 'added_todo' }); }}>Add</button> <ul> {state.todos.map(item => ( <li key={item.id}> {item.text} </li> ))} </ul> </> ); } Troubleshooting I\u2019ve dispatched action, logging gives old state value Calling dispatch function change state running code: function handleClick() { console.log(state.age); // 42 dispatch({ type: 'incremented_age' }); // Request re-render 43 console.log(state.age); // Still 42! setTimeout(() => { console.log(state.age); // Also 42! }, 5000); } states behaves like snapshot. Updating state requests another render new state value, affect state JavaScript variable already-running event handler. need guess next state value, calculate manually calling reducer yourself: const action = { type: 'incremented_age' }; dispatch(action); const nextState = reducer(state, action); console.log(state); // { age: 42 } console.log(nextState); // { age: 43 } I\u2019ve dispatched action, screen doesn\u2019t update React ignore update next state equal previous state, determined Object.is comparison. usually happens change object array state directly: function reducer(state, action) { switch (action.type) { case 'incremented_age': { // \ud83d\udea9 Wrong: mutating existing object state.age++; return state; } case 'changed_name': { // \ud83d\udea9 Wrong: mutating existing object state.name = action.nextName; return state; } // ... } } mutated existing state object returned it, React ignored update. fix this, need ensure you\u2019re always updating objects state updating arrays state instead mutating them: function reducer(state, action) { switch (action.type) { case 'incremented_age': { // \u2705 Correct: creating new object return { ...state, age: state.age + 1 }; } case 'changed_name': { // \u2705 Correct: creating new object return { ...state, name: action.nextName }; } // ... } } part reducer state becomes undefined dispatching Make sure every case branch copies existing fields returning new state: function reducer(state, action) { switch (action.type) { case 'incremented_age': { return { ...state, // forget this! age: state.age + 1 }; } // ... Without ...state above, returned next state would contain age field nothing else. entire reducer state becomes undefined dispatching state unexpectedly becomes undefined , you\u2019re likely forgetting return state one cases, action type doesn\u2019t match case statements. find why, throw error outside switch : function reducer(state, action) { switch (action.type) { case 'incremented_age': { // ... } case 'edited_name': { // ... } } throw Error('Unknown action: ' + action.type); } also use static type checker like TypeScript catch mistakes. I\u2019m getting error: \u201cToo many re-renders\u201d might get error says: many re-renders. React limits number renders prevent infinite loop. Typically, means you\u2019re unconditionally dispatching action render, component enters loop: render, dispatch (which causes render), render, dispatch (which causes render), on. often, caused mistake specifying event handler: // \ud83d\udea9 Wrong: calls handler render return <button onClick={handleClick()}>Click me</button> // \u2705 Correct: passes event handler return <button onClick={handleClick}>Click me</button> // \u2705 Correct: passes inline function return <button onClick={(e) => handleClick(e)}>Click me</button> can\u2019t find cause error, click arrow next error console look JavaScript stack find specific dispatch function call responsible error. reducer initializer function runs twice Strict Mode, React call reducer initializer functions twice. shouldn\u2019t break code. development-only behavior helps keep components pure. React uses result one calls, ignores result call. long component, initializer, reducer functions pure, shouldn\u2019t affect logic. However, accidentally impure, helps notice mistakes. example, impure reducer function mutates array state: function reducer(state, action) { switch (action.type) { case 'added_todo': { // \ud83d\udea9 Mistake: mutating state state.todos.push({ id: nextId++, text: action.text }); return state; } // ... } } React calls reducer function twice, you\u2019ll see todo added twice, you\u2019ll know mistake. example, fix mistake replacing array instead mutating it: function reducer(state, action) { switch (action.type) { case 'added_todo': { // \u2705 Correct: replacing new state return { ...state, todos: [ ...state.todos, { id: nextId++, text: action.text } ] }; } // ... } } reducer function pure, calling extra time doesn\u2019t make difference behavior. React calling twice helps find mistakes. component, initializer, reducer functions need pure. Event handlers don\u2019t need pure, React never call event handlers twice. Read keeping components pure learn more."},
{"source": "https://react.dev/reference/react/useRef", "title": "useRef \u2013 React", "text": "useRef useRef React Hook lets reference value that\u2019s needed rendering. const ref = useRef(initialValue) Reference useRef(initialValue) Call useRef top level component declare ref. import { useRef } 'react'; function MyComponent() { const intervalRef = useRef(0); const inputRef = useRef(null); // ... Parameters initialValue : value want ref object\u2019scurrent property initially. value type. argument ignored initial render. Returns useRef returns object single property: current : Initially, it\u2019s set theinitialValue passed. later set something else. pass ref object React aref attribute JSX node, React set itscurrent property. next renders, useRef return object. Caveats - mutate ref.current property. Unlike state, mutable. However, holds object used rendering (for example, piece state), shouldn\u2019t mutate object. - change ref.current property, React re-render component. React aware change ref plain JavaScript object. - write read ref.current rendering, except initialization. makes component\u2019s behavior unpredictable. - Strict Mode, React call component function twice order help find accidental impurities. development-only behavior affect production. ref object created twice, one versions discarded. component function pure (as be), affect behavior. Usage Referencing value ref Call useRef top level component declare one refs. import { useRef } 'react'; function Stopwatch() { const intervalRef = useRef(0); // ... useRef returns ref object single current property initially set initial value provided. next renders, useRef return object. change current property store information read later. might remind state, important difference. Changing ref trigger re-render. means refs perfect storing information doesn\u2019t affect visual output component. example, need store interval ID retrieve later, put ref. update value inside ref, need manually change current property: function handleStartClick() { const intervalId = setInterval(() => { // ... }, 1000); intervalRef.current = intervalId; } Later, read interval ID ref call clear interval: function handleStopClick() { const intervalId = intervalRef.current; clearInterval(intervalId); } using ref, ensure that: - store information re-renders (unlike regular variables, reset every render). - Changing trigger re-render (unlike state variables, trigger re-render). - information local copy component (unlike variables outside, shared). Changing ref trigger re-render, refs appropriate storing information want display screen. Use state instead. Read choosing useRef useState . Example 1 2: Click counter component uses ref keep track many times button clicked. Note it\u2019s okay use ref instead state click count read written event handler. import { useRef } 'react'; export default function Counter() { let ref = useRef(0); function handleClick() { ref.current = ref.current + 1; alert('You clicked ' + ref.current + ' times!'); } return ( <button onClick={handleClick}> Click me! </button> ); } show {ref.current} JSX, number won\u2019t update click. setting ref.current trigger re-render. Information that\u2019s used rendering state instead. Manipulating DOM ref It\u2019s particularly common use ref manipulate DOM. React built-in support this. First, declare ref object initial value null : import { useRef } 'react'; function MyComponent() { const inputRef = useRef(null); // ... pass ref object ref attribute JSX DOM node want manipulate: // ... return <input ref={inputRef} />; React creates DOM node puts screen, React set current property ref object DOM node. access <input> \u2019s DOM node call methods like focus() : function handleClick() { inputRef.current.focus(); } React set current property back null node removed screen. Read manipulating DOM refs. Example 1 4: Focusing text input example, clicking button focus input: import { useRef } 'react'; export default function Form() { const inputRef = useRef(null); function handleClick() { inputRef.current.focus(); } return ( <> <input ref={inputRef} /> <button onClick={handleClick}> Focus input </button> </> ); } Avoiding recreating ref contents React saves initial ref value ignores next renders. function Video() { const playerRef = useRef(new VideoPlayer()); // ... Although result new VideoPlayer() used initial render, you\u2019re still calling function every render. wasteful it\u2019s creating expensive objects. solve it, may initialize ref like instead: function Video() { const playerRef = useRef(null); (playerRef.current === null) { playerRef.current = new VideoPlayer(); } // ... Normally, writing reading ref.current render allowed. However, it\u2019s fine case result always same, condition executes initialization it\u2019s fully predictable. Deep Dive use type checker don\u2019t want always check null , try pattern like instead: function Video() { const playerRef = useRef(null); function getPlayer() { (playerRef.current !== null) { return playerRef.current; } const player = new VideoPlayer(); playerRef.current = player; return player; } // ... Here, playerRef nullable. However, able convince type checker case getPlayer() returns null . use getPlayer() event handlers. Troubleshooting can\u2019t get ref custom component try pass ref component like this: const inputRef = useRef(null); return <MyInput ref={inputRef} />; might get error console: default, components don\u2019t expose refs DOM nodes inside them. fix this, find component want get ref to: export default function MyInput({ value, onChange }) { return ( <input value={value} onChange={onChange} /> ); } add ref list props component accepts pass ref prop relevent child built-in component like this: function MyInput({ value, onChange, ref }) { return ( <input value={value} onChange={onChange} ref={ref} /> ); }; export default MyInput; parent component get ref it. Read accessing another component\u2019s DOM nodes."},
{"source": "https://react.dev/reference/react/useState", "title": "useState \u2013 React", "text": "useState useState React Hook lets add state variable component. const [state, setState] = useState(initialState) Reference useState(initialState) Call useState top level component declare state variable. import { useState } 'react'; function MyComponent() { const [age, setAge] = useState(28); const [name, setName] = useState('Taylor'); const [todos, setTodos] = useState(() => createTodos()); // ... convention name state variables like [something, setSomething] using array destructuring. Parameters initialState : value want state initially. value type, special behavior functions. argument ignored initial render.- pass function initialState , treated initializer function. pure, take arguments, return value type. React call initializer function initializing component, store return value initial state. See example below. - pass function Returns useState returns array exactly two values: - current state. first render, match initialState passed. - set function lets update state different value trigger re-render. Caveats useState Hook, call top level component Hooks. can\u2019t call inside loops conditions. need that, extract new component move state it.- Strict Mode, React call initializer function twice order help find accidental impurities. development-only behavior affect production. initializer function pure (as be), affect behavior. result one calls ignored. set functions, like setSomething(nextState) set function returned useState lets update state different value trigger re-render. pass next state directly, function calculates previous state: const [name, setName] = useState('Edward'); function handleClick() { setName('Taylor'); setAge(a => + 1); // ... Parameters nextState : value want state be. value type, special behavior functions.- pass function nextState , treated updater function. must pure, take pending state argument, return next state. React put updater function queue re-render component. next render, React calculate next state applying queued updaters previous state. See example below. - pass function Returns set functions return value. Caveats - set function updates state variable next render. read state variable calling theset function, still get old value screen call. - new value provide identical current state , determined anObject.is comparison, React skip re-rendering component children. optimization. Although cases React may still need call component skipping children, shouldn\u2019t affect code. - React batches state updates. updates screen event handlers run called set functions. prevents multiple re-renders single event. rare case need force React update screen earlier, example access DOM, useflushSync . - set function stable identity, often see omitted Effect dependencies, including cause Effect fire. linter lets omit dependency without errors, safe do. Learn removing Effect dependencies. - Calling set function rendering allowed within currently rendering component. React discard output immediately attempt render new state. pattern rarely needed, use store information previous renders. See example below. - Strict Mode, React call updater function twice order help find accidental impurities. development-only behavior affect production. updater function pure (as be), affect behavior. result one calls ignored. Usage Adding state component Call useState top level component declare one state variables. import { useState } 'react'; function MyComponent() { const [age, setAge] = useState(42); const [name, setName] = useState('Taylor'); // ... convention name state variables like [something, setSomething] using array destructuring. useState returns array exactly two items: - current state state variable, initially set initial state provided. - set function lets change value response interaction. update what\u2019s screen, call set function next state: function handleClick() { setName('Robin'); } React store next state, render component new values, update UI. Example 1 4: Counter (number) example, count state variable holds number. Clicking button increments it. import { useState } 'react'; export default function Counter() { const [count, setCount] = useState(0); function handleClick() { setCount(count + 1); } return ( <button onClick={handleClick}> pressed {count} times </button> ); } Updating state based previous state Suppose age 42 . handler calls setAge(age + 1) three times: function handleClick() { setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) } However, one click, age 43 rather 45 ! calling set function update age state variable already running code. setAge(age + 1) call becomes setAge(43) . solve problem, may pass updater function setAge instead next state: function handleClick() { setAge(a => + 1); // setAge(42 => 43) setAge(a => + 1); // setAge(43 => 44) setAge(a => + 1); // setAge(44 => 45) } Here, => + 1 updater function. takes pending state calculates next state it. React puts updater functions queue. Then, next render, call order: => + 1 receive42 pending state return43 next state.a => + 1 receive43 pending state return44 next state.a => + 1 receive44 pending state return45 next state. queued updates, React store 45 current state end. convention, it\u2019s common name pending state argument first letter state variable name, like age . However, may also call like prevAge something else find clearer. React may call updaters twice development verify pure. Deep Dive might hear recommendation always write code like setAge(a => + 1) state you\u2019re setting calculated previous state. harm it, also always necessary. cases, difference two approaches. React always makes sure intentional user actions, like clicks, age state variable would updated next click. means risk click handler seeing \u201cstale\u201d age beginning event handler. However, multiple updates within event, updaters helpful. They\u2019re also helpful accessing state variable inconvenient (you might run optimizing re-renders). prefer consistency slightly verbose syntax, it\u2019s reasonable always write updater state you\u2019re setting calculated previous state. it\u2019s calculated previous state state variable, might want combine one object use reducer. Example 1 2: Passing updater function example passes updater function, \u201c+3\u201d button works. import { useState } 'react'; export default function Counter() { const [age, setAge] = useState(42); function increment() { setAge(a => + 1); } return ( <> <h1>Your age: {age}</h1> <button onClick={() => { increment(); increment(); increment(); }}>+3</button> <button onClick={() => { increment(); }}>+1</button> </> ); } Updating objects arrays state put objects arrays state. React, state considered read-only, replace rather mutate existing objects. example, form object state, don\u2019t mutate it: // \ud83d\udea9 mutate object state like this: form.firstName = 'Taylor'; Instead, replace whole object creating new one: // \u2705 Replace state new object setForm({ ...form, firstName: 'Taylor' }); Read updating objects state updating arrays state learn more. Example 1 4: Form (object) example, form state variable holds object. input change handler calls setForm next state entire form. { ...form } spread syntax ensures state object replaced rather mutated. import { useState } 'react'; export default function Form() { const [form, setForm] = useState({ firstName: 'Barbara', lastName: 'Hepworth', email: 'bhepworth@sculpture.com', }); return ( <> <label> First name: <input value={form.firstName} onChange={e => { setForm({ ...form, firstName: e.target.value }); }} /> </label> <label> Last name: <input value={form.lastName} onChange={e => { setForm({ ...form, lastName: e.target.value }); }} /> </label> <label> Email: <input value={form.email} onChange={e => { setForm({ ...form, email: e.target.value }); }} /> </label> <p> {form.firstName}{' '} {form.lastName}{' '} ({form.email}) </p> </> ); } Avoiding recreating initial state React saves initial state ignores next renders. function TodoList() { const [todos, setTodos] = useState(createInitialTodos()); // ... Although result createInitialTodos() used initial render, you\u2019re still calling function every render. wasteful it\u2019s creating large arrays performing expensive calculations. solve this, may pass initializer function useState instead: function TodoList() { const [todos, setTodos] = useState(createInitialTodos); // ... Notice you\u2019re passing createInitialTodos , function itself, createInitialTodos() , result calling it. pass function useState , React call initialization. React may call initializers twice development verify pure. Example 1 2: Passing initializer function example passes initializer function, createInitialTodos function runs initialization. run component re-renders, type input. import { useState } 'react'; function createInitialTodos() { const initialTodos = []; (let = 0; < 50; i++) { initialTodos.push({ id: i, text: 'Item ' + (i + 1) }); } return initialTodos; } export default function TodoList() { const [todos, setTodos] = useState(createInitialTodos); const [text, setText] = useState(''); return ( <> <input value={text} onChange={e => setText(e.target.value)} /> <button onClick={() => { setText(''); setTodos([{ id: todos.length, text: text }, ...todos]); }}>Add</button> <ul> {todos.map(item => ( <li key={item.id}> {item.text} </li> ))} </ul> </> ); } Resetting state key You\u2019ll often encounter key attribute rendering lists. However, also serves another purpose. reset component\u2019s state passing different key component. example, Reset button changes version state variable, pass key Form . key changes, React re-creates Form component (and children) scratch, state gets reset. Read preserving resetting state learn more. import { useState } 'react'; export default function App() { const [version, setVersion] = useState(0); function handleReset() { setVersion(version + 1); } return ( <> <button onClick={handleReset}>Reset</button> <Form key={version} /> </> ); } function Form() { const [name, setName] = useState('Taylor'); return ( <> <input value={name} onChange={e => setName(e.target.value)} /> <p>Hello, {name}.</p> </> ); } Storing information previous renders Usually, update state event handlers. However, rare cases might want adjust state response rendering \u2014 example, might want change state variable prop changes. cases, don\u2019t need this: - value need computed entirely current props state, remove redundant state altogether. you\u2019re worried recomputing often, useMemo Hook help. - want reset entire component tree\u2019s state, pass different key component. - can, update relevant state event handlers. rare case none apply, pattern use update state based values rendered far, calling set function component rendering. Here\u2019s example. CountLabel component displays count prop passed it: export default function CountLabel({ count }) { return <h1>{count}</h1> } Say want show whether counter increased decreased since last change. count prop doesn\u2019t tell \u2014 need keep track previous value. Add prevCount state variable track it. Add another state variable called trend hold whether count increased decreased. Compare prevCount count , they\u2019re equal, update prevCount trend . show current count prop changed since last render. import { useState } 'react'; export default function CountLabel({ count }) { const [prevCount, setPrevCount] = useState(count); const [trend, setTrend] = useState(null); (prevCount !== count) { setPrevCount(count); setTrend(count > prevCount ? 'increasing' : 'decreasing'); } return ( <> <h1>{count}</h1> {trend && <p>The count {trend}</p>} </> ); } Note call set function rendering, must inside condition like prevCount !== count , must call like setPrevCount(count) inside condition. Otherwise, component would re-render loop crashes. Also, update state currently rendering component like this. Calling set function another component rendering error. Finally, set call still update state without mutation \u2014 doesn\u2019t mean break rules pure functions. pattern hard understand usually best avoided. However, it\u2019s better updating state effect. call set function render, React re-render component immediately component exits return statement, rendering children. way, children don\u2019t need render twice. rest component function still execute (and result thrown away). condition Hook calls, may add early return; restart rendering earlier. Troubleshooting I\u2019ve updated state, logging gives old value Calling set function change state running code: function handleClick() { console.log(count); // 0 setCount(count + 1); // Request re-render 1 console.log(count); // Still 0! setTimeout(() => { console.log(count); // Also 0! }, 5000); } states behaves like snapshot. Updating state requests another render new state value, affect count JavaScript variable already-running event handler. need use next state, save variable passing set function: const nextCount = count + 1; setCount(nextCount); console.log(count); // 0 console.log(nextCount); // 1 I\u2019ve updated state, screen doesn\u2019t update React ignore update next state equal previous state, determined Object.is comparison. usually happens change object array state directly: obj.x = 10; // \ud83d\udea9 Wrong: mutating existing object setObj(obj); // \ud83d\udea9 anything mutated existing obj object passed back setObj , React ignored update. fix this, need ensure you\u2019re always replacing objects arrays state instead mutating them: // \u2705 Correct: creating new object setObj({ ...obj, x: 10 }); I\u2019m getting error: \u201cToo many re-renders\u201d might get error says: many re-renders. React limits number renders prevent infinite loop. Typically, means you\u2019re unconditionally setting state render, component enters loop: render, set state (which causes render), render, set state (which causes render), on. often, caused mistake specifying event handler: // \ud83d\udea9 Wrong: calls handler render return <button onClick={handleClick()}>Click me</button> // \u2705 Correct: passes event handler return <button onClick={handleClick}>Click me</button> // \u2705 Correct: passes inline function return <button onClick={(e) => handleClick(e)}>Click me</button> can\u2019t find cause error, click arrow next error console look JavaScript stack find specific set function call responsible error. initializer updater function runs twice Strict Mode, React call functions twice instead once: function TodoList() { // component function run twice every render. const [todos, setTodos] = useState(() => { // initializer function run twice initialization. return createTodos(); }); function handleClick() { setTodos(prevTodos => { // updater function run twice every click. return [...prevTodos, createTodo()]; }); } // ... expected shouldn\u2019t break code. development-only behavior helps keep components pure. React uses result one calls, ignores result call. long component, initializer, updater functions pure, shouldn\u2019t affect logic. However, accidentally impure, helps notice mistakes. example, impure updater function mutates array state: setTodos(prevTodos => { // \ud83d\udea9 Mistake: mutating state prevTodos.push(createTodo()); }); React calls updater function twice, you\u2019ll see todo added twice, you\u2019ll know mistake. example, fix mistake replacing array instead mutating it: setTodos(prevTodos => { // \u2705 Correct: replacing new state return [...prevTodos, createTodo()]; }); updater function pure, calling extra time doesn\u2019t make difference behavior. React calling twice helps find mistakes. component, initializer, updater functions need pure. Event handlers don\u2019t need pure, React never call event handlers twice. Read keeping components pure learn more. I\u2019m trying set state function, gets called instead can\u2019t put function state like this: const [fn, setFn] = useState(someFunction); function handleClick() { setFn(someOtherFunction); } you\u2019re passing function, React assumes someFunction initializer function, someOtherFunction updater function, tries call store result. actually store function, put () => cases. React store functions pass. const [fn, setFn] = useState(() => someFunction); function handleClick() { setFn(() => someOtherFunction); }"},
{"source": "https://react.dev/reference/react/useSyncExternalStore", "title": "useSyncExternalStore \u2013 React", "text": "useSyncExternalStore useSyncExternalStore React Hook lets subscribe external store. const snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?) Reference useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?) Call useSyncExternalStore top level component read value external data store. import { useSyncExternalStore } 'react'; import { todosStore } './todoStore.js'; function TodosApp() { const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot); // ... } returns snapshot data store. need pass two functions arguments: - subscribe function subscribe store return function unsubscribes. - getSnapshot function read snapshot data store. Parameters - subscribe : function takes singlecallback argument subscribes store. store changes, invoke providedcallback , cause React re-callgetSnapshot (if needed) re-render component. Thesubscribe function return function cleans subscription. - getSnapshot : function returns snapshot data store that\u2019s needed component. store changed, repeated calls togetSnapshot must return value. store changes returned value different (as compared byObject.is ), React re-renders component. - optional getServerSnapshot : function returns initial snapshot data store. used server rendering hydration server-rendered content client. server snapshot must client server, usually serialized passed server client. omit argument, rendering component server throw error. Returns current snapshot store use rendering logic. Caveats - store snapshot returned getSnapshot must immutable. underlying store mutable data, return new immutable snapshot data changed. Otherwise, return cached last snapshot. - different subscribe function passed re-render, React re-subscribe store using newly passedsubscribe function. prevent declaringsubscribe outside component. - store mutated non-blocking Transition update, React fall back performing update blocking. Specifically, every Transition update, React call getSnapshot second time applying changes DOM. returns different value called originally, React restart update scratch, time applying blocking update, ensure every component screen reflecting version store. - It\u2019s recommended suspend render based store value returned useSyncExternalStore . reason mutations external store cannot marked non-blocking Transition updates, trigger nearestSuspense fallback, replacing already-rendered content screen loading spinner, typically makes poor UX.For example, following discouraged: const LazyProductDetailPage = lazy(() => import('./ProductDetailPage.js'));function ShoppingApp() {const selectedProductId = useSyncExternalStore(...);// \u274c Calling `use` Promise dependent `selectedProductId`const data = use(fetchItem(selectedProductId))// \u274c Conditionally rendering lazy component based `selectedProductId`return selectedProductId != null ? <LazyProductDetailPage /> : <FeaturedProducts />;} Usage Subscribing external store React components read data props, state, context. However, sometimes component needs read data store outside React changes time. includes: - Third-party state management libraries hold state outside React. - Browser APIs expose mutable value events subscribe changes. Call useSyncExternalStore top level component read value external data store. import { useSyncExternalStore } 'react'; import { todosStore } './todoStore.js'; function TodosApp() { const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot); // ... } returns snapshot data store. need pass two functions arguments: - subscribe function subscribe store return function unsubscribes. - getSnapshot function read snapshot data store. React use functions keep component subscribed store re-render changes. example, sandbox below, todosStore implemented external store stores data outside React. TodosApp component connects external store useSyncExternalStore Hook. import { useSyncExternalStore } 'react'; import { todosStore } './todoStore.js'; export default function TodosApp() { const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot); return ( <> <button onClick={() => todosStore.addTodo()}>Add todo</button> <hr /> <ul> {todos.map(todo => ( <li key={todo.id}>{todo.text}</li> ))} </ul> </> ); } Subscribing browser API Another reason add useSyncExternalStore want subscribe value exposed browser changes time. example, suppose want component display whether network connection active. browser exposes information via property called navigator.onLine . value change without React\u2019s knowledge, read useSyncExternalStore . import { useSyncExternalStore } 'react'; function ChatIndicator() { const isOnline = useSyncExternalStore(subscribe, getSnapshot); // ... } implement getSnapshot function, read current value browser API: function getSnapshot() { return navigator.onLine; } Next, need implement subscribe function. example, navigator.onLine changes, browser fires online offline events window object. need subscribe callback argument corresponding events, return function cleans subscriptions: function subscribe(callback) { window.addEventListener('online', callback); window.addEventListener('offline', callback); return () => { window.removeEventListener('online', callback); window.removeEventListener('offline', callback); }; } React knows read value external navigator.onLine API subscribe changes. Disconnect device network notice component re-renders response: import { useSyncExternalStore } 'react'; export default function ChatIndicator() { const isOnline = useSyncExternalStore(subscribe, getSnapshot); return <h1>{isOnline ? '\u2705 Online' : '\u274c Disconnected'}</h1>; } function getSnapshot() { return navigator.onLine; } function subscribe(callback) { window.addEventListener('online', callback); window.addEventListener('offline', callback); return () => { window.removeEventListener('online', callback); window.removeEventListener('offline', callback); }; } Extracting logic custom Hook Usually won\u2019t write useSyncExternalStore directly components. Instead, you\u2019ll typically call custom Hook. lets use external store different components. example, custom useOnlineStatus Hook tracks whether network online: import { useSyncExternalStore } 'react'; export function useOnlineStatus() { const isOnline = useSyncExternalStore(subscribe, getSnapshot); return isOnline; } function getSnapshot() { // ... } function subscribe(callback) { // ... } different components call useOnlineStatus without repeating underlying implementation: import { useOnlineStatus } './useOnlineStatus.js'; function StatusBar() { const isOnline = useOnlineStatus(); return <h1>{isOnline ? '\u2705 Online' : '\u274c Disconnected'}</h1>; } function SaveButton() { const isOnline = useOnlineStatus(); function handleSaveClick() { console.log('\u2705 Progress saved'); } return ( <button disabled={!isOnline} onClick={handleSaveClick}> {isOnline ? 'Save progress' : 'Reconnecting...'} </button> ); } export default function App() { return ( <> <SaveButton /> <StatusBar /> </> ); } Adding support server rendering React app uses server rendering, React components also run outside browser environment generate initial HTML. creates challenges connecting external store: - you\u2019re connecting browser-only API, won\u2019t work exist server. - you\u2019re connecting third-party data store, you\u2019ll need data match server client. solve issues, pass getServerSnapshot function third argument useSyncExternalStore : import { useSyncExternalStore } 'react'; export function useOnlineStatus() { const isOnline = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot); return isOnline; } function getSnapshot() { return navigator.onLine; } function getServerSnapshot() { return true; // Always show \"Online\" server-generated HTML } function subscribe(callback) { // ... } getServerSnapshot function similar getSnapshot , runs two situations: - runs server generating HTML. - runs client hydration, i.e. React takes server HTML makes interactive. lets provide initial snapshot value used app becomes interactive. meaningful initial value server rendering, omit argument force rendering client. Troubleshooting I\u2019m getting error: \u201cThe result getSnapshot cached\u201d error means getSnapshot function returns new object every time it\u2019s called, example: function getSnapshot() { // \ud83d\udd34 return always different objects getSnapshot return { todos: myStore.todos }; } React re-render component getSnapshot return value different last time. why, always return different value, enter infinite loop get error. getSnapshot object return different object something actually changed. store contains immutable data, return data directly: function getSnapshot() { // \u2705 return immutable data return myStore.todos; } store data mutable, getSnapshot function return immutable snapshot it. means need create new objects, shouldn\u2019t every single call. Instead, store last calculated snapshot, return snapshot last time data store changed. determine whether mutable data changed depends mutable store. subscribe function gets called every re-render subscribe function defined inside component different every re-render: function ChatIndicator() { const isOnline = useSyncExternalStore(subscribe, getSnapshot); // \ud83d\udea9 Always different function, React resubscribe every re-render function subscribe() { // ... } // ... } React resubscribe store pass different subscribe function re-renders. causes performance issues you\u2019d like avoid resubscribing, move subscribe function outside: function ChatIndicator() { const isOnline = useSyncExternalStore(subscribe, getSnapshot); // ... } // \u2705 Always function, React need resubscribe function subscribe() { // ... } Alternatively, wrap subscribe useCallback resubscribe argument changes: function ChatIndicator({ userId }) { const isOnline = useSyncExternalStore(subscribe, getSnapshot); // \u2705 function long userId change const subscribe = useCallback(() => { // ... }, [userId]); // ... }"},
{"source": "https://react.dev/reference/react/useTransition", "title": "useTransition \u2013 React", "text": "useTransition useTransition React Hook lets render part UI background. const [isPending, startTransition] = useTransition() - Reference - Usage - Troubleshooting - Updating input Transition doesn\u2019t work - React doesn\u2019t treat state update Transition - React doesn\u2019t treat state update await Transition - want call useTransition outside component - function pass startTransition executes immediately - state updates Transitions order Reference useTransition() Call useTransition top level component mark state updates Transitions. import { useTransition } 'react'; function TabContainer() { const [isPending, startTransition] = useTransition(); // ... } Parameters useTransition take parameters. Returns useTransition returns array exactly two items: - isPending flag tells whether pending Transition. - startTransition function lets mark updates Transition. startTransition(action) startTransition function returned useTransition lets mark update Transition. function TabContainer() { const [isPending, startTransition] = useTransition(); const [tab, setTab] = useState('about'); function selectTab(nextTab) { startTransition(() => { setTab(nextTab); }); } // ... } Parameters action : function updates state calling one moreset functions. React callsaction immediately parameters marks state updates scheduled synchronously theaction function call Transitions. async calls awaited theaction included Transition, currently require wrapping anyset functions theawait additionalstartTransition (see Troubleshooting). State updates marked Transitions non-blocking display unwanted loading indicators. Returns startTransition return anything. Caveats - useTransition Hook, called inside components custom Hooks. need start Transition somewhere else (for example, data library), call standalonestartTransition instead. - wrap update Transition access set function state. want start Transition response prop custom Hook value, tryuseDeferredValue instead. - function pass startTransition called immediately, marking state updates happen executes Transitions. try perform state updates asetTimeout , example, won\u2019t marked Transitions. - must wrap state updates async requests another startTransition mark Transitions. known limitation fix future (see Troubleshooting). - startTransition function stable identity, often see omitted Effect dependencies, including cause Effect fire. linter lets omit dependency without errors, safe do. Learn removing Effect dependencies. - state update marked Transition interrupted state updates. example, update chart component inside Transition, start typing input chart middle re-render, React restart rendering work chart component handling input update. - Transition updates can\u2019t used control text inputs. - multiple ongoing Transitions, React currently batches together. limitation may removed future release. Usage Perform non-blocking updates Actions Call useTransition top component create Actions, access pending state: import {useState, useTransition} 'react'; function CheckoutForm() { const [isPending, startTransition] = useTransition(); // ... } useTransition returns array exactly two items: - isPending flag tells whether pending Transition. - startTransition function lets create Action. start Transition, pass function startTransition like this: import {useState, useTransition} 'react'; import {updateQuantity} './api'; function CheckoutForm() { const [isPending, startTransition] = useTransition(); const [quantity, setQuantity] = useState(1); function onSubmit(newQuantity) { startTransition(async function () { const savedQuantity = await updateQuantity(newQuantity); startTransition(() => { setQuantity(savedQuantity); }); }); } // ... } function passed startTransition called \u201cAction\u201d. update state (optionally) perform side effects within Action, work done background without blocking user interactions page. Transition include multiple Actions, Transition progress, UI stays responsive. example, user clicks tab changes mind clicks another tab, second click immediately handled without waiting first update finish. give user feedback in-progress Transitions, isPending state switches true first call startTransition , stays true Actions complete final state shown user. Transitions ensure side effects Actions complete order prevent unwanted loading indicators, provide immediate feedback Transition progress useOptimistic . Example 1 2: Updating quantity Action example, updateQuantity function simulates request server update item\u2019s quantity cart. function artificially slowed takes least second complete request. Update quantity multiple times quickly. Notice pending \u201cTotal\u201d state shown requests progress, \u201cTotal\u201d updates final request complete. update Action, \u201cquantity\u201d continue updated request progress. import { useState, useTransition } \"react\"; import { updateQuantity } \"./api\"; import Item \"./Item\"; import Total \"./Total\"; export default function App({}) { const [quantity, setQuantity] = useState(1); const [isPending, startTransition] = useTransition(); const updateQuantityAction = async newQuantity => { // access pending state transition, // call startTransition again. startTransition(async () => { const savedQuantity = await updateQuantity(newQuantity); startTransition(() => { setQuantity(savedQuantity); }); }); }; return ( <div> <h1>Checkout</h1> <Item action={updateQuantityAction}/> <hr /> <Total quantity={quantity} isPending={isPending} /> </div> ); } basic example demonstrate Actions work, example handle requests completing order. updating quantity multiple times, it\u2019s possible previous requests finish later requests causing quantity update order. known limitation fix future (see Troubleshooting below). common use cases, React provides built-in abstractions as: solutions handle request ordering you. using Transitions build custom hooks libraries manage async state transitions, greater control request ordering, must handle yourself. Exposing action prop components expose action prop component allow parent call Action. example, TabButton component wraps onClick logic action prop: export default function TabButton({ action, children, isActive }) { const [isPending, startTransition] = useTransition(); (isActive) { return <b>{children}</b> } return ( <button onClick={() => { startTransition(() => { action(); }); }}> {children} </button> ); } parent component updates state inside action , state update gets marked Transition. means click \u201cPosts\u201d immediately click \u201cContact\u201d block user interactions: import { useTransition } 'react'; export default function TabButton({ action, children, isActive }) { const [isPending, startTransition] = useTransition(); (isActive) { return <b>{children}</b> } return ( <button onClick={() => { startTransition(() => { action(); }); }}> {children} </button> ); } Displaying pending visual state use isPending boolean value returned useTransition indicate user Transition progress. example, tab button special \u201cpending\u201d visual state: function TabButton({ action, children, isActive }) { const [isPending, startTransition] = useTransition(); // ... (isPending) { return <b className=\"pending\">{children}</b>; } // ... Notice clicking \u201cPosts\u201d feels responsive tab button updates right away: import { useTransition } 'react'; export default function TabButton({ action, children, isActive }) { const [isPending, startTransition] = useTransition(); (isActive) { return <b>{children}</b> } (isPending) { return <b className=\"pending\">{children}</b>; } return ( <button onClick={() => { startTransition(() => { action(); }); }}> {children} </button> ); } Preventing unwanted loading indicators example, PostsTab component fetches data using use. click \u201cPosts\u201d tab, PostsTab component suspends, causing closest loading fallback appear: import { Suspense, useState } 'react'; import TabButton './TabButton.js'; import AboutTab './AboutTab.js'; import PostsTab './PostsTab.js'; import ContactTab './ContactTab.js'; export default function TabContainer() { const [tab, setTab] = useState('about'); return ( <Suspense fallback={<h1>\ud83c\udf00 Loading...</h1>}> <TabButton isActive={tab === 'about'} action={() => setTab('about')} > </TabButton> <TabButton isActive={tab === 'posts'} action={() => setTab('posts')} > Posts </TabButton> <TabButton isActive={tab === 'contact'} action={() => setTab('contact')} > Contact </TabButton> <hr /> {tab === 'about' && <AboutTab />} {tab === 'posts' && <PostsTab />} {tab === 'contact' && <ContactTab />} </Suspense> ); } Hiding entire tab container show loading indicator leads jarring user experience. add useTransition TabButton , instead display pending state tab button instead. Notice clicking \u201cPosts\u201d longer replaces entire tab container spinner: import { useTransition } 'react'; export default function TabButton({ action, children, isActive }) { const [isPending, startTransition] = useTransition(); (isActive) { return <b>{children}</b> } (isPending) { return <b className=\"pending\">{children}</b>; } return ( <button onClick={() => { startTransition(() => { action(); }); }}> {children} </button> ); } Read using Transitions Suspense. Building Suspense-enabled router you\u2019re building React framework router, recommend marking page navigations Transitions. function Router() { const [page, setPage] = useState('/'); const [isPending, startTransition] = useTransition(); function navigate(url) { startTransition(() => { setPage(url); }); } // ... recommended three reasons: - Transitions interruptible, lets user click away without waiting re-render complete. - Transitions prevent unwanted loading indicators, lets user avoid jarring jumps navigation. - Transitions wait pending actions lets user wait side effects complete new page shown. simplified router example using Transitions navigations. import { Suspense, useState, useTransition } 'react'; import IndexPage './IndexPage.js'; import ArtistPage './ArtistPage.js'; import Layout './Layout.js'; export default function App() { return ( <Suspense fallback={<BigSpinner />}> <Router /> </Suspense> ); } function Router() { const [page, setPage] = useState('/'); const [isPending, startTransition] = useTransition(); function navigate(url) { startTransition(() => { setPage(url); }); } let content; (page === '/') { content = ( <IndexPage navigate={navigate} /> ); } else (page === '/the-beatles') { content = ( <ArtistPage artist={{ id: 'the-beatles', name: 'The Beatles', }} /> ); } return ( <Layout isPending={isPending}> {content} </Layout> ); } function BigSpinner() { return <h2>\ud83c\udf00 Loading...</h2>; } Displaying error users error boundary function passed startTransition throws error, display error user error boundary. use error boundary, wrap component calling useTransition error boundary. function passed startTransition errors, fallback error boundary displayed. import { useTransition } \"react\"; import { ErrorBoundary } \"react-error-boundary\"; export function AddCommentContainer() { return ( <ErrorBoundary fallback={<p>\u26a0\ufe0fSomething went wrong</p>}> <AddCommentButton /> </ErrorBoundary> ); } function addComment(comment) { // demonstration purposes show Error Boundary (comment == null) { throw new Error(\"Example Error: error thrown trigger error boundary\"); } } function AddCommentButton() { const [pending, startTransition] = useTransition(); return ( <button disabled={pending} onClick={() => { startTransition(() => { // Intentionally passing comment // error gets thrown addComment(); }); }} > Add comment </button> ); } Troubleshooting Updating input Transition doesn\u2019t work can\u2019t use Transition state variable controls input: const [text, setText] = useState(''); // ... function handleChange(e) { // \u274c Can't use Transitions controlled input state startTransition(() => { setText(e.target.value); }); } // ... return <input value={text} onChange={handleChange} />; Transitions non-blocking, updating input response change event happen synchronously. want run Transition response typing, two options: - declare two separate state variables: one input state (which always updates synchronously), one update Transition. lets control input using synchronous state, pass Transition state variable (which \u201clag behind\u201d input) rest rendering logic. - Alternatively, one state variable, add useDeferredValue \u201clag behind\u201d real value. trigger non-blocking re-renders \u201ccatch up\u201d new value automatically. React doesn\u2019t treat state update Transition wrap state update Transition, make sure happens startTransition call: startTransition(() => { // \u2705 Setting state *during* startTransition call setPage('/about'); }); function pass startTransition must synchronous. can\u2019t mark update Transition like this: startTransition(() => { // \u274c Setting state *after* startTransition call setTimeout(() => { setPage('/about'); }, 1000); }); Instead, could this: setTimeout(() => { startTransition(() => { // \u2705 Setting state *during* startTransition call setPage('/about'); }); }, 1000); React doesn\u2019t treat state update await Transition use await inside startTransition function, state updates happen await marked Transitions. must wrap state updates await startTransition call: startTransition(async () => { await someAsyncFunction(); // \u274c using startTransition await setPage('/about'); }); However, works instead: startTransition(async () => { await someAsyncFunction(); // \u2705 Using startTransition *after* await startTransition(() => { setPage('/about'); }); }); JavaScript limitation due React losing scope async context. future, AsyncContext available, limitation removed. want call useTransition outside component can\u2019t call useTransition outside component it\u2019s Hook. case, use standalone startTransition method instead. works way, doesn\u2019t provide isPending indicator. function pass startTransition executes immediately run code, print 1, 2, 3: console.log(1); startTransition(() => { console.log(2); setPage('/about'); }); console.log(3); expected print 1, 2, 3. function pass startTransition get delayed. Unlike browser setTimeout , run callback later. React executes function immediately, state updates scheduled running marked Transitions. imagine works like this: // simplified version React works let isInsideTransition = false; function startTransition(scope) { isInsideTransition = true; scope(); isInsideTransition = false; } function setState() { (isInsideTransition) { // ... schedule Transition state update ... } else { // ... schedule urgent state update ... } } state updates Transitions order await inside startTransition , might see updates happen order. example, updateQuantity function simulates request server update item\u2019s quantity cart. function artificially returns every request previous simulate race conditions network requests. Try updating quantity once, update quickly multiple times. might see incorrect total: import { useState, useTransition } \"react\"; import { updateQuantity } \"./api\"; import Item \"./Item\"; import Total \"./Total\"; export default function App({}) { const [quantity, setQuantity] = useState(1); const [isPending, startTransition] = useTransition(); // Store actual quantity separate state show mismatch. const [clientQuantity, setClientQuantity] = useState(1); const updateQuantityAction = newQuantity => { setClientQuantity(newQuantity); // Access pending state transition, // wrapping startTransition again. startTransition(async () => { const savedQuantity = await updateQuantity(newQuantity); startTransition(() => { setQuantity(savedQuantity); }); }); }; return ( <div> <h1>Checkout</h1> <Item action={updateQuantityAction}/> <hr /> <Total clientQuantity={clientQuantity} savedQuantity={quantity} isPending={isPending} /> </div> ); } clicking multiple times, it\u2019s possible previous requests finish later requests. happens, React currently way know intended order. updates scheduled asynchronously, React loses context order across async boundary. expected, Actions within Transition guarantee execution order. common use cases, React provides higher-level abstractions like useActionState <form> actions handle ordering you. advanced use cases, you\u2019ll need implement queuing abort logic handle this."},
{"source": "https://react.dev/reference/rsc/directives", "title": "Directives \u2013 React", "text": "Directives Directives provide instructions bundlers compatible React Server Components. Source code directives 'use client' lets mark code runs client.'use server' marks server-side functions called client-side code."},
{"source": "https://react.dev/reference/rsc/server-functions", "title": "Server Functions \u2013 React", "text": "Server Functions Server Functions allow Client Components call async functions executed server. Server Functions defined \"use server\" directive, framework automatically create reference server function, pass reference Client Component. function called client, React send request server execute function, return result. Server Functions created Server Components passed props Client Components, imported used Client Components. Usage Creating Server Function Server Component Server Components define Server Functions \"use server\" directive: // Server Component import Button './Button'; function EmptyNote () { async function createNoteAction() { // Server Function 'use server'; await db.notes.create(); } return <Button onClick={createNoteAction}/>; } React renders EmptyNote Server Function, create reference createNoteAction function, pass reference Button Client Component. button clicked, React send request server execute createNoteAction function reference provided: \"use client\"; export default function Button({onClick}) { console.log(onClick); // {$$typeof: Symbol.for(\"react.server.reference\"), $$id: 'createNoteAction'} return <button onClick={() => onClick()}>Create Empty Note</button> } more, see docs \"use server\" . Importing Server Functions Client Components Client Components import Server Functions files use \"use server\" directive: \"use server\"; export async function createNote() { await db.notes.create(); } bundler builds EmptyNote Client Component, create reference createNote function bundle. button clicked, React send request server execute createNote function using reference provided: \"use client\"; import {createNote} './actions'; function EmptyNote() { console.log(createNote); // {$$typeof: Symbol.for(\"react.server.reference\"), $$id: 'createNote'} <button onClick={() => createNote()} /> } more, see docs \"use server\" . Server Functions Actions Server Functions called Actions client: \"use server\"; export async function updateName(name) { (!name) { return {error: 'Name required'}; } await db.users.updateName(name); } \"use client\"; import {updateName} './actions'; function UpdateName() { const [name, setName] = useState(''); const [error, setError] = useState(null); const [isPending, startTransition] = useTransition(); const submitAction = async () => { startTransition(async () => { const {error} = await updateName(name); (!error) { setError(error); } else { setName(''); } }) } return ( <form action={submitAction}> <input type=\"text\" name=\"name\" disabled={isPending}/> {state.error && <span>Failed: {state.error}</span>} </form> ) } allows access isPending state Server Function wrapping Action client. more, see docs Calling Server Function outside <form> Server Functions Form Actions Server Functions work new Form features React 19. pass Server Function Form automatically submit form server: \"use client\"; import {updateName} './actions'; function UpdateName() { return ( <form action={updateName}> <input type=\"text\" name=\"name\" /> </form> ) } Form submission succeeds, React automatically reset form. add useActionState access pending state, last response, support progressive enhancement. more, see docs Server Functions Forms. Server Functions useActionState call Server Functions useActionState common case need access action pending state last returned response: \"use client\"; import {updateName} './actions'; function UpdateName() { const [state, submitAction, isPending] = useActionState(updateName, {error: null}); return ( <form action={submitAction}> <input type=\"text\" name=\"name\" disabled={isPending}/> {state.error && <span>Failed: {state.error}</span>} </form> ); } using useActionState Server Functions, React also automatically replay form submissions entered hydration finishes. means users interact app even app hydrated. more, see docs useActionState . Progressive enhancement useActionState Server Functions also support progressive enhancement third argument useActionState . \"use client\"; import {updateName} './actions'; function UpdateName() { const [, submitAction] = useActionState(updateName, null, `/name/update`); return ( <form action={submitAction}> ... </form> ); } permalink provided useActionState , React redirect provided URL form submitted JavaScript bundle loads. more, see docs useActionState ."},
{"source": "https://react.dev/reference/rsc/server-components", "title": "Server Components \u2013 React", "text": "Server Components Server Components new type Component renders ahead time, bundling, environment separate client app SSR server. separate environment \u201cserver\u201d React Server Components. Server Components run build time CI server, run request using web server. - Server Components without Server - Server Components Server - Adding interactivity Server Components - Async components Server Components Server Components without Server Server components run build time read filesystem fetch static content, web server required. example, may want read static data content management system. Without Server Components, it\u2019s common fetch static data client Effect: // bundle.js import marked 'marked'; // 35.9K (11.2K gzipped) import sanitizeHtml 'sanitize-html'; // 206K (63.3K gzipped) function Page({page}) { const [content, setContent] = useState(''); // NOTE: loads *after* first page render. useEffect(() => { fetch(`/api/content/${page}`).then((data) => { setContent(data.content); }); }, [page]); return <div>{sanitizeHtml(marked(content))}</div>; } // api.js app.get(`/api/content/:page`, async (req, res) => { const page = req.params.page; const content = await file.readFile(`${page}.md`); res.send({content}); }); pattern means users need download parse additional 75K (gzipped) libraries, wait second request fetch data page loads, render static content change lifetime page. Server Components, render components build time: import marked 'marked'; // included bundle import sanitizeHtml 'sanitize-html'; // included bundle async function Page({page}) { // NOTE: loads *during* render, app built. const content = await file.readFile(`${page}.md`); return <div>{sanitizeHtml(marked(content))}</div>; } rendered output server-side rendered (SSR) HTML uploaded CDN. app loads, client see original Page component, expensive libraries rendering markdown. client see rendered output: <div><!-- html markdown --></div> means content visible first page load, bundle include expensive libraries needed render static content. Server Components Server Server Components also run web server request page, letting access data layer without build API. rendered application bundled, pass data JSX props Client Components. Without Server Components, it\u2019s common fetch dynamic data client Effect: // bundle.js function Note({id}) { const [note, setNote] = useState(''); // NOTE: loads *after* first render. useEffect(() => { fetch(`/api/notes/${id}`).then(data => { setNote(data.note); }); }, [id]); return ( <div> <Author id={note.authorId} /> <p>{note}</p> </div> ); } function Author({id}) { const [author, setAuthor] = useState(''); // NOTE: loads *after* Note renders. // Causing expensive client-server waterfall. useEffect(() => { fetch(`/api/authors/${id}`).then(data => { setAuthor(data.author); }); }, [id]); return <span>By: {author.name}</span>; } // api import db './database'; app.get(`/api/notes/:id`, async (req, res) => { const note = await db.notes.get(id); res.send({note}); }); app.get(`/api/authors/:id`, async (req, res) => { const author = await db.authors.get(id); res.send({author}); }); Server Components, read data render component: import db './database'; async function Note({id}) { // NOTE: loads *during* render. const note = await db.notes.get(id); return ( <div> <Author id={note.authorId} /> <p>{note}</p> </div> ); } async function Author({id}) { // NOTE: loads *after* Note, // fast data co-located. const author = await db.authors.get(id); return <span>By: {author.name}</span>; } bundler combines data, rendered Server Components dynamic Client Components bundle. Optionally, bundle server-side rendered (SSR) create initial HTML page. page loads, browser see original Note Author components; rendered output sent client: <div> <span>By: React Team</span> <p>React 19 is...</p> </div> Server Components made dynamic re-fetching server, access data render again. new application architecture combines simple \u201crequest/response\u201d mental model server-centric Multi-Page Apps seamless interactivity client-centric Single-Page Apps, giving best worlds. Adding interactivity Server Components Server Components sent browser, cannot use interactive APIs like useState . add interactivity Server Components, compose Client Component using \"use client\" directive. following example, Notes Server Component imports Expandable Client Component uses state toggle expanded state: // Server Component import Expandable './Expandable'; async function Notes() { const notes = await db.notes.getAll(); return ( <div> {notes.map(note => ( <Expandable key={note.id}> <p note={note} /> </Expandable> ))} </div> ) } // Client Component \"use client\" export default function Expandable({children}) { const [expanded, setExpanded] = useState(false); return ( <div> <button onClick={() => setExpanded(!expanded)} > Toggle </button> {expanded && children} </div> ) } works first rendering Notes Server Component, instructing bundler create bundle Client Component Expandable . browser, Client Components see output Server Components passed props: <head> <!-- bundle Client Components --> <script src=\"bundle.js\" /> </head> <body> <div> <Expandable key={1}> <p>this first note</p> </Expandable> <Expandable key={2}> <p>this second note</p> </Expandable> <!--...--> </div> </body> Async components Server Components Server Components introduce new way write Components using async/await. await async component, React suspend wait promise resolve resuming rendering. works across server/client boundaries streaming support Suspense. even create promise server, await client: // Server Component import db './database'; async function Page({id}) { // suspend Server Component. const note = await db.notes.get(id); // NOTE: awaited, start await client. const commentsPromise = db.comments.get(note.id); return ( <div> {note} <Suspense fallback={<p>Loading Comments...</p>}> <Comments commentsPromise={commentsPromise} /> </Suspense> </div> ); } // Client Component \"use client\"; import {use} 'react'; function Comments({commentsPromise}) { // NOTE: resume promise server. // suspend data available. const comments = use(commentsPromise); return comments.map(commment => <p>{comment}</p>); } note content important data page render, await server. comments fold lower-priority, start promise server, wait client use API. Suspend client, without blocking note content rendering. Since async components supported client, await promise use ."},
{"source": "https://react.dev/reference/rsc/server-functions", "title": "Server Functions \u2013 React", "text": "Server Functions Server Functions allow Client Components call async functions executed server. Server Functions defined \"use server\" directive, framework automatically create reference server function, pass reference Client Component. function called client, React send request server execute function, return result. Server Functions created Server Components passed props Client Components, imported used Client Components. Usage Creating Server Function Server Component Server Components define Server Functions \"use server\" directive: // Server Component import Button './Button'; function EmptyNote () { async function createNoteAction() { // Server Function 'use server'; await db.notes.create(); } return <Button onClick={createNoteAction}/>; } React renders EmptyNote Server Function, create reference createNoteAction function, pass reference Button Client Component. button clicked, React send request server execute createNoteAction function reference provided: \"use client\"; export default function Button({onClick}) { console.log(onClick); // {$$typeof: Symbol.for(\"react.server.reference\"), $$id: 'createNoteAction'} return <button onClick={() => onClick()}>Create Empty Note</button> } more, see docs \"use server\" . Importing Server Functions Client Components Client Components import Server Functions files use \"use server\" directive: \"use server\"; export async function createNote() { await db.notes.create(); } bundler builds EmptyNote Client Component, create reference createNote function bundle. button clicked, React send request server execute createNote function using reference provided: \"use client\"; import {createNote} './actions'; function EmptyNote() { console.log(createNote); // {$$typeof: Symbol.for(\"react.server.reference\"), $$id: 'createNote'} <button onClick={() => createNote()} /> } more, see docs \"use server\" . Server Functions Actions Server Functions called Actions client: \"use server\"; export async function updateName(name) { (!name) { return {error: 'Name required'}; } await db.users.updateName(name); } \"use client\"; import {updateName} './actions'; function UpdateName() { const [name, setName] = useState(''); const [error, setError] = useState(null); const [isPending, startTransition] = useTransition(); const submitAction = async () => { startTransition(async () => { const {error} = await updateName(name); (!error) { setError(error); } else { setName(''); } }) } return ( <form action={submitAction}> <input type=\"text\" name=\"name\" disabled={isPending}/> {state.error && <span>Failed: {state.error}</span>} </form> ) } allows access isPending state Server Function wrapping Action client. more, see docs Calling Server Function outside <form> Server Functions Form Actions Server Functions work new Form features React 19. pass Server Function Form automatically submit form server: \"use client\"; import {updateName} './actions'; function UpdateName() { return ( <form action={updateName}> <input type=\"text\" name=\"name\" /> </form> ) } Form submission succeeds, React automatically reset form. add useActionState access pending state, last response, support progressive enhancement. more, see docs Server Functions Forms. Server Functions useActionState call Server Functions useActionState common case need access action pending state last returned response: \"use client\"; import {updateName} './actions'; function UpdateName() { const [state, submitAction, isPending] = useActionState(updateName, {error: null}); return ( <form action={submitAction}> <input type=\"text\" name=\"name\" disabled={isPending}/> {state.error && <span>Failed: {state.error}</span>} </form> ); } using useActionState Server Functions, React also automatically replay form submissions entered hydration finishes. means users interact app even app hydrated. more, see docs useActionState . Progressive enhancement useActionState Server Functions also support progressive enhancement third argument useActionState . \"use client\"; import {updateName} './actions'; function UpdateName() { const [, submitAction] = useActionState(updateName, null, `/name/update`); return ( <form action={submitAction}> ... </form> ); } permalink provided useActionState , React redirect provided URL form submitted JavaScript bundle loads. more, see docs useActionState ."},
{"source": "https://react.dev/reference/rsc/use-client", "title": "'use client' directive \u2013 React", "text": "'use client' 'use client' lets mark code runs client. Reference 'use client' Add 'use client' top file mark module transitive dependencies client code. 'use client'; import { useState } 'react'; import { formatDate } './formatters'; import Button './button'; export default function RichTextEditor({ timestamp, text }) { const date = formatDate(timestamp); // ... const editButton = <Button />; // ... } file marked 'use client' imported Server Component, compatible bundlers treat module import boundary server-run client-run code. dependencies RichTextEditor , formatDate Button also evaluated client regardless whether modules contain 'use client' directive. Note single module may evaluated server imported server code client imported client code. Caveats 'use client' must beginning file, imports code (comments OK). must written single double quotes, backticks.- 'use client' module imported another client-rendered module, directive effect. - component module contains 'use client' directive, usage component guaranteed Client Component. However, component still evaluated client even a'use client' directive.- component usage considered Client Component defined module 'use client' directive transitive dependency module contains a'use client' directive. Otherwise, Server Component. - component usage considered Client Component defined module - Code marked client evaluation limited components. code part Client module sub-tree sent run client. - server evaluated module imports values 'use client' module, values must either React component supported serializable prop values passed Client Component. use case throw exception. 'use client' marks client code React app, components often split separate files, modules. apps use React Server Components, app server-rendered default. 'use client' introduces server-client boundary module dependency tree, effectively creating subtree Client modules. better illustrate this, consider following React Server Components app. import FancyText './FancyText'; import InspirationGenerator './InspirationGenerator'; import Copyright './Copyright'; export default function App() { return ( <> <FancyText title text=\"Get Inspired App\" /> <InspirationGenerator> <Copyright year={2004} /> </InspirationGenerator> </> ); } module dependency tree example app, 'use client' directive InspirationGenerator.js marks module transitive dependencies Client modules. subtree starting InspirationGenerator.js marked Client modules. render, framework server-render root component continue render tree, opting-out evaluating code imported client-marked code. server-rendered portion render tree sent client. client, client code downloaded, completes rendering rest tree. introduce following definitions: - Client Components components render tree rendered client. - Server Components components render tree rendered server. Working example app, App , FancyText Copyright server-rendered considered Server Components. InspirationGenerator.js transitive dependencies marked client code, component InspirationGenerator child component FancyText Client Components. Deep Dive definitions, component FancyText Server Client Component, be? First, let\u2019s clarify term \u201ccomponent\u201d precise. two ways \u201ccomponent\u201d understood: - \u201ccomponent\u201d refer component definition. cases function. // definition component function MyComponent() { return <p>My Component</p> } - \u201ccomponent\u201d also refer component usage definition. import MyComponent './MyComponent'; function App() { // usage component return <MyComponent />; } Often, imprecision important explaining concepts, case is. talk Server Client Components, referring component usages. - component defined module 'use client' directive, component imported called Client Component, component usage Client Component. - Otherwise, component usage Server Component. Back question FancyText , see component definition 'use client' directive two usages. usage FancyText child App , marks usage Server Component. FancyText imported called InspirationGenerator , usage FancyText Client Component InspirationGenerator contains 'use client' directive. means component definition FancyText evaluated server also downloaded client render Client Component usage. Deep Dive Copyright rendered child Client Component InspirationGenerator , might surprised Server Component. Recall 'use client' defines boundary server client code module dependency tree, render tree. module dependency tree, see App.js imports calls Copyright Copyright.js module. Copyright.js contain 'use client' directive, component usage rendered server. App rendered server root component. Client Components render Server Components pass JSX props. case, InspirationGenerator receives Copyright children. However, InspirationGenerator module never directly imports Copyright module calls component, done App . fact, Copyright component fully executed InspirationGenerator starts rendering. takeaway parent-child render relationship components guarantee render environment. use 'use client' 'use client' , determine components Client Components. Server Components default, brief overview advantages limitations Server Components determine need mark something client rendered. simplicity, talk Server Components, principles apply code app server run. Advantages Server Components - Server Components reduce amount code sent run client. Client modules bundled evaluated client. - Server Components benefit running server. access local filesystem may experience low latency data fetches network requests. Limitations Server Components - Server Components cannot support interaction event handlers must registered triggered client. - example, event handlers like onClick defined Client Components. - example, event handlers like - Server Components cannot use Hooks. - Server Components rendered, output essentially list components client render. Server Components persist memory render cannot state. Serializable types returned Server Components React app, parent components pass data child components. rendered different environments, passing data Server Component Client Component requires extra consideration. Prop values passed Server Component Client Component must serializable. Serializable props include: - Primitives - Iterables containing serializable values - Date - Plain objects: created object initializers, serializable properties - Functions Server Functions - Client Server Component elements (JSX) - Promises Notably, supported: - Functions exported client-marked modules marked 'use server' - Classes - Objects instances class (other built-ins mentioned) objects null prototype - Symbols registered globally, ex. Symbol('my new symbol') Usage Building interactivity state 'use client'; import { useState } 'react'; export default function Counter({initialValue = 0}) { const [countValue, setCountValue] = useState(initialValue); const increment = () => setCountValue(countValue + 1); const decrement = () => setCountValue(countValue - 1); return ( <> <h2>Count Value: {countValue}</h2> <button onClick={increment}>+1</button> <button onClick={decrement}>-1</button> </> ); } Counter requires useState Hook event handlers increment decrement value, component must Client Component require 'use client' directive top. contrast, component renders UI without interaction need Client Component. import { readFile } 'node:fs/promises'; import Counter './Counter'; export default async function CounterContainer() { const initialValue = await readFile('/path/to/counter_value'); return <Counter initialValue={initialValue} /> } example, Counter \u2019s parent component, CounterContainer , require 'use client' interactive use state. addition, CounterContainer must Server Component reads local file system server, possible Server Component. also components don\u2019t use server client-only features agnostic render. earlier example, FancyText one component. export default function FancyText({title, text}) { return title ? <h1 className='fancy title'>{text}</h1> : <h3 className='fancy cursive'>{text}</h3> } case, don\u2019t add 'use client' directive, resulting FancyText \u2019s output (rather source code) sent browser referenced Server Component. demonstrated earlier Inspirations app example, FancyText used Server Client Component, depending imported used. FancyText \u2019s HTML output large relative source code (including dependencies), might efficient force always Client Component. Components return long SVG path string one case may efficient force component Client Component. Using client APIs React app may use client-specific APIs, browser\u2019s APIs web storage, audio video manipulation, device hardware, among others. example, component uses DOM APIs manipulate canvas element. Since APIs available browser, must marked Client Component. 'use client'; import {useRef, useEffect} 'react'; export default function Circle() { const ref = useRef(null); useLayoutEffect(() => { const canvas = ref.current; const context = canvas.getContext('2d'); context.reset(); context.beginPath(); context.arc(100, 75, 50, 0, 2 * Math.PI); context.stroke(); }); return <canvas ref={ref} />; } Using third-party libraries Often React app, you\u2019ll leverage third-party libraries handle common UI patterns logic. libraries may rely component Hooks client APIs. Third-party components use following React APIs must run client: - createContext react andreact-dom Hooks, excludinguse anduseId - forwardRef - memo - startTransition - use client APIs, ex. DOM insertion native platform views libraries updated compatible React Server Components, already include 'use client' markers own, allowing use directly Server Components. library hasn\u2019t updated, component needs props like event handlers specified client, may need add Client Component file third-party Client Component Server Component you\u2019d like use it."},
{"source": "https://react.dev/reference/rsc/use-server", "title": "'use server' directive \u2013 React", "text": "'use server' 'use server' marks server-side functions called client-side code. Reference 'use server' Add 'use server' top async function body mark function callable client. call functions Server Functions. async function addToCart(data) { 'use server'; // ... } calling Server Function client, make network request server includes serialized copy arguments passed. Server Function returns value, value serialized returned client. Instead individually marking functions 'use server' , add directive top file mark exports within file Server Functions used anywhere, including imported client code. Caveats 'use server' must beginning function module; code including imports (comments directives OK). must written single double quotes, backticks.'use server' used server-side files. resulting Server Functions passed Client Components props. See supported types serialization.- import Server Functions client code, directive must used module level. - underlying network calls always asynchronous, 'use server' used async functions. - Always treat arguments Server Functions untrusted input authorize mutations. See security considerations. - Server Functions called Transition. Server Functions passed <form action> orformAction automatically called transition. - Server Functions designed mutations update server-side state; recommended data fetching. Accordingly, frameworks implementing Server Functions typically process one action time way cache return value. Security considerations Arguments Server Functions fully client-controlled. security, always treat untrusted input, make sure validate escape arguments appropriate. Server Function, make sure validate logged-in user allowed perform action. Serializable arguments return values Since client code calls Server Function network, arguments passed need serializable. supported types Server Function arguments: - Primitives - Iterables containing serializable values - Date - FormData instances - Plain objects: created object initializers, serializable properties - Functions Server Functions - Promises Notably, supported: - React elements, JSX - Functions, including component functions function Server Function - Classes - Objects instances class (other built-ins mentioned) objects null prototype - Symbols registered globally, ex. Symbol('my new symbol') - Events event handlers Supported serializable return values serializable props boundary Client Component. Usage Server Functions forms common use case Server Functions calling functions mutate data. browser, HTML form element traditional approach user submit mutation. React Server Components, React introduces first-class support Server Functions Actions forms. form allows user request username. // App.js async function requestUsername(formData) { 'use server'; const username = formData.get('username'); // ... } export default function App() { return ( <form action={requestUsername}> <input type=\"text\" name=\"username\" /> <button type=\"submit\">Request</button> </form> ); } example requestUsername Server Function passed <form> . user submits form, network request server function requestUsername . calling Server Function form, React supply form\u2019s FormData first argument Server Function. passing Server Function form action , React progressively enhance form. means forms submitted JavaScript bundle loaded. Handling return values forms username request form, might chance username available. requestUsername tell us fails not. update UI based result Server Function supporting progressive enhancement, use useActionState . // requestUsername.js 'use server'; export default async function requestUsername(formData) { const username = formData.get('username'); (canRequest(username)) { // ... return 'successful'; } return 'failed'; } // UsernameForm.js 'use client'; import { useActionState } 'react'; import requestUsername './requestUsername'; function UsernameForm() { const [state, action] = useActionState(requestUsername, null, 'n/a'); return ( <> <form action={action}> <input type=\"text\" name=\"username\" /> <button type=\"submit\">Request</button> </form> <p>Last submission request returned: {state}</p> </> ); } Note like Hooks, useActionState called client code. Calling Server Function outside <form> Server Functions exposed server endpoints called anywhere client code. using Server Function outside form, call Server Function Transition, allows display loading indicator, show optimistic state updates, handle unexpected errors. Forms automatically wrap Server Functions transitions. import incrementLike './actions'; import { useState, useTransition } 'react'; function LikeButton() { const [isPending, startTransition] = useTransition(); const [likeCount, setLikeCount] = useState(0); const onClick = () => { startTransition(async () => { const currentCount = await incrementLike(); setLikeCount(currentCount); }); }; return ( <> <p>Total Likes: {likeCount}</p> <button onClick={onClick} disabled={isPending}>Like</button>; </> ); } // actions.js 'use server'; let likeCount = 0; export default async function incrementLike() { likeCount++; return likeCount; } read Server Function return value, you\u2019ll need await promise returned."},
{"source": "https://react.dev/reference/rules", "title": "Rules of React \u2013 React", "text": "Rules React different programming languages ways expressing concepts, React idioms \u2014 rules \u2014 express patterns way easy understand yields high-quality applications. section describes rules need follow write idiomatic React code. Writing idiomatic React code help write well organized, safe, composable applications. properties make app resilient changes makes easier work developers, libraries, tools. rules known Rules React. rules \u2013 guidelines \u2013 sense broken, app likely bugs. code also becomes unidiomatic harder understand reason about. strongly recommend using Strict Mode alongside React\u2019s ESLint plugin help codebase follow Rules React. following Rules React, you\u2019ll able find address bugs keep application maintainable. Components Hooks must pure Purity Components Hooks key rule React makes app predictable, easy debug, allows React automatically optimize code. - Components must idempotent \u2013 React components assumed always return output respect inputs \u2013 props, state, context. - Side effects must run outside render \u2013 Side effects run render, React render components multiple times create best possible user experience. - Props state immutable \u2013 component\u2019s props state immutable snapshots respect single render. Never mutate directly. - Return values arguments Hooks immutable \u2013 values passed Hook, modify them. Like props JSX, values become immutable passed Hook. - Values immutable passed JSX \u2013 Don\u2019t mutate values they\u2019ve used JSX. Move mutation JSX created. React calls Components Hooks React responsible rendering components hooks necessary optimize user experience. declarative: tell React render component\u2019s logic, React figure best display user. - Never call component functions directly \u2013 Components used JSX. Don\u2019t call regular functions. - Never pass around hooks regular values \u2013 Hooks called inside components. Never pass around regular value. Rules Hooks Hooks defined using JavaScript functions, represent special type reusable UI logic restrictions called. need follow Rules Hooks using them. - call Hooks top level \u2013 Don\u2019t call Hooks inside loops, conditions, nested functions. Instead, always use Hooks top level React function, early returns. - call Hooks React functions \u2013 Don\u2019t call Hooks regular JavaScript functions."},
{"source": "https://react.dev/reference/rules/components-and-hooks-must-be-pure", "title": "Components and Hooks must be pure \u2013 React", "text": "Components Hooks must pure Pure functions perform calculation nothing more. makes code easier understand, debug, allows React automatically optimize components Hooks correctly. - purity matter? - Components Hooks must idempotent - Side effects must run outside render - Props state immutable - Return values arguments Hooks immutable - Values immutable passed JSX purity matter? One key concepts makes React, React purity. pure component hook one is: - Idempotent \u2013 always get result every time run inputs \u2013 props, state, context component inputs; arguments hook inputs. - side effects render \u2013 Code side effects run separately rendering. example event handler \u2013 user interacts UI causes update; Effect \u2013 runs render. - mutate non-local values: Components Hooks never modify values aren\u2019t created locally render. render kept pure, React understand prioritize updates important user see first. made possible render purity: since components don\u2019t side effects render, React pause rendering components aren\u2019t important update, come back later it\u2019s needed. Concretely, means rendering logic run multiple times way allows React give user pleasant user experience. However, component untracked side effect \u2013 like modifying value global variable render \u2013 React runs rendering code again, side effects triggered way won\u2019t match want. often leads unexpected bugs degrade users experience app. see example Keeping Components Pure page. React run code? React declarative: tell React render, React figure best display user. this, React phases runs code. don\u2019t need know phases use React well. high level, know code runs render, runs outside it. Rendering refers calculating next version UI look like. rendering, Effects flushed (meaning run left) may update calculation Effects impacts layout. React takes new calculation compares calculation used create previous version UI, commits minimum changes needed DOM (what user actually sees) catch latest version. Deep Dive One quick heuristic tell code runs render examine is: it\u2019s written top level like example below, there\u2019s good chance runs render. function Dropdown() { const selectedItems = new Set(); // created render // ... } Event handlers Effects don\u2019t run render: function Dropdown() { const selectedItems = new Set(); const onSelect = (item) => { // code event handler, run user triggers selectedItems.add(item); } } function Dropdown() { const selectedItems = new Set(); useEffect(() => { // code inside Effect, runs rendering logForAnalytics(selectedItems); }, [selectedItems]); } Components Hooks must idempotent Components must always return output respect inputs \u2013 props, state, context. known idempotency. Idempotency term popularized functional programming. refers idea always get result every time run piece code inputs. means code runs render must also idempotent order rule hold. example, line code idempotent (and therefore, neither component): function Clock() { const time = new Date(); // \ud83d\udd34 Bad: always returns different result! return <span>{time.toLocaleString()}</span> } new Date() idempotent always returns current date changes result every time it\u2019s called. render component, time displayed screen stay stuck time component rendered. Similarly, functions like Math.random() also aren\u2019t idempotent, return different results every time they\u2019re called, even inputs same. doesn\u2019t mean shouldn\u2019t use non-idempotent functions like new Date() \u2013 avoid using render. case, synchronize latest date component using Effect: import { useState, useEffect } 'react'; function useTime() { // 1. Keep track current date's state. `useState` receives initializer function // initial state. runs hook called, current date // time hook called set first. const [time, setTime] = useState(() => new Date()); useEffect(() => { // 2. Update current date every second using `setInterval`. const id = setInterval(() => { setTime(new Date()); // \u2705 Good: non-idempotent code longer runs render }, 1000); // 3. Return cleanup function leak `setInterval` timer. return () => clearInterval(id); }, []); return time; } export default function Clock() { const time = useTime(); return <span>{time.toLocaleString()}</span>; } wrapping non-idempotent new Date() call Effect, moves calculation outside rendering. don\u2019t need synchronize external state React, also consider using event handler needs updated response user interaction. Side effects must run outside render Side effects run render, React render components multiple times create best possible user experience. render must kept pure, side effects necessary point order app anything interesting, like showing something screen! key point rule side effects run render, React render components multiple times. cases, you\u2019ll use event handlers handle side effects. Using event handler explicitly tells React code doesn\u2019t need run render, keeping render pure. you\u2019ve exhausted options \u2013 last resort \u2013 also handle side effects using useEffect . okay mutation? Local mutation One common example side effect mutation, JavaScript refers changing value non-primitive value. general, mutation idiomatic React, local mutation absolutely fine: function FriendList({ friends }) { const items = []; // \u2705 Good: locally created (let = 0; < friends.length; i++) { const friend = friends[i]; items.push( <Friend key={friend.id} friend={friend} /> ); // \u2705 Good: local mutation okay } return <section>{items}</section>; } need contort code avoid local mutation. Array.map could also used brevity, nothing wrong creating local array pushing items render. Even though looks like mutating items , key point note code locally \u2013 mutation isn\u2019t \u201cremembered\u201d component rendered again. words, items stays around long component does. items always recreated every time <FriendList /> rendered, component always return result. hand, items created outside component, holds previous values remembers changes: const items = []; // \ud83d\udd34 Bad: created outside component function FriendList({ friends }) { (let = 0; < friends.length; i++) { const friend = friends[i]; items.push( <Friend key={friend.id} friend={friend} /> ); // \ud83d\udd34 Bad: mutates value created outside render } return <section>{items}</section>; } <FriendList /> runs again, continue appending friends items every time component run, leading multiple duplicated results. version <FriendList /> observable side effects render breaks rule. Lazy initialization Lazy initialization also fine despite fully \u201cpure\u201d: function ExpenseForm() { SuperCalculator.initializeIfNotReady(); // \u2705 Good: affect components // Continue rendering... } Changing DOM Side effects directly visible user allowed render logic React components. words, merely calling component function shouldn\u2019t produce change screen. function ProductDetailPage({ product }) { document.title = product.title; // \ud83d\udd34 Bad: Changes DOM } One way achieve desired result updating document.title outside render synchronize component document . long calling component multiple times safe doesn\u2019t affect rendering components, React doesn\u2019t care it\u2019s 100% pure strict functional programming sense word. important components must idempotent. Props state immutable component\u2019s props state immutable snapshots. Never mutate directly. Instead, pass new props down, use setter function useState . think props state values snapshots updated rendering. reason, don\u2019t modify props state variables directly: instead pass new props, use setter function provided tell React state needs update next time component rendered. Don\u2019t mutate Props Props immutable mutate them, application produce inconsistent output, hard debug since may may work depending circumstance. function Post({ item }) { item.url = new Url(item.url, base); // \ud83d\udd34 Bad: never mutate props directly return <Link url={item.url}>{item.title}</Link>; } function Post({ item }) { const url = new Url(item.url, base); // \u2705 Good: make copy instead return <Link url={url}>{item.title}</Link>; } Don\u2019t mutate State useState returns state variable setter update state. const [stateVariable, setter] = useState(0); Rather updating state variable in-place, need update using setter function returned useState . Changing values state variable doesn\u2019t cause component update, leaving users outdated UI. Using setter function informs React state changed, need queue re-render update UI. function Counter() { const [count, setCount] = useState(0); function handleClick() { count = count + 1; // \ud83d\udd34 Bad: never mutate state directly } return ( <button onClick={handleClick}> pressed {count} times </button> ); } function Counter() { const [count, setCount] = useState(0); function handleClick() { setCount(count + 1); // \u2705 Good: use setter function returned useState } return ( <button onClick={handleClick}> pressed {count} times </button> ); } Return values arguments Hooks immutable values passed hook, modify them. Like props JSX, values become immutable passed hook. function useIconStyle(icon) { const theme = useContext(ThemeContext); (icon.enabled) { icon.className = computeStyle(icon, theme); // \ud83d\udd34 Bad: never mutate hook arguments directly } return icon; } function useIconStyle(icon) { const theme = useContext(ThemeContext); const newIcon = { ...icon }; // \u2705 Good: make copy instead (icon.enabled) { newIcon.className = computeStyle(icon, theme); } return newIcon; } One important principle React local reasoning: ability understand component hook looking code isolation. Hooks treated like \u201cblack boxes\u201d called. example, custom hook might used arguments dependencies memoize values inside it: function useIconStyle(icon) { const theme = useContext(ThemeContext); return useMemo(() => { const newIcon = { ...icon }; (icon.enabled) { newIcon.className = computeStyle(icon, theme); } return newIcon; }, [icon, theme]); } mutate Hooks arguments, custom hook\u2019s memoization become incorrect, it\u2019s important avoid that. style = useIconStyle(icon); // `style` memoized based `icon` icon.enabled = false; // Bad: \ud83d\udd34 never mutate hook arguments directly style = useIconStyle(icon); // previously memoized result returned style = useIconStyle(icon); // `style` memoized based `icon` icon = { ...icon, enabled: false }; // Good: \u2705 make copy instead style = useIconStyle(icon); // new value `style` calculated Similarly, it\u2019s important modify return values Hooks, may memoized. Values immutable passed JSX Don\u2019t mutate values they\u2019ve used JSX. Move mutation JSX created. use JSX expression, React may eagerly evaluate JSX component finishes rendering. means mutating values they\u2019ve passed JSX lead outdated UIs, React won\u2019t know update component\u2019s output. function Page({ colour }) { const styles = { colour, size: \"large\" }; const header = <Header styles={styles} />; styles.size = \"small\"; // \ud83d\udd34 Bad: styles already used JSX const footer = <Footer styles={styles} />; return ( <> {header} <Content /> {footer} </> ); } function Page({ colour }) { const headerStyles = { colour, size: \"large\" }; const header = <Header styles={headerStyles} />; const footerStyles = { colour, size: \"small\" }; // \u2705 Good: created new value const footer = <Footer styles={footerStyles} />; return ( <> {header} <Content /> {footer} </> ); }"},
{"source": "https://react.dev/reference/rules/react-calls-components-and-hooks", "title": "React calls Components and Hooks \u2013 React", "text": "React calls Components Hooks React responsible rendering components Hooks necessary optimize user experience. declarative: tell React render component\u2019s logic, React figure best display user. Never call component functions directly Components used JSX. Don\u2019t call regular functions. React call it. React must decide component function called rendering. React, using JSX. function BlogPost() { return <Layout><Article /></Layout>; // \u2705 Good: use components JSX } function BlogPost() { return <Layout>{Article()}</Layout>; // \ud83d\udd34 Bad: Never call directly } component contains Hooks, it\u2019s easy violate Rules Hooks components called directly loop conditionally. Letting React orchestrate rendering also allows number benefits: - Components become functions. React augment features like local state Hooks tied component\u2019s identity tree. - Component types participate reconciliation. letting React call components, also tell conceptual structure tree. example, move rendering <Feed> the<Profile> page, React won\u2019t attempt re-use them. - React enhance user experience. example, let browser work component calls re-rendering large component tree doesn\u2019t block main thread. - better debugging story. components first-class citizens library aware of, build rich developer tools introspection development. - efficient reconciliation. React decide exactly components tree need re-rendering skip ones don\u2019t. makes app faster snappy. Never pass around Hooks regular values Hooks called inside components Hooks. Never pass around regular value. Hooks allow augment component React features. always called function, never passed around regular value. enables local reasoning, ability developers understand everything component looking component isolation. Breaking rule cause React automatically optimize component. Don\u2019t dynamically mutate Hook Hooks \u201cstatic\u201d possible. means shouldn\u2019t dynamically mutate them. example, means shouldn\u2019t write higher order Hooks: function ChatInput() { const useDataWithLogging = withLogging(useData); // \ud83d\udd34 Bad: write higher order Hooks const data = useDataWithLogging(); } Hooks immutable mutated. Instead mutating Hook dynamically, create static version Hook desired functionality. function ChatInput() { const data = useDataWithLogging(); // \u2705 Good: Create new version Hook } function useDataWithLogging() { // ... Create new version Hook inline logic } Don\u2019t dynamically use Hooks Hooks also dynamically used: example, instead dependency injection component passing Hook value: function ChatInput() { return <Button useData={useDataWithLogging} /> // \ud83d\udd34 Bad: pass Hooks props } always inline call Hook component handle logic there. function ChatInput() { return <Button /> } function Button() { const data = useDataWithLogging(); // \u2705 Good: Use Hook directly } function useDataWithLogging() { // there's conditional logic change Hook's behavior, inlined // Hook } way, <Button /> much easier understand debug. Hooks used dynamic ways, increases complexity app greatly inhibits local reasoning, making team less productive long term. also makes easier accidentally break Rules Hooks Hooks called conditionally. find needing mock components tests, it\u2019s better mock server instead respond canned data. possible, it\u2019s also usually effective test app end-to-end tests."},
{"source": "https://react.dev/reference/rules/rules-of-hooks", "title": "Rules of Hooks \u2013 React", "text": "Rules Hooks Hooks defined using JavaScript functions, represent special type reusable UI logic restrictions called. call Hooks top level Functions whose names start use called Hooks React. Don\u2019t call Hooks inside loops, conditions, nested functions, try /catch /finally blocks. Instead, always use Hooks top level React function, early returns. call Hooks React rendering function component: - \u2705 Call top level body function component. - \u2705 Call top level body custom Hook. function Counter() { // \u2705 Good: top-level function component const [count, setCount] = useState(0); // ... } function useWindowWidth() { // \u2705 Good: top-level custom Hook const [width, setWidth] = useState(window.innerWidth); // ... } It\u2019s supported call Hooks (functions starting use ) cases, example: - \ud83d\udd34 call Hooks inside conditions loops. - \ud83d\udd34 call Hooks conditional return statement. - \ud83d\udd34 call Hooks event handlers. - \ud83d\udd34 call Hooks class components. - \ud83d\udd34 call Hooks inside functions passed useMemo ,useReducer , oruseEffect . - \ud83d\udd34 call Hooks inside try /catch /finally blocks. break rules, might see error. function Bad({ cond }) { (cond) { // \ud83d\udd34 Bad: inside condition (to fix, move outside!) const theme = useContext(ThemeContext); } // ... } function Bad() { (let = 0; < 10; i++) { // \ud83d\udd34 Bad: inside loop (to fix, move outside!) const theme = useContext(ThemeContext); } // ... } function Bad({ cond }) { (cond) { return; } // \ud83d\udd34 Bad: conditional return (to fix, move return!) const theme = useContext(ThemeContext); // ... } function Bad() { function handleClick() { // \ud83d\udd34 Bad: inside event handler (to fix, move outside!) const theme = useContext(ThemeContext); } // ... } function Bad() { const style = useMemo(() => { // \ud83d\udd34 Bad: inside useMemo (to fix, move outside!) const theme = useContext(ThemeContext); return createStyle(theme); }); // ... } class Bad extends React.Component { render() { // \ud83d\udd34 Bad: inside class component (to fix, write function component instead class!) useEffect(() => {}) // ... } } function Bad() { try { // \ud83d\udd34 Bad: inside try/catch/finally block (to fix, move outside!) const [x, setX] = useState(0); } catch { const [x, setX] = useState(1); } } use eslint-plugin-react-hooks plugin catch mistakes. call Hooks React functions Don\u2019t call Hooks regular JavaScript functions. Instead, can: \u2705 Call Hooks React function components. \u2705 Call Hooks custom Hooks. following rule, ensure stateful logic component clearly visible source code. function FriendList() { const [onlineStatus, setOnlineStatus] = useOnlineStatus(); // \u2705 } function setOnlineStatus() { // \u274c component custom Hook! const [onlineStatus, setOnlineStatus] = useOnlineStatus(); }"}]