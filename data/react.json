[
  {
    "source": "https://react.dev/reference/react",
    "title": "React Reference Overview \u2013 React",
    "text": "React Reference Overview\nThis section provides detailed reference documentation for working with React. For an introduction to React, please visit the Learn section.\nThe React reference documentation is broken down into functional subsections:\nReact\nProgrammatic React features:\n- Hooks - Use different React features from your components.\n- Components - Built-in components that you can use in your JSX.\n- APIs - APIs that are useful for defining components.\n- Directives - Provide instructions to bundlers compatible with React Server Components.\nReact DOM\nReact-dom contains features that are only supported for web applications (which run in the browser DOM environment). This section is broken into the following:\n- Hooks - Hooks for web applications which run in the browser DOM environment.\n- Components - React supports all of the browser built-in HTML and SVG components.\n- APIs - The\nreact-dom\npackage contains methods supported only in web applications. - Client APIs - The\nreact-dom/client\nAPIs let you render React components on the client (in the browser). - Server APIs - The\nreact-dom/server\nAPIs let you render React components to HTML on the server.\nRules of React\nReact has idioms \u2014 or rules \u2014 for how to express patterns in a way that is easy to understand and yields high-quality applications:\n- Components and Hooks must be pure \u2013 Purity makes your code easier to understand, debug, and allows React to automatically optimize your components and hooks correctly.\n- React calls Components and Hooks \u2013 React is responsible for rendering components and hooks when necessary to optimize the user experience.\n- Rules of Hooks \u2013 Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called.\nLegacy APIs\n- Legacy APIs - Exported from the\nreact\npackage, but not recommended for use in newly written code."
  },
  {
    "source": "https://react.dev/reference/react",
    "title": "React Reference Overview \u2013 React",
    "text": "React Reference Overview\nThis section provides detailed reference documentation for working with React. For an introduction to React, please visit the Learn section.\nThe React reference documentation is broken down into functional subsections:\nReact\nProgrammatic React features:\n- Hooks - Use different React features from your components.\n- Components - Built-in components that you can use in your JSX.\n- APIs - APIs that are useful for defining components.\n- Directives - Provide instructions to bundlers compatible with React Server Components.\nReact DOM\nReact-dom contains features that are only supported for web applications (which run in the browser DOM environment). This section is broken into the following:\n- Hooks - Hooks for web applications which run in the browser DOM environment.\n- Components - React supports all of the browser built-in HTML and SVG components.\n- APIs - The\nreact-dom\npackage contains methods supported only in web applications. - Client APIs - The\nreact-dom/client\nAPIs let you render React components on the client (in the browser). - Server APIs - The\nreact-dom/server\nAPIs let you render React components to HTML on the server.\nRules of React\nReact has idioms \u2014 or rules \u2014 for how to express patterns in a way that is easy to understand and yields high-quality applications:\n- Components and Hooks must be pure \u2013 Purity makes your code easier to understand, debug, and allows React to automatically optimize your components and hooks correctly.\n- React calls Components and Hooks \u2013 React is responsible for rendering components and hooks when necessary to optimize the user experience.\n- Rules of Hooks \u2013 Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called.\nLegacy APIs\n- Legacy APIs - Exported from the\nreact\npackage, but not recommended for use in newly written code."
  },
  {
    "source": "https://react.dev/reference/react-dom",
    "title": "React DOM APIs \u2013 React",
    "text": "React DOM APIs\nThe react-dom\npackage contains methods that are only supported for the web applications (which run in the browser DOM environment). They are not supported for React Native.\nAPIs\nThese APIs can be imported from your components. They are rarely used:\ncreatePortal\nlets you render child components in a different part of the DOM tree.flushSync\nlets you force React to flush a state update and update the DOM synchronously.\nResource Preloading APIs\nThese APIs can be used to make apps faster by pre-loading resources such as scripts, stylesheets, and fonts as soon as you know you need them, for example before navigating to another page where the resources will be used.\nReact-based frameworks frequently handle resource loading for you, so you might not have to call these APIs yourself. Consult your framework\u2019s documentation for details.\nprefetchDNS\nlets you prefetch the IP address of a DNS domain name that you expect to connect to.preconnect\nlets you connect to a server you expect to request resources from, even if you don\u2019t know what resources you\u2019ll need yet.preload\nlets you fetch a stylesheet, font, image, or external script that you expect to use.preloadModule\nlets you fetch an ESM module that you expect to use.preinit\nlets you fetch and evaluate an external script or fetch and insert a stylesheet.preinitModule\nlets you fetch and evaluate an ESM module.\nEntry points\nThe react-dom\npackage provides two additional entry points:\nreact-dom/client\ncontains APIs to render React components on the client (in the browser).react-dom/server\ncontains APIs to render React components on the server.\nRemoved APIs\nThese APIs were removed in React 19:\nfindDOMNode\n: see alternatives.hydrate\n: usehydrateRoot\ninstead.render\n: usecreateRoot\ninstead.unmountComponentAtNode\n: useroot.unmount()\ninstead.renderToNodeStream\n: usereact-dom/server\nAPIs instead.renderToStaticNodeStream\n: usereact-dom/server\nAPIs instead."
  },
  {
    "source": "https://react.dev/reference/react-dom/client",
    "title": "Client React DOM APIs \u2013 React",
    "text": "Client React DOM APIs\nThe react-dom/client\nAPIs let you render React components on the client (in the browser). These APIs are typically used at the top level of your app to initialize your React tree. A framework may call them for you. Most of your components don\u2019t need to import or use them.\nClient APIs\ncreateRoot\nlets you create a root to display React components inside a browser DOM node.hydrateRoot\nlets you display React components inside a browser DOM node whose HTML content was previously generated byreact-dom/server\n.\nBrowser support\nReact supports all popular browsers, including Internet Explorer 9 and above. Some polyfills are required for older browsers such as IE 9 and IE 10."
  },
  {
    "source": "https://react.dev/reference/react-dom/client/createRoot",
    "title": "createRoot \u2013 React",
    "text": "createRoot\ncreateRoot\nlets you create a root to display React components inside a browser DOM node.\nconst root = createRoot(domNode, options?)\nReference\ncreateRoot(domNode, options?)\nCall createRoot\nto create a React root for displaying content inside a browser DOM element.\nimport { createRoot } from 'react-dom/client';\nconst domNode = document.getElementById('root');\nconst root = createRoot(domNode);\nReact will create a root for the domNode\n, and take over managing the DOM inside it. After you\u2019ve created a root, you need to call root.render\nto display a React component inside of it:\nroot.render(<App />);\nAn app fully built with React will usually only have one createRoot\ncall for its root component. A page that uses \u201csprinkles\u201d of React for parts of the page may have as many separate roots as needed.\nParameters\n-\ndomNode\n: A DOM element. React will create a root for this DOM element and allow you to call functions on the root, such asrender\nto display rendered React content. -\noptional\noptions\n: An object with options for this React root.- optional\nonCaughtError\n: Callback called when React catches an error in an Error Boundary. Called with theerror\ncaught by the Error Boundary, and anerrorInfo\nobject containing thecomponentStack\n. - optional\nonUncaughtError\n: Callback called when an error is thrown and not caught by an Error Boundary. Called with theerror\nthat was thrown, and anerrorInfo\nobject containing thecomponentStack\n. - optional\nonRecoverableError\n: Callback called when React automatically recovers from errors. Called with anerror\nReact throws, and anerrorInfo\nobject containing thecomponentStack\n. Some recoverable errors may include the original error cause aserror.cause\n. - optional\nidentifierPrefix\n: A string prefix React uses for IDs generated byuseId\n. Useful to avoid conflicts when using multiple roots on the same page.\n- optional\nReturns\ncreateRoot\nreturns an object with two methods: render\nand unmount\n.\nCaveats\n- If your app is server-rendered, using\ncreateRoot()\nis not supported. UsehydrateRoot()\ninstead. - You\u2019ll likely have only one\ncreateRoot\ncall in your app. If you use a framework, it might do this call for you. - When you want to render a piece of JSX in a different part of the DOM tree that isn\u2019t a child of your component (for example, a modal or a tooltip), use\ncreatePortal\ninstead ofcreateRoot\n.\nroot.render(reactNode)\nCall root.render\nto display a piece of JSX (\u201cReact node\u201d) into the React root\u2019s browser DOM node.\nroot.render(<App />);\nReact will display <App />\nin the root\n, and take over managing the DOM inside it.\nParameters\nreactNode\n: A React node that you want to display. This will usually be a piece of JSX like<App />\n, but you can also pass a React element constructed withcreateElement()\n, a string, a number,null\n, orundefined\n.\nReturns\nroot.render\nreturns undefined\n.\nCaveats\n-\nThe first time you call\nroot.render\n, React will clear all the existing HTML content inside the React root before rendering the React component into it. -\nIf your root\u2019s DOM node contains HTML generated by React on the server or during the build, use\nhydrateRoot()\ninstead, which attaches the event handlers to the existing HTML. -\nIf you call\nrender\non the same root more than once, React will update the DOM as necessary to reflect the latest JSX you passed. React will decide which parts of the DOM can be reused and which need to be recreated by \u201cmatching it up\u201d with the previously rendered tree. Callingrender\non the same root again is similar to calling theset\nfunction on the root component: React avoids unnecessary DOM updates.\nroot.unmount()\nCall root.unmount\nto destroy a rendered tree inside a React root.\nroot.unmount();\nAn app fully built with React will usually not have any calls to root.unmount\n.\nThis is mostly useful if your React root\u2019s DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. In that case, you need to tell React to \u201cstop\u201d managing the removed root\u2019s content by calling root.unmount\n. Otherwise, the components inside the removed root won\u2019t know to clean up and free up global resources like subscriptions.\nCalling root.unmount\nwill unmount all the components in the root and \u201cdetach\u201d React from the root DOM node, including removing any event handlers or state in the tree.\nParameters\nroot.unmount\ndoes not accept any parameters.\nReturns\nroot.unmount\nreturns undefined\n.\nCaveats\n-\nCalling\nroot.unmount\nwill unmount all the components in the tree and \u201cdetach\u201d React from the root DOM node. -\nOnce you call\nroot.unmount\nyou cannot callroot.render\nagain on the same root. Attempting to callroot.render\non an unmounted root will throw a \u201cCannot update an unmounted root\u201d error. However, you can create a new root for the same DOM node after the previous root for that node has been unmounted.\nUsage\nRendering an app fully built with React\nIf your app is fully built with React, create a single root for your entire app.\nimport { createRoot } from 'react-dom/client';\nconst root = createRoot(document.getElementById('root'));\nroot.render(<App />);\nUsually, you only need to run this code once at startup. It will:\n- Find the browser DOM node defined in your HTML.\n- Display the React component for your app inside.\nimport { createRoot } from 'react-dom/client'; import App from './App.js'; import './styles.css'; const root = createRoot(document.getElementById('root')); root.render(<App />);\nIf your app is fully built with React, you shouldn\u2019t need to create any more roots, or to call root.render\nagain.\nFrom this point on, React will manage the DOM of your entire app. To add more components, nest them inside the App\ncomponent. When you need to update the UI, each of your components can do this by using state. When you need to display extra content like a modal or a tooltip outside the DOM node, render it with a portal.\nRendering a page partially built with React\nIf your page isn\u2019t fully built with React, you can call createRoot\nmultiple times to create a root for each top-level piece of UI managed by React. You can display different content in each root by calling root.render\n.\nHere, two different React components are rendered into two DOM nodes defined in the index.html\nfile:\nimport './styles.css'; import { createRoot } from 'react-dom/client'; import { Comments, Navigation } from './Components.js'; const navDomNode = document.getElementById('navigation'); const navRoot = createRoot(navDomNode); navRoot.render(<Navigation />); const commentDomNode = document.getElementById('comments'); const commentRoot = createRoot(commentDomNode); commentRoot.render(<Comments />);\nYou could also create a new DOM node with document.createElement()\nand add it to the document manually.\nconst domNode = document.createElement('div');\nconst root = createRoot(domNode);\nroot.render(<Comment />);\ndocument.body.appendChild(domNode); // You can add it anywhere in the document\nTo remove the React tree from the DOM node and clean up all the resources used by it, call root.unmount\n.\nroot.unmount();\nThis is mostly useful if your React components are inside an app written in a different framework.\nUpdating a root component\nYou can call render\nmore than once on the same root. As long as the component tree structure matches up with what was previously rendered, React will preserve the state. Notice how you can type in the input, which means that the updates from repeated render\ncalls every second in this example are not destructive:\nimport { createRoot } from 'react-dom/client'; import './styles.css'; import App from './App.js'; const root = createRoot(document.getElementById('root')); let i = 0; setInterval(() => { root.render(<App counter={i} />); i++; }, 1000);\nIt is uncommon to call render\nmultiple times. Usually, your components will update state instead.\nShow a dialog for uncaught errors\nBy default, React will log all uncaught errors to the console. To implement your own error reporting, you can provide the optional onUncaughtError\nroot option:\nimport { createRoot } from 'react-dom/client';\nconst root = createRoot(\ndocument.getElementById('root'),\n{\nonUncaughtError: (error, errorInfo) => {\nconsole.error(\n'Uncaught error',\nerror,\nerrorInfo.componentStack\n);\n}\n}\n);\nroot.render(<App />);\nThe onUncaughtError option is a function called with two arguments:\n- The error that was thrown.\n- An errorInfo object that contains the componentStack of the error.\nYou can use the onUncaughtError\nroot option to display error dialogs:\nimport { createRoot } from \"react-dom/client\"; import App from \"./App.js\"; import {reportUncaughtError} from \"./reportError\"; import \"./styles.css\"; const container = document.getElementById(\"root\"); const root = createRoot(container, { onUncaughtError: (error, errorInfo) => { if (error.message !== 'Known error') { reportUncaughtError({ error, componentStack: errorInfo.componentStack }); } } }); root.render(<App />);\nDisplaying Error Boundary errors\nBy default, React will log all errors caught by an Error Boundary to console.error\n. To override this behavior, you can provide the optional onCaughtError\nroot option to handle errors caught by an Error Boundary:\nimport { createRoot } from 'react-dom/client';\nconst root = createRoot(\ndocument.getElementById('root'),\n{\nonCaughtError: (error, errorInfo) => {\nconsole.error(\n'Caught error',\nerror,\nerrorInfo.componentStack\n);\n}\n}\n);\nroot.render(<App />);\nThe onCaughtError option is a function called with two arguments:\n- The error that was caught by the boundary.\n- An errorInfo object that contains the componentStack of the error.\nYou can use the onCaughtError\nroot option to display error dialogs or filter known errors from logging:\nimport { createRoot } from \"react-dom/client\"; import App from \"./App.js\"; import {reportCaughtError} from \"./reportError\"; import \"./styles.css\"; const container = document.getElementById(\"root\"); const root = createRoot(container, { onCaughtError: (error, errorInfo) => { if (error.message !== 'Known error') { reportCaughtError({ error, componentStack: errorInfo.componentStack, }); } } }); root.render(<App />);\nDisplaying a dialog for recoverable errors\nReact may automatically render a component a second time to attempt to recover from an error thrown in render. If successful, React will log a recoverable error to the console to notify the developer. To override this behavior, you can provide the optional onRecoverableError\nroot option:\nimport { createRoot } from 'react-dom/client';\nconst root = createRoot(\ndocument.getElementById('root'),\n{\nonRecoverableError: (error, errorInfo) => {\nconsole.error(\n'Recoverable error',\nerror,\nerror.cause,\nerrorInfo.componentStack,\n);\n}\n}\n);\nroot.render(<App />);\nThe onRecoverableError option is a function called with two arguments:\n- The error that React throws. Some errors may include the original cause as error.cause.\n- An errorInfo object that contains the componentStack of the error.\nYou can use the onRecoverableError\nroot option to display error dialogs:\nimport { createRoot } from \"react-dom/client\"; import App from \"./App.js\"; import {reportRecoverableError} from \"./reportError\"; import \"./styles.css\"; const container = document.getElementById(\"root\"); const root = createRoot(container, { onRecoverableError: (error, errorInfo) => { reportRecoverableError({ error, cause: error.cause, componentStack: errorInfo.componentStack, }); } }); root.render(<App />);\nTroubleshooting\nI\u2019ve created a root, but nothing is displayed\nMake sure you haven\u2019t forgotten to actually render your app into the root:\nimport { createRoot } from 'react-dom/client';\nimport App from './App.js';\nconst root = createRoot(document.getElementById('root'));\nroot.render(<App />);\nUntil you do that, nothing is displayed.\nI\u2019m getting an error: \u201cYou passed a second argument to root.render\u201d\nA common mistake is to pass the options for createRoot\nto root.render(...)\n:\nTo fix, pass the root options to createRoot(...)\n, not root.render(...)\n:\n// \ud83d\udea9 Wrong: root.render only takes one argument.\nroot.render(App, {onUncaughtError});\n// \u2705 Correct: pass options to createRoot.\nconst root = createRoot(container, {onUncaughtError});\nroot.render(<App />);\nI\u2019m getting an error: \u201cTarget container is not a DOM element\u201d\nThis error means that whatever you\u2019re passing to createRoot\nis not a DOM node.\nIf you\u2019re not sure what\u2019s happening, try logging it:\nconst domNode = document.getElementById('root');\nconsole.log(domNode); // ???\nconst root = createRoot(domNode);\nroot.render(<App />);\nFor example, if domNode\nis null\n, it means that getElementById\nreturned null\n. This will happen if there is no node in the document with the given ID at the time of your call. There may be a few reasons for it:\n- The ID you\u2019re looking for might differ from the ID you used in the HTML file. Check for typos!\n- Your bundle\u2019s\n<script>\ntag cannot \u201csee\u201d any DOM nodes that appear after it in the HTML.\nAnother common way to get this error is to write createRoot(<App />)\ninstead of createRoot(domNode)\n.\nI\u2019m getting an error: \u201cFunctions are not valid as a React child.\u201d\nThis error means that whatever you\u2019re passing to root.render\nis not a React component.\nThis may happen if you call root.render\nwith Component\ninstead of <Component />\n:\n// \ud83d\udea9 Wrong: App is a function, not a Component.\nroot.render(App);\n// \u2705 Correct: <App /> is a component.\nroot.render(<App />);\nOr if you pass a function to root.render\n, instead of the result of calling it:\n// \ud83d\udea9 Wrong: createApp is a function, not a component.\nroot.render(createApp);\n// \u2705 Correct: call createApp to return a component.\nroot.render(createApp());\nMy server-rendered HTML gets re-created from scratch\nIf your app is server-rendered and includes the initial HTML generated by React, you might notice that creating a root and calling root.render\ndeletes all that HTML, and then re-creates all the DOM nodes from scratch. This can be slower, resets focus and scroll positions, and may lose other user input.\nServer-rendered apps must use hydrateRoot\ninstead of createRoot\n:\nimport { hydrateRoot } from 'react-dom/client';\nimport App from './App.js';\nhydrateRoot(\ndocument.getElementById('root'),\n<App />\n);\nNote that its API is different. In particular, usually there will be no further root.render\ncall."
  },
  {
    "source": "https://react.dev/reference/react-dom/client/hydrateRoot",
    "title": "hydrateRoot \u2013 React",
    "text": "hydrateRoot\nhydrateRoot\nlets you display React components inside a browser DOM node whose HTML content was previously generated by react-dom/server\n.\nconst root = hydrateRoot(domNode, reactNode, options?)\n- Reference\n- Usage\n- Hydrating server-rendered HTML\n- Hydrating an entire document\n- Suppressing unavoidable hydration mismatch errors\n- Handling different client and server content\n- Updating a hydrated root component\n- Show a dialog for uncaught errors\n- Displaying Error Boundary errors\n- Show a dialog for recoverable hydration mismatch errors\n- Troubleshooting\nReference\nhydrateRoot(domNode, reactNode, options?)\nCall hydrateRoot\nto \u201cattach\u201d React to existing HTML that was already rendered by React in a server environment.\nimport { hydrateRoot } from 'react-dom/client';\nconst domNode = document.getElementById('root');\nconst root = hydrateRoot(domNode, reactNode);\nReact will attach to the HTML that exists inside the domNode\n, and take over managing the DOM inside it. An app fully built with React will usually only have one hydrateRoot\ncall with its root component.\nParameters\n-\ndomNode\n: A DOM element that was rendered as the root element on the server. -\nreactNode\n: The \u201cReact node\u201d used to render the existing HTML. This will usually be a piece of JSX like<App />\nwhich was rendered with aReactDOM Server\nmethod such asrenderToPipeableStream(<App />)\n. -\noptional\noptions\n: An object with options for this React root.- optional\nonCaughtError\n: Callback called when React catches an error in an Error Boundary. Called with theerror\ncaught by the Error Boundary, and anerrorInfo\nobject containing thecomponentStack\n. - optional\nonUncaughtError\n: Callback called when an error is thrown and not caught by an Error Boundary. Called with theerror\nthat was thrown and anerrorInfo\nobject containing thecomponentStack\n. - optional\nonRecoverableError\n: Callback called when React automatically recovers from errors. Called with theerror\nReact throws, and anerrorInfo\nobject containing thecomponentStack\n. Some recoverable errors may include the original error cause aserror.cause\n. - optional\nidentifierPrefix\n: A string prefix React uses for IDs generated byuseId\n. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as used on the server.\n- optional\nReturns\nhydrateRoot\nreturns an object with two methods: render\nand unmount\n.\nCaveats\nhydrateRoot()\nexpects the rendered content to be identical with the server-rendered content. You should treat mismatches as bugs and fix them.- In development mode, React warns about mismatches during hydration. There are no guarantees that attribute differences will be patched up in case of mismatches. This is important for performance reasons because in most apps, mismatches are rare, and so validating all markup would be prohibitively expensive.\n- You\u2019ll likely have only one\nhydrateRoot\ncall in your app. If you use a framework, it might do this call for you. - If your app is client-rendered with no HTML rendered already, using\nhydrateRoot()\nis not supported. UsecreateRoot()\ninstead.\nroot.render(reactNode)\nCall root.render\nto update a React component inside a hydrated React root for a browser DOM element.\nroot.render(<App />);\nReact will update <App />\nin the hydrated root\n.\nParameters\nreactNode\n: A \u201cReact node\u201d that you want to update. This will usually be a piece of JSX like<App />\n, but you can also pass a React element constructed withcreateElement()\n, a string, a number,null\n, orundefined\n.\nReturns\nroot.render\nreturns undefined\n.\nCaveats\n- If you call\nroot.render\nbefore the root has finished hydrating, React will clear the existing server-rendered HTML content and switch the entire root to client rendering.\nroot.unmount()\nCall root.unmount\nto destroy a rendered tree inside a React root.\nroot.unmount();\nAn app fully built with React will usually not have any calls to root.unmount\n.\nThis is mostly useful if your React root\u2019s DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. You need to tell React to \u201cstop\u201d managing the removed root\u2019s content by calling root.unmount\n. Otherwise, the components inside the removed root won\u2019t clean up and free up resources like subscriptions.\nCalling root.unmount\nwill unmount all the components in the root and \u201cdetach\u201d React from the root DOM node, including removing any event handlers or state in the tree.\nParameters\nroot.unmount\ndoes not accept any parameters.\nReturns\nroot.unmount\nreturns undefined\n.\nCaveats\n-\nCalling\nroot.unmount\nwill unmount all the components in the tree and \u201cdetach\u201d React from the root DOM node. -\nOnce you call\nroot.unmount\nyou cannot callroot.render\nagain on the root. Attempting to callroot.render\non an unmounted root will throw a \u201cCannot update an unmounted root\u201d error.\nUsage\nHydrating server-rendered HTML\nIf your app\u2019s HTML was generated by react-dom/server\n, you need to hydrate it on the client.\nimport { hydrateRoot } from 'react-dom/client';\nhydrateRoot(document.getElementById('root'), <App />);\nThis will hydrate the server HTML inside the browser DOM node with the React component for your app. Usually, you will do it once at startup. If you use a framework, it might do this behind the scenes for you.\nTo hydrate your app, React will \u201cattach\u201d your components\u2019 logic to the initial generated HTML from the server. Hydration turns the initial HTML snapshot from the server into a fully interactive app that runs in the browser.\nimport './styles.css'; import { hydrateRoot } from 'react-dom/client'; import App from './App.js'; hydrateRoot( document.getElementById('root'), <App /> );\nYou shouldn\u2019t need to call hydrateRoot\nagain or to call it in more places. From this point on, React will be managing the DOM of your application. To update the UI, your components will use state instead.\nHydrating an entire document\nApps fully built with React can render the entire document as JSX, including the <html>\ntag:\nfunction App() {\nreturn (\n<html>\n<head>\n<meta charSet=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<link rel=\"stylesheet\" href=\"/styles.css\"></link>\n<title>My app</title>\n</head>\n<body>\n<Router />\n</body>\n</html>\n);\n}\nTo hydrate the entire document, pass the document\nglobal as the first argument to hydrateRoot\n:\nimport { hydrateRoot } from 'react-dom/client';\nimport App from './App.js';\nhydrateRoot(document, <App />);\nSuppressing unavoidable hydration mismatch errors\nIf a single element\u2019s attribute or text content is unavoidably different between the server and the client (for example, a timestamp), you may silence the hydration mismatch warning.\nTo silence hydration warnings on an element, add suppressHydrationWarning={true}\n:\nexport default function App() { return ( <h1 suppressHydrationWarning={true}> Current Date: {new Date().toLocaleDateString()} </h1> ); }\nThis only works one level deep, and is intended to be an escape hatch. Don\u2019t overuse it. Unless it\u2019s text content, React still won\u2019t attempt to patch it up, so it may remain inconsistent until future updates.\nHandling different client and server content\nIf you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read a state variable like isClient\n, which you can set to true\nin an Effect:\nimport { useState, useEffect } from \"react\"; export default function App() { const [isClient, setIsClient] = useState(false); useEffect(() => { setIsClient(true); }, []); return ( <h1> {isClient ? 'Is Client' : 'Is Server'} </h1> ); }\nThis way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration.\nUpdating a hydrated root component\nAfter the root has finished hydrating, you can call root.render\nto update the root React component. Unlike with createRoot\n, you don\u2019t usually need to do this because the initial content was already rendered as HTML.\nIf you call root.render\nat some point after hydration, and the component tree structure matches up with what was previously rendered, React will preserve the state. Notice how you can type in the input, which means that the updates from repeated render\ncalls every second in this example are not destructive:\nimport { hydrateRoot } from 'react-dom/client'; import './styles.css'; import App from './App.js'; const root = hydrateRoot( document.getElementById('root'), <App counter={0} /> ); let i = 0; setInterval(() => { root.render(<App counter={i} />); i++; }, 1000);\nIt is uncommon to call root.render\non a hydrated root. Usually, you\u2019ll update state inside one of the components instead.\nShow a dialog for uncaught errors\nBy default, React will log all uncaught errors to the console. To implement your own error reporting, you can provide the optional onUncaughtError\nroot option:\nimport { hydrateRoot } from 'react-dom/client';\nconst root = hydrateRoot(\ndocument.getElementById('root'),\n<App />,\n{\nonUncaughtError: (error, errorInfo) => {\nconsole.error(\n'Uncaught error',\nerror,\nerrorInfo.componentStack\n);\n}\n}\n);\nroot.render(<App />);\nThe onUncaughtError option is a function called with two arguments:\n- The error that was thrown.\n- An errorInfo object that contains the componentStack of the error.\nYou can use the onUncaughtError\nroot option to display error dialogs:\nimport { hydrateRoot } from \"react-dom/client\"; import App from \"./App.js\"; import {reportUncaughtError} from \"./reportError\"; import \"./styles.css\"; import {renderToString} from 'react-dom/server'; const container = document.getElementById(\"root\"); const root = hydrateRoot(container, <App />, { onUncaughtError: (error, errorInfo) => { if (error.message !== 'Known error') { reportUncaughtError({ error, componentStack: errorInfo.componentStack }); } } });\nDisplaying Error Boundary errors\nBy default, React will log all errors caught by an Error Boundary to console.error\n. To override this behavior, you can provide the optional onCaughtError\nroot option for errors caught by an Error Boundary:\nimport { hydrateRoot } from 'react-dom/client';\nconst root = hydrateRoot(\ndocument.getElementById('root'),\n<App />,\n{\nonCaughtError: (error, errorInfo) => {\nconsole.error(\n'Caught error',\nerror,\nerrorInfo.componentStack\n);\n}\n}\n);\nroot.render(<App />);\nThe onCaughtError option is a function called with two arguments:\n- The error that was caught by the boundary.\n- An errorInfo object that contains the componentStack of the error.\nYou can use the onCaughtError\nroot option to display error dialogs or filter known errors from logging:\nimport { hydrateRoot } from \"react-dom/client\"; import App from \"./App.js\"; import {reportCaughtError} from \"./reportError\"; import \"./styles.css\"; const container = document.getElementById(\"root\"); const root = hydrateRoot(container, <App />, { onCaughtError: (error, errorInfo) => { if (error.message !== 'Known error') { reportCaughtError({ error, componentStack: errorInfo.componentStack }); } } });\nShow a dialog for recoverable hydration mismatch errors\nWhen React encounters a hydration mismatch, it will automatically attempt to recover by rendering on the client. By default, React will log hydration mismatch errors to console.error\n. To override this behavior, you can provide the optional onRecoverableError\nroot option:\nimport { hydrateRoot } from 'react-dom/client';\nconst root = hydrateRoot(\ndocument.getElementById('root'),\n<App />,\n{\nonRecoverableError: (error, errorInfo) => {\nconsole.error(\n'Caught error',\nerror,\nerror.cause,\nerrorInfo.componentStack\n);\n}\n}\n);\nThe onRecoverableError option is a function called with two arguments:\n- The error React throws. Some errors may include the original cause as error.cause.\n- An errorInfo object that contains the componentStack of the error.\nYou can use the onRecoverableError\nroot option to display error dialogs for hydration mismatches:\nimport { hydrateRoot } from \"react-dom/client\"; import App from \"./App.js\"; import {reportRecoverableError} from \"./reportError\"; import \"./styles.css\"; const container = document.getElementById(\"root\"); const root = hydrateRoot(container, <App />, { onRecoverableError: (error, errorInfo) => { reportRecoverableError({ error, cause: error.cause, componentStack: errorInfo.componentStack }); } });\nTroubleshooting\nI\u2019m getting an error: \u201cYou passed a second argument to root.render\u201d\nA common mistake is to pass the options for hydrateRoot\nto root.render(...)\n:\nTo fix, pass the root options to hydrateRoot(...)\n, not root.render(...)\n:\n// \ud83d\udea9 Wrong: root.render only takes one argument.\nroot.render(App, {onUncaughtError});\n// \u2705 Correct: pass options to createRoot.\nconst root = hydrateRoot(container, <App />, {onUncaughtError});"
  },
  {
    "source": "https://react.dev/reference/react-dom/components",
    "title": "React DOM Components \u2013 React",
    "text": "React DOM Components\nCommon components\nAll of the built-in browser components support some props and events.\nThis includes React-specific props like ref\nand dangerouslySetInnerHTML\n.\nForm components\nThese built-in browser components accept user input:\nThey are special in React because passing the value\nprop to them makes them controlled.\nResource and Metadata Components\nThese built-in browser components let you load external resources or annotate the document with metadata:\nThey are special in React because React can render them into the document head, suspend while resources are loading, and enact other behaviors that are described on the reference page for each specific component.\nAll HTML components\nReact supports all built-in browser HTML components. This includes:\n<aside>\n<audio>\n<b>\n<base>\n<bdi>\n<bdo>\n<blockquote>\n<body>\n<br>\n<button>\n<canvas>\n<caption>\n<cite>\n<code>\n<col>\n<colgroup>\n<data>\n<datalist>\n<dd>\n<del>\n<details>\n<dfn>\n<dialog>\n<div>\n<dl>\n<dt>\n<em>\n<embed>\n<fieldset>\n<figcaption>\n<figure>\n<footer>\n<form>\n<h1>\n<head>\n<header>\n<hgroup>\n<hr>\n<html>\n<i>\n<iframe>\n<img>\n<input>\n<ins>\n<kbd>\n<label>\n<legend>\n<li>\n<link>\n<main>\n<map>\n<mark>\n<menu>\n<meta>\n<meter>\n<nav>\n<noscript>\n<object>\n<ol>\n<optgroup>\n<option>\n<output>\n<p>\n<picture>\n<pre>\n<progress>\n<q>\n<rp>\n<rt>\n<ruby>\n<s>\n<samp>\n<script>\n<section>\n<select>\n<slot>\n<small>\n<source>\n<span>\n<strong>\n<style>\n<sub>\n<summary>\n<sup>\n<table>\n<tbody>\n<td>\n<template>\n<textarea>\n<tfoot>\n<th>\n<thead>\n<time>\n<title>\n<tr>\n<track>\n<u>\n<ul>\n<var>\n<video>\n<wbr>\nCustom HTML elements\nIf you render a tag with a dash, like <my-element>\n, React will assume you want to render a custom HTML element. In React, rendering custom elements works differently from rendering built-in browser tags:\n- All custom element props are serialized to strings and are always set using attributes.\n- Custom elements accept\nclass\nrather thanclassName\n, andfor\nrather thanhtmlFor\n.\nIf you render a built-in browser HTML element with an is\nattribute, it will also be treated as a custom element.\nAll SVG components\nReact supports all built-in browser SVG components. This includes:\n<a>\n<animate>\n<animateMotion>\n<animateTransform>\n<circle>\n<clipPath>\n<defs>\n<desc>\n<discard>\n<ellipse>\n<feBlend>\n<feColorMatrix>\n<feComponentTransfer>\n<feComposite>\n<feConvolveMatrix>\n<feDiffuseLighting>\n<feDisplacementMap>\n<feDistantLight>\n<feDropShadow>\n<feFlood>\n<feFuncA>\n<feFuncB>\n<feFuncG>\n<feFuncR>\n<feGaussianBlur>\n<feImage>\n<feMerge>\n<feMergeNode>\n<feMorphology>\n<feOffset>\n<fePointLight>\n<feSpecularLighting>\n<feSpotLight>\n<feTile>\n<feTurbulence>\n<filter>\n<foreignObject>\n<g>\n<hatch>\n<hatchpath>\n<image>\n<line>\n<linearGradient>\n<marker>\n<mask>\n<metadata>\n<mpath>\n<path>\n<pattern>\n<polygon>\n<polyline>\n<radialGradient>\n<rect>\n<script>\n<set>\n<stop>\n<style>\n<svg>\n<switch>\n<symbol>\n<text>\n<textPath>\n<title>\n<tspan>\n<use>\n<view>"
  },
  {
    "source": "https://react.dev/reference/react-dom/components/common",
    "title": "Common components (e.g. <div>) \u2013 React",
    "text": "Common components (e.g. <div>)\nAll built-in browser components, such as <div>\n, support some common props and events.\n- Reference\n- Common components (e.g.\n<div>\n) ref\ncallback function- React event object\nAnimationEvent\nhandler functionClipboardEvent\nhandler functionCompositionEvent\nhandler functionDragEvent\nhandler functionFocusEvent\nhandler functionEvent\nhandler functionInputEvent\nhandler functionKeyboardEvent\nhandler functionMouseEvent\nhandler functionPointerEvent\nhandler functionTouchEvent\nhandler functionTransitionEvent\nhandler functionUIEvent\nhandler functionWheelEvent\nhandler function\n- Common components (e.g.\n- Usage\nReference\nCommon components (e.g. <div>\n)\n<div className=\"wrapper\">Some content</div>\nProps\nThese special React props are supported for all built-in components:\n-\nchildren\n: A React node (an element, a string, a number, a portal, an empty node likenull\n,undefined\nand booleans, or an array of other React nodes). Specifies the content inside the component. When you use JSX, you will usually specify thechildren\nprop implicitly by nesting tags like<div><span /></div>\n. -\ndangerouslySetInnerHTML\n: An object of the form{ __html: '<p>some html</p>' }\nwith a raw HTML string inside. Overrides theinnerHTML\nproperty of the DOM node and displays the passed HTML inside. This should be used with extreme caution! If the HTML inside isn\u2019t trusted (for example, if it\u2019s based on user data), you risk introducing an XSS vulnerability. Read more about usingdangerouslySetInnerHTML\n. -\nref\n: A ref object fromuseRef\norcreateRef\n, or aref\ncallback function, or a string for legacy refs. Your ref will be filled with the DOM element for this node. Read more about manipulating the DOM with refs. -\nsuppressContentEditableWarning\n: A boolean. Iftrue\n, suppresses the warning that React shows for elements that both havechildren\nandcontentEditable={true}\n(which normally do not work together). Use this if you\u2019re building a text input library that manages thecontentEditable\ncontent manually. -\nsuppressHydrationWarning\n: A boolean. If you use server rendering, normally there is a warning when the server and the client render different content. In some rare cases (like timestamps), it is very hard or impossible to guarantee an exact match. If you setsuppressHydrationWarning\ntotrue\n, React will not warn you about mismatches in the attributes and the content of that element. It only works one level deep, and is intended to be used as an escape hatch. Don\u2019t overuse it. Read about suppressing hydration errors. -\nstyle\n: An object with CSS styles, for example{ fontWeight: 'bold', margin: 20 }\n. Similarly to the DOMstyle\nproperty, the CSS property names need to be written ascamelCase\n, for examplefontWeight\ninstead offont-weight\n. You can pass strings or numbers as values. If you pass a number, likewidth: 100\n, React will automatically appendpx\n(\u201cpixels\u201d) to the value unless it\u2019s a unitless property. We recommend usingstyle\nonly for dynamic styles where you don\u2019t know the style values ahead of time. In other cases, applying plain CSS classes withclassName\nis more efficient. Read more aboutclassName\nandstyle\n.\nThese standard DOM props are also supported for all built-in components:\naccessKey\n: A string. Specifies a keyboard shortcut for the element. Not generally recommended.aria-*\n: ARIA attributes let you specify the accessibility tree information for this element. See ARIA attributes for a complete reference. In React, all ARIA attribute names are exactly the same as in HTML.autoCapitalize\n: A string. Specifies whether and how the user input should be capitalized.className\n: A string. Specifies the element\u2019s CSS class name. Read more about applying CSS styles.contentEditable\n: A boolean. Iftrue\n, the browser lets the user edit the rendered element directly. This is used to implement rich text input libraries like Lexical. React warns if you try to pass React children to an element withcontentEditable={true}\nbecause React will not be able to update its content after user edits.data-*\n: Data attributes let you attach some string data to the element, for exampledata-fruit=\"banana\"\n. In React, they are not commonly used because you would usually read data from props or state instead.dir\n: Either'ltr'\nor'rtl'\n. Specifies the text direction of the element.draggable\n: A boolean. Specifies whether the element is draggable. Part of HTML Drag and Drop API.enterKeyHint\n: A string. Specifies which action to present for the enter key on virtual keyboards.htmlFor\n: A string. For<label>\nand<output>\n, lets you associate the label with some control. Same asfor\nHTML attribute. React uses the standard DOM property names (htmlFor\n) instead of HTML attribute names.hidden\n: A boolean or a string. Specifies whether the element should be hidden.id\n: A string. Specifies a unique identifier for this element, which can be used to find it later or connect it with other elements. Generate it withuseId\nto avoid clashes between multiple instances of the same component.is\n: A string. If specified, the component will behave like a custom element.inputMode\n: A string. Specifies what kind of keyboard to display (for example, text, number or telephone).itemProp\n: A string. Specifies which property the element represents for structured data crawlers.lang\n: A string. Specifies the language of the element.onAnimationEnd\n: AnAnimationEvent\nhandler function. Fires when a CSS animation completes.onAnimationEndCapture\n: A version ofonAnimationEnd\nthat fires in the capture phase.onAnimationIteration\n: AnAnimationEvent\nhandler function. Fires when an iteration of a CSS animation ends, and another one begins.onAnimationIterationCapture\n: A version ofonAnimationIteration\nthat fires in the capture phase.onAnimationStart\n: AnAnimationEvent\nhandler function. Fires when a CSS animation starts.onAnimationStartCapture\n:onAnimationStart\n, but fires in the capture phase.onAuxClick\n: AMouseEvent\nhandler function. Fires when a non-primary pointer button was clicked.onAuxClickCapture\n: A version ofonAuxClick\nthat fires in the capture phase.onBeforeInput\n: AnInputEvent\nhandler function. Fires before the value of an editable element is modified. React does not yet use the nativebeforeinput\nevent, and instead attempts to polyfill it using other events.onBeforeInputCapture\n: A version ofonBeforeInput\nthat fires in the capture phase.onBlur\n: AFocusEvent\nhandler function. Fires when an element lost focus. Unlike the built-in browserblur\nevent, in React theonBlur\nevent bubbles.onBlurCapture\n: A version ofonBlur\nthat fires in the capture phase.onClick\n: AMouseEvent\nhandler function. Fires when the primary button was clicked on the pointing device.onClickCapture\n: A version ofonClick\nthat fires in the capture phase.onCompositionStart\n: ACompositionEvent\nhandler function. Fires when an input method editor starts a new composition session.onCompositionStartCapture\n: A version ofonCompositionStart\nthat fires in the capture phase.onCompositionEnd\n: ACompositionEvent\nhandler function. Fires when an input method editor completes or cancels a composition session.onCompositionEndCapture\n: A version ofonCompositionEnd\nthat fires in the capture phase.onCompositionUpdate\n: ACompositionEvent\nhandler function. Fires when an input method editor receives a new character.onCompositionUpdateCapture\n: A version ofonCompositionUpdate\nthat fires in the capture phase.onContextMenu\n: AMouseEvent\nhandler function. Fires when the user tries to open a context menu.onContextMenuCapture\n: A version ofonContextMenu\nthat fires in the capture phase.onCopy\n: AClipboardEvent\nhandler function. Fires when the user tries to copy something into the clipboard.onCopyCapture\n: A version ofonCopy\nthat fires in the capture phase.onCut\n: AClipboardEvent\nhandler function. Fires when the user tries to cut something into the clipboard.onCutCapture\n: A version ofonCut\nthat fires in the capture phase.onDoubleClick\n: AMouseEvent\nhandler function. Fires when the user clicks twice. Corresponds to the browserdblclick\nevent.onDoubleClickCapture\n: A version ofonDoubleClick\nthat fires in the capture phase.onDrag\n: ADragEvent\nhandler function. Fires while the user is dragging something.onDragCapture\n: A version ofonDrag\nthat fires in the capture phase.onDragEnd\n: ADragEvent\nhandler function. Fires when the user stops dragging something.onDragEndCapture\n: A version ofonDragEnd\nthat fires in the capture phase.onDragEnter\n: ADragEvent\nhandler function. Fires when the dragged content enters a valid drop target.onDragEnterCapture\n: A version ofonDragEnter\nthat fires in the capture phase.onDragOver\n: ADragEvent\nhandler function. Fires on a valid drop target while the dragged content is dragged over it. You must calle.preventDefault()\nhere to allow dropping.onDragOverCapture\n: A version ofonDragOver\nthat fires in the capture phase.onDragStart\n: ADragEvent\nhandler function. Fires when the user starts dragging an element.onDragStartCapture\n: A version ofonDragStart\nthat fires in the capture phase.onDrop\n: ADragEvent\nhandler function. Fires when something is dropped on a valid drop target.onDropCapture\n: A version ofonDrop\nthat fires in the capture phase.onFocus\n: AFocusEvent\nhandler function. Fires when an element receives focus. Unlike the built-in browserfocus\nevent, in React theonFocus\nevent bubbles.onFocusCapture\n: A version ofonFocus\nthat fires in the capture phase.onGotPointerCapture\n: APointerEvent\nhandler function. Fires when an element programmatically captures a pointer.onGotPointerCaptureCapture\n: A version ofonGotPointerCapture\nthat fires in the capture phase.onKeyDown\n: AKeyboardEvent\nhandler function. Fires when a key is pressed.onKeyDownCapture\n: A version ofonKeyDown\nthat fires in the capture phase.onKeyPress\n: AKeyboardEvent\nhandler function. Deprecated. UseonKeyDown\noronBeforeInput\ninstead.onKeyPressCapture\n: A version ofonKeyPress\nthat fires in the capture phase.onKeyUp\n: AKeyboardEvent\nhandler function. Fires when a key is released.onKeyUpCapture\n: A version ofonKeyUp\nthat fires in the capture phase.onLostPointerCapture\n: APointerEvent\nhandler function. Fires when an element stops capturing a pointer.onLostPointerCaptureCapture\n: A version ofonLostPointerCapture\nthat fires in the capture phase.onMouseDown\n: AMouseEvent\nhandler function. Fires when the pointer is pressed down.onMouseDownCapture\n: A version ofonMouseDown\nthat fires in the capture phase.onMouseEnter\n: AMouseEvent\nhandler function. Fires when the pointer moves inside an element. Does not have a capture phase. Instead,onMouseLeave\nandonMouseEnter\npropagate from the element being left to the one being entered.onMouseLeave\n: AMouseEvent\nhandler function. Fires when the pointer moves outside an element. Does not have a capture phase. Instead,onMouseLeave\nandonMouseEnter\npropagate from the element being left to the one being entered.onMouseMove\n: AMouseEvent\nhandler function. Fires when the pointer changes coordinates.onMouseMoveCapture\n: A version ofonMouseMove\nthat fires in the capture phase.onMouseOut\n: AMouseEvent\nhandler function. Fires when the pointer moves outside an element, or if it moves into a child element.onMouseOutCapture\n: A version ofonMouseOut\nthat fires in the capture phase.onMouseUp\n: AMouseEvent\nhandler function. Fires when the pointer is released.onMouseUpCapture\n: A version ofonMouseUp\nthat fires in the capture phase.onPointerCancel\n: APointerEvent\nhandler function. Fires when the browser cancels a pointer interaction.onPointerCancelCapture\n: A version ofonPointerCancel\nthat fires in the capture phase.onPointerDown\n: APointerEvent\nhandler function. Fires when a pointer becomes active.onPointerDownCapture\n: A version ofonPointerDown\nthat fires in the capture phase.onPointerEnter\n: APointerEvent\nhandler function. Fires when a pointer moves inside an element. Does not have a capture phase. Instead,onPointerLeave\nandonPointerEnter\npropagate from the element being left to the one being entered.onPointerLeave\n: APointerEvent\nhandler function. Fires when a pointer moves outside an element. Does not have a capture phase. Instead,onPointerLeave\nandonPointerEnter\npropagate from the element being left to the one being entered.onPointerMove\n: APointerEvent\nhandler function. Fires when a pointer changes coordinates.onPointerMoveCapture\n: A version ofonPointerMove\nthat fires in the capture phase.onPointerOut\n: APointerEvent\nhandler function. Fires when a pointer moves outside an element, if the pointer interaction is cancelled, and a few other reasons.onPointerOutCapture\n: A version ofonPointerOut\nthat fires in the capture phase.onPointerUp\n: APointerEvent\nhandler function. Fires when a pointer is no longer active.onPointerUpCapture\n: A version ofonPointerUp\nthat fires in the capture phase.onPaste\n: AClipboardEvent\nhandler function. Fires when the user tries to paste something from the clipboard.onPasteCapture\n: A version ofonPaste\nthat fires in the capture phase.onScroll\n: AnEvent\nhandler function. Fires when an element has been scrolled. This event does not bubble.onScrollCapture\n: A version ofonScroll\nthat fires in the capture phase.onSelect\n: AnEvent\nhandler function. Fires after the selection inside an editable element like an input changes. React extends theonSelect\nevent to work forcontentEditable={true}\nelements as well. In addition, React extends it to fire for empty selection and on edits (which may affect the selection).onSelectCapture\n: A version ofonSelect\nthat fires in the capture phase.onTouchCancel\n: ATouchEvent\nhandler function. Fires when the browser cancels a touch interaction.onTouchCancelCapture\n: A version ofonTouchCancel\nthat fires in the capture phase.onTouchEnd\n: ATouchEvent\nhandler function. Fires when one or more touch points are removed.onTouchEndCapture\n: A version ofonTouchEnd\nthat fires in the capture phase.onTouchMove\n: ATouchEvent\nhandler function. Fires one or more touch points are moved.onTouchMoveCapture\n: A version ofonTouchMove\nthat fires in the capture phase.onTouchStart\n: ATouchEvent\nhandler function. Fires when one or more touch points are placed.onTouchStartCapture\n: A version ofonTouchStart\nthat fires in the capture phase.onTransitionEnd\n: ATransitionEvent\nhandler function. Fires when a CSS transition completes.onTransitionEndCapture\n: A version ofonTransitionEnd\nthat fires in the capture phase.onWheel\n: AWheelEvent\nhandler function. Fires when the user rotates a wheel button.onWheelCapture\n: A version ofonWheel\nthat fires in the capture phase.role\n: A string. Specifies the element role explicitly for assistive technologies.slot\n: A string. Specifies the slot name when using shadow DOM. In React, an equivalent pattern is typically achieved by passing JSX as props, for example<Layout left={<Sidebar />} right={<Content />} />\n.spellCheck\n: A boolean or null. If explicitly set totrue\norfalse\n, enables or disables spellchecking.tabIndex\n: A number. Overrides the default Tab button behavior. Avoid using values other than-1\nand0\n.title\n: A string. Specifies the tooltip text for the element.translate\n: Either'yes'\nor'no'\n. Passing'no'\nexcludes the element content from being translated.\nYou can also pass custom attributes as props, for example mycustomprop=\"someValue\"\n. This can be useful when integrating with third-party libraries. The custom attribute name must be lowercase and must not start with on\n. The value will be converted to a string. If you pass null\nor undefined\n, the custom attribute will be removed.\nThese events fire only for the <form>\nelements:\nonReset\n: AnEvent\nhandler function. Fires when a form gets reset.onResetCapture\n: A version ofonReset\nthat fires in the capture phase.onSubmit\n: AnEvent\nhandler function. Fires when a form gets submitted.onSubmitCapture\n: A version ofonSubmit\nthat fires in the capture phase.\nThese events fire only for the <dialog>\nelements. Unlike browser events, they bubble in React:\nonCancel\n: AnEvent\nhandler function. Fires when the user tries to dismiss the dialog.onCancelCapture\n: A version ofonCancel\nthat fires in the capture phase.onClose\n: AnEvent\nhandler function. Fires when a dialog has been closed.onCloseCapture\n: A version ofonClose\nthat fires in the capture phase.\nThese events fire only for the <details>\nelements. Unlike browser events, they bubble in React:\nonToggle\n: AnEvent\nhandler function. Fires when the user toggles the details.onToggleCapture\n: A version ofonToggle\nthat fires in the capture phase.\nThese events fire for <img>\n, <iframe>\n, <object>\n, <embed>\n, <link>\n, and SVG <image>\nelements. Unlike browser events, they bubble in React:\nonLoad\n: AnEvent\nhandler function. Fires when the resource has loaded.onLoadCapture\n: A version ofonLoad\nthat fires in the capture phase.onError\n: AnEvent\nhandler function. Fires when the resource could not be loaded.onErrorCapture\n: A version ofonError\nthat fires in the capture phase.\nThese events fire for resources like <audio>\nand <video>\n. Unlike browser events, they bubble in React:\nonAbort\n: AnEvent\nhandler function. Fires when the resource has not fully loaded, but not due to an error.onAbortCapture\n: A version ofonAbort\nthat fires in the capture phase.onCanPlay\n: AnEvent\nhandler function. Fires when there\u2019s enough data to start playing, but not enough to play to the end without buffering.onCanPlayCapture\n: A version ofonCanPlay\nthat fires in the capture phase.onCanPlayThrough\n: AnEvent\nhandler function. Fires when there\u2019s enough data that it\u2019s likely possible to start playing without buffering until the end.onCanPlayThroughCapture\n: A version ofonCanPlayThrough\nthat fires in the capture phase.onDurationChange\n: AnEvent\nhandler function. Fires when the media duration has updated.onDurationChangeCapture\n: A version ofonDurationChange\nthat fires in the capture phase.onEmptied\n: AnEvent\nhandler function. Fires when the media has become empty.onEmptiedCapture\n: A version ofonEmptied\nthat fires in the capture phase.onEncrypted\n: AnEvent\nhandler function. Fires when the browser encounters encrypted media.onEncryptedCapture\n: A version ofonEncrypted\nthat fires in the capture phase.onEnded\n: AnEvent\nhandler function. Fires when the playback stops because there\u2019s nothing left to play.onEndedCapture\n: A version ofonEnded\nthat fires in the capture phase.onError\n: AnEvent\nhandler function. Fires when the resource could not be loaded.onErrorCapture\n: A version ofonError\nthat fires in the capture phase.onLoadedData\n: AnEvent\nhandler function. Fires when the current playback frame has loaded.onLoadedDataCapture\n: A version ofonLoadedData\nthat fires in the capture phase.onLoadedMetadata\n: AnEvent\nhandler function. Fires when metadata has loaded.onLoadedMetadataCapture\n: A version ofonLoadedMetadata\nthat fires in the capture phase.onLoadStart\n: AnEvent\nhandler function. Fires when the browser started loading the resource.onLoadStartCapture\n: A version ofonLoadStart\nthat fires in the capture phase.onPause\n: AnEvent\nhandler function. Fires when the media was paused.onPauseCapture\n: A version ofonPause\nthat fires in the capture phase.onPlay\n: AnEvent\nhandler function. Fires when the media is no longer paused.onPlayCapture\n: A version ofonPlay\nthat fires in the capture phase.onPlaying\n: AnEvent\nhandler function. Fires when the media starts or restarts playing.onPlayingCapture\n: A version ofonPlaying\nthat fires in the capture phase.onProgress\n: AnEvent\nhandler function. Fires periodically while the resource is loading.onProgressCapture\n: A version ofonProgress\nthat fires in the capture phase.onRateChange\n: AnEvent\nhandler function. Fires when playback rate changes.onRateChangeCapture\n: A version ofonRateChange\nthat fires in the capture phase.onResize\n: AnEvent\nhandler function. Fires when video changes size.onResizeCapture\n: A version ofonResize\nthat fires in the capture phase.onSeeked\n: AnEvent\nhandler function. Fires when a seek operation completes.onSeekedCapture\n: A version ofonSeeked\nthat fires in the capture phase.onSeeking\n: AnEvent\nhandler function. Fires when a seek operation starts.onSeekingCapture\n: A version ofonSeeking\nthat fires in the capture phase.onStalled\n: AnEvent\nhandler function. Fires when the browser is waiting for data but it keeps not loading.onStalledCapture\n: A version ofonStalled\nthat fires in the capture phase.onSuspend\n: AnEvent\nhandler function. Fires when loading the resource was suspended.onSuspendCapture\n: A version ofonSuspend\nthat fires in the capture phase.onTimeUpdate\n: AnEvent\nhandler function. Fires when the current playback time updates.onTimeUpdateCapture\n: A version ofonTimeUpdate\nthat fires in the capture phase.onVolumeChange\n: AnEvent\nhandler function. Fires when the volume has changed.onVolumeChangeCapture\n: A version ofonVolumeChange\nthat fires in the capture phase.onWaiting\n: AnEvent\nhandler function. Fires when the playback stopped due to temporary lack of data.onWaitingCapture\n: A version ofonWaiting\nthat fires in the capture phase.\nCaveats\n- You cannot pass both\nchildren\nanddangerouslySetInnerHTML\nat the same time. - Some events (like\nonAbort\nandonLoad\n) don\u2019t bubble in the browser, but bubble in React.\nref\ncallback function\nInstead of a ref object (like the one returned by useRef\n), you may pass a function to the ref\nattribute.\n<div ref={(node) => {\nconsole.log('Attached', node);\nreturn () => {\nconsole.log('Clean up', node)\n}\n}}>\nSee an example of using the ref\ncallback.\nWhen the <div>\nDOM node is added to the screen, React will call your ref\ncallback with the DOM node\nas the argument. When that <div>\nDOM node is removed, React will call your the cleanup function returned from the callback.\nReact will also call your ref\ncallback whenever you pass a different ref\ncallback. In the above example, (node) => { ... }\nis a different function on every render. When your component re-renders, the previous function will be called with null\nas the argument, and the next function will be called with the DOM node.\nParameters\nnode\n: A DOM node. React will pass you the DOM node when the ref gets attached. Unless you pass the same function reference for theref\ncallback on every render, the callback will get temporarily cleanup and re-create during every re-render of the component.\nReturns\n- optional\ncleanup function\n: When theref\nis detached, React will call the cleanup function. If a function is not returned by theref\ncallback, React will call the callback again withnull\nas the argument when theref\ngets detached. This behavior will be removed in a future version.\nCaveats\n- When Strict Mode is on, React will run one extra development-only setup+cleanup cycle before the first real setup. This is a stress-test that ensures that your cleanup logic \u201cmirrors\u201d your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function.\n- When you pass a different\nref\ncallback, React will call the previous callback\u2019s cleanup function if provided. If no cleanup function is defined, theref\ncallback will be called withnull\nas the argument. The next function will be called with the DOM node.\nReact event object\nYour event handlers will receive a React event object. It is also sometimes known as a \u201csynthetic event\u201d.\n<button onClick={e => {\nconsole.log(e); // React event object\n}} />\nIt conforms to the same standard as the underlying DOM events, but fixes some browser inconsistencies.\nSome React events do not map directly to the browser\u2019s native events. For example in onMouseLeave\n, e.nativeEvent\nwill point to a mouseout\nevent. The specific mapping is not part of the public API and may change in the future. If you need the underlying browser event for some reason, read it from e.nativeEvent\n.\nProperties\nReact event objects implement some of the standard Event\nproperties:\nbubbles\n: A boolean. Returns whether the event bubbles through the DOM.cancelable\n: A boolean. Returns whether the event can be canceled.currentTarget\n: A DOM node. Returns the node to which the current handler is attached in the React tree.defaultPrevented\n: A boolean. Returns whetherpreventDefault\nwas called.eventPhase\n: A number. Returns which phase the event is currently in.isTrusted\n: A boolean. Returns whether the event was initiated by user.target\n: A DOM node. Returns the node on which the event has occurred (which could be a distant child).timeStamp\n: A number. Returns the time when the event occurred.\nAdditionally, React event objects provide these properties:\nnativeEvent\n: A DOMEvent\n. The original browser event object.\nMethods\nReact event objects implement some of the standard Event\nmethods:\npreventDefault()\n: Prevents the default browser action for the event.stopPropagation()\n: Stops the event propagation through the React tree.\nAdditionally, React event objects provide these methods:\nisDefaultPrevented()\n: Returns a boolean value indicating whetherpreventDefault\nwas called.isPropagationStopped()\n: Returns a boolean value indicating whetherstopPropagation\nwas called.persist()\n: Not used with React DOM. With React Native, call this to read event\u2019s properties after the event.isPersistent()\n: Not used with React DOM. With React Native, returns whetherpersist\nhas been called.\nCaveats\n- The values of\ncurrentTarget\n,eventPhase\n,target\n, andtype\nreflect the values your React code expects. Under the hood, React attaches event handlers at the root, but this is not reflected in React event objects. For example,e.currentTarget\nmay not be the same as the underlyinge.nativeEvent.currentTarget\n. For polyfilled events,e.type\n(React event type) may differ frome.nativeEvent.type\n(underlying type).\nAnimationEvent\nhandler function\nAn event handler type for the CSS animation events.\n<div\nonAnimationStart={e => console.log('onAnimationStart')}\nonAnimationIteration={e => console.log('onAnimationIteration')}\nonAnimationEnd={e => console.log('onAnimationEnd')}\n/>\nParameters\ne\n: A React event object with these extraAnimationEvent\nproperties:\nClipboardEvent\nhandler function\nAn event handler type for the Clipboard API events.\n<input\nonCopy={e => console.log('onCopy')}\nonCut={e => console.log('onCut')}\nonPaste={e => console.log('onPaste')}\n/>\nParameters\n-\ne\n: A React event object with these extraClipboardEvent\nproperties:\nCompositionEvent\nhandler function\nAn event handler type for the input method editor (IME) events.\n<input\nonCompositionStart={e => console.log('onCompositionStart')}\nonCompositionUpdate={e => console.log('onCompositionUpdate')}\nonCompositionEnd={e => console.log('onCompositionEnd')}\n/>\nParameters\ne\n: A React event object with these extraCompositionEvent\nproperties:\nDragEvent\nhandler function\nAn event handler type for the HTML Drag and Drop API events.\n<>\n<div\ndraggable={true}\nonDragStart={e => console.log('onDragStart')}\nonDragEnd={e => console.log('onDragEnd')}\n>\nDrag source\n</div>\n<div\nonDragEnter={e => console.log('onDragEnter')}\nonDragLeave={e => console.log('onDragLeave')}\nonDragOver={e => { e.preventDefault(); console.log('onDragOver'); }}\nonDrop={e => console.log('onDrop')}\n>\nDrop target\n</div>\n</>\nParameters\n-\ne\n: A React event object with these extraDragEvent\nproperties:It also includes the inherited\nMouseEvent\nproperties:altKey\nbutton\nbuttons\nctrlKey\nclientX\nclientY\ngetModifierState(key)\nmetaKey\nmovementX\nmovementY\npageX\npageY\nrelatedTarget\nscreenX\nscreenY\nshiftKey\nIt also includes the inherited\nUIEvent\nproperties:\nFocusEvent\nhandler function\nAn event handler type for the focus events.\n<input\nonFocus={e => console.log('onFocus')}\nonBlur={e => console.log('onBlur')}\n/>\nParameters\n-\ne\n: A React event object with these extraFocusEvent\nproperties:It also includes the inherited\nUIEvent\nproperties:\nEvent\nhandler function\nAn event handler type for generic events.\nParameters\ne\n: A React event object with no additional properties.\nInputEvent\nhandler function\nAn event handler type for the onBeforeInput\nevent.\n<input onBeforeInput={e => console.log('onBeforeInput')} />\nParameters\ne\n: A React event object with these extraInputEvent\nproperties:\nKeyboardEvent\nhandler function\nAn event handler type for keyboard events.\n<input\nonKeyDown={e => console.log('onKeyDown')}\nonKeyUp={e => console.log('onKeyUp')}\n/>\nParameters\n-\ne\n: A React event object with these extraKeyboardEvent\nproperties:altKey\ncharCode\ncode\nctrlKey\ngetModifierState(key)\nkey\nkeyCode\nlocale\nmetaKey\nlocation\nrepeat\nshiftKey\nwhich\nIt also includes the inherited\nUIEvent\nproperties:\nMouseEvent\nhandler function\nAn event handler type for mouse events.\n<div\nonClick={e => console.log('onClick')}\nonMouseEnter={e => console.log('onMouseEnter')}\nonMouseOver={e => console.log('onMouseOver')}\nonMouseDown={e => console.log('onMouseDown')}\nonMouseUp={e => console.log('onMouseUp')}\nonMouseLeave={e => console.log('onMouseLeave')}\n/>\nParameters\n-\ne\n: A React event object with these extraMouseEvent\nproperties:altKey\nbutton\nbuttons\nctrlKey\nclientX\nclientY\ngetModifierState(key)\nmetaKey\nmovementX\nmovementY\npageX\npageY\nrelatedTarget\nscreenX\nscreenY\nshiftKey\nIt also includes the inherited\nUIEvent\nproperties:\nPointerEvent\nhandler function\nAn event handler type for pointer events.\n<div\nonPointerEnter={e => console.log('onPointerEnter')}\nonPointerMove={e => console.log('onPointerMove')}\nonPointerDown={e => console.log('onPointerDown')}\nonPointerUp={e => console.log('onPointerUp')}\nonPointerLeave={e => console.log('onPointerLeave')}\n/>\nParameters\n-\ne\n: A React event object with these extraPointerEvent\nproperties:It also includes the inherited\nMouseEvent\nproperties:altKey\nbutton\nbuttons\nctrlKey\nclientX\nclientY\ngetModifierState(key)\nmetaKey\nmovementX\nmovementY\npageX\npageY\nrelatedTarget\nscreenX\nscreenY\nshiftKey\nIt also includes the inherited\nUIEvent\nproperties:\nTouchEvent\nhandler function\nAn event handler type for touch events.\n<div\nonTouchStart={e => console.log('onTouchStart')}\nonTouchMove={e => console.log('onTouchMove')}\nonTouchEnd={e => console.log('onTouchEnd')}\nonTouchCancel={e => console.log('onTouchCancel')}\n/>\nParameters\n-\ne\n: A React event object with these extraTouchEvent\nproperties:It also includes the inherited\nUIEvent\nproperties:\nTransitionEvent\nhandler function\nAn event handler type for the CSS transition events.\n<div\nonTransitionEnd={e => console.log('onTransitionEnd')}\n/>\nParameters\ne\n: A React event object with these extraTransitionEvent\nproperties:\nUIEvent\nhandler function\nAn event handler type for generic UI events.\n<div\nonScroll={e => console.log('onScroll')}\n/>\nParameters\ne\n: A React event object with these extraUIEvent\nproperties:\nWheelEvent\nhandler function\nAn event handler type for the onWheel\nevent.\n<div\nonWheel={e => console.log('onWheel')}\n/>\nParameters\n-\ne\n: A React event object with these extraWheelEvent\nproperties:It also includes the inherited\nMouseEvent\nproperties:altKey\nbutton\nbuttons\nctrlKey\nclientX\nclientY\ngetModifierState(key)\nmetaKey\nmovementX\nmovementY\npageX\npageY\nrelatedTarget\nscreenX\nscreenY\nshiftKey\nIt also includes the inherited\nUIEvent\nproperties:\nUsage\nApplying CSS styles\nIn React, you specify a CSS class with className\n. It works like the class\nattribute in HTML:\n<img className=\"avatar\" />\nThen you write the CSS rules for it in a separate CSS file:\n/* In your CSS */\n.avatar {\nborder-radius: 50%;\n}\nReact does not prescribe how you add CSS files. In the simplest case, you\u2019ll add a <link>\ntag to your HTML. If you use a build tool or a framework, consult its documentation to learn how to add a CSS file to your project.\nSometimes, the style values depend on data. Use the style\nattribute to pass some styles dynamically:\n<img\nclassName=\"avatar\"\nstyle={{\nwidth: user.imageSize,\nheight: user.imageSize\n}}\n/>\nIn the above example, style={{}}\nis not a special syntax, but a regular {}\nobject inside the style={ }\nJSX curly braces. We recommend only using the style\nattribute when your styles depend on JavaScript variables.\nexport default function Avatar({ user }) { return ( <img src={user.imageUrl} alt={'Photo of ' + user.name} className=\"avatar\" style={{ width: user.imageSize, height: user.imageSize }} /> ); }\nDeep Dive\nTo apply CSS classes conditionally, you need to produce the className\nstring yourself using JavaScript.\nFor example, className={'row ' + (isSelected ? 'selected': '')}\nwill produce either className=\"row\"\nor className=\"row selected\"\ndepending on whether isSelected\nis true\n.\nTo make this more readable, you can use a tiny helper library like classnames\n:\nimport cn from 'classnames';\nfunction Row({ isSelected }) {\nreturn (\n<div className={cn('row', isSelected && 'selected')}>\n...\n</div>\n);\n}\nIt is especially convenient if you have multiple conditional classes:\nimport cn from 'classnames';\nfunction Row({ isSelected, size }) {\nreturn (\n<div className={cn('row', {\nselected: isSelected,\nlarge: size === 'large',\nsmall: size === 'small',\n})}>\n...\n</div>\n);\n}\nManipulating a DOM node with a ref\nSometimes, you\u2019ll need to get the browser DOM node associated with a tag in JSX. For example, if you want to focus an <input>\nwhen a button is clicked, you need to call focus()\non the browser <input>\nDOM node.\nTo obtain the browser DOM node for a tag, declare a ref and pass it as the ref\nattribute to that tag:\nimport { useRef } from 'react';\nexport default function Form() {\nconst inputRef = useRef(null);\n// ...\nreturn (\n<input ref={inputRef} />\n// ...\nReact will put the DOM node into inputRef.current\nafter it\u2019s been rendered to the screen.\nimport { useRef } from 'react'; export default function Form() { const inputRef = useRef(null); function handleClick() { inputRef.current.focus(); } return ( <> <input ref={inputRef} /> <button onClick={handleClick}> Focus the input </button> </> ); }\nRead more about manipulating DOM with refs and check out more examples.\nFor more advanced use cases, the ref\nattribute also accepts a callback function.\nDangerously setting the inner HTML\nYou can pass a raw HTML string to an element like so:\nconst markup = { __html: '<p>some raw html</p>' };\nreturn <div dangerouslySetInnerHTML={markup} />;\nThis is dangerous. As with the underlying DOM innerHTML\nproperty, you must exercise extreme caution! Unless the markup is coming from a completely trusted source, it is trivial to introduce an XSS vulnerability this way.\nFor example, if you use a Markdown library that converts Markdown to HTML, you trust that its parser doesn\u2019t contain bugs, and the user only sees their own input, you can display the resulting HTML like this:\nimport { Remarkable } from 'remarkable'; const md = new Remarkable(); function renderMarkdownToHTML(markdown) { // This is ONLY safe because the output HTML // is shown to the same user, and because you // trust this Markdown parser to not have bugs. const renderedHTML = md.render(markdown); return {__html: renderedHTML}; } export default function MarkdownPreview({ markdown }) { const markup = renderMarkdownToHTML(markdown); return <div dangerouslySetInnerHTML={markup} />; }\nThe {__html}\nobject should be created as close to where the HTML is generated as possible, like the above example does in the renderMarkdownToHTML\nfunction. This ensures that all raw HTML being used in your code is explicitly marked as such, and that only variables that you expect to contain HTML are passed to dangerouslySetInnerHTML\n. It is not recommended to create the object inline like <div dangerouslySetInnerHTML={{__html: markup}} />\n.\nTo see why rendering arbitrary HTML is dangerous, replace the code above with this:\nconst post = {\n// Imagine this content is stored in the database.\ncontent: `<img src=\"\" onerror='alert(\"you were hacked\")'>`\n};\nexport default function MarkdownPreview() {\n// \ud83d\udd34 SECURITY HOLE: passing untrusted input to dangerouslySetInnerHTML\nconst markup = { __html: post.content };\nreturn <div dangerouslySetInnerHTML={markup} />;\n}\nThe code embedded in the HTML will run. A hacker could use this security hole to steal user information or to perform actions on their behalf. Only use dangerouslySetInnerHTML\nwith trusted and sanitized data.\nHandling mouse events\nThis example shows some common mouse events and when they fire.\nexport default function MouseExample() { return ( <div onMouseEnter={e => console.log('onMouseEnter (parent)')} onMouseLeave={e => console.log('onMouseLeave (parent)')} > <button onClick={e => console.log('onClick (first button)')} onMouseDown={e => console.log('onMouseDown (first button)')} onMouseEnter={e => console.log('onMouseEnter (first button)')} onMouseLeave={e => console.log('onMouseLeave (first button)')} onMouseOver={e => console.log('onMouseOver (first button)')} onMouseUp={e => console.log('onMouseUp (first button)')} > First button </button> <button onClick={e => console.log('onClick (second button)')} onMouseDown={e => console.log('onMouseDown (second button)')} onMouseEnter={e => console.log('onMouseEnter (second button)')} onMouseLeave={e => console.log('onMouseLeave (second button)')} onMouseOver={e => console.log('onMouseOver (second button)')} onMouseUp={e => console.log('onMouseUp (second button)')} > Second button </button> </div> ); }\nexport default function PointerExample() { return ( <div onPointerEnter={e => console.log('onPointerEnter (parent)')} onPointerLeave={e => console.log('onPointerLeave (parent)')} style={{ padding: 20, backgroundColor: '#ddd' }} > <div onPointerDown={e => console.log('onPointerDown (first child)')} onPointerEnter={e => console.log('onPointerEnter (first child)')} onPointerLeave={e => console.log('onPointerLeave (first child)')} onPointerMove={e => console.log('onPointerMove (first child)')} onPointerUp={e => console.log('onPointerUp (first child)')} style={{ padding: 20, backgroundColor: 'lightyellow' }} > First child </div> <div onPointerDown={e => console.log('onPointerDown (second child)')} onPointerEnter={e => console.log('onPointerEnter (second child)')} onPointerLeave={e => console.log('onPointerLeave (second child)')} onPointerMove={e => console.log('onPointerMove (second child)')} onPointerUp={e => console.log('onPointerUp (second child)')} style={{ padding: 20, backgroundColor: 'lightblue' }} > Second child </div> </div> ); }\nHandling focus events\nIn React, focus events bubble. You can use the currentTarget\nand relatedTarget\nto differentiate if the focusing or blurring events originated from outside of the parent element. The example shows how to detect focusing a child, focusing the parent element, and how to detect focus entering or leaving the whole subtree.\nexport default function FocusExample() { return ( <div tabIndex={1} onFocus={(e) => { if (e.currentTarget === e.target) { console.log('focused parent'); } else { console.log('focused child', e.target.name); } if (!e.currentTarget.contains(e.relatedTarget)) { // Not triggered when swapping focus between children console.log('focus entered parent'); } }} onBlur={(e) => { if (e.currentTarget === e.target) { console.log('unfocused parent'); } else { console.log('unfocused child', e.target.name); } if (!e.currentTarget.contains(e.relatedTarget)) { // Not triggered when swapping focus between children console.log('focus left parent'); } }} > <label> First name: <input name=\"firstName\" /> </label> <label> Last name: <input name=\"lastName\" /> </label> </div> ); }\nexport default function KeyboardExample() { return ( <label> First name: <input name=\"firstName\" onKeyDown={e => console.log('onKeyDown:', e.key, e.code)} onKeyUp={e => console.log('onKeyUp:', e.key, e.code)} /> </label> ); }"
  },
  {
    "source": "https://react.dev/reference/react-dom/components/form",
    "title": "<form> \u2013 React",
    "text": "<form>\nThe built-in browser <form>\ncomponent lets you create interactive controls for submitting information.\n<form action={search}>\n<input name=\"query\" />\n<button type=\"submit\">Search</button>\n</form>\nReference\n<form>\nTo create interactive controls for submitting information, render the built-in browser <form>\ncomponent.\n<form action={search}>\n<input name=\"query\" />\n<button type=\"submit\">Search</button>\n</form>\nProps\n<form>\nsupports all common element props.\naction\n: a URL or function. When a URL is passed to action\nthe form will behave like the HTML form component. When a function is passed to action\nthe function will handle the form submission. The function passed to action\nmay be async and will be called with a single argument containing the form data of the submitted form. The action\nprop can be overridden by a formAction\nattribute on a <button>\n, <input type=\"submit\">\n, or <input type=\"image\">\ncomponent.\nCaveats\n- When a function is passed to\naction\norformAction\nthe HTTP method will be POST regardless of value of themethod\nprop.\nUsage\nHandle form submission on the client\nPass a function to the action\nprop of form to run the function when the form is submitted. formData\nwill be passed to the function as an argument so you can access the data submitted by the form. This differs from the conventional HTML action, which only accepts URLs. After the action\nfunction succeeds, all uncontrolled field elements in the form are reset.\nexport default function Search() { function search(formData) { const query = formData.get(\"query\"); alert(`You searched for '${query}'`); } return ( <form action={search}> <input name=\"query\" /> <button type=\"submit\">Search</button> </form> ); }\nHandle form submission with a Server Function\nRender a <form>\nwith an input and submit button. Pass a Server Function (a function marked with 'use server'\n) to the action\nprop of form to run the function when the form is submitted.\nPassing a Server Function to <form action>\nallow users to submit forms without JavaScript enabled or before the code has loaded. This is beneficial to users who have a slow connection, device, or have JavaScript disabled and is similar to the way forms work when a URL is passed to the action\nprop.\nYou can use hidden form fields to provide data to the <form>\n\u2019s action. The Server Function will be called with the hidden form field data as an instance of FormData\n.\nimport { updateCart } from './lib.js';\nfunction AddToCart({productId}) {\nasync function addToCart(formData) {\n'use server'\nconst productId = formData.get('productId')\nawait updateCart(productId)\n}\nreturn (\n<form action={addToCart}>\n<input type=\"hidden\" name=\"productId\" value={productId} />\n<button type=\"submit\">Add to Cart</button>\n</form>\n);\n}\nIn lieu of using hidden form fields to provide data to the <form>\n\u2019s action, you can call the bind\nmethod to supply it with extra arguments. This will bind a new argument (productId\n) to the function in addition to the formData\nthat is passed as an argument to the function.\nimport { updateCart } from './lib.js';\nfunction AddToCart({productId}) {\nasync function addToCart(productId, formData) {\n\"use server\";\nawait updateCart(productId)\n}\nconst addProductToCart = addToCart.bind(null, productId);\nreturn (\n<form action={addProductToCart}>\n<button type=\"submit\">Add to Cart</button>\n</form>\n);\n}\nWhen <form>\nis rendered by a Server Component, and a Server Function is passed to the <form>\n\u2019s action\nprop, the form is progressively enhanced.\nDisplay a pending state during form submission\nTo display a pending state when a form is being submitted, you can call the useFormStatus\nHook in a component rendered in a <form>\nand read the pending\nproperty returned.\nHere, we use the pending\nproperty to indicate the form is submitting.\nimport { useFormStatus } from \"react-dom\"; import { submitForm } from \"./actions.js\"; function Submit() { const { pending } = useFormStatus(); return ( <button type=\"submit\" disabled={pending}> {pending ? \"Submitting...\" : \"Submit\"} </button> ); } function Form({ action }) { return ( <form action={action}> <Submit /> </form> ); } export default function App() { return <Form action={submitForm} />; }\nTo learn more about the useFormStatus\nHook see the reference documentation.\nOptimistically updating form data\nThe useOptimistic\nHook provides a way to optimistically update the user interface before a background operation, like a network request, completes. In the context of forms, this technique helps to make apps feel more responsive. When a user submits a form, instead of waiting for the server\u2019s response to reflect the changes, the interface is immediately updated with the expected outcome.\nFor example, when a user types a message into the form and hits the \u201cSend\u201d button, the useOptimistic\nHook allows the message to immediately appear in the list with a \u201cSending\u2026\u201d label, even before the message is actually sent to a server. This \u201coptimistic\u201d approach gives the impression of speed and responsiveness. The form then attempts to truly send the message in the background. Once the server confirms the message has been received, the \u201cSending\u2026\u201d label is removed.\nimport { useOptimistic, useState, useRef } from \"react\"; import { deliverMessage } from \"./actions.js\"; function Thread({ messages, sendMessage }) { const formRef = useRef(); async function formAction(formData) { addOptimisticMessage(formData.get(\"message\")); formRef.current.reset(); await sendMessage(formData); } const [optimisticMessages, addOptimisticMessage] = useOptimistic( messages, (state, newMessage) => [ ...state, { text: newMessage, sending: true } ] ); return ( <> {optimisticMessages.map((message, index) => ( <div key={index}> {message.text} {!!message.sending && <small> (Sending...)</small>} </div> ))} <form action={formAction} ref={formRef}> <input type=\"text\" name=\"message\" placeholder=\"Hello!\" /> <button type=\"submit\">Send</button> </form> </> ); } export default function App() { const [messages, setMessages] = useState([ { text: \"Hello there!\", sending: false, key: 1 } ]); async function sendMessage(formData) { const sentMessage = await deliverMessage(formData.get(\"message\")); setMessages([...messages, { text: sentMessage }]); } return <Thread messages={messages} sendMessage={sendMessage} />; }\nHandling form submission errors\nIn some cases the function called by a <form>\n\u2019s action\nprop throws an error. You can handle these errors by wrapping <form>\nin an Error Boundary. If the function called by a <form>\n\u2019s action\nprop throws an error, the fallback for the error boundary will be displayed.\nimport { ErrorBoundary } from \"react-error-boundary\"; export default function Search() { function search() { throw new Error(\"search error\"); } return ( <ErrorBoundary fallback={<p>There was an error while submitting the form</p>} > <form action={search}> <input name=\"query\" /> <button type=\"submit\">Search</button> </form> </ErrorBoundary> ); }\nDisplay a form submission error without JavaScript\nDisplaying a form submission error message before the JavaScript bundle loads for progressive enhancement requires that:\n<form>\nbe rendered by a Server Component- the function passed to the\n<form>\n\u2019saction\nprop be a Server Function - the\nuseActionState\nHook be used to display the error message\nuseActionState\ntakes two parameters: a Server Function and an initial state. useActionState\nreturns two values, a state variable and an action. The action returned by useActionState\nshould be passed to the action\nprop of the form. The state variable returned by useActionState\ncan be used to display an error message. The value returned by the Server Function passed to useActionState\nwill be used to update the state variable.\nimport { useActionState } from \"react\"; import { signUpNewUser } from \"./api\"; export default function Page() { async function signup(prevState, formData) { \"use server\"; const email = formData.get(\"email\"); try { await signUpNewUser(email); alert(`Added \"${email}\"`); } catch (err) { return err.toString(); } } const [message, signupAction] = useActionState(signup, null); return ( <> <h1>Signup for my newsletter</h1> <p>Signup with the same email twice to see an error</p> <form action={signupAction} id=\"signup-form\"> <label htmlFor=\"email\">Email: </label> <input name=\"email\" id=\"email\" placeholder=\"react@example.com\" /> <button>Sign up</button> {!!message && <p>{message}</p>} </form> </> ); }\nLearn more about updating state from a form action with the useActionState\ndocs\nHandling multiple submission types\nForms can be designed to handle multiple submission actions based on the button pressed by the user. Each button inside a form can be associated with a distinct action or behavior by setting the formAction\nprop.\nWhen a user taps a specific button, the form is submitted, and a corresponding action, defined by that button\u2019s attributes and action, is executed. For instance, a form might submit an article for review by default but have a separate button with formAction\nset to save the article as a draft.\nexport default function Search() { function publish(formData) { const content = formData.get(\"content\"); const button = formData.get(\"button\"); alert(`'${content}' was published with the '${button}' button`); } function save(formData) { const content = formData.get(\"content\"); alert(`Your draft of '${content}' has been saved!`); } return ( <form action={publish}> <textarea name=\"content\" rows={4} cols={40} /> <br /> <button type=\"submit\" name=\"button\" value=\"submit\">Publish</button> <button formAction={save}>Save draft</button> </form> ); }"
  },
  {
    "source": "https://react.dev/reference/react-dom/components/input",
    "title": "<input> \u2013 React",
    "text": "<input>\nThe built-in browser <input>\ncomponent lets you render different kinds of form inputs.\n<input />\nReference\n<input>\nTo display an input, render the built-in browser <input>\ncomponent.\n<input name=\"myInput\" />\nProps\n<input>\nsupports all common element props.\nformAction\n: A string or function. Overrides the parent<form action>\nfortype=\"submit\"\nandtype=\"image\"\n. When a URL is passed toaction\nthe form will behave like a standard HTML form. When a function is passed toformAction\nthe function will handle the form submission. See<form action>\n.\nYou can make an input controlled by passing one of these props:\nchecked\n: A boolean. For a checkbox input or a radio button, controls whether it is selected.value\n: A string. For a text input, controls its text. (For a radio button, specifies its form data.)\nWhen you pass either of them, you must also pass an onChange\nhandler that updates the passed value.\nThese <input>\nprops are only relevant for uncontrolled inputs:\ndefaultChecked\n: A boolean. Specifies the initial value fortype=\"checkbox\"\nandtype=\"radio\"\ninputs.defaultValue\n: A string. Specifies the initial value for a text input.\nThese <input>\nprops are relevant both for uncontrolled and controlled inputs:\naccept\n: A string. Specifies which filetypes are accepted by atype=\"file\"\ninput.alt\n: A string. Specifies the alternative image text for atype=\"image\"\ninput.capture\n: A string. Specifies the media (microphone, video, or camera) captured by atype=\"file\"\ninput.autoComplete\n: A string. Specifies one of the possible autocomplete behaviors.autoFocus\n: A boolean. Iftrue\n, React will focus the element on mount.dirname\n: A string. Specifies the form field name for the element\u2019s directionality.disabled\n: A boolean. Iftrue\n, the input will not be interactive and will appear dimmed.children\n:<input>\ndoes not accept children.form\n: A string. Specifies theid\nof the<form>\nthis input belongs to. If omitted, it\u2019s the closest parent form.formAction\n: A string. Overrides the parent<form action>\nfortype=\"submit\"\nandtype=\"image\"\n.formEnctype\n: A string. Overrides the parent<form enctype>\nfortype=\"submit\"\nandtype=\"image\"\n.formMethod\n: A string. Overrides the parent<form method>\nfortype=\"submit\"\nandtype=\"image\"\n.formNoValidate\n: A string. Overrides the parent<form noValidate>\nfortype=\"submit\"\nandtype=\"image\"\n.formTarget\n: A string. Overrides the parent<form target>\nfortype=\"submit\"\nandtype=\"image\"\n.height\n: A string. Specifies the image height fortype=\"image\"\n.list\n: A string. Specifies theid\nof the<datalist>\nwith the autocomplete options.max\n: A number. Specifies the maximum value of numerical and datetime inputs.maxLength\n: A number. Specifies the maximum length of text and other inputs.min\n: A number. Specifies the minimum value of numerical and datetime inputs.minLength\n: A number. Specifies the minimum length of text and other inputs.multiple\n: A boolean. Specifies whether multiple values are allowed for<type=\"file\"\nandtype=\"email\"\n.name\n: A string. Specifies the name for this input that\u2019s submitted with the form.onChange\n: AnEvent\nhandler function. Required for controlled inputs. Fires immediately when the input\u2019s value is changed by the user (for example, it fires on every keystroke). Behaves like the browserinput\nevent.onChangeCapture\n: A version ofonChange\nthat fires in the capture phase.onInput\n: AnEvent\nhandler function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to useonChange\ninstead which works similarly.onInputCapture\n: A version ofonInput\nthat fires in the capture phase.onInvalid\n: AnEvent\nhandler function. Fires if an input fails validation on form submit. Unlike the built-ininvalid\nevent, the ReactonInvalid\nevent bubbles.onInvalidCapture\n: A version ofonInvalid\nthat fires in the capture phase.onSelect\n: AnEvent\nhandler function. Fires after the selection inside the<input>\nchanges. React extends theonSelect\nevent to also fire for empty selection and on edits (which may affect the selection).onSelectCapture\n: A version ofonSelect\nthat fires in the capture phase.pattern\n: A string. Specifies the pattern that thevalue\nmust match.placeholder\n: A string. Displayed in a dimmed color when the input value is empty.readOnly\n: A boolean. Iftrue\n, the input is not editable by the user.required\n: A boolean. Iftrue\n, the value must be provided for the form to submit.size\n: A number. Similar to setting width, but the unit depends on the control.src\n: A string. Specifies the image source for atype=\"image\"\ninput.step\n: A positive number or an'any'\nstring. Specifies the distance between valid values.type\n: A string. One of the input types.width\n: A string. Specifies the image width for atype=\"image\"\ninput.\nCaveats\n- Checkboxes need\nchecked\n(ordefaultChecked\n), notvalue\n(ordefaultValue\n). - If a text input receives a string\nvalue\nprop, it will be treated as controlled. - If a checkbox or a radio button receives a boolean\nchecked\nprop, it will be treated as controlled. - An input can\u2019t be both controlled and uncontrolled at the same time.\n- An input cannot switch between being controlled or uncontrolled over its lifetime.\n- Every controlled input needs an\nonChange\nevent handler that synchronously updates its backing value.\nUsage\nDisplaying inputs of different types\nTo display an input, render an <input>\ncomponent. By default, it will be a text input. You can pass type=\"checkbox\"\nfor a checkbox, type=\"radio\"\nfor a radio button, or one of the other input types.\nexport default function MyForm() { return ( <> <label> Text input: <input name=\"myInput\" /> </label> <hr /> <label> Checkbox: <input type=\"checkbox\" name=\"myCheckbox\" /> </label> <hr /> <p> Radio buttons: <label> <input type=\"radio\" name=\"myRadio\" value=\"option1\" /> Option 1 </label> <label> <input type=\"radio\" name=\"myRadio\" value=\"option2\" /> Option 2 </label> <label> <input type=\"radio\" name=\"myRadio\" value=\"option3\" /> Option 3 </label> </p> </> ); }\nProviding a label for an input\nTypically, you will place every <input>\ninside a <label>\ntag. This tells the browser that this label is associated with that input. When the user clicks the label, the browser will automatically focus the input. It\u2019s also essential for accessibility: a screen reader will announce the label caption when the user focuses the associated input.\nIf you can\u2019t nest <input>\ninto a <label>\n, associate them by passing the same ID to <input id>\nand <label htmlFor>\n. To avoid conflicts between multiple instances of one component, generate such an ID with useId\n.\nimport { useId } from 'react'; export default function Form() { const ageInputId = useId(); return ( <> <label> Your first name: <input name=\"firstName\" /> </label> <hr /> <label htmlFor={ageInputId}>Your age:</label> <input id={ageInputId} name=\"age\" type=\"number\" /> </> ); }\nProviding an initial value for an input\nYou can optionally specify the initial value for any input. Pass it as the defaultValue\nstring for text inputs. Checkboxes and radio buttons should specify the initial value with the defaultChecked\nboolean instead.\nexport default function MyForm() { return ( <> <label> Text input: <input name=\"myInput\" defaultValue=\"Some initial value\" /> </label> <hr /> <label> Checkbox: <input type=\"checkbox\" name=\"myCheckbox\" defaultChecked={true} /> </label> <hr /> <p> Radio buttons: <label> <input type=\"radio\" name=\"myRadio\" value=\"option1\" /> Option 1 </label> <label> <input type=\"radio\" name=\"myRadio\" value=\"option2\" defaultChecked={true} /> Option 2 </label> <label> <input type=\"radio\" name=\"myRadio\" value=\"option3\" /> Option 3 </label> </p> </> ); }\nReading the input values when submitting a form\nAdd a <form>\naround your inputs with a <button type=\"submit\">\ninside. It will call your <form onSubmit>\nevent handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling e.preventDefault()\n. Read the form data with new FormData(e.target)\n.\nexport default function MyForm() { function handleSubmit(e) { // Prevent the browser from reloading the page e.preventDefault(); // Read the form data const form = e.target; const formData = new FormData(form); // You can pass formData as a fetch body directly: fetch('/some-api', { method: form.method, body: formData }); // Or you can work with it as a plain object: const formJson = Object.fromEntries(formData.entries()); console.log(formJson); } return ( <form method=\"post\" onSubmit={handleSubmit}> <label> Text input: <input name=\"myInput\" defaultValue=\"Some initial value\" /> </label> <hr /> <label> Checkbox: <input type=\"checkbox\" name=\"myCheckbox\" defaultChecked={true} /> </label> <hr /> <p> Radio buttons: <label><input type=\"radio\" name=\"myRadio\" value=\"option1\" /> Option 1</label> <label><input type=\"radio\" name=\"myRadio\" value=\"option2\" defaultChecked={true} /> Option 2</label> <label><input type=\"radio\" name=\"myRadio\" value=\"option3\" /> Option 3</label> </p> <hr /> <button type=\"reset\">Reset form</button> <button type=\"submit\">Submit form</button> </form> ); }\nControlling an input with a state variable\nAn input like <input />\nis uncontrolled. Even if you pass an initial value like <input defaultValue=\"Initial text\" />\n, your JSX only specifies the initial value. It does not control what the value should be right now.\nTo render a controlled input, pass the value\nprop to it (or checked\nfor checkboxes and radios). React will force the input to always have the value\nyou passed. Usually, you would do this by declaring a state variable:\nfunction Form() {\nconst [firstName, setFirstName] = useState(''); // Declare a state variable...\n// ...\nreturn (\n<input\nvalue={firstName} // ...force the input's value to match the state variable...\nonChange={e => setFirstName(e.target.value)} // ... and update the state variable on any edits!\n/>\n);\n}\nA controlled input makes sense if you needed state anyway\u2014for example, to re-render your UI on every edit:\nfunction Form() {\nconst [firstName, setFirstName] = useState('');\nreturn (\n<>\n<label>\nFirst name:\n<input value={firstName} onChange={e => setFirstName(e.target.value)} />\n</label>\n{firstName !== '' && <p>Your name is {firstName}.</p>}\n...\nIt\u2019s also useful if you want to offer multiple ways to adjust the input state (for example, by clicking a button):\nfunction Form() {\n// ...\nconst [age, setAge] = useState('');\nconst ageAsNumber = Number(age);\nreturn (\n<>\n<label>\nAge:\n<input\nvalue={age}\nonChange={e => setAge(e.target.value)}\ntype=\"number\"\n/>\n<button onClick={() => setAge(ageAsNumber + 10)}>\nAdd 10 years\n</button>\nThe value\nyou pass to controlled components should not be undefined\nor null\n. If you need the initial value to be empty (such as with the firstName\nfield below), initialize your state variable to an empty string (''\n).\nimport { useState } from 'react'; export default function Form() { const [firstName, setFirstName] = useState(''); const [age, setAge] = useState('20'); const ageAsNumber = Number(age); return ( <> <label> First name: <input value={firstName} onChange={e => setFirstName(e.target.value)} /> </label> <label> Age: <input value={age} onChange={e => setAge(e.target.value)} type=\"number\" /> <button onClick={() => setAge(ageAsNumber + 10)}> Add 10 years </button> </label> {firstName !== '' && <p>Your name is {firstName}.</p> } {ageAsNumber > 0 && <p>Your age is {ageAsNumber}.</p> } </> ); }\nOptimizing re-rendering on every keystroke\nWhen you use a controlled input, you set the state on every keystroke. If the component containing your state re-renders a large tree, this can get slow. There\u2019s a few ways you can optimize re-rendering performance.\nFor example, suppose you start with a form that re-renders all page content on every keystroke:\nfunction App() {\nconst [firstName, setFirstName] = useState('');\nreturn (\n<>\n<form>\n<input value={firstName} onChange={e => setFirstName(e.target.value)} />\n</form>\n<PageContent />\n</>\n);\n}\nSince <PageContent />\ndoesn\u2019t rely on the input state, you can move the input state into its own component:\nfunction App() {\nreturn (\n<>\n<SignupForm />\n<PageContent />\n</>\n);\n}\nfunction SignupForm() {\nconst [firstName, setFirstName] = useState('');\nreturn (\n<form>\n<input value={firstName} onChange={e => setFirstName(e.target.value)} />\n</form>\n);\n}\nThis significantly improves performance because now only SignupForm\nre-renders on every keystroke.\nIf there is no way to avoid re-rendering (for example, if PageContent\ndepends on the search input\u2019s value), useDeferredValue\nlets you keep the controlled input responsive even in the middle of a large re-render.\nTroubleshooting\nMy text input doesn\u2019t update when I type into it\nIf you render an input with value\nbut no onChange\n, you will see an error in the console:\n// \ud83d\udd34 Bug: controlled text input with no onChange handler\n<input value={something} />\nvalue\nprop to a form field without an onChange\nhandler. This will render a read-only field. If the field should be mutable use defaultValue\n. Otherwise, set either onChange\nor readOnly\n.As the error message suggests, if you only wanted to specify the initial value, pass defaultValue\ninstead:\n// \u2705 Good: uncontrolled input with an initial value\n<input defaultValue={something} />\nIf you want to control this input with a state variable, specify an onChange\nhandler:\n// \u2705 Good: controlled input with onChange\n<input value={something} onChange={e => setSomething(e.target.value)} />\nIf the value is intentionally read-only, add a readOnly\nprop to suppress the error:\n// \u2705 Good: readonly controlled input without on change\n<input value={something} readOnly={true} />\nMy checkbox doesn\u2019t update when I click on it\nIf you render a checkbox with checked\nbut no onChange\n, you will see an error in the console:\n// \ud83d\udd34 Bug: controlled checkbox with no onChange handler\n<input type=\"checkbox\" checked={something} />\nchecked\nprop to a form field without an onChange\nhandler. This will render a read-only field. If the field should be mutable use defaultChecked\n. Otherwise, set either onChange\nor readOnly\n.As the error message suggests, if you only wanted to specify the initial value, pass defaultChecked\ninstead:\n// \u2705 Good: uncontrolled checkbox with an initial value\n<input type=\"checkbox\" defaultChecked={something} />\nIf you want to control this checkbox with a state variable, specify an onChange\nhandler:\n// \u2705 Good: controlled checkbox with onChange\n<input type=\"checkbox\" checked={something} onChange={e => setSomething(e.target.checked)} />\nIf the checkbox is intentionally read-only, add a readOnly\nprop to suppress the error:\n// \u2705 Good: readonly controlled input without on change\n<input type=\"checkbox\" checked={something} readOnly={true} />\nMy input caret jumps to the beginning on every keystroke\nIf you control an input, you must update its state variable to the input\u2019s value from the DOM during onChange\n.\nYou can\u2019t update it to something other than e.target.value\n(or e.target.checked\nfor checkboxes):\nfunction handleChange(e) {\n// \ud83d\udd34 Bug: updating an input to something other than e.target.value\nsetFirstName(e.target.value.toUpperCase());\n}\nYou also can\u2019t update it asynchronously:\nfunction handleChange(e) {\n// \ud83d\udd34 Bug: updating an input asynchronously\nsetTimeout(() => {\nsetFirstName(e.target.value);\n}, 100);\n}\nTo fix your code, update it synchronously to e.target.value\n:\nfunction handleChange(e) {\n// \u2705 Updating a controlled input to e.target.value synchronously\nsetFirstName(e.target.value);\n}\nIf this doesn\u2019t fix the problem, it\u2019s possible that the input gets removed and re-added from the DOM on every keystroke. This can happen if you\u2019re accidentally resetting state on every re-render, for example if the input or one of its parents always receives a different key\nattribute, or if you nest component function definitions (which is not supported and causes the \u201cinner\u201d component to always be considered a different tree).\nI\u2019m getting an error: \u201cA component is changing an uncontrolled input to be controlled\u201d\nIf you provide a value\nto the component, it must remain a string throughout its lifetime.\nYou cannot pass value={undefined}\nfirst and later pass value=\"some string\"\nbecause React won\u2019t know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a string value\n, not null\nor undefined\n.\nIf your value\nis coming from an API or a state variable, it might be initialized to null\nor undefined\n. In that case, either set it to an empty string (''\n) initially, or pass value={someValue ?? ''}\nto ensure value\nis a string.\nSimilarly, if you pass checked\nto a checkbox, ensure it\u2019s always a boolean."
  },
  {
    "source": "https://react.dev/reference/react-dom/components/link",
    "title": "<link> \u2013 React",
    "text": "<link>\nThe built-in browser <link>\ncomponent lets you use external resources such as stylesheets or annotate the document with link metadata.\n<link rel=\"icon\" href=\"favicon.ico\" />\nReference\n<link>\nTo link to external resources such as stylesheets, fonts, and icons, or to annotate the document with link metadata, render the built-in browser <link>\ncomponent. You can render <link>\nfrom any component and React will in most cases place the corresponding DOM element in the document head.\n<link rel=\"icon\" href=\"favicon.ico\" />\nProps\n<link>\nsupports all common element props.\nrel\n: a string, required. Specifies the relationship to the resource. React treats links withrel=\"stylesheet\"\ndifferently from other links.\nThese props apply when rel=\"stylesheet\"\n:\nprecedence\n: a string. Tells React where to rank the<link>\nDOM node relative to others in the document<head>\n, which determines which stylesheet can override the other. React will infer that precedence values it discovers first are \u201clower\u201d and precedence values it discovers later are \u201chigher\u201d. Many style systems can work fine using a single precedence value because style rules are atomic. Stylesheets with the same precedence go together whether they are<link>\nor inline<style>\ntags or loaded usingpreinit\nfunctions.media\n: a string. Restricts the stylesheet to a certain media query.title\n: a string. Specifies the name of an alternative stylesheet.\nThese props apply when rel=\"stylesheet\"\nbut disable React\u2019s special treatment of stylesheets:\ndisabled\n: a boolean. Disables the stylesheet.onError\n: a function. Called when the stylesheet fails to load.onLoad\n: a function. Called when the stylesheet finishes being loaded.\nThese props apply when rel=\"preload\"\nor rel=\"modulepreload\"\n:\nas\n: a string. The type of resource. Its possible values areaudio\n,document\n,embed\n,fetch\n,font\n,image\n,object\n,script\n,style\n,track\n,video\n,worker\n.imageSrcSet\n: a string. Applicable only whenas=\"image\"\n. Specifies the source set of the image.imageSizes\n: a string. Applicable only whenas=\"image\"\n. Specifies the sizes of the image.\nThese props apply when rel=\"icon\"\nor rel=\"apple-touch-icon\"\n:\nsizes\n: a string. The sizes of the icon.\nThese props apply in all cases:\nhref\n: a string. The URL of the linked resource.crossOrigin\n: a string. The CORS policy to use. Its possible values areanonymous\nanduse-credentials\n. It is required whenas\nis set to\"fetch\"\n.referrerPolicy\n: a string. The Referrer header to send when fetching. Its possible values areno-referrer-when-downgrade\n(the default),no-referrer\n,origin\n,origin-when-cross-origin\n, andunsafe-url\n.fetchPriority\n: a string. Suggests a relative priority for fetching the resource. The possible values areauto\n(the default),high\n, andlow\n.hrefLang\n: a string. The language of the linked resource.integrity\n: a string. A cryptographic hash of the resource, to verify its authenticity.type\n: a string. The MIME type of the linked resource.\nProps that are not recommended for use with React:\nblocking\n: a string. If set to\"render\"\n, instructs the browser not to render the page until the stylesheet is loaded. React provides more fine-grained control using Suspense.\nSpecial rendering behavior\nReact will always place the DOM element corresponding to the <link>\ncomponent within the document\u2019s <head>\n, regardless of where in the React tree it is rendered. The <head>\nis the only valid place for <link>\nto exist within the DOM, yet it\u2019s convenient and keeps things composable if a component representing a specific page can render <link>\ncomponents itself.\nThere are a few exceptions to this:\n- If the\n<link>\nhas arel=\"stylesheet\"\nprop, then it has to also have aprecedence\nprop to get this special behavior. This is because the order of stylesheets within the document is significant, so React needs to know how to order this stylesheet relative to others, which you specify using theprecedence\nprop. If theprecedence\nprop is omitted, there is no special behavior. - If the\n<link>\nhas anitemProp\nprop, there is no special behavior, because in this case it doesn\u2019t apply to the document but instead represents metadata about a specific part of the page. - If the\n<link>\nhas anonLoad\noronError\nprop, because in that case you are managing the loading of the linked resource manually within your React component.\nSpecial behavior for stylesheets\nIn addition, if the <link>\nis to a stylesheet (namely, it has rel=\"stylesheet\"\nin its props), React treats it specially in the following ways:\n- The component that renders\n<link>\nwill suspend while the stylesheet is loading. - If multiple components render links to the same stylesheet, React will de-duplicate them and only put a single link into the DOM. Two links are considered the same if they have the same\nhref\nprop.\nThere are two exception to this special behavior:\n- If the link doesn\u2019t have a\nprecedence\nprop, there is no special behavior, because the order of stylesheets within the document is significant, so React needs to know how to order this stylesheet relative to others, which you specify using theprecedence\nprop. - If you supply any of the\nonLoad\n,onError\n, ordisabled\nprops, there is no special behavior, because these props indicate that you are managing the loading of the stylesheet manually within your component.\nThis special treatment comes with two caveats:\n- React will ignore changes to props after the link has been rendered. (React will issue a warning in development if this happens.)\n- React may leave the link in the DOM even after the component that rendered it has been unmounted.\nUsage\nLinking to related resources\nYou can annotate the document with links to related resources such as an icon, canonical URL, or pingback. React will place this metadata within the document <head>\nregardless of where in the React tree it is rendered.\nimport ShowRenderedHTML from './ShowRenderedHTML.js'; export default function BlogPage() { return ( <ShowRenderedHTML> <link rel=\"icon\" href=\"favicon.ico\" /> <link rel=\"pingback\" href=\"http://www.example.com/xmlrpc.php\" /> <h1>My Blog</h1> <p>...</p> </ShowRenderedHTML> ); }\nLinking to a stylesheet\nIf a component depends on a certain stylesheet in order to be displayed correctly, you can render a link to that stylesheet within the component. Your component will suspend while the stylesheet is loading. You must supply the precedence\nprop, which tells React where to place this stylesheet relative to others \u2014 stylesheets with higher precedence can override those with lower precedence.\nimport ShowRenderedHTML from './ShowRenderedHTML.js'; export default function SiteMapPage() { return ( <ShowRenderedHTML> <link rel=\"stylesheet\" href=\"sitemap.css\" precedence=\"medium\" /> <p>...</p> </ShowRenderedHTML> ); }\nControlling stylesheet precedence\nStylesheets can conflict with each other, and when they do, the browser goes with the one that comes later in the document. React lets you control the order of stylesheets with the precedence\nprop. In this example, three components render stylesheets, and the ones with the same precedence are grouped together in the <head>\n.\nimport ShowRenderedHTML from './ShowRenderedHTML.js'; export default function HomePage() { return ( <ShowRenderedHTML> <FirstComponent /> <SecondComponent /> <ThirdComponent/> ... </ShowRenderedHTML> ); } function FirstComponent() { return <link rel=\"stylesheet\" href=\"first.css\" precedence=\"first\" />; } function SecondComponent() { return <link rel=\"stylesheet\" href=\"second.css\" precedence=\"second\" />; } function ThirdComponent() { return <link rel=\"stylesheet\" href=\"third.css\" precedence=\"first\" />; }\nNote the precedence\nvalues themselves are arbitrary and their naming is up to you. React will infer that precedence values it discovers first are \u201clower\u201d and precedence values it discovers later are \u201chigher\u201d.\nDeduplicated stylesheet rendering\nIf you render the same stylesheet from multiple components, React will place only a single <link>\nin the document head.\nimport ShowRenderedHTML from './ShowRenderedHTML.js'; export default function HomePage() { return ( <ShowRenderedHTML> <Component /> <Component /> ... </ShowRenderedHTML> ); } function Component() { return <link rel=\"stylesheet\" href=\"styles.css\" precedence=\"medium\" />; }\nAnnotating specific items within the document with links\nYou can use the <link>\ncomponent with the itemProp\nprop to annotate specific items within the document with links to related resources. In this case, React will not place these annotations within the document <head>\nbut will place them like any other React component.\n<section itemScope>\n<h3>Annotating specific items</h3>\n<link itemProp=\"author\" href=\"http://example.com/\" />\n<p>...</p>\n</section>"
  },
  {
    "source": "https://react.dev/reference/react-dom/components/meta",
    "title": "<meta> \u2013 React",
    "text": "<meta>\nThe built-in browser <meta>\ncomponent lets you add metadata to the document.\n<meta name=\"keywords\" content=\"React, JavaScript, semantic markup, html\" />\nReference\n<meta>\nTo add document metadata, render the built-in browser <meta>\ncomponent. You can render <meta>\nfrom any component and React will always place the corresponding DOM element in the document head.\n<meta name=\"keywords\" content=\"React, JavaScript, semantic markup, html\" />\nProps\n<meta>\nsupports all common element props.\nIt should have exactly one of the following props: name\n, httpEquiv\n, charset\n, itemProp\n. The <meta>\ncomponent does something different depending on which of these props is specified.\nname\n: a string. Specifies the kind of metadata to be attached to the document.charset\n: a string. Specifies the character set used by the document. The only valid value is\"utf-8\"\n.httpEquiv\n: a string. Specifies a directive for processing the document.itemProp\n: a string. Specifies metadata about a particular item within the document rather than the document as a whole.content\n: a string. Specifies the metadata to be attached when used with thename\noritemProp\nprops or the behavior of the directive when used with thehttpEquiv\nprop.\nSpecial rendering behavior\nReact will always place the DOM element corresponding to the <meta>\ncomponent within the document\u2019s <head>\n, regardless of where in the React tree it is rendered. The <head>\nis the only valid place for <meta>\nto exist within the DOM, yet it\u2019s convenient and keeps things composable if a component representing a specific page can render <meta>\ncomponents itself.\nThere is one exception to this: if <meta>\nhas an itemProp\nprop, there is no special behavior, because in this case it doesn\u2019t represent metadata about the document but rather metadata about a specific part of the page.\nUsage\nAnnotating the document with metadata\nYou can annotate the document with metadata such as keywords, a summary, or the author\u2019s name. React will place this metadata within the document <head>\nregardless of where in the React tree it is rendered.\n<meta name=\"author\" content=\"John Smith\" />\n<meta name=\"keywords\" content=\"React, JavaScript, semantic markup, html\" />\n<meta name=\"description\" content=\"API reference for the <meta> component in React DOM\" />\nYou can render the <meta>\ncomponent from any component. React will put a <meta>\nDOM node in the document <head>\n.\nimport ShowRenderedHTML from './ShowRenderedHTML.js'; export default function SiteMapPage() { return ( <ShowRenderedHTML> <meta name=\"keywords\" content=\"React\" /> <meta name=\"description\" content=\"A site map for the React website\" /> <h1>Site Map</h1> <p>...</p> </ShowRenderedHTML> ); }\nAnnotating specific items within the document with metadata\nYou can use the <meta>\ncomponent with the itemProp\nprop to annotate specific items within the document with metadata. In this case, React will not place these annotations within the document <head>\nbut will place them like any other React component.\n<section itemScope>\n<h3>Annotating specific items</h3>\n<meta itemProp=\"description\" content=\"API reference for using <meta> with itemProp\" />\n<p>...</p>\n</section>"
  },
  {
    "source": "https://react.dev/reference/react-dom/components/option",
    "title": "<option> \u2013 React",
    "text": "<option>\nThe built-in browser <option>\ncomponent lets you render an option inside a <select>\nbox.\n<select>\n<option value=\"someOption\">Some option</option>\n<option value=\"otherOption\">Other option</option>\n</select>\nReference\n<option>\nThe built-in browser <option>\ncomponent lets you render an option inside a <select>\nbox.\n<select>\n<option value=\"someOption\">Some option</option>\n<option value=\"otherOption\">Other option</option>\n</select>\nProps\n<option>\nsupports all common element props.\nAdditionally, <option>\nsupports these props:\ndisabled\n: A boolean. Iftrue\n, the option will not be selectable and will appear dimmed.label\n: A string. Specifies the meaning of the option. If not specified, the text inside the option is used.value\n: The value to be used when submitting the parent<select>\nin a form if this option is selected.\nCaveats\n- React does not support the\nselected\nattribute on<option>\n. Instead, pass this option\u2019svalue\nto the parent<select defaultValue>\nfor an uncontrolled select box, or<select value>\nfor a controlled select.\nUsage\nDisplaying a select box with options\nRender a <select>\nwith a list of <option>\ncomponents inside to display a select box. Give each <option>\na value\nrepresenting the data to be submitted with the form.\nRead more about displaying a <select>\nwith a list of <option>\ncomponents.\nexport default function FruitPicker() { return ( <label> Pick a fruit: <select name=\"selectedFruit\"> <option value=\"apple\">Apple</option> <option value=\"banana\">Banana</option> <option value=\"orange\">Orange</option> </select> </label> ); }"
  },
  {
    "source": "https://react.dev/reference/react-dom/components/progress",
    "title": "<progress> \u2013 React",
    "text": "<progress>\nThe built-in browser <progress>\ncomponent lets you render a progress indicator.\n<progress value={0.5} />\nReference\n<progress>\nTo display a progress indicator, render the built-in browser <progress>\ncomponent.\n<progress value={0.5} />\nProps\n<progress>\nsupports all common element props.\nAdditionally, <progress>\nsupports these props:\nmax\n: A number. Specifies the maximumvalue\n. Defaults to1\n.value\n: A number between0\nandmax\n, ornull\nfor indeterminate progress. Specifies how much was done.\nUsage\nControlling a progress indicator\nTo display a progress indicator, render a <progress>\ncomponent. You can pass a number value\nbetween 0\nand the max\nvalue you specify. If you don\u2019t pass a max\nvalue, it will assumed to be 1\nby default.\nIf the operation is not ongoing, pass value={null}\nto put the progress indicator into an indeterminate state.\nexport default function App() { return ( <> <progress value={0} /> <progress value={0.5} /> <progress value={0.7} /> <progress value={75} max={100} /> <progress value={1} /> <progress value={null} /> </> ); }"
  },
  {
    "source": "https://react.dev/reference/react-dom/components/script",
    "title": "<script> \u2013 React",
    "text": "<script>\nThe built-in browser <script>\ncomponent lets you add a script to your document.\n<script> alert(\"hi!\") </script>\nReference\n<script>\nTo add inline or external scripts to your document, render the built-in browser <script>\ncomponent. You can render <script>\nfrom any component and React will in certain cases place the corresponding DOM element in the document head and de-duplicate identical scripts.\n<script> alert(\"hi!\") </script>\n<script src=\"script.js\" />\nProps\n<script>\nsupports all common element props.\nIt should have either children\nor a src\nprop.\nchildren\n: a string. The source code of an inline script.src\n: a string. The URL of an external script.\nOther supported props:\nasync\n: a boolean. Allows the browser to defer execution of the script until the rest of the document has been processed \u2014 the preferred behavior for performance.crossOrigin\n: a string. The CORS policy to use. Its possible values areanonymous\nanduse-credentials\n.fetchPriority\n: a string. Lets the browser rank scripts in priority when fetching multiple scripts at the same time. Can be\"high\"\n,\"low\"\n, or\"auto\"\n(the default).integrity\n: a string. A cryptographic hash of the script, to verify its authenticity.noModule\n: a boolean. Disables the script in browsers that support ES modules \u2014 allowing for a fallback script for browsers that do not.nonce\n: a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy.referrer\n: a string. Says what Referer header to send when fetching the script and any resources that the script fetches in turn.type\n: a string. Says whether the script is a classic script, ES module, or import map.\nProps that disable React\u2019s special treatment of scripts:\nonError\n: a function. Called when the script fails to load.onLoad\n: a function. Called when the script finishes being loaded.\nProps that are not recommended for use with React:\nblocking\n: a string. If set to\"render\"\n, instructs the browser not to render the page until the scriptsheet is loaded. React provides more fine-grained control using Suspense.defer\n: a string. Prevents the browser from executing the script until the document is done loading. Not compatible with streaming server-rendered components. Use theasync\nprop instead.\nSpecial rendering behavior\nReact can move <script>\ncomponents to the document\u2019s <head>\nand de-duplicate identical scripts.\nTo opt into this behavior, provide the src\nand async={true}\nprops. React will de-duplicate scripts if they have the same src\n. The async\nprop must be true to allow scripts to be safely moved.\nThis special treatment comes with two caveats:\n- React will ignore changes to props after the script has been rendered. (React will issue a warning in development if this happens.)\n- React may leave the script in the DOM even after the component that rendered it has been unmounted. (This has no effect as scripts just execute once when they are inserted into the DOM.)\nUsage\nRendering an external script\nIf a component depends on certain scripts in order to be displayed correctly, you can render a <script>\nwithin the component.\nHowever, the component might be committed before the script has finished loading.\nYou can start depending on the script content once the load\nevent is fired e.g. by using the onLoad\nprop.\nReact will de-duplicate scripts that have the same src\n, inserting only one of them into the DOM even if multiple components render it.\nimport ShowRenderedHTML from './ShowRenderedHTML.js'; function Map({lat, long}) { return ( <> <script async src=\"map-api.js\" onLoad={() => console.log('script loaded')} /> <div id=\"map\" data-lat={lat} data-long={long} /> </> ); } export default function Page() { return ( <ShowRenderedHTML> <Map /> </ShowRenderedHTML> ); }\nRendering an inline script\nTo include an inline script, render the <script>\ncomponent with the script source code as its children. Inline scripts are not de-duplicated or moved to the document <head>\n.\nimport ShowRenderedHTML from './ShowRenderedHTML.js'; function Tracking() { return ( <script> ga('send', 'pageview'); </script> ); } export default function Page() { return ( <ShowRenderedHTML> <h1>My Website</h1> <Tracking /> <p>Welcome</p> </ShowRenderedHTML> ); }"
  },
  {
    "source": "https://react.dev/reference/react-dom/components/select",
    "title": "<select> \u2013 React",
    "text": "<select>\nThe built-in browser <select>\ncomponent lets you render a select box with options.\n<select>\n<option value=\"someOption\">Some option</option>\n<option value=\"otherOption\">Other option</option>\n</select>\nReference\n<select>\nTo display a select box, render the built-in browser <select>\ncomponent.\n<select>\n<option value=\"someOption\">Some option</option>\n<option value=\"otherOption\">Other option</option>\n</select>\nProps\n<select>\nsupports all common element props.\nYou can make a select box controlled by passing a value\nprop:\nvalue\n: A string (or an array of strings formultiple={true}\n). Controls which option is selected. Every value string match thevalue\nof some<option>\nnested inside the<select>\n.\nWhen you pass value\n, you must also pass an onChange\nhandler that updates the passed value.\nIf your <select>\nis uncontrolled, you may pass the defaultValue\nprop instead:\ndefaultValue\n: A string (or an array of strings formultiple={true}\n). Specifies the initially selected option.\nThese <select>\nprops are relevant both for uncontrolled and controlled select boxes:\nautoComplete\n: A string. Specifies one of the possible autocomplete behaviors.autoFocus\n: A boolean. Iftrue\n, React will focus the element on mount.children\n:<select>\naccepts<option>\n,<optgroup>\n, and<datalist>\ncomponents as children. You can also pass your own components as long as they eventually render one of the allowed components. If you pass your own components that eventually render<option>\ntags, each<option>\nyou render must have avalue\n.disabled\n: A boolean. Iftrue\n, the select box will not be interactive and will appear dimmed.form\n: A string. Specifies theid\nof the<form>\nthis select box belongs to. If omitted, it\u2019s the closest parent form.multiple\n: A boolean. Iftrue\n, the browser allows multiple selection.name\n: A string. Specifies the name for this select box that\u2019s submitted with the form.onChange\n: AnEvent\nhandler function. Required for controlled select boxes. Fires immediately when the user picks a different option. Behaves like the browserinput\nevent.onChangeCapture\n: A version ofonChange\nthat fires in the capture phase.onInput\n: AnEvent\nhandler function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to useonChange\ninstead which works similarly.onInputCapture\n: A version ofonInput\nthat fires in the capture phase.onInvalid\n: AnEvent\nhandler function. Fires if an input fails validation on form submit. Unlike the built-ininvalid\nevent, the ReactonInvalid\nevent bubbles.onInvalidCapture\n: A version ofonInvalid\nthat fires in the capture phase.required\n: A boolean. Iftrue\n, the value must be provided for the form to submit.size\n: A number. Formultiple={true}\nselects, specifies the preferred number of initially visible items.\nCaveats\n- Unlike in HTML, passing a\nselected\nattribute to<option>\nis not supported. Instead, use<select defaultValue>\nfor uncontrolled select boxes and<select value>\nfor controlled select boxes. - If a select box receives a\nvalue\nprop, it will be treated as controlled. - A select box can\u2019t be both controlled and uncontrolled at the same time.\n- A select box cannot switch between being controlled or uncontrolled over its lifetime.\n- Every controlled select box needs an\nonChange\nevent handler that synchronously updates its backing value.\nUsage\nDisplaying a select box with options\nRender a <select>\nwith a list of <option>\ncomponents inside to display a select box. Give each <option>\na value\nrepresenting the data to be submitted with the form.\nexport default function FruitPicker() { return ( <label> Pick a fruit: <select name=\"selectedFruit\"> <option value=\"apple\">Apple</option> <option value=\"banana\">Banana</option> <option value=\"orange\">Orange</option> </select> </label> ); }\nProviding a label for a select box\nTypically, you will place every <select>\ninside a <label>\ntag. This tells the browser that this label is associated with that select box. When the user clicks the label, the browser will automatically focus the select box. It\u2019s also essential for accessibility: a screen reader will announce the label caption when the user focuses the select box.\nIf you can\u2019t nest <select>\ninto a <label>\n, associate them by passing the same ID to <select id>\nand <label htmlFor>\n. To avoid conflicts between multiple instances of one component, generate such an ID with useId\n.\nimport { useId } from 'react'; export default function Form() { const vegetableSelectId = useId(); return ( <> <label> Pick a fruit: <select name=\"selectedFruit\"> <option value=\"apple\">Apple</option> <option value=\"banana\">Banana</option> <option value=\"orange\">Orange</option> </select> </label> <hr /> <label htmlFor={vegetableSelectId}> Pick a vegetable: </label> <select id={vegetableSelectId} name=\"selectedVegetable\"> <option value=\"cucumber\">Cucumber</option> <option value=\"corn\">Corn</option> <option value=\"tomato\">Tomato</option> </select> </> ); }\nProviding an initially selected option\nBy default, the browser will select the first <option>\nin the list. To select a different option by default, pass that <option>\n\u2019s value\nas the defaultValue\nto the <select>\nelement.\nexport default function FruitPicker() { return ( <label> Pick a fruit: <select name=\"selectedFruit\" defaultValue=\"orange\"> <option value=\"apple\">Apple</option> <option value=\"banana\">Banana</option> <option value=\"orange\">Orange</option> </select> </label> ); }\nEnabling multiple selection\nPass multiple={true}\nto the <select>\nto let the user select multiple options. In that case, if you also specify defaultValue\nto choose the initially selected options, it must be an array.\nexport default function FruitPicker() { return ( <label> Pick some fruits: <select name=\"selectedFruit\" defaultValue={['orange', 'banana']} multiple={true} > <option value=\"apple\">Apple</option> <option value=\"banana\">Banana</option> <option value=\"orange\">Orange</option> </select> </label> ); }\nReading the select box value when submitting a form\nAdd a <form>\naround your select box with a <button type=\"submit\">\ninside. It will call your <form onSubmit>\nevent handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling e.preventDefault()\n. Read the form data with new FormData(e.target)\n.\nexport default function EditPost() { function handleSubmit(e) { // Prevent the browser from reloading the page e.preventDefault(); // Read the form data const form = e.target; const formData = new FormData(form); // You can pass formData as a fetch body directly: fetch('/some-api', { method: form.method, body: formData }); // You can generate a URL out of it, as the browser does by default: console.log(new URLSearchParams(formData).toString()); // You can work with it as a plain object. const formJson = Object.fromEntries(formData.entries()); console.log(formJson); // (!) This doesn't include multiple select values // Or you can get an array of name-value pairs. console.log([...formData.entries()]); } return ( <form method=\"post\" onSubmit={handleSubmit}> <label> Pick your favorite fruit: <select name=\"selectedFruit\" defaultValue=\"orange\"> <option value=\"apple\">Apple</option> <option value=\"banana\">Banana</option> <option value=\"orange\">Orange</option> </select> </label> <label> Pick all your favorite vegetables: <select name=\"selectedVegetables\" multiple={true} defaultValue={['corn', 'tomato']} > <option value=\"cucumber\">Cucumber</option> <option value=\"corn\">Corn</option> <option value=\"tomato\">Tomato</option> </select> </label> <hr /> <button type=\"reset\">Reset</button> <button type=\"submit\">Submit</button> </form> ); }\nControlling a select box with a state variable\nA select box like <select />\nis uncontrolled. Even if you pass an initially selected value like <select defaultValue=\"orange\" />\n, your JSX only specifies the initial value, not the value right now.\nTo render a controlled select box, pass the value\nprop to it. React will force the select box to always have the value\nyou passed. Typically, you will control a select box by declaring a state variable:\nfunction FruitPicker() {\nconst [selectedFruit, setSelectedFruit] = useState('orange'); // Declare a state variable...\n// ...\nreturn (\n<select\nvalue={selectedFruit} // ...force the select's value to match the state variable...\nonChange={e => setSelectedFruit(e.target.value)} // ... and update the state variable on any change!\n>\n<option value=\"apple\">Apple</option>\n<option value=\"banana\">Banana</option>\n<option value=\"orange\">Orange</option>\n</select>\n);\n}\nThis is useful if you want to re-render some part of the UI in response to every selection.\nimport { useState } from 'react'; export default function FruitPicker() { const [selectedFruit, setSelectedFruit] = useState('orange'); const [selectedVegs, setSelectedVegs] = useState(['corn', 'tomato']); return ( <> <label> Pick a fruit: <select value={selectedFruit} onChange={e => setSelectedFruit(e.target.value)} > <option value=\"apple\">Apple</option> <option value=\"banana\">Banana</option> <option value=\"orange\">Orange</option> </select> </label> <hr /> <label> Pick all your favorite vegetables: <select multiple={true} value={selectedVegs} onChange={e => { const options = [...e.target.selectedOptions]; const values = options.map(option => option.value); setSelectedVegs(values); }} > <option value=\"cucumber\">Cucumber</option> <option value=\"corn\">Corn</option> <option value=\"tomato\">Tomato</option> </select> </label> <hr /> <p>Your favorite fruit: {selectedFruit}</p> <p>Your favorite vegetables: {selectedVegs.join(', ')}</p> </> ); }"
  },
  {
    "source": "https://react.dev/reference/react-dom/components/style",
    "title": "<style> \u2013 React",
    "text": "<style>\nThe built-in browser <style>\ncomponent lets you add inline CSS stylesheets to your document.\n<style>{` p { color: red; } `}</style>\nReference\n<style>\nTo add inline styles to your document, render the built-in browser <style>\ncomponent. You can render <style>\nfrom any component and React will in certain cases place the corresponding DOM element in the document head and de-duplicate identical styles.\n<style>{` p { color: red; } `}</style>\nProps\n<style>\nsupports all common element props.\nchildren\n: a string, required. The contents of the stylesheet.precedence\n: a string. Tells React where to rank the<style>\nDOM node relative to others in the document<head>\n, which determines which stylesheet can override the other. React will infer that precedence values it discovers first are \u201clower\u201d and precedence values it discovers later are \u201chigher\u201d. Many style systems can work fine using a single precedence value because style rules are atomic. Stylesheets with the same precedence go together whether they are<link>\nor inline<style>\ntags or loaded usingpreinit\nfunctions.href\n: a string. Allows React to de-duplicate styles that have the samehref\n.media\n: a string. Restricts the stylesheet to a certain media query.nonce\n: a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy.title\n: a string. Specifies the name of an alternative stylesheet.\nProps that are not recommended for use with React:\nblocking\n: a string. If set to\"render\"\n, instructs the browser not to render the page until the stylesheet is loaded. React provides more fine-grained control using Suspense.\nSpecial rendering behavior\nReact can move <style>\ncomponents to the document\u2019s <head>\n, de-duplicate identical stylesheets, and suspend while the stylesheet is loading.\nTo opt into this behavior, provide the href\nand precedence\nprops. React will de-duplicate styles if they have the same href\n. The precedence prop tells React where to rank the <style>\nDOM node relative to others in the document <head>\n, which determines which stylesheet can override the other.\nThis special treatment comes with two caveats:\n- React will ignore changes to props after the style has been rendered. (React will issue a warning in development if this happens.)\n- React may leave the style in the DOM even after the component that rendered it has been unmounted.\nUsage\nRendering an inline CSS stylesheet\nIf a component depends on certain CSS styles in order to be displayed correctly, you can render an inline stylesheet within the component.\nThe href\nprop should uniquely identify the stylesheet, because React will de-duplicate stylesheets that have the same href\n.\nIf you supply a precedence\nprop, React will reorder inline stylesheets based on the order these values appear in the component tree.\nInline stylesheets will not trigger Suspense boundaries while they\u2019re loading. Even if they load async resources like fonts or images.\nimport ShowRenderedHTML from './ShowRenderedHTML.js'; import { useId } from 'react'; function PieChart({data, colors}) { const id = useId(); const stylesheet = colors.map((color, index) => `#${id} .color-${index}: \\{ color: \"${color}\"; \\}` ).join(); return ( <> <style href={\"PieChart-\" + JSON.stringify(colors)} precedence=\"medium\"> {stylesheet} </style> <svg id={id}> \u2026 </svg> </> ); } export default function App() { return ( <ShowRenderedHTML> <PieChart data=\"...\" colors={['red', 'green', 'blue']} /> </ShowRenderedHTML> ); }"
  },
  {
    "source": "https://react.dev/reference/react-dom/components/textarea",
    "title": "<textarea> \u2013 React",
    "text": "<textarea>\nThe built-in browser <textarea>\ncomponent lets you render a multiline text input.\n<textarea />\nReference\n<textarea>\nTo display a text area, render the built-in browser <textarea>\ncomponent.\n<textarea name=\"postContent\" />\nProps\n<textarea>\nsupports all common element props.\nYou can make a text area controlled by passing a value\nprop:\nvalue\n: A string. Controls the text inside the text area.\nWhen you pass value\n, you must also pass an onChange\nhandler that updates the passed value.\nIf your <textarea>\nis uncontrolled, you may pass the defaultValue\nprop instead:\ndefaultValue\n: A string. Specifies the initial value for a text area.\nThese <textarea>\nprops are relevant both for uncontrolled and controlled text areas:\nautoComplete\n: Either'on'\nor'off'\n. Specifies the autocomplete behavior.autoFocus\n: A boolean. Iftrue\n, React will focus the element on mount.children\n:<textarea>\ndoes not accept children. To set the initial value, usedefaultValue\n.cols\n: A number. Specifies the default width in average character widths. Defaults to20\n.disabled\n: A boolean. Iftrue\n, the input will not be interactive and will appear dimmed.form\n: A string. Specifies theid\nof the<form>\nthis input belongs to. If omitted, it\u2019s the closest parent form.maxLength\n: A number. Specifies the maximum length of text.minLength\n: A number. Specifies the minimum length of text.name\n: A string. Specifies the name for this input that\u2019s submitted with the form.onChange\n: AnEvent\nhandler function. Required for controlled text areas. Fires immediately when the input\u2019s value is changed by the user (for example, it fires on every keystroke). Behaves like the browserinput\nevent.onChangeCapture\n: A version ofonChange\nthat fires in the capture phase.onInput\n: AnEvent\nhandler function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to useonChange\ninstead which works similarly.onInputCapture\n: A version ofonInput\nthat fires in the capture phase.onInvalid\n: AnEvent\nhandler function. Fires if an input fails validation on form submit. Unlike the built-ininvalid\nevent, the ReactonInvalid\nevent bubbles.onInvalidCapture\n: A version ofonInvalid\nthat fires in the capture phase.onSelect\n: AnEvent\nhandler function. Fires after the selection inside the<textarea>\nchanges. React extends theonSelect\nevent to also fire for empty selection and on edits (which may affect the selection).onSelectCapture\n: A version ofonSelect\nthat fires in the capture phase.placeholder\n: A string. Displayed in a dimmed color when the text area value is empty.readOnly\n: A boolean. Iftrue\n, the text area is not editable by the user.required\n: A boolean. Iftrue\n, the value must be provided for the form to submit.rows\n: A number. Specifies the default height in average character heights. Defaults to2\n.wrap\n: Either'hard'\n,'soft'\n, or'off'\n. Specifies how the text should be wrapped when submitting a form.\nCaveats\n- Passing children like\n<textarea>something</textarea>\nis not allowed. UsedefaultValue\nfor initial content. - If a text area receives a string\nvalue\nprop, it will be treated as controlled. - A text area can\u2019t be both controlled and uncontrolled at the same time.\n- A text area cannot switch between being controlled or uncontrolled over its lifetime.\n- Every controlled text area needs an\nonChange\nevent handler that synchronously updates its backing value.\nUsage\nDisplaying a text area\nRender <textarea>\nto display a text area. You can specify its default size with the rows\nand cols\nattributes, but by default the user will be able to resize it. To disable resizing, you can specify resize: none\nin the CSS.\nexport default function NewPost() { return ( <label> Write your post: <textarea name=\"postContent\" rows={4} cols={40} /> </label> ); }\nProviding a label for a text area\nTypically, you will place every <textarea>\ninside a <label>\ntag. This tells the browser that this label is associated with that text area. When the user clicks the label, the browser will focus the text area. It\u2019s also essential for accessibility: a screen reader will announce the label caption when the user focuses the text area.\nIf you can\u2019t nest <textarea>\ninto a <label>\n, associate them by passing the same ID to <textarea id>\nand <label htmlFor>\n. To avoid conflicts between instances of one component, generate such an ID with useId\n.\nimport { useId } from 'react'; export default function Form() { const postTextAreaId = useId(); return ( <> <label htmlFor={postTextAreaId}> Write your post: </label> <textarea id={postTextAreaId} name=\"postContent\" rows={4} cols={40} /> </> ); }\nProviding an initial value for a text area\nYou can optionally specify the initial value for the text area. Pass it as the defaultValue\nstring.\nexport default function EditPost() { return ( <label> Edit your post: <textarea name=\"postContent\" defaultValue=\"I really enjoyed biking yesterday!\" rows={4} cols={40} /> </label> ); }\nReading the text area value when submitting a form\nAdd a <form>\naround your textarea with a <button type=\"submit\">\ninside. It will call your <form onSubmit>\nevent handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling e.preventDefault()\n. Read the form data with new FormData(e.target)\n.\nexport default function EditPost() { function handleSubmit(e) { // Prevent the browser from reloading the page e.preventDefault(); // Read the form data const form = e.target; const formData = new FormData(form); // You can pass formData as a fetch body directly: fetch('/some-api', { method: form.method, body: formData }); // Or you can work with it as a plain object: const formJson = Object.fromEntries(formData.entries()); console.log(formJson); } return ( <form method=\"post\" onSubmit={handleSubmit}> <label> Post title: <input name=\"postTitle\" defaultValue=\"Biking\" /> </label> <label> Edit your post: <textarea name=\"postContent\" defaultValue=\"I really enjoyed biking yesterday!\" rows={4} cols={40} /> </label> <hr /> <button type=\"reset\">Reset edits</button> <button type=\"submit\">Save post</button> </form> ); }\nControlling a text area with a state variable\nA text area like <textarea />\nis uncontrolled. Even if you pass an initial value like <textarea defaultValue=\"Initial text\" />\n, your JSX only specifies the initial value, not the value right now.\nTo render a controlled text area, pass the value\nprop to it. React will force the text area to always have the value\nyou passed. Typically, you will control a text area by declaring a state variable:\nfunction NewPost() {\nconst [postContent, setPostContent] = useState(''); // Declare a state variable...\n// ...\nreturn (\n<textarea\nvalue={postContent} // ...force the input's value to match the state variable...\nonChange={e => setPostContent(e.target.value)} // ... and update the state variable on any edits!\n/>\n);\n}\nThis is useful if you want to re-render some part of the UI in response to every keystroke.\n{ \"dependencies\": { \"react\": \"latest\", \"react-dom\": \"latest\", \"react-scripts\": \"latest\", \"remarkable\": \"2.0.1\" }, \"scripts\": { \"start\": \"react-scripts start\", \"build\": \"react-scripts build\", \"test\": \"react-scripts test --env=jsdom\", \"eject\": \"react-scripts eject\" }, \"devDependencies\": {} }\nTroubleshooting\nMy text area doesn\u2019t update when I type into it\nIf you render a text area with value\nbut no onChange\n, you will see an error in the console:\n// \ud83d\udd34 Bug: controlled text area with no onChange handler\n<textarea value={something} />\nvalue\nprop to a form field without an onChange\nhandler. This will render a read-only field. If the field should be mutable use defaultValue\n. Otherwise, set either onChange\nor readOnly\n.As the error message suggests, if you only wanted to specify the initial value, pass defaultValue\ninstead:\n// \u2705 Good: uncontrolled text area with an initial value\n<textarea defaultValue={something} />\nIf you want to control this text area with a state variable, specify an onChange\nhandler:\n// \u2705 Good: controlled text area with onChange\n<textarea value={something} onChange={e => setSomething(e.target.value)} />\nIf the value is intentionally read-only, add a readOnly\nprop to suppress the error:\n// \u2705 Good: readonly controlled text area without on change\n<textarea value={something} readOnly={true} />\nMy text area caret jumps to the beginning on every keystroke\nIf you control a text area, you must update its state variable to the text area\u2019s value from the DOM during onChange\n.\nYou can\u2019t update it to something other than e.target.value\n:\nfunction handleChange(e) {\n// \ud83d\udd34 Bug: updating an input to something other than e.target.value\nsetFirstName(e.target.value.toUpperCase());\n}\nYou also can\u2019t update it asynchronously:\nfunction handleChange(e) {\n// \ud83d\udd34 Bug: updating an input asynchronously\nsetTimeout(() => {\nsetFirstName(e.target.value);\n}, 100);\n}\nTo fix your code, update it synchronously to e.target.value\n:\nfunction handleChange(e) {\n// \u2705 Updating a controlled input to e.target.value synchronously\nsetFirstName(e.target.value);\n}\nIf this doesn\u2019t fix the problem, it\u2019s possible that the text area gets removed and re-added from the DOM on every keystroke. This can happen if you\u2019re accidentally resetting state on every re-render. For example, this can happen if the text area or one of its parents always receives a different key\nattribute, or if you nest component definitions (which is not allowed in React and causes the \u201cinner\u201d component to remount on every render).\nI\u2019m getting an error: \u201cA component is changing an uncontrolled input to be controlled\u201d\nIf you provide a value\nto the component, it must remain a string throughout its lifetime.\nYou cannot pass value={undefined}\nfirst and later pass value=\"some string\"\nbecause React won\u2019t know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a string value\n, not null\nor undefined\n.\nIf your value\nis coming from an API or a state variable, it might be initialized to null\nor undefined\n. In that case, either set it to an empty string (''\n) initially, or pass value={someValue ?? ''}\nto ensure value\nis a string."
  },
  {
    "source": "https://react.dev/reference/react-dom/components/title",
    "title": "<title> \u2013 React",
    "text": "<title>\nThe built-in browser <title>\ncomponent lets you specify the title of the document.\n<title>My Blog</title>\nReference\n<title>\nTo specify the title of the document, render the built-in browser <title>\ncomponent. You can render <title>\nfrom any component and React will always place the corresponding DOM element in the document head.\n<title>My Blog</title>\nProps\n<title>\nsupports all common element props.\nchildren\n:<title>\naccepts only text as a child. This text will become the title of the document. You can also pass your own components as long as they only render text.\nSpecial rendering behavior\nReact will always place the DOM element corresponding to the <title>\ncomponent within the document\u2019s <head>\n, regardless of where in the React tree it is rendered. The <head>\nis the only valid place for <title>\nto exist within the DOM, yet it\u2019s convenient and keeps things composable if a component representing a specific page can render its <title>\nitself.\nThere are two exception to this:\n- If\n<title>\nis within an<svg>\ncomponent, then there is no special behavior, because in this context it doesn\u2019t represent the document\u2019s title but rather is an accessibility annotation for that SVG graphic. - If the\n<title>\nhas anitemProp\nprop, there is no special behavior, because in this case it doesn\u2019t represent the document\u2019s title but rather metadata about a specific part of the page.\nUsage\nSet the document title\nRender the <title>\ncomponent from any component with text as its children. React will put a <title>\nDOM node in the document <head>\n.\nimport ShowRenderedHTML from './ShowRenderedHTML.js'; export default function ContactUsPage() { return ( <ShowRenderedHTML> <title>My Site: Contact Us</title> <h1>Contact Us</h1> <p>Email us at support@example.com</p> </ShowRenderedHTML> ); }\nUse variables in the title\nThe children of the <title>\ncomponent must be a single string of text. (Or a single number or a single object with a toString\nmethod.) It might not be obvious, but using JSX curly braces like this:\n<title>Results page {pageNumber}</title> // \ud83d\udd34 Problem: This is not a single string\n\u2026 actually causes the <title>\ncomponent to get a two-element array as its children (the string \"Results page\"\nand the value of pageNumber\n). This will cause an error. Instead, use string interpolation to pass <title>\na single string:\n<title>{`Results page ${pageNumber}`}</title>"
  },
  {
    "source": "https://react.dev/reference/react-dom/createPortal",
    "title": "createPortal \u2013 React",
    "text": "createPortal\ncreatePortal\nlets you render some children into a different part of the DOM.\n<div>\n<SomeComponent />\n{createPortal(children, domNode, key?)}\n</div>\nReference\ncreatePortal(children, domNode, key?)\nTo create a portal, call createPortal\n, passing some JSX, and the DOM node where it should be rendered:\nimport { createPortal } from 'react-dom';\n// ...\n<div>\n<p>This child is placed in the parent div.</p>\n{createPortal(\n<p>This child is placed in the document body.</p>,\ndocument.body\n)}\n</div>\nA portal only changes the physical placement of the DOM node. In every other way, the JSX you render into a portal acts as a child node of the React component that renders it. For example, the child can access the context provided by the parent tree, and events bubble up from children to parents according to the React tree.\nParameters\n-\nchildren\n: Anything that can be rendered with React, such as a piece of JSX (e.g.<div />\nor<SomeComponent />\n), a Fragment (<>...</>\n), a string or a number, or an array of these. -\ndomNode\n: Some DOM node, such as those returned bydocument.getElementById()\n. The node must already exist. Passing a different DOM node during an update will cause the portal content to be recreated. -\noptional\nkey\n: A unique string or number to be used as the portal\u2019s key.\nReturns\ncreatePortal\nreturns a React node that can be included into JSX or returned from a React component. If React encounters it in the render output, it will place the provided children\ninside the provided domNode\n.\nCaveats\n- Events from portals propagate according to the React tree rather than the DOM tree. For example, if you click inside a portal, and the portal is wrapped in\n<div onClick>\n, thatonClick\nhandler will fire. If this causes issues, either stop the event propagation from inside the portal, or move the portal itself up in the React tree.\nUsage\nRendering to a different part of the DOM\nPortals let your components render some of their children into a different place in the DOM. This lets a part of your component \u201cescape\u201d from whatever containers it may be in. For example, a component can display a modal dialog or a tooltip that appears above and outside of the rest of the page.\nTo create a portal, render the result of createPortal\nwith some JSX and the DOM node where it should go:\nimport { createPortal } from 'react-dom';\nfunction MyComponent() {\nreturn (\n<div style={{ border: '2px solid black' }}>\n<p>This child is placed in the parent div.</p>\n{createPortal(\n<p>This child is placed in the document body.</p>,\ndocument.body\n)}\n</div>\n);\n}\nReact will put the DOM nodes for the JSX you passed inside of the DOM node you provided.\nWithout a portal, the second <p>\nwould be placed inside the parent <div>\n, but the portal \u201cteleported\u201d it into the document.body\n:\nimport { createPortal } from 'react-dom'; export default function MyComponent() { return ( <div style={{ border: '2px solid black' }}> <p>This child is placed in the parent div.</p> {createPortal( <p>This child is placed in the document body.</p>, document.body )} </div> ); }\nNotice how the second paragraph visually appears outside the parent <div>\nwith the border. If you inspect the DOM structure with developer tools, you\u2019ll see that the second <p>\ngot placed directly into the <body>\n:\n<body>\n<div id=\"root\">\n...\n<div style=\"border: 2px solid black\">\n<p>This child is placed inside the parent div.</p>\n</div>\n...\n</div>\n<p>This child is placed in the document body.</p>\n</body>\nA portal only changes the physical placement of the DOM node. In every other way, the JSX you render into a portal acts as a child node of the React component that renders it. For example, the child can access the context provided by the parent tree, and events still bubble up from children to parents according to the React tree.\nRendering a modal dialog with a portal\nYou can use a portal to create a modal dialog that floats above the rest of the page, even if the component that summons the dialog is inside a container with overflow: hidden\nor other styles that interfere with the dialog.\nIn this example, the two containers have styles that disrupt the modal dialog, but the one rendered into a portal is unaffected because, in the DOM, the modal is not contained within the parent JSX elements.\nimport NoPortalExample from './NoPortalExample'; import PortalExample from './PortalExample'; export default function App() { return ( <> <div className=\"clipping-container\"> <NoPortalExample /> </div> <div className=\"clipping-container\"> <PortalExample /> </div> </> ); }\nRendering React components into non-React server markup\nPortals can be useful if your React root is only part of a static or server-rendered page that isn\u2019t built with React. For example, if your page is built with a server framework like Rails, you can create areas of interactivity within static areas such as sidebars. Compared with having multiple separate React roots, portals let you treat the app as a single React tree with shared state even though its parts render to different parts of the DOM.\nimport { createPortal } from 'react-dom'; const sidebarContentEl = document.getElementById('sidebar-content'); export default function App() { return ( <> <MainContent /> {createPortal( <SidebarContent />, sidebarContentEl )} </> ); } function MainContent() { return <p>This part is rendered by React</p>; } function SidebarContent() { return <p>This part is also rendered by React!</p>; }\nRendering React components into non-React DOM nodes\nYou can also use a portal to manage the content of a DOM node that\u2019s managed outside of React. For example, suppose you\u2019re integrating with a non-React map widget and you want to render React content inside a popup. To do this, declare a popupContainer\nstate variable to store the DOM node you\u2019re going to render into:\nconst [popupContainer, setPopupContainer] = useState(null);\nWhen you create the third-party widget, store the DOM node returned by the widget so you can render into it:\nuseEffect(() => {\nif (mapRef.current === null) {\nconst map = createMapWidget(containerRef.current);\nmapRef.current = map;\nconst popupDiv = addPopupToMapWidget(map);\nsetPopupContainer(popupDiv);\n}\n}, []);\nThis lets you use createPortal\nto render React content into popupContainer\nonce it becomes available:\nreturn (\n<div style={{ width: 250, height: 250 }} ref={containerRef}>\n{popupContainer !== null && createPortal(\n<p>Hello from React!</p>,\npopupContainer\n)}\n</div>\n);\nHere is a complete example you can play with:\nimport { useRef, useEffect, useState } from 'react'; import { createPortal } from 'react-dom'; import { createMapWidget, addPopupToMapWidget } from './map-widget.js'; export default function Map() { const containerRef = useRef(null); const mapRef = useRef(null); const [popupContainer, setPopupContainer] = useState(null); useEffect(() => { if (mapRef.current === null) { const map = createMapWidget(containerRef.current); mapRef.current = map; const popupDiv = addPopupToMapWidget(map); setPopupContainer(popupDiv); } }, []); return ( <div style={{ width: 250, height: 250 }} ref={containerRef}> {popupContainer !== null && createPortal( <p>Hello from React!</p>, popupContainer )} </div> ); }"
  },
  {
    "source": "https://react.dev/reference/react-dom/findDOMNode",
    "title": "findDOMNode \u2013 React",
    "text": "findDOMNode\nfindDOMNode\nfinds the browser DOM node for a React class component instance.\nconst domNode = findDOMNode(componentInstance)\nReference\nfindDOMNode(componentInstance)\nCall findDOMNode\nto find the browser DOM node for a given React class component instance.\nimport { findDOMNode } from 'react-dom';\nconst domNode = findDOMNode(componentInstance);\nParameters\ncomponentInstance\n: An instance of theComponent\nsubclass. For example,this\ninside a class component.\nReturns\nfindDOMNode\nreturns the first closest browser DOM node within the given componentInstance\n. When a component renders to null\n, or renders false\n, findDOMNode\nreturns null\n. When a component renders to a string, findDOMNode\nreturns a text DOM node containing that value.\nCaveats\n-\nA component may return an array or a Fragment with multiple children. In that case\nfindDOMNode\n, will return the DOM node corresponding to the first non-empty child. -\nfindDOMNode\nonly works on mounted components (that is, components that have been placed in the DOM). If you try to call this on a component that has not been mounted yet (like callingfindDOMNode()\ninrender()\non a component that has yet to be created), an exception will be thrown. -\nfindDOMNode\nonly returns the result at the time of your call. If a child component renders a different node later, there is no way for you to be notified of this change. -\nfindDOMNode\naccepts a class component instance, so it can\u2019t be used with function components.\nUsage\nFinding the root DOM node of a class component\nCall findDOMNode\nwith a class component instance (usually, this\n) to find the DOM node it has rendered.\nclass AutoselectingInput extends Component {\ncomponentDidMount() {\nconst input = findDOMNode(this);\ninput.select()\n}\nrender() {\nreturn <input defaultValue=\"Hello\" />\n}\n}\nHere, the input\nvariable will be set to the <input>\nDOM element. This lets you do something with it. For example, when clicking \u201cShow example\u201d below mounts the input, input.select()\nselects all text in the input:\nimport { Component } from 'react'; import { findDOMNode } from 'react-dom'; class AutoselectingInput extends Component { componentDidMount() { const input = findDOMNode(this); input.select() } render() { return <input defaultValue=\"Hello\" /> } } export default AutoselectingInput;\nAlternatives\nReading component\u2019s own DOM node from a ref\nCode using findDOMNode\nis fragile because the connection between the JSX node and the code manipulating the corresponding DOM node is not explicit. For example, try wrapping this <input />\ninto a <div>\n:\nimport { Component } from 'react'; import { findDOMNode } from 'react-dom'; class AutoselectingInput extends Component { componentDidMount() { const input = findDOMNode(this); input.select() } render() { return <input defaultValue=\"Hello\" /> } } export default AutoselectingInput;\nThis will break the code because now, findDOMNode(this)\nfinds the <div>\nDOM node, but the code expects an <input>\nDOM node. To avoid these kinds of problems, use createRef\nto manage a specific DOM node.\nIn this example, findDOMNode\nis no longer used. Instead, inputRef = createRef(null)\nis defined as an instance field on the class. To read the DOM node from it, you can use this.inputRef.current\n. To attach it to the JSX, you render <input ref={this.inputRef} />\n. This connects the code using the DOM node to its JSX:\nimport { createRef, Component } from 'react'; class AutoselectingInput extends Component { inputRef = createRef(null); componentDidMount() { const input = this.inputRef.current; input.select() } render() { return ( <input ref={this.inputRef} defaultValue=\"Hello\" /> ); } } export default AutoselectingInput;\nIn modern React without class components, the equivalent code would call useRef\ninstead:\nimport { useRef, useEffect } from 'react'; export default function AutoselectingInput() { const inputRef = useRef(null); useEffect(() => { const input = inputRef.current; input.select(); }, []); return <input ref={inputRef} defaultValue=\"Hello\" /> }\nRead more about manipulating the DOM with refs.\nReading a child component\u2019s DOM node from a forwarded ref\nIn this example, findDOMNode(this)\nfinds a DOM node that belongs to another component. The AutoselectingInput\nrenders MyInput\n, which is your own component that renders a browser <input>\n.\nimport { Component } from 'react'; import { findDOMNode } from 'react-dom'; import MyInput from './MyInput.js'; class AutoselectingInput extends Component { componentDidMount() { const input = findDOMNode(this); input.select() } render() { return <MyInput />; } } export default AutoselectingInput;\nNotice that calling findDOMNode(this)\ninside AutoselectingInput\nstill gives you the DOM <input>\n\u2014even though the JSX for this <input>\nis hidden inside the MyInput\ncomponent. This seems convenient for the above example, but it leads to fragile code. Imagine that you wanted to edit MyInput\nlater and add a wrapper <div>\naround it. This would break the code of AutoselectingInput\n(which expects to find an <input>\n).\nTo replace findDOMNode\nin this example, the two components need to coordinate:\nAutoSelectingInput\nshould declare a ref, like in the earlier example, and pass it to<MyInput>\n.MyInput\nshould be declared withforwardRef\nto take that ref and forward it down to the<input>\nnode.\nThis version does that, so it no longer needs findDOMNode\n:\nimport { createRef, Component } from 'react'; import MyInput from './MyInput.js'; class AutoselectingInput extends Component { inputRef = createRef(null); componentDidMount() { const input = this.inputRef.current; input.select() } render() { return ( <MyInput ref={this.inputRef} /> ); } } export default AutoselectingInput;\nHere is how this code would look like with function components instead of classes:\nimport { useRef, useEffect } from 'react'; import MyInput from './MyInput.js'; export default function AutoselectingInput() { const inputRef = useRef(null); useEffect(() => { const input = inputRef.current; input.select(); }, []); return <MyInput ref={inputRef} defaultValue=\"Hello\" /> }\nAdding a wrapper <div>\nelement\nSometimes a component needs to know the position and size of its children. This makes it tempting to find the children with findDOMNode(this)\n, and then use DOM methods like getBoundingClientRect\nfor measurements.\nThere is currently no direct equivalent for this use case, which is why findDOMNode\nis deprecated but is not yet removed completely from React. In the meantime, you can try rendering a wrapper <div>\nnode around the content as a workaround, and getting a ref to that node. However, extra wrappers can break styling.\n<div ref={someRef}>\n{children}\n</div>\nThis also applies to focusing and scrolling to arbitrary children."
  },
  {
    "source": "https://react.dev/reference/react-dom/flushSync",
    "title": "flushSync \u2013 React",
    "text": "flushSync\nflushSync\nlets you force React to flush any updates inside the provided callback synchronously. This ensures that the DOM is updated immediately.\nflushSync(callback)\nReference\nflushSync(callback)\nCall flushSync\nto force React to flush any pending work and update the DOM synchronously.\nimport { flushSync } from 'react-dom';\nflushSync(() => {\nsetSomething(123);\n});\nMost of the time, flushSync\ncan be avoided. Use flushSync\nas last resort.\nParameters\ncallback\n: A function. React will immediately call this callback and flush any updates it contains synchronously. It may also flush any pending updates, or Effects, or updates inside of Effects. If an update suspends as a result of thisflushSync\ncall, the fallbacks may be re-shown.\nReturns\nflushSync\nreturns undefined\n.\nCaveats\nflushSync\ncan significantly hurt performance. Use sparingly.flushSync\nmay force pending Suspense boundaries to show theirfallback\nstate.flushSync\nmay run pending Effects and synchronously apply any updates they contain before returning.flushSync\nmay flush updates outside the callback when necessary to flush the updates inside the callback. For example, if there are pending updates from a click, React may flush those before flushing the updates inside the callback.\nUsage\nFlushing updates for third-party integrations\nWhen integrating with third-party code such as browser APIs or UI libraries, it may be necessary to force React to flush updates. Use flushSync\nto force React to flush any state updates inside the callback synchronously:\nflushSync(() => {\nsetSomething(123);\n});\n// By this line, the DOM is updated.\nThis ensures that, by the time the next line of code runs, React has already updated the DOM.\nUsing flushSync\nis uncommon, and using it often can significantly hurt the performance of your app. If your app only uses React APIs, and does not integrate with third-party libraries, flushSync\nshould be unnecessary.\nHowever, it can be helpful for integrating with third-party code like browser APIs.\nSome browser APIs expect results inside of callbacks to be written to the DOM synchronously, by the end of the callback, so the browser can do something with the rendered DOM. In most cases, React handles this for you automatically. But in some cases it may be necessary to force a synchronous update.\nFor example, the browser onbeforeprint\nAPI allows you to change the page immediately before the print dialog opens. This is useful for applying custom print styles that allow the document to display better for printing. In the example below, you use flushSync\ninside of the onbeforeprint\ncallback to immediately \u201cflush\u201d the React state to the DOM. Then, by the time the print dialog opens, isPrinting\ndisplays \u201cyes\u201d:\nimport { useState, useEffect } from 'react'; import { flushSync } from 'react-dom'; export default function PrintApp() { const [isPrinting, setIsPrinting] = useState(false); useEffect(() => { function handleBeforePrint() { flushSync(() => { setIsPrinting(true); }) } function handleAfterPrint() { setIsPrinting(false); } window.addEventListener('beforeprint', handleBeforePrint); window.addEventListener('afterprint', handleAfterPrint); return () => { window.removeEventListener('beforeprint', handleBeforePrint); window.removeEventListener('afterprint', handleAfterPrint); } }, []); return ( <> <h1>isPrinting: {isPrinting ? 'yes' : 'no'}</h1> <button onClick={() => window.print()}> Print </button> </> ); }\nWithout flushSync\n, the print dialog will display isPrinting\nas \u201cno\u201d. This is because React batches the updates asynchronously and the print dialog is displayed before the state is updated."
  },
  {
    "source": "https://react.dev/reference/react-dom/hooks",
    "title": "Built-in React DOM Hooks \u2013 React",
    "text": "Built-in React DOM Hooks\nThe react-dom\npackage contains Hooks that are only supported for web applications (which run in the browser DOM environment). These Hooks are not supported in non-browser environments like iOS, Android, or Windows applications. If you are looking for Hooks that are supported in web browsers and other environments see the React Hooks page. This page lists all the Hooks in the react-dom\npackage.\nForm Hooks\nForms let you create interactive controls for submitting information. To manage forms in your components, use one of these Hooks:\nuseFormStatus\nallows you to make updates to the UI based on the status of the a form.\nfunction Form({ action }) {\nasync function increment(n) {\nreturn n + 1;\n}\nconst [count, incrementFormAction] = useActionState(increment, 0);\nreturn (\n<form action={action}>\n<button formAction={incrementFormAction}>Count: {count}</button>\n<Button />\n</form>\n);\n}\nfunction Button() {\nconst { pending } = useFormStatus();\nreturn (\n<button disabled={pending} type=\"submit\">\nSubmit\n</button>\n);\n}"
  },
  {
    "source": "https://react.dev/reference/react/useActionState",
    "title": "useActionState \u2013 React",
    "text": "useActionState\nuseActionState\nis a Hook that allows you to update state based on the result of a form action.\nconst [state, formAction, isPending] = useActionState(fn, initialState, permalink?);\nReference\nuseActionState(action, initialState, permalink?)\nCall useActionState\nat the top level of your component to create component state that is updated when a form action is invoked. You pass useActionState\nan existing form action function as well as an initial state, and it returns a new action that you use in your form, along with the latest form state and whether the Action is still pending. The latest form state is also passed to the function that you provided.\nimport { useActionState } from \"react\";\nasync function increment(previousState, formData) {\nreturn previousState + 1;\n}\nfunction StatefulForm({}) {\nconst [state, formAction] = useActionState(increment, 0);\nreturn (\n<form>\n{state}\n<button formAction={formAction}>Increment</button>\n</form>\n)\n}\nThe form state is the value returned by the action when the form was last submitted. If the form has not yet been submitted, it is the initial state that you pass.\nIf used with a Server Function, useActionState\nallows the server\u2019s response from submitting the form to be shown even before hydration has completed.\nParameters\nfn\n: The function to be called when the form is submitted or button pressed. When the function is called, it will receive the previous state of the form (initially theinitialState\nthat you pass, subsequently its previous return value) as its initial argument, followed by the arguments that a form action normally receives.initialState\n: The value you want the state to be initially. It can be any serializable value. This argument is ignored after the action is first invoked.- optional\npermalink\n: A string containing the unique page URL that this form modifies. For use on pages with dynamic content (eg: feeds) in conjunction with progressive enhancement: iffn\nis a server function and the form is submitted before the JavaScript bundle loads, the browser will navigate to the specified permalink URL, rather than the current page\u2019s URL. Ensure that the same form component is rendered on the destination page (including the same actionfn\nandpermalink\n) so that React knows how to pass the state through. Once the form has been hydrated, this parameter has no effect.\nReturns\nuseActionState\nreturns an array with the following values:\n- The current state. During the first render, it will match the\ninitialState\nyou have passed. After the action is invoked, it will match the value returned by the action. - A new action that you can pass as the\naction\nprop to yourform\ncomponent orformAction\nprop to anybutton\ncomponent within the form. - The\nisPending\nflag that tells you whether there is a pending Transition.\nCaveats\n- When used with a framework that supports React Server Components,\nuseActionState\nlets you make forms interactive before JavaScript has executed on the client. When used without Server Components, it is equivalent to component local state. - The function passed to\nuseActionState\nreceives an extra argument, the previous or initial state, as its first argument. This makes its signature different than if it were used directly as a form action without usinguseActionState\n.\nUsage\nUsing information returned by a form action\nCall useActionState\nat the top level of your component to access the return value of an action from the last time a form was submitted.\nimport { useActionState } from 'react';\nimport { action } from './actions.js';\nfunction MyComponent() {\nconst [state, formAction] = useActionState(action, null);\n// ...\nreturn (\n<form action={formAction}>\n{/* ... */}\n</form>\n);\n}\nuseActionState\nreturns an array with the following items:\n- The current state of the form, which is initially set to the initial state you provided, and after the form is submitted is set to the return value of the action you provided.\n- A new action that you pass to\n<form>\nas itsaction\nprop. - A pending state that you can utilise whilst your action is processing.\nWhen the form is submitted, the action function that you provided will be called. Its return value will become the new current state of the form.\nThe action that you provide will also receive a new first argument, namely the current state of the form. The first time the form is submitted, this will be the initial state you provided, while with subsequent submissions, it will be the return value from the last time the action was called. The rest of the arguments are the same as if useActionState\nhad not been used.\nfunction action(currentState, formData) {\n// ...\nreturn 'next state';\n}\nExample 1 of 2: Display form errors\nTo display messages such as an error message or toast that\u2019s returned by a Server Function, wrap the action in a call to useActionState\n.\nimport { useActionState, useState } from \"react\"; import { addToCart } from \"./actions.js\"; function AddToCartForm({itemID, itemTitle}) { const [message, formAction, isPending] = useActionState(addToCart, null); return ( <form action={formAction}> <h2>{itemTitle}</h2> <input type=\"hidden\" name=\"itemID\" value={itemID} /> <button type=\"submit\">Add to Cart</button> {isPending ? \"Loading...\" : message} </form> ); } export default function App() { return ( <> <AddToCartForm itemID=\"1\" itemTitle=\"JavaScript: The Definitive Guide\" /> <AddToCartForm itemID=\"2\" itemTitle=\"JavaScript: The Good Parts\" /> </> ) }\nTroubleshooting\nMy action can no longer read the submitted form data\nWhen you wrap an action with useActionState\n, it gets an extra argument as its first argument. The submitted form data is therefore its second argument instead of its first as it would usually be. The new first argument that gets added is the current state of the form.\nfunction action(currentState, formData) {\n// ...\n}"
  },
  {
    "source": "https://react.dev/reference/react-dom/hooks/useFormStatus",
    "title": "useFormStatus \u2013 React",
    "text": "useFormStatus\nuseFormStatus\nis a Hook that gives you status information of the last form submission.\nconst { pending, data, method, action } = useFormStatus();\nReference\nuseFormStatus()\nThe useFormStatus\nHook provides status information of the last form submission.\nimport { useFormStatus } from \"react-dom\";\nimport action from './actions';\nfunction Submit() {\nconst status = useFormStatus();\nreturn <button disabled={status.pending}>Submit</button>\n}\nexport default function App() {\nreturn (\n<form action={action}>\n<Submit />\n</form>\n);\n}\nTo get status information, the Submit\ncomponent must be rendered within a <form>\n. The Hook returns information like the pending\nproperty which tells you if the form is actively submitting.\nIn the above example, Submit\nuses this information to disable <button>\npresses while the form is submitting.\nParameters\nuseFormStatus\ndoes not take any parameters.\nReturns\nA status\nobject with the following properties:\n-\npending\n: A boolean. Iftrue\n, this means the parent<form>\nis pending submission. Otherwise,false\n. -\ndata\n: An object implementing theFormData interface\nthat contains the data the parent<form>\nis submitting. If there is no active submission or no parent<form>\n, it will benull\n. -\nmethod\n: A string value of either'get'\nor'post'\n. This represents whether the parent<form>\nis submitting with either aGET\norPOST\nHTTP method. By default, a<form>\nwill use theGET\nmethod and can be specified by themethod\nproperty.\naction\n: A reference to the function passed to theaction\nprop on the parent<form>\n. If there is no parent<form>\n, the property isnull\n. If there is a URI value provided to theaction\nprop, or noaction\nprop specified,status.action\nwill benull\n.\nCaveats\n- The\nuseFormStatus\nHook must be called from a component that is rendered inside a<form>\n. useFormStatus\nwill only return status information for a parent<form>\n. It will not return status information for any<form>\nrendered in that same component or children components.\nUsage\nDisplay a pending state during form submission\nTo display a pending state while a form is submitting, you can call the useFormStatus\nHook in a component rendered in a <form>\nand read the pending\nproperty returned.\nHere, we use the pending\nproperty to indicate the form is submitting.\nimport { useFormStatus } from \"react-dom\"; import { submitForm } from \"./actions.js\"; function Submit() { const { pending } = useFormStatus(); return ( <button type=\"submit\" disabled={pending}> {pending ? \"Submitting...\" : \"Submit\"} </button> ); } function Form({ action }) { return ( <form action={action}> <Submit /> </form> ); } export default function App() { return <Form action={submitForm} />; }\nRead the form data being submitted\nYou can use the data\nproperty of the status information returned from useFormStatus\nto display what data is being submitted by the user.\nHere, we have a form where users can request a username. We can use useFormStatus\nto display a temporary status message confirming what username they have requested.\nimport {useState, useMemo, useRef} from 'react'; import {useFormStatus} from 'react-dom'; export default function UsernameForm() { const {pending, data} = useFormStatus(); return ( <div> <h3>Request a Username: </h3> <input type=\"text\" name=\"username\" disabled={pending}/> <button type=\"submit\" disabled={pending}> Submit </button> <br /> <p>{data ? `Requesting ${data?.get(\"username\")}...`: ''}</p> </div> ); }\nTroubleshooting\nstatus.pending\nis never true\nuseFormStatus\nwill only return status information for a parent <form>\n.\nIf the component that calls useFormStatus\nis not nested in a <form>\n, status.pending\nwill always return false\n. Verify useFormStatus\nis called in a component that is a child of a <form>\nelement.\nuseFormStatus\nwill not track the status of a <form>\nrendered in the same component. See Pitfall for more details."
  },
  {
    "source": "https://react.dev/reference/react-dom/hydrate",
    "title": "hydrate \u2013 React",
    "text": "hydrate\nhydrate\nlets you display React components inside a browser DOM node whose HTML content was previously generated by react-dom/server\nin React 17 and below.\nhydrate(reactNode, domNode, callback?)\nReference\nhydrate(reactNode, domNode, callback?)\nCall hydrate\nin React 17 and below to \u201cattach\u201d React to existing HTML that was already rendered by React in a server environment.\nimport { hydrate } from 'react-dom';\nhydrate(reactNode, domNode);\nReact will attach to the HTML that exists inside the domNode\n, and take over managing the DOM inside it. An app fully built with React will usually only have one hydrate\ncall with its root component.\nParameters\n-\nreactNode\n: The \u201cReact node\u201d used to render the existing HTML. This will usually be a piece of JSX like<App />\nwhich was rendered with aReactDOM Server\nmethod such asrenderToString(<App />)\nin React 17. -\ndomNode\n: A DOM element that was rendered as the root element on the server. -\noptional:\ncallback\n: A function. If passed, React will call it after your component is hydrated.\nReturns\nhydrate\nreturns null.\nCaveats\nhydrate\nexpects the rendered content to be identical with the server-rendered content. React can patch up differences in text content, but you should treat mismatches as bugs and fix them.- In development mode, React warns about mismatches during hydration. There are no guarantees that attribute differences will be patched up in case of mismatches. This is important for performance reasons because in most apps, mismatches are rare, and so validating all markup would be prohibitively expensive.\n- You\u2019ll likely have only one\nhydrate\ncall in your app. If you use a framework, it might do this call for you. - If your app is client-rendered with no HTML rendered already, using\nhydrate()\nis not supported. Use render() (for React 17 and below) or createRoot() (for React 18+) instead.\nUsage\nCall hydrate\nto attach a React component into a server-rendered browser DOM node.\nimport { hydrate } from 'react-dom';\nhydrate(<App />, document.getElementById('root'));\nUsing hydrate()\nto render a client-only app (an app without server-rendered HTML) is not supported. Use render()\n(in React 17 and below) or createRoot()\n(in React 18+) instead.\nHydrating server-rendered HTML\nIn React, \u201chydration\u201d is how React \u201cattaches\u201d to existing HTML that was already rendered by React in a server environment. During hydration, React will attempt to attach event listeners to the existing markup and take over rendering the app on the client.\nIn apps fully built with React, you will usually only hydrate one \u201croot\u201d, once at startup for your entire app.\nimport './styles.css'; import { hydrate } from 'react-dom'; import App from './App.js'; hydrate(<App />, document.getElementById('root'));\nUsually you shouldn\u2019t need to call hydrate\nagain or to call it in more places. From this point on, React will be managing the DOM of your application. To update the UI, your components will use state.\nFor more information on hydration, see the docs for hydrateRoot\n.\nSuppressing unavoidable hydration mismatch errors\nIf a single element\u2019s attribute or text content is unavoidably different between the server and the client (for example, a timestamp), you may silence the hydration mismatch warning.\nTo silence hydration warnings on an element, add suppressHydrationWarning={true}\n:\nexport default function App() { return ( <h1 suppressHydrationWarning={true}> Current Date: {new Date().toLocaleDateString()} </h1> ); }\nThis only works one level deep, and is intended to be an escape hatch. Don\u2019t overuse it. Unless it\u2019s text content, React still won\u2019t attempt to patch it up, so it may remain inconsistent until future updates.\nHandling different client and server content\nIf you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read a state variable like isClient\n, which you can set to true\nin an Effect:\nimport { useState, useEffect } from \"react\"; export default function App() { const [isClient, setIsClient] = useState(false); useEffect(() => { setIsClient(true); }, []); return ( <h1> {isClient ? 'Is Client' : 'Is Server'} </h1> ); }\nThis way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration."
  },
  {
    "source": "https://react.dev/reference/react-dom/preconnect",
    "title": "preconnect \u2013 React",
    "text": "preconnect\npreconnect\nlets you eagerly connect to a server that you expect to load resources from.\npreconnect(\"https://example.com\");\nReference\npreconnect(href)\nTo preconnect to a host, call the preconnect\nfunction from react-dom\n.\nimport { preconnect } from 'react-dom';\nfunction AppRoot() {\npreconnect(\"https://example.com\");\n// ...\n}\nThe preconnect\nfunction provides the browser with a hint that it should open a connection to the given server. If the browser chooses to do so, this can speed up the loading of resources from that server.\nParameters\nhref\n: a string. The URL of the server you want to connect to.\nReturns\npreconnect\nreturns nothing.\nCaveats\n- Multiple calls to\npreconnect\nwith the same server have the same effect as a single call. - In the browser, you can call\npreconnect\nin any situation: while rendering a component, in an Effect, in an event handler, and so on. - In server-side rendering or when rendering Server Components,\npreconnect\nonly has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored. - If you know the specific resources you\u2019ll need, you can call other functions instead that will start loading the resources right away.\n- There is no benefit to preconnecting to the same server the webpage itself is hosted from because it\u2019s already been connected to by the time the hint would be given.\nUsage\nPreconnecting when rendering\nCall preconnect\nwhen rendering a component if you know that its children will load external resources from that host.\nimport { preconnect } from 'react-dom';\nfunction AppRoot() {\npreconnect(\"https://example.com\");\nreturn ...;\n}\nPreconnecting in an event handler\nCall preconnect\nin an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.\nimport { preconnect } from 'react-dom';\nfunction CallToAction() {\nconst onClick = () => {\npreconnect('http://example.com');\nstartWizard();\n}\nreturn (\n<button onClick={onClick}>Start Wizard</button>\n);\n}"
  },
  {
    "source": "https://react.dev/reference/react-dom/prefetchDNS",
    "title": "prefetchDNS \u2013 React",
    "text": "prefetchDNS\nprefetchDNS\nlets you eagerly look up the IP of a server that you expect to load resources from.\nprefetchDNS(\"https://example.com\");\nReference\nprefetchDNS(href)\nTo look up a host, call the prefetchDNS\nfunction from react-dom\n.\nimport { prefetchDNS } from 'react-dom';\nfunction AppRoot() {\nprefetchDNS(\"https://example.com\");\n// ...\n}\nThe prefetchDNS function provides the browser with a hint that it should look up the IP address of a given server. If the browser chooses to do so, this can speed up the loading of resources from that server.\nParameters\nhref\n: a string. The URL of the server you want to connect to.\nReturns\nprefetchDNS\nreturns nothing.\nCaveats\n- Multiple calls to\nprefetchDNS\nwith the same server have the same effect as a single call. - In the browser, you can call\nprefetchDNS\nin any situation: while rendering a component, in an Effect, in an event handler, and so on. - In server-side rendering or when rendering Server Components,\nprefetchDNS\nonly has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored. - If you know the specific resources you\u2019ll need, you can call other functions instead that will start loading the resources right away.\n- There is no benefit to prefetching the same server the webpage itself is hosted from because it\u2019s already been looked up by the time the hint would be given.\n- Compared with\npreconnect\n,prefetchDNS\nmay be better if you are speculatively connecting to a large number of domains, in which case the overhead of preconnections might outweigh the benefit.\nUsage\nPrefetching DNS when rendering\nCall prefetchDNS\nwhen rendering a component if you know that its children will load external resources from that host.\nimport { prefetchDNS } from 'react-dom';\nfunction AppRoot() {\nprefetchDNS(\"https://example.com\");\nreturn ...;\n}\nPrefetching DNS in an event handler\nCall prefetchDNS\nin an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.\nimport { prefetchDNS } from 'react-dom';\nfunction CallToAction() {\nconst onClick = () => {\nprefetchDNS('http://example.com');\nstartWizard();\n}\nreturn (\n<button onClick={onClick}>Start Wizard</button>\n);\n}"
  },
  {
    "source": "https://react.dev/reference/react-dom/preinit",
    "title": "preinit \u2013 React",
    "text": "preinit\npreinit\nlets you eagerly fetch and evaluate a stylesheet or external script.\npreinit(\"https://example.com/script.js\", {as: \"script\"});\nReference\npreinit(href, options)\nTo preinit a script or stylesheet, call the preinit\nfunction from react-dom\n.\nimport { preinit } from 'react-dom';\nfunction AppRoot() {\npreinit(\"https://example.com/script.js\", {as: \"script\"});\n// ...\n}\nThe preinit\nfunction provides the browser with a hint that it should start downloading and executing the given resource, which can save time. Scripts that you preinit\nare executed when they finish downloading. Stylesheets that you preinit are inserted into the document, which causes them to go into effect right away.\nParameters\nhref\n: a string. The URL of the resource you want to download and execute.options\n: an object. It contains the following properties:as\n: a required string. The type of resource. Its possible values arescript\nandstyle\n.precedence\n: a string. Required with stylesheets. Says where to insert the stylesheet relative to others. Stylesheets with higher precedence can override those with lower precedence. The possible values arereset\n,low\n,medium\n,high\n.crossOrigin\n: a string. The CORS policy to use. Its possible values areanonymous\nanduse-credentials\n. It is required whenas\nis set to\"fetch\"\n.integrity\n: a string. A cryptographic hash of the resource, to verify its authenticity.nonce\n: a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy.fetchPriority\n: a string. Suggests a relative priority for fetching the resource. The possible values areauto\n(the default),high\n, andlow\n.\nReturns\npreinit\nreturns nothing.\nCaveats\n- Multiple calls to\npreinit\nwith the samehref\nhave the same effect as a single call. - In the browser, you can call\npreinit\nin any situation: while rendering a component, in an Effect, in an event handler, and so on. - In server-side rendering or when rendering Server Components,\npreinit\nonly has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.\nUsage\nPreiniting when rendering\nCall preinit\nwhen rendering a component if you know that it or its children will use a specific resource, and you\u2019re OK with the resource being evaluated and thereby taking effect immediately upon being downloaded.\nExample 1 of 2: Preiniting an external script\nimport { preinit } from 'react-dom';\nfunction AppRoot() {\npreinit(\"https://example.com/script.js\", {as: \"script\"});\nreturn ...;\n}\nIf you want the browser to download the script but not to execute it right away, use preload\ninstead. If you want to load an ESM module, use preinitModule\n.\nPreiniting in an event handler\nCall preinit\nin an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.\nimport { preinit } from 'react-dom';\nfunction CallToAction() {\nconst onClick = () => {\npreinit(\"https://example.com/wizardStyles.css\", {as: \"style\"});\nstartWizard();\n}\nreturn (\n<button onClick={onClick}>Start Wizard</button>\n);\n}"
  },
  {
    "source": "https://react.dev/reference/react-dom/preinitModule",
    "title": "preinitModule \u2013 React",
    "text": "preinitModule\npreinitModule\nlets you eagerly fetch and evaluate an ESM module.\npreinitModule(\"https://example.com/module.js\", {as: \"script\"});\nReference\npreinitModule(href, options)\nTo preinit an ESM module, call the preinitModule\nfunction from react-dom\n.\nimport { preinitModule } from 'react-dom';\nfunction AppRoot() {\npreinitModule(\"https://example.com/module.js\", {as: \"script\"});\n// ...\n}\nThe preinitModule\nfunction provides the browser with a hint that it should start downloading and executing the given module, which can save time. Modules that you preinit\nare executed when they finish downloading.\nParameters\nhref\n: a string. The URL of the module you want to download and execute.options\n: an object. It contains the following properties:as\n: a required string. It must be'script'\n.crossOrigin\n: a string. The CORS policy to use. Its possible values areanonymous\nanduse-credentials\n.integrity\n: a string. A cryptographic hash of the module, to verify its authenticity.nonce\n: a string. A cryptographic nonce to allow the module when using a strict Content Security Policy.\nReturns\npreinitModule\nreturns nothing.\nCaveats\n- Multiple calls to\npreinitModule\nwith the samehref\nhave the same effect as a single call. - In the browser, you can call\npreinitModule\nin any situation: while rendering a component, in an Effect, in an event handler, and so on. - In server-side rendering or when rendering Server Components,\npreinitModule\nonly has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.\nUsage\nPreloading when rendering\nCall preinitModule\nwhen rendering a component if you know that it or its children will use a specific module and you\u2019re OK with the module being evaluated and thereby taking effect immediately upon being downloaded.\nimport { preinitModule } from 'react-dom';\nfunction AppRoot() {\npreinitModule(\"https://example.com/module.js\", {as: \"script\"});\nreturn ...;\n}\nIf you want the browser to download the module but not to execute it right away, use preloadModule\ninstead. If you want to preinit a script that isn\u2019t an ESM module, use preinit\n.\nPreloading in an event handler\nCall preinitModule\nin an event handler before transitioning to a page or state where the module will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.\nimport { preinitModule } from 'react-dom';\nfunction CallToAction() {\nconst onClick = () => {\npreinitModule(\"https://example.com/module.js\", {as: \"script\"});\nstartWizard();\n}\nreturn (\n<button onClick={onClick}>Start Wizard</button>\n);\n}"
  },
  {
    "source": "https://react.dev/reference/react-dom/preload",
    "title": "preload \u2013 React",
    "text": "preload\npreload\nlets you eagerly fetch a resource such as a stylesheet, font, or external script that you expect to use.\npreload(\"https://example.com/font.woff2\", {as: \"font\"});\nReference\npreload(href, options)\nTo preload a resource, call the preload\nfunction from react-dom\n.\nimport { preload } from 'react-dom';\nfunction AppRoot() {\npreload(\"https://example.com/font.woff2\", {as: \"font\"});\n// ...\n}\nThe preload\nfunction provides the browser with a hint that it should start downloading the given resource, which can save time.\nParameters\nhref\n: a string. The URL of the resource you want to download.options\n: an object. It contains the following properties:as\n: a required string. The type of resource. Its possible values areaudio\n,document\n,embed\n,fetch\n,font\n,image\n,object\n,script\n,style\n,track\n,video\n,worker\n.crossOrigin\n: a string. The CORS policy to use. Its possible values areanonymous\nanduse-credentials\n. It is required whenas\nis set to\"fetch\"\n.referrerPolicy\n: a string. The Referrer header to send when fetching. Its possible values areno-referrer-when-downgrade\n(the default),no-referrer\n,origin\n,origin-when-cross-origin\n, andunsafe-url\n.integrity\n: a string. A cryptographic hash of the resource, to verify its authenticity.type\n: a string. The MIME type of the resource.nonce\n: a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy.fetchPriority\n: a string. Suggests a relative priority for fetching the resource. The possible values areauto\n(the default),high\n, andlow\n.imageSrcSet\n: a string. For use only withas: \"image\"\n. Specifies the source set of the image.imageSizes\n: a string. For use only withas: \"image\"\n. Specifies the sizes of the image.\nReturns\npreload\nreturns nothing.\nCaveats\n- Multiple equivalent calls to\npreload\nhave the same effect as a single call. Calls topreload\nare considered equivalent according to the following rules:- Two calls are equivalent if they have the same\nhref\n, except: - If\nas\nis set toimage\n, two calls are equivalent if they have the samehref\n,imageSrcSet\n, andimageSizes\n.\n- Two calls are equivalent if they have the same\n- In the browser, you can call\npreload\nin any situation: while rendering a component, in an Effect, in an event handler, and so on. - In server-side rendering or when rendering Server Components,\npreload\nonly has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.\nUsage\nPreloading when rendering\nCall preload\nwhen rendering a component if you know that it or its children will use a specific resource.\nExample 1 of 4: Preloading an external script\nimport { preload } from 'react-dom';\nfunction AppRoot() {\npreload(\"https://example.com/script.js\", {as: \"script\"});\nreturn ...;\n}\nIf you want the browser to start executing the script immediately (rather than just downloading it), use preinit\ninstead. If you want to load an ESM module, use preloadModule\n.\nPreloading in an event handler\nCall preload\nin an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.\nimport { preload } from 'react-dom';\nfunction CallToAction() {\nconst onClick = () => {\npreload(\"https://example.com/wizardStyles.css\", {as: \"style\"});\nstartWizard();\n}\nreturn (\n<button onClick={onClick}>Start Wizard</button>\n);\n}"
  },
  {
    "source": "https://react.dev/reference/react-dom/preloadModule",
    "title": "preloadModule \u2013 React",
    "text": "preloadModule\npreloadModule\nlets you eagerly fetch an ESM module that you expect to use.\npreloadModule(\"https://example.com/module.js\", {as: \"script\"});\nReference\npreloadModule(href, options)\nTo preload an ESM module, call the preloadModule\nfunction from react-dom\n.\nimport { preloadModule } from 'react-dom';\nfunction AppRoot() {\npreloadModule(\"https://example.com/module.js\", {as: \"script\"});\n// ...\n}\nThe preloadModule\nfunction provides the browser with a hint that it should start downloading the given module, which can save time.\nParameters\nhref\n: a string. The URL of the module you want to download.options\n: an object. It contains the following properties:as\n: a required string. It must be'script'\n.crossOrigin\n: a string. The CORS policy to use. Its possible values areanonymous\nanduse-credentials\n.integrity\n: a string. A cryptographic hash of the module, to verify its authenticity.nonce\n: a string. A cryptographic nonce to allow the module when using a strict Content Security Policy.\nReturns\npreloadModule\nreturns nothing.\nCaveats\n- Multiple calls to\npreloadModule\nwith the samehref\nhave the same effect as a single call. - In the browser, you can call\npreloadModule\nin any situation: while rendering a component, in an Effect, in an event handler, and so on. - In server-side rendering or when rendering Server Components,\npreloadModule\nonly has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.\nUsage\nPreloading when rendering\nCall preloadModule\nwhen rendering a component if you know that it or its children will use a specific module.\nimport { preloadModule } from 'react-dom';\nfunction AppRoot() {\npreloadModule(\"https://example.com/module.js\", {as: \"script\"});\nreturn ...;\n}\nIf you want the browser to start executing the module immediately (rather than just downloading it), use preinitModule\ninstead. If you want to load a script that isn\u2019t an ESM module, use preload\n.\nPreloading in an event handler\nCall preloadModule\nin an event handler before transitioning to a page or state where the module will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.\nimport { preloadModule } from 'react-dom';\nfunction CallToAction() {\nconst onClick = () => {\npreloadModule(\"https://example.com/module.js\", {as: \"script\"});\nstartWizard();\n}\nreturn (\n<button onClick={onClick}>Start Wizard</button>\n);\n}"
  },
  {
    "source": "https://react.dev/reference/react-dom/render",
    "title": "render \u2013 React",
    "text": "render\nrender\nrenders a piece of JSX (\u201cReact node\u201d) into a browser DOM node.\nrender(reactNode, domNode, callback?)\nReference\nrender(reactNode, domNode, callback?)\nCall render\nto display a React component inside a browser DOM element.\nimport { render } from 'react-dom';\nconst domNode = document.getElementById('root');\nrender(<App />, domNode);\nReact will display <App />\nin the domNode\n, and take over managing the DOM inside it.\nAn app fully built with React will usually only have one render\ncall with its root component. A page that uses \u201csprinkles\u201d of React for parts of the page may have as many render\ncalls as needed.\nParameters\n-\nreactNode\n: A React node that you want to display. This will usually be a piece of JSX like<App />\n, but you can also pass a React element constructed withcreateElement()\n, a string, a number,null\n, orundefined\n. -\ndomNode\n: A DOM element. React will display thereactNode\nyou pass inside this DOM element. From this moment, React will manage the DOM inside thedomNode\nand update it when your React tree changes. -\noptional\ncallback\n: A function. If passed, React will call it after your component is placed into the DOM.\nReturns\nrender\nusually returns null\n. However, if the reactNode\nyou pass is a class component, then it will return an instance of that component.\nCaveats\n-\nIn React 18,\nrender\nwas replaced bycreateRoot\n. Please usecreateRoot\nfor React 18 and beyond. -\nThe first time you call\nrender\n, React will clear all the existing HTML content inside thedomNode\nbefore rendering the React component into it. If yourdomNode\ncontains HTML generated by React on the server or during the build, usehydrate()\ninstead, which attaches the event handlers to the existing HTML. -\nIf you call\nrender\non the samedomNode\nmore than once, React will update the DOM as necessary to reflect the latest JSX you passed. React will decide which parts of the DOM can be reused and which need to be recreated by \u201cmatching it up\u201d with the previously rendered tree. Callingrender\non the samedomNode\nagain is similar to calling theset\nfunction on the root component: React avoids unnecessary DOM updates. -\nIf your app is fully built with React, you\u2019ll likely have only one\nrender\ncall in your app. (If you use a framework, it might do this call for you.) When you want to render a piece of JSX in a different part of the DOM tree that isn\u2019t a child of your component (for example, a modal or a tooltip), usecreatePortal\ninstead ofrender\n.\nUsage\nCall render\nto display a React component inside a browser DOM node.\nimport { render } from 'react-dom';\nimport App from './App.js';\nrender(<App />, document.getElementById('root'));\nRendering the root component\nIn apps fully built with React, you will usually only do this once at startup\u2014to render the \u201croot\u201d component.\nimport './styles.css'; import { render } from 'react-dom'; import App from './App.js'; render(<App />, document.getElementById('root'));\nUsually you shouldn\u2019t need to call render\nagain or to call it in more places. From this point on, React will be managing the DOM of your application. To update the UI, your components will use state.\nRendering multiple roots\nIf your page isn\u2019t fully built with React, call render\nfor each top-level piece of UI managed by React.\nimport './styles.css'; import { render } from 'react-dom'; import { Comments, Navigation } from './Components.js'; render( <Navigation />, document.getElementById('navigation') ); render( <Comments />, document.getElementById('comments') );\nYou can destroy the rendered trees with unmountComponentAtNode()\n.\nUpdating the rendered tree\nYou can call render\nmore than once on the same DOM node. As long as the component tree structure matches up with what was previously rendered, React will preserve the state. Notice how you can type in the input, which means that the updates from repeated render\ncalls every second are not destructive:\nimport { render } from 'react-dom'; import './styles.css'; import App from './App.js'; let i = 0; setInterval(() => { render( <App counter={i} />, document.getElementById('root') ); i++; }, 1000);\nIt is uncommon to call render\nmultiple times. Usually, you\u2019ll update state inside your components instead."
  },
  {
    "source": "https://react.dev/reference/react-dom/server",
    "title": "Server React DOM APIs \u2013 React",
    "text": "Server React DOM APIs\nThe react-dom/server\nAPIs let you server-side render React components to HTML. These APIs are only used on the server at the top level of your app to generate the initial HTML. A framework may call them for you. Most of your components don\u2019t need to import or use them.\nServer APIs for Node.js Streams\nThese methods are only available in the environments with Node.js Streams:\nrenderToPipeableStream\nrenders a React tree to a pipeable Node.js Stream.\nServer APIs for Web Streams\nThese methods are only available in the environments with Web Streams, which includes browsers, Deno, and some modern edge runtimes:\nrenderToReadableStream\nrenders a React tree to a Readable Web Stream.\nLegacy Server APIs for non-streaming environments\nThese methods can be used in the environments that don\u2019t support streams:\nrenderToString\nrenders a React tree to a string.renderToStaticMarkup\nrenders a non-interactive React tree to a string.\nThey have limited functionality compared to the streaming APIs."
  },
  {
    "source": "https://react.dev/reference/react-dom/server/renderToNodeStream",
    "title": "renderToNodeStream \u2013 React",
    "text": "renderToNodeStream\nrenderToNodeStream\nrenders a React tree to a Node.js Readable Stream.\nconst stream = renderToNodeStream(reactNode, options?)\nReference\nrenderToNodeStream(reactNode, options?)\nOn the server, call renderToNodeStream\nto get a Node.js Readable Stream which you can pipe into the response.\nimport { renderToNodeStream } from 'react-dom/server';\nconst stream = renderToNodeStream(<App />);\nstream.pipe(response);\nOn the client, call hydrateRoot\nto make the server-generated HTML interactive.\nParameters\n-\nreactNode\n: A React node you want to render to HTML. For example, a JSX element like<App />\n. -\noptional\noptions\n: An object for server render.- optional\nidentifierPrefix\n: A string prefix React uses for IDs generated byuseId\n. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot\n.\n- optional\nReturns\nA Node.js Readable Stream that outputs an HTML string.\nCaveats\n-\nThis method will wait for all Suspense boundaries to complete before returning any output.\n-\nAs of React 18, this method buffers all of its output, so it doesn\u2019t actually provide any streaming benefits. This is why it\u2019s recommended that you migrate to\nrenderToPipeableStream\ninstead. -\nThe returned stream is a byte stream encoded in utf-8. If you need a stream in another encoding, take a look at a project like iconv-lite, which provides transform streams for transcoding text.\nUsage\nRendering a React tree as HTML to a Node.js Readable Stream\nCall renderToNodeStream\nto get a Node.js Readable Stream which you can pipe to your server response:\nimport { renderToNodeStream } from 'react-dom/server';\n// The route handler syntax depends on your backend framework\napp.use('/', (request, response) => {\nconst stream = renderToNodeStream(<App />);\nstream.pipe(response);\n});\nThe stream will produce the initial non-interactive HTML output of your React components. On the client, you will need to call hydrateRoot\nto hydrate that server-generated HTML and make it interactive."
  },
  {
    "source": "https://react.dev/reference/react-dom/server/renderToPipeableStream",
    "title": "renderToPipeableStream \u2013 React",
    "text": "renderToPipeableStream\nrenderToPipeableStream\nrenders a React tree to a pipeable Node.js Stream.\nconst { pipe, abort } = renderToPipeableStream(reactNode, options?)\n- Reference\n- Usage\n- Rendering a React tree as HTML to a Node.js Stream\n- Streaming more content as it loads\n- Specifying what goes into the shell\n- Logging crashes on the server\n- Recovering from errors inside the shell\n- Recovering from errors outside the shell\n- Setting the status code\n- Handling different errors in different ways\n- Waiting for all content to load for crawlers and static generation\n- Aborting server rendering\nReference\nrenderToPipeableStream(reactNode, options?)\nCall renderToPipeableStream\nto render your React tree as HTML into a Node.js Stream.\nimport { renderToPipeableStream } from 'react-dom/server';\nconst { pipe } = renderToPipeableStream(<App />, {\nbootstrapScripts: ['/main.js'],\nonShellReady() {\nresponse.setHeader('content-type', 'text/html');\npipe(response);\n}\n});\nOn the client, call hydrateRoot\nto make the server-generated HTML interactive.\nParameters\n-\nreactNode\n: A React node you want to render to HTML. For example, a JSX element like<App />\n. It is expected to represent the entire document, so theApp\ncomponent should render the<html>\ntag. -\noptional\noptions\n: An object with streaming options.- optional\nbootstrapScriptContent\n: If specified, this string will be placed in an inline<script>\ntag. - optional\nbootstrapScripts\n: An array of string URLs for the<script>\ntags to emit on the page. Use this to include the<script>\nthat callshydrateRoot\n. Omit it if you don\u2019t want to run React on the client at all. - optional\nbootstrapModules\n: LikebootstrapScripts\n, but emits<script type=\"module\">\ninstead. - optional\nidentifierPrefix\n: A string prefix React uses for IDs generated byuseId\n. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot\n. - optional\nnamespaceURI\n: A string with the root namespace URI for the stream. Defaults to regular HTML. Pass'http://www.w3.org/2000/svg'\nfor SVG or'http://www.w3.org/1998/Math/MathML'\nfor MathML. - optional\nnonce\n: Anonce\nstring to allow scripts forscript-src\nContent-Security-Policy. - optional\nonAllReady\n: A callback that fires when all rendering is complete, including both the shell and all additional content. You can use this instead ofonShellReady\nfor crawlers and static generation. If you start streaming here, you won\u2019t get any progressive loading. The stream will contain the final HTML. - optional\nonError\n: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only callsconsole.error\n. If you override it to log crash reports, make sure that you still callconsole.error\n. You can also use it to adjust the status code before the shell is emitted. - optional\nonShellReady\n: A callback that fires right after the initial shell has been rendered. You can set the status code and callpipe\nhere to start streaming. React will stream the additional content after the shell along with the inline<script>\ntags that replace the HTML loading fallbacks with the content. - optional\nonShellError\n: A callback that fires if there was an error rendering the initial shell. It receives the error as an argument. No bytes were emitted from the stream yet, and neitheronShellReady\nnoronAllReady\nwill get called, so you can output a fallback HTML shell. - optional\nprogressiveChunkSize\n: The number of bytes in a chunk. Read more about the default heuristic.\n- optional\nReturns\nrenderToPipeableStream\nreturns an object with two methods:\npipe\noutputs the HTML into the provided Writable Node.js Stream. Callpipe\ninonShellReady\nif you want to enable streaming, or inonAllReady\nfor crawlers and static generation.abort\nlets you abort server rendering and render the rest on the client.\nUsage\nRendering a React tree as HTML to a Node.js Stream\nCall renderToPipeableStream\nto render your React tree as HTML into a Node.js Stream:\nimport { renderToPipeableStream } from 'react-dom/server';\n// The route handler syntax depends on your backend framework\napp.use('/', (request, response) => {\nconst { pipe } = renderToPipeableStream(<App />, {\nbootstrapScripts: ['/main.js'],\nonShellReady() {\nresponse.setHeader('content-type', 'text/html');\npipe(response);\n}\n});\n});\nAlong with the root component, you need to provide a list of bootstrap <script>\npaths. Your root component should return the entire document including the root <html>\ntag.\nFor example, it might look like this:\nexport default function App() {\nreturn (\n<html>\n<head>\n<meta charSet=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<link rel=\"stylesheet\" href=\"/styles.css\"></link>\n<title>My app</title>\n</head>\n<body>\n<Router />\n</body>\n</html>\n);\n}\nReact will inject the doctype and your bootstrap <script>\ntags into the resulting HTML stream:\n<!DOCTYPE html>\n<html>\n<!-- ... HTML from your components ... -->\n</html>\n<script src=\"/main.js\" async=\"\"></script>\nOn the client, your bootstrap script should hydrate the entire document\nwith a call to hydrateRoot\n:\nimport { hydrateRoot } from 'react-dom/client';\nimport App from './App.js';\nhydrateRoot(document, <App />);\nThis will attach event listeners to the server-generated HTML and make it interactive.\nDeep Dive\nThe final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead of styles.css\nyou might end up with styles.123456.css\n. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content.\nHowever, if you don\u2019t know the asset URLs until after the build, there\u2019s no way for you to put them in the source code. For example, hardcoding \"/styles.css\"\ninto JSX like earlier wouldn\u2019t work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:\nexport default function App({ assetMap }) {\nreturn (\n<html>\n<head>\n...\n<link rel=\"stylesheet\" href={assetMap['styles.css']}></link>\n...\n</head>\n...\n</html>\n);\n}\nOn the server, render <App assetMap={assetMap} />\nand pass your assetMap\nwith the asset URLs:\n// You'd need to get this JSON from your build tooling, e.g. read it from the build output.\nconst assetMap = {\n'styles.css': '/styles.123456.css',\n'main.js': '/main.123456.js'\n};\napp.use('/', (request, response) => {\nconst { pipe } = renderToPipeableStream(<App assetMap={assetMap} />, {\nbootstrapScripts: [assetMap['main.js']],\nonShellReady() {\nresponse.setHeader('content-type', 'text/html');\npipe(response);\n}\n});\n});\nSince your server is now rendering <App assetMap={assetMap} />\n, you need to render it with assetMap\non the client too to avoid hydration errors. You can serialize and pass assetMap\nto the client like this:\n// You'd need to get this JSON from your build tooling.\nconst assetMap = {\n'styles.css': '/styles.123456.css',\n'main.js': '/main.123456.js'\n};\napp.use('/', (request, response) => {\nconst { pipe } = renderToPipeableStream(<App assetMap={assetMap} />, {\n// Careful: It's safe to stringify() this because this data isn't user-generated.\nbootstrapScriptContent: `window.assetMap = ${JSON.stringify(assetMap)};`,\nbootstrapScripts: [assetMap['main.js']],\nonShellReady() {\nresponse.setHeader('content-type', 'text/html');\npipe(response);\n}\n});\n});\nIn the example above, the bootstrapScriptContent\noption adds an extra inline <script>\ntag that sets the global window.assetMap\nvariable on the client. This lets the client code read the same assetMap\n:\nimport { hydrateRoot } from 'react-dom/client';\nimport App from './App.js';\nhydrateRoot(document, <App assetMap={window.assetMap} />);\nBoth client and server render App\nwith the same assetMap\nprop, so there are no hydration errors.\nStreaming more content as it loads\nStreaming allows the user to start seeing the content even before all the data has loaded on the server. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:\nfunction ProfilePage() {\nreturn (\n<ProfileLayout>\n<ProfileCover />\n<Sidebar>\n<Friends />\n<Photos />\n</Sidebar>\n<Posts />\n</ProfileLayout>\n);\n}\nImagine that loading data for <Posts />\ntakes some time. Ideally, you\u2019d want to show the rest of the profile page content to the user without waiting for the posts. To do this, wrap Posts\nin a <Suspense>\nboundary:\nfunction ProfilePage() {\nreturn (\n<ProfileLayout>\n<ProfileCover />\n<Sidebar>\n<Friends />\n<Photos />\n</Sidebar>\n<Suspense fallback={<PostsGlimmer />}>\n<Posts />\n</Suspense>\n</ProfileLayout>\n);\n}\nThis tells React to start streaming the HTML before Posts\nloads its data. React will send the HTML for the loading fallback (PostsGlimmer\n) first, and then, when Posts\nfinishes loading its data, React will send the remaining HTML along with an inline <script>\ntag that replaces the loading fallback with that HTML. From the user\u2019s perspective, the page will first appear with the PostsGlimmer\n, later replaced by the Posts\n.\nYou can further nest <Suspense>\nboundaries to create a more granular loading sequence:\nfunction ProfilePage() {\nreturn (\n<ProfileLayout>\n<ProfileCover />\n<Suspense fallback={<BigSpinner />}>\n<Sidebar>\n<Friends />\n<Photos />\n</Sidebar>\n<Suspense fallback={<PostsGlimmer />}>\n<Posts />\n</Suspense>\n</Suspense>\n</ProfileLayout>\n);\n}\nIn this example, React can start streaming the page even earlier. Only ProfileLayout\nand ProfileCover\nmust finish rendering first because they are not wrapped in any <Suspense>\nboundary. However, if Sidebar\n, Friends\n, or Photos\nneed to load some data, React will send the HTML for the BigSpinner\nfallback instead. Then, as more data becomes available, more content will continue to be revealed until all of it becomes visible.\nStreaming does not need to wait for React itself to load in the browser, or for your app to become interactive. The HTML content from the server will get progressively revealed before any of the <script>\ntags load.\nRead more about how streaming HTML works.\nSpecifying what goes into the shell\nThe part of your app outside of any <Suspense>\nboundaries is called the shell:\nfunction ProfilePage() {\nreturn (\n<ProfileLayout>\n<ProfileCover />\n<Suspense fallback={<BigSpinner />}>\n<Sidebar>\n<Friends />\n<Photos />\n</Sidebar>\n<Suspense fallback={<PostsGlimmer />}>\n<Posts />\n</Suspense>\n</Suspense>\n</ProfileLayout>\n);\n}\nIt determines the earliest loading state that the user may see:\n<ProfileLayout>\n<ProfileCover />\n<BigSpinner />\n</ProfileLayout>\nIf you wrap the whole app into a <Suspense>\nboundary at the root, the shell will only contain that spinner. However, that\u2019s not a pleasant user experience because seeing a big spinner on the screen can feel slower and more annoying than waiting a bit more and seeing the real layout. This is why usually you\u2019ll want to place the <Suspense>\nboundaries so that the shell feels minimal but complete\u2014like a skeleton of the entire page layout.\nThe onShellReady\ncallback fires when the entire shell has been rendered. Usually, you\u2019ll start streaming then:\nconst { pipe } = renderToPipeableStream(<App />, {\nbootstrapScripts: ['/main.js'],\nonShellReady() {\nresponse.setHeader('content-type', 'text/html');\npipe(response);\n}\n});\nBy the time onShellReady\nfires, components in nested <Suspense>\nboundaries might still be loading data.\nLogging crashes on the server\nBy default, all errors on the server are logged to console. You can override this behavior to log crash reports:\nconst { pipe } = renderToPipeableStream(<App />, {\nbootstrapScripts: ['/main.js'],\nonShellReady() {\nresponse.setHeader('content-type', 'text/html');\npipe(response);\n},\nonError(error) {\nconsole.error(error);\nlogServerCrashReport(error);\n}\n});\nIf you provide a custom onError\nimplementation, don\u2019t forget to also log errors to the console like above.\nRecovering from errors inside the shell\nIn this example, the shell contains ProfileLayout\n, ProfileCover\n, and PostsGlimmer\n:\nfunction ProfilePage() {\nreturn (\n<ProfileLayout>\n<ProfileCover />\n<Suspense fallback={<PostsGlimmer />}>\n<Posts />\n</Suspense>\n</ProfileLayout>\n);\n}\nIf an error occurs while rendering those components, React won\u2019t have any meaningful HTML to send to the client. Override onShellError\nto send a fallback HTML that doesn\u2019t rely on server rendering as the last resort:\nconst { pipe } = renderToPipeableStream(<App />, {\nbootstrapScripts: ['/main.js'],\nonShellReady() {\nresponse.setHeader('content-type', 'text/html');\npipe(response);\n},\nonShellError(error) {\nresponse.statusCode = 500;\nresponse.setHeader('content-type', 'text/html');\nresponse.send('<h1>Something went wrong</h1>');\n},\nonError(error) {\nconsole.error(error);\nlogServerCrashReport(error);\n}\n});\nIf there is an error while generating the shell, both onError\nand onShellError\nwill fire. Use onError\nfor error reporting and use onShellError\nto send the fallback HTML document. Your fallback HTML does not have to be an error page. Instead, you may include an alternative shell that renders your app on the client only.\nRecovering from errors outside the shell\nIn this example, the <Posts />\ncomponent is wrapped in <Suspense>\nso it is not a part of the shell:\nfunction ProfilePage() {\nreturn (\n<ProfileLayout>\n<ProfileCover />\n<Suspense fallback={<PostsGlimmer />}>\n<Posts />\n</Suspense>\n</ProfileLayout>\n);\n}\nIf an error happens in the Posts\ncomponent or somewhere inside it, React will try to recover from it:\n- It will emit the loading fallback for the closest\n<Suspense>\nboundary (PostsGlimmer\n) into the HTML. - It will \u201cgive up\u201d on trying to render the\nPosts\ncontent on the server anymore. - When the JavaScript code loads on the client, React will retry rendering\nPosts\non the client.\nIf retrying rendering Posts\non the client also fails, React will throw the error on the client. As with all the errors thrown during rendering, the closest parent error boundary determines how to present the error to the user. In practice, this means that the user will see a loading indicator until it is certain that the error is not recoverable.\nIf retrying rendering Posts\non the client succeeds, the loading fallback from the server will be replaced with the client rendering output. The user will not know that there was a server error. However, the server onError\ncallback and the client onRecoverableError\ncallbacks will fire so that you can get notified about the error.\nSetting the status code\nStreaming introduces a tradeoff. You want to start streaming the page as early as possible so that the user can see the content sooner. However, once you start streaming, you can no longer set the response status code.\nBy dividing your app into the shell (above all <Suspense>\nboundaries) and the rest of the content, you\u2019ve already solved a part of this problem. If the shell errors, you\u2019ll get the onShellError\ncallback which lets you set the error status code. Otherwise, you know that the app may recover on the client, so you can send \u201cOK\u201d.\nconst { pipe } = renderToPipeableStream(<App />, {\nbootstrapScripts: ['/main.js'],\nonShellReady() {\nresponse.statusCode = 200;\nresponse.setHeader('content-type', 'text/html');\npipe(response);\n},\nonShellError(error) {\nresponse.statusCode = 500;\nresponse.setHeader('content-type', 'text/html');\nresponse.send('<h1>Something went wrong</h1>');\n},\nonError(error) {\nconsole.error(error);\nlogServerCrashReport(error);\n}\n});\nIf a component outside the shell (i.e. inside a <Suspense>\nboundary) throws an error, React will not stop rendering. This means that the onError\ncallback will fire, but you will still get onShellReady\ninstead of onShellError\n. This is because React will try to recover from that error on the client, as described above.\nHowever, if you\u2019d like, you can use the fact that something has errored to set the status code:\nlet didError = false;\nconst { pipe } = renderToPipeableStream(<App />, {\nbootstrapScripts: ['/main.js'],\nonShellReady() {\nresponse.statusCode = didError ? 500 : 200;\nresponse.setHeader('content-type', 'text/html');\npipe(response);\n},\nonShellError(error) {\nresponse.statusCode = 500;\nresponse.setHeader('content-type', 'text/html');\nresponse.send('<h1>Something went wrong</h1>');\n},\nonError(error) {\ndidError = true;\nconsole.error(error);\nlogServerCrashReport(error);\n}\n});\nThis will only catch errors outside the shell that happened while generating the initial shell content, so it\u2019s not exhaustive. If knowing whether an error occurred for some content is critical, you can move it up into the shell.\nHandling different errors in different ways\nYou can create your own Error\nsubclasses and use the instanceof\noperator to check which error is thrown. For example, you can define a custom NotFoundError\nand throw it from your component. Then your onError\n, onShellReady\n, and onShellError\ncallbacks can do something different depending on the error type:\nlet didError = false;\nlet caughtError = null;\nfunction getStatusCode() {\nif (didError) {\nif (caughtError instanceof NotFoundError) {\nreturn 404;\n} else {\nreturn 500;\n}\n} else {\nreturn 200;\n}\n}\nconst { pipe } = renderToPipeableStream(<App />, {\nbootstrapScripts: ['/main.js'],\nonShellReady() {\nresponse.statusCode = getStatusCode();\nresponse.setHeader('content-type', 'text/html');\npipe(response);\n},\nonShellError(error) {\nresponse.statusCode = getStatusCode();\nresponse.setHeader('content-type', 'text/html');\nresponse.send('<h1>Something went wrong</h1>');\n},\nonError(error) {\ndidError = true;\ncaughtError = error;\nconsole.error(error);\nlogServerCrashReport(error);\n}\n});\nKeep in mind that once you emit the shell and start streaming, you can\u2019t change the status code.\nWaiting for all content to load for crawlers and static generation\nStreaming offers a better user experience because the user can see the content as it becomes available.\nHowever, when a crawler visits your page, or if you\u2019re generating the pages at the build time, you might want to let all of the content load first and then produce the final HTML output instead of revealing it progressively.\nYou can wait for all the content to load using the onAllReady\ncallback:\nlet didError = false;\nlet isCrawler = // ... depends on your bot detection strategy ...\nconst { pipe } = renderToPipeableStream(<App />, {\nbootstrapScripts: ['/main.js'],\nonShellReady() {\nif (!isCrawler) {\nresponse.statusCode = didError ? 500 : 200;\nresponse.setHeader('content-type', 'text/html');\npipe(response);\n}\n},\nonShellError(error) {\nresponse.statusCode = 500;\nresponse.setHeader('content-type', 'text/html');\nresponse.send('<h1>Something went wrong</h1>');\n},\nonAllReady() {\nif (isCrawler) {\nresponse.statusCode = didError ? 500 : 200;\nresponse.setHeader('content-type', 'text/html');\npipe(response);\n}\n},\nonError(error) {\ndidError = true;\nconsole.error(error);\nlogServerCrashReport(error);\n}\n});\nA regular visitor will get a stream of progressively loaded content. A crawler will receive the final HTML output after all the data loads. However, this also means that the crawler will have to wait for all data, some of which might be slow to load or error. Depending on your app, you could choose to send the shell to the crawlers too.\nAborting server rendering\nYou can force the server rendering to \u201cgive up\u201d after a timeout:\nconst { pipe, abort } = renderToPipeableStream(<App />, {\n// ...\n});\nsetTimeout(() => {\nabort();\n}, 10000);\nReact will flush the remaining loading fallbacks as HTML, and will attempt to render the rest on the client."
  },
  {
    "source": "https://react.dev/reference/react-dom/server/renderToReadableStream",
    "title": "renderToReadableStream \u2013 React",
    "text": "renderToReadableStream\nrenderToReadableStream\nrenders a React tree to a Readable Web Stream.\nconst stream = await renderToReadableStream(reactNode, options?)\n- Reference\n- Usage\n- Rendering a React tree as HTML to a Readable Web Stream\n- Streaming more content as it loads\n- Specifying what goes into the shell\n- Logging crashes on the server\n- Recovering from errors inside the shell\n- Recovering from errors outside the shell\n- Setting the status code\n- Handling different errors in different ways\n- Waiting for all content to load for crawlers and static generation\n- Aborting server rendering\nReference\nrenderToReadableStream(reactNode, options?)\nCall renderToReadableStream\nto render your React tree as HTML into a Readable Web Stream.\nimport { renderToReadableStream } from 'react-dom/server';\nasync function handler(request) {\nconst stream = await renderToReadableStream(<App />, {\nbootstrapScripts: ['/main.js']\n});\nreturn new Response(stream, {\nheaders: { 'content-type': 'text/html' },\n});\n}\nOn the client, call hydrateRoot\nto make the server-generated HTML interactive.\nParameters\n-\nreactNode\n: A React node you want to render to HTML. For example, a JSX element like<App />\n. It is expected to represent the entire document, so theApp\ncomponent should render the<html>\ntag. -\noptional\noptions\n: An object with streaming options.- optional\nbootstrapScriptContent\n: If specified, this string will be placed in an inline<script>\ntag. - optional\nbootstrapScripts\n: An array of string URLs for the<script>\ntags to emit on the page. Use this to include the<script>\nthat callshydrateRoot\n. Omit it if you don\u2019t want to run React on the client at all. - optional\nbootstrapModules\n: LikebootstrapScripts\n, but emits<script type=\"module\">\ninstead. - optional\nidentifierPrefix\n: A string prefix React uses for IDs generated byuseId\n. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot\n. - optional\nnamespaceURI\n: A string with the root namespace URI for the stream. Defaults to regular HTML. Pass'http://www.w3.org/2000/svg'\nfor SVG or'http://www.w3.org/1998/Math/MathML'\nfor MathML. - optional\nnonce\n: Anonce\nstring to allow scripts forscript-src\nContent-Security-Policy. - optional\nonError\n: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only callsconsole.error\n. If you override it to log crash reports, make sure that you still callconsole.error\n. You can also use it to adjust the status code before the shell is emitted. - optional\nprogressiveChunkSize\n: The number of bytes in a chunk. Read more about the default heuristic. - optional\nsignal\n: An abort signal that lets you abort server rendering and render the rest on the client.\n- optional\nReturns\nrenderToReadableStream\nreturns a Promise:\n- If rendering the shell is successful, that Promise will resolve to a Readable Web Stream.\n- If rendering the shell fails, the Promise will be rejected. Use this to output a fallback shell.\nThe returned stream has an additional property:\nallReady\n: A Promise that resolves when all rendering is complete, including both the shell and all additional content. You canawait stream.allReady\nbefore returning a response for crawlers and static generation. If you do that, you won\u2019t get any progressive loading. The stream will contain the final HTML.\nUsage\nRendering a React tree as HTML to a Readable Web Stream\nCall renderToReadableStream\nto render your React tree as HTML into a Readable Web Stream:\nimport { renderToReadableStream } from 'react-dom/server';\nasync function handler(request) {\nconst stream = await renderToReadableStream(<App />, {\nbootstrapScripts: ['/main.js']\n});\nreturn new Response(stream, {\nheaders: { 'content-type': 'text/html' },\n});\n}\nAlong with the root component, you need to provide a list of bootstrap <script>\npaths. Your root component should return the entire document including the root <html>\ntag.\nFor example, it might look like this:\nexport default function App() {\nreturn (\n<html>\n<head>\n<meta charSet=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<link rel=\"stylesheet\" href=\"/styles.css\"></link>\n<title>My app</title>\n</head>\n<body>\n<Router />\n</body>\n</html>\n);\n}\nReact will inject the doctype and your bootstrap <script>\ntags into the resulting HTML stream:\n<!DOCTYPE html>\n<html>\n<!-- ... HTML from your components ... -->\n</html>\n<script src=\"/main.js\" async=\"\"></script>\nOn the client, your bootstrap script should hydrate the entire document\nwith a call to hydrateRoot\n:\nimport { hydrateRoot } from 'react-dom/client';\nimport App from './App.js';\nhydrateRoot(document, <App />);\nThis will attach event listeners to the server-generated HTML and make it interactive.\nDeep Dive\nThe final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead of styles.css\nyou might end up with styles.123456.css\n. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content.\nHowever, if you don\u2019t know the asset URLs until after the build, there\u2019s no way for you to put them in the source code. For example, hardcoding \"/styles.css\"\ninto JSX like earlier wouldn\u2019t work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:\nexport default function App({ assetMap }) {\nreturn (\n<html>\n<head>\n<title>My app</title>\n<link rel=\"stylesheet\" href={assetMap['styles.css']}></link>\n</head>\n...\n</html>\n);\n}\nOn the server, render <App assetMap={assetMap} />\nand pass your assetMap\nwith the asset URLs:\n// You'd need to get this JSON from your build tooling, e.g. read it from the build output.\nconst assetMap = {\n'styles.css': '/styles.123456.css',\n'main.js': '/main.123456.js'\n};\nasync function handler(request) {\nconst stream = await renderToReadableStream(<App assetMap={assetMap} />, {\nbootstrapScripts: [assetMap['/main.js']]\n});\nreturn new Response(stream, {\nheaders: { 'content-type': 'text/html' },\n});\n}\nSince your server is now rendering <App assetMap={assetMap} />\n, you need to render it with assetMap\non the client too to avoid hydration errors. You can serialize and pass assetMap\nto the client like this:\n// You'd need to get this JSON from your build tooling.\nconst assetMap = {\n'styles.css': '/styles.123456.css',\n'main.js': '/main.123456.js'\n};\nasync function handler(request) {\nconst stream = await renderToReadableStream(<App assetMap={assetMap} />, {\n// Careful: It's safe to stringify() this because this data isn't user-generated.\nbootstrapScriptContent: `window.assetMap = ${JSON.stringify(assetMap)};`,\nbootstrapScripts: [assetMap['/main.js']],\n});\nreturn new Response(stream, {\nheaders: { 'content-type': 'text/html' },\n});\n}\nIn the example above, the bootstrapScriptContent\noption adds an extra inline <script>\ntag that sets the global window.assetMap\nvariable on the client. This lets the client code read the same assetMap\n:\nimport { hydrateRoot } from 'react-dom/client';\nimport App from './App.js';\nhydrateRoot(document, <App assetMap={window.assetMap} />);\nBoth client and server render App\nwith the same assetMap\nprop, so there are no hydration errors.\nStreaming more content as it loads\nStreaming allows the user to start seeing the content even before all the data has loaded on the server. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:\nfunction ProfilePage() {\nreturn (\n<ProfileLayout>\n<ProfileCover />\n<Sidebar>\n<Friends />\n<Photos />\n</Sidebar>\n<Posts />\n</ProfileLayout>\n);\n}\nImagine that loading data for <Posts />\ntakes some time. Ideally, you\u2019d want to show the rest of the profile page content to the user without waiting for the posts. To do this, wrap Posts\nin a <Suspense>\nboundary:\nfunction ProfilePage() {\nreturn (\n<ProfileLayout>\n<ProfileCover />\n<Sidebar>\n<Friends />\n<Photos />\n</Sidebar>\n<Suspense fallback={<PostsGlimmer />}>\n<Posts />\n</Suspense>\n</ProfileLayout>\n);\n}\nThis tells React to start streaming the HTML before Posts\nloads its data. React will send the HTML for the loading fallback (PostsGlimmer\n) first, and then, when Posts\nfinishes loading its data, React will send the remaining HTML along with an inline <script>\ntag that replaces the loading fallback with that HTML. From the user\u2019s perspective, the page will first appear with the PostsGlimmer\n, later replaced by the Posts\n.\nYou can further nest <Suspense>\nboundaries to create a more granular loading sequence:\nfunction ProfilePage() {\nreturn (\n<ProfileLayout>\n<ProfileCover />\n<Suspense fallback={<BigSpinner />}>\n<Sidebar>\n<Friends />\n<Photos />\n</Sidebar>\n<Suspense fallback={<PostsGlimmer />}>\n<Posts />\n</Suspense>\n</Suspense>\n</ProfileLayout>\n);\n}\nIn this example, React can start streaming the page even earlier. Only ProfileLayout\nand ProfileCover\nmust finish rendering first because they are not wrapped in any <Suspense>\nboundary. However, if Sidebar\n, Friends\n, or Photos\nneed to load some data, React will send the HTML for the BigSpinner\nfallback instead. Then, as more data becomes available, more content will continue to be revealed until all of it becomes visible.\nStreaming does not need to wait for React itself to load in the browser, or for your app to become interactive. The HTML content from the server will get progressively revealed before any of the <script>\ntags load.\nRead more about how streaming HTML works.\nSpecifying what goes into the shell\nThe part of your app outside of any <Suspense>\nboundaries is called the shell:\nfunction ProfilePage() {\nreturn (\n<ProfileLayout>\n<ProfileCover />\n<Suspense fallback={<BigSpinner />}>\n<Sidebar>\n<Friends />\n<Photos />\n</Sidebar>\n<Suspense fallback={<PostsGlimmer />}>\n<Posts />\n</Suspense>\n</Suspense>\n</ProfileLayout>\n);\n}\nIt determines the earliest loading state that the user may see:\n<ProfileLayout>\n<ProfileCover />\n<BigSpinner />\n</ProfileLayout>\nIf you wrap the whole app into a <Suspense>\nboundary at the root, the shell will only contain that spinner. However, that\u2019s not a pleasant user experience because seeing a big spinner on the screen can feel slower and more annoying than waiting a bit more and seeing the real layout. This is why usually you\u2019ll want to place the <Suspense>\nboundaries so that the shell feels minimal but complete\u2014like a skeleton of the entire page layout.\nThe async call to renderToReadableStream\nwill resolve to a stream\nas soon as the entire shell has been rendered. Usually, you\u2019ll start streaming then by creating and returning a response with that stream\n:\nasync function handler(request) {\nconst stream = await renderToReadableStream(<App />, {\nbootstrapScripts: ['/main.js']\n});\nreturn new Response(stream, {\nheaders: { 'content-type': 'text/html' },\n});\n}\nBy the time the stream\nis returned, components in nested <Suspense>\nboundaries might still be loading data.\nLogging crashes on the server\nBy default, all errors on the server are logged to console. You can override this behavior to log crash reports:\nasync function handler(request) {\nconst stream = await renderToReadableStream(<App />, {\nbootstrapScripts: ['/main.js'],\nonError(error) {\nconsole.error(error);\nlogServerCrashReport(error);\n}\n});\nreturn new Response(stream, {\nheaders: { 'content-type': 'text/html' },\n});\n}\nIf you provide a custom onError\nimplementation, don\u2019t forget to also log errors to the console like above.\nRecovering from errors inside the shell\nIn this example, the shell contains ProfileLayout\n, ProfileCover\n, and PostsGlimmer\n:\nfunction ProfilePage() {\nreturn (\n<ProfileLayout>\n<ProfileCover />\n<Suspense fallback={<PostsGlimmer />}>\n<Posts />\n</Suspense>\n</ProfileLayout>\n);\n}\nIf an error occurs while rendering those components, React won\u2019t have any meaningful HTML to send to the client. Wrap your renderToReadableStream\ncall in a try...catch\nto send a fallback HTML that doesn\u2019t rely on server rendering as the last resort:\nasync function handler(request) {\ntry {\nconst stream = await renderToReadableStream(<App />, {\nbootstrapScripts: ['/main.js'],\nonError(error) {\nconsole.error(error);\nlogServerCrashReport(error);\n}\n});\nreturn new Response(stream, {\nheaders: { 'content-type': 'text/html' },\n});\n} catch (error) {\nreturn new Response('<h1>Something went wrong</h1>', {\nstatus: 500,\nheaders: { 'content-type': 'text/html' },\n});\n}\n}\nIf there is an error while generating the shell, both onError\nand your catch\nblock will fire. Use onError\nfor error reporting and use the catch\nblock to send the fallback HTML document. Your fallback HTML does not have to be an error page. Instead, you may include an alternative shell that renders your app on the client only.\nRecovering from errors outside the shell\nIn this example, the <Posts />\ncomponent is wrapped in <Suspense>\nso it is not a part of the shell:\nfunction ProfilePage() {\nreturn (\n<ProfileLayout>\n<ProfileCover />\n<Suspense fallback={<PostsGlimmer />}>\n<Posts />\n</Suspense>\n</ProfileLayout>\n);\n}\nIf an error happens in the Posts\ncomponent or somewhere inside it, React will try to recover from it:\n- It will emit the loading fallback for the closest\n<Suspense>\nboundary (PostsGlimmer\n) into the HTML. - It will \u201cgive up\u201d on trying to render the\nPosts\ncontent on the server anymore. - When the JavaScript code loads on the client, React will retry rendering\nPosts\non the client.\nIf retrying rendering Posts\non the client also fails, React will throw the error on the client. As with all the errors thrown during rendering, the closest parent error boundary determines how to present the error to the user. In practice, this means that the user will see a loading indicator until it is certain that the error is not recoverable.\nIf retrying rendering Posts\non the client succeeds, the loading fallback from the server will be replaced with the client rendering output. The user will not know that there was a server error. However, the server onError\ncallback and the client onRecoverableError\ncallbacks will fire so that you can get notified about the error.\nSetting the status code\nStreaming introduces a tradeoff. You want to start streaming the page as early as possible so that the user can see the content sooner. However, once you start streaming, you can no longer set the response status code.\nBy dividing your app into the shell (above all <Suspense>\nboundaries) and the rest of the content, you\u2019ve already solved a part of this problem. If the shell errors, your catch\nblock will run which lets you set the error status code. Otherwise, you know that the app may recover on the client, so you can send \u201cOK\u201d.\nasync function handler(request) {\ntry {\nconst stream = await renderToReadableStream(<App />, {\nbootstrapScripts: ['/main.js'],\nonError(error) {\nconsole.error(error);\nlogServerCrashReport(error);\n}\n});\nreturn new Response(stream, {\nstatus: 200,\nheaders: { 'content-type': 'text/html' },\n});\n} catch (error) {\nreturn new Response('<h1>Something went wrong</h1>', {\nstatus: 500,\nheaders: { 'content-type': 'text/html' },\n});\n}\n}\nIf a component outside the shell (i.e. inside a <Suspense>\nboundary) throws an error, React will not stop rendering. This means that the onError\ncallback will fire, but your code will continue running without getting into the catch\nblock. This is because React will try to recover from that error on the client, as described above.\nHowever, if you\u2019d like, you can use the fact that something has errored to set the status code:\nasync function handler(request) {\ntry {\nlet didError = false;\nconst stream = await renderToReadableStream(<App />, {\nbootstrapScripts: ['/main.js'],\nonError(error) {\ndidError = true;\nconsole.error(error);\nlogServerCrashReport(error);\n}\n});\nreturn new Response(stream, {\nstatus: didError ? 500 : 200,\nheaders: { 'content-type': 'text/html' },\n});\n} catch (error) {\nreturn new Response('<h1>Something went wrong</h1>', {\nstatus: 500,\nheaders: { 'content-type': 'text/html' },\n});\n}\n}\nThis will only catch errors outside the shell that happened while generating the initial shell content, so it\u2019s not exhaustive. If knowing whether an error occurred for some content is critical, you can move it up into the shell.\nHandling different errors in different ways\nYou can create your own Error\nsubclasses and use the instanceof\noperator to check which error is thrown. For example, you can define a custom NotFoundError\nand throw it from your component. Then you can save the error in onError\nand do something different before returning the response depending on the error type:\nasync function handler(request) {\nlet didError = false;\nlet caughtError = null;\nfunction getStatusCode() {\nif (didError) {\nif (caughtError instanceof NotFoundError) {\nreturn 404;\n} else {\nreturn 500;\n}\n} else {\nreturn 200;\n}\n}\ntry {\nconst stream = await renderToReadableStream(<App />, {\nbootstrapScripts: ['/main.js'],\nonError(error) {\ndidError = true;\ncaughtError = error;\nconsole.error(error);\nlogServerCrashReport(error);\n}\n});\nreturn new Response(stream, {\nstatus: getStatusCode(),\nheaders: { 'content-type': 'text/html' },\n});\n} catch (error) {\nreturn new Response('<h1>Something went wrong</h1>', {\nstatus: getStatusCode(),\nheaders: { 'content-type': 'text/html' },\n});\n}\n}\nKeep in mind that once you emit the shell and start streaming, you can\u2019t change the status code.\nWaiting for all content to load for crawlers and static generation\nStreaming offers a better user experience because the user can see the content as it becomes available.\nHowever, when a crawler visits your page, or if you\u2019re generating the pages at the build time, you might want to let all of the content load first and then produce the final HTML output instead of revealing it progressively.\nYou can wait for all the content to load by awaiting the stream.allReady\nPromise:\nasync function handler(request) {\ntry {\nlet didError = false;\nconst stream = await renderToReadableStream(<App />, {\nbootstrapScripts: ['/main.js'],\nonError(error) {\ndidError = true;\nconsole.error(error);\nlogServerCrashReport(error);\n}\n});\nlet isCrawler = // ... depends on your bot detection strategy ...\nif (isCrawler) {\nawait stream.allReady;\n}\nreturn new Response(stream, {\nstatus: didError ? 500 : 200,\nheaders: { 'content-type': 'text/html' },\n});\n} catch (error) {\nreturn new Response('<h1>Something went wrong</h1>', {\nstatus: 500,\nheaders: { 'content-type': 'text/html' },\n});\n}\n}\nA regular visitor will get a stream of progressively loaded content. A crawler will receive the final HTML output after all the data loads. However, this also means that the crawler will have to wait for all data, some of which might be slow to load or error. Depending on your app, you could choose to send the shell to the crawlers too.\nAborting server rendering\nYou can force the server rendering to \u201cgive up\u201d after a timeout:\nasync function handler(request) {\ntry {\nconst controller = new AbortController();\nsetTimeout(() => {\ncontroller.abort();\n}, 10000);\nconst stream = await renderToReadableStream(<App />, {\nsignal: controller.signal,\nbootstrapScripts: ['/main.js'],\nonError(error) {\ndidError = true;\nconsole.error(error);\nlogServerCrashReport(error);\n}\n});\n// ...\nReact will flush the remaining loading fallbacks as HTML, and will attempt to render the rest on the client."
  },
  {
    "source": "https://react.dev/reference/react-dom/server/renderToStaticMarkup",
    "title": "renderToStaticMarkup \u2013 React",
    "text": "renderToStaticMarkup\nrenderToStaticMarkup\nrenders a non-interactive React tree to an HTML string.\nconst html = renderToStaticMarkup(reactNode, options?)\nReference\nrenderToStaticMarkup(reactNode, options?)\nOn the server, call renderToStaticMarkup\nto render your app to HTML.\nimport { renderToStaticMarkup } from 'react-dom/server';\nconst html = renderToStaticMarkup(<Page />);\nIt will produce non-interactive HTML output of your React components.\nParameters\nreactNode\n: A React node you want to render to HTML. For example, a JSX node like<Page />\n.- optional\noptions\n: An object for server render.- optional\nidentifierPrefix\n: A string prefix React uses for IDs generated byuseId\n. Useful to avoid conflicts when using multiple roots on the same page.\n- optional\nReturns\nAn HTML string.\nCaveats\n-\nrenderToStaticMarkup\noutput cannot be hydrated. -\nrenderToStaticMarkup\nhas limited Suspense support. If a component suspends,renderToStaticMarkup\nimmediately sends its fallback as HTML. -\nrenderToStaticMarkup\nworks in the browser, but using it in the client code is not recommended. If you need to render a component to HTML in the browser, get the HTML by rendering it into a DOM node.\nUsage\nRendering a non-interactive React tree as HTML to a string\nCall renderToStaticMarkup\nto render your app to an HTML string which you can send with your server response:\nimport { renderToStaticMarkup } from 'react-dom/server';\n// The route handler syntax depends on your backend framework\napp.use('/', (request, response) => {\nconst html = renderToStaticMarkup(<Page />);\nresponse.send(html);\n});\nThis will produce the initial non-interactive HTML output of your React components."
  },
  {
    "source": "https://react.dev/reference/react-dom/server/renderToStaticNodeStream",
    "title": "renderToStaticNodeStream \u2013 React",
    "text": "renderToStaticNodeStream\nrenderToStaticNodeStream\nrenders a non-interactive React tree to a Node.js Readable Stream.\nconst stream = renderToStaticNodeStream(reactNode, options?)\nReference\nrenderToStaticNodeStream(reactNode, options?)\nOn the server, call renderToStaticNodeStream\nto get a Node.js Readable Stream.\nimport { renderToStaticNodeStream } from 'react-dom/server';\nconst stream = renderToStaticNodeStream(<Page />);\nstream.pipe(response);\nThe stream will produce non-interactive HTML output of your React components.\nParameters\n-\nreactNode\n: A React node you want to render to HTML. For example, a JSX element like<Page />\n. -\noptional\noptions\n: An object for server render.- optional\nidentifierPrefix\n: A string prefix React uses for IDs generated byuseId\n. Useful to avoid conflicts when using multiple roots on the same page.\n- optional\nReturns\nA Node.js Readable Stream that outputs an HTML string. The resulting HTML can\u2019t be hydrated on the client.\nCaveats\n-\nrenderToStaticNodeStream\noutput cannot be hydrated. -\nThis method will wait for all Suspense boundaries to complete before returning any output.\n-\nAs of React 18, this method buffers all of its output, so it doesn\u2019t actually provide any streaming benefits.\n-\nThe returned stream is a byte stream encoded in utf-8. If you need a stream in another encoding, take a look at a project like iconv-lite, which provides transform streams for transcoding text.\nUsage\nRendering a React tree as static HTML to a Node.js Readable Stream\nCall renderToStaticNodeStream\nto get a Node.js Readable Stream which you can pipe to your server response:\nimport { renderToStaticNodeStream } from 'react-dom/server';\n// The route handler syntax depends on your backend framework\napp.use('/', (request, response) => {\nconst stream = renderToStaticNodeStream(<Page />);\nstream.pipe(response);\n});\nThe stream will produce the initial non-interactive HTML output of your React components."
  },
  {
    "source": "https://react.dev/reference/react-dom/server/renderToString",
    "title": "renderToString \u2013 React",
    "text": "renderToString\nrenderToString\nrenders a React tree to an HTML string.\nconst html = renderToString(reactNode, options?)\nReference\nrenderToString(reactNode, options?)\nOn the server, call renderToString\nto render your app to HTML.\nimport { renderToString } from 'react-dom/server';\nconst html = renderToString(<App />);\nOn the client, call hydrateRoot\nto make the server-generated HTML interactive.\nParameters\n-\nreactNode\n: A React node you want to render to HTML. For example, a JSX node like<App />\n. -\noptional\noptions\n: An object for server render.- optional\nidentifierPrefix\n: A string prefix React uses for IDs generated byuseId\n. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot\n.\n- optional\nReturns\nAn HTML string.\nCaveats\n-\nrenderToString\nhas limited Suspense support. If a component suspends,renderToString\nimmediately sends its fallback as HTML. -\nrenderToString\nworks in the browser, but using it in the client code is not recommended.\nUsage\nRendering a React tree as HTML to a string\nCall renderToString\nto render your app to an HTML string which you can send with your server response:\nimport { renderToString } from 'react-dom/server';\n// The route handler syntax depends on your backend framework\napp.use('/', (request, response) => {\nconst html = renderToString(<App />);\nresponse.send(html);\n});\nThis will produce the initial non-interactive HTML output of your React components. On the client, you will need to call hydrateRoot\nto hydrate that server-generated HTML and make it interactive.\nAlternatives\nMigrating from renderToString\nto a streaming render on the server\nrenderToString\nreturns a string immediately, so it does not support streaming content as it loads.\nWhen possible, we recommend using these fully-featured alternatives:\n- If you use Node.js, use\nrenderToPipeableStream\n. - If you use Deno or a modern edge runtime with Web Streams, use\nrenderToReadableStream\n.\nYou can continue using renderToString\nif your server environment does not support streams.\nMigrating from renderToString\nto a static prerender on the server\nrenderToString\nreturns a string immediately, so it does not support waiting for data to load for static HTML generation.\nWe recommend using these fully-featured alternatives:\n- If you use Node.js, use\nprerenderToNodeStream\n. - If you use Deno or a modern edge runtime with Web Streams, use\nprerender\n.\nYou can continue using renderToString\nif your static site generation environment does not support streams.\nRemoving renderToString\nfrom the client code\nSometimes, renderToString\nis used on the client to convert some component to HTML.\n// \ud83d\udea9 Unnecessary: using renderToString on the client\nimport { renderToString } from 'react-dom/server';\nconst html = renderToString(<MyIcon />);\nconsole.log(html); // For example, \"<svg>...</svg>\"\nImporting react-dom/server\non the client unnecessarily increases your bundle size and should be avoided. If you need to render some component to HTML in the browser, use createRoot\nand read HTML from the DOM:\nimport { createRoot } from 'react-dom/client';\nimport { flushSync } from 'react-dom';\nconst div = document.createElement('div');\nconst root = createRoot(div);\nflushSync(() => {\nroot.render(<MyIcon />);\n});\nconsole.log(div.innerHTML); // For example, \"<svg>...</svg>\"\nThe flushSync\ncall is necessary so that the DOM is updated before reading its innerHTML\nproperty.\nTroubleshooting\nWhen a component suspends, the HTML always contains a fallback\nrenderToString\ndoes not fully support Suspense.\nIf some component suspends (for example, because it\u2019s defined with lazy\nor fetches data), renderToString\nwill not wait for its content to resolve. Instead, renderToString\nwill find the closest <Suspense>\nboundary above it and render its fallback\nprop in the HTML. The content will not appear until the client code loads.\nTo solve this, use one of the recommended streaming solutions. For server side rendering, they can stream content in chunks as it resolves on the server so that the user sees the page being progressively filled in before the client code loads. For static site generation, they can wait for all the content to resolve before generating the static HTML."
  },
  {
    "source": "https://react.dev/reference/react-dom/static",
    "title": "Static React DOM APIs \u2013 React",
    "text": "Static React DOM APIs\nThe react-dom/static\nAPIs let you generate static HTML for React components. They have limited functionality compared to the streaming APIs. A framework may call them for you. Most of your components don\u2019t need to import or use them.\nStatic APIs for Web Streams\nThese methods are only available in the environments with Web Streams, which includes browsers, Deno, and some modern edge runtimes:\nprerender\nrenders a React tree to static HTML with a Readable Web Stream.\nStatic APIs for Node.js Streams\nThese methods are only available in the environments with Node.js Streams:\nprerenderToNodeStream\nrenders a React tree to static HTML with a Node.js Stream."
  },
  {
    "source": "https://react.dev/reference/react-dom/static/prerender",
    "title": "prerender \u2013 React",
    "text": "prerender\nprerender\nrenders a React tree to a static HTML string using a Web Stream.\nconst {prelude} = await prerender(reactNode, options?)\nReference\nprerender(reactNode, options?)\nCall prerender\nto render your app to static HTML.\nimport { prerender } from 'react-dom/static';\nasync function handler(request) {\nconst {prelude} = await prerender(<App />, {\nbootstrapScripts: ['/main.js']\n});\nreturn new Response(prelude, {\nheaders: { 'content-type': 'text/html' },\n});\n}\nOn the client, call hydrateRoot\nto make the server-generated HTML interactive.\nParameters\n-\nreactNode\n: A React node you want to render to HTML. For example, a JSX node like<App />\n. It is expected to represent the entire document, so the App component should render the<html>\ntag. -\noptional\noptions\n: An object with static generation options.- optional\nbootstrapScriptContent\n: If specified, this string will be placed in an inline<script>\ntag. - optional\nbootstrapScripts\n: An array of string URLs for the<script>\ntags to emit on the page. Use this to include the<script>\nthat callshydrateRoot\n. Omit it if you don\u2019t want to run React on the client at all. - optional\nbootstrapModules\n: LikebootstrapScripts\n, but emits<script type=\"module\">\ninstead. - optional\nidentifierPrefix\n: A string prefix React uses for IDs generated byuseId\n. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot\n. - optional\nnamespaceURI\n: A string with the root namespace URI for the stream. Defaults to regular HTML. Pass'http://www.w3.org/2000/svg'\nfor SVG or'http://www.w3.org/1998/Math/MathML'\nfor MathML. - optional\nonError\n: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only callsconsole.error\n. If you override it to log crash reports, make sure that you still callconsole.error\n. You can also use it to adjust the status code before the shell is emitted. - optional\nprogressiveChunkSize\n: The number of bytes in a chunk. Read more about the default heuristic. - optional\nsignal\n: An abort signal that lets you abort server rendering and render the rest on the client.\n- optional\nReturns\nprerender\nreturns a Promise:\n- If rendering the is successful, the Promise will resolve to an object containing:\nprelude\n: a Web Stream of HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.\n- If rendering fails, the Promise will be rejected. Use this to output a fallback shell.\nUsage\nRendering a React tree to a stream of static HTML\nCall prerender\nto render your React tree to static HTML into a Readable Web Stream::\nimport { prerender } from 'react-dom/static';\nasync function handler(request) {\nconst {prelude} = await prerender(<App />, {\nbootstrapScripts: ['/main.js']\n});\nreturn new Response(prelude, {\nheaders: { 'content-type': 'text/html' },\n});\n}\nAlong with the root component, you need to provide a list of bootstrap <script>\npaths. Your root component should return the entire document including the root <html>\ntag.\nFor example, it might look like this:\nexport default function App() {\nreturn (\n<html>\n<head>\n<meta charSet=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<link rel=\"stylesheet\" href=\"/styles.css\"></link>\n<title>My app</title>\n</head>\n<body>\n<Router />\n</body>\n</html>\n);\n}\nReact will inject the doctype and your bootstrap <script>\ntags into the resulting HTML stream:\n<!DOCTYPE html>\n<html>\n<!-- ... HTML from your components ... -->\n</html>\n<script src=\"/main.js\" async=\"\"></script>\nOn the client, your bootstrap script should hydrate the entire document\nwith a call to hydrateRoot\n:\nimport { hydrateRoot } from 'react-dom/client';\nimport App from './App.js';\nhydrateRoot(document, <App />);\nThis will attach event listeners to the static server-generated HTML and make it interactive.\nDeep Dive\nThe final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead of styles.css\nyou might end up with styles.123456.css\n. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content.\nHowever, if you don\u2019t know the asset URLs until after the build, there\u2019s no way for you to put them in the source code. For example, hardcoding \"/styles.css\"\ninto JSX like earlier wouldn\u2019t work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:\nexport default function App({ assetMap }) {\nreturn (\n<html>\n<head>\n<title>My app</title>\n<link rel=\"stylesheet\" href={assetMap['styles.css']}></link>\n</head>\n...\n</html>\n);\n}\nOn the server, render <App assetMap={assetMap} />\nand pass your assetMap\nwith the asset URLs:\n// You'd need to get this JSON from your build tooling, e.g. read it from the build output.\nconst assetMap = {\n'styles.css': '/styles.123456.css',\n'main.js': '/main.123456.js'\n};\nasync function handler(request) {\nconst {prelude} = await prerender(<App assetMap={assetMap} />, {\nbootstrapScripts: [assetMap['/main.js']]\n});\nreturn new Response(prelude, {\nheaders: { 'content-type': 'text/html' },\n});\n}\nSince your server is now rendering <App assetMap={assetMap} />\n, you need to render it with assetMap\non the client too to avoid hydration errors. You can serialize and pass assetMap\nto the client like this:\n// You'd need to get this JSON from your build tooling.\nconst assetMap = {\n'styles.css': '/styles.123456.css',\n'main.js': '/main.123456.js'\n};\nasync function handler(request) {\nconst {prelude} = await prerender(<App assetMap={assetMap} />, {\n// Careful: It's safe to stringify() this because this data isn't user-generated.\nbootstrapScriptContent: `window.assetMap = ${JSON.stringify(assetMap)};`,\nbootstrapScripts: [assetMap['/main.js']],\n});\nreturn new Response(prelude, {\nheaders: { 'content-type': 'text/html' },\n});\n}\nIn the example above, the bootstrapScriptContent\noption adds an extra inline <script>\ntag that sets the global window.assetMap\nvariable on the client. This lets the client code read the same assetMap\n:\nimport { hydrateRoot } from 'react-dom/client';\nimport App from './App.js';\nhydrateRoot(document, <App assetMap={window.assetMap} />);\nBoth client and server render App\nwith the same assetMap\nprop, so there are no hydration errors.\nRendering a React tree to a string of static HTML\nCall prerender\nto render your app to a static HTML string:\nimport { prerender } from 'react-dom/static';\nasync function renderToString() {\nconst {prelude} = await prerender(<App />, {\nbootstrapScripts: ['/main.js']\n});\nconst reader = stream.getReader();\nlet content = '';\nwhile (true) {\nconst {done, value} = await reader.read();\nif (done) {\nreturn content;\n}\ncontent += Buffer.from(value).toString('utf8');\n}\n}\nThis will produce the initial non-interactive HTML output of your React components. On the client, you will need to call hydrateRoot\nto hydrate that server-generated HTML and make it interactive.\nWaiting for all data to load\nprerender\nwaits for all data to load before finishing the static HTML generation and resolving. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:\nfunction ProfilePage() {\nreturn (\n<ProfileLayout>\n<ProfileCover />\n<Sidebar>\n<Friends />\n<Photos />\n</Sidebar>\n<Suspense fallback={<PostsGlimmer />}>\n<Posts />\n</Suspense>\n</ProfileLayout>\n);\n}\nImagine that <Posts />\nneeds to load some data, which takes some time. Ideally, you\u2019d want wait for the posts to finish so it\u2019s included in the HTML. To do this, you can use Suspense to suspend on the data, and prerender\nwill wait for the suspended content to finish before resolving to the static HTML.\nTroubleshooting\nMy stream doesn\u2019t start until the entire app is rendered\nThe prerender\nresponse waits for the entire app to finish rendering, including waiting for all suspense boundaries to resolve, before resolving. It is designed for static site generation (SSG) ahead of time and does not support streaming more content as it loads.\nTo stream content as it loads, use a streaming server render API like renderToReadableStream."
  },
  {
    "source": "https://react.dev/reference/react-dom/static/prerenderToNodeStream",
    "title": "prerenderToNodeStream \u2013 React",
    "text": "prerenderToNodeStream\nprerenderToNodeStream\nrenders a React tree to a static HTML string using a Node.js Stream..\nconst {prelude} = await prerenderToNodeStream(reactNode, options?)\nReference\nprerenderToNodeStream(reactNode, options?)\nCall prerenderToNodeStream\nto render your app to static HTML.\nimport { prerenderToNodeStream } from 'react-dom/static';\n// The route handler syntax depends on your backend framework\napp.use('/', async (request, response) => {\nconst { prelude } = await prerenderToNodeStream(<App />, {\nbootstrapScripts: ['/main.js'],\n});\nresponse.setHeader('Content-Type', 'text/plain');\nprelude.pipe(response);\n});\nOn the client, call hydrateRoot\nto make the server-generated HTML interactive.\nParameters\n-\nreactNode\n: A React node you want to render to HTML. For example, a JSX node like<App />\n. It is expected to represent the entire document, so the App component should render the<html>\ntag. -\noptional\noptions\n: An object with static generation options.- optional\nbootstrapScriptContent\n: If specified, this string will be placed in an inline<script>\ntag. - optional\nbootstrapScripts\n: An array of string URLs for the<script>\ntags to emit on the page. Use this to include the<script>\nthat callshydrateRoot\n. Omit it if you don\u2019t want to run React on the client at all. - optional\nbootstrapModules\n: LikebootstrapScripts\n, but emits<script type=\"module\">\ninstead. - optional\nidentifierPrefix\n: A string prefix React uses for IDs generated byuseId\n. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot\n. - optional\nnamespaceURI\n: A string with the root namespace URI for the stream. Defaults to regular HTML. Pass'http://www.w3.org/2000/svg'\nfor SVG or'http://www.w3.org/1998/Math/MathML'\nfor MathML. - optional\nonError\n: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only callsconsole.error\n. If you override it to log crash reports, make sure that you still callconsole.error\n. You can also use it to adjust the status code before the shell is emitted. - optional\nprogressiveChunkSize\n: The number of bytes in a chunk. Read more about the default heuristic. - optional\nsignal\n: An abort signal that lets you abort server rendering and render the rest on the client.\n- optional\nReturns\nprerenderToNodeStream\nreturns a Promise:\n- If rendering the is successful, the Promise will resolve to an object containing:\nprelude\n: a Node.js Stream. of HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.\n- If rendering fails, the Promise will be rejected. Use this to output a fallback shell.\nUsage\nRendering a React tree to a stream of static HTML\nCall prerenderToNodeStream\nto render your React tree to static HTML into a Node.js Stream.:\nimport { prerenderToNodeStream } from 'react-dom/static';\n// The route handler syntax depends on your backend framework\napp.use('/', async (request, response) => {\nconst { prelude } = await prerenderToNodeStream(<App />, {\nbootstrapScripts: ['/main.js'],\n});\nresponse.setHeader('Content-Type', 'text/plain');\nprelude.pipe(response);\n});\nAlong with the root component, you need to provide a list of bootstrap <script>\npaths. Your root component should return the entire document including the root <html>\ntag.\nFor example, it might look like this:\nexport default function App() {\nreturn (\n<html>\n<head>\n<meta charSet=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<link rel=\"stylesheet\" href=\"/styles.css\"></link>\n<title>My app</title>\n</head>\n<body>\n<Router />\n</body>\n</html>\n);\n}\nReact will inject the doctype and your bootstrap <script>\ntags into the resulting HTML stream:\n<!DOCTYPE html>\n<html>\n<!-- ... HTML from your components ... -->\n</html>\n<script src=\"/main.js\" async=\"\"></script>\nOn the client, your bootstrap script should hydrate the entire document\nwith a call to hydrateRoot\n:\nimport { hydrateRoot } from 'react-dom/client';\nimport App from './App.js';\nhydrateRoot(document, <App />);\nThis will attach event listeners to the static server-generated HTML and make it interactive.\nDeep Dive\nThe final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead of styles.css\nyou might end up with styles.123456.css\n. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content.\nHowever, if you don\u2019t know the asset URLs until after the build, there\u2019s no way for you to put them in the source code. For example, hardcoding \"/styles.css\"\ninto JSX like earlier wouldn\u2019t work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:\nexport default function App({ assetMap }) {\nreturn (\n<html>\n<head>\n<title>My app</title>\n<link rel=\"stylesheet\" href={assetMap['styles.css']}></link>\n</head>\n...\n</html>\n);\n}\nOn the server, render <App assetMap={assetMap} />\nand pass your assetMap\nwith the asset URLs:\n// You'd need to get this JSON from your build tooling, e.g. read it from the build output.\nconst assetMap = {\n'styles.css': '/styles.123456.css',\n'main.js': '/main.123456.js'\n};\napp.use('/', async (request, response) => {\nconst { prelude } = await prerenderToNodeStream(<App />, {\nbootstrapScripts: [assetMap['/main.js']]\n});\nresponse.setHeader('Content-Type', 'text/html');\nprelude.pipe(response);\n});\nSince your server is now rendering <App assetMap={assetMap} />\n, you need to render it with assetMap\non the client too to avoid hydration errors. You can serialize and pass assetMap\nto the client like this:\n// You'd need to get this JSON from your build tooling.\nconst assetMap = {\n'styles.css': '/styles.123456.css',\n'main.js': '/main.123456.js'\n};\napp.use('/', async (request, response) => {\nconst { prelude } = await prerenderToNodeStream(<App />, {\n// Careful: It's safe to stringify() this because this data isn't user-generated.\nbootstrapScriptContent: `window.assetMap = ${JSON.stringify(assetMap)};`,\nbootstrapScripts: [assetMap['/main.js']],\n});\nresponse.setHeader('Content-Type', 'text/html');\nprelude.pipe(response);\n});\nIn the example above, the bootstrapScriptContent\noption adds an extra inline <script>\ntag that sets the global window.assetMap\nvariable on the client. This lets the client code read the same assetMap\n:\nimport { hydrateRoot } from 'react-dom/client';\nimport App from './App.js';\nhydrateRoot(document, <App assetMap={window.assetMap} />);\nBoth client and server render App\nwith the same assetMap\nprop, so there are no hydration errors.\nRendering a React tree to a string of static HTML\nCall prerenderToNodeStream\nto render your app to a static HTML string:\nimport { prerenderToNodeStream } from 'react-dom/static';\nasync function renderToString() {\nconst {prelude} = await prerenderToNodeStream(<App />, {\nbootstrapScripts: ['/main.js']\n});\nreturn new Promise((resolve, reject) => {\nlet data = '';\nprelude.on('data', chunk => {\ndata += chunk;\n});\nprelude.on('end', () => resolve(data));\nprelude.on('error', reject);\n});\n}\nThis will produce the initial non-interactive HTML output of your React components. On the client, you will need to call hydrateRoot\nto hydrate that server-generated HTML and make it interactive.\nWaiting for all data to load\nprerenderToNodeStream\nwaits for all data to load before finishing the static HTML generation and resolving. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:\nfunction ProfilePage() {\nreturn (\n<ProfileLayout>\n<ProfileCover />\n<Sidebar>\n<Friends />\n<Photos />\n</Sidebar>\n<Suspense fallback={<PostsGlimmer />}>\n<Posts />\n</Suspense>\n</ProfileLayout>\n);\n}\nImagine that <Posts />\nneeds to load some data, which takes some time. Ideally, you\u2019d want wait for the posts to finish so it\u2019s included in the HTML. To do this, you can use Suspense to suspend on the data, and prerenderToNodeStream\nwill wait for the suspended content to finish before resolving to the static HTML.\nTroubleshooting\nMy stream doesn\u2019t start until the entire app is rendered\nThe prerenderToNodeStream\nresponse waits for the entire app to finish rendering, including waiting for all suspense boundaries to resolve, before resolving. It is designed for static site generation (SSG) ahead of time and does not support streaming more content as it loads.\nTo stream content as it loads, use a streaming server render API like renderToPipeableStream."
  },
  {
    "source": "https://react.dev/reference/react-dom/unmountComponentAtNode",
    "title": "unmountComponentAtNode \u2013 React",
    "text": "unmountComponentAtNode\nunmountComponentAtNode\nremoves a mounted React component from the DOM.\nunmountComponentAtNode(domNode)\nReference\nunmountComponentAtNode(domNode)\nCall unmountComponentAtNode\nto remove a mounted React component from the DOM and clean up its event handlers and state.\nimport { unmountComponentAtNode } from 'react-dom';\nconst domNode = document.getElementById('root');\nrender(<App />, domNode);\nunmountComponentAtNode(domNode);\nParameters\ndomNode\n: A DOM element. React will remove a mounted React component from this element.\nReturns\nunmountComponentAtNode\nreturns true\nif a component was unmounted and false\notherwise.\nUsage\nCall unmountComponentAtNode\nto remove a mounted React component from a browser DOM node and clean up its event handlers and state.\nimport { render, unmountComponentAtNode } from 'react-dom';\nimport App from './App.js';\nconst rootNode = document.getElementById('root');\nrender(<App />, rootNode);\n// ...\nunmountComponentAtNode(rootNode);\nRemoving a React app from a DOM element\nOccasionally, you may want to \u201csprinkle\u201d React on an existing page, or a page that is not fully written in React. In those cases, you may need to \u201cstop\u201d the React app, by removing all of the UI, state, and listeners from the DOM node it was rendered to.\nIn this example, clicking \u201cRender React App\u201d will render a React app. Click \u201cUnmount React App\u201d to destroy it:\nimport './styles.css'; import { render, unmountComponentAtNode } from 'react-dom'; import App from './App.js'; const domNode = document.getElementById('root'); document.getElementById('render').addEventListener('click', () => { render(<App />, domNode); }); document.getElementById('unmount').addEventListener('click', () => { unmountComponentAtNode(domNode); });"
  },
  {
    "source": "https://react.dev/reference/react/Children",
    "title": "Children \u2013 React",
    "text": "Children\nChildren\nlets you manipulate and transform the JSX you received as the children\nprop.\nconst mappedChildren = Children.map(children, child =>\n<div className=\"Row\">\n{child}\n</div>\n);\nReference\nChildren.count(children)\nCall Children.count(children)\nto count the number of children in the children\ndata structure.\nimport { Children } from 'react';\nfunction RowList({ children }) {\nreturn (\n<>\n<h1>Total rows: {Children.count(children)}</h1>\n...\n</>\n);\n}\nParameters\nchildren\n: The value of thechildren\nprop received by your component.\nReturns\nThe number of nodes inside these children\n.\nCaveats\n- Empty nodes (\nnull\n,undefined\n, and Booleans), strings, numbers, and React elements count as individual nodes. Arrays don\u2019t count as individual nodes, but their children do. The traversal does not go deeper than React elements: they don\u2019t get rendered, and their children aren\u2019t traversed. Fragments don\u2019t get traversed.\nChildren.forEach(children, fn, thisArg?)\nCall Children.forEach(children, fn, thisArg?)\nto run some code for each child in the children\ndata structure.\nimport { Children } from 'react';\nfunction SeparatorList({ children }) {\nconst result = [];\nChildren.forEach(children, (child, index) => {\nresult.push(child);\nresult.push(<hr key={index} />);\n});\n// ...\nParameters\nchildren\n: The value of thechildren\nprop received by your component.fn\n: The function you want to run for each child, similar to the arrayforEach\nmethod callback. It will be called with the child as the first argument and its index as the second argument. The index starts at0\nand increments on each call.- optional\nthisArg\n: Thethis\nvalue with which thefn\nfunction should be called. If omitted, it\u2019sundefined\n.\nReturns\nChildren.forEach\nreturns undefined\n.\nCaveats\n- Empty nodes (\nnull\n,undefined\n, and Booleans), strings, numbers, and React elements count as individual nodes. Arrays don\u2019t count as individual nodes, but their children do. The traversal does not go deeper than React elements: they don\u2019t get rendered, and their children aren\u2019t traversed. Fragments don\u2019t get traversed.\nChildren.map(children, fn, thisArg?)\nCall Children.map(children, fn, thisArg?)\nto map or transform each child in the children\ndata structure.\nimport { Children } from 'react';\nfunction RowList({ children }) {\nreturn (\n<div className=\"RowList\">\n{Children.map(children, child =>\n<div className=\"Row\">\n{child}\n</div>\n)}\n</div>\n);\n}\nParameters\nchildren\n: The value of thechildren\nprop received by your component.fn\n: The mapping function, similar to the arraymap\nmethod callback. It will be called with the child as the first argument and its index as the second argument. The index starts at0\nand increments on each call. You need to return a React node from this function. This may be an empty node (null\n,undefined\n, or a Boolean), a string, a number, a React element, or an array of other React nodes.- optional\nthisArg\n: Thethis\nvalue with which thefn\nfunction should be called. If omitted, it\u2019sundefined\n.\nReturns\nIf children\nis null\nor undefined\n, returns the same value.\nOtherwise, returns a flat array consisting of the nodes you\u2019ve returned from the fn\nfunction. The returned array will contain all nodes you returned except for null\nand undefined\n.\nCaveats\n-\nEmpty nodes (\nnull\n,undefined\n, and Booleans), strings, numbers, and React elements count as individual nodes. Arrays don\u2019t count as individual nodes, but their children do. The traversal does not go deeper than React elements: they don\u2019t get rendered, and their children aren\u2019t traversed. Fragments don\u2019t get traversed. -\nIf you return an element or an array of elements with keys from\nfn\n, the returned elements\u2019 keys will be automatically combined with the key of the corresponding original item fromchildren\n. When you return multiple elements fromfn\nin an array, their keys only need to be unique locally amongst each other.\nChildren.only(children)\nCall Children.only(children)\nto assert that children\nrepresent a single React element.\nfunction Box({ children }) {\nconst element = Children.only(children);\n// ...\nParameters\nchildren\n: The value of thechildren\nprop received by your component.\nReturns\nIf children\nis a valid element, returns that element.\nOtherwise, throws an error.\nCaveats\n- This method always throws if you pass an array (such as the return value of\nChildren.map\n) aschildren\n. In other words, it enforces thatchildren\nis a single React element, not that it\u2019s an array with a single element.\nChildren.toArray(children)\nCall Children.toArray(children)\nto create an array out of the children\ndata structure.\nimport { Children } from 'react';\nexport default function ReversedList({ children }) {\nconst result = Children.toArray(children);\nresult.reverse();\n// ...\nParameters\nchildren\n: The value of thechildren\nprop received by your component.\nReturns\nReturns a flat array of elements in children\n.\nCaveats\n- Empty nodes (\nnull\n,undefined\n, and Booleans) will be omitted in the returned array. The returned elements\u2019 keys will be calculated from the original elements\u2019 keys and their level of nesting and position. This ensures that flattening the array does not introduce changes in behavior.\nUsage\nTransforming children\nTo transform the children JSX that your component receives as the children\nprop, call Children.map\n:\nimport { Children } from 'react';\nfunction RowList({ children }) {\nreturn (\n<div className=\"RowList\">\n{Children.map(children, child =>\n<div className=\"Row\">\n{child}\n</div>\n)}\n</div>\n);\n}\nIn the example above, the RowList\nwraps every child it receives into a <div className=\"Row\">\ncontainer. For example, let\u2019s say the parent component passes three <p>\ntags as the children\nprop to RowList\n:\n<RowList>\n<p>This is the first item.</p>\n<p>This is the second item.</p>\n<p>This is the third item.</p>\n</RowList>\nThen, with the RowList\nimplementation above, the final rendered result will look like this:\n<div className=\"RowList\">\n<div className=\"Row\">\n<p>This is the first item.</p>\n</div>\n<div className=\"Row\">\n<p>This is the second item.</p>\n</div>\n<div className=\"Row\">\n<p>This is the third item.</p>\n</div>\n</div>\nChildren.map\nis similar to to transforming arrays with map()\n. The difference is that the children\ndata structure is considered opaque. This means that even if it\u2019s sometimes an array, you should not assume it\u2019s an array or any other particular data type. This is why you should use Children.map\nif you need to transform it.\nimport { Children } from 'react'; export default function RowList({ children }) { return ( <div className=\"RowList\"> {Children.map(children, child => <div className=\"Row\"> {child} </div> )} </div> ); }\nDeep Dive\nIn React, the children\nprop is considered an opaque data structure. This means that you shouldn\u2019t rely on how it is structured. To transform, filter, or count children, you should use the Children\nmethods.\nIn practice, the children\ndata structure is often represented as an array internally. However, if there is only a single child, then React won\u2019t create an extra array since this would lead to unnecessary memory overhead. As long as you use the Children\nmethods instead of directly introspecting the children\nprop, your code will not break even if React changes how the data structure is actually implemented.\nEven when children\nis an array, Children.map\nhas useful special behavior. For example, Children.map\ncombines the keys on the returned elements with the keys on the children\nyou\u2019ve passed to it. This ensures the original JSX children don\u2019t \u201close\u201d keys even if they get wrapped like in the example above.\nRunning some code for each child\nCall Children.forEach\nto iterate over each child in the children\ndata structure. It does not return any value and is similar to the array forEach\nmethod. You can use it to run custom logic like constructing your own array.\nimport { Children } from 'react'; export default function SeparatorList({ children }) { const result = []; Children.forEach(children, (child, index) => { result.push(child); result.push(<hr key={index} />); }); result.pop(); // Remove the last separator return result; }\nimport { Children } from 'react'; export default function RowList({ children }) { return ( <div className=\"RowList\"> <h1 className=\"RowListHeader\"> Total rows: {Children.count(children)} </h1> {Children.map(children, child => <div className=\"Row\"> {child} </div> )} </div> ); }\nConverting children to an array\nCall Children.toArray(children)\nto turn the children\ndata structure into a regular JavaScript array. This lets you manipulate the array with built-in array methods like filter\n, sort\n, or reverse\n.\nimport { Children } from 'react'; export default function ReversedList({ children }) { const result = Children.toArray(children); result.reverse(); return result; }\nAlternatives\nExposing multiple components\nManipulating children with the Children\nmethods often leads to fragile code. When you pass children to a component in JSX, you don\u2019t usually expect the component to manipulate or transform the individual children.\nWhen you can, try to avoid using the Children\nmethods. For example, if you want every child of RowList\nto be wrapped in <div className=\"Row\">\n, export a Row\ncomponent, and manually wrap every row into it like this:\nimport { RowList, Row } from './RowList.js'; export default function App() { return ( <RowList> <Row> <p>This is the first item.</p> </Row> <Row> <p>This is the second item.</p> </Row> <Row> <p>This is the third item.</p> </Row> </RowList> ); }\nUnlike using Children.map\n, this approach does not wrap every child automatically. However, this approach has a significant benefit compared to the earlier example with Children.map\nbecause it works even if you keep extracting more components. For example, it still works if you extract your own MoreRows\ncomponent:\nimport { RowList, Row } from './RowList.js'; export default function App() { return ( <RowList> <Row> <p>This is the first item.</p> </Row> <MoreRows /> </RowList> ); } function MoreRows() { return ( <> <Row> <p>This is the second item.</p> </Row> <Row> <p>This is the third item.</p> </Row> </> ); }\nThis wouldn\u2019t work with Children.map\nbecause it would \u201csee\u201d <MoreRows />\nas a single child (and a single row).\nAccepting an array of objects as a prop\nYou can also explicitly pass an array as a prop. For example, this RowList\naccepts a rows\narray as a prop:\nimport { RowList, Row } from './RowList.js'; export default function App() { return ( <RowList rows={[ { id: 'first', content: <p>This is the first item.</p> }, { id: 'second', content: <p>This is the second item.</p> }, { id: 'third', content: <p>This is the third item.</p> } ]} /> ); }\nSince rows\nis a regular JavaScript array, the RowList\ncomponent can use built-in array methods like map\non it.\nThis pattern is especially useful when you want to be able to pass more information as structured data together with children. In the below example, the TabSwitcher\ncomponent receives an array of objects as the tabs\nprop:\nimport TabSwitcher from './TabSwitcher.js'; export default function App() { return ( <TabSwitcher tabs={[ { id: 'first', header: 'First', content: <p>This is the first item.</p> }, { id: 'second', header: 'Second', content: <p>This is the second item.</p> }, { id: 'third', header: 'Third', content: <p>This is the third item.</p> } ]} /> ); }\nUnlike passing the children as JSX, this approach lets you associate some extra data like header\nwith each item. Because you are working with the tabs\ndirectly, and it is an array, you do not need the Children\nmethods.\nCalling a render prop to customize rendering\nInstead of producing JSX for every single item, you can also pass a function that returns JSX, and call that function when necessary. In this example, the App\ncomponent passes a renderContent\nfunction to the TabSwitcher\ncomponent. The TabSwitcher\ncomponent calls renderContent\nonly for the selected tab:\nimport TabSwitcher from './TabSwitcher.js'; export default function App() { return ( <TabSwitcher tabIds={['first', 'second', 'third']} getHeader={tabId => { return tabId[0].toUpperCase() + tabId.slice(1); }} renderContent={tabId => { return <p>This is the {tabId} item.</p>; }} /> ); }\nA prop like renderContent\nis called a render prop because it is a prop that specifies how to render a piece of the user interface. However, there is nothing special about it: it is a regular prop which happens to be a function.\nRender props are functions, so you can pass information to them. For example, this RowList\ncomponent passes the id\nand the index\nof each row to the renderRow\nrender prop, which uses index\nto highlight even rows:\nimport { RowList, Row } from './RowList.js'; export default function App() { return ( <RowList rowIds={['first', 'second', 'third']} renderRow={(id, index) => { return ( <Row isHighlighted={index % 2 === 0}> <p>This is the {id} item.</p> </Row> ); }} /> ); }\nThis is another example of how parent and child components can cooperate without manipulating the children.\nTroubleshooting\nI pass a custom component, but the Children\nmethods don\u2019t show its render result\nSuppose you pass two children to RowList\nlike this:\n<RowList>\n<p>First item</p>\n<MoreRows />\n</RowList>\nIf you do Children.count(children)\ninside RowList\n, you will get 2\n. Even if MoreRows\nrenders 10 different items, or if it returns null\n, Children.count(children)\nwill still be 2\n. From the RowList\n\u2019s perspective, it only \u201csees\u201d the JSX it has received. It does not \u201csee\u201d the internals of the MoreRows\ncomponent.\nThe limitation makes it hard to extract a component. This is why alternatives are preferred to using Children\n."
  },
  {
    "source": "https://react.dev/reference/react/Component",
    "title": "Component \u2013 React",
    "text": "Component\nComponent\nis the base class for the React components defined as JavaScript classes. Class components are still supported by React, but we don\u2019t recommend using them in new code.\nclass Greeting extends Component {\nrender() {\nreturn <h1>Hello, {this.props.name}!</h1>;\n}\n}\n- Reference\nComponent\ncontext\nprops\nstate\nconstructor(props)\ncomponentDidCatch(error, info)\ncomponentDidMount()\ncomponentDidUpdate(prevProps, prevState, snapshot?)\ncomponentWillMount()\ncomponentWillReceiveProps(nextProps)\ncomponentWillUpdate(nextProps, nextState)\ncomponentWillUnmount()\nforceUpdate(callback?)\ngetSnapshotBeforeUpdate(prevProps, prevState)\nrender()\nsetState(nextState, callback?)\nshouldComponentUpdate(nextProps, nextState, nextContext)\nUNSAFE_componentWillMount()\nUNSAFE_componentWillReceiveProps(nextProps, nextContext)\nUNSAFE_componentWillUpdate(nextProps, nextState)\nstatic contextType\nstatic defaultProps\nstatic getDerivedStateFromError(error)\nstatic getDerivedStateFromProps(props, state)\n- Usage\n- Alternatives\nReference\nComponent\nTo define a React component as a class, extend the built-in Component\nclass and define a render\nmethod:\nimport { Component } from 'react';\nclass Greeting extends Component {\nrender() {\nreturn <h1>Hello, {this.props.name}!</h1>;\n}\n}\nOnly the render\nmethod is required, other methods are optional.\ncontext\nThe context of a class component is available as this.context\n. It is only available if you specify which context you want to receive using static contextType\n.\nA class component can only read one context at a time.\nclass Button extends Component {\nstatic contextType = ThemeContext;\nrender() {\nconst theme = this.context;\nconst className = 'button-' + theme;\nreturn (\n<button className={className}>\n{this.props.children}\n</button>\n);\n}\n}\nprops\nThe props passed to a class component are available as this.props\n.\nclass Greeting extends Component {\nrender() {\nreturn <h1>Hello, {this.props.name}!</h1>;\n}\n}\n<Greeting name=\"Taylor\" />\nstate\nThe state of a class component is available as this.state\n. The state\nfield must be an object. Do not mutate the state directly. If you wish to change the state, call setState\nwith the new state.\nclass Counter extends Component {\nstate = {\nage: 42,\n};\nhandleAgeChange = () => {\nthis.setState({\nage: this.state.age + 1\n});\n};\nrender() {\nreturn (\n<>\n<button onClick={this.handleAgeChange}>\nIncrement age\n</button>\n<p>You are {this.state.age}.</p>\n</>\n);\n}\n}\nconstructor(props)\nThe constructor runs before your class component mounts (gets added to the screen). Typically, a constructor is only used for two purposes in React. It lets you declare state and bind your class methods to the class instance:\nclass Counter extends Component {\nconstructor(props) {\nsuper(props);\nthis.state = { counter: 0 };\nthis.handleClick = this.handleClick.bind(this);\n}\nhandleClick() {\n// ...\n}\nIf you use modern JavaScript syntax, constructors are rarely needed. Instead, you can rewrite this code above using the public class field syntax which is supported both by modern browsers and tools like Babel:\nclass Counter extends Component {\nstate = { counter: 0 };\nhandleClick = () => {\n// ...\n}\nA constructor should not contain any side effects or subscriptions.\nParameters\nprops\n: The component\u2019s initial props.\nReturns\nconstructor\nshould not return anything.\nCaveats\n-\nDo not run any side effects or subscriptions in the constructor. Instead, use\ncomponentDidMount\nfor that. -\nInside a constructor, you need to call\nsuper(props)\nbefore any other statement. If you don\u2019t do that,this.props\nwill beundefined\nwhile the constructor runs, which can be confusing and cause bugs. -\nConstructor is the only place where you can assign\nthis.state\ndirectly. In all other methods, you need to usethis.setState()\ninstead. Do not callsetState\nin the constructor. -\nWhen you use server rendering, the constructor will run on the server too, followed by the\nrender\nmethod. However, lifecycle methods likecomponentDidMount\norcomponentWillUnmount\nwill not run on the server. -\nWhen Strict Mode is on, React will call\nconstructor\ntwice in development and then throw away one of the instances. This helps you notice the accidental side effects that need to be moved out of theconstructor\n.\ncomponentDidCatch(error, info)\nIf you define componentDidCatch\n, React will call it when some child component (including distant children) throws an error during rendering. This lets you log that error to an error reporting service in production.\nTypically, it is used together with static getDerivedStateFromError\nwhich lets you update state in response to an error and display an error message to the user. A component with these methods is called an error boundary.\nParameters\n-\nerror\n: The error that was thrown. In practice, it will usually be an instance ofError\nbut this is not guaranteed because JavaScript allows tothrow\nany value, including strings or evennull\n. -\ninfo\n: An object containing additional information about the error. ItscomponentStack\nfield contains a stack trace with the component that threw, as well as the names and source locations of all its parent components. In production, the component names will be minified. If you set up production error reporting, you can decode the component stack using sourcemaps the same way as you would do for regular JavaScript error stacks.\nReturns\ncomponentDidCatch\nshould not return anything.\nCaveats\n-\nIn the past, it was common to call\nsetState\ninsidecomponentDidCatch\nin order to update the UI and display the fallback error message. This is deprecated in favor of definingstatic getDerivedStateFromError\n. -\nProduction and development builds of React slightly differ in the way\ncomponentDidCatch\nhandles errors. In development, the errors will bubble up towindow\n, which means that anywindow.onerror\norwindow.addEventListener('error', callback)\nwill intercept the errors that have been caught bycomponentDidCatch\n. In production, instead, the errors will not bubble up, which means any ancestor error handler will only receive errors not explicitly caught bycomponentDidCatch\n.\ncomponentDidMount()\nIf you define the componentDidMount\nmethod, React will call it when your component is added (mounted) to the screen. This is a common place to start data fetching, set up subscriptions, or manipulate the DOM nodes.\nIf you implement componentDidMount\n, you usually need to implement other lifecycle methods to avoid bugs. For example, if componentDidMount\nreads some state or props, you also have to implement componentDidUpdate\nto handle their changes, and componentWillUnmount\nto clean up whatever componentDidMount\nwas doing.\nclass ChatRoom extends Component {\nstate = {\nserverUrl: 'https://localhost:1234'\n};\ncomponentDidMount() {\nthis.setupConnection();\n}\ncomponentDidUpdate(prevProps, prevState) {\nif (\nthis.props.roomId !== prevProps.roomId ||\nthis.state.serverUrl !== prevState.serverUrl\n) {\nthis.destroyConnection();\nthis.setupConnection();\n}\n}\ncomponentWillUnmount() {\nthis.destroyConnection();\n}\n// ...\n}\nParameters\ncomponentDidMount\ndoes not take any parameters.\nReturns\ncomponentDidMount\nshould not return anything.\nCaveats\n-\nWhen Strict Mode is on, in development React will call\ncomponentDidMount\n, then immediately callcomponentWillUnmount\n, and then callcomponentDidMount\nagain. This helps you notice if you forgot to implementcomponentWillUnmount\nor if its logic doesn\u2019t fully \u201cmirror\u201d whatcomponentDidMount\ndoes. -\nAlthough you may call\nsetState\nimmediately incomponentDidMount\n, it\u2019s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though therender\nwill be called twice in this case, the user won\u2019t see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in theconstructor\ninstead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.\ncomponentDidUpdate(prevProps, prevState, snapshot?)\nIf you define the componentDidUpdate\nmethod, React will call it immediately after your component has been re-rendered with updated props or state. This method is not called for the initial render.\nYou can use it to manipulate the DOM after an update. This is also a common place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed). Typically, you\u2019d use it together with componentDidMount\nand componentWillUnmount\n:\nclass ChatRoom extends Component {\nstate = {\nserverUrl: 'https://localhost:1234'\n};\ncomponentDidMount() {\nthis.setupConnection();\n}\ncomponentDidUpdate(prevProps, prevState) {\nif (\nthis.props.roomId !== prevProps.roomId ||\nthis.state.serverUrl !== prevState.serverUrl\n) {\nthis.destroyConnection();\nthis.setupConnection();\n}\n}\ncomponentWillUnmount() {\nthis.destroyConnection();\n}\n// ...\n}\nParameters\n-\nprevProps\n: Props before the update. CompareprevProps\ntothis.props\nto determine what changed. -\nprevState\n: State before the update. CompareprevState\ntothis.state\nto determine what changed. -\nsnapshot\n: If you implementedgetSnapshotBeforeUpdate\n,snapshot\nwill contain the value you returned from that method. Otherwise, it will beundefined\n.\nReturns\ncomponentDidUpdate\nshould not return anything.\nCaveats\n-\ncomponentDidUpdate\nwill not get called ifshouldComponentUpdate\nis defined and returnsfalse\n. -\nThe logic inside\ncomponentDidUpdate\nshould usually be wrapped in conditions comparingthis.props\nwithprevProps\n, andthis.state\nwithprevState\n. Otherwise, there\u2019s a risk of creating infinite loops. -\nAlthough you may call\nsetState\nimmediately incomponentDidUpdate\n, it\u2019s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though therender\nwill be called twice in this case, the user won\u2019t see the intermediate state. This pattern often causes performance issues, but it may be necessary for rare cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.\ncomponentWillMount()\ncomponentWillReceiveProps(nextProps)\ncomponentWillUpdate(nextProps, nextState)\ncomponentWillUnmount()\nIf you define the componentWillUnmount\nmethod, React will call it before your component is removed (unmounted) from the screen. This is a common place to cancel data fetching or remove subscriptions.\nThe logic inside componentWillUnmount\nshould \u201cmirror\u201d the logic inside componentDidMount\n. For example, if componentDidMount\nsets up a subscription, componentWillUnmount\nshould clean up that subscription. If the cleanup logic in your componentWillUnmount\nreads some props or state, you will usually also need to implement componentDidUpdate\nto clean up resources (such as subscriptions) corresponding to the old props and state.\nclass ChatRoom extends Component {\nstate = {\nserverUrl: 'https://localhost:1234'\n};\ncomponentDidMount() {\nthis.setupConnection();\n}\ncomponentDidUpdate(prevProps, prevState) {\nif (\nthis.props.roomId !== prevProps.roomId ||\nthis.state.serverUrl !== prevState.serverUrl\n) {\nthis.destroyConnection();\nthis.setupConnection();\n}\n}\ncomponentWillUnmount() {\nthis.destroyConnection();\n}\n// ...\n}\nParameters\ncomponentWillUnmount\ndoes not take any parameters.\nReturns\ncomponentWillUnmount\nshould not return anything.\nCaveats\n- When Strict Mode is on, in development React will call\ncomponentDidMount\n, then immediately callcomponentWillUnmount\n, and then callcomponentDidMount\nagain. This helps you notice if you forgot to implementcomponentWillUnmount\nor if its logic doesn\u2019t fully \u201cmirror\u201d whatcomponentDidMount\ndoes.\nforceUpdate(callback?)\nForces a component to re-render.\nUsually, this is not necessary. If your component\u2019s render\nmethod only reads from this.props\n, this.state\n, or this.context\n, it will re-render automatically when you call setState\ninside your component or one of its parents. However, if your component\u2019s render\nmethod reads directly from an external data source, you have to tell React to update the user interface when that data source changes. That\u2019s what forceUpdate\nlets you do.\nTry to avoid all uses of forceUpdate\nand only read from this.props\nand this.state\nin render\n.\nParameters\n- optional\ncallback\nIf specified, React will call thecallback\nyou\u2019ve provided after the update is committed.\nReturns\nforceUpdate\ndoes not return anything.\nCaveats\n- If you call\nforceUpdate\n, React will re-render without callingshouldComponentUpdate\n.\ngetSnapshotBeforeUpdate(prevProps, prevState)\nIf you implement getSnapshotBeforeUpdate\n, React will call it immediately before React updates the DOM. It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle method will be passed as a parameter to componentDidUpdate\n.\nFor example, you can use it in a UI like a chat thread that needs to preserve its scroll position during updates:\nclass ScrollingList extends React.Component {\nconstructor(props) {\nsuper(props);\nthis.listRef = React.createRef();\n}\ngetSnapshotBeforeUpdate(prevProps, prevState) {\n// Are we adding new items to the list?\n// Capture the scroll position so we can adjust scroll later.\nif (prevProps.list.length < this.props.list.length) {\nconst list = this.listRef.current;\nreturn list.scrollHeight - list.scrollTop;\n}\nreturn null;\n}\ncomponentDidUpdate(prevProps, prevState, snapshot) {\n// If we have a snapshot value, we've just added new items.\n// Adjust scroll so these new items don't push the old ones out of view.\n// (snapshot here is the value returned from getSnapshotBeforeUpdate)\nif (snapshot !== null) {\nconst list = this.listRef.current;\nlist.scrollTop = list.scrollHeight - snapshot;\n}\n}\nrender() {\nreturn (\n<div ref={this.listRef}>{/* ...contents... */}</div>\n);\n}\n}\nIn the above example, it is important to read the scrollHeight\nproperty directly in getSnapshotBeforeUpdate\n. It is not safe to read it in render\n, UNSAFE_componentWillReceiveProps\n, or UNSAFE_componentWillUpdate\nbecause there is a potential time gap between these methods getting called and React updating the DOM.\nParameters\n-\nprevProps\n: Props before the update. CompareprevProps\ntothis.props\nto determine what changed. -\nprevState\n: State before the update. CompareprevState\ntothis.state\nto determine what changed.\nReturns\nYou should return a snapshot value of any type that you\u2019d like, or null\n. The value you returned will be passed as the third argument to componentDidUpdate\n.\nCaveats\ngetSnapshotBeforeUpdate\nwill not get called ifshouldComponentUpdate\nis defined and returnsfalse\n.\nrender()\nThe render\nmethod is the only required method in a class component.\nThe render\nmethod should specify what you want to appear on the screen, for example:\nimport { Component } from 'react';\nclass Greeting extends Component {\nrender() {\nreturn <h1>Hello, {this.props.name}!</h1>;\n}\n}\nReact may call render\nat any moment, so you shouldn\u2019t assume that it runs at a particular time. Usually, the render\nmethod should return a piece of JSX, but a few other return types (like strings) are supported. To calculate the returned JSX, the render\nmethod can read this.props\n, this.state\n, and this.context\n.\nYou should write the render\nmethod as a pure function, meaning that it should return the same result if props, state, and context are the same. It also shouldn\u2019t contain side effects (like setting up subscriptions) or interact with the browser APIs. Side effects should happen either in event handlers or methods like componentDidMount\n.\nParameters\nrender\ndoes not take any parameters.\nReturns\nrender\ncan return any valid React node. This includes React elements such as <div />\n, strings, numbers, portals, empty nodes (null\n, undefined\n, true\n, and false\n), and arrays of React nodes.\nCaveats\n-\nrender\nshould be written as a pure function of props, state, and context. It should not have side effects. -\nrender\nwill not get called ifshouldComponentUpdate\nis defined and returnsfalse\n. -\nWhen Strict Mode is on, React will call\nrender\ntwice in development and then throw away one of the results. This helps you notice the accidental side effects that need to be moved out of therender\nmethod. -\nThere is no one-to-one correspondence between the\nrender\ncall and the subsequentcomponentDidMount\norcomponentDidUpdate\ncall. Some of therender\ncall results may be discarded by React when it\u2019s beneficial.\nsetState(nextState, callback?)\nCall setState\nto update the state of your React component.\nclass Form extends Component {\nstate = {\nname: 'Taylor',\n};\nhandleNameChange = (e) => {\nconst newName = e.target.value;\nthis.setState({\nname: newName\n});\n}\nrender() {\nreturn (\n<>\n<input value={this.state.name} onChange={this.handleNameChange} />\n<p>Hello, {this.state.name}.</p>\n</>\n);\n}\n}\nsetState\nenqueues changes to the component state. It tells React that this component and its children need to re-render with the new state. This is the main way you\u2019ll update the user interface in response to interactions.\nYou can also pass a function to setState\n. It lets you update state based on the previous state:\nhandleIncreaseAge = () => {\nthis.setState(prevState => {\nreturn {\nage: prevState.age + 1\n};\n});\n}\nYou don\u2019t have to do this, but it\u2019s handy if you want to update state multiple times during the same event.\nParameters\n-\nnextState\n: Either an object or a function.- If you pass an object as\nnextState\n, it will be shallowly merged intothis.state\n. - If you pass a function as\nnextState\n, it will be treated as an updater function. It must be pure, should take the pending state and props as arguments, and should return the object to be shallowly merged intothis.state\n. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state.\n- If you pass an object as\n-\noptional\ncallback\n: If specified, React will call thecallback\nyou\u2019ve provided after the update is committed.\nReturns\nsetState\ndoes not return anything.\nCaveats\n-\nThink of\nsetState\nas a request rather than an immediate command to update the component. When multiple components update their state in response to an event, React will batch their updates and re-render them together in a single pass at the end of the event. In the rare case that you need to force a particular state update to be applied synchronously, you may wrap it influshSync\n, but this may hurt performance. -\nsetState\ndoes not updatethis.state\nimmediately. This makes readingthis.state\nright after callingsetState\na potential pitfall. Instead, usecomponentDidUpdate\nor the setStatecallback\nargument, either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, you can pass a function tonextState\nas described above.\nshouldComponentUpdate(nextProps, nextState, nextContext)\nIf you define shouldComponentUpdate\n, React will call it to determine whether a re-render can be skipped.\nIf you are confident you want to write it by hand, you may compare this.props\nwith nextProps\nand this.state\nwith nextState\nand return false\nto tell React the update can be skipped.\nclass Rectangle extends Component {\nstate = {\nisHovered: false\n};\nshouldComponentUpdate(nextProps, nextState) {\nif (\nnextProps.position.x === this.props.position.x &&\nnextProps.position.y === this.props.position.y &&\nnextProps.size.width === this.props.size.width &&\nnextProps.size.height === this.props.size.height &&\nnextState.isHovered === this.state.isHovered\n) {\n// Nothing has changed, so a re-render is unnecessary\nreturn false;\n}\nreturn true;\n}\n// ...\n}\nReact calls shouldComponentUpdate\nbefore rendering when new props or state are being received. Defaults to true\n. This method is not called for the initial render or when forceUpdate\nis used.\nParameters\nnextProps\n: The next props that the component is about to render with. ComparenextProps\ntothis.props\nto determine what changed.nextState\n: The next state that the component is about to render with. ComparenextState\ntothis.state\nto determine what changed.nextContext\n: The next context that the component is about to render with. ComparenextContext\ntothis.context\nto determine what changed. Only available if you specifystatic contextType\n.\nReturns\nReturn true\nif you want the component to re-render. That\u2019s the default behavior.\nReturn false\nto tell React that re-rendering can be skipped.\nCaveats\n-\nThis method only exists as a performance optimization. If your component breaks without it, fix that first.\n-\nConsider using\nPureComponent\ninstead of writingshouldComponentUpdate\nby hand.PureComponent\nshallowly compares props and state, and reduces the chance that you\u2019ll skip a necessary update. -\nWe do not recommend doing deep equality checks or using\nJSON.stringify\ninshouldComponentUpdate\n. It makes performance unpredictable and dependent on the data structure of every prop and state. In the best case, you risk introducing multi-second stalls to your application, and in the worst case you risk crashing it. -\nReturning\nfalse\ndoes not prevent child components from re-rendering when their state changes. -\nReturning\nfalse\ndoes not guarantee that the component will not re-render. React will use the return value as a hint but it may still choose to re-render your component if it makes sense to do for other reasons.\nUNSAFE_componentWillMount()\nIf you define UNSAFE_componentWillMount\n, React will call it immediately after the constructor\n. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:\n- To initialize state, declare\nstate\nas a class field or setthis.state\ninside theconstructor\n. - If you need to run a side effect or set up a subscription, move that logic to\ncomponentDidMount\ninstead.\nSee examples of migrating away from unsafe lifecycles.\nParameters\nUNSAFE_componentWillMount\ndoes not take any parameters.\nReturns\nUNSAFE_componentWillMount\nshould not return anything.\nCaveats\n-\nUNSAFE_componentWillMount\nwill not get called if the component implementsstatic getDerivedStateFromProps\norgetSnapshotBeforeUpdate\n. -\nDespite its naming,\nUNSAFE_componentWillMount\ndoes not guarantee that the component will get mounted if your app uses modern React features likeSuspense\n. If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. This is why this method is \u201cunsafe\u201d. Code that relies on mounting (like adding a subscription) should go intocomponentDidMount\n. -\nUNSAFE_componentWillMount\nis the only lifecycle method that runs during server rendering. For all practical purposes, it is identical toconstructor\n, so you should use theconstructor\nfor this type of logic instead.\nUNSAFE_componentWillReceiveProps(nextProps, nextContext)\nIf you define UNSAFE_componentWillReceiveProps\n, React will call it when the component receives new props. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:\n- If you need to run a side effect (for example, fetch data, run an animation, or reinitialize a subscription) in response to prop changes, move that logic to\ncomponentDidUpdate\ninstead. - If you need to avoid re-computing some data only when a prop changes, use a memoization helper instead.\n- If you need to \u201creset\u201d some state when a prop changes, consider either making a component fully controlled or fully uncontrolled with a key instead.\n- If you need to \u201cadjust\u201d some state when a prop changes, check whether you can compute all the necessary information from props alone during rendering. If you can\u2019t, use\nstatic getDerivedStateFromProps\ninstead.\nSee examples of migrating away from unsafe lifecycles.\nParameters\nnextProps\n: The next props that the component is about to receive from its parent component. ComparenextProps\ntothis.props\nto determine what changed.nextContext\n: The next context that the component is about to receive from the closest provider. ComparenextContext\ntothis.context\nto determine what changed. Only available if you specifystatic contextType\n.\nReturns\nUNSAFE_componentWillReceiveProps\nshould not return anything.\nCaveats\n-\nUNSAFE_componentWillReceiveProps\nwill not get called if the component implementsstatic getDerivedStateFromProps\norgetSnapshotBeforeUpdate\n. -\nDespite its naming,\nUNSAFE_componentWillReceiveProps\ndoes not guarantee that the component will receive those props if your app uses modern React features likeSuspense\n. If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props might be different. This is why this method is \u201cunsafe\u201d. Code that should run only for committed updates (like resetting a subscription) should go intocomponentDidUpdate\n. -\nUNSAFE_componentWillReceiveProps\ndoes not mean that the component has received different props than the last time. You need to comparenextProps\nandthis.props\nyourself to check if something changed. -\nReact doesn\u2019t call\nUNSAFE_componentWillReceiveProps\nwith initial props during mounting. It only calls this method if some of component\u2019s props are going to be updated. For example, callingsetState\ndoesn\u2019t generally triggerUNSAFE_componentWillReceiveProps\ninside the same component.\nUNSAFE_componentWillUpdate(nextProps, nextState)\nIf you define UNSAFE_componentWillUpdate\n, React will call it before rendering with the new props or state. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:\n- If you need to run a side effect (for example, fetch data, run an animation, or reinitialize a subscription) in response to prop or state changes, move that logic to\ncomponentDidUpdate\ninstead. - If you need to read some information from the DOM (for example, to save the current scroll position) so that you can use it in\ncomponentDidUpdate\nlater, read it insidegetSnapshotBeforeUpdate\ninstead.\nSee examples of migrating away from unsafe lifecycles.\nParameters\nnextProps\n: The next props that the component is about to render with. ComparenextProps\ntothis.props\nto determine what changed.nextState\n: The next state that the component is about to render with. ComparenextState\ntothis.state\nto determine what changed.\nReturns\nUNSAFE_componentWillUpdate\nshould not return anything.\nCaveats\n-\nUNSAFE_componentWillUpdate\nwill not get called ifshouldComponentUpdate\nis defined and returnsfalse\n. -\nUNSAFE_componentWillUpdate\nwill not get called if the component implementsstatic getDerivedStateFromProps\norgetSnapshotBeforeUpdate\n. -\nIt\u2019s not supported to call\nsetState\n(or any method that leads tosetState\nbeing called, like dispatching a Redux action) duringcomponentWillUpdate\n. -\nDespite its naming,\nUNSAFE_componentWillUpdate\ndoes not guarantee that the component will update if your app uses modern React features likeSuspense\n. If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props and state might be different. This is why this method is \u201cunsafe\u201d. Code that should run only for committed updates (like resetting a subscription) should go intocomponentDidUpdate\n. -\nUNSAFE_componentWillUpdate\ndoes not mean that the component has received different props or state than the last time. You need to comparenextProps\nwiththis.props\nandnextState\nwiththis.state\nyourself to check if something changed. -\nReact doesn\u2019t call\nUNSAFE_componentWillUpdate\nwith initial props and state during mounting.\nstatic contextType\nIf you want to read this.context\nfrom your class component, you must specify which context it needs to read. The context you specify as the static contextType\nmust be a value previously created by createContext\n.\nclass Button extends Component {\nstatic contextType = ThemeContext;\nrender() {\nconst theme = this.context;\nconst className = 'button-' + theme;\nreturn (\n<button className={className}>\n{this.props.children}\n</button>\n);\n}\n}\nstatic defaultProps\nYou can define static defaultProps\nto set the default props for the class. They will be used for undefined\nand missing props, but not for null\nprops.\nFor example, here is how you define that the color\nprop should default to 'blue'\n:\nclass Button extends Component {\nstatic defaultProps = {\ncolor: 'blue'\n};\nrender() {\nreturn <button className={this.props.color}>click me</button>;\n}\n}\nIf the color\nprop is not provided or is undefined\n, it will be set by default to 'blue'\n:\n<>\n{/* this.props.color is \"blue\" */}\n<Button />\n{/* this.props.color is \"blue\" */}\n<Button color={undefined} />\n{/* this.props.color is null */}\n<Button color={null} />\n{/* this.props.color is \"red\" */}\n<Button color=\"red\" />\n</>\nstatic getDerivedStateFromError(error)\nIf you define static getDerivedStateFromError\n, React will call it when a child component (including distant children) throws an error during rendering. This lets you display an error message instead of clearing the UI.\nTypically, it is used together with componentDidCatch\nwhich lets you send the error report to some analytics service. A component with these methods is called an error boundary.\nParameters\nerror\n: The error that was thrown. In practice, it will usually be an instance ofError\nbut this is not guaranteed because JavaScript allows tothrow\nany value, including strings or evennull\n.\nReturns\nstatic getDerivedStateFromError\nshould return the state telling the component to display the error message.\nCaveats\nstatic getDerivedStateFromError\nshould be a pure function. If you want to perform a side effect (for example, to call an analytics service), you need to also implementcomponentDidCatch\n.\nstatic getDerivedStateFromProps(props, state)\nIf you define static getDerivedStateFromProps\n, React will call it right before calling render\n, both on the initial mount and on subsequent updates. It should return an object to update the state, or null\nto update nothing.\nThis method exists for rare use cases where the state depends on changes in props over time. For example, this Form\ncomponent resets the email\nstate when the userID\nprop changes:\nclass Form extends Component {\nstate = {\nemail: this.props.defaultEmail,\nprevUserID: this.props.userID\n};\nstatic getDerivedStateFromProps(props, state) {\n// Any time the current user changes,\n// Reset any parts of state that are tied to that user.\n// In this simple example, that's just the email.\nif (props.userID !== state.prevUserID) {\nreturn {\nprevUserID: props.userID,\nemail: props.defaultEmail\n};\n}\nreturn null;\n}\n// ...\n}\nNote that this pattern requires you to keep a previous value of the prop (like userID\n) in state (like prevUserID\n).\nParameters\nprops\n: The next props that the component is about to render with.state\n: The next state that the component is about to render with.\nReturns\nstatic getDerivedStateFromProps\nreturn an object to update the state, or null\nto update nothing.\nCaveats\n-\nThis method is fired on every render, regardless of the cause. This is different from\nUNSAFE_componentWillReceiveProps\n, which only fires when the parent causes a re-render and not as a result of a localsetState\n. -\nThis method doesn\u2019t have access to the component instance. If you\u2019d like, you can reuse some code between\nstatic getDerivedStateFromProps\nand the other class methods by extracting pure functions of the component props and state outside the class definition.\nUsage\nDefining a class component\nTo define a React component as a class, extend the built-in Component\nclass and define a render\nmethod:\nimport { Component } from 'react';\nclass Greeting extends Component {\nrender() {\nreturn <h1>Hello, {this.props.name}!</h1>;\n}\n}\nReact will call your render\nmethod whenever it needs to figure out what to display on the screen. Usually, you will return some JSX from it. Your render\nmethod should be a pure function: it should only calculate the JSX.\nSimilarly to function components, a class component can receive information by props from its parent component. However, the syntax for reading props is different. For example, if the parent component renders <Greeting name=\"Taylor\" />\n, then you can read the name\nprop from this.props\n, like this.props.name\n:\nimport { Component } from 'react'; class Greeting extends Component { render() { return <h1>Hello, {this.props.name}!</h1>; } } export default function App() { return ( <> <Greeting name=\"Sara\" /> <Greeting name=\"Cahal\" /> <Greeting name=\"Edite\" /> </> ); }\nNote that Hooks (functions starting with use\n, like useState\n) are not supported inside class components.\nAdding state to a class component\nTo add state to a class, assign an object to a property called state\n. To update state, call this.setState\n.\nimport { Component } from 'react'; export default class Counter extends Component { state = { name: 'Taylor', age: 42, }; handleNameChange = (e) => { this.setState({ name: e.target.value }); } handleAgeChange = () => { this.setState({ age: this.state.age + 1 }); }; render() { return ( <> <input value={this.state.name} onChange={this.handleNameChange} /> <button onClick={this.handleAgeChange}> Increment age </button> <p>Hello, {this.state.name}. You are {this.state.age}.</p> </> ); } }\nAdding lifecycle methods to a class component\nThere are a few special methods you can define on your class.\nIf you define the componentDidMount\nmethod, React will call it when your component is added (mounted) to the screen. React will call componentDidUpdate\nafter your component re-renders due to changed props or state. React will call componentWillUnmount\nafter your component has been removed (unmounted) from the screen.\nIf you implement componentDidMount\n, you usually need to implement all three lifecycles to avoid bugs. For example, if componentDidMount\nreads some state or props, you also have to implement componentDidUpdate\nto handle their changes, and componentWillUnmount\nto clean up whatever componentDidMount\nwas doing.\nFor example, this ChatRoom\ncomponent keeps a chat connection synchronized with props and state:\nimport { Component } from 'react'; import { createConnection } from './chat.js'; export default class ChatRoom extends Component { state = { serverUrl: 'https://localhost:1234' }; componentDidMount() { this.setupConnection(); } componentDidUpdate(prevProps, prevState) { if ( this.props.roomId !== prevProps.roomId || this.state.serverUrl !== prevState.serverUrl ) { this.destroyConnection(); this.setupConnection(); } } componentWillUnmount() { this.destroyConnection(); } setupConnection() { this.connection = createConnection( this.state.serverUrl, this.props.roomId ); this.connection.connect(); } destroyConnection() { this.connection.disconnect(); this.connection = null; } render() { return ( <> <label> Server URL:{' '} <input value={this.state.serverUrl} onChange={e => { this.setState({ serverUrl: e.target.value }); }} /> </label> <h1>Welcome to the {this.props.roomId} room!</h1> </> ); } }\nNote that in development when Strict Mode is on, React will call componentDidMount\n, immediately call componentWillUnmount\n, and then call componentDidMount\nagain. This helps you notice if you forgot to implement componentWillUnmount\nor if its logic doesn\u2019t fully \u201cmirror\u201d what componentDidMount\ndoes.\nCatching rendering errors with an error boundary\nBy default, if your application throws an error during rendering, React will remove its UI from the screen. To prevent this, you can wrap a part of your UI into an error boundary. An error boundary is a special component that lets you display some fallback UI instead of the part that crashed\u2014for example, an error message.\nTo implement an error boundary component, you need to provide static getDerivedStateFromError\nwhich lets you update state in response to an error and display an error message to the user. You can also optionally implement componentDidCatch\nto add some extra logic, for example, to log the error to an analytics service.\nclass ErrorBoundary extends React.Component {\nconstructor(props) {\nsuper(props);\nthis.state = { hasError: false };\n}\nstatic getDerivedStateFromError(error) {\n// Update state so the next render will show the fallback UI.\nreturn { hasError: true };\n}\ncomponentDidCatch(error, info) {\n// Example \"componentStack\":\n// in ComponentThatThrows (created by App)\n// in ErrorBoundary (created by App)\n// in div (created by App)\n// in App\nlogErrorToMyService(error, info.componentStack);\n}\nrender() {\nif (this.state.hasError) {\n// You can render any custom fallback UI\nreturn this.props.fallback;\n}\nreturn this.props.children;\n}\n}\nThen you can wrap a part of your component tree with it:\n<ErrorBoundary fallback={<p>Something went wrong</p>}>\n<Profile />\n</ErrorBoundary>\nIf Profile\nor its child component throws an error, ErrorBoundary\nwill \u201ccatch\u201d that error, display a fallback UI with the error message you\u2019ve provided, and send a production error report to your error reporting service.\nYou don\u2019t need to wrap every component into a separate error boundary. When you think about the granularity of error boundaries, consider where it makes sense to display an error message. For example, in a messaging app, it makes sense to place an error boundary around the list of conversations. It also makes sense to place one around every individual message. However, it wouldn\u2019t make sense to place a boundary around every avatar.\nAlternatives\nMigrating a simple component from a class to a function\nTypically, you will define components as functions instead.\nFor example, suppose you\u2019re converting this Greeting\nclass component to a function:\nimport { Component } from 'react'; class Greeting extends Component { render() { return <h1>Hello, {this.props.name}!</h1>; } } export default function App() { return ( <> <Greeting name=\"Sara\" /> <Greeting name=\"Cahal\" /> <Greeting name=\"Edite\" /> </> ); }\nDefine a function called Greeting\n. This is where you will move the body of your render\nfunction.\nfunction Greeting() {\n// ... move the code from the render method here ...\n}\nInstead of this.props.name\n, define the name\nprop using the destructuring syntax and read it directly:\nfunction Greeting({ name }) {\nreturn <h1>Hello, {name}!</h1>;\n}\nHere is a complete example:\nfunction Greeting({ name }) { return <h1>Hello, {name}!</h1>; } export default function App() { return ( <> <Greeting name=\"Sara\" /> <Greeting name=\"Cahal\" /> <Greeting name=\"Edite\" /> </> ); }\nMigrating a component with state from a class to a function\nSuppose you\u2019re converting this Counter\nclass component to a function:\nimport { Component } from 'react'; export default class Counter extends Component { state = { name: 'Taylor', age: 42, }; handleNameChange = (e) => { this.setState({ name: e.target.value }); } handleAgeChange = (e) => { this.setState({ age: this.state.age + 1 }); }; render() { return ( <> <input value={this.state.name} onChange={this.handleNameChange} /> <button onClick={this.handleAgeChange}> Increment age </button> <p>Hello, {this.state.name}. You are {this.state.age}.</p> </> ); } }\nStart by declaring a function with the necessary state variables:\nimport { useState } from 'react';\nfunction Counter() {\nconst [name, setName] = useState('Taylor');\nconst [age, setAge] = useState(42);\n// ...\nNext, convert the event handlers:\nfunction Counter() {\nconst [name, setName] = useState('Taylor');\nconst [age, setAge] = useState(42);\nfunction handleNameChange(e) {\nsetName(e.target.value);\n}\nfunction handleAgeChange() {\nsetAge(age + 1);\n}\n// ...\nFinally, replace all references starting with this\nwith the variables and functions you defined in your component. For example, replace this.state.age\nwith age\n, and replace this.handleNameChange\nwith handleNameChange\n.\nHere is a fully converted component:\nimport { useState } from 'react'; export default function Counter() { const [name, setName] = useState('Taylor'); const [age, setAge] = useState(42); function handleNameChange(e) { setName(e.target.value); } function handleAgeChange() { setAge(age + 1); } return ( <> <input value={name} onChange={handleNameChange} /> <button onClick={handleAgeChange}> Increment age </button> <p>Hello, {name}. You are {age}.</p> </> ) }\nMigrating a component with lifecycle methods from a class to a function\nSuppose you\u2019re converting this ChatRoom\nclass component with lifecycle methods to a function:\nimport { Component } from 'react'; import { createConnection } from './chat.js'; export default class ChatRoom extends Component { state = { serverUrl: 'https://localhost:1234' }; componentDidMount() { this.setupConnection(); } componentDidUpdate(prevProps, prevState) { if ( this.props.roomId !== prevProps.roomId || this.state.serverUrl !== prevState.serverUrl ) { this.destroyConnection(); this.setupConnection(); } } componentWillUnmount() { this.destroyConnection(); } setupConnection() { this.connection = createConnection( this.state.serverUrl, this.props.roomId ); this.connection.connect(); } destroyConnection() { this.connection.disconnect(); this.connection = null; } render() { return ( <> <label> Server URL:{' '} <input value={this.state.serverUrl} onChange={e => { this.setState({ serverUrl: e.target.value }); }} /> </label> <h1>Welcome to the {this.props.roomId} room!</h1> </> ); } }\nFirst, verify that your componentWillUnmount\ndoes the opposite of componentDidMount\n. In the above example, that\u2019s true: it disconnects the connection that componentDidMount\nsets up. If such logic is missing, add it first.\nNext, verify that your componentDidUpdate\nmethod handles changes to any props and state you\u2019re using in componentDidMount\n. In the above example, componentDidMount\ncalls setupConnection\nwhich reads this.state.serverUrl\nand this.props.roomId\n. This is why componentDidUpdate\nchecks whether this.state.serverUrl\nand this.props.roomId\nhave changed, and resets the connection if they did. If your componentDidUpdate\nlogic is missing or doesn\u2019t handle changes to all relevant props and state, fix that first.\nIn the above example, the logic inside the lifecycle methods connects the component to a system outside of React (a chat server). To connect a component to an external system, describe this logic as a single Effect:\nimport { useState, useEffect } from 'react';\nfunction ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\nuseEffect(() => {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () => {\nconnection.disconnect();\n};\n}, [serverUrl, roomId]);\n// ...\n}\nThis useEffect\ncall is equivalent to the logic in the lifecycle methods above. If your lifecycle methods do multiple unrelated things, split them into multiple independent Effects. Here is a complete example you can play with:\nimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; export default function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => { connection.disconnect(); }; }, [roomId, serverUrl]); return ( <> <label> Server URL:{' '} <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} /> </label> <h1>Welcome to the {roomId} room!</h1> </> ); }\nMigrating a component with context from a class to a function\nIn this example, the Panel\nand Button\nclass components read context from this.context\n:\nimport { createContext, Component } from 'react'; const ThemeContext = createContext(null); class Panel extends Component { static contextType = ThemeContext; render() { const theme = this.context; const className = 'panel-' + theme; return ( <section className={className}> <h1>{this.props.title}</h1> {this.props.children} </section> ); } } class Button extends Component { static contextType = ThemeContext; render() { const theme = this.context; const className = 'button-' + theme; return ( <button className={className}> {this.props.children} </button> ); } } function Form() { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> </Panel> ); } export default function MyApp() { return ( <ThemeContext.Provider value=\"dark\"> <Form /> </ThemeContext.Provider> ) }\nWhen you convert them to function components, replace this.context\nwith useContext\ncalls:\nimport { createContext, useContext } from 'react'; const ThemeContext = createContext(null); function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> <h1>{title}</h1> {children} </section> ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className}> {children} </button> ); } function Form() { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> </Panel> ); } export default function MyApp() { return ( <ThemeContext.Provider value=\"dark\"> <Form /> </ThemeContext.Provider> ) }"
  },
  {
    "source": "https://react.dev/reference/react/Fragment",
    "title": "<Fragment> (<>...</>) \u2013 React",
    "text": "<Fragment> (<>...</>)\n<Fragment>\n, often used via <>...</>\nsyntax, lets you group elements without a wrapper node.\n<>\n<OneChild />\n<AnotherChild />\n</>\nReference\n<Fragment>\nWrap elements in <Fragment>\nto group them together in situations where you need a single element. Grouping elements in Fragment\nhas no effect on the resulting DOM; it is the same as if the elements were not grouped. The empty JSX tag <></>\nis shorthand for <Fragment></Fragment>\nin most cases.\nProps\n- optional\nkey\n: Fragments declared with the explicit<Fragment>\nsyntax may have keys.\nCaveats\n-\nIf you want to pass\nkey\nto a Fragment, you can\u2019t use the<>...</>\nsyntax. You have to explicitly importFragment\nfrom'react'\nand render<Fragment key={yourKey}>...</Fragment>\n. -\nReact does not reset state when you go from rendering\n<><Child /></>\nto[<Child />]\nor back, or when you go from rendering<><Child /></>\nto<Child />\nand back. This only works a single level deep: for example, going from<><><Child /></></>\nto<Child />\nresets the state. See the precise semantics here.\nUsage\nReturning multiple elements\nUse Fragment\n, or the equivalent <>...</>\nsyntax, to group multiple elements together. You can use it to put multiple elements in any place where a single element can go. For example, a component can only return one element, but by using a Fragment you can group multiple elements together and then return them as a group:\nfunction Post() {\nreturn (\n<>\n<PostTitle />\n<PostBody />\n</>\n);\n}\nFragments are useful because grouping elements with a Fragment has no effect on layout or styles, unlike if you wrapped the elements in another container like a DOM element. If you inspect this example with the browser tools, you\u2019ll see that all <h1>\nand <article>\nDOM nodes appear as siblings without wrappers around them:\nexport default function Blog() { return ( <> <Post title=\"An update\" body=\"It's been a while since I posted...\" /> <Post title=\"My new blog\" body=\"I am starting a new blog!\" /> </> ) } function Post({ title, body }) { return ( <> <PostTitle title={title} /> <PostBody body={body} /> </> ); } function PostTitle({ title }) { return <h1>{title}</h1> } function PostBody({ body }) { return ( <article> <p>{body}</p> </article> ); }\nDeep Dive\nThe example above is equivalent to importing Fragment\nfrom React:\nimport { Fragment } from 'react';\nfunction Post() {\nreturn (\n<Fragment>\n<PostTitle />\n<PostBody />\n</Fragment>\n);\n}\nUsually you won\u2019t need this unless you need to pass a key\nto your Fragment\n.\nAssigning multiple elements to a variable\nLike any other element, you can assign Fragment elements to variables, pass them as props, and so on:\nfunction CloseDialog() {\nconst buttons = (\n<>\n<OKButton />\n<CancelButton />\n</>\n);\nreturn (\n<AlertDialog buttons={buttons}>\nAre you sure you want to leave this page?\n</AlertDialog>\n);\n}\nGrouping elements with text\nYou can use Fragment\nto group text together with components:\nfunction DateRangePicker({ start, end }) {\nreturn (\n<>\nFrom\n<DatePicker date={start} />\nto\n<DatePicker date={end} />\n</>\n);\n}\nRendering a list of Fragments\nHere\u2019s a situation where you need to write Fragment\nexplicitly instead of using the <></>\nsyntax. When you render multiple elements in a loop, you need to assign a key\nto each element. If the elements within the loop are Fragments, you need to use the normal JSX element syntax in order to provide the key\nattribute:\nfunction Blog() {\nreturn posts.map(post =>\n<Fragment key={post.id}>\n<PostTitle title={post.title} />\n<PostBody body={post.body} />\n</Fragment>\n);\n}\nYou can inspect the DOM to verify that there are no wrapper elements around the Fragment children:\nimport { Fragment } from 'react'; const posts = [ { id: 1, title: 'An update', body: \"It's been a while since I posted...\" }, { id: 2, title: 'My new blog', body: 'I am starting a new blog!' } ]; export default function Blog() { return posts.map(post => <Fragment key={post.id}> <PostTitle title={post.title} /> <PostBody body={post.body} /> </Fragment> ); } function PostTitle({ title }) { return <h1>{title}</h1> } function PostBody({ body }) { return ( <article> <p>{body}</p> </article> ); }"
  },
  {
    "source": "https://react.dev/reference/react/Profiler",
    "title": "<Profiler> \u2013 React",
    "text": "<Profiler>\n<Profiler>\nlets you measure rendering performance of a React tree programmatically.\n<Profiler id=\"App\" onRender={onRender}>\n<App />\n</Profiler>\nReference\n<Profiler>\nWrap a component tree in a <Profiler>\nto measure its rendering performance.\n<Profiler id=\"App\" onRender={onRender}>\n<App />\n</Profiler>\nProps\nid\n: A string identifying the part of the UI you are measuring.onRender\n: AnonRender\ncallback that React calls every time components within the profiled tree update. It receives information about what was rendered and how much time it took.\nCaveats\n- Profiling adds some additional overhead, so it is disabled in the production build by default. To opt into production profiling, you need to enable a special production build with profiling enabled.\nonRender\ncallback\nReact will call your onRender\ncallback with information about what was rendered.\nfunction onRender(id, phase, actualDuration, baseDuration, startTime, commitTime) {\n// Aggregate or log render timings...\n}\nParameters\nid\n: The stringid\nprop of the<Profiler>\ntree that has just committed. This lets you identify which part of the tree was committed if you are using multiple profilers.phase\n:\"mount\"\n,\"update\"\nor\"nested-update\"\n. This lets you know whether the tree has just been mounted for the first time or re-rendered due to a change in props, state, or Hooks.actualDuration\n: The number of milliseconds spent rendering the<Profiler>\nand its descendants for the current update. This indicates how well the subtree makes use of memoization (e.g.memo\nanduseMemo\n). Ideally this value should decrease significantly after the initial mount as many of the descendants will only need to re-render if their specific props change.baseDuration\n: The number of milliseconds estimating how much time it would take to re-render the entire<Profiler>\nsubtree without any optimizations. It is calculated by summing up the most recent render durations of each component in the tree. This value estimates a worst-case cost of rendering (e.g. the initial mount or a tree with no memoization). CompareactualDuration\nagainst it to see if memoization is working.startTime\n: A numeric timestamp for when React began rendering the current update.commitTime\n: A numeric timestamp for when React committed the current update. This value is shared between all profilers in a commit, enabling them to be grouped if desirable.\nUsage\nMeasuring rendering performance programmatically\nWrap the <Profiler>\ncomponent around a React tree to measure its rendering performance.\n<App>\n<Profiler id=\"Sidebar\" onRender={onRender}>\n<Sidebar />\n</Profiler>\n<PageContent />\n</App>\nIt requires two props: an id\n(string) and an onRender\ncallback (function) which React calls any time a component within the tree \u201ccommits\u201d an update.\nMeasuring different parts of the application\nYou can use multiple <Profiler>\ncomponents to measure different parts of your application:\n<App>\n<Profiler id=\"Sidebar\" onRender={onRender}>\n<Sidebar />\n</Profiler>\n<Profiler id=\"Content\" onRender={onRender}>\n<Content />\n</Profiler>\n</App>\nYou can also nest <Profiler>\ncomponents:\n<App>\n<Profiler id=\"Sidebar\" onRender={onRender}>\n<Sidebar />\n</Profiler>\n<Profiler id=\"Content\" onRender={onRender}>\n<Content>\n<Profiler id=\"Editor\" onRender={onRender}>\n<Editor />\n</Profiler>\n<Preview />\n</Content>\n</Profiler>\n</App>\nAlthough <Profiler>\nis a lightweight component, it should be used only when necessary. Each use adds some CPU and memory overhead to an application."
  },
  {
    "source": "https://react.dev/reference/react/PureComponent",
    "title": "PureComponent \u2013 React",
    "text": "PureComponent\nPureComponent\nis similar to Component\nbut it skips re-renders for same props and state. Class components are still supported by React, but we don\u2019t recommend using them in new code.\nclass Greeting extends PureComponent {\nrender() {\nreturn <h1>Hello, {this.props.name}!</h1>;\n}\n}\nReference\nPureComponent\nTo skip re-rendering a class component for same props and state, extend PureComponent\ninstead of Component\n:\nimport { PureComponent } from 'react';\nclass Greeting extends PureComponent {\nrender() {\nreturn <h1>Hello, {this.props.name}!</h1>;\n}\n}\nPureComponent\nis a subclass of Component\nand supports all the Component\nAPIs. Extending PureComponent\nis equivalent to defining a custom shouldComponentUpdate\nmethod that shallowly compares props and state.\nUsage\nSkipping unnecessary re-renders for class components\nReact normally re-renders a component whenever its parent re-renders. As an optimization, you can create a component that React will not re-render when its parent re-renders so long as its new props and state are the same as the old props and state. Class components can opt into this behavior by extending PureComponent\n:\nclass Greeting extends PureComponent {\nrender() {\nreturn <h1>Hello, {this.props.name}!</h1>;\n}\n}\nA React component should always have pure rendering logic. This means that it must return the same output if its props, state, and context haven\u2019t changed. By using PureComponent\n, you are telling React that your component complies with this requirement, so React doesn\u2019t need to re-render as long as its props and state haven\u2019t changed. However, your component will still re-render if a context that it\u2019s using changes.\nIn this example, notice that the Greeting\ncomponent re-renders whenever name\nis changed (because that\u2019s one of its props), but not when address\nis changed (because it\u2019s not passed to Greeting\nas a prop):\nimport { PureComponent, useState } from 'react'; class Greeting extends PureComponent { render() { console.log(\"Greeting was rendered at\", new Date().toLocaleTimeString()); return <h3>Hello{this.props.name && ', '}{this.props.name}!</h3>; } } export default function MyApp() { const [name, setName] = useState(''); const [address, setAddress] = useState(''); return ( <> <label> Name{': '} <input value={name} onChange={e => setName(e.target.value)} /> </label> <label> Address{': '} <input value={address} onChange={e => setAddress(e.target.value)} /> </label> <Greeting name={name} /> </> ); }\nAlternatives\nMigrating from a PureComponent\nclass component to a function\nWe recommend using function components instead of class components in new code. If you have some existing class components using PureComponent\n, here is how you can convert them. This is the original code:\nimport { PureComponent, useState } from 'react'; class Greeting extends PureComponent { render() { console.log(\"Greeting was rendered at\", new Date().toLocaleTimeString()); return <h3>Hello{this.props.name && ', '}{this.props.name}!</h3>; } } export default function MyApp() { const [name, setName] = useState(''); const [address, setAddress] = useState(''); return ( <> <label> Name{': '} <input value={name} onChange={e => setName(e.target.value)} /> </label> <label> Address{': '} <input value={address} onChange={e => setAddress(e.target.value)} /> </label> <Greeting name={name} /> </> ); }\nWhen you convert this component from a class to a function, wrap it in memo\n:\nimport { memo, useState } from 'react'; const Greeting = memo(function Greeting({ name }) { console.log(\"Greeting was rendered at\", new Date().toLocaleTimeString()); return <h3>Hello{name && ', '}{name}!</h3>; }); export default function MyApp() { const [name, setName] = useState(''); const [address, setAddress] = useState(''); return ( <> <label> Name{': '} <input value={name} onChange={e => setName(e.target.value)} /> </label> <label> Address{': '} <input value={address} onChange={e => setAddress(e.target.value)} /> </label> <Greeting name={name} /> </> ); }"
  },
  {
    "source": "https://react.dev/reference/react/StrictMode",
    "title": "<StrictMode> \u2013 React",
    "text": "<StrictMode>\n<StrictMode>\nlets you find common bugs in your components early during development.\n<StrictMode>\n<App />\n</StrictMode>\nReference\n<StrictMode>\nUse StrictMode\nto enable additional development behaviors and warnings for the component tree inside:\nimport { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\nconst root = createRoot(document.getElementById('root'));\nroot.render(\n<StrictMode>\n<App />\n</StrictMode>\n);\nStrict Mode enables the following development-only behaviors:\n- Your components will re-render an extra time to find bugs caused by impure rendering.\n- Your components will re-run Effects an extra time to find bugs caused by missing Effect cleanup.\n- Your components will re-run refs callbacks an extra time to find bugs caused by missing ref cleanup.\n- Your components will be checked for usage of deprecated APIs.\nProps\nStrictMode\naccepts no props.\nCaveats\n- There is no way to opt out of Strict Mode inside a tree wrapped in\n<StrictMode>\n. This gives you confidence that all components inside<StrictMode>\nare checked. If two teams working on a product disagree whether they find the checks valuable, they need to either reach consensus or move<StrictMode>\ndown in the tree.\nUsage\nEnabling Strict Mode for entire app\nStrict Mode enables extra development-only checks for the entire component tree inside the <StrictMode>\ncomponent. These checks help you find common bugs in your components early in the development process.\nTo enable Strict Mode for your entire app, wrap your root component with <StrictMode>\nwhen you render it:\nimport { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\nconst root = createRoot(document.getElementById('root'));\nroot.render(\n<StrictMode>\n<App />\n</StrictMode>\n);\nWe recommend wrapping your entire app in Strict Mode, especially for newly created apps. If you use a framework that calls createRoot\nfor you, check its documentation for how to enable Strict Mode.\nAlthough the Strict Mode checks only run in development, they help you find bugs that already exist in your code but can be tricky to reliably reproduce in production. Strict Mode lets you fix bugs before your users report them.\nEnabling Strict Mode for a part of the app\nYou can also enable Strict Mode for any part of your application:\nimport { StrictMode } from 'react';\nfunction App() {\nreturn (\n<>\n<Header />\n<StrictMode>\n<main>\n<Sidebar />\n<Content />\n</main>\n</StrictMode>\n<Footer />\n</>\n);\n}\nIn this example, Strict Mode checks will not run against the Header\nand Footer\ncomponents. However, they will run on Sidebar\nand Content\n, as well as all of the components inside them, no matter how deep.\nFixing bugs found by double rendering in development\nReact assumes that every component you write is a pure function. This means that React components you write must always return the same JSX given the same inputs (props, state, and context).\nComponents breaking this rule behave unpredictably and cause bugs. To help you find accidentally impure code, Strict Mode calls some of your functions (only the ones that should be pure) twice in development. This includes:\n- Your component function body (only top-level logic, so this doesn\u2019t include code inside event handlers)\n- Functions that you pass to\nuseState\n,set\nfunctions,useMemo\n, oruseReducer\n- Some class component methods like\nconstructor\n,render\n,shouldComponentUpdate\n(see the whole list)\nIf a function is pure, running it twice does not change its behavior because a pure function produces the same result every time. However, if a function is impure (for example, it mutates the data it receives), running it twice tends to be noticeable (that\u2019s what makes it impure!) This helps you spot and fix the bug early.\nHere is an example to illustrate how double rendering in Strict Mode helps you find bugs early.\nThis StoryTray\ncomponent takes an array of stories\nand adds one last \u201cCreate Story\u201d item at the end:\nexport default function StoryTray({ stories }) { const items = stories; items.push({ id: 'create', label: 'Create Story' }); return ( <ul> {items.map(story => ( <li key={story.id}> {story.label} </li> ))} </ul> ); }\nThere is a mistake in the code above. However, it is easy to miss because the initial output appears correct.\nThis mistake will become more noticeable if the StoryTray\ncomponent re-renders multiple times. For example, let\u2019s make the StoryTray\nre-render with a different background color whenever you hover over it:\nimport { useState } from 'react'; export default function StoryTray({ stories }) { const [isHover, setIsHover] = useState(false); const items = stories; items.push({ id: 'create', label: 'Create Story' }); return ( <ul onPointerEnter={() => setIsHover(true)} onPointerLeave={() => setIsHover(false)} style={{ backgroundColor: isHover ? '#ddd' : '#fff' }} > {items.map(story => ( <li key={story.id}> {story.label} </li> ))} </ul> ); }\nNotice how every time you hover over the StoryTray\ncomponent, \u201cCreate Story\u201d gets added to the list again. The intention of the code was to add it once at the end. But StoryTray\ndirectly modifies the stories\narray from the props. Every time StoryTray\nrenders, it adds \u201cCreate Story\u201d again at the end of the same array. In other words, StoryTray\nis not a pure function\u2014running it multiple times produces different results.\nTo fix this problem, you can make a copy of the array, and modify that copy instead of the original one:\nexport default function StoryTray({ stories }) {\nconst items = stories.slice(); // Clone the array\n// \u2705 Good: Pushing into a new array\nitems.push({ id: 'create', label: 'Create Story' });\nThis would make the StoryTray\nfunction pure. Each time it is called, it would only modify a new copy of the array, and would not affect any external objects or variables. This solves the bug, but you had to make the component re-render more often before it became obvious that something is wrong with its behavior.\nIn the original example, the bug wasn\u2019t obvious. Now let\u2019s wrap the original (buggy) code in <StrictMode>\n:\nexport default function StoryTray({ stories }) { const items = stories; items.push({ id: 'create', label: 'Create Story' }); return ( <ul> {items.map(story => ( <li key={story.id}> {story.label} </li> ))} </ul> ); }\nStrict Mode always calls your rendering function twice, so you can see the mistake right away (\u201cCreate Story\u201d appears twice). This lets you notice such mistakes early in the process. When you fix your component to render in Strict Mode, you also fix many possible future production bugs like the hover functionality from before:\nimport { useState } from 'react'; export default function StoryTray({ stories }) { const [isHover, setIsHover] = useState(false); const items = stories.slice(); // Clone the array items.push({ id: 'create', label: 'Create Story' }); return ( <ul onPointerEnter={() => setIsHover(true)} onPointerLeave={() => setIsHover(false)} style={{ backgroundColor: isHover ? '#ddd' : '#fff' }} > {items.map(story => ( <li key={story.id}> {story.label} </li> ))} </ul> ); }\nWithout Strict Mode, it was easy to miss the bug until you added more re-renders. Strict Mode made the same bug appear right away. Strict Mode helps you find bugs before you push them to your team and to your users.\nRead more about keeping components pure.\nFixing bugs found by re-running Effects in development\nStrict Mode can also help find bugs in Effects.\nEvery Effect has some setup code and may have some cleanup code. Normally, React calls setup when the component mounts (is added to the screen) and calls cleanup when the component unmounts (is removed from the screen). React then calls cleanup and setup again if its dependencies changed since the last render.\nWhen Strict Mode is on, React will also run one extra setup+cleanup cycle in development for every Effect. This may feel surprising, but it helps reveal subtle bugs that are hard to catch manually.\nHere is an example to illustrate how re-running Effects in Strict Mode helps you find bugs early.\nConsider this example that connects a component to a chat:\nimport { createRoot } from 'react-dom/client'; import './styles.css'; import App from './App'; const root = createRoot(document.getElementById(\"root\")); root.render(<App />);\nThere is an issue with this code, but it might not be immediately clear.\nTo make the issue more obvious, let\u2019s implement a feature. In the example below, roomId\nis not hardcoded. Instead, the user can select the roomId\nthat they want to connect to from a dropdown. Click \u201cOpen chat\u201d and then select different chat rooms one by one. Keep track of the number of active connections in the console:\nimport { createRoot } from 'react-dom/client'; import './styles.css'; import App from './App'; const root = createRoot(document.getElementById(\"root\")); root.render(<App />);\nYou\u2019ll notice that the number of open connections always keeps growing. In a real app, this would cause performance and network problems. The issue is that your Effect is missing a cleanup function:\nuseEffect(() => {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () => connection.disconnect();\n}, [roomId]);\nNow that your Effect \u201ccleans up\u201d after itself and destroys the outdated connections, the leak is solved. However, notice that the problem did not become visible until you\u2019ve added more features (the select box).\nIn the original example, the bug wasn\u2019t obvious. Now let\u2019s wrap the original (buggy) code in <StrictMode>\n:\nimport { StrictMode } from 'react'; import { createRoot } from 'react-dom/client'; import './styles.css'; import App from './App'; const root = createRoot(document.getElementById(\"root\")); root.render( <StrictMode> <App /> </StrictMode> );\nWith Strict Mode, you immediately see that there is a problem (the number of active connections jumps to 2). Strict Mode runs an extra setup+cleanup cycle for every Effect. This Effect has no cleanup logic, so it creates an extra connection but doesn\u2019t destroy it. This is a hint that you\u2019re missing a cleanup function.\nStrict Mode lets you notice such mistakes early in the process. When you fix your Effect by adding a cleanup function in Strict Mode, you also fix many possible future production bugs like the select box from before:\nimport { StrictMode } from 'react'; import { createRoot } from 'react-dom/client'; import './styles.css'; import App from './App'; const root = createRoot(document.getElementById(\"root\")); root.render( <StrictMode> <App /> </StrictMode> );\nNotice how the active connection count in the console doesn\u2019t keep growing anymore.\nWithout Strict Mode, it was easy to miss that your Effect needed cleanup. By running setup \u2192 cleanup \u2192 setup instead of setup for your Effect in development, Strict Mode made the missing cleanup logic more noticeable.\nRead more about implementing Effect cleanup.\nFixing bugs found by re-running ref callbacks in development\nStrict Mode can also help find bugs in callbacks refs.\nEvery callback ref\nhas some setup code and may have some cleanup code. Normally, React calls setup when the element is created (is added to the DOM) and calls cleanup when the element is removed (is removed from the DOM).\nWhen Strict Mode is on, React will also run one extra setup+cleanup cycle in development for every callback ref\n. This may feel surprising, but it helps reveal subtle bugs that are hard to catch manually.\nConsider this example, which allows you to select an animal and then scroll to one of them. Notice when you switch from \u201cCats\u201d to \u201cDogs\u201d, the console logs show that the number of animals in the list keeps growing, and the \u201cScroll to\u201d buttons stop working:\nimport { useRef, useState } from \"react\"; export default function AnimalFriends() { const itemsRef = useRef([]); const [animalList, setAnimalList] = useState(setupAnimalList); const [animal, setAnimal] = useState('cat'); function scrollToAnimal(index) { const list = itemsRef.current; const {node} = list[index]; node.scrollIntoView({ behavior: \"smooth\", block: \"nearest\", inline: \"center\", }); } const animals = animalList.filter(a => a.type === animal) return ( <> <nav> <button onClick={() => setAnimal('cat')}>Cats</button> <button onClick={() => setAnimal('dog')}>Dogs</button> </nav> <hr /> <nav> <span>Scroll to:</span>{animals.map((animal, index) => ( <button key={animal.src} onClick={() => scrollToAnimal(index)}> {index} </button> ))} </nav> <div> <ul> {animals.map((animal) => ( <li key={animal.src} ref={(node) => { const list = itemsRef.current; const item = {animal: animal, node}; list.push(item); console.log(`\u2705 Adding animal to the map. Total animals: ${list.length}`); if (list.length > 10) { console.log('\u274c Too many animals in the list!'); } return () => { // \ud83d\udea9 No cleanup, this is a bug! } }} > <img src={animal.src} /> </li> ))} </ul> </div> </> ); } function setupAnimalList() { const animalList = []; for (let i = 0; i < 10; i++) { animalList.push({type: 'cat', src: \"https://loremflickr.com/320/240/cat?lock=\" + i}); } for (let i = 0; i < 10; i++) { animalList.push({type: 'dog', src: \"https://loremflickr.com/320/240/dog?lock=\" + i}); } return animalList; }\nThis is a production bug! Since the ref callback doesn\u2019t remove animals from the list in the cleanup, the list of animals keeps growing. This is a memory leak that can cause performance problems in a real app, and breaks the behavior of the app.\nThe issue is the ref callback doesn\u2019t cleanup after itself:\n<li\nref={node => {\nconst list = itemsRef.current;\nconst item = {animal, node};\nlist.push(item);\nreturn () => {\n// \ud83d\udea9 No cleanup, this is a bug!\n}\n}}\n</li>\nNow let\u2019s wrap the original (buggy) code in <StrictMode>\n:\nimport { useRef, useState } from \"react\"; export default function AnimalFriends() { const itemsRef = useRef([]); const [animalList, setAnimalList] = useState(setupAnimalList); const [animal, setAnimal] = useState('cat'); function scrollToAnimal(index) { const list = itemsRef.current; const {node} = list[index]; node.scrollIntoView({ behavior: \"smooth\", block: \"nearest\", inline: \"center\", }); } const animals = animalList.filter(a => a.type === animal) return ( <> <nav> <button onClick={() => setAnimal('cat')}>Cats</button> <button onClick={() => setAnimal('dog')}>Dogs</button> </nav> <hr /> <nav> <span>Scroll to:</span>{animals.map((animal, index) => ( <button key={animal.src} onClick={() => scrollToAnimal(index)}> {index} </button> ))} </nav> <div> <ul> {animals.map((animal) => ( <li key={animal.src} ref={(node) => { const list = itemsRef.current; const item = {animal: animal, node} list.push(item); console.log(`\u2705 Adding animal to the map. Total animals: ${list.length}`); if (list.length > 10) { console.log('\u274c Too many animals in the list!'); } return () => { // \ud83d\udea9 No cleanup, this is a bug! } }} > <img src={animal.src} /> </li> ))} </ul> </div> </> ); } function setupAnimalList() { const animalList = []; for (let i = 0; i < 10; i++) { animalList.push({type: 'cat', src: \"https://loremflickr.com/320/240/cat?lock=\" + i}); } for (let i = 0; i < 10; i++) { animalList.push({type: 'dog', src: \"https://loremflickr.com/320/240/dog?lock=\" + i}); } return animalList; }\nWith Strict Mode, you immediately see that there is a problem. Strict Mode runs an extra setup+cleanup cycle for every callback ref. This callback ref has no cleanup logic, so it adds refs but doesn\u2019t remove them. This is a hint that you\u2019re missing a cleanup function.\nStrict Mode lets you eagerly find mistakes in callback refs. When you fix your callback by adding a cleanup function in Strict Mode, you also fix many possible future production bugs like the \u201cScroll to\u201d bug from before:\nimport { useRef, useState } from \"react\"; export default function AnimalFriends() { const itemsRef = useRef([]); const [animalList, setAnimalList] = useState(setupAnimalList); const [animal, setAnimal] = useState('cat'); function scrollToAnimal(index) { const list = itemsRef.current; const {node} = list[index]; node.scrollIntoView({ behavior: \"smooth\", block: \"nearest\", inline: \"center\", }); } const animals = animalList.filter(a => a.type === animal) return ( <> <nav> <button onClick={() => setAnimal('cat')}>Cats</button> <button onClick={() => setAnimal('dog')}>Dogs</button> </nav> <hr /> <nav> <span>Scroll to:</span>{animals.map((animal, index) => ( <button key={animal.src} onClick={() => scrollToAnimal(index)}> {index} </button> ))} </nav> <div> <ul> {animals.map((animal) => ( <li key={animal.src} ref={(node) => { const list = itemsRef.current; const item = {animal, node}; list.push({animal: animal, node}); console.log(`\u2705 Adding animal to the map. Total animals: ${list.length}`); if (list.length > 10) { console.log('\u274c Too many animals in the list!'); } return () => { list.splice(list.indexOf(item)); console.log(`\u274c Removing animal from the map. Total animals: ${itemsRef.current.length}`); } }} > <img src={animal.src} /> </li> ))} </ul> </div> </> ); } function setupAnimalList() { const animalList = []; for (let i = 0; i < 10; i++) { animalList.push({type: 'cat', src: \"https://loremflickr.com/320/240/cat?lock=\" + i}); } for (let i = 0; i < 10; i++) { animalList.push({type: 'dog', src: \"https://loremflickr.com/320/240/dog?lock=\" + i}); } return animalList; }\nNow on inital mount in StrictMode, the ref callbacks are all setup, cleaned up, and setup again:\n...\n\u2705 Adding animal to the map. Total animals: 10\n...\n\u274c Removing animal from the map. Total animals: 0\n...\n\u2705 Adding animal to the map. Total animals: 10\nThis is expected. Strict Mode confirms that the ref callbacks are cleaned up correctly, so the size never grows above the expected amount. After the fix, there are no memory leaks, and all the features work as expected.\nWithout Strict Mode, it was easy to miss the bug until you clicked around to app to notice broken features. Strict Mode made the bugs appear right away, before you push them to production.\nFixing deprecation warnings enabled by Strict Mode\nReact warns if some component anywhere inside a <StrictMode>\ntree uses one of these deprecated APIs:\nUNSAFE_\nclass lifecycle methods likeUNSAFE_componentWillMount\n. See alternatives.\nThese APIs are primarily used in older class components so they rarely appear in modern apps."
  },
  {
    "source": "https://react.dev/reference/react/Suspense",
    "title": "<Suspense> \u2013 React",
    "text": "<Suspense>\n<Suspense>\nlets you display a fallback until its children have finished loading.\n<Suspense fallback={<Loading />}>\n<SomeComponent />\n</Suspense>\n- Reference\n- Usage\n- Displaying a fallback while content is loading\n- Revealing content together at once\n- Revealing nested content as it loads\n- Showing stale content while fresh content is loading\n- Preventing already revealed content from hiding\n- Indicating that a Transition is happening\n- Resetting Suspense boundaries on navigation\n- Providing a fallback for server errors and client-only content\n- Troubleshooting\nReference\n<Suspense>\nProps\nchildren\n: The actual UI you intend to render. Ifchildren\nsuspends while rendering, the Suspense boundary will switch to renderingfallback\n.fallback\n: An alternate UI to render in place of the actual UI if it has not finished loading. Any valid React node is accepted, though in practice, a fallback is a lightweight placeholder view, such as a loading spinner or skeleton. Suspense will automatically switch tofallback\nwhenchildren\nsuspends, and back tochildren\nwhen the data is ready. Iffallback\nsuspends while rendering, it will activate the closest parent Suspense boundary.\nCaveats\n- React does not preserve any state for renders that got suspended before they were able to mount for the first time. When the component has loaded, React will retry rendering the suspended tree from scratch.\n- If Suspense was displaying content for the tree, but then it suspended again, the\nfallback\nwill be shown again unless the update causing it was caused bystartTransition\noruseDeferredValue\n. - If React needs to hide the already visible content because it suspended again, it will clean up layout Effects in the content tree. When the content is ready to be shown again, React will fire the layout Effects again. This ensures that Effects measuring the DOM layout don\u2019t try to do this while the content is hidden.\n- React includes under-the-hood optimizations like Streaming Server Rendering and Selective Hydration that are integrated with Suspense. Read an architectural overview and watch a technical talk to learn more.\nUsage\nDisplaying a fallback while content is loading\nYou can wrap any part of your application with a Suspense boundary:\n<Suspense fallback={<Loading />}>\n<Albums />\n</Suspense>\nReact will display your loading fallback until all the code and data needed by the children has been loaded.\nIn the example below, the Albums\ncomponent suspends while fetching the list of albums. Until it\u2019s ready to render, React switches the closest Suspense boundary above to show the fallback\u2014your Loading\ncomponent. Then, when the data loads, React hides the Loading\nfallback and renders the Albums\ncomponent with data.\nimport { Suspense } from 'react'; import Albums from './Albums.js'; export default function ArtistPage({ artist }) { return ( <> <h1>{artist.name}</h1> <Suspense fallback={<Loading />}> <Albums artistId={artist.id} /> </Suspense> </> ); } function Loading() { return <h2>\ud83c\udf00 Loading...</h2>; }\nRevealing content together at once\nBy default, the whole tree inside Suspense is treated as a single unit. For example, even if only one of these components suspends waiting for some data, all of them together will be replaced by the loading indicator:\n<Suspense fallback={<Loading />}>\n<Biography />\n<Panel>\n<Albums />\n</Panel>\n</Suspense>\nThen, after all of them are ready to be displayed, they will all appear together at once.\nIn the example below, both Biography\nand Albums\nfetch some data. However, because they are grouped under a single Suspense boundary, these components always \u201cpop in\u201d together at the same time.\nimport { Suspense } from 'react'; import Albums from './Albums.js'; import Biography from './Biography.js'; import Panel from './Panel.js'; export default function ArtistPage({ artist }) { return ( <> <h1>{artist.name}</h1> <Suspense fallback={<Loading />}> <Biography artistId={artist.id} /> <Panel> <Albums artistId={artist.id} /> </Panel> </Suspense> </> ); } function Loading() { return <h2>\ud83c\udf00 Loading...</h2>; }\nComponents that load data don\u2019t have to be direct children of the Suspense boundary. For example, you can move Biography\nand Albums\ninto a new Details\ncomponent. This doesn\u2019t change the behavior. Biography\nand Albums\nshare the same closest parent Suspense boundary, so their reveal is coordinated together.\n<Suspense fallback={<Loading />}>\n<Details artistId={artist.id} />\n</Suspense>\nfunction Details({ artistId }) {\nreturn (\n<>\n<Biography artistId={artistId} />\n<Panel>\n<Albums artistId={artistId} />\n</Panel>\n</>\n);\n}\nRevealing nested content as it loads\nWhen a component suspends, the closest parent Suspense component shows the fallback. This lets you nest multiple Suspense components to create a loading sequence. Each Suspense boundary\u2019s fallback will be filled in as the next level of content becomes available. For example, you can give the album list its own fallback:\n<Suspense fallback={<BigSpinner />}>\n<Biography />\n<Suspense fallback={<AlbumsGlimmer />}>\n<Panel>\n<Albums />\n</Panel>\n</Suspense>\n</Suspense>\nWith this change, displaying the Biography\ndoesn\u2019t need to \u201cwait\u201d for the Albums\nto load.\nThe sequence will be:\n- If\nBiography\nhasn\u2019t loaded yet,BigSpinner\nis shown in place of the entire content area. - Once\nBiography\nfinishes loading,BigSpinner\nis replaced by the content. - If\nAlbums\nhasn\u2019t loaded yet,AlbumsGlimmer\nis shown in place ofAlbums\nand its parentPanel\n. - Finally, once\nAlbums\nfinishes loading, it replacesAlbumsGlimmer\n.\nimport { Suspense } from 'react'; import Albums from './Albums.js'; import Biography from './Biography.js'; import Panel from './Panel.js'; export default function ArtistPage({ artist }) { return ( <> <h1>{artist.name}</h1> <Suspense fallback={<BigSpinner />}> <Biography artistId={artist.id} /> <Suspense fallback={<AlbumsGlimmer />}> <Panel> <Albums artistId={artist.id} /> </Panel> </Suspense> </Suspense> </> ); } function BigSpinner() { return <h2>\ud83c\udf00 Loading...</h2>; } function AlbumsGlimmer() { return ( <div className=\"glimmer-panel\"> <div className=\"glimmer-line\" /> <div className=\"glimmer-line\" /> <div className=\"glimmer-line\" /> </div> ); }\nSuspense boundaries let you coordinate which parts of your UI should always \u201cpop in\u201d together at the same time, and which parts should progressively reveal more content in a sequence of loading states. You can add, move, or delete Suspense boundaries in any place in the tree without affecting the rest of your app\u2019s behavior.\nDon\u2019t put a Suspense boundary around every component. Suspense boundaries should not be more granular than the loading sequence that you want the user to experience. If you work with a designer, ask them where the loading states should be placed\u2014it\u2019s likely that they\u2019ve already included them in their design wireframes.\nShowing stale content while fresh content is loading\nIn this example, the SearchResults\ncomponent suspends while fetching the search results. Type \"a\"\n, wait for the results, and then edit it to \"ab\"\n. The results for \"a\"\nwill get replaced by the loading fallback.\nimport { Suspense, useState } from 'react'; import SearchResults from './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); return ( <> <label> Search albums: <input value={query} onChange={e => setQuery(e.target.value)} /> </label> <Suspense fallback={<h2>Loading...</h2>}> <SearchResults query={query} /> </Suspense> </> ); }\nA common alternative UI pattern is to defer updating the list and to keep showing the previous results until the new results are ready. The useDeferredValue\nHook lets you pass a deferred version of the query down:\nexport default function App() {\nconst [query, setQuery] = useState('');\nconst deferredQuery = useDeferredValue(query);\nreturn (\n<>\n<label>\nSearch albums:\n<input value={query} onChange={e => setQuery(e.target.value)} />\n</label>\n<Suspense fallback={<h2>Loading...</h2>}>\n<SearchResults query={deferredQuery} />\n</Suspense>\n</>\n);\n}\nThe query\nwill update immediately, so the input will display the new value. However, the deferredQuery\nwill keep its previous value until the data has loaded, so SearchResults\nwill show the stale results for a bit.\nTo make it more obvious to the user, you can add a visual indication when the stale result list is displayed:\n<div style={{\nopacity: query !== deferredQuery ? 0.5 : 1\n}}>\n<SearchResults query={deferredQuery} />\n</div>\nEnter \"a\"\nin the example below, wait for the results to load, and then edit the input to \"ab\"\n. Notice how instead of the Suspense fallback, you now see the dimmed stale result list until the new results have loaded:\nimport { Suspense, useState, useDeferredValue } from 'react'; import SearchResults from './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); const isStale = query !== deferredQuery; return ( <> <label> Search albums: <input value={query} onChange={e => setQuery(e.target.value)} /> </label> <Suspense fallback={<h2>Loading...</h2>}> <div style={{ opacity: isStale ? 0.5 : 1 }}> <SearchResults query={deferredQuery} /> </div> </Suspense> </> ); }\nPreventing already revealed content from hiding\nWhen a component suspends, the closest parent Suspense boundary switches to showing the fallback. This can lead to a jarring user experience if it was already displaying some content. Try pressing this button:\nimport { Suspense, useState } from 'react'; import IndexPage from './IndexPage.js'; import ArtistPage from './ArtistPage.js'; import Layout from './Layout.js'; export default function App() { return ( <Suspense fallback={<BigSpinner />}> <Router /> </Suspense> ); } function Router() { const [page, setPage] = useState('/'); function navigate(url) { setPage(url); } let content; if (page === '/') { content = ( <IndexPage navigate={navigate} /> ); } else if (page === '/the-beatles') { content = ( <ArtistPage artist={{ id: 'the-beatles', name: 'The Beatles', }} /> ); } return ( <Layout> {content} </Layout> ); } function BigSpinner() { return <h2>\ud83c\udf00 Loading...</h2>; }\nWhen you pressed the button, the Router\ncomponent rendered ArtistPage\ninstead of IndexPage\n. A component inside ArtistPage\nsuspended, so the closest Suspense boundary started showing the fallback. The closest Suspense boundary was near the root, so the whole site layout got replaced by BigSpinner\n.\nTo prevent this, you can mark the navigation state update as a Transition with startTransition\n:\nfunction Router() {\nconst [page, setPage] = useState('/');\nfunction navigate(url) {\nstartTransition(() => {\nsetPage(url);\n});\n}\n// ...\nThis tells React that the state transition is not urgent, and it\u2019s better to keep showing the previous page instead of hiding any already revealed content. Now clicking the button \u201cwaits\u201d for the Biography\nto load:\nimport { Suspense, startTransition, useState } from 'react'; import IndexPage from './IndexPage.js'; import ArtistPage from './ArtistPage.js'; import Layout from './Layout.js'; export default function App() { return ( <Suspense fallback={<BigSpinner />}> <Router /> </Suspense> ); } function Router() { const [page, setPage] = useState('/'); function navigate(url) { startTransition(() => { setPage(url); }); } let content; if (page === '/') { content = ( <IndexPage navigate={navigate} /> ); } else if (page === '/the-beatles') { content = ( <ArtistPage artist={{ id: 'the-beatles', name: 'The Beatles', }} /> ); } return ( <Layout> {content} </Layout> ); } function BigSpinner() { return <h2>\ud83c\udf00 Loading...</h2>; }\nA Transition doesn\u2019t wait for all content to load. It only waits long enough to avoid hiding already revealed content. For example, the website Layout\nwas already revealed, so it would be bad to hide it behind a loading spinner. However, the nested Suspense\nboundary around Albums\nis new, so the Transition doesn\u2019t wait for it.\nIndicating that a Transition is happening\nIn the above example, once you click the button, there is no visual indication that a navigation is in progress. To add an indicator, you can replace startTransition\nwith useTransition\nwhich gives you a boolean isPending\nvalue. In the example below, it\u2019s used to change the website header styling while a Transition is happening:\nimport { Suspense, useState, useTransition } from 'react'; import IndexPage from './IndexPage.js'; import ArtistPage from './ArtistPage.js'; import Layout from './Layout.js'; export default function App() { return ( <Suspense fallback={<BigSpinner />}> <Router /> </Suspense> ); } function Router() { const [page, setPage] = useState('/'); const [isPending, startTransition] = useTransition(); function navigate(url) { startTransition(() => { setPage(url); }); } let content; if (page === '/') { content = ( <IndexPage navigate={navigate} /> ); } else if (page === '/the-beatles') { content = ( <ArtistPage artist={{ id: 'the-beatles', name: 'The Beatles', }} /> ); } return ( <Layout isPending={isPending}> {content} </Layout> ); } function BigSpinner() { return <h2>\ud83c\udf00 Loading...</h2>; }\nResetting Suspense boundaries on navigation\nDuring a Transition, React will avoid hiding already revealed content. However, if you navigate to a route with different parameters, you might want to tell React it is different content. You can express this with a key\n:\n<ProfilePage key={queryParams.id} />\nImagine you\u2019re navigating within a user\u2019s profile page, and something suspends. If that update is wrapped in a Transition, it will not trigger the fallback for already visible content. That\u2019s the expected behavior.\nHowever, now imagine you\u2019re navigating between two different user profiles. In that case, it makes sense to show the fallback. For example, one user\u2019s timeline is different content from another user\u2019s timeline. By specifying a key\n, you ensure that React treats different users\u2019 profiles as different components, and resets the Suspense boundaries during navigation. Suspense-integrated routers should do this automatically.\nProviding a fallback for server errors and client-only content\nIf you use one of the streaming server rendering APIs (or a framework that relies on them), React will also use your <Suspense>\nboundaries to handle errors on the server. If a component throws an error on the server, React will not abort the server render. Instead, it will find the closest <Suspense>\ncomponent above it and include its fallback (such as a spinner) into the generated server HTML. The user will see a spinner at first.\nOn the client, React will attempt to render the same component again. If it errors on the client too, React will throw the error and display the closest error boundary. However, if it does not error on the client, React will not display the error to the user since the content was eventually displayed successfully.\nYou can use this to opt out some components from rendering on the server. To do this, throw an error in the server environment and then wrap them in a <Suspense>\nboundary to replace their HTML with fallbacks:\n<Suspense fallback={<Loading />}>\n<Chat />\n</Suspense>\nfunction Chat() {\nif (typeof window === 'undefined') {\nthrow Error('Chat should only render on the client.');\n}\n// ...\n}\nThe server HTML will include the loading indicator. It will be replaced by the Chat\ncomponent on the client.\nTroubleshooting\nHow do I prevent the UI from being replaced by a fallback during an update?\nReplacing visible UI with a fallback creates a jarring user experience. This can happen when an update causes a component to suspend, and the nearest Suspense boundary is already showing content to the user.\nTo prevent this from happening, mark the update as non-urgent using startTransition\n. During a Transition, React will wait until enough data has loaded to prevent an unwanted fallback from appearing:\nfunction handleNextPageClick() {\n// If this update suspends, don't hide the already displayed content\nstartTransition(() => {\nsetCurrentPage(currentPage + 1);\n});\n}\nThis will avoid hiding existing content. However, any newly rendered Suspense\nboundaries will still immediately display fallbacks to avoid blocking the UI and let the user see the content as it becomes available.\nReact will only prevent unwanted fallbacks during non-urgent updates. It will not delay a render if it\u2019s the result of an urgent update. You must opt in with an API like startTransition\nor useDeferredValue\n.\nIf your router is integrated with Suspense, it should wrap its updates into startTransition\nautomatically."
  },
  {
    "source": "https://react.dev/reference/react/act",
    "title": "act \u2013 React",
    "text": "act\nis a test helper to apply pending React updates before making assertions.\nawait act(async actFn)\nTo prepare a component for assertions, wrap the code rendering it and performing updates inside an await act()\ncall. This makes your test run closer to how React works in the browser.\nReference\nawait act(async actFn)\nWhen writing UI tests, tasks like rendering, user events, or data fetching can be considered as \u201cunits\u201d of interaction with a user interface. React provides a helper called act()\nthat makes sure all updates related to these \u201cunits\u201d have been processed and applied to the DOM before you make any assertions.\nThe name act\ncomes from the Arrange-Act-Assert pattern.\nit ('renders with button disabled', async () => {\nawait act(async () => {\nroot.render(<TestComponent />)\n});\nexpect(container.querySelector('button')).toBeDisabled();\n});\nParameters\nasync actFn\n: An async function wrapping renders or interactions for components being tested. Any updates triggered within theactFn\n, are added to an internal act queue, which are then flushed together to process and apply any changes to the DOM. Since it is async, React will also run any code that crosses an async boundary, and flush any updates scheduled.\nReturns\nact\ndoes not return anything.\nUsage\nWhen testing a component, you can use act\nto make assertions about its output.\nFor example, let\u2019s say we have this Counter\ncomponent, the usage examples below show how to test it:\nfunction Counter() {\nconst [count, setCount] = useState(0);\nconst handleClick = () => {\nsetCount(prev => prev + 1);\n}\nuseEffect(() => {\ndocument.title = `You clicked ${count} times`;\n}, [count]);\nreturn (\n<div>\n<p>You clicked {count} times</p>\n<button onClick={handleClick}>\nClick me\n</button>\n</div>\n)\n}\nRendering components in tests\nTo test the render output of a component, wrap the render inside act()\n:\nimport {act} from 'react';\nimport ReactDOMClient from 'react-dom/client';\nimport Counter from './Counter';\nit('can render and update a counter', async () => {\ncontainer = document.createElement('div');\ndocument.body.appendChild(container);\n// \u2705 Render the component inside act().\nawait act(() => {\nReactDOMClient.createRoot(container).render(<Counter />);\n});\nconst button = container.querySelector('button');\nconst label = container.querySelector('p');\nexpect(label.textContent).toBe('You clicked 0 times');\nexpect(document.title).toBe('You clicked 0 times');\n});\nHere, we create a container, append it to the document, and render the Counter\ncomponent inside act()\n. This ensures that the component is rendered and its effects are applied before making assertions.\nUsing act\nensures that all updates have been applied before we make assertions.\nDispatching events in tests\nTo test events, wrap the event dispatch inside act()\n:\nimport {act} from 'react';\nimport ReactDOMClient from 'react-dom/client';\nimport Counter from './Counter';\nit.only('can render and update a counter', async () => {\nconst container = document.createElement('div');\ndocument.body.appendChild(container);\nawait act( async () => {\nReactDOMClient.createRoot(container).render(<Counter />);\n});\n// \u2705 Dispatch the event inside act().\nawait act(async () => {\nbutton.dispatchEvent(new MouseEvent('click', { bubbles: true }));\n});\nconst button = container.querySelector('button');\nconst label = container.querySelector('p');\nexpect(label.textContent).toBe('You clicked 1 times');\nexpect(document.title).toBe('You clicked 1 times');\n});\nHere, we render the component with act\n, and then dispatch the event inside another act()\n. This ensures that all updates from the event are applied before making assertions.\nTroubleshooting\nI\u2019m getting an error: \u201cThe current testing environment is not configured to support act\u201d(\u2026)\u201d\nUsing act\nrequires setting global.IS_REACT_ACT_ENVIRONMENT=true\nin your test environment. This is to ensure that act\nis only used in the correct environment.\nIf you don\u2019t set the global, you will see an error like this:\nTo fix, add this to your global setup file for React tests:\nglobal.IS_REACT_ACT_ENVIRONMENT=true"
  },
  {
    "source": "https://react.dev/reference/react/apis",
    "title": "Built-in React APIs \u2013 React",
    "text": "Built-in React APIs\nIn addition to Hooks and Components, the react\npackage exports a few other APIs that are useful for defining components. This page lists all the remaining modern React APIs.\ncreateContext\nlets you define and provide context to the child components. Used withuseContext\n.forwardRef\nlets your component expose a DOM node as a ref to the parent. Used withuseRef\n.lazy\nlets you defer loading a component\u2019s code until it\u2019s rendered for the first time.memo\nlets your component skip re-renders with same props. Used withuseMemo\nanduseCallback\n.startTransition\nlets you mark a state update as non-urgent. Similar touseTransition\n.act\nlets you wrap renders and interactions in tests to ensure updates have processed before making assertions.\nResource APIs\nResources can be accessed by a component without having them as part of their state. For example, a component can read a message from a Promise or read styling information from a context.\nTo read a value from a resource, use this API:\nfunction MessageComponent({ messagePromise }) {\nconst message = use(messagePromise);\nconst theme = use(ThemeContext);\n// ...\n}"
  },
  {
    "source": "https://react.dev/reference/react/cache",
    "title": "cache \u2013 React",
    "text": "cache\ncache\nlets you cache the result of a data fetch or computation.\nconst cachedFn = cache(fn);\nReference\ncache(fn)\nCall cache\noutside of any components to create a version of the function with caching.\nimport {cache} from 'react';\nimport calculateMetrics from 'lib/metrics';\nconst getMetrics = cache(calculateMetrics);\nfunction Chart({data}) {\nconst report = getMetrics(data);\n// ...\n}\nWhen getMetrics\nis first called with data\n, getMetrics\nwill call calculateMetrics(data)\nand store the result in cache. If getMetrics\nis called again with the same data\n, it will return the cached result instead of calling calculateMetrics(data)\nagain.\nParameters\nfn\n: The function you want to cache results for.fn\ncan take any arguments and return any value.\nReturns\ncache\nreturns a cached version of fn\nwith the same type signature. It does not call fn\nin the process.\nWhen calling cachedFn\nwith given arguments, it first checks if a cached result exists in the cache. If a cached result exists, it returns the result. If not, it calls fn\nwith the arguments, stores the result in the cache, and returns the result. The only time fn\nis called is when there is a cache miss.\nCaveats\n- React will invalidate the cache for all memoized functions for each server request.\n- Each call to\ncache\ncreates a new function. This means that callingcache\nwith the same function multiple times will return different memoized functions that do not share the same cache. cachedFn\nwill also cache errors. Iffn\nthrows an error for certain arguments, it will be cached, and the same error is re-thrown whencachedFn\nis called with those same arguments.cache\nis for use in Server Components only.\nUsage\nCache an expensive computation\nUse cache\nto skip duplicate work.\nimport {cache} from 'react';\nimport calculateUserMetrics from 'lib/user';\nconst getUserMetrics = cache(calculateUserMetrics);\nfunction Profile({user}) {\nconst metrics = getUserMetrics(user);\n// ...\n}\nfunction TeamReport({users}) {\nfor (let user in users) {\nconst metrics = getUserMetrics(user);\n// ...\n}\n// ...\n}\nIf the same user\nobject is rendered in both Profile\nand TeamReport\n, the two components can share work and only call calculateUserMetrics\nonce for that user\n.\nAssume Profile\nis rendered first. It will call getUserMetrics\n, and check if there is a cached result. Since it is the first time getUserMetrics\nis called with that user\n, there will be a cache miss. getUserMetrics\nwill then call calculateUserMetrics\nwith that user\nand write the result to cache.\nWhen TeamReport\nrenders its list of users\nand reaches the same user\nobject, it will call getUserMetrics\nand read the result from cache.\nShare a snapshot of data\nTo share a snapshot of data between components, call cache\nwith a data-fetching function like fetch\n. When multiple components make the same data fetch, only one request is made and the data returned is cached and shared across components. All components refer to the same snapshot of data across the server render.\nimport {cache} from 'react';\nimport {fetchTemperature} from './api.js';\nconst getTemperature = cache(async (city) => {\nreturn await fetchTemperature(city);\n});\nasync function AnimatedWeatherCard({city}) {\nconst temperature = await getTemperature(city);\n// ...\n}\nasync function MinimalWeatherCard({city}) {\nconst temperature = await getTemperature(city);\n// ...\n}\nIf AnimatedWeatherCard\nand MinimalWeatherCard\nboth render for the same city, they will receive the same snapshot of data from the memoized function.\nIf AnimatedWeatherCard\nand MinimalWeatherCard\nsupply different city arguments to getTemperature\n, then fetchTemperature\nwill be called twice and each call site will receive different data.\nThe city acts as a cache key.\nPreload data\nBy caching a long-running data fetch, you can kick off asynchronous work prior to rendering the component.\nconst getUser = cache(async (id) => {\nreturn await db.user.query(id);\n});\nasync function Profile({id}) {\nconst user = await getUser(id);\nreturn (\n<section>\n<img src={user.profilePic} />\n<h2>{user.name}</h2>\n</section>\n);\n}\nfunction Page({id}) {\n// \u2705 Good: start fetching the user data\ngetUser(id);\n// ... some computational work\nreturn (\n<>\n<Profile id={id} />\n</>\n);\n}\nWhen rendering Page\n, the component calls getUser\nbut note that it doesn\u2019t use the returned data. This early getUser\ncall kicks off the asynchronous database query that occurs while Page\nis doing other computational work and rendering children.\nWhen rendering Profile\n, we call getUser\nagain. If the initial getUser\ncall has already returned and cached the user data, when Profile\nasks and waits for this data, it can simply read from the cache without requiring another remote procedure call. If the initial data request hasn\u2019t been completed, preloading data in this pattern reduces delay in data-fetching.\nDeep Dive\nWhen evaluating an asynchronous function, you will receive a Promise for that work. The promise holds the state of that work (pending, fulfilled, failed) and its eventual settled result.\nIn this example, the asynchronous function fetchData\nreturns a promise that is awaiting the fetch\n.\nasync function fetchData() {\nreturn await fetch(`https://...`);\n}\nconst getData = cache(fetchData);\nasync function MyComponent() {\ngetData();\n// ... some computational work\nawait getData();\n// ...\n}\nIn calling getData\nthe first time, the promise returned from fetchData\nis cached. Subsequent look-ups will then return the same promise.\nNotice that the first getData\ncall does not await\nwhereas the second does. await\nis a JavaScript operator that will wait and return the settled result of the promise. The first getData\ncall simply initiates the fetch\nto cache the promise for the second getData\nto look-up.\nIf by the second call the promise is still pending, then await\nwill pause for the result. The optimization is that while we wait on the fetch\n, React can continue with computational work, thus reducing the wait time for the second call.\nIf the promise is already settled, either to an error or the fulfilled result, await\nwill return that value immediately. In both outcomes, there is a performance benefit.\nDeep Dive\nAll mentioned APIs offer memoization but the difference is what they\u2019re intended to memoize, who can access the cache, and when their cache is invalidated.\nuseMemo\nIn general, you should use useMemo\nfor caching a expensive computation in a Client Component across renders. As an example, to memoize a transformation of data within a component.\n'use client';\nfunction WeatherReport({record}) {\nconst avgTemp = useMemo(() => calculateAvg(record), record);\n// ...\n}\nfunction App() {\nconst record = getRecord();\nreturn (\n<>\n<WeatherReport record={record} />\n<WeatherReport record={record} />\n</>\n);\n}\nIn this example, App\nrenders two WeatherReport\ns with the same record. Even though both components do the same work, they cannot share work. useMemo\n\u2019s cache is only local to the component.\nHowever, useMemo\ndoes ensure that if App\nre-renders and the record\nobject doesn\u2019t change, each component instance would skip work and use the memoized value of avgTemp\n. useMemo\nwill only cache the last computation of avgTemp\nwith the given dependencies.\ncache\nIn general, you should use cache\nin Server Components to memoize work that can be shared across components.\nconst cachedFetchReport = cache(fetchReport);\nfunction WeatherReport({city}) {\nconst report = cachedFetchReport(city);\n// ...\n}\nfunction App() {\nconst city = \"Los Angeles\";\nreturn (\n<>\n<WeatherReport city={city} />\n<WeatherReport city={city} />\n</>\n);\n}\nRe-writing the previous example to use cache\n, in this case the second instance of WeatherReport\nwill be able to skip duplicate work and read from the same cache as the first WeatherReport\n. Another difference from the previous example is that cache\nis also recommended for memoizing data fetches, unlike useMemo\nwhich should only be used for computations.\nAt this time, cache\nshould only be used in Server Components and the cache will be invalidated across server requests.\nmemo\nYou should use memo\nto prevent a component re-rendering if its props are unchanged.\n'use client';\nfunction WeatherReport({record}) {\nconst avgTemp = calculateAvg(record);\n// ...\n}\nconst MemoWeatherReport = memo(WeatherReport);\nfunction App() {\nconst record = getRecord();\nreturn (\n<>\n<MemoWeatherReport record={record} />\n<MemoWeatherReport record={record} />\n</>\n);\n}\nIn this example, both MemoWeatherReport\ncomponents will call calculateAvg\nwhen first rendered. However, if App\nre-renders, with no changes to record\n, none of the props have changed and MemoWeatherReport\nwill not re-render.\nCompared to useMemo\n, memo\nmemoizes the component render based on props vs. specific computations. Similar to useMemo\n, the memoized component only caches the last render with the last prop values. Once the props change, the cache invalidates and the component re-renders.\nTroubleshooting\nMy memoized function still runs even though I\u2019ve called it with the same arguments\nSee prior mentioned pitfalls\n- Calling different memoized functions will read from different caches.\n- Calling a memoized function outside of a component will not use the cache.\nIf none of the above apply, it may be a problem with how React checks if something exists in cache.\nIf your arguments are not primitives (ex. objects, functions, arrays), ensure you\u2019re passing the same object reference.\nWhen calling a memoized function, React will look up the input arguments to see if a result is already cached. React will use shallow equality of the arguments to determine if there is a cache hit.\nimport {cache} from 'react';\nconst calculateNorm = cache((vector) => {\n// ...\n});\nfunction MapMarker(props) {\n// \ud83d\udea9 Wrong: props is an object that changes every render.\nconst length = calculateNorm(props);\n// ...\n}\nfunction App() {\nreturn (\n<>\n<MapMarker x={10} y={10} z={10} />\n<MapMarker x={10} y={10} z={10} />\n</>\n);\n}\nIn this case the two MapMarker\ns look like they\u2019re doing the same work and calling calculateNorm\nwith the same value of {x: 10, y: 10, z:10}\n. Even though the objects contain the same values, they are not the same object reference as each component creates its own props\nobject.\nReact will call Object.is\non the input to verify if there is a cache hit.\nimport {cache} from 'react';\nconst calculateNorm = cache((x, y, z) => {\n// ...\n});\nfunction MapMarker(props) {\n// \u2705 Good: Pass primitives to memoized function\nconst length = calculateNorm(props.x, props.y, props.z);\n// ...\n}\nfunction App() {\nreturn (\n<>\n<MapMarker x={10} y={10} z={10} />\n<MapMarker x={10} y={10} z={10} />\n</>\n);\n}\nOne way to address this could be to pass the vector dimensions to calculateNorm\n. This works because the dimensions themselves are primitives.\nAnother solution may be to pass the vector object itself as a prop to the component. We\u2019ll need to pass the same object to both component instances.\nimport {cache} from 'react';\nconst calculateNorm = cache((vector) => {\n// ...\n});\nfunction MapMarker(props) {\n// \u2705 Good: Pass the same `vector` object\nconst length = calculateNorm(props.vector);\n// ...\n}\nfunction App() {\nconst vector = [10, 10, 10];\nreturn (\n<>\n<MapMarker vector={vector} />\n<MapMarker vector={vector} />\n</>\n);\n}"
  },
  {
    "source": "https://react.dev/reference/react/cloneElement",
    "title": "cloneElement \u2013 React",
    "text": "cloneElement\ncloneElement\nlets you create a new React element using another element as a starting point.\nconst clonedElement = cloneElement(element, props, ...children)\nReference\ncloneElement(element, props, ...children)\nCall cloneElement\nto create a React element based on the element\n, but with different props\nand children\n:\nimport { cloneElement } from 'react';\n// ...\nconst clonedElement = cloneElement(\n<Row title=\"Cabbage\">\nHello\n</Row>,\n{ isHighlighted: true },\n'Goodbye'\n);\nconsole.log(clonedElement); // <Row title=\"Cabbage\" isHighlighted={true}>Goodbye</Row>\nParameters\n-\nelement\n: Theelement\nargument must be a valid React element. For example, it could be a JSX node like<Something />\n, the result of callingcreateElement\n, or the result of anothercloneElement\ncall. -\nprops\n: Theprops\nargument must either be an object ornull\n. If you passnull\n, the cloned element will retain all of the originalelement.props\n. Otherwise, for every prop in theprops\nobject, the returned element will \u201cprefer\u201d the value fromprops\nover the value fromelement.props\n. The rest of the props will be filled from the originalelement.props\n. If you passprops.key\norprops.ref\n, they will replace the original ones. -\noptional\n...children\n: Zero or more child nodes. They can be any React nodes, including React elements, strings, numbers, portals, empty nodes (null\n,undefined\n,true\n, andfalse\n), and arrays of React nodes. If you don\u2019t pass any...children\narguments, the originalelement.props.children\nwill be preserved.\nReturns\ncloneElement\nreturns a React element object with a few properties:\ntype\n: Same aselement.type\n.props\n: The result of shallowly mergingelement.props\nwith the overridingprops\nyou have passed.ref\n: The originalelement.ref\n, unless it was overridden byprops.ref\n.key\n: The originalelement.key\n, unless it was overridden byprops.key\n.\nUsually, you\u2019ll return the element from your component or make it a child of another element. Although you may read the element\u2019s properties, it\u2019s best to treat every element as opaque after it\u2019s created, and only render it.\nCaveats\n-\nCloning an element does not modify the original element.\n-\nYou should only pass children as multiple arguments to\ncloneElement\nif they are all statically known, likecloneElement(element, null, child1, child2, child3)\n. If your children are dynamic, pass the entire array as the third argument:cloneElement(element, null, listItems)\n. This ensures that React will warn you about missingkey\ns for any dynamic lists. For static lists this is not necessary because they never reorder. -\ncloneElement\nmakes it harder to trace the data flow, so try the alternatives instead.\nUsage\nOverriding props of an element\nTo override the props of some React element, pass it to cloneElement\nwith the props you want to override:\nimport { cloneElement } from 'react';\n// ...\nconst clonedElement = cloneElement(\n<Row title=\"Cabbage\" />,\n{ isHighlighted: true }\n);\nHere, the resulting cloned element will be <Row title=\"Cabbage\" isHighlighted={true} />\n.\nLet\u2019s walk through an example to see when it\u2019s useful.\nImagine a List\ncomponent that renders its children\nas a list of selectable rows with a \u201cNext\u201d button that changes which row is selected. The List\ncomponent needs to render the selected Row\ndifferently, so it clones every <Row>\nchild that it has received, and adds an extra isHighlighted: true\nor isHighlighted: false\nprop:\nexport default function List({ children }) {\nconst [selectedIndex, setSelectedIndex] = useState(0);\nreturn (\n<div className=\"List\">\n{Children.map(children, (child, index) =>\ncloneElement(child, {\nisHighlighted: index === selectedIndex\n})\n)}\nLet\u2019s say the original JSX received by List\nlooks like this:\n<List>\n<Row title=\"Cabbage\" />\n<Row title=\"Garlic\" />\n<Row title=\"Apple\" />\n</List>\nBy cloning its children, the List\ncan pass extra information to every Row\ninside. The result looks like this:\n<List>\n<Row\ntitle=\"Cabbage\"\nisHighlighted={true}\n/>\n<Row\ntitle=\"Garlic\"\nisHighlighted={false}\n/>\n<Row\ntitle=\"Apple\"\nisHighlighted={false}\n/>\n</List>\nNotice how pressing \u201cNext\u201d updates the state of the List\n, and highlights a different row:\nimport { Children, cloneElement, useState } from 'react'; export default function List({ children }) { const [selectedIndex, setSelectedIndex] = useState(0); return ( <div className=\"List\"> {Children.map(children, (child, index) => cloneElement(child, { isHighlighted: index === selectedIndex }) )} <hr /> <button onClick={() => { setSelectedIndex(i => (i + 1) % Children.count(children) ); }}> Next </button> </div> ); }\nTo summarize, the List\ncloned the <Row />\nelements it received and added an extra prop to them.\nAlternatives\nPassing data with a render prop\nInstead of using cloneElement\n, consider accepting a render prop like renderItem\n. Here, List\nreceives renderItem\nas a prop. List\ncalls renderItem\nfor every item and passes isHighlighted\nas an argument:\nexport default function List({ items, renderItem }) {\nconst [selectedIndex, setSelectedIndex] = useState(0);\nreturn (\n<div className=\"List\">\n{items.map((item, index) => {\nconst isHighlighted = index === selectedIndex;\nreturn renderItem(item, isHighlighted);\n})}\nThe renderItem\nprop is called a \u201crender prop\u201d because it\u2019s a prop that specifies how to render something. For example, you can pass a renderItem\nimplementation that renders a <Row>\nwith the given isHighlighted\nvalue:\n<List\nitems={products}\nrenderItem={(product, isHighlighted) =>\n<Row\nkey={product.id}\ntitle={product.title}\nisHighlighted={isHighlighted}\n/>\n}\n/>\nThe end result is the same as with cloneElement\n:\n<List>\n<Row\ntitle=\"Cabbage\"\nisHighlighted={true}\n/>\n<Row\ntitle=\"Garlic\"\nisHighlighted={false}\n/>\n<Row\ntitle=\"Apple\"\nisHighlighted={false}\n/>\n</List>\nHowever, you can clearly trace where the isHighlighted\nvalue is coming from.\nimport { useState } from 'react'; export default function List({ items, renderItem }) { const [selectedIndex, setSelectedIndex] = useState(0); return ( <div className=\"List\"> {items.map((item, index) => { const isHighlighted = index === selectedIndex; return renderItem(item, isHighlighted); })} <hr /> <button onClick={() => { setSelectedIndex(i => (i + 1) % items.length ); }}> Next </button> </div> ); }\nThis pattern is preferred to cloneElement\nbecause it is more explicit.\nPassing data through context\nAnother alternative to cloneElement\nis to pass data through context.\nFor example, you can call createContext\nto define a HighlightContext\n:\nexport const HighlightContext = createContext(false);\nYour List\ncomponent can wrap every item it renders into a HighlightContext\nprovider:\nexport default function List({ items, renderItem }) {\nconst [selectedIndex, setSelectedIndex] = useState(0);\nreturn (\n<div className=\"List\">\n{items.map((item, index) => {\nconst isHighlighted = index === selectedIndex;\nreturn (\n<HighlightContext.Provider key={item.id} value={isHighlighted}>\n{renderItem(item)}\n</HighlightContext.Provider>\n);\n})}\nWith this approach, Row\ndoes not need to receive an isHighlighted\nprop at all. Instead, it reads the context:\nexport default function Row({ title }) {\nconst isHighlighted = useContext(HighlightContext);\n// ...\nThis allows the calling component to not know or worry about passing isHighlighted\nto <Row>\n:\n<List\nitems={products}\nrenderItem={product =>\n<Row title={product.title} />\n}\n/>\nInstead, List\nand Row\ncoordinate the highlighting logic through context.\nimport { useState } from 'react'; import { HighlightContext } from './HighlightContext.js'; export default function List({ items, renderItem }) { const [selectedIndex, setSelectedIndex] = useState(0); return ( <div className=\"List\"> {items.map((item, index) => { const isHighlighted = index === selectedIndex; return ( <HighlightContext.Provider key={item.id} value={isHighlighted} > {renderItem(item)} </HighlightContext.Provider> ); })} <hr /> <button onClick={() => { setSelectedIndex(i => (i + 1) % items.length ); }}> Next </button> </div> ); }\nLearn more about passing data through context.\nExtracting logic into a custom Hook\nAnother approach you can try is to extract the \u201cnon-visual\u201d logic into your own Hook, and use the information returned by your Hook to decide what to render. For example, you could write a useList\ncustom Hook like this:\nimport { useState } from 'react';\nexport default function useList(items) {\nconst [selectedIndex, setSelectedIndex] = useState(0);\nfunction onNext() {\nsetSelectedIndex(i =>\n(i + 1) % items.length\n);\n}\nconst selected = items[selectedIndex];\nreturn [selected, onNext];\n}\nThen you could use it like this:\nexport default function App() {\nconst [selected, onNext] = useList(products);\nreturn (\n<div className=\"List\">\n{products.map(product =>\n<Row\nkey={product.id}\ntitle={product.title}\nisHighlighted={selected === product}\n/>\n)}\n<hr />\n<button onClick={onNext}>\nNext\n</button>\n</div>\n);\n}\nThe data flow is explicit, but the state is inside the useList\ncustom Hook that you can use from any component:\nimport Row from './Row.js'; import useList from './useList.js'; import { products } from './data.js'; export default function App() { const [selected, onNext] = useList(products); return ( <div className=\"List\"> {products.map(product => <Row key={product.id} title={product.title} isHighlighted={selected === product} /> )} <hr /> <button onClick={onNext}> Next </button> </div> ); }\nThis approach is particularly useful if you want to reuse this logic between different components."
  },
  {
    "source": "https://react.dev/reference/react/components",
    "title": "Built-in React Components \u2013 React",
    "text": "Built-in React Components\nReact exposes a few built-in components that you can use in your JSX.\nBuilt-in components\n<Fragment>\n, alternatively written as<>...</>\n, lets you group multiple JSX nodes together.<Profiler>\nlets you measure rendering performance of a React tree programmatically.<Suspense>\nlets you display a fallback while the child components are loading.<StrictMode>\nenables extra development-only checks that help you find bugs early.\nYour own components\nYou can also define your own components as JavaScript functions."
  },
  {
    "source": "https://react.dev/reference/react/createContext",
    "title": "createContext \u2013 React",
    "text": "createContext\ncreateContext\nlets you create a context that components can provide or read.\nconst SomeContext = createContext(defaultValue)\nReference\ncreateContext(defaultValue)\nCall createContext\noutside of any components to create a context.\nimport { createContext } from 'react';\nconst ThemeContext = createContext('light');\nParameters\ndefaultValue\n: The value that you want the context to have when there is no matching context provider in the tree above the component that reads context. If you don\u2019t have any meaningful default value, specifynull\n. The default value is meant as a \u201clast resort\u201d fallback. It is static and never changes over time.\nReturns\ncreateContext\nreturns a context object.\nThe context object itself does not hold any information. It represents which context other components read or provide. Typically, you will use SomeContext.Provider\nin components above to specify the context value, and call useContext(SomeContext)\nin components below to read it. The context object has a few properties:\nSomeContext.Provider\nlets you provide the context value to components.SomeContext.Consumer\nis an alternative and rarely used way to read the context value.\nSomeContext.Provider\nWrap your components into a context provider to specify the value of this context for all components inside:\nfunction App() {\nconst [theme, setTheme] = useState('light');\n// ...\nreturn (\n<ThemeContext.Provider value={theme}>\n<Page />\n</ThemeContext.Provider>\n);\n}\nProps\nvalue\n: The value that you want to pass to all the components reading this context inside this provider, no matter how deep. The context value can be of any type. A component callinguseContext(SomeContext)\ninside of the provider receives thevalue\nof the innermost corresponding context provider above it.\nSomeContext.Consumer\nBefore useContext\nexisted, there was an older way to read context:\nfunction Button() {\n// \ud83d\udfe1 Legacy way (not recommended)\nreturn (\n<ThemeContext.Consumer>\n{theme => (\n<button className={theme} />\n)}\n</ThemeContext.Consumer>\n);\n}\nAlthough this older way still works, newly written code should read context with useContext()\ninstead:\nfunction Button() {\n// \u2705 Recommended way\nconst theme = useContext(ThemeContext);\nreturn <button className={theme} />;\n}\nProps\nchildren\n: A function. React will call the function you pass with the current context value determined by the same algorithm asuseContext()\ndoes, and render the result you return from this function. React will also re-run this function and update the UI whenever the context from the parent components changes.\nUsage\nCreating context\nContext lets components pass information deep down without explicitly passing props.\nCall createContext\noutside any components to create one or more contexts.\nimport { createContext } from 'react';\nconst ThemeContext = createContext('light');\nconst AuthContext = createContext(null);\ncreateContext\nreturns a context object. Components can read context by passing it to useContext()\n:\nfunction Button() {\nconst theme = useContext(ThemeContext);\n// ...\n}\nfunction Profile() {\nconst currentUser = useContext(AuthContext);\n// ...\n}\nBy default, the values they receive will be the default values you have specified when creating the contexts. However, by itself this isn\u2019t useful because the default values never change.\nContext is useful because you can provide other, dynamic values from your components:\nfunction App() {\nconst [theme, setTheme] = useState('dark');\nconst [currentUser, setCurrentUser] = useState({ name: 'Taylor' });\n// ...\nreturn (\n<ThemeContext.Provider value={theme}>\n<AuthContext.Provider value={currentUser}>\n<Page />\n</AuthContext.Provider>\n</ThemeContext.Provider>\n);\n}\nNow the Page\ncomponent and any components inside it, no matter how deep, will \u201csee\u201d the passed context values. If the passed context values change, React will re-render the components reading the context as well.\nRead more about reading and providing context and see examples.\nImporting and exporting context from a file\nOften, components in different files will need access to the same context. This is why it\u2019s common to declare contexts in a separate file. Then you can use the export\nstatement to make context available for other files:\n// Contexts.js\nimport { createContext } from 'react';\nexport const ThemeContext = createContext('light');\nexport const AuthContext = createContext(null);\nComponents declared in other files can then use the import\nstatement to read or provide this context:\n// Button.js\nimport { ThemeContext } from './Contexts.js';\nfunction Button() {\nconst theme = useContext(ThemeContext);\n// ...\n}\n// App.js\nimport { ThemeContext, AuthContext } from './Contexts.js';\nfunction App() {\n// ...\nreturn (\n<ThemeContext.Provider value={theme}>\n<AuthContext.Provider value={currentUser}>\n<Page />\n</AuthContext.Provider>\n</ThemeContext.Provider>\n);\n}\nThis works similar to importing and exporting components.\nTroubleshooting\nI can\u2019t find a way to change the context value\nCode like this specifies the default context value:\nconst ThemeContext = createContext('light');\nThis value never changes. React only uses this value as a fallback if it can\u2019t find a matching provider above.\nTo make context change over time, add state and wrap components in a context provider."
  },
  {
    "source": "https://react.dev/reference/react/createElement",
    "title": "createElement \u2013 React",
    "text": "createElement\ncreateElement\nlets you create a React element. It serves as an alternative to writing JSX.\nconst element = createElement(type, props, ...children)\nReference\ncreateElement(type, props, ...children)\nCall createElement\nto create a React element with the given type\n, props\n, and children\n.\nimport { createElement } from 'react';\nfunction Greeting({ name }) {\nreturn createElement(\n'h1',\n{ className: 'greeting' },\n'Hello'\n);\n}\nParameters\n-\ntype\n: Thetype\nargument must be a valid React component type. For example, it could be a tag name string (such as'div'\nor'span'\n), or a React component (a function, a class, or a special component likeFragment\n). -\nprops\n: Theprops\nargument must either be an object ornull\n. If you passnull\n, it will be treated the same as an empty object. React will create an element with props matching theprops\nyou have passed. Note thatref\nandkey\nfrom yourprops\nobject are special and will not be available aselement.props.ref\nandelement.props.key\non the returnedelement\n. They will be available aselement.ref\nandelement.key\n. -\noptional\n...children\n: Zero or more child nodes. They can be any React nodes, including React elements, strings, numbers, portals, empty nodes (null\n,undefined\n,true\n, andfalse\n), and arrays of React nodes.\nReturns\ncreateElement\nreturns a React element object with a few properties:\ntype\n: Thetype\nyou have passed.props\n: Theprops\nyou have passed except forref\nandkey\n.ref\n: Theref\nyou have passed. If missing,null\n.key\n: Thekey\nyou have passed, coerced to a string. If missing,null\n.\nUsually, you\u2019ll return the element from your component or make it a child of another element. Although you may read the element\u2019s properties, it\u2019s best to treat every element as opaque after it\u2019s created, and only render it.\nCaveats\n-\nYou must treat React elements and their props as immutable and never change their contents after creation. In development, React will freeze the returned element and its\nprops\nproperty shallowly to enforce this. -\nWhen you use JSX, you must start a tag with a capital letter to render your own custom component. In other words,\n<Something />\nis equivalent tocreateElement(Something)\n, but<something />\n(lowercase) is equivalent tocreateElement('something')\n(note it\u2019s a string, so it will be treated as a built-in HTML tag). -\nYou should only pass children as multiple arguments to\ncreateElement\nif they are all statically known, likecreateElement('h1', {}, child1, child2, child3)\n. If your children are dynamic, pass the entire array as the third argument:createElement('ul', {}, listItems)\n. This ensures that React will warn you about missingkey\ns for any dynamic lists. For static lists this is not necessary because they never reorder.\nUsage\nCreating an element without JSX\nIf you don\u2019t like JSX or can\u2019t use it in your project, you can use createElement\nas an alternative.\nTo create an element without JSX, call createElement\nwith some type, props, and children:\nimport { createElement } from 'react';\nfunction Greeting({ name }) {\nreturn createElement(\n'h1',\n{ className: 'greeting' },\n'Hello ',\ncreateElement('i', null, name),\n'. Welcome!'\n);\n}\nThe children are optional, and you can pass as many as you need (the example above has three children). This code will display a <h1>\nheader with a greeting. For comparison, here is the same example rewritten with JSX:\nfunction Greeting({ name }) {\nreturn (\n<h1 className=\"greeting\">\nHello <i>{name}</i>. Welcome!\n</h1>\n);\n}\nTo render your own React component, pass a function like Greeting\nas the type instead of a string like 'h1'\n:\nexport default function App() {\nreturn createElement(Greeting, { name: 'Taylor' });\n}\nWith JSX, it would look like this:\nexport default function App() {\nreturn <Greeting name=\"Taylor\" />;\n}\nHere is a complete example written with createElement\n:\nimport { createElement } from 'react'; function Greeting({ name }) { return createElement( 'h1', { className: 'greeting' }, 'Hello ', createElement('i', null, name), '. Welcome!' ); } export default function App() { return createElement( Greeting, { name: 'Taylor' } ); }\nAnd here is the same example written using JSX:\nfunction Greeting({ name }) { return ( <h1 className=\"greeting\"> Hello <i>{name}</i>. Welcome! </h1> ); } export default function App() { return <Greeting name=\"Taylor\" />; }\nBoth coding styles are fine, so you can use whichever one you prefer for your project. The main benefit of using JSX compared to createElement\nis that it\u2019s easy to see which closing tag corresponds to which opening tag.\nDeep Dive\nAn element is a lightweight description of a piece of the user interface. For example, both <Greeting name=\"Taylor\" />\nand createElement(Greeting, { name: 'Taylor' })\nproduce an object like this:\n// Slightly simplified\n{\ntype: Greeting,\nprops: {\nname: 'Taylor'\n},\nkey: null,\nref: null,\n}\nNote that creating this object does not render the Greeting\ncomponent or create any DOM elements.\nA React element is more like a description\u2014an instruction for React to later render the Greeting\ncomponent. By returning this object from your App\ncomponent, you tell React what to do next.\nCreating elements is extremely cheap so you don\u2019t need to try to optimize or avoid it."
  },
  {
    "source": "https://react.dev/reference/react/createFactory",
    "title": "createFactory \u2013 React",
    "text": "createFactory\ncreateFactory\nlets you create a function that produces React elements of a given type.\nconst factory = createFactory(type)\nReference\ncreateFactory(type)\nCall createFactory(type)\nto create a factory function which produces React elements of a given type\n.\nimport { createFactory } from 'react';\nconst button = createFactory('button');\nThen you can use it to create React elements without JSX:\nexport default function App() {\nreturn button({\nonClick: () => {\nalert('Clicked!')\n}\n}, 'Click me');\n}\nParameters\ntype\n: Thetype\nargument must be a valid React component type. For example, it could be a tag name string (such as'div'\nor'span'\n), or a React component (a function, a class, or a special component likeFragment\n).\nReturns\nReturns a factory function. That factory function receives a props\nobject as the first argument, followed by a list of ...children\narguments, and returns a React element with the given type\n, props\nand children\n.\nUsage\nCreating React elements with a factory\nAlthough most React projects use JSX to describe the user interface, JSX is not required. In the past, createFactory\nused to be one of the ways you could describe the user interface without JSX.\nCall createFactory\nto create a factory function for a specific element type like 'button'\n:\nimport { createFactory } from 'react';\nconst button = createFactory('button');\nCalling that factory function will produce React elements with the props and children you have provided:\nimport { createFactory } from 'react'; const button = createFactory('button'); export default function App() { return button({ onClick: () => { alert('Clicked!') } }, 'Click me'); }\nThis is how createFactory\nwas used as an alternative to JSX. However, createFactory\nis deprecated, and you should not call createFactory\nin any new code. See how to migrate away from createFactory\nbelow.\nAlternatives\nCopying createFactory\ninto your project\nIf your project has many createFactory\ncalls, copy this createFactory.js\nimplementation into your project:\nimport { createFactory } from './createFactory.js'; const button = createFactory('button'); export default function App() { return button({ onClick: () => { alert('Clicked!') } }, 'Click me'); }\nThis lets you keep all of your code unchanged except the imports.\nReplacing createFactory\nwith createElement\nIf you have a few createFactory\ncalls that you don\u2019t mind porting manually, and you don\u2019t want to use JSX, you can replace every call a factory function with a createElement\ncall. For example, you can replace this code:\nimport { createFactory } from 'react';\nconst button = createFactory('button');\nexport default function App() {\nreturn button({\nonClick: () => {\nalert('Clicked!')\n}\n}, 'Click me');\n}\nwith this code:\nimport { createElement } from 'react';\nexport default function App() {\nreturn createElement('button', {\nonClick: () => {\nalert('Clicked!')\n}\n}, 'Click me');\n}\nHere is a complete example of using React without JSX:\nimport { createElement } from 'react'; export default function App() { return createElement('button', { onClick: () => { alert('Clicked!') } }, 'Click me'); }\nReplacing createFactory\nwith JSX\nFinally, you can use JSX instead of createFactory\n. This is the most common way to use React:\nexport default function App() { return ( <button onClick={() => { alert('Clicked!'); }}> Click me </button> ); };"
  },
  {
    "source": "https://react.dev/reference/react/createRef",
    "title": "createRef \u2013 React",
    "text": "createRef\ncreateRef\ncreates a ref object which can contain arbitrary value.\nclass MyInput extends Component {\ninputRef = createRef();\n// ...\n}\nReference\ncreateRef()\nCall createRef\nto declare a ref inside a class component.\nimport { createRef, Component } from 'react';\nclass MyComponent extends Component {\nintervalRef = createRef();\ninputRef = createRef();\n// ...\nParameters\ncreateRef\ntakes no parameters.\nReturns\ncreateRef\nreturns an object with a single property:\ncurrent\n: Initially, it\u2019s set to thenull\n. You can later set it to something else. If you pass the ref object to React as aref\nattribute to a JSX node, React will set itscurrent\nproperty.\nCaveats\ncreateRef\nalways returns a different object. It\u2019s equivalent to writing{ current: null }\nyourself.- In a function component, you probably want\nuseRef\ninstead which always returns the same object. const ref = useRef()\nis equivalent toconst [ref, _] = useState(() => createRef(null))\n.\nUsage\nDeclaring a ref in a class component\nTo declare a ref inside a class component, call createRef\nand assign its result to a class field:\nimport { Component, createRef } from 'react';\nclass Form extends Component {\ninputRef = createRef();\n// ...\n}\nIf you now pass ref={this.inputRef}\nto an <input>\nin your JSX, React will populate this.inputRef.current\nwith the input DOM node. For example, here is how you make a button that focuses the input:\nimport { Component, createRef } from 'react'; export default class Form extends Component { inputRef = createRef(); handleClick = () => { this.inputRef.current.focus(); } render() { return ( <> <input ref={this.inputRef} /> <button onClick={this.handleClick}> Focus the input </button> </> ); } }\nAlternatives\nMigrating from a class with createRef\nto a function with useRef\nWe recommend using function components instead of class components in new code. If you have some existing class components using createRef\n, here is how you can convert them. This is the original code:\nimport { Component, createRef } from 'react'; export default class Form extends Component { inputRef = createRef(); handleClick = () => { this.inputRef.current.focus(); } render() { return ( <> <input ref={this.inputRef} /> <button onClick={this.handleClick}> Focus the input </button> </> ); } }\nWhen you convert this component from a class to a function, replace calls to createRef\nwith calls to useRef\n:\nimport { useRef } from 'react'; export default function Form() { const inputRef = useRef(null); function handleClick() { inputRef.current.focus(); } return ( <> <input ref={inputRef} /> <button onClick={handleClick}> Focus the input </button> </> ); }"
  },
  {
    "source": "https://react.dev/reference/react/experimental_taintObjectReference",
    "title": "experimental_taintObjectReference \u2013 React",
    "text": "experimental_taintObjectReference\ntaintObjectReference\nlets you prevent a specific object instance from being passed to a Client Component like a user\nobject.\nexperimental_taintObjectReference(message, object);\nTo prevent passing a key, hash or token, see taintUniqueValue\n.\nReference\ntaintObjectReference(message, object)\nCall taintObjectReference\nwith an object to register it with React as something that should not be allowed to be passed to the Client as is:\nimport {experimental_taintObjectReference} from 'react';\nexperimental_taintObjectReference(\n'Do not pass ALL environment variables to the client.',\nprocess.env\n);\nParameters\n-\nmessage\n: The message you want to display if the object gets passed to a Client Component. This message will be displayed as a part of the Error that will be thrown if the object gets passed to a Client Component. -\nobject\n: The object to be tainted. Functions and class instances can be passed totaintObjectReference\nasobject\n. Functions and classes are already blocked from being passed to Client Components but the React\u2019s default error message will be replaced by what you defined inmessage\n. When a specific instance of a Typed Array is passed totaintObjectReference\nasobject\n, any other copies of the Typed Array will not be tainted.\nReturns\nexperimental_taintObjectReference\nreturns undefined\n.\nCaveats\n- Recreating or cloning a tainted object creates a new untainted object which may contain sensitive data. For example, if you have a tainted\nuser\nobject,const userInfo = {name: user.name, ssn: user.ssn}\nor{...user}\nwill create new objects which are not tainted.taintObjectReference\nonly protects against simple mistakes when the object is passed through to a Client Component unchanged.\nUsage\nPrevent user data from unintentionally reaching the client\nA Client Component should never accept objects that carry sensitive data. Ideally, the data fetching functions should not expose data that the current user should not have access to. Sometimes mistakes happen during refactoring. To protect against these mistakes happening down the line we can \u201ctaint\u201d the user object in our data API.\nimport {experimental_taintObjectReference} from 'react';\nexport async function getUser(id) {\nconst user = await db`SELECT * FROM users WHERE id = ${id}`;\nexperimental_taintObjectReference(\n'Do not pass the entire user object to the client. ' +\n'Instead, pick off the specific properties you need for this use case.',\nuser,\n);\nreturn user;\n}\nNow whenever anyone tries to pass this object to a Client Component, an error will be thrown with the passed in error message instead.\nDeep Dive\nIf you\u2019re running a Server Components environment that has access to sensitive data, you have to be careful not to pass objects straight through:\n// api.js\nexport async function getUser(id) {\nconst user = await db`SELECT * FROM users WHERE id = ${id}`;\nreturn user;\n}\nimport { getUser } from 'api.js';\nimport { InfoCard } from 'components.js';\nexport async function Profile(props) {\nconst user = await getUser(props.userId);\n// DO NOT DO THIS\nreturn <InfoCard user={user} />;\n}\n// components.js\n\"use client\";\nexport async function InfoCard({ user }) {\nreturn <div>{user.name}</div>;\n}\nIdeally, the getUser\nshould not expose data that the current user should not have access to. To prevent passing the user\nobject to a Client Component down the line we can \u201ctaint\u201d the user object:\n// api.js\nimport {experimental_taintObjectReference} from 'react';\nexport async function getUser(id) {\nconst user = await db`SELECT * FROM users WHERE id = ${id}`;\nexperimental_taintObjectReference(\n'Do not pass the entire user object to the client. ' +\n'Instead, pick off the specific properties you need for this use case.',\nuser,\n);\nreturn user;\n}\nNow if anyone tries to pass the user\nobject to a Client Component, an error will be thrown with the passed in error message."
  },
  {
    "source": "https://react.dev/reference/react/experimental_taintUniqueValue",
    "title": "experimental_taintUniqueValue \u2013 React",
    "text": "experimental_taintUniqueValue\ntaintUniqueValue\nlets you prevent unique values from being passed to Client Components like passwords, keys, or tokens.\ntaintUniqueValue(errMessage, lifetime, value)\nTo prevent passing an object containing sensitive data, see taintObjectReference\n.\nReference\ntaintUniqueValue(message, lifetime, value)\nCall taintUniqueValue\nwith a password, token, key or hash to register it with React as something that should not be allowed to be passed to the Client as is:\nimport {experimental_taintUniqueValue} from 'react';\nexperimental_taintUniqueValue(\n'Do not pass secret keys to the client.',\nprocess,\nprocess.env.SECRET_KEY\n);\nParameters\n-\nmessage\n: The message you want to display ifvalue\nis passed to a Client Component. This message will be displayed as a part of the Error that will be thrown ifvalue\nis passed to a Client Component. -\nlifetime\n: Any object that indicates how longvalue\nshould be tainted.value\nwill be blocked from being sent to any Client Component while this object still exists. For example, passingglobalThis\nblocks the value for the lifetime of an app.lifetime\nis typically an object whose properties containsvalue\n. -\nvalue\n: A string, bigint or TypedArray.value\nmust be a unique sequence of characters or bytes with high entropy such as a cryptographic token, private key, hash, or a long password.value\nwill be blocked from being sent to any Client Component.\nReturns\nexperimental_taintUniqueValue\nreturns undefined\n.\nCaveats\n- Deriving new values from tainted values can compromise tainting protection. New values created by uppercasing tainted values, concatenating tainted string values into a larger string, converting tainted values to base64, substringing tainted values, and other similar transformations are not tainted unless you explicitly call\ntaintUniqueValue\non these newly created values. - Do not use\ntaintUniqueValue\nto protect low-entropy values such as PIN codes or phone numbers. If any value in a request is controlled by an attacker, they could infer which value is tainted by enumerating all possible values of the secret.\nUsage\nPrevent a token from being passed to Client Components\nTo ensure that sensitive information such as passwords, session tokens, or other unique values do not inadvertently get passed to Client Components, the taintUniqueValue\nfunction provides a layer of protection. When a value is tainted, any attempt to pass it to a Client Component will result in an error.\nThe lifetime\nargument defines the duration for which the value remains tainted. For values that should remain tainted indefinitely, objects like globalThis\nor process\ncan serve as the lifetime\nargument. These objects have a lifespan that spans the entire duration of your app\u2019s execution.\nimport {experimental_taintUniqueValue} from 'react';\nexperimental_taintUniqueValue(\n'Do not pass a user password to the client.',\nglobalThis,\nprocess.env.SECRET_KEY\n);\nIf the tainted value\u2019s lifespan is tied to a object, the lifetime\nshould be the object that encapsulates the value. This ensures the tainted value remains protected for the lifetime of the encapsulating object.\nimport {experimental_taintUniqueValue} from 'react';\nexport async function getUser(id) {\nconst user = await db`SELECT * FROM users WHERE id = ${id}`;\nexperimental_taintUniqueValue(\n'Do not pass a user session token to the client.',\nuser,\nuser.session.token\n);\nreturn user;\n}\nIn this example, the user\nobject serves as the lifetime\nargument. If this object gets stored in a global cache or is accessible by another request, the session token remains tainted.\nDeep Dive\nIf you\u2019re running a Server Components environment that has access to private keys or passwords such as database passwords, you have to be careful not to pass that to a Client Component.\nexport async function Dashboard(props) {\n// DO NOT DO THIS\nreturn <Overview password={process.env.API_PASSWORD} />;\n}\n\"use client\";\nimport {useEffect} from '...'\nexport async function Overview({ password }) {\nuseEffect(() => {\nconst headers = { Authorization: password };\nfetch(url, { headers }).then(...);\n}, [password]);\n...\n}\nThis example would leak the secret API token to the client. If this API token can be used to access data this particular user shouldn\u2019t have access to, it could lead to a data breach.\nIdeally, secrets like this are abstracted into a single helper file that can only be imported by trusted data utilities on the server. The helper can even be tagged with server-only\nto ensure that this file isn\u2019t imported on the client.\nimport \"server-only\";\nexport function fetchAPI(url) {\nconst headers = { Authorization: process.env.API_PASSWORD };\nreturn fetch(url, { headers });\n}\nSometimes mistakes happen during refactoring and not all of your colleagues might know about this. To protect against this mistakes happening down the line we can \u201ctaint\u201d the actual password:\nimport \"server-only\";\nimport {experimental_taintUniqueValue} from 'react';\nexperimental_taintUniqueValue(\n'Do not pass the API token password to the client. ' +\n'Instead do all fetches on the server.'\nprocess,\nprocess.env.API_PASSWORD\n);\nNow whenever anyone tries to pass this password to a Client Component, or send the password to a Client Component with a Server Function, an error will be thrown with message you defined when you called taintUniqueValue\n."
  },
  {
    "source": "https://react.dev/reference/react/experimental_useEffectEvent",
    "title": "experimental_useEffectEvent \u2013 React",
    "text": "experimental_useEffectEvent\nuseEffectEvent\nis a React Hook that lets you extract non-reactive logic into an Effect Event.\nconst onSomething = useEffectEvent(callback)\nThis API is experimental and is not available in a stable version of React yet.\nYou can try it by upgrading React packages to the most recent experimental version:\nreact@experimental\nreact-dom@experimental\neslint-plugin-react-hooks@experimental\nExperimental versions of React may contain bugs. Don\u2019t use them in production.\nuseEffectEvent\nis a React Hook that lets you extract non-reactive logic into an Effect Event.\nconst onSomething = useEffectEvent(callback)"
  },
  {
    "source": "https://react.dev/reference/react/forwardRef",
    "title": "forwardRef \u2013 React",
    "text": "forwardRef\nforwardRef\nlets your component expose a DOM node to parent component with a ref.\nconst SomeComponent = forwardRef(render)\nReference\nforwardRef(render)\nCall forwardRef()\nto let your component receive a ref and forward it to a child component:\nimport { forwardRef } from 'react';\nconst MyInput = forwardRef(function MyInput(props, ref) {\n// ...\n});\nParameters\nrender\n: The render function for your component. React calls this function with the props andref\nthat your component received from its parent. The JSX you return will be the output of your component.\nReturns\nforwardRef\nreturns a React component that you can render in JSX. Unlike React components defined as plain functions, a component returned by forwardRef\nis also able to receive a ref\nprop.\nCaveats\n- In Strict Mode, React will call your render function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your render function is pure (as it should be), this should not affect the logic of your component. The result from one of the calls will be ignored.\nrender\nfunction\nforwardRef\naccepts a render function as an argument. React calls this function with props\nand ref\n:\nconst MyInput = forwardRef(function MyInput(props, ref) {\nreturn (\n<label>\n{props.label}\n<input ref={ref} />\n</label>\n);\n});\nParameters\n-\nprops\n: The props passed by the parent component. -\nref\n: Theref\nattribute passed by the parent component. Theref\ncan be an object or a function. If the parent component has not passed a ref, it will benull\n. You should either pass theref\nyou receive to another component, or pass it touseImperativeHandle\n.\nReturns\nforwardRef\nreturns a React component that you can render in JSX. Unlike React components defined as plain functions, the component returned by forwardRef\nis able to take a ref\nprop.\nUsage\nExposing a DOM node to the parent component\nBy default, each component\u2019s DOM nodes are private. However, sometimes it\u2019s useful to expose a DOM node to the parent\u2014for example, to allow focusing it. To opt in, wrap your component definition into forwardRef()\n:\nimport { forwardRef } from 'react';\nconst MyInput = forwardRef(function MyInput(props, ref) {\nconst { label, ...otherProps } = props;\nreturn (\n<label>\n{label}\n<input {...otherProps} />\n</label>\n);\n});\nYou will receive a ref as the second argument after props. Pass it to the DOM node that you want to expose:\nimport { forwardRef } from 'react';\nconst MyInput = forwardRef(function MyInput(props, ref) {\nconst { label, ...otherProps } = props;\nreturn (\n<label>\n{label}\n<input {...otherProps} ref={ref} />\n</label>\n);\n});\nThis lets the parent Form\ncomponent access the <input>\nDOM node exposed by MyInput\n:\nfunction Form() {\nconst ref = useRef(null);\nfunction handleClick() {\nref.current.focus();\n}\nreturn (\n<form>\n<MyInput label=\"Enter your name:\" ref={ref} />\n<button type=\"button\" onClick={handleClick}>\nEdit\n</button>\n</form>\n);\n}\nThis Form\ncomponent passes a ref to MyInput\n. The MyInput\ncomponent forwards that ref to the <input>\nbrowser tag. As a result, the Form\ncomponent can access that <input>\nDOM node and call focus()\non it.\nKeep in mind that exposing a ref to the DOM node inside your component makes it harder to change your component\u2019s internals later. You will typically expose DOM nodes from reusable low-level components like buttons or text inputs, but you won\u2019t do it for application-level components like an avatar or a comment.\nExample 1 of 2: Focusing a text input\nClicking the button will focus the input. The Form\ncomponent defines a ref and passes it to the MyInput\ncomponent. The MyInput\ncomponent forwards that ref to the browser <input>\n. This lets the Form\ncomponent focus the <input>\n.\nimport { useRef } from 'react'; import MyInput from './MyInput.js'; export default function Form() { const ref = useRef(null); function handleClick() { ref.current.focus(); } return ( <form> <MyInput label=\"Enter your name:\" ref={ref} /> <button type=\"button\" onClick={handleClick}> Edit </button> </form> ); }\nForwarding a ref through multiple components\nInstead of forwarding a ref\nto a DOM node, you can forward it to your own component like MyInput\n:\nconst FormField = forwardRef(function FormField(props, ref) {\n// ...\nreturn (\n<>\n<MyInput ref={ref} />\n...\n</>\n);\n});\nIf that MyInput\ncomponent forwards a ref to its <input>\n, a ref to FormField\nwill give you that <input>\n:\nfunction Form() {\nconst ref = useRef(null);\nfunction handleClick() {\nref.current.focus();\n}\nreturn (\n<form>\n<FormField label=\"Enter your name:\" ref={ref} isRequired={true} />\n<button type=\"button\" onClick={handleClick}>\nEdit\n</button>\n</form>\n);\n}\nThe Form\ncomponent defines a ref and passes it to FormField\n. The FormField\ncomponent forwards that ref to MyInput\n, which forwards it to a browser <input>\nDOM node. This is how Form\naccesses that DOM node.\nimport { useRef } from 'react'; import FormField from './FormField.js'; export default function Form() { const ref = useRef(null); function handleClick() { ref.current.focus(); } return ( <form> <FormField label=\"Enter your name:\" ref={ref} isRequired={true} /> <button type=\"button\" onClick={handleClick}> Edit </button> </form> ); }\nExposing an imperative handle instead of a DOM node\nInstead of exposing an entire DOM node, you can expose a custom object, called an imperative handle, with a more constrained set of methods. To do this, you\u2019d need to define a separate ref to hold the DOM node:\nconst MyInput = forwardRef(function MyInput(props, ref) {\nconst inputRef = useRef(null);\n// ...\nreturn <input {...props} ref={inputRef} />;\n});\nPass the ref\nyou received to useImperativeHandle\nand specify the value you want to expose to the ref\n:\nimport { forwardRef, useRef, useImperativeHandle } from 'react';\nconst MyInput = forwardRef(function MyInput(props, ref) {\nconst inputRef = useRef(null);\nuseImperativeHandle(ref, () => {\nreturn {\nfocus() {\ninputRef.current.focus();\n},\nscrollIntoView() {\ninputRef.current.scrollIntoView();\n},\n};\n}, []);\nreturn <input {...props} ref={inputRef} />;\n});\nIf some component gets a ref to MyInput\n, it will only receive your { focus, scrollIntoView }\nobject instead of the DOM node. This lets you limit the information you expose about your DOM node to the minimum.\nimport { useRef } from 'react'; import MyInput from './MyInput.js'; export default function Form() { const ref = useRef(null); function handleClick() { ref.current.focus(); // This won't work because the DOM node isn't exposed: // ref.current.style.opacity = 0.5; } return ( <form> <MyInput placeholder=\"Enter your name\" ref={ref} /> <button type=\"button\" onClick={handleClick}> Edit </button> </form> ); }\nRead more about using imperative handles.\nTroubleshooting\nMy component is wrapped in forwardRef\n, but the ref\nto it is always null\nThis usually means that you forgot to actually use the ref\nthat you received.\nFor example, this component doesn\u2019t do anything with its ref\n:\nconst MyInput = forwardRef(function MyInput({ label }, ref) {\nreturn (\n<label>\n{label}\n<input />\n</label>\n);\n});\nTo fix it, pass the ref\ndown to a DOM node or another component that can accept a ref:\nconst MyInput = forwardRef(function MyInput({ label }, ref) {\nreturn (\n<label>\n{label}\n<input ref={ref} />\n</label>\n);\n});\nThe ref\nto MyInput\ncould also be null\nif some of the logic is conditional:\nconst MyInput = forwardRef(function MyInput({ label, showInput }, ref) {\nreturn (\n<label>\n{label}\n{showInput && <input ref={ref} />}\n</label>\n);\n});\nIf showInput\nis false\n, then the ref won\u2019t be forwarded to any node, and a ref to MyInput\nwill remain empty. This is particularly easy to miss if the condition is hidden inside another component, like Panel\nin this example:\nconst MyInput = forwardRef(function MyInput({ label, showInput }, ref) {\nreturn (\n<label>\n{label}\n<Panel isExpanded={showInput}>\n<input ref={ref} />\n</Panel>\n</label>\n);\n});"
  },
  {
    "source": "https://react.dev/reference/react/hooks",
    "title": "Built-in React Hooks \u2013 React",
    "text": "Built-in React Hooks\nHooks let you use different React features from your components. You can either use the built-in Hooks or combine them to build your own. This page lists all built-in Hooks in React.\nState Hooks\nState lets a component \u201cremember\u201d information like user input. For example, a form component can use state to store the input value, while an image gallery component can use state to store the selected image index.\nTo add state to a component, use one of these Hooks:\nuseState\ndeclares a state variable that you can update directly.useReducer\ndeclares a state variable with the update logic inside a reducer function.\nfunction ImageGallery() {\nconst [index, setIndex] = useState(0);\n// ...\nContext Hooks\nContext lets a component receive information from distant parents without passing it as props. For example, your app\u2019s top-level component can pass the current UI theme to all components below, no matter how deep.\nuseContext\nreads and subscribes to a context.\nfunction Button() {\nconst theme = useContext(ThemeContext);\n// ...\nRef Hooks\nRefs let a component hold some information that isn\u2019t used for rendering, like a DOM node or a timeout ID. Unlike with state, updating a ref does not re-render your component. Refs are an \u201cescape hatch\u201d from the React paradigm. They are useful when you need to work with non-React systems, such as the built-in browser APIs.\nuseRef\ndeclares a ref. You can hold any value in it, but most often it\u2019s used to hold a DOM node.useImperativeHandle\nlets you customize the ref exposed by your component. This is rarely used.\nfunction Form() {\nconst inputRef = useRef(null);\n// ...\nEffect Hooks\nEffects let a component connect to and synchronize with external systems. This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code.\nuseEffect\nconnects a component to an external system.\nfunction ChatRoom({ roomId }) {\nuseEffect(() => {\nconst connection = createConnection(roomId);\nconnection.connect();\nreturn () => connection.disconnect();\n}, [roomId]);\n// ...\nEffects are an \u201cescape hatch\u201d from the React paradigm. Don\u2019t use Effects to orchestrate the data flow of your application. If you\u2019re not interacting with an external system, you might not need an Effect.\nThere are two rarely used variations of useEffect\nwith differences in timing:\nuseLayoutEffect\nfires before the browser repaints the screen. You can measure layout here.useInsertionEffect\nfires before React makes changes to the DOM. Libraries can insert dynamic CSS here.\nPerformance Hooks\nA common way to optimize re-rendering performance is to skip unnecessary work. For example, you can tell React to reuse a cached calculation or to skip a re-render if the data has not changed since the previous render.\nTo skip calculations and unnecessary re-rendering, use one of these Hooks:\nuseMemo\nlets you cache the result of an expensive calculation.useCallback\nlets you cache a function definition before passing it down to an optimized component.\nfunction TodoList({ todos, tab, theme }) {\nconst visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\n// ...\n}\nSometimes, you can\u2019t skip re-rendering because the screen actually needs to update. In that case, you can improve performance by separating blocking updates that must be synchronous (like typing into an input) from non-blocking updates which don\u2019t need to block the user interface (like updating a chart).\nTo prioritize rendering, use one of these Hooks:\nuseTransition\nlets you mark a state transition as non-blocking and allow other updates to interrupt it.useDeferredValue\nlets you defer updating a non-critical part of the UI and let other parts update first.\nOther Hooks\nThese Hooks are mostly useful to library authors and aren\u2019t commonly used in the application code.\nuseDebugValue\nlets you customize the label React DevTools displays for your custom Hook.useId\nlets a component associate a unique ID with itself. Typically used with accessibility APIs.useSyncExternalStore\nlets a component subscribe to an external store.\nuseActionState\nallows you to manage state of actions.\nYour own Hooks\nYou can also define your own custom Hooks as JavaScript functions."
  },
  {
    "source": "https://react.dev/reference/react/isValidElement",
    "title": "isValidElement \u2013 React",
    "text": "isValidElement\nisValidElement\nchecks whether a value is a React element.\nconst isElement = isValidElement(value)\nReference\nisValidElement(value)\nCall isValidElement(value)\nto check whether value\nis a React element.\nimport { isValidElement, createElement } from 'react';\n// \u2705 React elements\nconsole.log(isValidElement(<p />)); // true\nconsole.log(isValidElement(createElement('p'))); // true\n// \u274c Not React elements\nconsole.log(isValidElement(25)); // false\nconsole.log(isValidElement('Hello')); // false\nconsole.log(isValidElement({ age: 42 })); // false\nParameters\nvalue\n: Thevalue\nyou want to check. It can be any a value of any type.\nReturns\nisValidElement\nreturns true\nif the value\nis a React element. Otherwise, it returns false\n.\nCaveats\n- Only JSX tags and objects returned by\ncreateElement\nare considered to be React elements. For example, even though a number like42\nis a valid React node (and can be returned from a component), it is not a valid React element. Arrays and portals created withcreatePortal\nare also not considered to be React elements.\nUsage\nChecking if something is a React element\nCall isValidElement\nto check if some value is a React element.\nReact elements are:\n- Values produced by writing a JSX tag\n- Values produced by calling\ncreateElement\nFor React elements, isValidElement\nreturns true\n:\nimport { isValidElement, createElement } from 'react';\n// \u2705 JSX tags are React elements\nconsole.log(isValidElement(<p />)); // true\nconsole.log(isValidElement(<MyComponent />)); // true\n// \u2705 Values returned by createElement are React elements\nconsole.log(isValidElement(createElement('p'))); // true\nconsole.log(isValidElement(createElement(MyComponent))); // true\nAny other values, such as strings, numbers, or arbitrary objects and arrays, are not React elements.\nFor them, isValidElement\nreturns false\n:\n// \u274c These are *not* React elements\nconsole.log(isValidElement(null)); // false\nconsole.log(isValidElement(25)); // false\nconsole.log(isValidElement('Hello')); // false\nconsole.log(isValidElement({ age: 42 })); // false\nconsole.log(isValidElement([<div />, <div />])); // false\nconsole.log(isValidElement(MyComponent)); // false\nIt is very uncommon to need isValidElement\n. It\u2019s mostly useful if you\u2019re calling another API that only accepts elements (like cloneElement\ndoes) and you want to avoid an error when your argument is not a React element.\nUnless you have some very specific reason to add an isValidElement\ncheck, you probably don\u2019t need it.\nDeep Dive\nWhen you write a component, you can return any kind of React node from it:\nfunction MyComponent() {\n// ... you can return any React node ...\n}\nA React node can be:\n- A React element created like\n<div />\norcreateElement('div')\n- A portal created with\ncreatePortal\n- A string\n- A number\ntrue\n,false\n,null\n, orundefined\n(which are not displayed)- An array of other React nodes\nNote isValidElement\nchecks whether the argument is a React element, not whether it\u2019s a React node. For example, 42\nis not a valid React element. However, it is a perfectly valid React node:\nfunction MyComponent() {\nreturn 42; // It's ok to return a number from component\n}\nThis is why you shouldn\u2019t use isValidElement\nas a way to check whether something can be rendered."
  },
  {
    "source": "https://react.dev/reference/react/lazy",
    "title": "lazy \u2013 React",
    "text": "lazy\nlets you defer loading component\u2019s code until it is rendered for the first time.\nconst SomeComponent = lazy(load)\nReference\nlazy(load)\nCall lazy\noutside your components to declare a lazy-loaded React component:\nimport { lazy } from 'react';\nconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\nParameters\nload\n: A function that returns a Promise or another thenable (a Promise-like object with athen\nmethod). React will not callload\nuntil the first time you attempt to render the returned component. After React first callsload\n, it will wait for it to resolve, and then render the resolved value\u2019s.default\nas a React component. Both the returned Promise and the Promise\u2019s resolved value will be cached, so React will not callload\nmore than once. If the Promise rejects, React willthrow\nthe rejection reason for the nearest Error Boundary to handle.\nReturns\nlazy\nreturns a React component you can render in your tree. While the code for the lazy component is still loading, attempting to render it will suspend. Use <Suspense>\nto display a loading indicator while it\u2019s loading.\nload\nfunction\nParameters\nload\nreceives no parameters.\nReturns\nYou need to return a Promise or some other thenable (a Promise-like object with a then\nmethod). It needs to eventually resolve to an object whose .default\nproperty is a valid React component type, such as a function, memo\n, or a forwardRef\ncomponent.\nUsage\nLazy-loading components with Suspense\nUsually, you import components with the static import\ndeclaration:\nimport MarkdownPreview from './MarkdownPreview.js';\nTo defer loading this component\u2019s code until it\u2019s rendered for the first time, replace this import with:\nimport { lazy } from 'react';\nconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\nThis code relies on dynamic import()\n, which might require support from your bundler or framework. Using this pattern requires that the lazy component you\u2019re importing was exported as the default\nexport.\nNow that your component\u2019s code loads on demand, you also need to specify what should be displayed while it is loading. You can do this by wrapping the lazy component or any of its parents into a <Suspense>\nboundary:\n<Suspense fallback={<Loading />}>\n<h2>Preview</h2>\n<MarkdownPreview />\n</Suspense>\nIn this example, the code for MarkdownPreview\nwon\u2019t be loaded until you attempt to render it. If MarkdownPreview\nhasn\u2019t loaded yet, Loading\nwill be shown in its place. Try ticking the checkbox:\nimport { useState, Suspense, lazy } from 'react'; import Loading from './Loading.js'; const MarkdownPreview = lazy(() => delayForDemo(import('./MarkdownPreview.js'))); export default function MarkdownEditor() { const [showPreview, setShowPreview] = useState(false); const [markdown, setMarkdown] = useState('Hello, **world**!'); return ( <> <textarea value={markdown} onChange={e => setMarkdown(e.target.value)} /> <label> <input type=\"checkbox\" checked={showPreview} onChange={e => setShowPreview(e.target.checked)} /> Show preview </label> <hr /> {showPreview && ( <Suspense fallback={<Loading />}> <h2>Preview</h2> <MarkdownPreview markdown={markdown} /> </Suspense> )} </> ); } // Add a fixed delay so you can see the loading state function delayForDemo(promise) { return new Promise(resolve => { setTimeout(resolve, 2000); }).then(() => promise); }\nThis demo loads with an artificial delay. The next time you untick and tick the checkbox, Preview\nwill be cached, so there will be no loading state. To see the loading state again, click \u201cReset\u201d on the sandbox.\nLearn more about managing loading states with Suspense.\nTroubleshooting\nMy lazy\ncomponent\u2019s state gets reset unexpectedly\nDo not declare lazy\ncomponents inside other components:\nimport { lazy } from 'react';\nfunction Editor() {\n// \ud83d\udd34 Bad: This will cause all state to be reset on re-renders\nconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\n// ...\n}\nInstead, always declare them at the top level of your module:\nimport { lazy } from 'react';\n// \u2705 Good: Declare lazy components outside of your components\nconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\nfunction Editor() {\n// ...\n}"
  },
  {
    "source": "https://react.dev/reference/react/legacy",
    "title": "Legacy React APIs \u2013 React",
    "text": "Legacy React APIs\nThese APIs are exported from the react\npackage, but they are not recommended for use in newly written code. See the linked individual API pages for the suggested alternatives.\nLegacy APIs\nChildren\nlets you manipulate and transform the JSX received as thechildren\nprop. See alternatives.cloneElement\nlets you create a React element using another element as a starting point. See alternatives.Component\nlets you define a React component as a JavaScript class. See alternatives.createElement\nlets you create a React element. Typically, you\u2019ll use JSX instead.createRef\ncreates a ref object which can contain arbitrary value. See alternatives.forwardRef\nlets your component expose a DOM node to parent component with a ref.isValidElement\nchecks whether a value is a React element. Typically used withcloneElement\n.PureComponent\nis similar toComponent\n, but it skip re-renders with same props. See alternatives.\nRemoved APIs\nThese APIs were removed in React 19:\ncreateFactory\n: use JSX instead.- Class Components:\nstatic contextTypes\n: usestatic contextType\ninstead. - Class Components:\nstatic childContextTypes\n: usestatic contextType\ninstead. - Class Components:\nstatic getChildContext\n: useContext.Provider\ninstead. - Class Components:\nstatic propTypes\n: use a type system like TypeScript instead. - Class Components:\nthis.refs\n: usecreateRef\ninstead."
  },
  {
    "source": "https://react.dev/reference/react/memo",
    "title": "memo \u2013 React",
    "text": "memo\nlets you skip re-rendering a component when its props are unchanged.\nconst MemoizedComponent = memo(SomeComponent, arePropsEqual?)\nReference\nmemo(Component, arePropsEqual?)\nWrap a component in memo\nto get a memoized version of that component. This memoized version of your component will usually not be re-rendered when its parent component is re-rendered as long as its props have not changed. But React may still re-render it: memoization is a performance optimization, not a guarantee.\nimport { memo } from 'react';\nconst SomeComponent = memo(function SomeComponent(props) {\n// ...\n});\nParameters\n-\nComponent\n: The component that you want to memoize. Thememo\ndoes not modify this component, but returns a new, memoized component instead. Any valid React component, including functions andforwardRef\ncomponents, is accepted. -\noptional\narePropsEqual\n: A function that accepts two arguments: the component\u2019s previous props, and its new props. It should returntrue\nif the old and new props are equal: that is, if the component will render the same output and behave in the same way with the new props as with the old. Otherwise it should returnfalse\n. Usually, you will not specify this function. By default, React will compare each prop withObject.is\n.\nReturns\nmemo\nreturns a new React component. It behaves the same as the component provided to memo\nexcept that React will not always re-render it when its parent is being re-rendered unless its props have changed.\nUsage\nSkipping re-rendering when props are unchanged\nReact normally re-renders a component whenever its parent re-renders. With memo\n, you can create a component that React will not re-render when its parent re-renders so long as its new props are the same as the old props. Such a component is said to be memoized.\nTo memoize a component, wrap it in memo\nand use the value that it returns in place of your original component:\nconst Greeting = memo(function Greeting({ name }) {\nreturn <h1>Hello, {name}!</h1>;\n});\nexport default Greeting;\nA React component should always have pure rendering logic. This means that it must return the same output if its props, state, and context haven\u2019t changed. By using memo\n, you are telling React that your component complies with this requirement, so React doesn\u2019t need to re-render as long as its props haven\u2019t changed. Even with memo\n, your component will re-render if its own state changes or if a context that it\u2019s using changes.\nIn this example, notice that the Greeting\ncomponent re-renders whenever name\nis changed (because that\u2019s one of its props), but not when address\nis changed (because it\u2019s not passed to Greeting\nas a prop):\nimport { memo, useState } from 'react'; export default function MyApp() { const [name, setName] = useState(''); const [address, setAddress] = useState(''); return ( <> <label> Name{': '} <input value={name} onChange={e => setName(e.target.value)} /> </label> <label> Address{': '} <input value={address} onChange={e => setAddress(e.target.value)} /> </label> <Greeting name={name} /> </> ); } const Greeting = memo(function Greeting({ name }) { console.log(\"Greeting was rendered at\", new Date().toLocaleTimeString()); return <h3>Hello{name && ', '}{name}!</h3>; });\nDeep Dive\nIf your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.\nOptimizing with memo\nis only valuable when your component re-renders often with the same exact props, and its re-rendering logic is expensive. If there is no perceptible lag when your component re-renders, memo\nis unnecessary. Keep in mind that memo\nis completely useless if the props passed to your component are always different, such as if you pass an object or a plain function defined during rendering. This is why you will often need useMemo\nand useCallback\ntogether with memo\n.\nThere is no benefit to wrapping a component in memo\nin other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value that\u2019s \u201calways new\u201d is enough to break memoization for an entire component.\nIn practice, you can make a lot of memoization unnecessary by following a few principles:\n- When a component visually wraps other components, let it accept JSX as children. This way, when the wrapper component updates its own state, React knows that its children don\u2019t need to re-render.\n- Prefer local state and don\u2019t lift state up any further than necessary. For example, don\u2019t keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.\n- Keep your rendering logic pure. If re-rendering a component causes a problem or produces some noticeable visual artifact, it\u2019s a bug in your component! Fix the bug instead of adding memoization.\n- Avoid unnecessary Effects that update state. Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.\n- Try to remove unnecessary dependencies from your Effects. For example, instead of memoization, it\u2019s often simpler to move some object or a function inside an Effect or outside the component.\nIf a specific interaction still feels laggy, use the React Developer Tools profiler to see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it\u2019s good to follow them in any case. In the long term, we\u2019re researching doing granular memoization automatically to solve this once and for all.\nUpdating a memoized component using state\nEven when a component is memoized, it will still re-render when its own state changes. Memoization only has to do with props that are passed to the component from its parent.\nimport { memo, useState } from 'react'; export default function MyApp() { const [name, setName] = useState(''); const [address, setAddress] = useState(''); return ( <> <label> Name{': '} <input value={name} onChange={e => setName(e.target.value)} /> </label> <label> Address{': '} <input value={address} onChange={e => setAddress(e.target.value)} /> </label> <Greeting name={name} /> </> ); } const Greeting = memo(function Greeting({ name }) { console.log('Greeting was rendered at', new Date().toLocaleTimeString()); const [greeting, setGreeting] = useState('Hello'); return ( <> <h3>{greeting}{name && ', '}{name}!</h3> <GreetingSelector value={greeting} onChange={setGreeting} /> </> ); }); function GreetingSelector({ value, onChange }) { return ( <> <label> <input type=\"radio\" checked={value === 'Hello'} onChange={e => onChange('Hello')} /> Regular greeting </label> <label> <input type=\"radio\" checked={value === 'Hello and welcome'} onChange={e => onChange('Hello and welcome')} /> Enthusiastic greeting </label> </> ); }\nIf you set a state variable to its current value, React will skip re-rendering your component even without memo\n. You may still see your component function being called an extra time, but the result will be discarded.\nUpdating a memoized component using a context\nEven when a component is memoized, it will still re-render when a context that it\u2019s using changes. Memoization only has to do with props that are passed to the component from its parent.\nimport { createContext, memo, useContext, useState } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { const [theme, setTheme] = useState('dark'); function handleClick() { setTheme(theme === 'dark' ? 'light' : 'dark'); } return ( <ThemeContext.Provider value={theme}> <button onClick={handleClick}> Switch theme </button> <Greeting name=\"Taylor\" /> </ThemeContext.Provider> ); } const Greeting = memo(function Greeting({ name }) { console.log(\"Greeting was rendered at\", new Date().toLocaleTimeString()); const theme = useContext(ThemeContext); return ( <h3 className={theme}>Hello, {name}!</h3> ); });\nTo make your component re-render only when a part of some context changes, split your component in two. Read what you need from the context in the outer component, and pass it down to a memoized child as a prop.\nMinimizing props changes\nWhen you use memo\n, your component re-renders whenever any prop is not shallowly equal to what it was previously. This means that React compares every prop in your component with its previous value using the Object.is\ncomparison. Note that Object.is(3, 3)\nis true\n, but Object.is({}, {})\nis false\n.\nTo get the most out of memo\n, minimize the times that the props change. For example, if the prop is an object, prevent the parent component from re-creating that object every time by using useMemo\n:\nfunction Page() {\nconst [name, setName] = useState('Taylor');\nconst [age, setAge] = useState(42);\nconst person = useMemo(\n() => ({ name, age }),\n[name, age]\n);\nreturn <Profile person={person} />;\n}\nconst Profile = memo(function Profile({ person }) {\n// ...\n});\nA better way to minimize props changes is to make sure the component accepts the minimum necessary information in its props. For example, it could accept individual values instead of a whole object:\nfunction Page() {\nconst [name, setName] = useState('Taylor');\nconst [age, setAge] = useState(42);\nreturn <Profile name={name} age={age} />;\n}\nconst Profile = memo(function Profile({ name, age }) {\n// ...\n});\nEven individual values can sometimes be projected to ones that change less frequently. For example, here a component accepts a boolean indicating the presence of a value rather than the value itself:\nfunction GroupsLanding({ person }) {\nconst hasGroups = person.groups !== null;\nreturn <CallToAction hasGroups={hasGroups} />;\n}\nconst CallToAction = memo(function CallToAction({ hasGroups }) {\n// ...\n});\nWhen you need to pass a function to memoized component, either declare it outside your component so that it never changes, or useCallback\nto cache its definition between re-renders.\nSpecifying a custom comparison function\nIn rare cases it may be infeasible to minimize the props changes of a memoized component. In that case, you can provide a custom comparison function, which React will use to compare the old and new props instead of using shallow equality. This function is passed as a second argument to memo\n. It should return true\nonly if the new props would result in the same output as the old props; otherwise it should return false\n.\nconst Chart = memo(function Chart({ dataPoints }) {\n// ...\n}, arePropsEqual);\nfunction arePropsEqual(oldProps, newProps) {\nreturn (\noldProps.dataPoints.length === newProps.dataPoints.length &&\noldProps.dataPoints.every((oldPoint, index) => {\nconst newPoint = newProps.dataPoints[index];\nreturn oldPoint.x === newPoint.x && oldPoint.y === newPoint.y;\n})\n);\n}\nIf you do this, use the Performance panel in your browser developer tools to make sure that your comparison function is actually faster than re-rendering the component. You might be surprised.\nWhen you do performance measurements, make sure that React is running in the production mode.\nTroubleshooting\nMy component re-renders when a prop is an object, array, or function\nReact compares old and new props by shallow equality: that is, it considers whether each new prop is reference-equal to the old prop. If you create a new object or array each time the parent is re-rendered, even if the individual elements are each the same, React will still consider it to be changed. Similarly, if you create a new function when rendering the parent component, React will consider it to have changed even if the function has the same definition. To avoid this, simplify props or memoize props in the parent component."
  },
  {
    "source": "https://react.dev/reference/react/startTransition",
    "title": "startTransition \u2013 React",
    "text": "startTransition\nstartTransition\nlets you render a part of the UI in the background.\nstartTransition(action)\nReference\nstartTransition(action)\nThe startTransition\nfunction lets you mark a state update as a Transition.\nimport { startTransition } from 'react';\nfunction TabContainer() {\nconst [tab, setTab] = useState('about');\nfunction selectTab(nextTab) {\nstartTransition(() => {\nsetTab(nextTab);\n});\n}\n// ...\n}\nParameters\naction\n: A function that updates some state by calling one or moreset\nfunctions. React callsaction\nimmediately with no parameters and marks all state updates scheduled synchronously during theaction\nfunction call as Transitions. Any async calls awaited in theaction\nwill be included in the transition, but currently require wrapping anyset\nfunctions after theawait\nin an additionalstartTransition\n(see Troubleshooting). State updates marked as Transitions will be non-blocking and will not display unwanted loading indicators..\nReturns\nstartTransition\ndoes not return anything.\nCaveats\n-\nstartTransition\ndoes not provide a way to track whether a Transition is pending. To show a pending indicator while the Transition is ongoing, you needuseTransition\ninstead. -\nYou can wrap an update into a Transition only if you have access to the\nset\nfunction of that state. If you want to start a Transition in response to some prop or a custom Hook return value, tryuseDeferredValue\ninstead. -\nThe function you pass to\nstartTransition\nis called immediately, marking all state updates that happen while it executes as Transitions. If you try to perform state updates in asetTimeout\n, for example, they won\u2019t be marked as Transitions. -\nYou must wrap any state updates after any async requests in another\nstartTransition\nto mark them as Transitions. This is a known limitation that we will fix in the future (see Troubleshooting). -\nA state update marked as a Transition will be interrupted by other state updates. For example, if you update a chart component inside a Transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input state update.\n-\nTransition updates can\u2019t be used to control text inputs.\n-\nIf there are multiple ongoing Transitions, React currently batches them together. This is a limitation that may be removed in a future release.\nUsage\nMarking a state update as a non-blocking Transition\nYou can mark a state update as a Transition by wrapping it in a startTransition\ncall:\nimport { startTransition } from 'react';\nfunction TabContainer() {\nconst [tab, setTab] = useState('about');\nfunction selectTab(nextTab) {\nstartTransition(() => {\nsetTab(nextTab);\n});\n}\n// ...\n}\nTransitions let you keep the user interface updates responsive even on slow devices.\nWith a Transition, your UI stays responsive in the middle of a re-render. For example, if the user clicks a tab but then change their mind and click another tab, they can do that without waiting for the first re-render to finish."
  },
  {
    "source": "https://react.dev/reference/react/use",
    "title": "use \u2013 React",
    "text": "use\nis a React API that lets you read the value of a resource like a Promise or context.\nconst value = use(resource);\nReference\nuse(resource)\nCall use\nin your component to read the value of a resource like a Promise or context.\nimport { use } from 'react';\nfunction MessageComponent({ messagePromise }) {\nconst message = use(messagePromise);\nconst theme = use(ThemeContext);\n// ...\nUnlike React Hooks, use\ncan be called within loops and conditional statements like if\n. Like React Hooks, the function that calls use\nmust be a Component or Hook.\nWhen called with a Promise, the use\nAPI integrates with Suspense\nand error boundaries. The component calling use\nsuspends while the Promise passed to use\nis pending. If the component that calls use\nis wrapped in a Suspense boundary, the fallback will be displayed. Once the Promise is resolved, the Suspense fallback is replaced by the rendered components using the data returned by the use\nAPI. If the Promise passed to use\nis rejected, the fallback of the nearest Error Boundary will be displayed.\nParameters\nresource\n: this is the source of the data you want to read a value from. A resource can be a Promise or a context.\nReturns\nThe use\nAPI returns the value that was read from the resource like the resolved value of a Promise or context.\nCaveats\n- The\nuse\nAPI must be called inside a Component or a Hook. - When fetching data in a Server Component, prefer\nasync\nandawait\noveruse\n.async\nandawait\npick up rendering from the point whereawait\nwas invoked, whereasuse\nre-renders the component after the data is resolved. - Prefer creating Promises in Server Components and passing them to Client Components over creating Promises in Client Components. Promises created in Client Components are recreated on every render. Promises passed from a Server Component to a Client Component are stable across re-renders. See this example.\nUsage\nReading context with use\nWhen a context is passed to use\n, it works similarly to useContext\n. While useContext\nmust be called at the top level of your component, use\ncan be called inside conditionals like if\nand loops like for\n. use\nis preferred over useContext\nbecause it is more flexible.\nimport { use } from 'react';\nfunction Button() {\nconst theme = use(ThemeContext);\n// ...\nuse\nreturns the context value for the context you passed. To determine the context value, React searches the component tree and finds the closest context provider above for that particular context.\nTo pass context to a Button\n, wrap it or one of its parent components into the corresponding context provider.\nfunction MyPage() {\nreturn (\n<ThemeContext.Provider value=\"dark\">\n<Form />\n</ThemeContext.Provider>\n);\n}\nfunction Form() {\n// ... renders buttons inside ...\n}\nIt doesn\u2019t matter how many layers of components there are between the provider and the Button\n. When a Button\nanywhere inside of Form\ncalls use(ThemeContext)\n, it will receive \"dark\"\nas the value.\nUnlike useContext\n, use\ncan be called in conditionals and loops like if\n.\nfunction HorizontalRule({ show }) {\nif (show) {\nconst theme = use(ThemeContext);\nreturn <hr className={theme} />;\n}\nreturn false;\n}\nuse\nis called from inside a if\nstatement, allowing you to conditionally read values from a Context.\nimport { createContext, use } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { return ( <ThemeContext.Provider value=\"dark\"> <Form /> </ThemeContext.Provider> ) } function Form() { return ( <Panel title=\"Welcome\"> <Button show={true}>Sign up</Button> <Button show={false}>Log in</Button> </Panel> ); } function Panel({ title, children }) { const theme = use(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> <h1>{title}</h1> {children} </section> ) } function Button({ show, children }) { if (show) { const theme = use(ThemeContext); const className = 'button-' + theme; return ( <button className={className}> {children} </button> ); } return false }\nStreaming data from the server to the client\nData can be streamed from the server to the client by passing a Promise as a prop from a Server Component to a Client Component.\nimport { fetchMessage } from './lib.js';\nimport { Message } from './message.js';\nexport default function App() {\nconst messagePromise = fetchMessage();\nreturn (\n<Suspense fallback={<p>waiting for message...</p>}>\n<Message messagePromise={messagePromise} />\n</Suspense>\n);\n}\nThe Client Component then takes the Promise it received as a prop and passes it to the use\nAPI. This allows the Client Component to read the value from the Promise that was initially created by the Server Component.\n// message.js\n'use client';\nimport { use } from 'react';\nexport function Message({ messagePromise }) {\nconst messageContent = use(messagePromise);\nreturn <p>Here is the message: {messageContent}</p>;\n}\nBecause Message\nis wrapped in Suspense\n, the fallback will be displayed until the Promise is resolved. When the Promise is resolved, the value will be read by the use\nAPI and the Message\ncomponent will replace the Suspense fallback.\n\"use client\"; import { use, Suspense } from \"react\"; function Message({ messagePromise }) { const messageContent = use(messagePromise); return <p>Here is the message: {messageContent}</p>; } export function MessageContainer({ messagePromise }) { return ( <Suspense fallback={<p>\u231bDownloading message...</p>}> <Message messagePromise={messagePromise} /> </Suspense> ); }\nDeep Dive\nA Promise can be passed from a Server Component to a Client Component and resolved in the Client Component with the use\nAPI. You can also resolve the Promise in a Server Component with await\nand pass the required data to the Client Component as a prop.\nexport default async function App() {\nconst messageContent = await fetchMessage();\nreturn <Message messageContent={messageContent} />\n}\nBut using await\nin a Server Component will block its rendering until the await\nstatement is finished. Passing a Promise from a Server Component to a Client Component prevents the Promise from blocking the rendering of the Server Component.\nDealing with rejected Promises\nIn some cases a Promise passed to use\ncould be rejected. You can handle rejected Promises by either:\n- Displaying an error to users with an error boundary.\n- Providing an alternative value with\nPromise.catch\nDisplaying an error to users with an error boundary\nIf you\u2019d like to display an error to your users when a Promise is rejected, you can use an error boundary. To use an error boundary, wrap the component where you are calling the use\nAPI in an error boundary. If the Promise passed to use\nis rejected the fallback for the error boundary will be displayed.\n\"use client\"; import { use, Suspense } from \"react\"; import { ErrorBoundary } from \"react-error-boundary\"; export function MessageContainer({ messagePromise }) { return ( <ErrorBoundary fallback={<p>\u26a0\ufe0fSomething went wrong</p>}> <Suspense fallback={<p>\u231bDownloading message...</p>}> <Message messagePromise={messagePromise} /> </Suspense> </ErrorBoundary> ); } function Message({ messagePromise }) { const content = use(messagePromise); return <p>Here is the message: {content}</p>; }\nProviding an alternative value with Promise.catch\nIf you\u2019d like to provide an alternative value when the Promise passed to use\nis rejected you can use the Promise\u2019s catch\nmethod.\nimport { Message } from './message.js';\nexport default function App() {\nconst messagePromise = new Promise((resolve, reject) => {\nreject();\n}).catch(() => {\nreturn \"no new message found.\";\n});\nreturn (\n<Suspense fallback={<p>waiting for message...</p>}>\n<Message messagePromise={messagePromise} />\n</Suspense>\n);\n}\nTo use the Promise\u2019s catch\nmethod, call catch\non the Promise object. catch\ntakes a single argument: a function that takes an error message as an argument. Whatever is returned by the function passed to catch\nwill be used as the resolved value of the Promise.\nTroubleshooting\n\u201cSuspense Exception: This is not a real error!\u201d\nYou are either calling use\noutside of a React Component or Hook function, or calling use\nin a try\u2013catch block. If you are calling use\ninside a try\u2013catch block, wrap your component in an error boundary, or call the Promise\u2019s catch\nto catch the error and resolve the Promise with another value. See these examples.\nIf you are calling use\noutside a React Component or Hook function, move the use\ncall to a React Component or Hook function.\nfunction MessageComponent({messagePromise}) {\nfunction download() {\n// \u274c the function calling `use` is not a Component or Hook\nconst message = use(messagePromise);\n// ...\nInstead, call use\noutside any component closures, where the function that calls use\nis a Component or Hook.\nfunction MessageComponent({messagePromise}) {\n// \u2705 `use` is being called from a component.\nconst message = use(messagePromise);\n// ..."
  },
  {
    "source": "https://react.dev/reference/react/useActionState",
    "title": "useActionState \u2013 React",
    "text": "useActionState\nuseActionState\nis a Hook that allows you to update state based on the result of a form action.\nconst [state, formAction, isPending] = useActionState(fn, initialState, permalink?);\nReference\nuseActionState(action, initialState, permalink?)\nCall useActionState\nat the top level of your component to create component state that is updated when a form action is invoked. You pass useActionState\nan existing form action function as well as an initial state, and it returns a new action that you use in your form, along with the latest form state and whether the Action is still pending. The latest form state is also passed to the function that you provided.\nimport { useActionState } from \"react\";\nasync function increment(previousState, formData) {\nreturn previousState + 1;\n}\nfunction StatefulForm({}) {\nconst [state, formAction] = useActionState(increment, 0);\nreturn (\n<form>\n{state}\n<button formAction={formAction}>Increment</button>\n</form>\n)\n}\nThe form state is the value returned by the action when the form was last submitted. If the form has not yet been submitted, it is the initial state that you pass.\nIf used with a Server Function, useActionState\nallows the server\u2019s response from submitting the form to be shown even before hydration has completed.\nParameters\nfn\n: The function to be called when the form is submitted or button pressed. When the function is called, it will receive the previous state of the form (initially theinitialState\nthat you pass, subsequently its previous return value) as its initial argument, followed by the arguments that a form action normally receives.initialState\n: The value you want the state to be initially. It can be any serializable value. This argument is ignored after the action is first invoked.- optional\npermalink\n: A string containing the unique page URL that this form modifies. For use on pages with dynamic content (eg: feeds) in conjunction with progressive enhancement: iffn\nis a server function and the form is submitted before the JavaScript bundle loads, the browser will navigate to the specified permalink URL, rather than the current page\u2019s URL. Ensure that the same form component is rendered on the destination page (including the same actionfn\nandpermalink\n) so that React knows how to pass the state through. Once the form has been hydrated, this parameter has no effect.\nReturns\nuseActionState\nreturns an array with the following values:\n- The current state. During the first render, it will match the\ninitialState\nyou have passed. After the action is invoked, it will match the value returned by the action. - A new action that you can pass as the\naction\nprop to yourform\ncomponent orformAction\nprop to anybutton\ncomponent within the form. - The\nisPending\nflag that tells you whether there is a pending Transition.\nCaveats\n- When used with a framework that supports React Server Components,\nuseActionState\nlets you make forms interactive before JavaScript has executed on the client. When used without Server Components, it is equivalent to component local state. - The function passed to\nuseActionState\nreceives an extra argument, the previous or initial state, as its first argument. This makes its signature different than if it were used directly as a form action without usinguseActionState\n.\nUsage\nUsing information returned by a form action\nCall useActionState\nat the top level of your component to access the return value of an action from the last time a form was submitted.\nimport { useActionState } from 'react';\nimport { action } from './actions.js';\nfunction MyComponent() {\nconst [state, formAction] = useActionState(action, null);\n// ...\nreturn (\n<form action={formAction}>\n{/* ... */}\n</form>\n);\n}\nuseActionState\nreturns an array with the following items:\n- The current state of the form, which is initially set to the initial state you provided, and after the form is submitted is set to the return value of the action you provided.\n- A new action that you pass to\n<form>\nas itsaction\nprop. - A pending state that you can utilise whilst your action is processing.\nWhen the form is submitted, the action function that you provided will be called. Its return value will become the new current state of the form.\nThe action that you provide will also receive a new first argument, namely the current state of the form. The first time the form is submitted, this will be the initial state you provided, while with subsequent submissions, it will be the return value from the last time the action was called. The rest of the arguments are the same as if useActionState\nhad not been used.\nfunction action(currentState, formData) {\n// ...\nreturn 'next state';\n}\nExample 1 of 2: Display form errors\nTo display messages such as an error message or toast that\u2019s returned by a Server Function, wrap the action in a call to useActionState\n.\nimport { useActionState, useState } from \"react\"; import { addToCart } from \"./actions.js\"; function AddToCartForm({itemID, itemTitle}) { const [message, formAction, isPending] = useActionState(addToCart, null); return ( <form action={formAction}> <h2>{itemTitle}</h2> <input type=\"hidden\" name=\"itemID\" value={itemID} /> <button type=\"submit\">Add to Cart</button> {isPending ? \"Loading...\" : message} </form> ); } export default function App() { return ( <> <AddToCartForm itemID=\"1\" itemTitle=\"JavaScript: The Definitive Guide\" /> <AddToCartForm itemID=\"2\" itemTitle=\"JavaScript: The Good Parts\" /> </> ) }\nTroubleshooting\nMy action can no longer read the submitted form data\nWhen you wrap an action with useActionState\n, it gets an extra argument as its first argument. The submitted form data is therefore its second argument instead of its first as it would usually be. The new first argument that gets added is the current state of the form.\nfunction action(currentState, formData) {\n// ...\n}"
  },
  {
    "source": "https://react.dev/reference/react/useCallback",
    "title": "useCallback \u2013 React",
    "text": "useCallback\nuseCallback\nis a React Hook that lets you cache a function definition between re-renders.\nconst cachedFn = useCallback(fn, dependencies)\nReference\nuseCallback(fn, dependencies)\nCall useCallback\nat the top level of your component to cache a function definition between re-renders:\nimport { useCallback } from 'react';\nexport default function ProductPage({ productId, referrer, theme }) {\nconst handleSubmit = useCallback((orderDetails) => {\npost('/product/' + productId + '/buy', {\nreferrer,\norderDetails,\n});\n}, [productId, referrer]);\nParameters\n-\nfn\n: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if thedependencies\nhave not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it. -\ndependencies\n: The list of all reactive values referenced inside of thefn\ncode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]\n. React will compare each dependency with its previous value using theObject.is\ncomparison algorithm.\nReturns\nOn the initial render, useCallback\nreturns the fn\nfunction you have passed.\nDuring subsequent renders, it will either return an already stored fn\nfunction from the last render (if the dependencies haven\u2019t changed), or return the fn\nfunction you have passed during this render.\nCaveats\nuseCallback\nis a Hook, so you can only call it at the top level of your component or your own Hooks. You can\u2019t call it inside loops or conditions. If you need that, extract a new component and move the state into it.- React will not throw away the cached function unless there is a specific reason to do that. For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache\u2014for example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should match your expectations if you rely on\nuseCallback\nas a performance optimization. Otherwise, a state variable or a ref may be more appropriate.\nUsage\nSkipping re-rendering of components\nWhen you optimize rendering performance, you will sometimes need to cache the functions that you pass to child components. Let\u2019s first look at the syntax for how to do this, and then see in which cases it\u2019s useful.\nTo cache a function between re-renders of your component, wrap its definition into the useCallback\nHook:\nimport { useCallback } from 'react';\nfunction ProductPage({ productId, referrer, theme }) {\nconst handleSubmit = useCallback((orderDetails) => {\npost('/product/' + productId + '/buy', {\nreferrer,\norderDetails,\n});\n}, [productId, referrer]);\n// ...\nYou need to pass two things to useCallback\n:\n- A function definition that you want to cache between re-renders.\n- A list of dependencies including every value within your component that\u2019s used inside your function.\nOn the initial render, the returned function you\u2019ll get from useCallback\nwill be the function you passed.\nOn the following renders, React will compare the dependencies with the dependencies you passed during the previous render. If none of the dependencies have changed (compared with Object.is\n), useCallback\nwill return the same function as before. Otherwise, useCallback\nwill return the function you passed on this render.\nIn other words, useCallback\ncaches a function between re-renders until its dependencies change.\nLet\u2019s walk through an example to see when this is useful.\nSay you\u2019re passing a handleSubmit\nfunction down from the ProductPage\nto the ShippingForm\ncomponent:\nfunction ProductPage({ productId, referrer, theme }) {\n// ...\nreturn (\n<div className={theme}>\n<ShippingForm onSubmit={handleSubmit} />\n</div>\n);\nYou\u2019ve noticed that toggling the theme\nprop freezes the app for a moment, but if you remove <ShippingForm />\nfrom your JSX, it feels fast. This tells you that it\u2019s worth trying to optimize the ShippingForm\ncomponent.\nBy default, when a component re-renders, React re-renders all of its children recursively. This is why, when ProductPage\nre-renders with a different theme\n, the ShippingForm\ncomponent also re-renders. This is fine for components that don\u2019t require much calculation to re-render. But if you verified a re-render is slow, you can tell ShippingForm\nto skip re-rendering when its props are the same as on last render by wrapping it in memo\n:\nimport { memo } from 'react';\nconst ShippingForm = memo(function ShippingForm({ onSubmit }) {\n// ...\n});\nWith this change, ShippingForm\nwill skip re-rendering if all of its props are the same as on the last render. This is when caching a function becomes important! Let\u2019s say you defined handleSubmit\nwithout useCallback\n:\nfunction ProductPage({ productId, referrer, theme }) {\n// Every time the theme changes, this will be a different function...\nfunction handleSubmit(orderDetails) {\npost('/product/' + productId + '/buy', {\nreferrer,\norderDetails,\n});\n}\nreturn (\n<div className={theme}>\n{/* ... so ShippingForm's props will never be the same, and it will re-render every time */}\n<ShippingForm onSubmit={handleSubmit} />\n</div>\n);\n}\nIn JavaScript, a function () {}\nor () => {}\nalways creates a different function, similar to how the {}\nobject literal always creates a new object. Normally, this wouldn\u2019t be a problem, but it means that ShippingForm\nprops will never be the same, and your memo\noptimization won\u2019t work. This is where useCallback\ncomes in handy:\nfunction ProductPage({ productId, referrer, theme }) {\n// Tell React to cache your function between re-renders...\nconst handleSubmit = useCallback((orderDetails) => {\npost('/product/' + productId + '/buy', {\nreferrer,\norderDetails,\n});\n}, [productId, referrer]); // ...so as long as these dependencies don't change...\nreturn (\n<div className={theme}>\n{/* ...ShippingForm will receive the same props and can skip re-rendering */}\n<ShippingForm onSubmit={handleSubmit} />\n</div>\n);\n}\nBy wrapping handleSubmit\nin useCallback\n, you ensure that it\u2019s the same function between the re-renders (until dependencies change). You don\u2019t have to wrap a function in useCallback\nunless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in memo\n, and this lets it skip re-rendering. There are other reasons you might need useCallback\nwhich are described further on this page.\nDeep Dive\nYou will often see useMemo\nalongside useCallback\n. They are both useful when you\u2019re trying to optimize a child component. They let you memoize (or, in other words, cache) something you\u2019re passing down:\nimport { useMemo, useCallback } from 'react';\nfunction ProductPage({ productId, referrer }) {\nconst product = useData('/product/' + productId);\nconst requirements = useMemo(() => { // Calls your function and caches its result\nreturn computeRequirements(product);\n}, [product]);\nconst handleSubmit = useCallback((orderDetails) => { // Caches your function itself\npost('/product/' + productId + '/buy', {\nreferrer,\norderDetails,\n});\n}, [productId, referrer]);\nreturn (\n<div className={theme}>\n<ShippingForm requirements={requirements} onSubmit={handleSubmit} />\n</div>\n);\n}\nThe difference is in what they\u2019re letting you cache:\nuseMemo\ncaches the result of calling your function. In this example, it caches the result of callingcomputeRequirements(product)\nso that it doesn\u2019t change unlessproduct\nhas changed. This lets you pass therequirements\nobject down without unnecessarily re-renderingShippingForm\n. When necessary, React will call the function you\u2019ve passed during rendering to calculate the result.useCallback\ncaches the function itself. UnlikeuseMemo\n, it does not call the function you provide. Instead, it caches the function you provided so thathandleSubmit\nitself doesn\u2019t change unlessproductId\norreferrer\nhas changed. This lets you pass thehandleSubmit\nfunction down without unnecessarily re-renderingShippingForm\n. Your code won\u2019t run until the user submits the form.\nIf you\u2019re already familiar with useMemo\n, you might find it helpful to think of useCallback\nas this:\n// Simplified implementation (inside React)\nfunction useCallback(fn, dependencies) {\nreturn useMemo(() => fn, dependencies);\n}\nRead more about the difference between useMemo\nand useCallback\n.\nDeep Dive\nIf your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.\nCaching a function with useCallback\nis only valuable in a few cases:\n- You pass it as a prop to a component wrapped in\nmemo\n. You want to skip re-rendering if the value hasn\u2019t changed. Memoization lets your component re-render only if dependencies changed. - The function you\u2019re passing is later used as a dependency of some Hook. For example, another function wrapped in\nuseCallback\ndepends on it, or you depend on this function fromuseEffect.\nThere is no benefit to wrapping a function in useCallback\nin other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside is that code becomes less readable. Also, not all memoization is effective: a single value that\u2019s \u201calways new\u201d is enough to break memoization for an entire component.\nNote that useCallback\ndoes not prevent creating the function. You\u2019re always creating a function (and that\u2019s fine!), but React ignores it and gives you back a cached function if nothing changed.\nIn practice, you can make a lot of memoization unnecessary by following a few principles:\n- When a component visually wraps other components, let it accept JSX as children. Then, if the wrapper component updates its own state, React knows that its children don\u2019t need to re-render.\n- Prefer local state and don\u2019t lift state up any further than necessary. Don\u2019t keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.\n- Keep your rendering logic pure. If re-rendering a component causes a problem or produces some noticeable visual artifact, it\u2019s a bug in your component! Fix the bug instead of adding memoization.\n- Avoid unnecessary Effects that update state. Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.\n- Try to remove unnecessary dependencies from your Effects. For example, instead of memoization, it\u2019s often simpler to move some object or a function inside an Effect or outside the component.\nIf a specific interaction still feels laggy, use the React Developer Tools profiler to see which components benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it\u2019s good to follow them in any case. In long term, we\u2019re researching doing memoization automatically to solve this once and for all.\nExample 1 of 2: Skipping re-rendering with useCallback\nand memo\nIn this example, the ShippingForm\ncomponent is artificially slowed down so that you can see what happens when a React component you\u2019re rendering is genuinely slow. Try incrementing the counter and toggling the theme.\nIncrementing the counter feels slow because it forces the slowed down ShippingForm\nto re-render. That\u2019s expected because the counter has changed, and so you need to reflect the user\u2019s new choice on the screen.\nNext, try toggling the theme. Thanks to useCallback\ntogether with memo\n, it\u2019s fast despite the artificial slowdown! ShippingForm\nskipped re-rendering because the handleSubmit\nfunction has not changed. The handleSubmit\nfunction has not changed because both productId\nand referrer\n(your useCallback\ndependencies) haven\u2019t changed since last render.\nimport { useCallback } from 'react'; import ShippingForm from './ShippingForm.js'; export default function ProductPage({ productId, referrer, theme }) { const handleSubmit = useCallback((orderDetails) => { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); return ( <div className={theme}> <ShippingForm onSubmit={handleSubmit} /> </div> ); } function post(url, data) { // Imagine this sends a request... console.log('POST /' + url); console.log(data); }\nUpdating state from a memoized callback\nSometimes, you might need to update state based on previous state from a memoized callback.\nThis handleAddTodo\nfunction specifies todos\nas a dependency because it computes the next todos from it:\nfunction TodoList() {\nconst [todos, setTodos] = useState([]);\nconst handleAddTodo = useCallback((text) => {\nconst newTodo = { id: nextId++, text };\nsetTodos([...todos, newTodo]);\n}, [todos]);\n// ...\nYou\u2019ll usually want memoized functions to have as few dependencies as possible. When you read some state only to calculate the next state, you can remove that dependency by passing an updater function instead:\nfunction TodoList() {\nconst [todos, setTodos] = useState([]);\nconst handleAddTodo = useCallback((text) => {\nconst newTodo = { id: nextId++, text };\nsetTodos(todos => [...todos, newTodo]);\n}, []); // \u2705 No need for the todos dependency\n// ...\nHere, instead of making todos\na dependency and reading it inside, you pass an instruction about how to update the state (todos => [...todos, newTodo]\n) to React. Read more about updater functions.\nPreventing an Effect from firing too often\nSometimes, you might want to call a function from inside an Effect:\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState('');\nfunction createOptions() {\nreturn {\nserverUrl: 'https://localhost:1234',\nroomId: roomId\n};\n}\nuseEffect(() => {\nconst options = createOptions();\nconst connection = createConnection(options);\nconnection.connect();\n// ...\nThis creates a problem. Every reactive value must be declared as a dependency of your Effect. However, if you declare createOptions\nas a dependency, it will cause your Effect to constantly reconnect to the chat room:\nuseEffect(() => {\nconst options = createOptions();\nconst connection = createConnection(options);\nconnection.connect();\nreturn () => connection.disconnect();\n}, [createOptions]); // \ud83d\udd34 Problem: This dependency changes on every render\n// ...\nTo solve this, you can wrap the function you need to call from an Effect into useCallback\n:\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState('');\nconst createOptions = useCallback(() => {\nreturn {\nserverUrl: 'https://localhost:1234',\nroomId: roomId\n};\n}, [roomId]); // \u2705 Only changes when roomId changes\nuseEffect(() => {\nconst options = createOptions();\nconst connection = createConnection(options);\nconnection.connect();\nreturn () => connection.disconnect();\n}, [createOptions]); // \u2705 Only changes when createOptions changes\n// ...\nThis ensures that the createOptions\nfunction is the same between re-renders if the roomId\nis the same. However, it\u2019s even better to remove the need for a function dependency. Move your function inside the Effect:\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState('');\nuseEffect(() => {\nfunction createOptions() { // \u2705 No need for useCallback or function dependencies!\nreturn {\nserverUrl: 'https://localhost:1234',\nroomId: roomId\n};\n}\nconst options = createOptions();\nconst connection = createConnection(options);\nconnection.connect();\nreturn () => connection.disconnect();\n}, [roomId]); // \u2705 Only changes when roomId changes\n// ...\nNow your code is simpler and doesn\u2019t need useCallback\n. Learn more about removing Effect dependencies.\nOptimizing a custom Hook\nIf you\u2019re writing a custom Hook, it\u2019s recommended to wrap any functions that it returns into useCallback\n:\nfunction useRouter() {\nconst { dispatch } = useContext(RouterStateContext);\nconst navigate = useCallback((url) => {\ndispatch({ type: 'navigate', url });\n}, [dispatch]);\nconst goBack = useCallback(() => {\ndispatch({ type: 'back' });\n}, [dispatch]);\nreturn {\nnavigate,\ngoBack,\n};\n}\nThis ensures that the consumers of your Hook can optimize their own code when needed.\nTroubleshooting\nEvery time my component renders, useCallback\nreturns a different function\nMake sure you\u2019ve specified the dependency array as a second argument!\nIf you forget the dependency array, useCallback\nwill return a new function every time:\nfunction ProductPage({ productId, referrer }) {\nconst handleSubmit = useCallback((orderDetails) => {\npost('/product/' + productId + '/buy', {\nreferrer,\norderDetails,\n});\n}); // \ud83d\udd34 Returns a new function every time: no dependency array\n// ...\nThis is the corrected version passing the dependency array as a second argument:\nfunction ProductPage({ productId, referrer }) {\nconst handleSubmit = useCallback((orderDetails) => {\npost('/product/' + productId + '/buy', {\nreferrer,\norderDetails,\n});\n}, [productId, referrer]); // \u2705 Does not return a new function unnecessarily\n// ...\nIf this doesn\u2019t help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:\nconst handleSubmit = useCallback((orderDetails) => {\n// ..\n}, [productId, referrer]);\nconsole.log([productId, referrer]);\nYou can then right-click on the arrays from different re-renders in the console and select \u201cStore as a global variable\u201d for both of them. Assuming the first one got saved as temp1\nand the second one got saved as temp2\n, you can then use the browser console to check whether each dependency in both arrays is the same:\nObject.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?\nObject.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?\nObject.is(temp1[2], temp2[2]); // ... and so on for every dependency ...\nWhen you find which dependency is breaking memoization, either find a way to remove it, or memoize it as well.\nI need to call useCallback\nfor each list item in a loop, but it\u2019s not allowed\nSuppose the Chart\ncomponent is wrapped in memo\n. You want to skip re-rendering every Chart\nin the list when the ReportList\ncomponent re-renders. However, you can\u2019t call useCallback\nin a loop:\nfunction ReportList({ items }) {\nreturn (\n<article>\n{items.map(item => {\n// \ud83d\udd34 You can't call useCallback in a loop like this:\nconst handleClick = useCallback(() => {\nsendReport(item)\n}, [item]);\nreturn (\n<figure key={item.id}>\n<Chart onClick={handleClick} />\n</figure>\n);\n})}\n</article>\n);\n}\nInstead, extract a component for an individual item, and put useCallback\nthere:\nfunction ReportList({ items }) {\nreturn (\n<article>\n{items.map(item =>\n<Report key={item.id} item={item} />\n)}\n</article>\n);\n}\nfunction Report({ item }) {\n// \u2705 Call useCallback at the top level:\nconst handleClick = useCallback(() => {\nsendReport(item)\n}, [item]);\nreturn (\n<figure>\n<Chart onClick={handleClick} />\n</figure>\n);\n}\nAlternatively, you could remove useCallback\nin the last snippet and instead wrap Report\nitself in memo\n. If the item\nprop does not change, Report\nwill skip re-rendering, so Chart\nwill skip re-rendering too:\nfunction ReportList({ items }) {\n// ...\n}\nconst Report = memo(function Report({ item }) {\nfunction handleClick() {\nsendReport(item);\n}\nreturn (\n<figure>\n<Chart onClick={handleClick} />\n</figure>\n);\n});"
  },
  {
    "source": "https://react.dev/reference/react/useContext",
    "title": "useContext \u2013 React",
    "text": "useContext\nuseContext\nis a React Hook that lets you read and subscribe to context from your component.\nconst value = useContext(SomeContext)\nReference\nuseContext(SomeContext)\nCall useContext\nat the top level of your component to read and subscribe to context.\nimport { useContext } from 'react';\nfunction MyComponent() {\nconst theme = useContext(ThemeContext);\n// ...\nParameters\nSomeContext\n: The context that you\u2019ve previously created withcreateContext\n. The context itself does not hold the information, it only represents the kind of information you can provide or read from components.\nReturns\nuseContext\nreturns the context value for the calling component. It is determined as the value\npassed to the closest SomeContext.Provider\nabove the calling component in the tree. If there is no such provider, then the returned value will be the defaultValue\nyou have passed to createContext\nfor that context. The returned value is always up-to-date. React automatically re-renders components that read some context if it changes.\nCaveats\nuseContext()\ncall in a component is not affected by providers returned from the same component. The corresponding<Context.Provider>\nneeds to be above the component doing theuseContext()\ncall.- React automatically re-renders all the children that use a particular context starting from the provider that receives a different\nvalue\n. The previous and the next values are compared with theObject.is\ncomparison. Skipping re-renders withmemo\ndoes not prevent the children receiving fresh context values. - If your build system produces duplicates modules in the output (which can happen with symlinks), this can break context. Passing something via context only works if\nSomeContext\nthat you use to provide context andSomeContext\nthat you use to read it are exactly the same object, as determined by a===\ncomparison.\nUsage\nPassing data deeply into the tree\nCall useContext\nat the top level of your component to read and subscribe to context.\nimport { useContext } from 'react';\nfunction Button() {\nconst theme = useContext(ThemeContext);\n// ...\nuseContext\nreturns the context value for the context you passed. To determine the context value, React searches the component tree and finds the closest context provider above for that particular context.\nTo pass context to a Button\n, wrap it or one of its parent components into the corresponding context provider:\nfunction MyPage() {\nreturn (\n<ThemeContext.Provider value=\"dark\">\n<Form />\n</ThemeContext.Provider>\n);\n}\nfunction Form() {\n// ... renders buttons inside ...\n}\nIt doesn\u2019t matter how many layers of components there are between the provider and the Button\n. When a Button\nanywhere inside of Form\ncalls useContext(ThemeContext)\n, it will receive \"dark\"\nas the value.\nimport { createContext, useContext } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { return ( <ThemeContext.Provider value=\"dark\"> <Form /> </ThemeContext.Provider> ) } function Form() { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> </Panel> ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> <h1>{title}</h1> {children} </section> ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className}> {children} </button> ); }\nUpdating data passed via context\nOften, you\u2019ll want the context to change over time. To update context, combine it with state. Declare a state variable in the parent component, and pass the current state down as the context value to the provider.\nfunction MyPage() {\nconst [theme, setTheme] = useState('dark');\nreturn (\n<ThemeContext.Provider value={theme}>\n<Form />\n<Button onClick={() => {\nsetTheme('light');\n}}>\nSwitch to light theme\n</Button>\n</ThemeContext.Provider>\n);\n}\nNow any Button\ninside of the provider will receive the current theme\nvalue. If you call setTheme\nto update the theme\nvalue that you pass to the provider, all Button\ncomponents will re-render with the new 'light'\nvalue.\nExample 1 of 5: Updating a value via context\nIn this example, the MyApp\ncomponent holds a state variable which is then passed to the ThemeContext\nprovider. Checking the \u201cDark mode\u201d checkbox updates the state. Changing the provided value re-renders all the components using that context.\nimport { createContext, useContext, useState } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { const [theme, setTheme] = useState('light'); return ( <ThemeContext.Provider value={theme}> <Form /> <label> <input type=\"checkbox\" checked={theme === 'dark'} onChange={(e) => { setTheme(e.target.checked ? 'dark' : 'light') }} /> Use dark mode </label> </ThemeContext.Provider> ) } function Form({ children }) { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> </Panel> ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> <h1>{title}</h1> {children} </section> ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className}> {children} </button> ); }\nNote that value=\"dark\"\npasses the \"dark\"\nstring, but value={theme}\npasses the value of the JavaScript theme\nvariable with JSX curly braces. Curly braces also let you pass context values that aren\u2019t strings.\nSpecifying a fallback default value\nIf React can\u2019t find any providers of that particular context in the parent tree, the context value returned by useContext()\nwill be equal to the default value that you specified when you created that context:\nconst ThemeContext = createContext(null);\nThe default value never changes. If you want to update context, use it with state as described above.\nOften, instead of null\n, there is some more meaningful value you can use as a default, for example:\nconst ThemeContext = createContext('light');\nThis way, if you accidentally render some component without a corresponding provider, it won\u2019t break. This also helps your components work well in a test environment without setting up a lot of providers in the tests.\nIn the example below, the \u201cToggle theme\u201d button is always light because it\u2019s outside any theme context provider and the default context theme value is 'light'\n. Try editing the default theme to be 'dark'\n.\nimport { createContext, useContext, useState } from 'react'; const ThemeContext = createContext('light'); export default function MyApp() { const [theme, setTheme] = useState('light'); return ( <> <ThemeContext.Provider value={theme}> <Form /> </ThemeContext.Provider> <Button onClick={() => { setTheme(theme === 'dark' ? 'light' : 'dark'); }}> Toggle theme </Button> </> ) } function Form({ children }) { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> </Panel> ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> <h1>{title}</h1> {children} </section> ) } function Button({ children, onClick }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className} onClick={onClick}> {children} </button> ); }\nOverriding context for a part of the tree\nYou can override the context for a part of the tree by wrapping that part in a provider with a different value.\n<ThemeContext.Provider value=\"dark\">\n...\n<ThemeContext.Provider value=\"light\">\n<Footer />\n</ThemeContext.Provider>\n...\n</ThemeContext.Provider>\nYou can nest and override providers as many times as you need.\nExample 1 of 2: Overriding a theme\nHere, the button inside the Footer\nreceives a different context value (\"light\"\n) than the buttons outside (\"dark\"\n).\nimport { createContext, useContext } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { return ( <ThemeContext.Provider value=\"dark\"> <Form /> </ThemeContext.Provider> ) } function Form() { return ( <Panel title=\"Welcome\"> <Button>Sign up</Button> <Button>Log in</Button> <ThemeContext.Provider value=\"light\"> <Footer /> </ThemeContext.Provider> </Panel> ); } function Footer() { return ( <footer> <Button>Settings</Button> </footer> ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( <section className={className}> {title && <h1>{title}</h1>} {children} </section> ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( <button className={className}> {children} </button> ); }\nOptimizing re-renders when passing objects and functions\nYou can pass any values via context, including objects and functions.\nfunction MyApp() {\nconst [currentUser, setCurrentUser] = useState(null);\nfunction login(response) {\nstoreCredentials(response.credentials);\nsetCurrentUser(response.user);\n}\nreturn (\n<AuthContext.Provider value={{ currentUser, login }}>\n<Page />\n</AuthContext.Provider>\n);\n}\nHere, the context value is a JavaScript object with two properties, one of which is a function. Whenever MyApp\nre-renders (for example, on a route update), this will be a different object pointing at a different function, so React will also have to re-render all components deep in the tree that call useContext(AuthContext)\n.\nIn smaller apps, this is not a problem. However, there is no need to re-render them if the underlying data, like currentUser\n, has not changed. To help React take advantage of that fact, you may wrap the login\nfunction with useCallback\nand wrap the object creation into useMemo\n. This is a performance optimization:\nimport { useCallback, useMemo } from 'react';\nfunction MyApp() {\nconst [currentUser, setCurrentUser] = useState(null);\nconst login = useCallback((response) => {\nstoreCredentials(response.credentials);\nsetCurrentUser(response.user);\n}, []);\nconst contextValue = useMemo(() => ({\ncurrentUser,\nlogin\n}), [currentUser, login]);\nreturn (\n<AuthContext.Provider value={contextValue}>\n<Page />\n</AuthContext.Provider>\n);\n}\nAs a result of this change, even if MyApp\nneeds to re-render, the components calling useContext(AuthContext)\nwon\u2019t need to re-render unless currentUser\nhas changed.\nRead more about useMemo\nand useCallback\n.\nTroubleshooting\nMy component doesn\u2019t see the value from my provider\nThere are a few common ways that this can happen:\n- You\u2019re rendering\n<SomeContext.Provider>\nin the same component (or below) as where you\u2019re callinguseContext()\n. Move<SomeContext.Provider>\nabove and outside the component callinguseContext()\n. - You may have forgotten to wrap your component with\n<SomeContext.Provider>\n, or you might have put it in a different part of the tree than you thought. Check whether the hierarchy is right using React DevTools. - You might be running into some build issue with your tooling that causes\nSomeContext\nas seen from the providing component andSomeContext\nas seen by the reading component to be two different objects. This can happen if you use symlinks, for example. You can verify this by assigning them to globals likewindow.SomeContext1\nandwindow.SomeContext2\nand then checking whetherwindow.SomeContext1 === window.SomeContext2\nin the console. If they\u2019re not the same, fix that issue on the build tool level.\nI am always getting undefined\nfrom my context although the default value is different\nYou might have a provider without a value\nin the tree:\n// \ud83d\udea9 Doesn't work: no value prop\n<ThemeContext.Provider>\n<Button />\n</ThemeContext.Provider>\nIf you forget to specify value\n, it\u2019s like passing value={undefined}\n.\nYou may have also mistakingly used a different prop name by mistake:\n// \ud83d\udea9 Doesn't work: prop should be called \"value\"\n<ThemeContext.Provider theme={theme}>\n<Button />\n</ThemeContext.Provider>\nIn both of these cases you should see a warning from React in the console. To fix them, call the prop value\n:\n// \u2705 Passing the value prop\n<ThemeContext.Provider value={theme}>\n<Button />\n</ThemeContext.Provider>\nNote that the default value from your createContext(defaultValue)\ncall is only used if there is no matching provider above at all. If there is a <SomeContext.Provider value={undefined}>\ncomponent somewhere in the parent tree, the component calling useContext(SomeContext)\nwill receive undefined\nas the context value."
  },
  {
    "source": "https://react.dev/reference/react/useDebugValue",
    "title": "useDebugValue \u2013 React",
    "text": "useDebugValue\nuseDebugValue\nis a React Hook that lets you add a label to a custom Hook in React DevTools.\nuseDebugValue(value, format?)\nReference\nuseDebugValue(value, format?)\nCall useDebugValue\nat the top level of your custom Hook to display a readable debug value:\nimport { useDebugValue } from 'react';\nfunction useOnlineStatus() {\n// ...\nuseDebugValue(isOnline ? 'Online' : 'Offline');\n// ...\n}\nParameters\nvalue\n: The value you want to display in React DevTools. It can have any type.- optional\nformat\n: A formatting function. When the component is inspected, React DevTools will call the formatting function with thevalue\nas the argument, and then display the returned formatted value (which may have any type). If you don\u2019t specify the formatting function, the originalvalue\nitself will be displayed.\nReturns\nuseDebugValue\ndoes not return anything.\nUsage\nAdding a label to a custom Hook\nCall useDebugValue\nat the top level of your custom Hook to display a readable debug value for React DevTools.\nimport { useDebugValue } from 'react';\nfunction useOnlineStatus() {\n// ...\nuseDebugValue(isOnline ? 'Online' : 'Offline');\n// ...\n}\nThis gives components calling useOnlineStatus\na label like OnlineStatus: \"Online\"\nwhen you inspect them:\nWithout the useDebugValue\ncall, only the underlying data (in this example, true\n) would be displayed.\nimport { useSyncExternalStore, useDebugValue } from 'react'; export function useOnlineStatus() { const isOnline = useSyncExternalStore(subscribe, () => navigator.onLine, () => true); useDebugValue(isOnline ? 'Online' : 'Offline'); return isOnline; } function subscribe(callback) { window.addEventListener('online', callback); window.addEventListener('offline', callback); return () => { window.removeEventListener('online', callback); window.removeEventListener('offline', callback); }; }\nDeferring formatting of a debug value\nYou can also pass a formatting function as the second argument to useDebugValue\n:\nuseDebugValue(date, date => date.toDateString());\nYour formatting function will receive the debug value as a parameter and should return a formatted display value. When your component is inspected, React DevTools will call this function and display its result.\nThis lets you avoid running potentially expensive formatting logic unless the component is actually inspected. For example, if date\nis a Date value, this avoids calling toDateString()\non it for every render."
  },
  {
    "source": "https://react.dev/reference/react/useDeferredValue",
    "title": "useDeferredValue \u2013 React",
    "text": "useDeferredValue\nuseDeferredValue\nis a React Hook that lets you defer updating a part of the UI.\nconst deferredValue = useDeferredValue(value)\nReference\nuseDeferredValue(value, initialValue?)\nCall useDeferredValue\nat the top level of your component to get a deferred version of that value.\nimport { useState, useDeferredValue } from 'react';\nfunction SearchPage() {\nconst [query, setQuery] = useState('');\nconst deferredQuery = useDeferredValue(query);\n// ...\n}\nParameters\nvalue\n: The value you want to defer. It can have any type.- optional\ninitialValue\n: A value to use during the initial render of a component. If this option is omitted,useDeferredValue\nwill not defer during the initial render, because there\u2019s no previous version ofvalue\nthat it can render instead.\nReturns\ncurrentValue\n: During the initial render, the returned deferred value will be theinitialValue\n, or the same as the value you provided. During updates, React will first attempt a re-render with the old value (so it will return the old value), and then try another re-render in the background with the new value (so it will return the updated value).\nCaveats\n-\nWhen an update is inside a Transition,\nuseDeferredValue\nalways returns the newvalue\nand does not spawn a deferred render, since the update is already deferred. -\nThe values you pass to\nuseDeferredValue\nshould either be primitive values (like strings and numbers) or objects created outside of rendering. If you create a new object during rendering and immediately pass it touseDeferredValue\n, it will be different on every render, causing unnecessary background re-renders. -\nWhen\nuseDeferredValue\nreceives a different value (compared withObject.is\n), in addition to the current render (when it still uses the previous value), it schedules a re-render in the background with the new value. The background re-render is interruptible: if there\u2019s another update to thevalue\n, React will restart the background re-render from scratch. For example, if the user is typing into an input faster than a chart receiving its deferred value can re-render, the chart will only re-render after the user stops typing. -\nuseDeferredValue\nis integrated with<Suspense>\n. If the background update caused by a new value suspends the UI, the user will not see the fallback. They will see the old deferred value until the data loads. -\nuseDeferredValue\ndoes not by itself prevent extra network requests. -\nThere is no fixed delay caused by\nuseDeferredValue\nitself. As soon as React finishes the original re-render, React will immediately start working on the background re-render with the new deferred value. Any updates caused by events (like typing) will interrupt the background re-render and get prioritized over it. -\nThe background re-render caused by\nuseDeferredValue\ndoes not fire Effects until it\u2019s committed to the screen. If the background re-render suspends, its Effects will run after the data loads and the UI updates.\nUsage\nShowing stale content while fresh content is loading\nCall useDeferredValue\nat the top level of your component to defer updating some part of your UI.\nimport { useState, useDeferredValue } from 'react';\nfunction SearchPage() {\nconst [query, setQuery] = useState('');\nconst deferredQuery = useDeferredValue(query);\n// ...\n}\nDuring the initial render, the deferred value will be the same as the value you provided.\nDuring updates, the deferred value will \u201clag behind\u201d the latest value. In particular, React will first re-render without updating the deferred value, and then try to re-render with the newly received value in the background.\nLet\u2019s walk through an example to see when this is useful.\nIn this example, the SearchResults\ncomponent suspends while fetching the search results. Try typing \"a\"\n, waiting for the results, and then editing it to \"ab\"\n. The results for \"a\"\nget replaced by the loading fallback.\nimport { Suspense, useState } from 'react'; import SearchResults from './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); return ( <> <label> Search albums: <input value={query} onChange={e => setQuery(e.target.value)} /> </label> <Suspense fallback={<h2>Loading...</h2>}> <SearchResults query={query} /> </Suspense> </> ); }\nA common alternative UI pattern is to defer updating the list of results and to keep showing the previous results until the new results are ready. Call useDeferredValue\nto pass a deferred version of the query down:\nexport default function App() {\nconst [query, setQuery] = useState('');\nconst deferredQuery = useDeferredValue(query);\nreturn (\n<>\n<label>\nSearch albums:\n<input value={query} onChange={e => setQuery(e.target.value)} />\n</label>\n<Suspense fallback={<h2>Loading...</h2>}>\n<SearchResults query={deferredQuery} />\n</Suspense>\n</>\n);\n}\nThe query\nwill update immediately, so the input will display the new value. However, the deferredQuery\nwill keep its previous value until the data has loaded, so SearchResults\nwill show the stale results for a bit.\nEnter \"a\"\nin the example below, wait for the results to load, and then edit the input to \"ab\"\n. Notice how instead of the Suspense fallback, you now see the stale result list until the new results have loaded:\nimport { Suspense, useState, useDeferredValue } from 'react'; import SearchResults from './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); return ( <> <label> Search albums: <input value={query} onChange={e => setQuery(e.target.value)} /> </label> <Suspense fallback={<h2>Loading...</h2>}> <SearchResults query={deferredQuery} /> </Suspense> </> ); }\nDeep Dive\nYou can think of it as happening in two steps:\n-\nFirst, React re-renders with the new\nquery\n(\"ab\"\n) but with the olddeferredQuery\n(still\"a\")\n. ThedeferredQuery\nvalue, which you pass to the result list, is deferred: it \u201clags behind\u201d thequery\nvalue. -\nIn the background, React tries to re-render with both\nquery\nanddeferredQuery\nupdated to\"ab\"\n. If this re-render completes, React will show it on the screen. However, if it suspends (the results for\"ab\"\nhave not loaded yet), React will abandon this rendering attempt, and retry this re-render again after the data has loaded. The user will keep seeing the stale deferred value until the data is ready.\nThe deferred \u201cbackground\u201d rendering is interruptible. For example, if you type into the input again, React will abandon it and restart with the new value. React will always use the latest provided value.\nNote that there is still a network request per each keystroke. What\u2019s being deferred here is displaying results (until they\u2019re ready), not the network requests themselves. Even if the user continues typing, responses for each keystroke get cached, so pressing Backspace is instant and doesn\u2019t fetch again.\nIndicating that the content is stale\nIn the example above, there is no indication that the result list for the latest query is still loading. This can be confusing to the user if the new results take a while to load. To make it more obvious to the user that the result list does not match the latest query, you can add a visual indication when the stale result list is displayed:\n<div style={{\nopacity: query !== deferredQuery ? 0.5 : 1,\n}}>\n<SearchResults query={deferredQuery} />\n</div>\nWith this change, as soon as you start typing, the stale result list gets slightly dimmed until the new result list loads. You can also add a CSS transition to delay dimming so that it feels gradual, like in the example below:\nimport { Suspense, useState, useDeferredValue } from 'react'; import SearchResults from './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); const isStale = query !== deferredQuery; return ( <> <label> Search albums: <input value={query} onChange={e => setQuery(e.target.value)} /> </label> <Suspense fallback={<h2>Loading...</h2>}> <div style={{ opacity: isStale ? 0.5 : 1, transition: isStale ? 'opacity 0.2s 0.2s linear' : 'opacity 0s 0s linear' }}> <SearchResults query={deferredQuery} /> </div> </Suspense> </> ); }\nDeferring re-rendering for a part of the UI\nYou can also apply useDeferredValue\nas a performance optimization. It is useful when a part of your UI is slow to re-render, there\u2019s no easy way to optimize it, and you want to prevent it from blocking the rest of the UI.\nImagine you have a text field and a component (like a chart or a long list) that re-renders on every keystroke:\nfunction App() {\nconst [text, setText] = useState('');\nreturn (\n<>\n<input value={text} onChange={e => setText(e.target.value)} />\n<SlowList text={text} />\n</>\n);\n}\nFirst, optimize SlowList\nto skip re-rendering when its props are the same. To do this, wrap it in memo\n:\nconst SlowList = memo(function SlowList({ text }) {\n// ...\n});\nHowever, this only helps if the SlowList\nprops are the same as during the previous render. The problem you\u2019re facing now is that it\u2019s slow when they\u2019re different, and when you actually need to show different visual output.\nConcretely, the main performance problem is that whenever you type into the input, the SlowList\nreceives new props, and re-rendering its entire tree makes the typing feel janky. In this case, useDeferredValue\nlets you prioritize updating the input (which must be fast) over updating the result list (which is allowed to be slower):\nfunction App() {\nconst [text, setText] = useState('');\nconst deferredText = useDeferredValue(text);\nreturn (\n<>\n<input value={text} onChange={e => setText(e.target.value)} />\n<SlowList text={deferredText} />\n</>\n);\n}\nThis does not make re-rendering of the SlowList\nfaster. However, it tells React that re-rendering the list can be deprioritized so that it doesn\u2019t block the keystrokes. The list will \u201clag behind\u201d the input and then \u201ccatch up\u201d. Like before, React will attempt to update the list as soon as possible, but will not block the user from typing.\nExample 1 of 2: Deferred re-rendering of the list\nIn this example, each item in the SlowList\ncomponent is artificially slowed down so that you can see how useDeferredValue\nlets you keep the input responsive. Type into the input and notice that typing feels snappy while the list \u201clags behind\u201d it.\nimport { useState, useDeferredValue } from 'react'; import SlowList from './SlowList.js'; export default function App() { const [text, setText] = useState(''); const deferredText = useDeferredValue(text); return ( <> <input value={text} onChange={e => setText(e.target.value)} /> <SlowList text={deferredText} /> </> ); }\nDeep Dive\nThere are two common optimization techniques you might have used before in this scenario:\n- Debouncing means you\u2019d wait for the user to stop typing (e.g. for a second) before updating the list.\n- Throttling means you\u2019d update the list every once in a while (e.g. at most once a second).\nWhile these techniques are helpful in some cases, useDeferredValue\nis better suited to optimizing rendering because it is deeply integrated with React itself and adapts to the user\u2019s device.\nUnlike debouncing or throttling, it doesn\u2019t require choosing any fixed delay. If the user\u2019s device is fast (e.g. powerful laptop), the deferred re-render would happen almost immediately and wouldn\u2019t be noticeable. If the user\u2019s device is slow, the list would \u201clag behind\u201d the input proportionally to how slow the device is.\nAlso, unlike with debouncing or throttling, deferred re-renders done by useDeferredValue\nare interruptible by default. This means that if React is in the middle of re-rendering a large list, but the user makes another keystroke, React will abandon that re-render, handle the keystroke, and then start rendering in the background again. By contrast, debouncing and throttling still produce a janky experience because they\u2019re blocking: they merely postpone the moment when rendering blocks the keystroke.\nIf the work you\u2019re optimizing doesn\u2019t happen during rendering, debouncing and throttling are still useful. For example, they can let you fire fewer network requests. You can also use these techniques together."
  },
  {
    "source": "https://react.dev/reference/react/useEffect",
    "title": "useEffect \u2013 React",
    "text": "useEffect\nuseEffect\nis a React Hook that lets you synchronize a component with an external system.\nuseEffect(setup, dependencies?)\n- Reference\n- Usage\n- Connecting to an external system\n- Wrapping Effects in custom Hooks\n- Controlling a non-React widget\n- Fetching data with Effects\n- Specifying reactive dependencies\n- Updating state based on previous state from an Effect\n- Removing unnecessary object dependencies\n- Removing unnecessary function dependencies\n- Reading the latest props and state from an Effect\n- Displaying different content on the server and the client\n- Troubleshooting\nReference\nuseEffect(setup, dependencies?)\nCall useEffect\nat the top level of your component to declare an Effect:\nimport { useEffect } from 'react';\nimport { createConnection } from './chat.js';\nfunction ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\nuseEffect(() => {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () => {\nconnection.disconnect();\n};\n}, [serverUrl, roomId]);\n// ...\n}\nParameters\n-\nsetup\n: The function with your Effect\u2019s logic. Your setup function may also optionally return a cleanup function. When your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. After your component is removed from the DOM, React will run your cleanup function. -\noptional\ndependencies\n: The list of all reactive values referenced inside of thesetup\ncode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]\n. React will compare each dependency with its previous value using theObject.is\ncomparison. If you omit this argument, your Effect will re-run after every re-render of the component. See the difference between passing an array of dependencies, an empty array, and no dependencies at all.\nReturns\nuseEffect\nreturns undefined\n.\nCaveats\n-\nuseEffect\nis a Hook, so you can only call it at the top level of your component or your own Hooks. You can\u2019t call it inside loops or conditions. If you need that, extract a new component and move the state into it. -\nIf you\u2019re not trying to synchronize with some external system, you probably don\u2019t need an Effect.\n-\nWhen Strict Mode is on, React will run one extra development-only setup+cleanup cycle before the first real setup. This is a stress-test that ensures that your cleanup logic \u201cmirrors\u201d your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function.\n-\nIf some of your dependencies are objects or functions defined inside the component, there is a risk that they will cause the Effect to re-run more often than needed. To fix this, remove unnecessary object and function dependencies. You can also extract state updates and non-reactive logic outside of your Effect.\n-\nIf your Effect wasn\u2019t caused by an interaction (like a click), React will generally let the browser paint the updated screen first before running your Effect. If your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), replace\nuseEffect\nwithuseLayoutEffect\n. -\nIf your Effect is caused by an interaction (like a click), React may run your Effect before the browser paints the updated screen. This ensures that the result of the Effect can be observed by the event system. Usually, this works as expected. However, if you must defer the work until after paint, such as an\nalert()\n, you can usesetTimeout\n. See reactwg/react-18/128 for more information. -\nEven if your Effect was caused by an interaction (like a click), React may allow the browser to repaint the screen before processing the state updates inside your Effect. Usually, this works as expected. However, if you must block the browser from repainting the screen, you need to replace\nuseEffect\nwithuseLayoutEffect\n. -\nEffects only run on the client. They don\u2019t run during server rendering.\nUsage\nConnecting to an external system\nSome components need to stay connected to the network, some browser API, or a third-party library, while they are displayed on the page. These systems aren\u2019t controlled by React, so they are called external.\nTo connect your component to some external system, call useEffect\nat the top level of your component:\nimport { useEffect } from 'react';\nimport { createConnection } from './chat.js';\nfunction ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\nuseEffect(() => {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () => {\nconnection.disconnect();\n};\n}, [serverUrl, roomId]);\n// ...\n}\nYou need to pass two arguments to useEffect\n:\n- A setup function with setup code that connects to that system.\n- It should return a cleanup function with cleanup code that disconnects from that system.\n- A list of dependencies including every value from your component used inside of those functions.\nReact calls your setup and cleanup functions whenever it\u2019s necessary, which may happen multiple times:\n- Your setup code runs when your component is added to the page (mounts).\n- After every re-render of your component where the dependencies have changed:\n- First, your cleanup code runs with the old props and state.\n- Then, your setup code runs with the new props and state.\n- Your cleanup code runs one final time after your component is removed from the page (unmounts).\nLet\u2019s illustrate this sequence for the example above.\nWhen the ChatRoom\ncomponent above gets added to the page, it will connect to the chat room with the initial serverUrl\nand roomId\n. If either serverUrl\nor roomId\nchange as a result of a re-render (say, if the user picks a different chat room in a dropdown), your Effect will disconnect from the previous room, and connect to the next one. When the ChatRoom\ncomponent is removed from the page, your Effect will disconnect one last time.\nTo help you find bugs, in development React runs setup and cleanup one extra time before the setup. This is a stress-test that verifies your Effect\u2019s logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn\u2019t be able to distinguish between the setup being called once (as in production) and a setup \u2192 cleanup \u2192 setup sequence (as in development). See common solutions.\nTry to write every Effect as an independent process and think about a single setup/cleanup cycle at a time. It shouldn\u2019t matter whether your component is mounting, updating, or unmounting. When your cleanup logic correctly \u201cmirrors\u201d the setup logic, your Effect is resilient to running setup and cleanup as often as needed.\nExample 1 of 5: Connecting to a chat server\nIn this example, the ChatRoom\ncomponent uses an Effect to stay connected to an external system defined in chat.js\n. Press \u201cOpen chat\u201d to make the ChatRoom\ncomponent appear. This sandbox runs in development mode, so there is an extra connect-and-disconnect cycle, as explained here. Try changing the roomId\nand serverUrl\nusing the dropdown and the input, and see how the Effect re-connects to the chat. Press \u201cClose chat\u201d to see the Effect disconnect one last time.\nimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => { connection.disconnect(); }; }, [roomId, serverUrl]); return ( <> <label> Server URL:{' '} <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} /> </label> <h1>Welcome to the {roomId} room!</h1> </> ); } export default function App() { const [roomId, setRoomId] = useState('general'); const [show, setShow] = useState(false); return ( <> <label> Choose the chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> </label> <button onClick={() => setShow(!show)}> {show ? 'Close chat' : 'Open chat'} </button> {show && <hr />} {show && <ChatRoom roomId={roomId} />} </> ); }\nWrapping Effects in custom Hooks\nEffects are an \u201cescape hatch\u201d: you use them when you need to \u201cstep outside React\u201d and when there is no better built-in solution for your use case. If you find yourself often needing to manually write Effects, it\u2019s usually a sign that you need to extract some custom Hooks for common behaviors your components rely on.\nFor example, this useChatRoom\ncustom Hook \u201chides\u201d the logic of your Effect behind a more declarative API:\nfunction useChatRoom({ serverUrl, roomId }) {\nuseEffect(() => {\nconst options = {\nserverUrl: serverUrl,\nroomId: roomId\n};\nconst connection = createConnection(options);\nconnection.connect();\nreturn () => connection.disconnect();\n}, [roomId, serverUrl]);\n}\nThen you can use it from any component like this:\nfunction ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\nuseChatRoom({\nroomId: roomId,\nserverUrl: serverUrl\n});\n// ...\nThere are also many excellent custom Hooks for every purpose available in the React ecosystem.\nExample 1 of 3: Custom useChatRoom\nHook\nThis example is identical to one of the earlier examples, but the logic is extracted to a custom Hook.\nimport { useState } from 'react'; import { useChatRoom } from './useChatRoom.js'; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useChatRoom({ roomId: roomId, serverUrl: serverUrl }); return ( <> <label> Server URL:{' '} <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} /> </label> <h1>Welcome to the {roomId} room!</h1> </> ); } export default function App() { const [roomId, setRoomId] = useState('general'); const [show, setShow] = useState(false); return ( <> <label> Choose the chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> </label> <button onClick={() => setShow(!show)}> {show ? 'Close chat' : 'Open chat'} </button> {show && <hr />} {show && <ChatRoom roomId={roomId} />} </> ); }\nControlling a non-React widget\nSometimes, you want to keep an external system synchronized to some prop or state of your component.\nFor example, if you have a third-party map widget or a video player component written without React, you can use an Effect to call methods on it that make its state match the current state of your React component. This Effect creates an instance of a MapWidget\nclass defined in map-widget.js\n. When you change the zoomLevel\nprop of the Map\ncomponent, the Effect calls the setZoom()\non the class instance to keep it synchronized:\nimport { useRef, useEffect } from 'react'; import { MapWidget } from './map-widget.js'; export default function Map({ zoomLevel }) { const containerRef = useRef(null); const mapRef = useRef(null); useEffect(() => { if (mapRef.current === null) { mapRef.current = new MapWidget(containerRef.current); } const map = mapRef.current; map.setZoom(zoomLevel); }, [zoomLevel]); return ( <div style={{ width: 200, height: 200 }} ref={containerRef} /> ); }\nIn this example, a cleanup function is not needed because the MapWidget\nclass manages only the DOM node that was passed to it. After the Map\nReact component is removed from the tree, both the DOM node and the MapWidget\nclass instance will be automatically garbage-collected by the browser JavaScript engine.\nFetching data with Effects\nYou can use an Effect to fetch data for your component. Note that if you use a framework, using your framework\u2019s data fetching mechanism will be a lot more efficient than writing Effects manually.\nIf you want to fetch data from an Effect manually, your code might look like this:\nimport { useState, useEffect } from 'react';\nimport { fetchBio } from './api.js';\nexport default function Page() {\nconst [person, setPerson] = useState('Alice');\nconst [bio, setBio] = useState(null);\nuseEffect(() => {\nlet ignore = false;\nsetBio(null);\nfetchBio(person).then(result => {\nif (!ignore) {\nsetBio(result);\n}\n});\nreturn () => {\nignore = true;\n};\n}, [person]);\n// ...\nNote the ignore\nvariable which is initialized to false\n, and is set to true\nduring cleanup. This ensures your code doesn\u2019t suffer from \u201crace conditions\u201d: network responses may arrive in a different order than you sent them.\nimport { useState, useEffect } from 'react'; import { fetchBio } from './api.js'; export default function Page() { const [person, setPerson] = useState('Alice'); const [bio, setBio] = useState(null); useEffect(() => { let ignore = false; setBio(null); fetchBio(person).then(result => { if (!ignore) { setBio(result); } }); return () => { ignore = true; } }, [person]); return ( <> <select value={person} onChange={e => { setPerson(e.target.value); }}> <option value=\"Alice\">Alice</option> <option value=\"Bob\">Bob</option> <option value=\"Taylor\">Taylor</option> </select> <hr /> <p><i>{bio ?? 'Loading...'}</i></p> </> ); }\nYou can also rewrite using the async\n/ await\nsyntax, but you still need to provide a cleanup function:\nimport { useState, useEffect } from 'react'; import { fetchBio } from './api.js'; export default function Page() { const [person, setPerson] = useState('Alice'); const [bio, setBio] = useState(null); useEffect(() => { async function startFetching() { setBio(null); const result = await fetchBio(person); if (!ignore) { setBio(result); } } let ignore = false; startFetching(); return () => { ignore = true; } }, [person]); return ( <> <select value={person} onChange={e => { setPerson(e.target.value); }}> <option value=\"Alice\">Alice</option> <option value=\"Bob\">Bob</option> <option value=\"Taylor\">Taylor</option> </select> <hr /> <p><i>{bio ?? 'Loading...'}</i></p> </> ); }\nWriting data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. It\u2019s easier to use a custom Hook\u2014either your own or maintained by the community.\nDeep Dive\nWriting fetch\ncalls inside Effects is a popular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:\n- Effects don\u2019t run on the server. This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.\n- Fetching directly in Effects makes it easy to create \u201cnetwork waterfalls\u201d. You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.\n- Fetching directly in Effects usually means you don\u2019t preload or cache data. For example, if the component unmounts and then mounts again, it would have to fetch the data again.\n- It\u2019s not very ergonomic. There\u2019s quite a bit of boilerplate code involved when writing\nfetch\ncalls in a way that doesn\u2019t suffer from bugs like race conditions.\nThis list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:\n- If you use a framework, use its built-in data fetching mechanism. Modern React frameworks have integrated data fetching mechanisms that are efficient and don\u2019t suffer from the above pitfalls.\n- Otherwise, consider using or building a client-side cache. Popular open source solutions include React Query, useSWR, and React Router 6.4+. You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes).\nYou can continue fetching data directly in Effects if neither of these approaches suit you.\nSpecifying reactive dependencies\nNotice that you can\u2019t \u201cchoose\u201d the dependencies of your Effect. Every reactive value used by your Effect\u2019s code must be declared as a dependency. Your Effect\u2019s dependency list is determined by the surrounding code:\nfunction ChatRoom({ roomId }) { // This is a reactive value\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234'); // This is a reactive value too\nuseEffect(() => {\nconst connection = createConnection(serverUrl, roomId); // This Effect reads these reactive values\nconnection.connect();\nreturn () => connection.disconnect();\n}, [serverUrl, roomId]); // \u2705 So you must specify them as dependencies of your Effect\n// ...\n}\nIf either serverUrl\nor roomId\nchange, your Effect will reconnect to the chat using the new values.\nReactive values include props and all variables and functions declared directly inside of your component. Since roomId\nand serverUrl\nare reactive values, you can\u2019t remove them from the dependencies. If you try to omit them and your linter is correctly configured for React, the linter will flag this as a mistake you need to fix:\nfunction ChatRoom({ roomId }) {\nconst [serverUrl, setServerUrl] = useState('https://localhost:1234');\nuseEffect(() => {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () => connection.disconnect();\n}, []); // \ud83d\udd34 React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl'\n// ...\n}\nTo remove a dependency, you need to \u201cprove\u201d to the linter that it doesn\u2019t need to be a dependency. For example, you can move serverUrl\nout of your component to prove that it\u2019s not reactive and won\u2019t change on re-renders:\nconst serverUrl = 'https://localhost:1234'; // Not a reactive value anymore\nfunction ChatRoom({ roomId }) {\nuseEffect(() => {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () => connection.disconnect();\n}, [roomId]); // \u2705 All dependencies declared\n// ...\n}\nNow that serverUrl\nis not a reactive value (and can\u2019t change on a re-render), it doesn\u2019t need to be a dependency. If your Effect\u2019s code doesn\u2019t use any reactive values, its dependency list should be empty ([]\n):\nconst serverUrl = 'https://localhost:1234'; // Not a reactive value anymore\nconst roomId = 'music'; // Not a reactive value anymore\nfunction ChatRoom() {\nuseEffect(() => {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () => connection.disconnect();\n}, []); // \u2705 All dependencies declared\n// ...\n}\nAn Effect with empty dependencies doesn\u2019t re-run when any of your component\u2019s props or state change.\nExample 1 of 3: Passing a dependency array\nIf you specify the dependencies, your Effect runs after the initial render and after re-renders with changed dependencies.\nuseEffect(() => {\n// ...\n}, [a, b]); // Runs again if a or b are different\nIn the below example, serverUrl\nand roomId\nare reactive values, so they both must be specified as dependencies. As a result, selecting a different room in the dropdown or editing the server URL input causes the chat to re-connect. However, since message\nisn\u2019t used in the Effect (and so it isn\u2019t a dependency), editing the message doesn\u2019t re-connect to the chat.\nimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); const [message, setMessage] = useState(''); useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.connect(); return () => { connection.disconnect(); }; }, [serverUrl, roomId]); return ( <> <label> Server URL:{' '} <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} /> </label> <h1>Welcome to the {roomId} room!</h1> <label> Your message:{' '} <input value={message} onChange={e => setMessage(e.target.value)} /> </label> </> ); } export default function App() { const [show, setShow] = useState(false); const [roomId, setRoomId] = useState('general'); return ( <> <label> Choose the chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> <button onClick={() => setShow(!show)}> {show ? 'Close chat' : 'Open chat'} </button> </label> {show && <hr />} {show && <ChatRoom roomId={roomId}/>} </> ); }\nUpdating state based on previous state from an Effect\nWhen you want to update state based on previous state from an Effect, you might run into a problem:\nfunction Counter() {\nconst [count, setCount] = useState(0);\nuseEffect(() => {\nconst intervalId = setInterval(() => {\nsetCount(count + 1); // You want to increment the counter every second...\n}, 1000)\nreturn () => clearInterval(intervalId);\n}, [count]); // \ud83d\udea9 ... but specifying `count` as a dependency always resets the interval.\n// ...\n}\nSince count\nis a reactive value, it must be specified in the list of dependencies. However, that causes the Effect to cleanup and setup again every time the count\nchanges. This is not ideal.\nTo fix this, pass the c => c + 1\nstate updater to setCount\n:\nimport { useState, useEffect } from 'react'; export default function Counter() { const [count, setCount] = useState(0); useEffect(() => { const intervalId = setInterval(() => { setCount(c => c + 1); // \u2705 Pass a state updater }, 1000); return () => clearInterval(intervalId); }, []); // \u2705 Now count is not a dependency return <h1>{count}</h1>; }\nNow that you\u2019re passing c => c + 1\ninstead of count + 1\n, your Effect no longer needs to depend on count\n. As a result of this fix, it won\u2019t need to cleanup and setup the interval again every time the count\nchanges.\nRemoving unnecessary object dependencies\nIf your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the options\nobject is different for every render:\nconst serverUrl = 'https://localhost:1234';\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState('');\nconst options = { // \ud83d\udea9 This object is created from scratch on every re-render\nserverUrl: serverUrl,\nroomId: roomId\n};\nuseEffect(() => {\nconst connection = createConnection(options); // It's used inside the Effect\nconnection.connect();\nreturn () => connection.disconnect();\n}, [options]); // \ud83d\udea9 As a result, these dependencies are always different on a re-render\n// ...\nAvoid using an object created during rendering as a dependency. Instead, create the object inside the Effect:\nimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() => { const options = { serverUrl: serverUrl, roomId: roomId }; const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [roomId]); return ( <> <h1>Welcome to the {roomId} room!</h1> <input value={message} onChange={e => setMessage(e.target.value)} /> </> ); } export default function App() { const [roomId, setRoomId] = useState('general'); return ( <> <label> Choose the chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> </label> <hr /> <ChatRoom roomId={roomId} /> </> ); }\nNow that you create the options\nobject inside the Effect, the Effect itself only depends on the roomId\nstring.\nWith this fix, typing into the input doesn\u2019t reconnect the chat. Unlike an object which gets re-created, a string like roomId\ndoesn\u2019t change unless you set it to another value. Read more about removing dependencies.\nRemoving unnecessary function dependencies\nIf your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the createOptions\nfunction is different for every render:\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState('');\nfunction createOptions() { // \ud83d\udea9 This function is created from scratch on every re-render\nreturn {\nserverUrl: serverUrl,\nroomId: roomId\n};\n}\nuseEffect(() => {\nconst options = createOptions(); // It's used inside the Effect\nconst connection = createConnection();\nconnection.connect();\nreturn () => connection.disconnect();\n}, [createOptions]); // \ud83d\udea9 As a result, these dependencies are always different on a re-render\n// ...\nBy itself, creating a function from scratch on every re-render is not a problem. You don\u2019t need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render.\nAvoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:\nimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() => { function createOptions() { return { serverUrl: serverUrl, roomId: roomId }; } const options = createOptions(); const connection = createConnection(options); connection.connect(); return () => connection.disconnect(); }, [roomId]); return ( <> <h1>Welcome to the {roomId} room!</h1> <input value={message} onChange={e => setMessage(e.target.value)} /> </> ); } export default function App() { const [roomId, setRoomId] = useState('general'); return ( <> <label> Choose the chat room:{' '} <select value={roomId} onChange={e => setRoomId(e.target.value)} > <option value=\"general\">general</option> <option value=\"travel\">travel</option> <option value=\"music\">music</option> </select> </label> <hr /> <ChatRoom roomId={roomId} /> </> ); }\nNow that you define the createOptions\nfunction inside the Effect, the Effect itself only depends on the roomId\nstring. With this fix, typing into the input doesn\u2019t reconnect the chat. Unlike a function which gets re-created, a string like roomId\ndoesn\u2019t change unless you set it to another value. Read more about removing dependencies.\nReading the latest props and state from an Effect\nBy default, when you read a reactive value from an Effect, you have to add it as a dependency. This ensures that your Effect \u201creacts\u201d to every change of that value. For most dependencies, that\u2019s the behavior you want.\nHowever, sometimes you\u2019ll want to read the latest props and state from an Effect without \u201creacting\u201d to them. For example, imagine you want to log the number of the items in the shopping cart for every page visit:\nfunction Page({ url, shoppingCart }) {\nuseEffect(() => {\nlogVisit(url, shoppingCart.length);\n}, [url, shoppingCart]); // \u2705 All dependencies declared\n// ...\n}\nWhat if you want to log a new page visit after every url\nchange, but not if only the shoppingCart\nchanges? You can\u2019t exclude shoppingCart\nfrom dependencies without breaking the reactivity rules. However, you can express that you don\u2019t want a piece of code to \u201creact\u201d to changes even though it is called from inside an Effect. Declare an Effect Event with the useEffectEvent\nHook, and move the code reading shoppingCart\ninside of it:\nfunction Page({ url, shoppingCart }) {\nconst onVisit = useEffectEvent(visitedUrl => {\nlogVisit(visitedUrl, shoppingCart.length)\n});\nuseEffect(() => {\nonVisit(url);\n}, [url]); // \u2705 All dependencies declared\n// ...\n}\nEffect Events are not reactive and must always be omitted from dependencies of your Effect. This is what lets you put non-reactive code (where you can read the latest value of some props and state) inside of them. By reading shoppingCart\ninside of onVisit\n, you ensure that shoppingCart\nwon\u2019t re-run your Effect.\nRead more about how Effect Events let you separate reactive and non-reactive code.\nDisplaying different content on the server and the client\nIf your app uses server rendering (either directly or via a framework), your component will render in two different environments. On the server, it will render to produce the initial HTML. On the client, React will run the rendering code again so that it can attach your event handlers to that HTML. This is why, for hydration to work, your initial render output must be identical on the client and the server.\nIn rare cases, you might need to display different content on the client. For example, if your app reads some data from localStorage\n, it can\u2019t possibly do that on the server. Here is how you could implement this:\nfunction MyComponent() {\nconst [didMount, setDidMount] = useState(false);\nuseEffect(() => {\nsetDidMount(true);\n}, []);\nif (didMount) {\n// ... return client-only JSX ...\n} else {\n// ... return initial JSX ...\n}\n}\nWhile the app is loading, the user will see the initial render output. Then, when it\u2019s loaded and hydrated, your Effect will run and set didMount\nto true\n, triggering a re-render. This will switch to the client-only render output. Effects don\u2019t run on the server, so this is why didMount\nwas false\nduring the initial server render.\nUse this pattern sparingly. Keep in mind that users with a slow connection will see the initial content for quite a bit of time\u2014potentially, many seconds\u2014so you don\u2019t want to make jarring changes to your component\u2019s appearance. In many cases, you can avoid the need for this by conditionally showing different things with CSS.\nTroubleshooting\nMy Effect runs twice when the component mounts\nWhen Strict Mode is on, in development, React runs setup and cleanup one extra time before the actual setup.\nThis is a stress-test that verifies your Effect\u2019s logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn\u2019t be able to distinguish between the setup being called once (as in production) and a setup \u2192 cleanup \u2192 setup sequence (as in development).\nRead more about how this helps find bugs and how to fix your logic.\nMy Effect runs after every re-render\nFirst, check that you haven\u2019t forgotten to specify the dependency array:\nuseEffect(() => {\n// ...\n}); // \ud83d\udea9 No dependency array: re-runs after every render!\nIf you\u2019ve specified the dependency array but your Effect still re-runs in a loop, it\u2019s because one of your dependencies is different on every re-render.\nYou can debug this problem by manually logging your dependencies to the console:\nuseEffect(() => {\n// ..\n}, [serverUrl, roomId]);\nconsole.log([serverUrl, roomId]);\nYou can then right-click on the arrays from different re-renders in the console and select \u201cStore as a global variable\u201d for both of them. Assuming the first one got saved as temp1\nand the second one got saved as temp2\n, you can then use the browser console to check whether each dependency in both arrays is the same:\nObject.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?\nObject.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?\nObject.is(temp1[2], temp2[2]); // ... and so on for every dependency ...\nWhen you find the dependency that is different on every re-render, you can usually fix it in one of these ways:\n- Updating state based on previous state from an Effect\n- Removing unnecessary object dependencies\n- Removing unnecessary function dependencies\n- Reading the latest props and state from an Effect\nAs a last resort (if these methods didn\u2019t help), wrap its creation with useMemo\nor useCallback\n(for functions).\nMy Effect keeps re-running in an infinite cycle\nIf your Effect runs in an infinite cycle, these two things must be true:\n- Your Effect is updating some state.\n- That state leads to a re-render, which causes the Effect\u2019s dependencies to change.\nBefore you start fixing the problem, ask yourself whether your Effect is connecting to some external system (like DOM, network, a third-party widget, and so on). Why does your Effect need to set state? Does it synchronize with that external system? Or are you trying to manage your application\u2019s data flow with it?\nIf there is no external system, consider whether removing the Effect altogether would simplify your logic.\nIf you\u2019re genuinely synchronizing with some external system, think about why and under what conditions your Effect should update the state. Has something changed that affects your component\u2019s visual output? If you need to keep track of some data that isn\u2019t used by rendering, a ref (which doesn\u2019t trigger re-renders) might be more appropriate. Verify your Effect doesn\u2019t update the state (and trigger re-renders) more than needed.\nFinally, if your Effect is updating the state at the right time, but there is still a loop, it\u2019s because that state update leads to one of the Effect\u2019s dependencies changing. Read how to debug dependency changes.\nMy cleanup logic runs even though my component didn\u2019t unmount\nThe cleanup function runs not only during unmount, but before every re-render with changed dependencies. Additionally, in development, React runs setup+cleanup one extra time immediately after component mounts.\nIf you have cleanup code without corresponding setup code, it\u2019s usually a code smell:\nuseEffect(() => {\n// \ud83d\udd34 Avoid: Cleanup logic without corresponding setup logic\nreturn () => {\ndoSomething();\n};\n}, []);\nYour cleanup logic should be \u201csymmetrical\u201d to the setup logic, and should stop or undo whatever setup did:\nuseEffect(() => {\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () => {\nconnection.disconnect();\n};\n}, [serverUrl, roomId]);\nLearn how the Effect lifecycle is different from the component\u2019s lifecycle.\nMy Effect does something visual, and I see a flicker before it runs\nIf your Effect must block the browser from painting the screen, replace useEffect\nwith useLayoutEffect\n. Note that this shouldn\u2019t be needed for the vast majority of Effects. You\u2019ll only need this if it\u2019s crucial to run your Effect before the browser paint: for example, to measure and position a tooltip before the user sees it."
  },
  {
    "source": "https://react.dev/reference/react/useId",
    "title": "useId \u2013 React",
    "text": "useId\nuseId\nis a React Hook for generating unique IDs that can be passed to accessibility attributes.\nconst id = useId()\nReference\nuseId()\nCall useId\nat the top level of your component to generate a unique ID:\nimport { useId } from 'react';\nfunction PasswordField() {\nconst passwordHintId = useId();\n// ...\nParameters\nuseId\ndoes not take any parameters.\nReturns\nuseId\nreturns a unique ID string associated with this particular useId\ncall in this particular component.\nCaveats\n-\nuseId\nis a Hook, so you can only call it at the top level of your component or your own Hooks. You can\u2019t call it inside loops or conditions. If you need that, extract a new component and move the state into it. -\nuseId\nshould not be used to generate keys in a list. Keys should be generated from your data.\nUsage\nGenerating unique IDs for accessibility attributes\nCall useId\nat the top level of your component to generate a unique ID:\nimport { useId } from 'react';\nfunction PasswordField() {\nconst passwordHintId = useId();\n// ...\nYou can then pass the generated ID to different attributes:\n<>\n<input type=\"password\" aria-describedby={passwordHintId} />\n<p id={passwordHintId}>\n</>\nLet\u2019s walk through an example to see when this is useful.\nHTML accessibility attributes like aria-describedby\nlet you specify that two tags are related to each other. For example, you can specify that an element (like an input) is described by another element (like a paragraph).\nIn regular HTML, you would write it like this:\n<label>\nPassword:\n<input\ntype=\"password\"\naria-describedby=\"password-hint\"\n/>\n</label>\n<p id=\"password-hint\">\nThe password should contain at least 18 characters\n</p>\nHowever, hardcoding IDs like this is not a good practice in React. A component may be rendered more than once on the page\u2014but IDs have to be unique! Instead of hardcoding an ID, generate a unique ID with useId\n:\nimport { useId } from 'react';\nfunction PasswordField() {\nconst passwordHintId = useId();\nreturn (\n<>\n<label>\nPassword:\n<input\ntype=\"password\"\naria-describedby={passwordHintId}\n/>\n</label>\n<p id={passwordHintId}>\nThe password should contain at least 18 characters\n</p>\n</>\n);\n}\nNow, even if PasswordField\nappears multiple times on the screen, the generated IDs won\u2019t clash.\nimport { useId } from 'react'; function PasswordField() { const passwordHintId = useId(); return ( <> <label> Password: <input type=\"password\" aria-describedby={passwordHintId} /> </label> <p id={passwordHintId}> The password should contain at least 18 characters </p> </> ); } export default function App() { return ( <> <h2>Choose password</h2> <PasswordField /> <h2>Confirm password</h2> <PasswordField /> </> ); }\nWatch this video to see the difference in the user experience with assistive technologies.\nDeep Dive\nYou might be wondering why useId\nis better than incrementing a global variable like nextId++\n.\nThe primary benefit of useId\nis that React ensures that it works with server rendering. During server rendering, your components generate HTML output. Later, on the client, hydration attaches your event handlers to the generated HTML. For hydration to work, the client output must match the server HTML.\nThis is very difficult to guarantee with an incrementing counter because the order in which the Client Components are hydrated may not match the order in which the server HTML was emitted. By calling useId\n, you ensure that hydration will work, and the output will match between the server and the client.\nInside React, useId\nis generated from the \u201cparent path\u201d of the calling component. This is why, if the client and the server tree are the same, the \u201cparent path\u201d will match up regardless of rendering order.\nGenerating IDs for several related elements\nIf you need to give IDs to multiple related elements, you can call useId\nto generate a shared prefix for them:\nimport { useId } from 'react'; export default function Form() { const id = useId(); return ( <form> <label htmlFor={id + '-firstName'}>First Name:</label> <input id={id + '-firstName'} type=\"text\" /> <hr /> <label htmlFor={id + '-lastName'}>Last Name:</label> <input id={id + '-lastName'} type=\"text\" /> </form> ); }\nThis lets you avoid calling useId\nfor every single element that needs a unique ID.\nSpecifying a shared prefix for all generated IDs\nIf you render multiple independent React applications on a single page, pass identifierPrefix\nas an option to your createRoot\nor hydrateRoot\ncalls. This ensures that the IDs generated by the two different apps never clash because every identifier generated with useId\nwill start with the distinct prefix you\u2019ve specified.\nimport { createRoot } from 'react-dom/client'; import App from './App.js'; import './styles.css'; const root1 = createRoot(document.getElementById('root1'), { identifierPrefix: 'my-first-app-' }); root1.render(<App />); const root2 = createRoot(document.getElementById('root2'), { identifierPrefix: 'my-second-app-' }); root2.render(<App />);\nUsing the same ID prefix on the client and the server\nIf you render multiple independent React apps on the same page, and some of these apps are server-rendered, make sure that the identifierPrefix\nyou pass to the hydrateRoot\ncall on the client side is the same as the identifierPrefix\nyou pass to the server APIs such as renderToPipeableStream\n.\n// Server\nimport { renderToPipeableStream } from 'react-dom/server';\nconst { pipe } = renderToPipeableStream(\n<App />,\n{ identifierPrefix: 'react-app1' }\n);\n// Client\nimport { hydrateRoot } from 'react-dom/client';\nconst domNode = document.getElementById('root');\nconst root = hydrateRoot(\ndomNode,\nreactNode,\n{ identifierPrefix: 'react-app1' }\n);\nYou do not need to pass identifierPrefix\nif you only have one React app on the page."
  },
  {
    "source": "https://react.dev/reference/react/useImperativeHandle",
    "title": "useImperativeHandle \u2013 React",
    "text": "useImperativeHandle\nuseImperativeHandle\nis a React Hook that lets you customize the handle exposed as a ref.\nuseImperativeHandle(ref, createHandle, dependencies?)\nReference\nuseImperativeHandle(ref, createHandle, dependencies?)\nCall useImperativeHandle\nat the top level of your component to customize the ref handle it exposes:\nimport { useImperativeHandle } from 'react';\nfunction MyInput({ ref }) {\nuseImperativeHandle(ref, () => {\nreturn {\n// ... your methods ...\n};\n}, []);\n// ...\nParameters\n-\nref\n: Theref\nyou received as a prop to theMyInput\ncomponent. -\ncreateHandle\n: A function that takes no arguments and returns the ref handle you want to expose. That ref handle can have any type. Usually, you will return an object with the methods you want to expose. -\noptional\ndependencies\n: The list of all reactive values referenced inside of thecreateHandle\ncode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]\n. React will compare each dependency with its previous value using theObject.is\ncomparison. If a re-render resulted in a change to some dependency, or if you omitted this argument, yourcreateHandle\nfunction will re-execute, and the newly created handle will be assigned to the ref.\nReturns\nuseImperativeHandle\nreturns undefined\n.\nUsage\nExposing a custom ref handle to the parent component\nTo expose a DOM node to the parent element, pass in the ref\nprop to the node.\nfunction MyInput({ ref }) {\nreturn <input ref={ref} />;\n};\nWith the code above, a ref to MyInput\nwill receive the <input>\nDOM node. However, you can expose a custom value instead. To customize the exposed handle, call useImperativeHandle\nat the top level of your component:\nimport { useImperativeHandle } from 'react';\nfunction MyInput({ ref }) {\nuseImperativeHandle(ref, () => {\nreturn {\n// ... your methods ...\n};\n}, []);\nreturn <input />;\n};\nNote that in the code above, the ref\nis no longer passed to the <input>\n.\nFor example, suppose you don\u2019t want to expose the entire <input>\nDOM node, but you want to expose two of its methods: focus\nand scrollIntoView\n. To do this, keep the real browser DOM in a separate ref. Then use useImperativeHandle\nto expose a handle with only the methods that you want the parent component to call:\nimport { useRef, useImperativeHandle } from 'react';\nfunction MyInput({ ref }) {\nconst inputRef = useRef(null);\nuseImperativeHandle(ref, () => {\nreturn {\nfocus() {\ninputRef.current.focus();\n},\nscrollIntoView() {\ninputRef.current.scrollIntoView();\n},\n};\n}, []);\nreturn <input ref={inputRef} />;\n};\nNow, if the parent component gets a ref to MyInput\n, it will be able to call the focus\nand scrollIntoView\nmethods on it. However, it will not have full access to the underlying <input>\nDOM node.\nimport { useRef } from 'react'; import MyInput from './MyInput.js'; export default function Form() { const ref = useRef(null); function handleClick() { ref.current.focus(); // This won't work because the DOM node isn't exposed: // ref.current.style.opacity = 0.5; } return ( <form> <MyInput placeholder=\"Enter your name\" ref={ref} /> <button type=\"button\" onClick={handleClick}> Edit </button> </form> ); }\nExposing your own imperative methods\nThe methods you expose via an imperative handle don\u2019t have to match the DOM methods exactly. For example, this Post\ncomponent exposes a scrollAndFocusAddComment\nmethod via an imperative handle. This lets the parent Page\nscroll the list of comments and focus the input field when you click the button:\nimport { useRef } from 'react'; import Post from './Post.js'; export default function Page() { const postRef = useRef(null); function handleClick() { postRef.current.scrollAndFocusAddComment(); } return ( <> <button onClick={handleClick}> Write a comment </button> <Post ref={postRef} /> </> ); }"
  },
  {
    "source": "https://react.dev/reference/react/useInsertionEffect",
    "title": "useInsertionEffect \u2013 React",
    "text": "useInsertionEffect\nuseInsertionEffect\nallows inserting elements into the DOM before any layout Effects fire.\nuseInsertionEffect(setup, dependencies?)\nReference\nuseInsertionEffect(setup, dependencies?)\nCall useInsertionEffect\nto insert styles before any Effects fire that may need to read layout:\nimport { useInsertionEffect } from 'react';\n// Inside your CSS-in-JS library\nfunction useCSS(rule) {\nuseInsertionEffect(() => {\n// ... inject <style> tags here ...\n});\nreturn rule;\n}\nParameters\n-\nsetup\n: The function with your Effect\u2019s logic. Your setup function may also optionally return a cleanup function. When your component is added to the DOM, but before any layout Effects fire, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. When your component is removed from the DOM, React will run your cleanup function. -\noptional\ndependencies\n: The list of all reactive values referenced inside of thesetup\ncode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]\n. React will compare each dependency with its previous value using theObject.is\ncomparison algorithm. If you don\u2019t specify the dependencies at all, your Effect will re-run after every re-render of the component.\nReturns\nuseInsertionEffect\nreturns undefined\n.\nCaveats\n- Effects only run on the client. They don\u2019t run during server rendering.\n- You can\u2019t update state from inside\nuseInsertionEffect\n. - By the time\nuseInsertionEffect\nruns, refs are not attached yet. useInsertionEffect\nmay run either before or after the DOM has been updated. You shouldn\u2019t rely on the DOM being updated at any particular time.- Unlike other types of Effects, which fire cleanup for every Effect and then setup for every Effect,\nuseInsertionEffect\nwill fire both cleanup and setup one component at a time. This results in an \u201cinterleaving\u201d of the cleanup and setup functions.\nUsage\nInjecting dynamic styles from CSS-in-JS libraries\nTraditionally, you would style React components using plain CSS.\n// In your JS file:\n<button className=\"success\" />\n// In your CSS file:\n.success { color: green; }\nSome teams prefer to author styles directly in JavaScript code instead of writing CSS files. This usually requires using a CSS-in-JS library or a tool. There are three common approaches to CSS-in-JS:\n- Static extraction to CSS files with a compiler\n- Inline styles, e.g.\n<div style={{ opacity: 1 }}>\n- Runtime injection of\n<style>\ntags\nIf you use CSS-in-JS, we recommend a combination of the first two approaches (CSS files for static styles, inline styles for dynamic styles). We don\u2019t recommend runtime <style>\ntag injection for two reasons:\n- Runtime injection forces the browser to recalculate the styles a lot more often.\n- Runtime injection can be very slow if it happens at the wrong time in the React lifecycle.\nThe first problem is not solvable, but useInsertionEffect\nhelps you solve the second problem.\nCall useInsertionEffect\nto insert the styles before any layout Effects fire:\n// Inside your CSS-in-JS library\nlet isInserted = new Set();\nfunction useCSS(rule) {\nuseInsertionEffect(() => {\n// As explained earlier, we don't recommend runtime injection of <style> tags.\n// But if you have to do it, then it's important to do in useInsertionEffect.\nif (!isInserted.has(rule)) {\nisInserted.add(rule);\ndocument.head.appendChild(getStyleForRule(rule));\n}\n});\nreturn rule;\n}\nfunction Button() {\nconst className = useCSS('...');\nreturn <div className={className} />;\n}\nSimilarly to useEffect\n, useInsertionEffect\ndoes not run on the server. If you need to collect which CSS rules have been used on the server, you can do it during rendering:\nlet collectedRulesSet = new Set();\nfunction useCSS(rule) {\nif (typeof window === 'undefined') {\ncollectedRulesSet.add(rule);\n}\nuseInsertionEffect(() => {\n// ...\n});\nreturn rule;\n}\nRead more about upgrading CSS-in-JS libraries with runtime injection to useInsertionEffect\n.\nDeep Dive\nIf you insert styles during rendering and React is processing a non-blocking update, the browser will recalculate the styles every single frame while rendering a component tree, which can be extremely slow.\nuseInsertionEffect\nis better than inserting styles during useLayoutEffect\nor useEffect\nbecause it ensures that by the time other Effects run in your components, the <style>\ntags have already been inserted. Otherwise, layout calculations in regular Effects would be wrong due to outdated styles."
  },
  {
    "source": "https://react.dev/reference/react/useLayoutEffect",
    "title": "useLayoutEffect \u2013 React",
    "text": "useLayoutEffect\nuseLayoutEffect\nis a version of useEffect\nthat fires before the browser repaints the screen.\nuseLayoutEffect(setup, dependencies?)\nReference\nuseLayoutEffect(setup, dependencies?)\nCall useLayoutEffect\nto perform the layout measurements before the browser repaints the screen:\nimport { useState, useRef, useLayoutEffect } from 'react';\nfunction Tooltip() {\nconst ref = useRef(null);\nconst [tooltipHeight, setTooltipHeight] = useState(0);\nuseLayoutEffect(() => {\nconst { height } = ref.current.getBoundingClientRect();\nsetTooltipHeight(height);\n}, []);\n// ...\nParameters\n-\nsetup\n: The function with your Effect\u2019s logic. Your setup function may also optionally return a cleanup function. Before your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. Before your component is removed from the DOM, React will run your cleanup function. -\noptional\ndependencies\n: The list of all reactive values referenced inside of thesetup\ncode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]\n. React will compare each dependency with its previous value using theObject.is\ncomparison. If you omit this argument, your Effect will re-run after every re-render of the component.\nReturns\nuseLayoutEffect\nreturns undefined\n.\nCaveats\n-\nuseLayoutEffect\nis a Hook, so you can only call it at the top level of your component or your own Hooks. You can\u2019t call it inside loops or conditions. If you need that, extract a component and move the Effect there. -\nWhen Strict Mode is on, React will run one extra development-only setup+cleanup cycle before the first real setup. This is a stress-test that ensures that your cleanup logic \u201cmirrors\u201d your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function.\n-\nIf some of your dependencies are objects or functions defined inside the component, there is a risk that they will cause the Effect to re-run more often than needed. To fix this, remove unnecessary object and function dependencies. You can also extract state updates and non-reactive logic outside of your Effect.\n-\nEffects only run on the client. They don\u2019t run during server rendering.\n-\nThe code inside\nuseLayoutEffect\nand all state updates scheduled from it block the browser from repainting the screen. When used excessively, this makes your app slow. When possible, preferuseEffect\n. -\nIf you trigger a state update inside\nuseLayoutEffect\n, React will execute all remaining Effects immediately includinguseEffect\n.\nUsage\nMeasuring layout before the browser repaints the screen\nMost components don\u2019t need to know their position and size on the screen to decide what to render. They only return some JSX. Then the browser calculates their layout (position and size) and repaints the screen.\nSometimes, that\u2019s not enough. Imagine a tooltip that appears next to some element on hover. If there\u2019s enough space, the tooltip should appear above the element, but if it doesn\u2019t fit, it should appear below. In order to render the tooltip at the right final position, you need to know its height (i.e. whether it fits at the top).\nTo do this, you need to render in two passes:\n- Render the tooltip anywhere (even with a wrong position).\n- Measure its height and decide where to place the tooltip.\n- Render the tooltip again in the correct place.\nAll of this needs to happen before the browser repaints the screen. You don\u2019t want the user to see the tooltip moving. Call useLayoutEffect\nto perform the layout measurements before the browser repaints the screen:\nfunction Tooltip() {\nconst ref = useRef(null);\nconst [tooltipHeight, setTooltipHeight] = useState(0); // You don't know real height yet\nuseLayoutEffect(() => {\nconst { height } = ref.current.getBoundingClientRect();\nsetTooltipHeight(height); // Re-render now that you know the real height\n}, []);\n// ...use tooltipHeight in the rendering logic below...\n}\nHere\u2019s how this works step by step:\nTooltip\nrenders with the initialtooltipHeight = 0\n(so the tooltip may be wrongly positioned).- React places it in the DOM and runs the code in\nuseLayoutEffect\n. - Your\nuseLayoutEffect\nmeasures the height of the tooltip content and triggers an immediate re-render. Tooltip\nrenders again with the realtooltipHeight\n(so the tooltip is correctly positioned).- React updates it in the DOM, and the browser finally displays the tooltip.\nHover over the buttons below and see how the tooltip adjusts its position depending on whether it fits:\nimport { useRef, useLayoutEffect, useState } from 'react'; import { createPortal } from 'react-dom'; import TooltipContainer from './TooltipContainer.js'; export default function Tooltip({ children, targetRect }) { const ref = useRef(null); const [tooltipHeight, setTooltipHeight] = useState(0); useLayoutEffect(() => { const { height } = ref.current.getBoundingClientRect(); setTooltipHeight(height); console.log('Measured tooltip height: ' + height); }, []); let tooltipX = 0; let tooltipY = 0; if (targetRect !== null) { tooltipX = targetRect.left; tooltipY = targetRect.top - tooltipHeight; if (tooltipY < 0) { // It doesn't fit above, so place below. tooltipY = targetRect.bottom; } } return createPortal( <TooltipContainer x={tooltipX} y={tooltipY} contentRef={ref}> {children} </TooltipContainer>, document.body ); }\nNotice that even though the Tooltip\ncomponent has to render in two passes (first, with tooltipHeight\ninitialized to 0\nand then with the real measured height), you only see the final result. This is why you need useLayoutEffect\ninstead of useEffect\nfor this example. Let\u2019s look at the difference in detail below.\nExample 1 of 2: useLayoutEffect\nblocks the browser from repainting\nReact guarantees that the code inside useLayoutEffect\nand any state updates scheduled inside it will be processed before the browser repaints the screen. This lets you render the tooltip, measure it, and re-render the tooltip again without the user noticing the first extra render. In other words, useLayoutEffect\nblocks the browser from painting.\nimport { useRef, useLayoutEffect, useState } from 'react'; import { createPortal } from 'react-dom'; import TooltipContainer from './TooltipContainer.js'; export default function Tooltip({ children, targetRect }) { const ref = useRef(null); const [tooltipHeight, setTooltipHeight] = useState(0); useLayoutEffect(() => { const { height } = ref.current.getBoundingClientRect(); setTooltipHeight(height); }, []); let tooltipX = 0; let tooltipY = 0; if (targetRect !== null) { tooltipX = targetRect.left; tooltipY = targetRect.top - tooltipHeight; if (tooltipY < 0) { // It doesn't fit above, so place below. tooltipY = targetRect.bottom; } } return createPortal( <TooltipContainer x={tooltipX} y={tooltipY} contentRef={ref}> {children} </TooltipContainer>, document.body ); }\nTroubleshooting\nI\u2019m getting an error: \u201cuseLayoutEffect\ndoes nothing on the server\u201d\nThe purpose of useLayoutEffect\nis to let your component use layout information for rendering:\n- Render the initial content.\n- Measure the layout before the browser repaints the screen.\n- Render the final content using the layout information you\u2019ve read.\nWhen you or your framework uses server rendering, your React app renders to HTML on the server for the initial render. This lets you show the initial HTML before the JavaScript code loads.\nThe problem is that on the server, there is no layout information.\nIn the earlier example, the useLayoutEffect\ncall in the Tooltip\ncomponent lets it position itself correctly (either above or below content) depending on the content height. If you tried to render Tooltip\nas a part of the initial server HTML, this would be impossible to determine. On the server, there is no layout yet! So, even if you rendered it on the server, its position would \u201cjump\u201d on the client after the JavaScript loads and runs.\nUsually, components that rely on layout information don\u2019t need to render on the server anyway. For example, it probably doesn\u2019t make sense to show a Tooltip\nduring the initial render. It is triggered by a client interaction.\nHowever, if you\u2019re running into this problem, you have a few different options:\n-\nReplace\nuseLayoutEffect\nwithuseEffect\n. This tells React that it\u2019s okay to display the initial render result without blocking the paint (because the original HTML will become visible before your Effect runs). -\nAlternatively, mark your component as client-only. This tells React to replace its content up to the closest\n<Suspense>\nboundary with a loading fallback (for example, a spinner or a glimmer) during server rendering. -\nAlternatively, you can render a component with\nuseLayoutEffect\nonly after hydration. Keep a booleanisMounted\nstate that\u2019s initialized tofalse\n, and set it totrue\ninside auseEffect\ncall. Your rendering logic can then be likereturn isMounted ? <RealContent /> : <FallbackContent />\n. On the server and during the hydration, the user will seeFallbackContent\nwhich should not calluseLayoutEffect\n. Then React will replace it withRealContent\nwhich runs on the client only and can includeuseLayoutEffect\ncalls. -\nIf you synchronize your component with an external data store and rely on\nuseLayoutEffect\nfor different reasons than measuring layout, consideruseSyncExternalStore\ninstead which supports server rendering."
  },
  {
    "source": "https://react.dev/reference/react/useMemo",
    "title": "useMemo \u2013 React",
    "text": "useMemo\nuseMemo\nis a React Hook that lets you cache the result of a calculation between re-renders.\nconst cachedValue = useMemo(calculateValue, dependencies)\nReference\nuseMemo(calculateValue, dependencies)\nCall useMemo\nat the top level of your component to cache a calculation between re-renders:\nimport { useMemo } from 'react';\nfunction TodoList({ todos, tab }) {\nconst visibleTodos = useMemo(\n() => filterTodos(todos, tab),\n[todos, tab]\n);\n// ...\n}\nParameters\n-\ncalculateValue\n: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if thedependencies\nhave not changed since the last render. Otherwise, it will callcalculateValue\n, return its result, and store it so it can be reused later. -\ndependencies\n: The list of all reactive values referenced inside of thecalculateValue\ncode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]\n. React will compare each dependency with its previous value using theObject.is\ncomparison.\nReturns\nOn the initial render, useMemo\nreturns the result of calling calculateValue\nwith no arguments.\nDuring next renders, it will either return an already stored value from the last render (if the dependencies haven\u2019t changed), or call calculateValue\nagain, and return the result that calculateValue\nhas returned.\nCaveats\nuseMemo\nis a Hook, so you can only call it at the top level of your component or your own Hooks. You can\u2019t call it inside loops or conditions. If you need that, extract a new component and move the state into it.- In Strict Mode, React will call your calculation function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your calculation function is pure (as it should be), this should not affect your logic. The result from one of the calls will be ignored.\n- React will not throw away the cached value unless there is a specific reason to do that. For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache\u2014for example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should be fine if you rely on\nuseMemo\nsolely as a performance optimization. Otherwise, a state variable or a ref may be more appropriate.\nUsage\nSkipping expensive recalculations\nTo cache a calculation between re-renders, wrap it in a useMemo\ncall at the top level of your component:\nimport { useMemo } from 'react';\nfunction TodoList({ todos, tab, theme }) {\nconst visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\n// ...\n}\nYou need to pass two things to useMemo\n:\n- A calculation function that takes no arguments, like\n() =>\n, and returns what you wanted to calculate. - A list of dependencies including every value within your component that\u2019s used inside your calculation.\nOn the initial render, the value you\u2019ll get from useMemo\nwill be the result of calling your calculation.\nOn every subsequent render, React will compare the dependencies with the dependencies you passed during the last render. If none of the dependencies have changed (compared with Object.is\n), useMemo\nwill return the value you already calculated before. Otherwise, React will re-run your calculation and return the new value.\nIn other words, useMemo\ncaches a calculation result between re-renders until its dependencies change.\nLet\u2019s walk through an example to see when this is useful.\nBy default, React will re-run the entire body of your component every time that it re-renders. For example, if this TodoList\nupdates its state or receives new props from its parent, the filterTodos\nfunction will re-run:\nfunction TodoList({ todos, tab, theme }) {\nconst visibleTodos = filterTodos(todos, tab);\n// ...\n}\nUsually, this isn\u2019t a problem because most calculations are very fast. However, if you\u2019re filtering or transforming a large array, or doing some expensive computation, you might want to skip doing it again if data hasn\u2019t changed. If both todos\nand tab\nare the same as they were during the last render, wrapping the calculation in useMemo\nlike earlier lets you reuse visibleTodos\nyou\u2019ve already calculated before.\nThis type of caching is called memoization.\nDeep Dive\nIn general, unless you\u2019re creating or looping over thousands of objects, it\u2019s probably not expensive. If you want to get more confidence, you can add a console log to measure the time spent in a piece of code:\nconsole.time('filter array');\nconst visibleTodos = filterTodos(todos, tab);\nconsole.timeEnd('filter array');\nPerform the interaction you\u2019re measuring (for example, typing into the input). You will then see logs like filter array: 0.15ms\nin your console. If the overall logged time adds up to a significant amount (say, 1ms\nor more), it might make sense to memoize that calculation. As an experiment, you can then wrap the calculation in useMemo\nto verify whether the total logged time has decreased for that interaction or not:\nconsole.time('filter array');\nconst visibleTodos = useMemo(() => {\nreturn filterTodos(todos, tab); // Skipped if todos and tab haven't changed\n}, [todos, tab]);\nconsole.timeEnd('filter array');\nuseMemo\nwon\u2019t make the first render faster. It only helps you skip unnecessary work on updates.\nKeep in mind that your machine is probably faster than your users\u2019 so it\u2019s a good idea to test the performance with an artificial slowdown. For example, Chrome offers a CPU Throttling option for this.\nAlso note that measuring performance in development will not give you the most accurate results. (For example, when Strict Mode is on, you will see each component render twice rather than once.) To get the most accurate timings, build your app for production and test it on a device like your users have.\nDeep Dive\nIf your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.\nOptimizing with useMemo\nis only valuable in a few cases:\n- The calculation you\u2019re putting in\nuseMemo\nis noticeably slow, and its dependencies rarely change. - You pass it as a prop to a component wrapped in\nmemo\n. You want to skip re-rendering if the value hasn\u2019t changed. Memoization lets your component re-render only when dependencies aren\u2019t the same. - The value you\u2019re passing is later used as a dependency of some Hook. For example, maybe another\nuseMemo\ncalculation value depends on it. Or maybe you are depending on this value fromuseEffect.\nThere is no benefit to wrapping a calculation in useMemo\nin other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value that\u2019s \u201calways new\u201d is enough to break memoization for an entire component.\nIn practice, you can make a lot of memoization unnecessary by following a few principles:\n- When a component visually wraps other components, let it accept JSX as children. This way, when the wrapper component updates its own state, React knows that its children don\u2019t need to re-render.\n- Prefer local state and don\u2019t lift state up any further than necessary. For example, don\u2019t keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.\n- Keep your rendering logic pure. If re-rendering a component causes a problem or produces some noticeable visual artifact, it\u2019s a bug in your component! Fix the bug instead of adding memoization.\n- Avoid unnecessary Effects that update state. Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.\n- Try to remove unnecessary dependencies from your Effects. For example, instead of memoization, it\u2019s often simpler to move some object or a function inside an Effect or outside the component.\nIf a specific interaction still feels laggy, use the React Developer Tools profiler to see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it\u2019s good to follow them in any case. In the long term, we\u2019re researching doing granular memoization automatically to solve this once and for all.\nExample 1 of 2: Skipping recalculation with useMemo\nIn this example, the filterTodos\nimplementation is artificially slowed down so that you can see what happens when some JavaScript function you\u2019re calling during rendering is genuinely slow. Try switching the tabs and toggling the theme.\nSwitching the tabs feels slow because it forces the slowed down filterTodos\nto re-execute. That\u2019s expected because the tab\nhas changed, and so the entire calculation needs to re-run. (If you\u2019re curious why it runs twice, it\u2019s explained here.)\nToggle the theme. Thanks to useMemo\n, it\u2019s fast despite the artificial slowdown! The slow filterTodos\ncall was skipped because both todos\nand tab\n(which you pass as dependencies to useMemo\n) haven\u2019t changed since the last render.\nimport { useMemo } from 'react'; import { filterTodos } from './utils.js' export default function TodoList({ todos, theme, tab }) { const visibleTodos = useMemo( () => filterTodos(todos, tab), [todos, tab] ); return ( <div className={theme}> <p><b>Note: <code>filterTodos</code> is artificially slowed down!</b></p> <ul> {visibleTodos.map(todo => ( <li key={todo.id}> {todo.completed ? <s>{todo.text}</s> : todo.text } </li> ))} </ul> </div> ); }\nSkipping re-rendering of components\nIn some cases, useMemo\ncan also help you optimize performance of re-rendering child components. To illustrate this, let\u2019s say this TodoList\ncomponent passes the visibleTodos\nas a prop to the child List\ncomponent:\nexport default function TodoList({ todos, tab, theme }) {\n// ...\nreturn (\n<div className={theme}>\n<List items={visibleTodos} />\n</div>\n);\n}\nYou\u2019ve noticed that toggling the theme\nprop freezes the app for a moment, but if you remove <List />\nfrom your JSX, it feels fast. This tells you that it\u2019s worth trying to optimize the List\ncomponent.\nBy default, when a component re-renders, React re-renders all of its children recursively. This is why, when TodoList\nre-renders with a different theme\n, the List\ncomponent also re-renders. This is fine for components that don\u2019t require much calculation to re-render. But if you\u2019ve verified that a re-render is slow, you can tell List\nto skip re-rendering when its props are the same as on last render by wrapping it in memo\n:\nimport { memo } from 'react';\nconst List = memo(function List({ items }) {\n// ...\n});\nWith this change, List\nwill skip re-rendering if all of its props are the same as on the last render. This is where caching the calculation becomes important! Imagine that you calculated visibleTodos\nwithout useMemo\n:\nexport default function TodoList({ todos, tab, theme }) {\n// Every time the theme changes, this will be a different array...\nconst visibleTodos = filterTodos(todos, tab);\nreturn (\n<div className={theme}>\n{/* ... so List's props will never be the same, and it will re-render every time */}\n<List items={visibleTodos} />\n</div>\n);\n}\nIn the above example, the filterTodos\nfunction always creates a different array, similar to how the {}\nobject literal always creates a new object. Normally, this wouldn\u2019t be a problem, but it means that List\nprops will never be the same, and your memo\noptimization won\u2019t work. This is where useMemo\ncomes in handy:\nexport default function TodoList({ todos, tab, theme }) {\n// Tell React to cache your calculation between re-renders...\nconst visibleTodos = useMemo(\n() => filterTodos(todos, tab),\n[todos, tab] // ...so as long as these dependencies don't change...\n);\nreturn (\n<div className={theme}>\n{/* ...List will receive the same props and can skip re-rendering */}\n<List items={visibleTodos} />\n</div>\n);\n}\nBy wrapping the visibleTodos\ncalculation in useMemo\n, you ensure that it has the same value between the re-renders (until dependencies change). You don\u2019t have to wrap a calculation in useMemo\nunless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in memo\n, and this lets it skip re-rendering. There are a few other reasons to add useMemo\nwhich are described further on this page.\nDeep Dive\nInstead of wrapping List\nin memo\n, you could wrap the <List />\nJSX node itself in useMemo\n:\nexport default function TodoList({ todos, tab, theme }) {\nconst visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\nconst children = useMemo(() => <List items={visibleTodos} />, [visibleTodos]);\nreturn (\n<div className={theme}>\n{children}\n</div>\n);\n}\nThe behavior would be the same. If the visibleTodos\nhaven\u2019t changed, List\nwon\u2019t be re-rendered.\nA JSX node like <List items={visibleTodos} />\nis an object like { type: List, props: { items: visibleTodos } }\n. Creating this object is very cheap, but React doesn\u2019t know whether its contents is the same as last time or not. This is why by default, React will re-render the List\ncomponent.\nHowever, if React sees the same exact JSX as during the previous render, it won\u2019t try to re-render your component. This is because JSX nodes are immutable. A JSX node object could not have changed over time, so React knows it\u2019s safe to skip a re-render. However, for this to work, the node has to actually be the same object, not merely look the same in code. This is what useMemo\ndoes in this example.\nManually wrapping JSX nodes into useMemo\nis not convenient. For example, you can\u2019t do this conditionally. This is usually why you would wrap components with memo\ninstead of wrapping JSX nodes.\nExample 1 of 2: Skipping re-rendering with useMemo\nand memo\nIn this example, the List\ncomponent is artificially slowed down so that you can see what happens when a React component you\u2019re rendering is genuinely slow. Try switching the tabs and toggling the theme.\nSwitching the tabs feels slow because it forces the slowed down List\nto re-render. That\u2019s expected because the tab\nhas changed, and so you need to reflect the user\u2019s new choice on the screen.\nNext, try toggling the theme. Thanks to useMemo\ntogether with memo\n, it\u2019s fast despite the artificial slowdown! The List\nskipped re-rendering because the visibleTodos\narray has not changed since the last render. The visibleTodos\narray has not changed because both todos\nand tab\n(which you pass as dependencies to useMemo\n) haven\u2019t changed since the last render.\nimport { useMemo } from 'react'; import List from './List.js'; import { filterTodos } from './utils.js' export default function TodoList({ todos, theme, tab }) { const visibleTodos = useMemo( () => filterTodos(todos, tab), [todos, tab] ); return ( <div className={theme}> <p><b>Note: <code>List</code> is artificially slowed down!</b></p> <List items={visibleTodos} /> </div> ); }\nPreventing an Effect from firing too often\nSometimes, you might want to use a value inside an Effect:\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState('');\nconst options = {\nserverUrl: 'https://localhost:1234',\nroomId: roomId\n}\nuseEffect(() => {\nconst connection = createConnection(options);\nconnection.connect();\n// ...\nThis creates a problem. Every reactive value must be declared as a dependency of your Effect. However, if you declare options\nas a dependency, it will cause your Effect to constantly reconnect to the chat room:\nuseEffect(() => {\nconst connection = createConnection(options);\nconnection.connect();\nreturn () => connection.disconnect();\n}, [options]); // \ud83d\udd34 Problem: This dependency changes on every render\n// ...\nTo solve this, you can wrap the object you need to call from an Effect in useMemo\n:\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState('');\nconst options = useMemo(() => {\nreturn {\nserverUrl: 'https://localhost:1234',\nroomId: roomId\n};\n}, [roomId]); // \u2705 Only changes when roomId changes\nuseEffect(() => {\nconst connection = createConnection(options);\nconnection.connect();\nreturn () => connection.disconnect();\n}, [options]); // \u2705 Only changes when options changes\n// ...\nThis ensures that the options\nobject is the same between re-renders if useMemo\nreturns the cached object.\nHowever, since useMemo\nis performance optimization, not a semantic guarantee, React may throw away the cached value if there is a specific reason to do that. This will also cause the effect to re-fire, so it\u2019s even better to remove the need for a function dependency by moving your object inside the Effect:\nfunction ChatRoom({ roomId }) {\nconst [message, setMessage] = useState('');\nuseEffect(() => {\nconst options = { // \u2705 No need for useMemo or object dependencies!\nserverUrl: 'https://localhost:1234',\nroomId: roomId\n}\nconst connection = createConnection(options);\nconnection.connect();\nreturn () => connection.disconnect();\n}, [roomId]); // \u2705 Only changes when roomId changes\n// ...\nNow your code is simpler and doesn\u2019t need useMemo\n. Learn more about removing Effect dependencies.\nMemoizing a dependency of another Hook\nSuppose you have a calculation that depends on an object created directly in the component body:\nfunction Dropdown({ allItems, text }) {\nconst searchOptions = { matchMode: 'whole-word', text };\nconst visibleItems = useMemo(() => {\nreturn searchItems(allItems, searchOptions);\n}, [allItems, searchOptions]); // \ud83d\udea9 Caution: Dependency on an object created in the component body\n// ...\nDepending on an object like this defeats the point of memoization. When a component re-renders, all of the code directly inside the component body runs again. The lines of code creating the searchOptions\nobject will also run on every re-render. Since searchOptions\nis a dependency of your useMemo\ncall, and it\u2019s different every time, React knows the dependencies are different, and recalculate searchItems\nevery time.\nTo fix this, you could memoize the searchOptions\nobject itself before passing it as a dependency:\nfunction Dropdown({ allItems, text }) {\nconst searchOptions = useMemo(() => {\nreturn { matchMode: 'whole-word', text };\n}, [text]); // \u2705 Only changes when text changes\nconst visibleItems = useMemo(() => {\nreturn searchItems(allItems, searchOptions);\n}, [allItems, searchOptions]); // \u2705 Only changes when allItems or searchOptions changes\n// ...\nIn the example above, if the text\ndid not change, the searchOptions\nobject also won\u2019t change. However, an even better fix is to move the searchOptions\nobject declaration inside of the useMemo\ncalculation function:\nfunction Dropdown({ allItems, text }) {\nconst visibleItems = useMemo(() => {\nconst searchOptions = { matchMode: 'whole-word', text };\nreturn searchItems(allItems, searchOptions);\n}, [allItems, text]); // \u2705 Only changes when allItems or text changes\n// ...\nNow your calculation depends on text\ndirectly (which is a string and can\u2019t \u201caccidentally\u201d become different).\nMemoizing a function\nSuppose the Form\ncomponent is wrapped in memo\n. You want to pass a function to it as a prop:\nexport default function ProductPage({ productId, referrer }) {\nfunction handleSubmit(orderDetails) {\npost('/product/' + productId + '/buy', {\nreferrer,\norderDetails\n});\n}\nreturn <Form onSubmit={handleSubmit} />;\n}\nJust as {}\ncreates a different object, function declarations like function() {}\nand expressions like () => {}\nproduce a different function on every re-render. By itself, creating a new function is not a problem. This is not something to avoid! However, if the Form\ncomponent is memoized, presumably you want to skip re-rendering it when no props have changed. A prop that is always different would defeat the point of memoization.\nTo memoize a function with useMemo\n, your calculation function would have to return another function:\nexport default function Page({ productId, referrer }) {\nconst handleSubmit = useMemo(() => {\nreturn (orderDetails) => {\npost('/product/' + productId + '/buy', {\nreferrer,\norderDetails\n});\n};\n}, [productId, referrer]);\nreturn <Form onSubmit={handleSubmit} />;\n}\nThis looks clunky! Memoizing functions is common enough that React has a built-in Hook specifically for that. Wrap your functions into useCallback\ninstead of useMemo\nto avoid having to write an extra nested function:\nexport default function Page({ productId, referrer }) {\nconst handleSubmit = useCallback((orderDetails) => {\npost('/product/' + productId + '/buy', {\nreferrer,\norderDetails\n});\n}, [productId, referrer]);\nreturn <Form onSubmit={handleSubmit} />;\n}\nThe two examples above are completely equivalent. The only benefit to useCallback\nis that it lets you avoid writing an extra nested function inside. It doesn\u2019t do anything else. Read more about useCallback\n.\nTroubleshooting\nMy calculation runs twice on every re-render\nIn Strict Mode, React will call some of your functions twice instead of once:\nfunction TodoList({ todos, tab }) {\n// This component function will run twice for every render.\nconst visibleTodos = useMemo(() => {\n// This calculation will run twice if any of the dependencies change.\nreturn filterTodos(todos, tab);\n}, [todos, tab]);\n// ...\nThis is expected and shouldn\u2019t break your code.\nThis development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component and calculation functions are pure, this shouldn\u2019t affect your logic. However, if they are accidentally impure, this helps you notice and fix the mistake.\nFor example, this impure calculation function mutates an array you received as a prop:\nconst visibleTodos = useMemo(() => {\n// \ud83d\udea9 Mistake: mutating a prop\ntodos.push({ id: 'last', text: 'Go for a walk!' });\nconst filtered = filterTodos(todos, tab);\nreturn filtered;\n}, [todos, tab]);\nReact calls your function twice, so you\u2019d notice the todo is added twice. Your calculation shouldn\u2019t change any existing objects, but it\u2019s okay to change any new objects you created during the calculation. For example, if the filterTodos\nfunction always returns a different array, you can mutate that array instead:\nconst visibleTodos = useMemo(() => {\nconst filtered = filterTodos(todos, tab);\n// \u2705 Correct: mutating an object you created during the calculation\nfiltered.push({ id: 'last', text: 'Go for a walk!' });\nreturn filtered;\n}, [todos, tab]);\nRead keeping components pure to learn more about purity.\nAlso, check out the guides on updating objects and updating arrays without mutation.\nMy useMemo\ncall is supposed to return an object, but returns undefined\nThis code doesn\u2019t work:\n// \ud83d\udd34 You can't return an object from an arrow function with () => {\nconst searchOptions = useMemo(() => {\nmatchMode: 'whole-word',\ntext: text\n}, [text]);\nIn JavaScript, () => {\nstarts the arrow function body, so the {\nbrace is not a part of your object. This is why it doesn\u2019t return an object, and leads to mistakes. You could fix it by adding parentheses like ({\nand })\n:\n// This works, but is easy for someone to break again\nconst searchOptions = useMemo(() => ({\nmatchMode: 'whole-word',\ntext: text\n}), [text]);\nHowever, this is still confusing and too easy for someone to break by removing the parentheses.\nTo avoid this mistake, write a return\nstatement explicitly:\n// \u2705 This works and is explicit\nconst searchOptions = useMemo(() => {\nreturn {\nmatchMode: 'whole-word',\ntext: text\n};\n}, [text]);\nEvery time my component renders, the calculation in useMemo\nre-runs\nMake sure you\u2019ve specified the dependency array as a second argument!\nIf you forget the dependency array, useMemo\nwill re-run the calculation every time:\nfunction TodoList({ todos, tab }) {\n// \ud83d\udd34 Recalculates every time: no dependency array\nconst visibleTodos = useMemo(() => filterTodos(todos, tab));\n// ...\nThis is the corrected version passing the dependency array as a second argument:\nfunction TodoList({ todos, tab }) {\n// \u2705 Does not recalculate unnecessarily\nconst visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\n// ...\nIf this doesn\u2019t help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:\nconst visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\nconsole.log([todos, tab]);\nYou can then right-click on the arrays from different re-renders in the console and select \u201cStore as a global variable\u201d for both of them. Assuming the first one got saved as temp1\nand the second one got saved as temp2\n, you can then use the browser console to check whether each dependency in both arrays is the same:\nObject.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?\nObject.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?\nObject.is(temp1[2], temp2[2]); // ... and so on for every dependency ...\nWhen you find which dependency breaks memoization, either find a way to remove it, or memoize it as well.\nI need to call useMemo\nfor each list item in a loop, but it\u2019s not allowed\nSuppose the Chart\ncomponent is wrapped in memo\n. You want to skip re-rendering every Chart\nin the list when the ReportList\ncomponent re-renders. However, you can\u2019t call useMemo\nin a loop:\nfunction ReportList({ items }) {\nreturn (\n<article>\n{items.map(item => {\n// \ud83d\udd34 You can't call useMemo in a loop like this:\nconst data = useMemo(() => calculateReport(item), [item]);\nreturn (\n<figure key={item.id}>\n<Chart data={data} />\n</figure>\n);\n})}\n</article>\n);\n}\nInstead, extract a component for each item and memoize data for individual items:\nfunction ReportList({ items }) {\nreturn (\n<article>\n{items.map(item =>\n<Report key={item.id} item={item} />\n)}\n</article>\n);\n}\nfunction Report({ item }) {\n// \u2705 Call useMemo at the top level:\nconst data = useMemo(() => calculateReport(item), [item]);\nreturn (\n<figure>\n<Chart data={data} />\n</figure>\n);\n}\nAlternatively, you could remove useMemo\nand instead wrap Report\nitself in memo\n. If the item\nprop does not change, Report\nwill skip re-rendering, so Chart\nwill skip re-rendering too:\nfunction ReportList({ items }) {\n// ...\n}\nconst Report = memo(function Report({ item }) {\nconst data = calculateReport(item);\nreturn (\n<figure>\n<Chart data={data} />\n</figure>\n);\n});"
  },
  {
    "source": "https://react.dev/reference/react/useOptimistic",
    "title": "useOptimistic \u2013 React",
    "text": "useOptimistic\nuseOptimistic\nis a React Hook that lets you optimistically update the UI.\nconst [optimisticState, addOptimistic] = useOptimistic(state, updateFn);\nReference\nuseOptimistic(state, updateFn)\nuseOptimistic\nis a React Hook that lets you show a different state while an async action is underway. It accepts some state as an argument and returns a copy of that state that can be different during the duration of an async action such as a network request. You provide a function that takes the current state and the input to the action, and returns the optimistic state to be used while the action is pending.\nThis state is called the \u201coptimistic\u201d state because it is usually used to immediately present the user with the result of performing an action, even though the action actually takes time to complete.\nimport { useOptimistic } from 'react';\nfunction AppContainer() {\nconst [optimisticState, addOptimistic] = useOptimistic(\nstate,\n// updateFn\n(currentState, optimisticValue) => {\n// merge and return new state\n// with optimistic value\n}\n);\n}\nParameters\nstate\n: the value to be returned initially and whenever no action is pending.updateFn(currentState, optimisticValue)\n: a function that takes the current state and the optimistic value passed toaddOptimistic\nand returns the resulting optimistic state. It must be a pure function.updateFn\ntakes in two parameters. ThecurrentState\nand theoptimisticValue\n. The return value will be the merged value of thecurrentState\nandoptimisticValue\n.\nReturns\noptimisticState\n: The resulting optimistic state. It is equal tostate\nunless an action is pending, in which case it is equal to the value returned byupdateFn\n.addOptimistic\n:addOptimistic\nis the dispatching function to call when you have an optimistic update. It takes one argument,optimisticValue\n, of any type and will call theupdateFn\nwithstate\nandoptimisticValue\n.\nUsage\nOptimistically updating forms\nThe useOptimistic\nHook provides a way to optimistically update the user interface before a background operation, like a network request, completes. In the context of forms, this technique helps to make apps feel more responsive. When a user submits a form, instead of waiting for the server\u2019s response to reflect the changes, the interface is immediately updated with the expected outcome.\nFor example, when a user types a message into the form and hits the \u201cSend\u201d button, the useOptimistic\nHook allows the message to immediately appear in the list with a \u201cSending\u2026\u201d label, even before the message is actually sent to a server. This \u201coptimistic\u201d approach gives the impression of speed and responsiveness. The form then attempts to truly send the message in the background. Once the server confirms the message has been received, the \u201cSending\u2026\u201d label is removed.\nimport { useOptimistic, useState, useRef } from \"react\"; import { deliverMessage } from \"./actions.js\"; function Thread({ messages, sendMessage }) { const formRef = useRef(); async function formAction(formData) { addOptimisticMessage(formData.get(\"message\")); formRef.current.reset(); await sendMessage(formData); } const [optimisticMessages, addOptimisticMessage] = useOptimistic( messages, (state, newMessage) => [ ...state, { text: newMessage, sending: true } ] ); return ( <> {optimisticMessages.map((message, index) => ( <div key={index}> {message.text} {!!message.sending && <small> (Sending...)</small>} </div> ))} <form action={formAction} ref={formRef}> <input type=\"text\" name=\"message\" placeholder=\"Hello!\" /> <button type=\"submit\">Send</button> </form> </> ); } export default function App() { const [messages, setMessages] = useState([ { text: \"Hello there!\", sending: false, key: 1 } ]); async function sendMessage(formData) { const sentMessage = await deliverMessage(formData.get(\"message\")); setMessages((messages) => [...messages, { text: sentMessage }]); } return <Thread messages={messages} sendMessage={sendMessage} />; }"
  },
  {
    "source": "https://react.dev/reference/react/useReducer",
    "title": "useReducer \u2013 React",
    "text": "useReducer\nuseReducer\nis a React Hook that lets you add a reducer to your component.\nconst [state, dispatch] = useReducer(reducer, initialArg, init?)\n- Reference\n- Usage\n- Troubleshooting\n- I\u2019ve dispatched an action, but logging gives me the old state value\n- I\u2019ve dispatched an action, but the screen doesn\u2019t update\n- A part of my reducer state becomes undefined after dispatching\n- My entire reducer state becomes undefined after dispatching\n- I\u2019m getting an error: \u201cToo many re-renders\u201d\n- My reducer or initializer function runs twice\nReference\nuseReducer(reducer, initialArg, init?)\nCall useReducer\nat the top level of your component to manage its state with a reducer.\nimport { useReducer } from 'react';\nfunction reducer(state, action) {\n// ...\n}\nfunction MyComponent() {\nconst [state, dispatch] = useReducer(reducer, { age: 42 });\n// ...\nParameters\nreducer\n: The reducer function that specifies how the state gets updated. It must be pure, should take the state and action as arguments, and should return the next state. State and action can be of any types.initialArg\n: The value from which the initial state is calculated. It can be a value of any type. How the initial state is calculated from it depends on the nextinit\nargument.- optional\ninit\n: The initializer function that should return the initial state. If it\u2019s not specified, the initial state is set toinitialArg\n. Otherwise, the initial state is set to the result of callinginit(initialArg)\n.\nReturns\nuseReducer\nreturns an array with exactly two values:\n- The current state. During the first render, it\u2019s set to\ninit(initialArg)\norinitialArg\n(if there\u2019s noinit\n). - The\ndispatch\nfunction that lets you update the state to a different value and trigger a re-render.\nCaveats\nuseReducer\nis a Hook, so you can only call it at the top level of your component or your own Hooks. You can\u2019t call it inside loops or conditions. If you need that, extract a new component and move the state into it.- The\ndispatch\nfunction has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do. Learn more about removing Effect dependencies. - In Strict Mode, React will call your reducer and initializer twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your reducer and initializer are pure (as they should be), this should not affect your logic. The result from one of the calls is ignored.\ndispatch\nfunction\nThe dispatch\nfunction returned by useReducer\nlets you update the state to a different value and trigger a re-render. You need to pass the action as the only argument to the dispatch\nfunction:\nconst [state, dispatch] = useReducer(reducer, { age: 42 });\nfunction handleClick() {\ndispatch({ type: 'incremented_age' });\n// ...\nReact will set the next state to the result of calling the reducer\nfunction you\u2019ve provided with the current state\nand the action you\u2019ve passed to dispatch\n.\nParameters\naction\n: The action performed by the user. It can be a value of any type. By convention, an action is usually an object with atype\nproperty identifying it and, optionally, other properties with additional information.\nReturns\ndispatch\nfunctions do not have a return value.\nCaveats\n-\nThe\ndispatch\nfunction only updates the state variable for the next render. If you read the state variable after calling thedispatch\nfunction, you will still get the old value that was on the screen before your call. -\nIf the new value you provide is identical to the current\nstate\n, as determined by anObject.is\ncomparison, React will skip re-rendering the component and its children. This is an optimization. React may still need to call your component before ignoring the result, but it shouldn\u2019t affect your code. -\nReact batches state updates. It updates the screen after all the event handlers have run and have called their\nset\nfunctions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can useflushSync\n.\nUsage\nAdding a reducer to a component\nCall useReducer\nat the top level of your component to manage state with a reducer.\nimport { useReducer } from 'react';\nfunction reducer(state, action) {\n// ...\n}\nfunction MyComponent() {\nconst [state, dispatch] = useReducer(reducer, { age: 42 });\n// ...\nuseReducer\nreturns an array with exactly two items:\n- The current state of this state variable, initially set to the initial state you provided.\n- The\ndispatch\nfunction that lets you change it in response to interaction.\nTo update what\u2019s on the screen, call dispatch\nwith an object representing what the user did, called an action:\nfunction handleClick() {\ndispatch({ type: 'incremented_age' });\n}\nReact will pass the current state and the action to your reducer function. Your reducer will calculate and return the next state. React will store that next state, render your component with it, and update the UI.\nimport { useReducer } from 'react'; function reducer(state, action) { if (action.type === 'incremented_age') { return { age: state.age + 1 }; } throw Error('Unknown action.'); } export default function Counter() { const [state, dispatch] = useReducer(reducer, { age: 42 }); return ( <> <button onClick={() => { dispatch({ type: 'incremented_age' }) }}> Increment age </button> <p>Hello! You are {state.age}.</p> </> ); }\nuseReducer\nis very similar to useState\n, but it lets you move the state update logic from event handlers into a single function outside of your component. Read more about choosing between useState\nand useReducer\n.\nWriting the reducer function\nA reducer function is declared like this:\nfunction reducer(state, action) {\n// ...\n}\nThen you need to fill in the code that will calculate and return the next state. By convention, it is common to write it as a switch\nstatement. For each case\nin the switch\n, calculate and return some next state.\nfunction reducer(state, action) {\nswitch (action.type) {\ncase 'incremented_age': {\nreturn {\nname: state.name,\nage: state.age + 1\n};\n}\ncase 'changed_name': {\nreturn {\nname: action.nextName,\nage: state.age\n};\n}\n}\nthrow Error('Unknown action: ' + action.type);\n}\nActions can have any shape. By convention, it\u2019s common to pass objects with a type\nproperty identifying the action. It should include the minimal necessary information that the reducer needs to compute the next state.\nfunction Form() {\nconst [state, dispatch] = useReducer(reducer, { name: 'Taylor', age: 42 });\nfunction handleButtonClick() {\ndispatch({ type: 'incremented_age' });\n}\nfunction handleInputChange(e) {\ndispatch({\ntype: 'changed_name',\nnextName: e.target.value\n});\n}\n// ...\nThe action type names are local to your component. Each action describes a single interaction, even if that leads to multiple changes in data. The shape of the state is arbitrary, but usually it\u2019ll be an object or an array.\nRead extracting state logic into a reducer to learn more.\nExample 1 of 3: Form (object)\nIn this example, the reducer manages a state object with two fields: name\nand age\n.\nimport { useReducer } from 'react'; function reducer(state, action) { switch (action.type) { case 'incremented_age': { return { name: state.name, age: state.age + 1 }; } case 'changed_name': { return { name: action.nextName, age: state.age }; } } throw Error('Unknown action: ' + action.type); } const initialState = { name: 'Taylor', age: 42 }; export default function Form() { const [state, dispatch] = useReducer(reducer, initialState); function handleButtonClick() { dispatch({ type: 'incremented_age' }); } function handleInputChange(e) { dispatch({ type: 'changed_name', nextName: e.target.value }); } return ( <> <input value={state.name} onChange={handleInputChange} /> <button onClick={handleButtonClick}> Increment age </button> <p>Hello, {state.name}. You are {state.age}.</p> </> ); }\nAvoiding recreating the initial state\nReact saves the initial state once and ignores it on the next renders.\nfunction createInitialState(username) {\n// ...\n}\nfunction TodoList({ username }) {\nconst [state, dispatch] = useReducer(reducer, createInitialState(username));\n// ...\nAlthough the result of createInitialState(username)\nis only used for the initial render, you\u2019re still calling this function on every render. This can be wasteful if it\u2019s creating large arrays or performing expensive calculations.\nTo solve this, you may pass it as an initializer function to useReducer\nas the third argument instead:\nfunction createInitialState(username) {\n// ...\n}\nfunction TodoList({ username }) {\nconst [state, dispatch] = useReducer(reducer, username, createInitialState);\n// ...\nNotice that you\u2019re passing createInitialState\n, which is the function itself, and not createInitialState()\n, which is the result of calling it. This way, the initial state does not get re-created after initialization.\nIn the above example, createInitialState\ntakes a username\nargument. If your initializer doesn\u2019t need any information to compute the initial state, you may pass null\nas the second argument to useReducer\n.\nExample 1 of 2: Passing the initializer function\nThis example passes the initializer function, so the createInitialState\nfunction only runs during initialization. It does not run when component re-renders, such as when you type into the input.\nimport { useReducer } from 'react'; function createInitialState(username) { const initialTodos = []; for (let i = 0; i < 50; i++) { initialTodos.push({ id: i, text: username + \"'s task #\" + (i + 1) }); } return { draft: '', todos: initialTodos, }; } function reducer(state, action) { switch (action.type) { case 'changed_draft': { return { draft: action.nextDraft, todos: state.todos, }; }; case 'added_todo': { return { draft: '', todos: [{ id: state.todos.length, text: state.draft }, ...state.todos] } } } throw Error('Unknown action: ' + action.type); } export default function TodoList({ username }) { const [state, dispatch] = useReducer( reducer, username, createInitialState ); return ( <> <input value={state.draft} onChange={e => { dispatch({ type: 'changed_draft', nextDraft: e.target.value }) }} /> <button onClick={() => { dispatch({ type: 'added_todo' }); }}>Add</button> <ul> {state.todos.map(item => ( <li key={item.id}> {item.text} </li> ))} </ul> </> ); }\nTroubleshooting\nI\u2019ve dispatched an action, but logging gives me the old state value\nCalling the dispatch\nfunction does not change state in the running code:\nfunction handleClick() {\nconsole.log(state.age); // 42\ndispatch({ type: 'incremented_age' }); // Request a re-render with 43\nconsole.log(state.age); // Still 42!\nsetTimeout(() => {\nconsole.log(state.age); // Also 42!\n}, 5000);\n}\nThis is because states behaves like a snapshot. Updating state requests another render with the new state value, but does not affect the state\nJavaScript variable in your already-running event handler.\nIf you need to guess the next state value, you can calculate it manually by calling the reducer yourself:\nconst action = { type: 'incremented_age' };\ndispatch(action);\nconst nextState = reducer(state, action);\nconsole.log(state); // { age: 42 }\nconsole.log(nextState); // { age: 43 }\nI\u2019ve dispatched an action, but the screen doesn\u2019t update\nReact will ignore your update if the next state is equal to the previous state, as determined by an Object.is\ncomparison. This usually happens when you change an object or an array in state directly:\nfunction reducer(state, action) {\nswitch (action.type) {\ncase 'incremented_age': {\n// \ud83d\udea9 Wrong: mutating existing object\nstate.age++;\nreturn state;\n}\ncase 'changed_name': {\n// \ud83d\udea9 Wrong: mutating existing object\nstate.name = action.nextName;\nreturn state;\n}\n// ...\n}\n}\nYou mutated an existing state\nobject and returned it, so React ignored the update. To fix this, you need to ensure that you\u2019re always updating objects in state and updating arrays in state instead of mutating them:\nfunction reducer(state, action) {\nswitch (action.type) {\ncase 'incremented_age': {\n// \u2705 Correct: creating a new object\nreturn {\n...state,\nage: state.age + 1\n};\n}\ncase 'changed_name': {\n// \u2705 Correct: creating a new object\nreturn {\n...state,\nname: action.nextName\n};\n}\n// ...\n}\n}\nA part of my reducer state becomes undefined after dispatching\nMake sure that every case\nbranch copies all of the existing fields when returning the new state:\nfunction reducer(state, action) {\nswitch (action.type) {\ncase 'incremented_age': {\nreturn {\n...state, // Don't forget this!\nage: state.age + 1\n};\n}\n// ...\nWithout ...state\nabove, the returned next state would only contain the age\nfield and nothing else.\nMy entire reducer state becomes undefined after dispatching\nIf your state unexpectedly becomes undefined\n, you\u2019re likely forgetting to return\nstate in one of the cases, or your action type doesn\u2019t match any of the case\nstatements. To find why, throw an error outside the switch\n:\nfunction reducer(state, action) {\nswitch (action.type) {\ncase 'incremented_age': {\n// ...\n}\ncase 'edited_name': {\n// ...\n}\n}\nthrow Error('Unknown action: ' + action.type);\n}\nYou can also use a static type checker like TypeScript to catch such mistakes.\nI\u2019m getting an error: \u201cToo many re-renders\u201d\nYou might get an error that says: Too many re-renders. React limits the number of renders to prevent an infinite loop.\nTypically, this means that you\u2019re unconditionally dispatching an action during render, so your component enters a loop: render, dispatch (which causes a render), render, dispatch (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:\n// \ud83d\udea9 Wrong: calls the handler during render\nreturn <button onClick={handleClick()}>Click me</button>\n// \u2705 Correct: passes down the event handler\nreturn <button onClick={handleClick}>Click me</button>\n// \u2705 Correct: passes down an inline function\nreturn <button onClick={(e) => handleClick(e)}>Click me</button>\nIf you can\u2019t find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific dispatch\nfunction call responsible for the error.\nMy reducer or initializer function runs twice\nIn Strict Mode, React will call your reducer and initializer functions twice. This shouldn\u2019t break your code.\nThis development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and reducer functions are pure, this shouldn\u2019t affect your logic. However, if they are accidentally impure, this helps you notice the mistakes.\nFor example, this impure reducer function mutates an array in state:\nfunction reducer(state, action) {\nswitch (action.type) {\ncase 'added_todo': {\n// \ud83d\udea9 Mistake: mutating state\nstate.todos.push({ id: nextId++, text: action.text });\nreturn state;\n}\n// ...\n}\n}\nBecause React calls your reducer function twice, you\u2019ll see the todo was added twice, so you\u2019ll know that there is a mistake. In this example, you can fix the mistake by replacing the array instead of mutating it:\nfunction reducer(state, action) {\nswitch (action.type) {\ncase 'added_todo': {\n// \u2705 Correct: replacing with new state\nreturn {\n...state,\ntodos: [\n...state.todos,\n{ id: nextId++, text: action.text }\n]\n};\n}\n// ...\n}\n}\nNow that this reducer function is pure, calling it an extra time doesn\u2019t make a difference in behavior. This is why React calling it twice helps you find mistakes. Only component, initializer, and reducer functions need to be pure. Event handlers don\u2019t need to be pure, so React will never call your event handlers twice.\nRead keeping components pure to learn more."
  },
  {
    "source": "https://react.dev/reference/react/useRef",
    "title": "useRef \u2013 React",
    "text": "useRef\nuseRef\nis a React Hook that lets you reference a value that\u2019s not needed for rendering.\nconst ref = useRef(initialValue)\nReference\nuseRef(initialValue)\nCall useRef\nat the top level of your component to declare a ref.\nimport { useRef } from 'react';\nfunction MyComponent() {\nconst intervalRef = useRef(0);\nconst inputRef = useRef(null);\n// ...\nParameters\ninitialValue\n: The value you want the ref object\u2019scurrent\nproperty to be initially. It can be a value of any type. This argument is ignored after the initial render.\nReturns\nuseRef\nreturns an object with a single property:\ncurrent\n: Initially, it\u2019s set to theinitialValue\nyou have passed. You can later set it to something else. If you pass the ref object to React as aref\nattribute to a JSX node, React will set itscurrent\nproperty.\nOn the next renders, useRef\nwill return the same object.\nCaveats\n- You can mutate the\nref.current\nproperty. Unlike state, it is mutable. However, if it holds an object that is used for rendering (for example, a piece of your state), then you shouldn\u2019t mutate that object. - When you change the\nref.current\nproperty, React does not re-render your component. React is not aware of when you change it because a ref is a plain JavaScript object. - Do not write or read\nref.current\nduring rendering, except for initialization. This makes your component\u2019s behavior unpredictable. - In Strict Mode, React will call your component function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. Each ref object will be created twice, but one of the versions will be discarded. If your component function is pure (as it should be), this should not affect the behavior.\nUsage\nReferencing a value with a ref\nCall useRef\nat the top level of your component to declare one or more refs.\nimport { useRef } from 'react';\nfunction Stopwatch() {\nconst intervalRef = useRef(0);\n// ...\nuseRef\nreturns a ref object with a single current\nproperty initially set to the initial value you provided.\nOn the next renders, useRef\nwill return the same object. You can change its current\nproperty to store information and read it later. This might remind you of state, but there is an important difference.\nChanging a ref does not trigger a re-render. This means refs are perfect for storing information that doesn\u2019t affect the visual output of your component. For example, if you need to store an interval ID and retrieve it later, you can put it in a ref. To update the value inside the ref, you need to manually change its current\nproperty:\nfunction handleStartClick() {\nconst intervalId = setInterval(() => {\n// ...\n}, 1000);\nintervalRef.current = intervalId;\n}\nLater, you can read that interval ID from the ref so that you can call clear that interval:\nfunction handleStopClick() {\nconst intervalId = intervalRef.current;\nclearInterval(intervalId);\n}\nBy using a ref, you ensure that:\n- You can store information between re-renders (unlike regular variables, which reset on every render).\n- Changing it does not trigger a re-render (unlike state variables, which trigger a re-render).\n- The information is local to each copy of your component (unlike the variables outside, which are shared).\nChanging a ref does not trigger a re-render, so refs are not appropriate for storing information you want to display on the screen. Use state for that instead. Read more about choosing between useRef\nand useState\n.\nExample 1 of 2: Click counter\nThis component uses a ref to keep track of how many times the button was clicked. Note that it\u2019s okay to use a ref instead of state here because the click count is only read and written in an event handler.\nimport { useRef } from 'react'; export default function Counter() { let ref = useRef(0); function handleClick() { ref.current = ref.current + 1; alert('You clicked ' + ref.current + ' times!'); } return ( <button onClick={handleClick}> Click me! </button> ); }\nIf you show {ref.current}\nin the JSX, the number won\u2019t update on click. This is because setting ref.current\ndoes not trigger a re-render. Information that\u2019s used for rendering should be state instead.\nManipulating the DOM with a ref\nIt\u2019s particularly common to use a ref to manipulate the DOM. React has built-in support for this.\nFirst, declare a ref object with an initial value of null\n:\nimport { useRef } from 'react';\nfunction MyComponent() {\nconst inputRef = useRef(null);\n// ...\nThen pass your ref object as the ref\nattribute to the JSX of the DOM node you want to manipulate:\n// ...\nreturn <input ref={inputRef} />;\nAfter React creates the DOM node and puts it on the screen, React will set the current\nproperty of your ref object to that DOM node. Now you can access the <input>\n\u2019s DOM node and call methods like focus()\n:\nfunction handleClick() {\ninputRef.current.focus();\n}\nReact will set the current\nproperty back to null\nwhen the node is removed from the screen.\nRead more about manipulating the DOM with refs.\nExample 1 of 4: Focusing a text input\nIn this example, clicking the button will focus the input:\nimport { useRef } from 'react'; export default function Form() { const inputRef = useRef(null); function handleClick() { inputRef.current.focus(); } return ( <> <input ref={inputRef} /> <button onClick={handleClick}> Focus the input </button> </> ); }\nAvoiding recreating the ref contents\nReact saves the initial ref value once and ignores it on the next renders.\nfunction Video() {\nconst playerRef = useRef(new VideoPlayer());\n// ...\nAlthough the result of new VideoPlayer()\nis only used for the initial render, you\u2019re still calling this function on every render. This can be wasteful if it\u2019s creating expensive objects.\nTo solve it, you may initialize the ref like this instead:\nfunction Video() {\nconst playerRef = useRef(null);\nif (playerRef.current === null) {\nplayerRef.current = new VideoPlayer();\n}\n// ...\nNormally, writing or reading ref.current\nduring render is not allowed. However, it\u2019s fine in this case because the result is always the same, and the condition only executes during initialization so it\u2019s fully predictable.\nDeep Dive\nIf you use a type checker and don\u2019t want to always check for null\n, you can try a pattern like this instead:\nfunction Video() {\nconst playerRef = useRef(null);\nfunction getPlayer() {\nif (playerRef.current !== null) {\nreturn playerRef.current;\n}\nconst player = new VideoPlayer();\nplayerRef.current = player;\nreturn player;\n}\n// ...\nHere, the playerRef\nitself is nullable. However, you should be able to convince your type checker that there is no case in which getPlayer()\nreturns null\n. Then use getPlayer()\nin your event handlers.\nTroubleshooting\nI can\u2019t get a ref to a custom component\nIf you try to pass a ref\nto your own component like this:\nconst inputRef = useRef(null);\nreturn <MyInput ref={inputRef} />;\nYou might get an error in the console:\nBy default, your own components don\u2019t expose refs to the DOM nodes inside them.\nTo fix this, find the component that you want to get a ref to:\nexport default function MyInput({ value, onChange }) {\nreturn (\n<input\nvalue={value}\nonChange={onChange}\n/>\n);\n}\nAnd then add ref\nto the list of props your component accepts and pass ref\nas a prop to the relevent child built-in component like this:\nfunction MyInput({ value, onChange, ref }) {\nreturn (\n<input\nvalue={value}\nonChange={onChange}\nref={ref}\n/>\n);\n};\nexport default MyInput;\nThen the parent component can get a ref to it.\nRead more about accessing another component\u2019s DOM nodes."
  },
  {
    "source": "https://react.dev/reference/react/useState",
    "title": "useState \u2013 React",
    "text": "useState\nuseState\nis a React Hook that lets you add a state variable to your component.\nconst [state, setState] = useState(initialState)\nReference\nuseState(initialState)\nCall useState\nat the top level of your component to declare a state variable.\nimport { useState } from 'react';\nfunction MyComponent() {\nconst [age, setAge] = useState(28);\nconst [name, setName] = useState('Taylor');\nconst [todos, setTodos] = useState(() => createTodos());\n// ...\nThe convention is to name state variables like [something, setSomething]\nusing array destructuring.\nParameters\ninitialState\n: The value you want the state to be initially. It can be a value of any type, but there is a special behavior for functions. This argument is ignored after the initial render.- If you pass a function as\ninitialState\n, it will be treated as an initializer function. It should be pure, should take no arguments, and should return a value of any type. React will call your initializer function when initializing the component, and store its return value as the initial state. See an example below.\n- If you pass a function as\nReturns\nuseState\nreturns an array with exactly two values:\n- The current state. During the first render, it will match the\ninitialState\nyou have passed. - The\nset\nfunction that lets you update the state to a different value and trigger a re-render.\nCaveats\nuseState\nis a Hook, so you can only call it at the top level of your component or your own Hooks. You can\u2019t call it inside loops or conditions. If you need that, extract a new component and move the state into it.- In Strict Mode, React will call your initializer function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your initializer function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored.\nset\nfunctions, like setSomething(nextState)\nThe set\nfunction returned by useState\nlets you update the state to a different value and trigger a re-render. You can pass the next state directly, or a function that calculates it from the previous state:\nconst [name, setName] = useState('Edward');\nfunction handleClick() {\nsetName('Taylor');\nsetAge(a => a + 1);\n// ...\nParameters\nnextState\n: The value that you want the state to be. It can be a value of any type, but there is a special behavior for functions.- If you pass a function as\nnextState\n, it will be treated as an updater function. It must be pure, should take the pending state as its only argument, and should return the next state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state. See an example below.\n- If you pass a function as\nReturns\nset\nfunctions do not have a return value.\nCaveats\n-\nThe\nset\nfunction only updates the state variable for the next render. If you read the state variable after calling theset\nfunction, you will still get the old value that was on the screen before your call. -\nIf the new value you provide is identical to the current\nstate\n, as determined by anObject.is\ncomparison, React will skip re-rendering the component and its children. This is an optimization. Although in some cases React may still need to call your component before skipping the children, it shouldn\u2019t affect your code. -\nReact batches state updates. It updates the screen after all the event handlers have run and have called their\nset\nfunctions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can useflushSync\n. -\nThe\nset\nfunction has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do. Learn more about removing Effect dependencies. -\nCalling the\nset\nfunction during rendering is only allowed from within the currently rendering component. React will discard its output and immediately attempt to render it again with the new state. This pattern is rarely needed, but you can use it to store information from the previous renders. See an example below. -\nIn Strict Mode, React will call your updater function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your updater function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored.\nUsage\nAdding state to a component\nCall useState\nat the top level of your component to declare one or more state variables.\nimport { useState } from 'react';\nfunction MyComponent() {\nconst [age, setAge] = useState(42);\nconst [name, setName] = useState('Taylor');\n// ...\nThe convention is to name state variables like [something, setSomething]\nusing array destructuring.\nuseState\nreturns an array with exactly two items:\n- The current state of this state variable, initially set to the initial state you provided.\n- The\nset\nfunction that lets you change it to any other value in response to interaction.\nTo update what\u2019s on the screen, call the set\nfunction with some next state:\nfunction handleClick() {\nsetName('Robin');\n}\nReact will store the next state, render your component again with the new values, and update the UI.\nExample 1 of 4: Counter (number)\nIn this example, the count\nstate variable holds a number. Clicking the button increments it.\nimport { useState } from 'react'; export default function Counter() { const [count, setCount] = useState(0); function handleClick() { setCount(count + 1); } return ( <button onClick={handleClick}> You pressed me {count} times </button> ); }\nUpdating state based on the previous state\nSuppose the age\nis 42\n. This handler calls setAge(age + 1)\nthree times:\nfunction handleClick() {\nsetAge(age + 1); // setAge(42 + 1)\nsetAge(age + 1); // setAge(42 + 1)\nsetAge(age + 1); // setAge(42 + 1)\n}\nHowever, after one click, age\nwill only be 43\nrather than 45\n! This is because calling the set\nfunction does not update the age\nstate variable in the already running code. So each setAge(age + 1)\ncall becomes setAge(43)\n.\nTo solve this problem, you may pass an updater function to setAge\ninstead of the next state:\nfunction handleClick() {\nsetAge(a => a + 1); // setAge(42 => 43)\nsetAge(a => a + 1); // setAge(43 => 44)\nsetAge(a => a + 1); // setAge(44 => 45)\n}\nHere, a => a + 1\nis your updater function. It takes the pending state and calculates the next state from it.\nReact puts your updater functions in a queue. Then, during the next render, it will call them in the same order:\na => a + 1\nwill receive42\nas the pending state and return43\nas the next state.a => a + 1\nwill receive43\nas the pending state and return44\nas the next state.a => a + 1\nwill receive44\nas the pending state and return45\nas the next state.\nThere are no other queued updates, so React will store 45\nas the current state in the end.\nBy convention, it\u2019s common to name the pending state argument for the first letter of the state variable name, like a\nfor age\n. However, you may also call it like prevAge\nor something else that you find clearer.\nReact may call your updaters twice in development to verify that they are pure.\nDeep Dive\nYou might hear a recommendation to always write code like setAge(a => a + 1)\nif the state you\u2019re setting is calculated from the previous state. There is no harm in it, but it is also not always necessary.\nIn most cases, there is no difference between these two approaches. React always makes sure that for intentional user actions, like clicks, the age\nstate variable would be updated before the next click. This means there is no risk of a click handler seeing a \u201cstale\u201d age\nat the beginning of the event handler.\nHowever, if you do multiple updates within the same event, updaters can be helpful. They\u2019re also helpful if accessing the state variable itself is inconvenient (you might run into this when optimizing re-renders).\nIf you prefer consistency over slightly more verbose syntax, it\u2019s reasonable to always write an updater if the state you\u2019re setting is calculated from the previous state. If it\u2019s calculated from the previous state of some other state variable, you might want to combine them into one object and use a reducer.\nExample 1 of 2: Passing the updater function\nThis example passes the updater function, so the \u201c+3\u201d button works.\nimport { useState } from 'react'; export default function Counter() { const [age, setAge] = useState(42); function increment() { setAge(a => a + 1); } return ( <> <h1>Your age: {age}</h1> <button onClick={() => { increment(); increment(); increment(); }}>+3</button> <button onClick={() => { increment(); }}>+1</button> </> ); }\nUpdating objects and arrays in state\nYou can put objects and arrays into state. In React, state is considered read-only, so you should replace it rather than mutate your existing objects. For example, if you have a form\nobject in state, don\u2019t mutate it:\n// \ud83d\udea9 Don't mutate an object in state like this:\nform.firstName = 'Taylor';\nInstead, replace the whole object by creating a new one:\n// \u2705 Replace state with a new object\nsetForm({\n...form,\nfirstName: 'Taylor'\n});\nRead updating objects in state and updating arrays in state to learn more.\nExample 1 of 4: Form (object)\nIn this example, the form\nstate variable holds an object. Each input has a change handler that calls setForm\nwith the next state of the entire form. The { ...form }\nspread syntax ensures that the state object is replaced rather than mutated.\nimport { useState } from 'react'; export default function Form() { const [form, setForm] = useState({ firstName: 'Barbara', lastName: 'Hepworth', email: 'bhepworth@sculpture.com', }); return ( <> <label> First name: <input value={form.firstName} onChange={e => { setForm({ ...form, firstName: e.target.value }); }} /> </label> <label> Last name: <input value={form.lastName} onChange={e => { setForm({ ...form, lastName: e.target.value }); }} /> </label> <label> Email: <input value={form.email} onChange={e => { setForm({ ...form, email: e.target.value }); }} /> </label> <p> {form.firstName}{' '} {form.lastName}{' '} ({form.email}) </p> </> ); }\nAvoiding recreating the initial state\nReact saves the initial state once and ignores it on the next renders.\nfunction TodoList() {\nconst [todos, setTodos] = useState(createInitialTodos());\n// ...\nAlthough the result of createInitialTodos()\nis only used for the initial render, you\u2019re still calling this function on every render. This can be wasteful if it\u2019s creating large arrays or performing expensive calculations.\nTo solve this, you may pass it as an initializer function to useState\ninstead:\nfunction TodoList() {\nconst [todos, setTodos] = useState(createInitialTodos);\n// ...\nNotice that you\u2019re passing createInitialTodos\n, which is the function itself, and not createInitialTodos()\n, which is the result of calling it. If you pass a function to useState\n, React will only call it during initialization.\nReact may call your initializers twice in development to verify that they are pure.\nExample 1 of 2: Passing the initializer function\nThis example passes the initializer function, so the createInitialTodos\nfunction only runs during initialization. It does not run when component re-renders, such as when you type into the input.\nimport { useState } from 'react'; function createInitialTodos() { const initialTodos = []; for (let i = 0; i < 50; i++) { initialTodos.push({ id: i, text: 'Item ' + (i + 1) }); } return initialTodos; } export default function TodoList() { const [todos, setTodos] = useState(createInitialTodos); const [text, setText] = useState(''); return ( <> <input value={text} onChange={e => setText(e.target.value)} /> <button onClick={() => { setText(''); setTodos([{ id: todos.length, text: text }, ...todos]); }}>Add</button> <ul> {todos.map(item => ( <li key={item.id}> {item.text} </li> ))} </ul> </> ); }\nResetting state with a key\nYou\u2019ll often encounter the key\nattribute when rendering lists. However, it also serves another purpose.\nYou can reset a component\u2019s state by passing a different key\nto a component. In this example, the Reset button changes the version\nstate variable, which we pass as a key\nto the Form\n. When the key\nchanges, React re-creates the Form\ncomponent (and all of its children) from scratch, so its state gets reset.\nRead preserving and resetting state to learn more.\nimport { useState } from 'react'; export default function App() { const [version, setVersion] = useState(0); function handleReset() { setVersion(version + 1); } return ( <> <button onClick={handleReset}>Reset</button> <Form key={version} /> </> ); } function Form() { const [name, setName] = useState('Taylor'); return ( <> <input value={name} onChange={e => setName(e.target.value)} /> <p>Hello, {name}.</p> </> ); }\nStoring information from previous renders\nUsually, you will update state in event handlers. However, in rare cases you might want to adjust state in response to rendering \u2014 for example, you might want to change a state variable when a prop changes.\nIn most cases, you don\u2019t need this:\n- If the value you need can be computed entirely from the current props or other state, remove that redundant state altogether. If you\u2019re worried about recomputing too often, the\nuseMemo\nHook can help. - If you want to reset the entire component tree\u2019s state, pass a different\nkey\nto your component. - If you can, update all the relevant state in the event handlers.\nIn the rare case that none of these apply, there is a pattern you can use to update state based on the values that have been rendered so far, by calling a set\nfunction while your component is rendering.\nHere\u2019s an example. This CountLabel\ncomponent displays the count\nprop passed to it:\nexport default function CountLabel({ count }) {\nreturn <h1>{count}</h1>\n}\nSay you want to show whether the counter has increased or decreased since the last change. The count\nprop doesn\u2019t tell you this \u2014 you need to keep track of its previous value. Add the prevCount\nstate variable to track it. Add another state variable called trend\nto hold whether the count has increased or decreased. Compare prevCount\nwith count\n, and if they\u2019re not equal, update both prevCount\nand trend\n. Now you can show both the current count prop and how it has changed since the last render.\nimport { useState } from 'react'; export default function CountLabel({ count }) { const [prevCount, setPrevCount] = useState(count); const [trend, setTrend] = useState(null); if (prevCount !== count) { setPrevCount(count); setTrend(count > prevCount ? 'increasing' : 'decreasing'); } return ( <> <h1>{count}</h1> {trend && <p>The count is {trend}</p>} </> ); }\nNote that if you call a set\nfunction while rendering, it must be inside a condition like prevCount !== count\n, and there must be a call like setPrevCount(count)\ninside of the condition. Otherwise, your component would re-render in a loop until it crashes. Also, you can only update the state of the currently rendering component like this. Calling the set\nfunction of another component during rendering is an error. Finally, your set\ncall should still update state without mutation \u2014 this doesn\u2019t mean you can break other rules of pure functions.\nThis pattern can be hard to understand and is usually best avoided. However, it\u2019s better than updating state in an effect. When you call the set\nfunction during render, React will re-render that component immediately after your component exits with a return\nstatement, and before rendering the children. This way, children don\u2019t need to render twice. The rest of your component function will still execute (and the result will be thrown away). If your condition is below all the Hook calls, you may add an early return;\nto restart rendering earlier.\nTroubleshooting\nI\u2019ve updated the state, but logging gives me the old value\nCalling the set\nfunction does not change state in the running code:\nfunction handleClick() {\nconsole.log(count); // 0\nsetCount(count + 1); // Request a re-render with 1\nconsole.log(count); // Still 0!\nsetTimeout(() => {\nconsole.log(count); // Also 0!\n}, 5000);\n}\nThis is because states behaves like a snapshot. Updating state requests another render with the new state value, but does not affect the count\nJavaScript variable in your already-running event handler.\nIf you need to use the next state, you can save it in a variable before passing it to the set\nfunction:\nconst nextCount = count + 1;\nsetCount(nextCount);\nconsole.log(count); // 0\nconsole.log(nextCount); // 1\nI\u2019ve updated the state, but the screen doesn\u2019t update\nReact will ignore your update if the next state is equal to the previous state, as determined by an Object.is\ncomparison. This usually happens when you change an object or an array in state directly:\nobj.x = 10; // \ud83d\udea9 Wrong: mutating existing object\nsetObj(obj); // \ud83d\udea9 Doesn't do anything\nYou mutated an existing obj\nobject and passed it back to setObj\n, so React ignored the update. To fix this, you need to ensure that you\u2019re always replacing objects and arrays in state instead of mutating them:\n// \u2705 Correct: creating a new object\nsetObj({\n...obj,\nx: 10\n});\nI\u2019m getting an error: \u201cToo many re-renders\u201d\nYou might get an error that says: Too many re-renders. React limits the number of renders to prevent an infinite loop.\nTypically, this means that you\u2019re unconditionally setting state during render, so your component enters a loop: render, set state (which causes a render), render, set state (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:\n// \ud83d\udea9 Wrong: calls the handler during render\nreturn <button onClick={handleClick()}>Click me</button>\n// \u2705 Correct: passes down the event handler\nreturn <button onClick={handleClick}>Click me</button>\n// \u2705 Correct: passes down an inline function\nreturn <button onClick={(e) => handleClick(e)}>Click me</button>\nIf you can\u2019t find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific set\nfunction call responsible for the error.\nMy initializer or updater function runs twice\nIn Strict Mode, React will call some of your functions twice instead of once:\nfunction TodoList() {\n// This component function will run twice for every render.\nconst [todos, setTodos] = useState(() => {\n// This initializer function will run twice during initialization.\nreturn createTodos();\n});\nfunction handleClick() {\nsetTodos(prevTodos => {\n// This updater function will run twice for every click.\nreturn [...prevTodos, createTodo()];\n});\n}\n// ...\nThis is expected and shouldn\u2019t break your code.\nThis development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and updater functions are pure, this shouldn\u2019t affect your logic. However, if they are accidentally impure, this helps you notice the mistakes.\nFor example, this impure updater function mutates an array in state:\nsetTodos(prevTodos => {\n// \ud83d\udea9 Mistake: mutating state\nprevTodos.push(createTodo());\n});\nBecause React calls your updater function twice, you\u2019ll see the todo was added twice, so you\u2019ll know that there is a mistake. In this example, you can fix the mistake by replacing the array instead of mutating it:\nsetTodos(prevTodos => {\n// \u2705 Correct: replacing with new state\nreturn [...prevTodos, createTodo()];\n});\nNow that this updater function is pure, calling it an extra time doesn\u2019t make a difference in behavior. This is why React calling it twice helps you find mistakes. Only component, initializer, and updater functions need to be pure. Event handlers don\u2019t need to be pure, so React will never call your event handlers twice.\nRead keeping components pure to learn more.\nI\u2019m trying to set state to a function, but it gets called instead\nYou can\u2019t put a function into state like this:\nconst [fn, setFn] = useState(someFunction);\nfunction handleClick() {\nsetFn(someOtherFunction);\n}\nBecause you\u2019re passing a function, React assumes that someFunction\nis an initializer function, and that someOtherFunction\nis an updater function, so it tries to call them and store the result. To actually store a function, you have to put () =>\nbefore them in both cases. Then React will store the functions you pass.\nconst [fn, setFn] = useState(() => someFunction);\nfunction handleClick() {\nsetFn(() => someOtherFunction);\n}"
  },
  {
    "source": "https://react.dev/reference/react/useSyncExternalStore",
    "title": "useSyncExternalStore \u2013 React",
    "text": "useSyncExternalStore\nuseSyncExternalStore\nis a React Hook that lets you subscribe to an external store.\nconst snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)\nReference\nuseSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)\nCall useSyncExternalStore\nat the top level of your component to read a value from an external data store.\nimport { useSyncExternalStore } from 'react';\nimport { todosStore } from './todoStore.js';\nfunction TodosApp() {\nconst todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);\n// ...\n}\nIt returns the snapshot of the data in the store. You need to pass two functions as arguments:\n- The\nsubscribe\nfunction should subscribe to the store and return a function that unsubscribes. - The\ngetSnapshot\nfunction should read a snapshot of the data from the store.\nParameters\n-\nsubscribe\n: A function that takes a singlecallback\nargument and subscribes it to the store. When the store changes, it should invoke the providedcallback\n, which will cause React to re-callgetSnapshot\nand (if needed) re-render the component. Thesubscribe\nfunction should return a function that cleans up the subscription. -\ngetSnapshot\n: A function that returns a snapshot of the data in the store that\u2019s needed by the component. While the store has not changed, repeated calls togetSnapshot\nmust return the same value. If the store changes and the returned value is different (as compared byObject.is\n), React re-renders the component. -\noptional\ngetServerSnapshot\n: A function that returns the initial snapshot of the data in the store. It will be used only during server rendering and during hydration of server-rendered content on the client. The server snapshot must be the same between the client and the server, and is usually serialized and passed from the server to the client. If you omit this argument, rendering the component on the server will throw an error.\nReturns\nThe current snapshot of the store which you can use in your rendering logic.\nCaveats\n-\nThe store snapshot returned by\ngetSnapshot\nmust be immutable. If the underlying store has mutable data, return a new immutable snapshot if the data has changed. Otherwise, return a cached last snapshot. -\nIf a different\nsubscribe\nfunction is passed during a re-render, React will re-subscribe to the store using the newly passedsubscribe\nfunction. You can prevent this by declaringsubscribe\noutside the component. -\nIf the store is mutated during a non-blocking Transition update, React will fall back to performing that update as blocking. Specifically, for every Transition update, React will call\ngetSnapshot\na second time just before applying changes to the DOM. If it returns a different value than when it was called originally, React will restart the update from scratch, this time applying it as a blocking update, to ensure that every component on screen is reflecting the same version of the store. -\nIt\u2019s not recommended to suspend a render based on a store value returned by\nuseSyncExternalStore\n. The reason is that mutations to the external store cannot be marked as non-blocking Transition updates, so they will trigger the nearestSuspense\nfallback, replacing already-rendered content on screen with a loading spinner, which typically makes a poor UX.For example, the following are discouraged:\nconst LazyProductDetailPage = lazy(() => import('./ProductDetailPage.js'));function ShoppingApp() {const selectedProductId = useSyncExternalStore(...);// \u274c Calling `use` with a Promise dependent on `selectedProductId`const data = use(fetchItem(selectedProductId))// \u274c Conditionally rendering a lazy component based on `selectedProductId`return selectedProductId != null ? <LazyProductDetailPage /> : <FeaturedProducts />;}\nUsage\nSubscribing to an external store\nMost of your React components will only read data from their props, state, and context. However, sometimes a component needs to read some data from some store outside of React that changes over time. This includes:\n- Third-party state management libraries that hold state outside of React.\n- Browser APIs that expose a mutable value and events to subscribe to its changes.\nCall useSyncExternalStore\nat the top level of your component to read a value from an external data store.\nimport { useSyncExternalStore } from 'react';\nimport { todosStore } from './todoStore.js';\nfunction TodosApp() {\nconst todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);\n// ...\n}\nIt returns the snapshot of the data in the store. You need to pass two functions as arguments:\n- The\nsubscribe\nfunction should subscribe to the store and return a function that unsubscribes. - The\ngetSnapshot\nfunction should read a snapshot of the data from the store.\nReact will use these functions to keep your component subscribed to the store and re-render it on changes.\nFor example, in the sandbox below, todosStore\nis implemented as an external store that stores data outside of React. The TodosApp\ncomponent connects to that external store with the useSyncExternalStore\nHook.\nimport { useSyncExternalStore } from 'react'; import { todosStore } from './todoStore.js'; export default function TodosApp() { const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot); return ( <> <button onClick={() => todosStore.addTodo()}>Add todo</button> <hr /> <ul> {todos.map(todo => ( <li key={todo.id}>{todo.text}</li> ))} </ul> </> ); }\nSubscribing to a browser API\nAnother reason to add useSyncExternalStore\nis when you want to subscribe to some value exposed by the browser that changes over time. For example, suppose that you want your component to display whether the network connection is active. The browser exposes this information via a property called navigator.onLine\n.\nThis value can change without React\u2019s knowledge, so you should read it with useSyncExternalStore\n.\nimport { useSyncExternalStore } from 'react';\nfunction ChatIndicator() {\nconst isOnline = useSyncExternalStore(subscribe, getSnapshot);\n// ...\n}\nTo implement the getSnapshot\nfunction, read the current value from the browser API:\nfunction getSnapshot() {\nreturn navigator.onLine;\n}\nNext, you need to implement the subscribe\nfunction. For example, when navigator.onLine\nchanges, the browser fires the online\nand offline\nevents on the window\nobject. You need to subscribe the callback\nargument to the corresponding events, and then return a function that cleans up the subscriptions:\nfunction subscribe(callback) {\nwindow.addEventListener('online', callback);\nwindow.addEventListener('offline', callback);\nreturn () => {\nwindow.removeEventListener('online', callback);\nwindow.removeEventListener('offline', callback);\n};\n}\nNow React knows how to read the value from the external navigator.onLine\nAPI and how to subscribe to its changes. Disconnect your device from the network and notice that the component re-renders in response:\nimport { useSyncExternalStore } from 'react'; export default function ChatIndicator() { const isOnline = useSyncExternalStore(subscribe, getSnapshot); return <h1>{isOnline ? '\u2705 Online' : '\u274c Disconnected'}</h1>; } function getSnapshot() { return navigator.onLine; } function subscribe(callback) { window.addEventListener('online', callback); window.addEventListener('offline', callback); return () => { window.removeEventListener('online', callback); window.removeEventListener('offline', callback); }; }\nExtracting the logic to a custom Hook\nUsually you won\u2019t write useSyncExternalStore\ndirectly in your components. Instead, you\u2019ll typically call it from your own custom Hook. This lets you use the same external store from different components.\nFor example, this custom useOnlineStatus\nHook tracks whether the network is online:\nimport { useSyncExternalStore } from 'react';\nexport function useOnlineStatus() {\nconst isOnline = useSyncExternalStore(subscribe, getSnapshot);\nreturn isOnline;\n}\nfunction getSnapshot() {\n// ...\n}\nfunction subscribe(callback) {\n// ...\n}\nNow different components can call useOnlineStatus\nwithout repeating the underlying implementation:\nimport { useOnlineStatus } from './useOnlineStatus.js'; function StatusBar() { const isOnline = useOnlineStatus(); return <h1>{isOnline ? '\u2705 Online' : '\u274c Disconnected'}</h1>; } function SaveButton() { const isOnline = useOnlineStatus(); function handleSaveClick() { console.log('\u2705 Progress saved'); } return ( <button disabled={!isOnline} onClick={handleSaveClick}> {isOnline ? 'Save progress' : 'Reconnecting...'} </button> ); } export default function App() { return ( <> <SaveButton /> <StatusBar /> </> ); }\nAdding support for server rendering\nIf your React app uses server rendering, your React components will also run outside the browser environment to generate the initial HTML. This creates a few challenges when connecting to an external store:\n- If you\u2019re connecting to a browser-only API, it won\u2019t work because it does not exist on the server.\n- If you\u2019re connecting to a third-party data store, you\u2019ll need its data to match between the server and client.\nTo solve these issues, pass a getServerSnapshot\nfunction as the third argument to useSyncExternalStore\n:\nimport { useSyncExternalStore } from 'react';\nexport function useOnlineStatus() {\nconst isOnline = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\nreturn isOnline;\n}\nfunction getSnapshot() {\nreturn navigator.onLine;\n}\nfunction getServerSnapshot() {\nreturn true; // Always show \"Online\" for server-generated HTML\n}\nfunction subscribe(callback) {\n// ...\n}\nThe getServerSnapshot\nfunction is similar to getSnapshot\n, but it runs only in two situations:\n- It runs on the server when generating the HTML.\n- It runs on the client during hydration, i.e. when React takes the server HTML and makes it interactive.\nThis lets you provide the initial snapshot value which will be used before the app becomes interactive. If there is no meaningful initial value for the server rendering, omit this argument to force rendering on the client.\nTroubleshooting\nI\u2019m getting an error: \u201cThe result of getSnapshot\nshould be cached\u201d\nThis error means your getSnapshot\nfunction returns a new object every time it\u2019s called, for example:\nfunction getSnapshot() {\n// \ud83d\udd34 Do not return always different objects from getSnapshot\nreturn {\ntodos: myStore.todos\n};\n}\nReact will re-render the component if getSnapshot\nreturn value is different from the last time. This is why, if you always return a different value, you will enter an infinite loop and get this error.\nYour getSnapshot\nobject should only return a different object if something has actually changed. If your store contains immutable data, you can return that data directly:\nfunction getSnapshot() {\n// \u2705 You can return immutable data\nreturn myStore.todos;\n}\nIf your store data is mutable, your getSnapshot\nfunction should return an immutable snapshot of it. This means it does need to create new objects, but it shouldn\u2019t do this for every single call. Instead, it should store the last calculated snapshot, and return the same snapshot as the last time if the data in the store has not changed. How you determine whether mutable data has changed depends on your mutable store.\nMy subscribe\nfunction gets called after every re-render\nThis subscribe\nfunction is defined inside a component so it is different on every re-render:\nfunction ChatIndicator() {\nconst isOnline = useSyncExternalStore(subscribe, getSnapshot);\n// \ud83d\udea9 Always a different function, so React will resubscribe on every re-render\nfunction subscribe() {\n// ...\n}\n// ...\n}\nReact will resubscribe to your store if you pass a different subscribe\nfunction between re-renders. If this causes performance issues and you\u2019d like to avoid resubscribing, move the subscribe\nfunction outside:\nfunction ChatIndicator() {\nconst isOnline = useSyncExternalStore(subscribe, getSnapshot);\n// ...\n}\n// \u2705 Always the same function, so React won't need to resubscribe\nfunction subscribe() {\n// ...\n}\nAlternatively, wrap subscribe\ninto useCallback\nto only resubscribe when some argument changes:\nfunction ChatIndicator({ userId }) {\nconst isOnline = useSyncExternalStore(subscribe, getSnapshot);\n// \u2705 Same function as long as userId doesn't change\nconst subscribe = useCallback(() => {\n// ...\n}, [userId]);\n// ...\n}"
  },
  {
    "source": "https://react.dev/reference/react/useTransition",
    "title": "useTransition \u2013 React",
    "text": "useTransition\nuseTransition\nis a React Hook that lets you render a part of the UI in the background.\nconst [isPending, startTransition] = useTransition()\n- Reference\n- Usage\n- Troubleshooting\n- Updating an input in a Transition doesn\u2019t work\n- React doesn\u2019t treat my state update as a Transition\n- React doesn\u2019t treat my state update after\nawait\nas a Transition - I want to call\nuseTransition\nfrom outside a component - The function I pass to\nstartTransition\nexecutes immediately - My state updates in Transitions are out of order\nReference\nuseTransition()\nCall useTransition\nat the top level of your component to mark some state updates as Transitions.\nimport { useTransition } from 'react';\nfunction TabContainer() {\nconst [isPending, startTransition] = useTransition();\n// ...\n}\nParameters\nuseTransition\ndoes not take any parameters.\nReturns\nuseTransition\nreturns an array with exactly two items:\n- The\nisPending\nflag that tells you whether there is a pending Transition. - The\nstartTransition\nfunction that lets you mark updates as a Transition.\nstartTransition(action)\nThe startTransition\nfunction returned by useTransition\nlets you mark an update as a Transition.\nfunction TabContainer() {\nconst [isPending, startTransition] = useTransition();\nconst [tab, setTab] = useState('about');\nfunction selectTab(nextTab) {\nstartTransition(() => {\nsetTab(nextTab);\n});\n}\n// ...\n}\nParameters\naction\n: A function that updates some state by calling one or moreset\nfunctions. React callsaction\nimmediately with no parameters and marks all state updates scheduled synchronously during theaction\nfunction call as Transitions. Any async calls that are awaited in theaction\nwill be included in the Transition, but currently require wrapping anyset\nfunctions after theawait\nin an additionalstartTransition\n(see Troubleshooting). State updates marked as Transitions will be non-blocking and will not display unwanted loading indicators.\nReturns\nstartTransition\ndoes not return anything.\nCaveats\n-\nuseTransition\nis a Hook, so it can only be called inside components or custom Hooks. If you need to start a Transition somewhere else (for example, from a data library), call the standalonestartTransition\ninstead. -\nYou can wrap an update into a Transition only if you have access to the\nset\nfunction of that state. If you want to start a Transition in response to some prop or a custom Hook value, tryuseDeferredValue\ninstead. -\nThe function you pass to\nstartTransition\nis called immediately, marking all state updates that happen while it executes as Transitions. If you try to perform state updates in asetTimeout\n, for example, they won\u2019t be marked as Transitions. -\nYou must wrap any state updates after any async requests in another\nstartTransition\nto mark them as Transitions. This is a known limitation that we will fix in the future (see Troubleshooting). -\nThe\nstartTransition\nfunction has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do. Learn more about removing Effect dependencies. -\nA state update marked as a Transition will be interrupted by other state updates. For example, if you update a chart component inside a Transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input update.\n-\nTransition updates can\u2019t be used to control text inputs.\n-\nIf there are multiple ongoing Transitions, React currently batches them together. This is a limitation that may be removed in a future release.\nUsage\nPerform non-blocking updates with Actions\nCall useTransition\nat the top of your component to create Actions, and access the pending state:\nimport {useState, useTransition} from 'react';\nfunction CheckoutForm() {\nconst [isPending, startTransition] = useTransition();\n// ...\n}\nuseTransition\nreturns an array with exactly two items:\n- The\nisPending\nflag that tells you whether there is a pending Transition. - The\nstartTransition\nfunction that lets you create an Action.\nTo start a Transition, pass a function to startTransition\nlike this:\nimport {useState, useTransition} from 'react';\nimport {updateQuantity} from './api';\nfunction CheckoutForm() {\nconst [isPending, startTransition] = useTransition();\nconst [quantity, setQuantity] = useState(1);\nfunction onSubmit(newQuantity) {\nstartTransition(async function () {\nconst savedQuantity = await updateQuantity(newQuantity);\nstartTransition(() => {\nsetQuantity(savedQuantity);\n});\n});\n}\n// ...\n}\nThe function passed to startTransition\nis called the \u201cAction\u201d. You can update state and (optionally) perform side effects within an Action, and the work will be done in the background without blocking user interactions on the page. A Transition can include multiple Actions, and while a Transition is in progress, your UI stays responsive. For example, if the user clicks a tab but then changes their mind and clicks another tab, the second click will be immediately handled without waiting for the first update to finish.\nTo give the user feedback about in-progress Transitions, to isPending\nstate switches to true\nat the first call to startTransition\n, and stays true\nuntil all Actions complete and the final state is shown to the user. Transitions ensure side effects in Actions to complete in order to prevent unwanted loading indicators, and you can provide immediate feedback while the Transition is in progress with useOptimistic\n.\nExample 1 of 2: Updating the quantity in an Action\nIn this example, the updateQuantity\nfunction simulates a request to the server to update the item\u2019s quantity in the cart. This function is artificially slowed down so that it takes at least a second to complete the request.\nUpdate the quantity multiple times quickly. Notice that the pending \u201cTotal\u201d state is shown while any requests are in progress, and the \u201cTotal\u201d updates only after the final request is complete. Because the update is in an Action, the \u201cquantity\u201d can continue to be updated while the request is in progress.\nimport { useState, useTransition } from \"react\"; import { updateQuantity } from \"./api\"; import Item from \"./Item\"; import Total from \"./Total\"; export default function App({}) { const [quantity, setQuantity] = useState(1); const [isPending, startTransition] = useTransition(); const updateQuantityAction = async newQuantity => { // To access the pending state of a transition, // call startTransition again. startTransition(async () => { const savedQuantity = await updateQuantity(newQuantity); startTransition(() => { setQuantity(savedQuantity); }); }); }; return ( <div> <h1>Checkout</h1> <Item action={updateQuantityAction}/> <hr /> <Total quantity={quantity} isPending={isPending} /> </div> ); }\nThis is a basic example to demonstrate how Actions work, but this example does not handle requests completing out of order. When updating the quantity multiple times, it\u2019s possible for the previous requests to finish after later requests causing the quantity to update out of order. This is a known limitation that we will fix in the future (see Troubleshooting below).\nFor common use cases, React provides built-in abstractions such as:\nThese solutions handle request ordering for you. When using Transitions to build your own custom hooks or libraries that manage async state transitions, you have greater control over the request ordering, but you must handle it yourself.\nExposing action\nprop from components\nYou can expose an action\nprop from a component to allow a parent to call an Action.\nFor example, this TabButton\ncomponent wraps its onClick\nlogic in an action\nprop:\nexport default function TabButton({ action, children, isActive }) {\nconst [isPending, startTransition] = useTransition();\nif (isActive) {\nreturn <b>{children}</b>\n}\nreturn (\n<button onClick={() => {\nstartTransition(() => {\naction();\n});\n}}>\n{children}\n</button>\n);\n}\nBecause the parent component updates its state inside the action\n, that state update gets marked as a Transition. This means you can click on \u201cPosts\u201d and then immediately click \u201cContact\u201d and it does not block user interactions:\nimport { useTransition } from 'react'; export default function TabButton({ action, children, isActive }) { const [isPending, startTransition] = useTransition(); if (isActive) { return <b>{children}</b> } return ( <button onClick={() => { startTransition(() => { action(); }); }}> {children} </button> ); }\nDisplaying a pending visual state\nYou can use the isPending\nboolean value returned by useTransition\nto indicate to the user that a Transition is in progress. For example, the tab button can have a special \u201cpending\u201d visual state:\nfunction TabButton({ action, children, isActive }) {\nconst [isPending, startTransition] = useTransition();\n// ...\nif (isPending) {\nreturn <b className=\"pending\">{children}</b>;\n}\n// ...\nNotice how clicking \u201cPosts\u201d now feels more responsive because the tab button itself updates right away:\nimport { useTransition } from 'react'; export default function TabButton({ action, children, isActive }) { const [isPending, startTransition] = useTransition(); if (isActive) { return <b>{children}</b> } if (isPending) { return <b className=\"pending\">{children}</b>; } return ( <button onClick={() => { startTransition(() => { action(); }); }}> {children} </button> ); }\nPreventing unwanted loading indicators\nIn this example, the PostsTab\ncomponent fetches some data using use. When you click the \u201cPosts\u201d tab, the PostsTab\ncomponent suspends, causing the closest loading fallback to appear:\nimport { Suspense, useState } from 'react'; import TabButton from './TabButton.js'; import AboutTab from './AboutTab.js'; import PostsTab from './PostsTab.js'; import ContactTab from './ContactTab.js'; export default function TabContainer() { const [tab, setTab] = useState('about'); return ( <Suspense fallback={<h1>\ud83c\udf00 Loading...</h1>}> <TabButton isActive={tab === 'about'} action={() => setTab('about')} > About </TabButton> <TabButton isActive={tab === 'posts'} action={() => setTab('posts')} > Posts </TabButton> <TabButton isActive={tab === 'contact'} action={() => setTab('contact')} > Contact </TabButton> <hr /> {tab === 'about' && <AboutTab />} {tab === 'posts' && <PostsTab />} {tab === 'contact' && <ContactTab />} </Suspense> ); }\nHiding the entire tab container to show a loading indicator leads to a jarring user experience. If you add useTransition\nto TabButton\n, you can instead display the pending state in the tab button instead.\nNotice that clicking \u201cPosts\u201d no longer replaces the entire tab container with a spinner:\nimport { useTransition } from 'react'; export default function TabButton({ action, children, isActive }) { const [isPending, startTransition] = useTransition(); if (isActive) { return <b>{children}</b> } if (isPending) { return <b className=\"pending\">{children}</b>; } return ( <button onClick={() => { startTransition(() => { action(); }); }}> {children} </button> ); }\nRead more about using Transitions with Suspense.\nBuilding a Suspense-enabled router\nIf you\u2019re building a React framework or a router, we recommend marking page navigations as Transitions.\nfunction Router() {\nconst [page, setPage] = useState('/');\nconst [isPending, startTransition] = useTransition();\nfunction navigate(url) {\nstartTransition(() => {\nsetPage(url);\n});\n}\n// ...\nThis is recommended for three reasons:\n- Transitions are interruptible, which lets the user click away without waiting for the re-render to complete.\n- Transitions prevent unwanted loading indicators, which lets the user avoid jarring jumps on navigation.\n- Transitions wait for all pending actions which lets the user wait for side effects to complete before the new page is shown.\nHere is a simplified router example using Transitions for navigations.\nimport { Suspense, useState, useTransition } from 'react'; import IndexPage from './IndexPage.js'; import ArtistPage from './ArtistPage.js'; import Layout from './Layout.js'; export default function App() { return ( <Suspense fallback={<BigSpinner />}> <Router /> </Suspense> ); } function Router() { const [page, setPage] = useState('/'); const [isPending, startTransition] = useTransition(); function navigate(url) { startTransition(() => { setPage(url); }); } let content; if (page === '/') { content = ( <IndexPage navigate={navigate} /> ); } else if (page === '/the-beatles') { content = ( <ArtistPage artist={{ id: 'the-beatles', name: 'The Beatles', }} /> ); } return ( <Layout isPending={isPending}> {content} </Layout> ); } function BigSpinner() { return <h2>\ud83c\udf00 Loading...</h2>; }\nDisplaying an error to users with an error boundary\nIf a function passed to startTransition\nthrows an error, you can display an error to your user with an error boundary. To use an error boundary, wrap the component where you are calling the useTransition\nin an error boundary. Once the function passed to startTransition\nerrors, the fallback for the error boundary will be displayed.\nimport { useTransition } from \"react\"; import { ErrorBoundary } from \"react-error-boundary\"; export function AddCommentContainer() { return ( <ErrorBoundary fallback={<p>\u26a0\ufe0fSomething went wrong</p>}> <AddCommentButton /> </ErrorBoundary> ); } function addComment(comment) { // For demonstration purposes to show Error Boundary if (comment == null) { throw new Error(\"Example Error: An error thrown to trigger error boundary\"); } } function AddCommentButton() { const [pending, startTransition] = useTransition(); return ( <button disabled={pending} onClick={() => { startTransition(() => { // Intentionally not passing a comment // so error gets thrown addComment(); }); }} > Add comment </button> ); }\nTroubleshooting\nUpdating an input in a Transition doesn\u2019t work\nYou can\u2019t use a Transition for a state variable that controls an input:\nconst [text, setText] = useState('');\n// ...\nfunction handleChange(e) {\n// \u274c Can't use Transitions for controlled input state\nstartTransition(() => {\nsetText(e.target.value);\n});\n}\n// ...\nreturn <input value={text} onChange={handleChange} />;\nThis is because Transitions are non-blocking, but updating an input in response to the change event should happen synchronously. If you want to run a Transition in response to typing, you have two options:\n- You can declare two separate state variables: one for the input state (which always updates synchronously), and one that you will update in a Transition. This lets you control the input using the synchronous state, and pass the Transition state variable (which will \u201clag behind\u201d the input) to the rest of your rendering logic.\n- Alternatively, you can have one state variable, and add\nuseDeferredValue\nwhich will \u201clag behind\u201d the real value. It will trigger non-blocking re-renders to \u201ccatch up\u201d with the new value automatically.\nReact doesn\u2019t treat my state update as a Transition\nWhen you wrap a state update in a Transition, make sure that it happens during the startTransition\ncall:\nstartTransition(() => {\n// \u2705 Setting state *during* startTransition call\nsetPage('/about');\n});\nThe function you pass to startTransition\nmust be synchronous. You can\u2019t mark an update as a Transition like this:\nstartTransition(() => {\n// \u274c Setting state *after* startTransition call\nsetTimeout(() => {\nsetPage('/about');\n}, 1000);\n});\nInstead, you could do this:\nsetTimeout(() => {\nstartTransition(() => {\n// \u2705 Setting state *during* startTransition call\nsetPage('/about');\n});\n}, 1000);\nReact doesn\u2019t treat my state update after await\nas a Transition\nWhen you use await\ninside a startTransition\nfunction, the state updates that happen after the await\nare not marked as Transitions. You must wrap state updates after each await\nin a startTransition\ncall:\nstartTransition(async () => {\nawait someAsyncFunction();\n// \u274c Not using startTransition after await\nsetPage('/about');\n});\nHowever, this works instead:\nstartTransition(async () => {\nawait someAsyncFunction();\n// \u2705 Using startTransition *after* await\nstartTransition(() => {\nsetPage('/about');\n});\n});\nThis is a JavaScript limitation due to React losing the scope of the async context. In the future, when AsyncContext is available, this limitation will be removed.\nI want to call useTransition\nfrom outside a component\nYou can\u2019t call useTransition\noutside a component because it\u2019s a Hook. In this case, use the standalone startTransition\nmethod instead. It works the same way, but it doesn\u2019t provide the isPending\nindicator.\nThe function I pass to startTransition\nexecutes immediately\nIf you run this code, it will print 1, 2, 3:\nconsole.log(1);\nstartTransition(() => {\nconsole.log(2);\nsetPage('/about');\n});\nconsole.log(3);\nIt is expected to print 1, 2, 3. The function you pass to startTransition\ndoes not get delayed. Unlike with the browser setTimeout\n, it does not run the callback later. React executes your function immediately, but any state updates scheduled while it is running are marked as Transitions. You can imagine that it works like this:\n// A simplified version of how React works\nlet isInsideTransition = false;\nfunction startTransition(scope) {\nisInsideTransition = true;\nscope();\nisInsideTransition = false;\n}\nfunction setState() {\nif (isInsideTransition) {\n// ... schedule a Transition state update ...\n} else {\n// ... schedule an urgent state update ...\n}\n}\nMy state updates in Transitions are out of order\nIf you await\ninside startTransition\n, you might see the updates happen out of order.\nIn this example, the updateQuantity\nfunction simulates a request to the server to update the item\u2019s quantity in the cart. This function artificially returns the every other request after the previous to simulate race conditions for network requests.\nTry updating the quantity once, then update it quickly multiple times. You might see the incorrect total:\nimport { useState, useTransition } from \"react\"; import { updateQuantity } from \"./api\"; import Item from \"./Item\"; import Total from \"./Total\"; export default function App({}) { const [quantity, setQuantity] = useState(1); const [isPending, startTransition] = useTransition(); // Store the actual quantity in separate state to show the mismatch. const [clientQuantity, setClientQuantity] = useState(1); const updateQuantityAction = newQuantity => { setClientQuantity(newQuantity); // Access the pending state of the transition, // by wrapping in startTransition again. startTransition(async () => { const savedQuantity = await updateQuantity(newQuantity); startTransition(() => { setQuantity(savedQuantity); }); }); }; return ( <div> <h1>Checkout</h1> <Item action={updateQuantityAction}/> <hr /> <Total clientQuantity={clientQuantity} savedQuantity={quantity} isPending={isPending} /> </div> ); }\nWhen clicking multiple times, it\u2019s possible for previous requests to finish after later requests. When this happens, React currently has no way to know the intended order. This is because the updates are scheduled asynchronously, and React loses context of the order across the async boundary.\nThis is expected, because Actions within a Transition do not guarantee execution order. For common use cases, React provides higher-level abstractions like useActionState\nand <form>\nactions that handle ordering for you. For advanced use cases, you\u2019ll need to implement your own queuing and abort logic to handle this."
  },
  {
    "source": "https://react.dev/reference/rsc/directives",
    "title": "Directives \u2013 React",
    "text": "Directives\nDirectives provide instructions to bundlers compatible with React Server Components.\nSource code directives\n'use client'\nlets you mark what code runs on the client.'use server'\nmarks server-side functions that can be called from client-side code."
  },
  {
    "source": "https://react.dev/reference/rsc/server-functions",
    "title": "Server Functions \u2013 React",
    "text": "Server Functions\nServer Functions allow Client Components to call async functions executed on the server.\nWhen a Server Functions is defined with the \"use server\"\ndirective, your framework will automatically create a reference to the server function, and pass that reference to the Client Component. When that function is called on the client, React will send a request to the server to execute the function, and return the result.\nServer Functions can be created in Server Components and passed as props to Client Components, or they can be imported and used in Client Components.\nUsage\nCreating a Server Function from a Server Component\nServer Components can define Server Functions with the \"use server\"\ndirective:\n// Server Component\nimport Button from './Button';\nfunction EmptyNote () {\nasync function createNoteAction() {\n// Server Function\n'use server';\nawait db.notes.create();\n}\nreturn <Button onClick={createNoteAction}/>;\n}\nWhen React renders the EmptyNote\nServer Function, it will create a reference to the createNoteAction\nfunction, and pass that reference to the Button\nClient Component. When the button is clicked, React will send a request to the server to execute the createNoteAction\nfunction with the reference provided:\n\"use client\";\nexport default function Button({onClick}) {\nconsole.log(onClick);\n// {$$typeof: Symbol.for(\"react.server.reference\"), $$id: 'createNoteAction'}\nreturn <button onClick={() => onClick()}>Create Empty Note</button>\n}\nFor more, see the docs for \"use server\"\n.\nImporting Server Functions from Client Components\nClient Components can import Server Functions from files that use the \"use server\"\ndirective:\n\"use server\";\nexport async function createNote() {\nawait db.notes.create();\n}\nWhen the bundler builds the EmptyNote\nClient Component, it will create a reference to the createNoteAction\nfunction in the bundle. When the button\nis clicked, React will send a request to the server to execute the createNoteAction\nfunction using the reference provided:\n\"use client\";\nimport {createNote} from './actions';\nfunction EmptyNote() {\nconsole.log(createNote);\n// {$$typeof: Symbol.for(\"react.server.reference\"), $$id: 'createNoteAction'}\n<button onClick={() => createNote()} />\n}\nFor more, see the docs for \"use server\"\n.\nServer Functions with Actions\nServer Functions can be called from Actions on the client:\n\"use server\";\nexport async function updateName(name) {\nif (!name) {\nreturn {error: 'Name is required'};\n}\nawait db.users.updateName(name);\n}\n\"use client\";\nimport {updateName} from './actions';\nfunction UpdateName() {\nconst [name, setName] = useState('');\nconst [error, setError] = useState(null);\nconst [isPending, startTransition] = useTransition();\nconst submitAction = async () => {\nstartTransition(async () => {\nconst {error} = await updateName(name);\nif (!error) {\nsetError(error);\n} else {\nsetName('');\n}\n})\n}\nreturn (\n<form action={submitAction}>\n<input type=\"text\" name=\"name\" disabled={isPending}/>\n{state.error && <span>Failed: {state.error}</span>}\n</form>\n)\n}\nThis allows you to access the isPending\nstate of the Server Function by wrapping it in an Action on the client.\nFor more, see the docs for Calling a Server Function outside of <form>\nServer Functions with Form Actions\nServer Functions work with the new Form features in React 19.\nYou can pass a Server Function to a Form to automatically submit the form to the server:\n\"use client\";\nimport {updateName} from './actions';\nfunction UpdateName() {\nreturn (\n<form action={updateName}>\n<input type=\"text\" name=\"name\" />\n</form>\n)\n}\nWhen the Form submission succeeds, React will automatically reset the form. You can add useActionState\nto access the pending state, last response, or to support progressive enhancement.\nFor more, see the docs for Server Functions in Forms.\nServer Functions with useActionState\nYou can call Server Functions with useActionState\nfor the common case where you just need access to the action pending state and last returned response:\n\"use client\";\nimport {updateName} from './actions';\nfunction UpdateName() {\nconst [state, submitAction, isPending] = useActionState(updateName, {error: null});\nreturn (\n<form action={submitAction}>\n<input type=\"text\" name=\"name\" disabled={isPending}/>\n{state.error && <span>Failed: {state.error}</span>}\n</form>\n);\n}\nWhen using useActionState\nwith Server Functions, React will also automatically replay form submissions entered before hydration finishes. This means users can interact with your app even before the app has hydrated.\nFor more, see the docs for useActionState\n.\nProgressive enhancement with useActionState\nServer Functions also support progressive enhancement with the third argument of useActionState\n.\n\"use client\";\nimport {updateName} from './actions';\nfunction UpdateName() {\nconst [, submitAction] = useActionState(updateName, null, `/name/update`);\nreturn (\n<form action={submitAction}>\n...\n</form>\n);\n}\nWhen the permalink is provided to useActionState\n, React will redirect to the provided URL if the form is submitted before the JavaScript bundle loads.\nFor more, see the docs for useActionState\n."
  },
  {
    "source": "https://react.dev/reference/rsc/server-components",
    "title": "Server Components \u2013 React",
    "text": "Server Components\nServer Components are a new type of Component that renders ahead of time, before bundling, in an environment separate from your client app or SSR server.\nThis separate environment is the \u201cserver\u201d in React Server Components. Server Components can run once at build time on your CI server, or they can be run for each request using a web server.\n- Server Components without a Server\n- Server Components with a Server\n- Adding interactivity to Server Components\n- Async components with Server Components\nServer Components without a Server\nServer components can run at build time to read from the filesystem or fetch static content, so a web server is not required. For example, you may want to read static data from a content management system.\nWithout Server Components, it\u2019s common to fetch static data on the client with an Effect:\n// bundle.js\nimport marked from 'marked'; // 35.9K (11.2K gzipped)\nimport sanitizeHtml from 'sanitize-html'; // 206K (63.3K gzipped)\nfunction Page({page}) {\nconst [content, setContent] = useState('');\n// NOTE: loads *after* first page render.\nuseEffect(() => {\nfetch(`/api/content/${page}`).then((data) => {\nsetContent(data.content);\n});\n}, [page]);\nreturn <div>{sanitizeHtml(marked(content))}</div>;\n}\n// api.js\napp.get(`/api/content/:page`, async (req, res) => {\nconst page = req.params.page;\nconst content = await file.readFile(`${page}.md`);\nres.send({content});\n});\nThis pattern means users need to download and parse an additional 75K (gzipped) of libraries, and wait for a second request to fetch the data after the page loads, just to render static content that will not change for the lifetime of the page.\nWith Server Components, you can render these components once at build time:\nimport marked from 'marked'; // Not included in bundle\nimport sanitizeHtml from 'sanitize-html'; // Not included in bundle\nasync function Page({page}) {\n// NOTE: loads *during* render, when the app is built.\nconst content = await file.readFile(`${page}.md`);\nreturn <div>{sanitizeHtml(marked(content))}</div>;\n}\nThe rendered output can then be server-side rendered (SSR) to HTML and uploaded to a CDN. When the app loads, the client will not see the original Page\ncomponent, or the expensive libraries for rendering the markdown. The client will only see the rendered output:\n<div><!-- html for markdown --></div>\nThis means the content is visible during first page load, and the bundle does not include the expensive libraries needed to render the static content.\nServer Components with a Server\nServer Components can also run on a web server during a request for a page, letting you access your data layer without having to build an API. They are rendered before your application is bundled, and can pass data and JSX as props to Client Components.\nWithout Server Components, it\u2019s common to fetch dynamic data on the client in an Effect:\n// bundle.js\nfunction Note({id}) {\nconst [note, setNote] = useState('');\n// NOTE: loads *after* first render.\nuseEffect(() => {\nfetch(`/api/notes/${id}`).then(data => {\nsetNote(data.note);\n});\n}, [id]);\nreturn (\n<div>\n<Author id={note.authorId} />\n<p>{note}</p>\n</div>\n);\n}\nfunction Author({id}) {\nconst [author, setAuthor] = useState('');\n// NOTE: loads *after* Note renders.\n// Causing an expensive client-server waterfall.\nuseEffect(() => {\nfetch(`/api/authors/${id}`).then(data => {\nsetAuthor(data.author);\n});\n}, [id]);\nreturn <span>By: {author.name}</span>;\n}\n// api\nimport db from './database';\napp.get(`/api/notes/:id`, async (req, res) => {\nconst note = await db.notes.get(id);\nres.send({note});\n});\napp.get(`/api/authors/:id`, async (req, res) => {\nconst author = await db.authors.get(id);\nres.send({author});\n});\nWith Server Components, you can read the data and render it in the component:\nimport db from './database';\nasync function Note({id}) {\n// NOTE: loads *during* render.\nconst note = await db.notes.get(id);\nreturn (\n<div>\n<Author id={note.authorId} />\n<p>{note}</p>\n</div>\n);\n}\nasync function Author({id}) {\n// NOTE: loads *after* Note,\n// but is fast if data is co-located.\nconst author = await db.authors.get(id);\nreturn <span>By: {author.name}</span>;\n}\nThe bundler then combines the data, rendered Server Components and dynamic Client Components into a bundle. Optionally, that bundle can then be server-side rendered (SSR) to create the initial HTML for the page. When the page loads, the browser does not see the original Note\nand Author\ncomponents; only the rendered output is sent to the client:\n<div>\n<span>By: The React Team</span>\n<p>React 19 is...</p>\n</div>\nServer Components can be made dynamic by re-fetching them from a server, where they can access the data and render again. This new application architecture combines the simple \u201crequest/response\u201d mental model of server-centric Multi-Page Apps with the seamless interactivity of client-centric Single-Page Apps, giving you the best of both worlds.\nAdding interactivity to Server Components\nServer Components are not sent to the browser, so they cannot use interactive APIs like useState\n. To add interactivity to Server Components, you can compose them with Client Component using the \"use client\"\ndirective.\nIn the following example, the Notes\nServer Component imports an Expandable\nClient Component that uses state to toggle its expanded\nstate:\n// Server Component\nimport Expandable from './Expandable';\nasync function Notes() {\nconst notes = await db.notes.getAll();\nreturn (\n<div>\n{notes.map(note => (\n<Expandable key={note.id}>\n<p note={note} />\n</Expandable>\n))}\n</div>\n)\n}\n// Client Component\n\"use client\"\nexport default function Expandable({children}) {\nconst [expanded, setExpanded] = useState(false);\nreturn (\n<div>\n<button\nonClick={() => setExpanded(!expanded)}\n>\nToggle\n</button>\n{expanded && children}\n</div>\n)\n}\nThis works by first rendering Notes\nas a Server Component, and then instructing the bundler to create a bundle for the Client Component Expandable\n. In the browser, the Client Components will see output of the Server Components passed as props:\n<head>\n<!-- the bundle for Client Components -->\n<script src=\"bundle.js\" />\n</head>\n<body>\n<div>\n<Expandable key={1}>\n<p>this is the first note</p>\n</Expandable>\n<Expandable key={2}>\n<p>this is the second note</p>\n</Expandable>\n<!--...-->\n</div>\n</body>\nAsync components with Server Components\nServer Components introduce a new way to write Components using async/await. When you await\nin an async component, React will suspend and wait for the promise to resolve before resuming rendering. This works across server/client boundaries with streaming support for Suspense.\nYou can even create a promise on the server, and await it on the client:\n// Server Component\nimport db from './database';\nasync function Page({id}) {\n// Will suspend the Server Component.\nconst note = await db.notes.get(id);\n// NOTE: not awaited, will start here and await on the client.\nconst commentsPromise = db.comments.get(note.id);\nreturn (\n<div>\n{note}\n<Suspense fallback={<p>Loading Comments...</p>}>\n<Comments commentsPromise={commentsPromise} />\n</Suspense>\n</div>\n);\n}\n// Client Component\n\"use client\";\nimport {use} from 'react';\nfunction Comments({commentsPromise}) {\n// NOTE: this will resume the promise from the server.\n// It will suspend until the data is available.\nconst comments = use(commentsPromise);\nreturn comments.map(commment => <p>{comment}</p>);\n}\nThe note\ncontent is important data for the page to render, so we await\nit on the server. The comments are below the fold and lower-priority, so we start the promise on the server, and wait for it on the client with the use\nAPI. This will Suspend on the client, without blocking the note\ncontent from rendering.\nSince async components are not supported on the client, we await the promise with use\n."
  },
  {
    "source": "https://react.dev/reference/rsc/server-functions",
    "title": "Server Functions \u2013 React",
    "text": "Server Functions\nServer Functions allow Client Components to call async functions executed on the server.\nWhen a Server Functions is defined with the \"use server\"\ndirective, your framework will automatically create a reference to the server function, and pass that reference to the Client Component. When that function is called on the client, React will send a request to the server to execute the function, and return the result.\nServer Functions can be created in Server Components and passed as props to Client Components, or they can be imported and used in Client Components.\nUsage\nCreating a Server Function from a Server Component\nServer Components can define Server Functions with the \"use server\"\ndirective:\n// Server Component\nimport Button from './Button';\nfunction EmptyNote () {\nasync function createNoteAction() {\n// Server Function\n'use server';\nawait db.notes.create();\n}\nreturn <Button onClick={createNoteAction}/>;\n}\nWhen React renders the EmptyNote\nServer Function, it will create a reference to the createNoteAction\nfunction, and pass that reference to the Button\nClient Component. When the button is clicked, React will send a request to the server to execute the createNoteAction\nfunction with the reference provided:\n\"use client\";\nexport default function Button({onClick}) {\nconsole.log(onClick);\n// {$$typeof: Symbol.for(\"react.server.reference\"), $$id: 'createNoteAction'}\nreturn <button onClick={() => onClick()}>Create Empty Note</button>\n}\nFor more, see the docs for \"use server\"\n.\nImporting Server Functions from Client Components\nClient Components can import Server Functions from files that use the \"use server\"\ndirective:\n\"use server\";\nexport async function createNote() {\nawait db.notes.create();\n}\nWhen the bundler builds the EmptyNote\nClient Component, it will create a reference to the createNoteAction\nfunction in the bundle. When the button\nis clicked, React will send a request to the server to execute the createNoteAction\nfunction using the reference provided:\n\"use client\";\nimport {createNote} from './actions';\nfunction EmptyNote() {\nconsole.log(createNote);\n// {$$typeof: Symbol.for(\"react.server.reference\"), $$id: 'createNoteAction'}\n<button onClick={() => createNote()} />\n}\nFor more, see the docs for \"use server\"\n.\nServer Functions with Actions\nServer Functions can be called from Actions on the client:\n\"use server\";\nexport async function updateName(name) {\nif (!name) {\nreturn {error: 'Name is required'};\n}\nawait db.users.updateName(name);\n}\n\"use client\";\nimport {updateName} from './actions';\nfunction UpdateName() {\nconst [name, setName] = useState('');\nconst [error, setError] = useState(null);\nconst [isPending, startTransition] = useTransition();\nconst submitAction = async () => {\nstartTransition(async () => {\nconst {error} = await updateName(name);\nif (!error) {\nsetError(error);\n} else {\nsetName('');\n}\n})\n}\nreturn (\n<form action={submitAction}>\n<input type=\"text\" name=\"name\" disabled={isPending}/>\n{state.error && <span>Failed: {state.error}</span>}\n</form>\n)\n}\nThis allows you to access the isPending\nstate of the Server Function by wrapping it in an Action on the client.\nFor more, see the docs for Calling a Server Function outside of <form>\nServer Functions with Form Actions\nServer Functions work with the new Form features in React 19.\nYou can pass a Server Function to a Form to automatically submit the form to the server:\n\"use client\";\nimport {updateName} from './actions';\nfunction UpdateName() {\nreturn (\n<form action={updateName}>\n<input type=\"text\" name=\"name\" />\n</form>\n)\n}\nWhen the Form submission succeeds, React will automatically reset the form. You can add useActionState\nto access the pending state, last response, or to support progressive enhancement.\nFor more, see the docs for Server Functions in Forms.\nServer Functions with useActionState\nYou can call Server Functions with useActionState\nfor the common case where you just need access to the action pending state and last returned response:\n\"use client\";\nimport {updateName} from './actions';\nfunction UpdateName() {\nconst [state, submitAction, isPending] = useActionState(updateName, {error: null});\nreturn (\n<form action={submitAction}>\n<input type=\"text\" name=\"name\" disabled={isPending}/>\n{state.error && <span>Failed: {state.error}</span>}\n</form>\n);\n}\nWhen using useActionState\nwith Server Functions, React will also automatically replay form submissions entered before hydration finishes. This means users can interact with your app even before the app has hydrated.\nFor more, see the docs for useActionState\n.\nProgressive enhancement with useActionState\nServer Functions also support progressive enhancement with the third argument of useActionState\n.\n\"use client\";\nimport {updateName} from './actions';\nfunction UpdateName() {\nconst [, submitAction] = useActionState(updateName, null, `/name/update`);\nreturn (\n<form action={submitAction}>\n...\n</form>\n);\n}\nWhen the permalink is provided to useActionState\n, React will redirect to the provided URL if the form is submitted before the JavaScript bundle loads.\nFor more, see the docs for useActionState\n."
  },
  {
    "source": "https://react.dev/reference/rsc/use-client",
    "title": "'use client' directive \u2013 React",
    "text": "'use client'\n'use client'\nlets you mark what code runs on the client.\nReference\n'use client'\nAdd 'use client'\nat the top of a file to mark the module and its transitive dependencies as client code.\n'use client';\nimport { useState } from 'react';\nimport { formatDate } from './formatters';\nimport Button from './button';\nexport default function RichTextEditor({ timestamp, text }) {\nconst date = formatDate(timestamp);\n// ...\nconst editButton = <Button />;\n// ...\n}\nWhen a file marked with 'use client'\nis imported from a Server Component, compatible bundlers will treat the module import as a boundary between server-run and client-run code.\nAs dependencies of RichTextEditor\n, formatDate\nand Button\nwill also be evaluated on the client regardless of whether their modules contain a 'use client'\ndirective. Note that a single module may be evaluated on the server when imported from server code and on the client when imported from client code.\nCaveats\n'use client'\nmust be at the very beginning of a file, above any imports or other code (comments are OK). They must be written with single or double quotes, but not backticks.- When a\n'use client'\nmodule is imported from another client-rendered module, the directive has no effect. - When a component module contains a\n'use client'\ndirective, any usage of that component is guaranteed to be a Client Component. However, a component can still be evaluated on the client even if it does not have a'use client'\ndirective.- A component usage is considered a Client Component if it is defined in module with\n'use client'\ndirective or when it is a transitive dependency of a module that contains a'use client'\ndirective. Otherwise, it is a Server Component.\n- A component usage is considered a Client Component if it is defined in module with\n- Code that is marked for client evaluation is not limited to components. All code that is a part of the Client module sub-tree is sent to and run by the client.\n- When a server evaluated module imports values from a\n'use client'\nmodule, the values must either be a React component or supported serializable prop values to be passed to a Client Component. Any other use case will throw an exception.\nHow 'use client'\nmarks client code\nIn a React app, components are often split into separate files, or modules.\nFor apps that use React Server Components, the app is server-rendered by default. 'use client'\nintroduces a server-client boundary in the module dependency tree, effectively creating a subtree of Client modules.\nTo better illustrate this, consider the following React Server Components app.\nimport FancyText from './FancyText'; import InspirationGenerator from './InspirationGenerator'; import Copyright from './Copyright'; export default function App() { return ( <> <FancyText title text=\"Get Inspired App\" /> <InspirationGenerator> <Copyright year={2004} /> </InspirationGenerator> </> ); }\nIn the module dependency tree of this example app, the 'use client'\ndirective in InspirationGenerator.js\nmarks that module and all of its transitive dependencies as Client modules. The subtree starting at InspirationGenerator.js\nis now marked as Client modules.\nDuring render, the framework will server-render the root component and continue through the render tree, opting-out of evaluating any code imported from client-marked code.\nThe server-rendered portion of the render tree is then sent to the client. The client, with its client code downloaded, then completes rendering the rest of the tree.\nWe introduce the following definitions:\n- Client Components are components in a render tree that are rendered on the client.\n- Server Components are components in a render tree that are rendered on the server.\nWorking through the example app, App\n, FancyText\nand Copyright\nare all server-rendered and considered Server Components. As InspirationGenerator.js\nand its transitive dependencies are marked as client code, the component InspirationGenerator\nand its child component FancyText\nare Client Components.\nDeep Dive\nBy the above definitions, the component FancyText\nis both a Server and Client Component, how can that be?\nFirst, let\u2019s clarify that the term \u201ccomponent\u201d is not very precise. Here are just two ways \u201ccomponent\u201d can be understood:\n- A \u201ccomponent\u201d can refer to a component definition. In most cases this will be a function.\n// This is a definition of a component\nfunction MyComponent() {\nreturn <p>My Component</p>\n}\n- A \u201ccomponent\u201d can also refer to a component usage of its definition.\nimport MyComponent from './MyComponent';\nfunction App() {\n// This is a usage of a component\nreturn <MyComponent />;\n}\nOften, the imprecision is not important when explaining concepts, but in this case it is.\nWhen we talk about Server or Client Components, we are referring to component usages.\n- If the component is defined in a module with a\n'use client'\ndirective, or the component is imported and called in a Client Component, then the component usage is a Client Component. - Otherwise, the component usage is a Server Component.\nBack to the question of FancyText\n, we see that the component definition does not have a 'use client'\ndirective and it has two usages.\nThe usage of FancyText\nas a child of App\n, marks that usage as a Server Component. When FancyText\nis imported and called under InspirationGenerator\n, that usage of FancyText\nis a Client Component as InspirationGenerator\ncontains a 'use client'\ndirective.\nThis means that the component definition for FancyText\nwill both be evaluated on the server and also downloaded by the client to render its Client Component usage.\nDeep Dive\nBecause Copyright\nis rendered as a child of the Client Component InspirationGenerator\n, you might be surprised that it is a Server Component.\nRecall that 'use client'\ndefines the boundary between server and client code on the module dependency tree, not the render tree.\nIn the module dependency tree, we see that App.js\nimports and calls Copyright\nfrom the Copyright.js\nmodule. As Copyright.js\ndoes not contain a 'use client'\ndirective, the component usage is rendered on the server. App\nis rendered on the server as it is the root component.\nClient Components can render Server Components because you can pass JSX as props. In this case, InspirationGenerator\nreceives Copyright\nas children. However, the InspirationGenerator\nmodule never directly imports the Copyright\nmodule nor calls the component, all of that is done by App\n. In fact, the Copyright\ncomponent is fully executed before InspirationGenerator\nstarts rendering.\nThe takeaway is that a parent-child render relationship between components does not guarantee the same render environment.\nWhen to use 'use client'\nWith 'use client'\n, you can determine when components are Client Components. As Server Components are default, here is a brief overview of the advantages and limitations to Server Components to determine when you need to mark something as client rendered.\nFor simplicity, we talk about Server Components, but the same principles apply to all code in your app that is server run.\nAdvantages of Server Components\n- Server Components can reduce the amount of code sent and run by the client. Only Client modules are bundled and evaluated by the client.\n- Server Components benefit from running on the server. They can access the local filesystem and may experience low latency for data fetches and network requests.\nLimitations of Server Components\n- Server Components cannot support interaction as event handlers must be registered and triggered by a client.\n- For example, event handlers like\nonClick\ncan only be defined in Client Components.\n- For example, event handlers like\n- Server Components cannot use most Hooks.\n- When Server Components are rendered, their output is essentially a list of components for the client to render. Server Components do not persist in memory after render and cannot have their own state.\nSerializable types returned by Server Components\nAs in any React app, parent components pass data to child components. As they are rendered in different environments, passing data from a Server Component to a Client Component requires extra consideration.\nProp values passed from a Server Component to Client Component must be serializable.\nSerializable props include:\n- Primitives\n- Iterables containing serializable values\n- Date\n- Plain objects: those created with object initializers, with serializable properties\n- Functions that are Server Functions\n- Client or Server Component elements (JSX)\n- Promises\nNotably, these are not supported:\n- Functions that are not exported from client-marked modules or marked with\n'use server'\n- Classes\n- Objects that are instances of any class (other than the built-ins mentioned) or objects with a null prototype\n- Symbols not registered globally, ex.\nSymbol('my new symbol')\nUsage\nBuilding with interactivity and state\n'use client'; import { useState } from 'react'; export default function Counter({initialValue = 0}) { const [countValue, setCountValue] = useState(initialValue); const increment = () => setCountValue(countValue + 1); const decrement = () => setCountValue(countValue - 1); return ( <> <h2>Count Value: {countValue}</h2> <button onClick={increment}>+1</button> <button onClick={decrement}>-1</button> </> ); }\nAs Counter\nrequires both the useState\nHook and event handlers to increment or decrement the value, this component must be a Client Component and will require a 'use client'\ndirective at the top.\nIn contrast, a component that renders UI without interaction will not need to be a Client Component.\nimport { readFile } from 'node:fs/promises';\nimport Counter from './Counter';\nexport default async function CounterContainer() {\nconst initialValue = await readFile('/path/to/counter_value');\nreturn <Counter initialValue={initialValue} />\n}\nFor example, Counter\n\u2019s parent component, CounterContainer\n, does not require 'use client'\nas it is not interactive and does not use state. In addition, CounterContainer\nmust be a Server Component as it reads from the local file system on the server, which is possible only in a Server Component.\nThere are also components that don\u2019t use any server or client-only features and can be agnostic to where they render. In our earlier example, FancyText\nis one such component.\nexport default function FancyText({title, text}) {\nreturn title\n? <h1 className='fancy title'>{text}</h1>\n: <h3 className='fancy cursive'>{text}</h3>\n}\nIn this case, we don\u2019t add the 'use client'\ndirective, resulting in FancyText\n\u2019s output (rather than its source code) to be sent to the browser when referenced from a Server Component. As demonstrated in the earlier Inspirations app example, FancyText\nis used as both a Server or Client Component, depending on where it is imported and used.\nBut if FancyText\n\u2019s HTML output was large relative to its source code (including dependencies), it might be more efficient to force it to always be a Client Component. Components that return a long SVG path string are one case where it may be more efficient to force a component to be a Client Component.\nUsing client APIs\nYour React app may use client-specific APIs, such as the browser\u2019s APIs for web storage, audio and video manipulation, and device hardware, among others.\nIn this example, the component uses DOM APIs to manipulate a canvas\nelement. Since those APIs are only available in the browser, it must be marked as a Client Component.\n'use client';\nimport {useRef, useEffect} from 'react';\nexport default function Circle() {\nconst ref = useRef(null);\nuseLayoutEffect(() => {\nconst canvas = ref.current;\nconst context = canvas.getContext('2d');\ncontext.reset();\ncontext.beginPath();\ncontext.arc(100, 75, 50, 0, 2 * Math.PI);\ncontext.stroke();\n});\nreturn <canvas ref={ref} />;\n}\nUsing third-party libraries\nOften in a React app, you\u2019ll leverage third-party libraries to handle common UI patterns or logic.\nThese libraries may rely on component Hooks or client APIs. Third-party components that use any of the following React APIs must run on the client:\n- createContext\nreact\nandreact-dom\nHooks, excludinguse\nanduseId\n- forwardRef\n- memo\n- startTransition\n- If they use client APIs, ex. DOM insertion or native platform views\nIf these libraries have been updated to be compatible with React Server Components, then they will already include 'use client'\nmarkers of their own, allowing you to use them directly from your Server Components. If a library hasn\u2019t been updated, or if a component needs props like event handlers that can only be specified on the client, you may need to add your own Client Component file in between the third-party Client Component and your Server Component where you\u2019d like to use it."
  },
  {
    "source": "https://react.dev/reference/rsc/use-server",
    "title": "'use server' directive \u2013 React",
    "text": "'use server'\n'use server'\nmarks server-side functions that can be called from client-side code.\nReference\n'use server'\nAdd 'use server'\nat the top of an async function body to mark the function as callable by the client. We call these functions Server Functions.\nasync function addToCart(data) {\n'use server';\n// ...\n}\nWhen calling a Server Function on the client, it will make a network request to the server that includes a serialized copy of any arguments passed. If the Server Function returns a value, that value will be serialized and returned to the client.\nInstead of individually marking functions with 'use server'\n, you can add the directive to the top of a file to mark all exports within that file as Server Functions that can be used anywhere, including imported in client code.\nCaveats\n'use server'\nmust be at the very beginning of their function or module; above any other code including imports (comments above directives are OK). They must be written with single or double quotes, not backticks.'use server'\ncan only be used in server-side files. The resulting Server Functions can be passed to Client Components through props. See supported types for serialization.- To import a Server Functions from client code, the directive must be used on a module level.\n- Because the underlying network calls are always asynchronous,\n'use server'\ncan only be used on async functions. - Always treat arguments to Server Functions as untrusted input and authorize any mutations. See security considerations.\n- Server Functions should be called in a Transition. Server Functions passed to\n<form action>\norformAction\nwill automatically be called in a transition. - Server Functions are designed for mutations that update server-side state; they are not recommended for data fetching. Accordingly, frameworks implementing Server Functions typically process one action at a time and do not have a way to cache the return value.\nSecurity considerations\nArguments to Server Functions are fully client-controlled. For security, always treat them as untrusted input, and make sure to validate and escape arguments as appropriate.\nIn any Server Function, make sure to validate that the logged-in user is allowed to perform that action.\nSerializable arguments and return values\nSince client code calls the Server Function over the network, any arguments passed will need to be serializable.\nHere are supported types for Server Function arguments:\n- Primitives\n- Iterables containing serializable values\n- Date\n- FormData instances\n- Plain objects: those created with object initializers, with serializable properties\n- Functions that are Server Functions\n- Promises\nNotably, these are not supported:\n- React elements, or JSX\n- Functions, including component functions or any other function that is not a Server Function\n- Classes\n- Objects that are instances of any class (other than the built-ins mentioned) or objects with a null prototype\n- Symbols not registered globally, ex.\nSymbol('my new symbol')\n- Events from event handlers\nSupported serializable return values are the same as serializable props for a boundary Client Component.\nUsage\nServer Functions in forms\nThe most common use case of Server Functions will be calling functions that mutate data. On the browser, the HTML form element is the traditional approach for a user to submit a mutation. With React Server Components, React introduces first-class support for Server Functions as Actions in forms.\nHere is a form that allows a user to request a username.\n// App.js\nasync function requestUsername(formData) {\n'use server';\nconst username = formData.get('username');\n// ...\n}\nexport default function App() {\nreturn (\n<form action={requestUsername}>\n<input type=\"text\" name=\"username\" />\n<button type=\"submit\">Request</button>\n</form>\n);\n}\nIn this example requestUsername\nis a Server Function passed to a <form>\n. When a user submits this form, there is a network request to the server function requestUsername\n. When calling a Server Function in a form, React will supply the form\u2019s FormData as the first argument to the Server Function.\nBy passing a Server Function to the form action\n, React can progressively enhance the form. This means that forms can be submitted before the JavaScript bundle is loaded.\nHandling return values in forms\nIn the username request form, there might be the chance that a username is not available. requestUsername\nshould tell us if it fails or not.\nTo update the UI based on the result of a Server Function while supporting progressive enhancement, use useActionState\n.\n// requestUsername.js\n'use server';\nexport default async function requestUsername(formData) {\nconst username = formData.get('username');\nif (canRequest(username)) {\n// ...\nreturn 'successful';\n}\nreturn 'failed';\n}\n// UsernameForm.js\n'use client';\nimport { useActionState } from 'react';\nimport requestUsername from './requestUsername';\nfunction UsernameForm() {\nconst [state, action] = useActionState(requestUsername, null, 'n/a');\nreturn (\n<>\n<form action={action}>\n<input type=\"text\" name=\"username\" />\n<button type=\"submit\">Request</button>\n</form>\n<p>Last submission request returned: {state}</p>\n</>\n);\n}\nNote that like most Hooks, useActionState\ncan only be called in client code.\nCalling a Server Function outside of <form>\nServer Functions are exposed server endpoints and can be called anywhere in client code.\nWhen using a Server Function outside a form, call the Server Function in a Transition, which allows you to display a loading indicator, show optimistic state updates, and handle unexpected errors. Forms will automatically wrap Server Functions in transitions.\nimport incrementLike from './actions';\nimport { useState, useTransition } from 'react';\nfunction LikeButton() {\nconst [isPending, startTransition] = useTransition();\nconst [likeCount, setLikeCount] = useState(0);\nconst onClick = () => {\nstartTransition(async () => {\nconst currentCount = await incrementLike();\nsetLikeCount(currentCount);\n});\n};\nreturn (\n<>\n<p>Total Likes: {likeCount}</p>\n<button onClick={onClick} disabled={isPending}>Like</button>;\n</>\n);\n}\n// actions.js\n'use server';\nlet likeCount = 0;\nexport default async function incrementLike() {\nlikeCount++;\nreturn likeCount;\n}\nTo read a Server Function return value, you\u2019ll need to await\nthe promise returned."
  },
  {
    "source": "https://react.dev/reference/rules",
    "title": "Rules of React \u2013 React",
    "text": "Rules of React\nJust as different programming languages have their own ways of expressing concepts, React has its own idioms \u2014 or rules \u2014 for how to express patterns in a way that is easy to understand and yields high-quality applications.\nThis section describes the rules you need to follow to write idiomatic React code. Writing idiomatic React code can help you write well organized, safe, and composable applications. These properties make your app more resilient to changes and makes it easier to work with other developers, libraries, and tools.\nThese rules are known as the Rules of React. They are rules \u2013 and not just guidelines \u2013 in the sense that if they are broken, your app likely has bugs. Your code also becomes unidiomatic and harder to understand and reason about.\nWe strongly recommend using Strict Mode alongside React\u2019s ESLint plugin to help your codebase follow the Rules of React. By following the Rules of React, you\u2019ll be able to find and address these bugs and keep your application maintainable.\nComponents and Hooks must be pure\nPurity in Components and Hooks is a key rule of React that makes your app predictable, easy to debug, and allows React to automatically optimize your code.\n- Components must be idempotent \u2013 React components are assumed to always return the same output with respect to their inputs \u2013 props, state, and context.\n- Side effects must run outside of render \u2013 Side effects should not run in render, as React can render components multiple times to create the best possible user experience.\n- Props and state are immutable \u2013 A component\u2019s props and state are immutable snapshots with respect to a single render. Never mutate them directly.\n- Return values and arguments to Hooks are immutable \u2013 Once values are passed to a Hook, you should not modify them. Like props in JSX, values become immutable when passed to a Hook.\n- Values are immutable after being passed to JSX \u2013 Don\u2019t mutate values after they\u2019ve been used in JSX. Move the mutation before the JSX is created.\nReact calls Components and Hooks\nReact is responsible for rendering components and hooks when necessary to optimize the user experience. It is declarative: you tell React what to render in your component\u2019s logic, and React will figure out how best to display it to your user.\n- Never call component functions directly \u2013 Components should only be used in JSX. Don\u2019t call them as regular functions.\n- Never pass around hooks as regular values \u2013 Hooks should only be called inside of components. Never pass it around as a regular value.\nRules of Hooks\nHooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called. You need to follow the Rules of Hooks when using them.\n- Only call Hooks at the top level \u2013 Don\u2019t call Hooks inside loops, conditions, or nested functions. Instead, always use Hooks at the top level of your React function, before any early returns.\n- Only call Hooks from React functions \u2013 Don\u2019t call Hooks from regular JavaScript functions."
  },
  {
    "source": "https://react.dev/reference/rules/components-and-hooks-must-be-pure",
    "title": "Components and Hooks must be pure \u2013 React",
    "text": "Components and Hooks must be pure\nPure functions only perform a calculation and nothing more. It makes your code easier to understand, debug, and allows React to automatically optimize your components and Hooks correctly.\n- Why does purity matter?\n- Components and Hooks must be idempotent\n- Side effects must run outside of render\n- Props and state are immutable\n- Return values and arguments to Hooks are immutable\n- Values are immutable after being passed to JSX\nWhy does purity matter?\nOne of the key concepts that makes React, React is purity. A pure component or hook is one that is:\n- Idempotent \u2013 You always get the same result every time you run it with the same inputs \u2013 props, state, context for component inputs; and arguments for hook inputs.\n- Has no side effects in render \u2013 Code with side effects should run separately from rendering. For example as an event handler \u2013 where the user interacts with the UI and causes it to update; or as an Effect \u2013 which runs after render.\n- Does not mutate non-local values: Components and Hooks should never modify values that aren\u2019t created locally in render.\nWhen render is kept pure, React can understand how to prioritize which updates are most important for the user to see first. This is made possible because of render purity: since components don\u2019t have side effects in render, React can pause rendering components that aren\u2019t as important to update, and only come back to them later when it\u2019s needed.\nConcretely, this means that rendering logic can be run multiple times in a way that allows React to give your user a pleasant user experience. However, if your component has an untracked side effect \u2013 like modifying the value of a global variable during render \u2013 when React runs your rendering code again, your side effects will be triggered in a way that won\u2019t match what you want. This often leads to unexpected bugs that can degrade how your users experience your app. You can see an example of this in the Keeping Components Pure page.\nHow does React run your code?\nReact is declarative: you tell React what to render, and React will figure out how best to display it to your user. To do this, React has a few phases where it runs your code. You don\u2019t need to know about all of these phases to use React well. But at a high level, you should know about what code runs in render, and what runs outside of it.\nRendering refers to calculating what the next version of your UI should look like. After rendering, Effects are flushed (meaning they are run until there are no more left) and may update the calculation if the Effects have impacts on layout. React takes this new calculation and compares it to the calculation used to create the previous version of your UI, then commits just the minimum changes needed to the DOM (what your user actually sees) to catch it up to the latest version.\nDeep Dive\nOne quick heuristic to tell if code runs during render is to examine where it is: if it\u2019s written at the top level like in the example below, there\u2019s a good chance it runs during render.\nfunction Dropdown() {\nconst selectedItems = new Set(); // created during render\n// ...\n}\nEvent handlers and Effects don\u2019t run in render:\nfunction Dropdown() {\nconst selectedItems = new Set();\nconst onSelect = (item) => {\n// this code is in an event handler, so it's only run when the user triggers this\nselectedItems.add(item);\n}\n}\nfunction Dropdown() {\nconst selectedItems = new Set();\nuseEffect(() => {\n// this code is inside of an Effect, so it only runs after rendering\nlogForAnalytics(selectedItems);\n}, [selectedItems]);\n}\nComponents and Hooks must be idempotent\nComponents must always return the same output with respect to their inputs \u2013 props, state, and context. This is known as idempotency. Idempotency is a term popularized in functional programming. It refers to the idea that you always get the same result every time you run that piece of code with the same inputs.\nThis means that all code that runs during render must also be idempotent in order for this rule to hold. For example, this line of code is not idempotent (and therefore, neither is the component):\nfunction Clock() {\nconst time = new Date(); // \ud83d\udd34 Bad: always returns a different result!\nreturn <span>{time.toLocaleString()}</span>\n}\nnew Date()\nis not idempotent as it always returns the current date and changes its result every time it\u2019s called. When you render the above component, the time displayed on the screen will stay stuck on the time that the component was rendered. Similarly, functions like Math.random()\nalso aren\u2019t idempotent, because they return different results every time they\u2019re called, even when the inputs are the same.\nThis doesn\u2019t mean you shouldn\u2019t use non-idempotent functions like new Date()\nat all \u2013 you should just avoid using them during render. In this case, we can synchronize the latest date to this component using an Effect:\nimport { useState, useEffect } from 'react'; function useTime() { // 1. Keep track of the current date's state. `useState` receives an initializer function as its // initial state. It only runs once when the hook is called, so only the current date at the // time the hook is called is set first. const [time, setTime] = useState(() => new Date()); useEffect(() => { // 2. Update the current date every second using `setInterval`. const id = setInterval(() => { setTime(new Date()); // \u2705 Good: non-idempotent code no longer runs in render }, 1000); // 3. Return a cleanup function so we don't leak the `setInterval` timer. return () => clearInterval(id); }, []); return time; } export default function Clock() { const time = useTime(); return <span>{time.toLocaleString()}</span>; }\nBy wrapping the non-idempotent new Date()\ncall in an Effect, it moves that calculation outside of rendering.\nIf you don\u2019t need to synchronize some external state with React, you can also consider using an event handler if it only needs to be updated in response to a user interaction.\nSide effects must run outside of render\nSide effects should not run in render, as React can render components multiple times to create the best possible user experience.\nWhile render must be kept pure, side effects are necessary at some point in order for your app to do anything interesting, like showing something on the screen! The key point of this rule is that side effects should not run in render, as React can render components multiple times. In most cases, you\u2019ll use event handlers to handle side effects. Using an event handler explicitly tells React that this code doesn\u2019t need to run during render, keeping render pure. If you\u2019ve exhausted all options \u2013 and only as a last resort \u2013 you can also handle side effects using useEffect\n.\nWhen is it okay to have mutation?\nLocal mutation\nOne common example of a side effect is mutation, which in JavaScript refers to changing the value of a non-primitive value. In general, while mutation is not idiomatic in React, local mutation is absolutely fine:\nfunction FriendList({ friends }) {\nconst items = []; // \u2705 Good: locally created\nfor (let i = 0; i < friends.length; i++) {\nconst friend = friends[i];\nitems.push(\n<Friend key={friend.id} friend={friend} />\n); // \u2705 Good: local mutation is okay\n}\nreturn <section>{items}</section>;\n}\nThere is no need to contort your code to avoid local mutation. Array.map\ncould also be used here for brevity, but there is nothing wrong with creating a local array and then pushing items into it during render.\nEven though it looks like we are mutating items\n, the key point to note is that this code only does so locally \u2013 the mutation isn\u2019t \u201cremembered\u201d when the component is rendered again. In other words, items\nonly stays around as long as the component does. Because items\nis always recreated every time <FriendList />\nis rendered, the component will always return the same result.\nOn the other hand, if items\nwas created outside of the component, it holds on to its previous values and remembers changes:\nconst items = []; // \ud83d\udd34 Bad: created outside of the component\nfunction FriendList({ friends }) {\nfor (let i = 0; i < friends.length; i++) {\nconst friend = friends[i];\nitems.push(\n<Friend key={friend.id} friend={friend} />\n); // \ud83d\udd34 Bad: mutates a value created outside of render\n}\nreturn <section>{items}</section>;\n}\nWhen <FriendList />\nruns again, we will continue appending friends\nto items\nevery time that component is run, leading to multiple duplicated results. This version of <FriendList />\nhas observable side effects during render and breaks the rule.\nLazy initialization\nLazy initialization is also fine despite not being fully \u201cpure\u201d:\nfunction ExpenseForm() {\nSuperCalculator.initializeIfNotReady(); // \u2705 Good: if it doesn't affect other components\n// Continue rendering...\n}\nChanging the DOM\nSide effects that are directly visible to the user are not allowed in the render logic of React components. In other words, merely calling a component function shouldn\u2019t by itself produce a change on the screen.\nfunction ProductDetailPage({ product }) {\ndocument.title = product.title; // \ud83d\udd34 Bad: Changes the DOM\n}\nOne way to achieve the desired result of updating document.title\noutside of render is to synchronize the component with document\n.\nAs long as calling a component multiple times is safe and doesn\u2019t affect the rendering of other components, React doesn\u2019t care if it\u2019s 100% pure in the strict functional programming sense of the word. It is more important that components must be idempotent.\nProps and state are immutable\nA component\u2019s props and state are immutable snapshots. Never mutate them directly. Instead, pass new props down, and use the setter function from useState\n.\nYou can think of the props and state values as snapshots that are updated after rendering. For this reason, you don\u2019t modify the props or state variables directly: instead you pass new props, or use the setter function provided to you to tell React that state needs to update the next time the component is rendered.\nDon\u2019t mutate Props\nProps are immutable because if you mutate them, the application will produce inconsistent output, which can be hard to debug since it may or may not work depending on the circumstance.\nfunction Post({ item }) {\nitem.url = new Url(item.url, base); // \ud83d\udd34 Bad: never mutate props directly\nreturn <Link url={item.url}>{item.title}</Link>;\n}\nfunction Post({ item }) {\nconst url = new Url(item.url, base); // \u2705 Good: make a copy instead\nreturn <Link url={url}>{item.title}</Link>;\n}\nDon\u2019t mutate State\nuseState\nreturns the state variable and a setter to update that state.\nconst [stateVariable, setter] = useState(0);\nRather than updating the state variable in-place, we need to update it using the setter function that is returned by useState\n. Changing values on the state variable doesn\u2019t cause the component to update, leaving your users with an outdated UI. Using the setter function informs React that the state has changed, and that we need to queue a re-render to update the UI.\nfunction Counter() {\nconst [count, setCount] = useState(0);\nfunction handleClick() {\ncount = count + 1; // \ud83d\udd34 Bad: never mutate state directly\n}\nreturn (\n<button onClick={handleClick}>\nYou pressed me {count} times\n</button>\n);\n}\nfunction Counter() {\nconst [count, setCount] = useState(0);\nfunction handleClick() {\nsetCount(count + 1); // \u2705 Good: use the setter function returned by useState\n}\nreturn (\n<button onClick={handleClick}>\nYou pressed me {count} times\n</button>\n);\n}\nReturn values and arguments to Hooks are immutable\nOnce values are passed to a hook, you should not modify them. Like props in JSX, values become immutable when passed to a hook.\nfunction useIconStyle(icon) {\nconst theme = useContext(ThemeContext);\nif (icon.enabled) {\nicon.className = computeStyle(icon, theme); // \ud83d\udd34 Bad: never mutate hook arguments directly\n}\nreturn icon;\n}\nfunction useIconStyle(icon) {\nconst theme = useContext(ThemeContext);\nconst newIcon = { ...icon }; // \u2705 Good: make a copy instead\nif (icon.enabled) {\nnewIcon.className = computeStyle(icon, theme);\n}\nreturn newIcon;\n}\nOne important principle in React is local reasoning: the ability to understand what a component or hook does by looking at its code in isolation. Hooks should be treated like \u201cblack boxes\u201d when they are called. For example, a custom hook might have used its arguments as dependencies to memoize values inside it:\nfunction useIconStyle(icon) {\nconst theme = useContext(ThemeContext);\nreturn useMemo(() => {\nconst newIcon = { ...icon };\nif (icon.enabled) {\nnewIcon.className = computeStyle(icon, theme);\n}\nreturn newIcon;\n}, [icon, theme]);\n}\nIf you were to mutate the Hooks arguments, the custom hook\u2019s memoization will become incorrect, so it\u2019s important to avoid doing that.\nstyle = useIconStyle(icon); // `style` is memoized based on `icon`\nicon.enabled = false; // Bad: \ud83d\udd34 never mutate hook arguments directly\nstyle = useIconStyle(icon); // previously memoized result is returned\nstyle = useIconStyle(icon); // `style` is memoized based on `icon`\nicon = { ...icon, enabled: false }; // Good: \u2705 make a copy instead\nstyle = useIconStyle(icon); // new value of `style` is calculated\nSimilarly, it\u2019s important to not modify the return values of Hooks, as they may have been memoized.\nValues are immutable after being passed to JSX\nDon\u2019t mutate values after they\u2019ve been used in JSX. Move the mutation before the JSX is created.\nWhen you use JSX in an expression, React may eagerly evaluate the JSX before the component finishes rendering. This means that mutating values after they\u2019ve been passed to JSX can lead to outdated UIs, as React won\u2019t know to update the component\u2019s output.\nfunction Page({ colour }) {\nconst styles = { colour, size: \"large\" };\nconst header = <Header styles={styles} />;\nstyles.size = \"small\"; // \ud83d\udd34 Bad: styles was already used in the JSX above\nconst footer = <Footer styles={styles} />;\nreturn (\n<>\n{header}\n<Content />\n{footer}\n</>\n);\n}\nfunction Page({ colour }) {\nconst headerStyles = { colour, size: \"large\" };\nconst header = <Header styles={headerStyles} />;\nconst footerStyles = { colour, size: \"small\" }; // \u2705 Good: we created a new value\nconst footer = <Footer styles={footerStyles} />;\nreturn (\n<>\n{header}\n<Content />\n{footer}\n</>\n);\n}"
  },
  {
    "source": "https://react.dev/reference/rules/react-calls-components-and-hooks",
    "title": "React calls Components and Hooks \u2013 React",
    "text": "React calls Components and Hooks\nReact is responsible for rendering components and Hooks when necessary to optimize the user experience. It is declarative: you tell React what to render in your component\u2019s logic, and React will figure out how best to display it to your user.\nNever call component functions directly\nComponents should only be used in JSX. Don\u2019t call them as regular functions. React should call it.\nReact must decide when your component function is called during rendering. In React, you do this using JSX.\nfunction BlogPost() {\nreturn <Layout><Article /></Layout>; // \u2705 Good: Only use components in JSX\n}\nfunction BlogPost() {\nreturn <Layout>{Article()}</Layout>; // \ud83d\udd34 Bad: Never call them directly\n}\nIf a component contains Hooks, it\u2019s easy to violate the Rules of Hooks when components are called directly in a loop or conditionally.\nLetting React orchestrate rendering also allows a number of benefits:\n- Components become more than functions. React can augment them with features like local state through Hooks that are tied to the component\u2019s identity in the tree.\n- Component types participate in reconciliation. By letting React call your components, you also tell it more about the conceptual structure of your tree. For example, when you move from rendering\n<Feed>\nto the<Profile>\npage, React won\u2019t attempt to re-use them. - React can enhance your user experience. For example, it can let the browser do some work between component calls so that re-rendering a large component tree doesn\u2019t block the main thread.\n- A better debugging story. If components are first-class citizens that the library is aware of, we can build rich developer tools for introspection in development.\n- More efficient reconciliation. React can decide exactly which components in the tree need re-rendering and skip over the ones that don\u2019t. That makes your app faster and more snappy.\nNever pass around Hooks as regular values\nHooks should only be called inside of components or Hooks. Never pass it around as a regular value.\nHooks allow you to augment a component with React features. They should always be called as a function, and never passed around as a regular value. This enables local reasoning, or the ability for developers to understand everything a component can do by looking at that component in isolation.\nBreaking this rule will cause React to not automatically optimize your component.\nDon\u2019t dynamically mutate a Hook\nHooks should be as \u201cstatic\u201d as possible. This means you shouldn\u2019t dynamically mutate them. For example, this means you shouldn\u2019t write higher order Hooks:\nfunction ChatInput() {\nconst useDataWithLogging = withLogging(useData); // \ud83d\udd34 Bad: don't write higher order Hooks\nconst data = useDataWithLogging();\n}\nHooks should be immutable and not be mutated. Instead of mutating a Hook dynamically, create a static version of the Hook with the desired functionality.\nfunction ChatInput() {\nconst data = useDataWithLogging(); // \u2705 Good: Create a new version of the Hook\n}\nfunction useDataWithLogging() {\n// ... Create a new version of the Hook and inline the logic here\n}\nDon\u2019t dynamically use Hooks\nHooks should also not be dynamically used: for example, instead of doing dependency injection in a component by passing a Hook as a value:\nfunction ChatInput() {\nreturn <Button useData={useDataWithLogging} /> // \ud83d\udd34 Bad: don't pass Hooks as props\n}\nYou should always inline the call of the Hook into that component and handle any logic in there.\nfunction ChatInput() {\nreturn <Button />\n}\nfunction Button() {\nconst data = useDataWithLogging(); // \u2705 Good: Use the Hook directly\n}\nfunction useDataWithLogging() {\n// If there's any conditional logic to change the Hook's behavior, it should be inlined into\n// the Hook\n}\nThis way, <Button />\nis much easier to understand and debug. When Hooks are used in dynamic ways, it increases the complexity of your app greatly and inhibits local reasoning, making your team less productive in the long term. It also makes it easier to accidentally break the Rules of Hooks that Hooks should not be called conditionally. If you find yourself needing to mock components for tests, it\u2019s better to mock the server instead to respond with canned data. If possible, it\u2019s also usually more effective to test your app with end-to-end tests."
  },
  {
    "source": "https://react.dev/reference/rules/rules-of-hooks",
    "title": "Rules of Hooks \u2013 React",
    "text": "Rules of Hooks\nHooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called.\nOnly call Hooks at the top level\nFunctions whose names start with use\nare called Hooks in React.\nDon\u2019t call Hooks inside loops, conditions, nested functions, or try\n/catch\n/finally\nblocks. Instead, always use Hooks at the top level of your React function, before any early returns. You can only call Hooks while React is rendering a function component:\n- \u2705 Call them at the top level in the body of a function component.\n- \u2705 Call them at the top level in the body of a custom Hook.\nfunction Counter() {\n// \u2705 Good: top-level in a function component\nconst [count, setCount] = useState(0);\n// ...\n}\nfunction useWindowWidth() {\n// \u2705 Good: top-level in a custom Hook\nconst [width, setWidth] = useState(window.innerWidth);\n// ...\n}\nIt\u2019s not supported to call Hooks (functions starting with use\n) in any other cases, for example:\n- \ud83d\udd34 Do not call Hooks inside conditions or loops.\n- \ud83d\udd34 Do not call Hooks after a conditional\nreturn\nstatement. - \ud83d\udd34 Do not call Hooks in event handlers.\n- \ud83d\udd34 Do not call Hooks in class components.\n- \ud83d\udd34 Do not call Hooks inside functions passed to\nuseMemo\n,useReducer\n, oruseEffect\n. - \ud83d\udd34 Do not call Hooks inside\ntry\n/catch\n/finally\nblocks.\nIf you break these rules, you might see this error.\nfunction Bad({ cond }) {\nif (cond) {\n// \ud83d\udd34 Bad: inside a condition (to fix, move it outside!)\nconst theme = useContext(ThemeContext);\n}\n// ...\n}\nfunction Bad() {\nfor (let i = 0; i < 10; i++) {\n// \ud83d\udd34 Bad: inside a loop (to fix, move it outside!)\nconst theme = useContext(ThemeContext);\n}\n// ...\n}\nfunction Bad({ cond }) {\nif (cond) {\nreturn;\n}\n// \ud83d\udd34 Bad: after a conditional return (to fix, move it before the return!)\nconst theme = useContext(ThemeContext);\n// ...\n}\nfunction Bad() {\nfunction handleClick() {\n// \ud83d\udd34 Bad: inside an event handler (to fix, move it outside!)\nconst theme = useContext(ThemeContext);\n}\n// ...\n}\nfunction Bad() {\nconst style = useMemo(() => {\n// \ud83d\udd34 Bad: inside useMemo (to fix, move it outside!)\nconst theme = useContext(ThemeContext);\nreturn createStyle(theme);\n});\n// ...\n}\nclass Bad extends React.Component {\nrender() {\n// \ud83d\udd34 Bad: inside a class component (to fix, write a function component instead of a class!)\nuseEffect(() => {})\n// ...\n}\n}\nfunction Bad() {\ntry {\n// \ud83d\udd34 Bad: inside try/catch/finally block (to fix, move it outside!)\nconst [x, setX] = useState(0);\n} catch {\nconst [x, setX] = useState(1);\n}\n}\nYou can use the eslint-plugin-react-hooks\nplugin to catch these mistakes.\nOnly call Hooks from React functions\nDon\u2019t call Hooks from regular JavaScript functions. Instead, you can:\n\u2705 Call Hooks from React function components. \u2705 Call Hooks from custom Hooks.\nBy following this rule, you ensure that all stateful logic in a component is clearly visible from its source code.\nfunction FriendList() {\nconst [onlineStatus, setOnlineStatus] = useOnlineStatus(); // \u2705\n}\nfunction setOnlineStatus() { // \u274c Not a component or custom Hook!\nconst [onlineStatus, setOnlineStatus] = useOnlineStatus();\n}"
  }
]
