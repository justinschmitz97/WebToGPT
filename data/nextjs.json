[{"source": "https://nextjs.org/docs/app/api-reference", "title": "App Router: API Reference | Next.js", "text": "API Reference Next.js API reference divided following sections: Directives Directives used modify behavior Next.js application. Components API Reference Next.js built-in components. File Conventions API Reference Next.js File Conventions. Functions API Reference Next.js Functions Hooks. Configuration Learn configure Next.js applications. CLI API Reference Next.js Command Line Interface (CLI) tools. Edge Runtime API Reference Edge Runtime. Turbopack Turbopack incremental bundler optimized JavaScript TypeScript, written Rust, built Next.js. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/cli", "title": "API Reference: CLI | Next.js", "text": "CLI Next.js comes two Command Line Interface (CLI) tools: create-next-app : Quickly create new Next.js application using default template example public GitHub repository.next : Run Next.js development server, build application, more. create-next-app Create Next.js apps using one command create-next-app CLI. next CLI Learn run build application Next.js CLI. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/cli/create-next-app", "title": "CLI: create-next-app | Next.js", "text": "create-next-app create-next-app CLI allow create new Next.js application using default template example public GitHub repository. easiest way get started Next.js. Basic usage: npx create-next-app@latest [project-name] [options] Reference following options available: | Options | Description | |---|---| -h --help | Show available options | -v --version | Output version number | --no-* | Negate default options. E.g. --no-eslint | --ts --typescript | Initialize TypeScript project (default) | --js --javascript | Initialize JavaScript project | --tailwind | Initialize Tailwind CSS config (default) | --eslint | Initialize ESLint config | --app | Initialize App Router project | --src-dir | Initialize inside src/ directory | --turbopack | Enable Turbopack default development | --import-alias <alias-to-configure> | Specify import alias use (default \"@/*\") | --empty | Initialize empty project | --use-npm | Explicitly tell CLI bootstrap application using npm | --use-pnpm | Explicitly tell CLI bootstrap application using pnpm | --use-yarn | Explicitly tell CLI bootstrap application using Yarn | --use-bun | Explicitly tell CLI bootstrap application using Bun | -e --example [name] [github-url] | example bootstrap app | --example-path <path-to-example> | Specify path example separately | --reset-preferences | Explicitly tell CLI reset stored preferences | --skip-install | Explicitly tell CLI skip installing packages | --yes | Use previous preferences defaults options | Examples default template create new app using default template, run following command terminal: npx create-next-app@latest asked following prompts: project named? my-app Would like use TypeScript? / Yes Would like use ESLint? / Yes Would like use Tailwind CSS? / Yes Would like code inside `src/` directory? / Yes Would like use App Router? (recommended) / Yes Would like use Turbopack `next dev`? / Yes Would like customize import alias (`@/*` default)? / Yes answered prompts, new project created chosen configuration. official Next.js example create new app using official Next.js example, use --example flag. example: npx create-next-app@latest --example [example-name] [your-project-name] view list available examples along setup instructions Next.js repository. public GitHub example create new app using public GitHub example, use --example option GitHub repo's URL. example: npx create-next-app@latest --example \"https://github.com/.../\" [your-project-name] helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/cli/next", "title": "CLI: next CLI | Next.js", "text": "next CLI Next.js CLI allows develop, build, start application, more. Basic usage: npx next [command] [options] Reference following options available: | Options | Description | |---|---| -h --help | Shows available options | -v --version | Outputs Next.js version number | Commands following commands available: | Command | Description | |---|---| dev | Starts Next.js development mode Hot Module Reloading, error reporting, more. | build | Creates optimized production build application. Displaying information route. | start | Starts Next.js production mode. application compiled next build first. | info | Prints relevant details current system used report Next.js bugs. | lint | Runs ESLint files /src , /app , /pages , /components , /lib directories. also provides guided setup install required dependencies ESLint already configured application. | telemetry | Allows enable disable Next.js' completely anonymous telemetry collection. | Good know: Running next without command alias fornext dev . next dev options next dev starts application development mode Hot Module Reloading (HMR), error reporting, more. following options available running next dev : | Option | Description | |---|---| -h, --help | Show available options. | [directory] | directory build application. provided, current directory used. | --turbopack | Starts development mode using Turbopack. | -p --port <port> | Specify port number start application. Default: 3000, env: PORT | -H --hostname <hostname> | Specify hostname start application. Useful making application available devices network. Default: 0.0.0.0 | --experimental-https | Starts server HTTPS generates self-signed certificate. | --experimental-https-key <path> | Path HTTPS key file. | --experimental-https-cert <path> | Path HTTPS certificate file. | --experimental-https-ca <path> | Path HTTPS certificate authority file. | --experimental-upload-trace <traceUrl> | Reports subset debugging trace remote HTTP URL. | next build options next build creates optimized production build application. output displays information route. example: Route (app) Size First Load JS \u250c \u25cb /_not-found 0 B 0 kB \u2514 \u0192 /products/[id] 0 B 0 kB \u25cb (Static) prerendered static content \u0192 (Dynamic) server-rendered demand - Size: size assets downloaded navigating page client-side. size route includes dependencies. - First Load JS: size assets downloaded visiting page server. amount JS shared shown separate metric. values compressed gzip. first load indicated green, yellow, red. Aim green performant applications. following options available next build command: | Option | Description | |---|---| -h, --help | Show available options. | [directory] | directory build application. provided, current directory used. | -d --debug | Enables verbose build output. flag enabled additional build output like rewrites, redirects, headers shown. | --profile | Enables production profiling React. | --no-lint | Disables linting. | --no-mangling | Disables mangling. may affect performance used debugging purposes. | --experimental-app-only | Builds App Router routes. | --experimental-build-mode [mode] | Uses experimental build mode. (choices: \"compile\", \"generate\", default: \"default\") | next start options next start starts application production mode. application compiled next build first. following options available next start command: | Option | Description | |---|---| -h --help | Show available options. | [directory] | directory start application. directory provided, current directory used. | -p --port <port> | Specify port number start application. (default: 3000, env: PORT) | -H --hostname <hostname> | Specify hostname start application (default: 0.0.0.0). | --keepAliveTimeout <keepAliveTimeout> | Specify maximum amount milliseconds wait closing inactive connections. | next info options next info prints relevant details current system used report Next.js bugs opening GitHub issue. information includes Operating System platform/arch/version, Binaries (Node.js, npm, Yarn, pnpm), package versions (next , react , react-dom ), more. output look like this: Operating System: Platform: darwin Arch: arm64 Version: Darwin Kernel Version 23.6.0 Available memory (MB): 65536 Available CPU cores: 10 Binaries: Node: 20.12.0 npm: 10.5.0 Yarn: 1.22.19 pnpm: 9.6.0 Relevant Packages: next: 15.0.0-canary.115 // Latest available version detected (15.0.0-canary.115). eslint-config-next: 14.2.5 react: 19.0.0-rc react-dom: 19.0.0 typescript: 5.5.4 Next.js Config: output: N/A following options available next info command: | Option | Description | |---|---| -h --help | Show available options | --verbose | Collects additional information debugging. | next lint options next lint runs ESLint files pages/ , app/ , components/ , lib/ , src/ directories. also provides guided setup install required dependencies ESLint already configured application. following options available next lint command: | Option | Description | |---|---| [directory] | base directory lint application. provided, current directory used. | -d, --dir, <dirs...> | Include directory, directories, run ESLint. | --file, <files...> | Include file, files, run ESLint. | --ext, [exts...] | Specify JavaScript file extensions. (default: [\".js\", \".mjs\", \".cjs\", \".jsx\", \".ts\", \".mts\", \".cts\", \".tsx\"]) | -c, --config, <config> | Uses configuration file, overriding configuration options. | --resolve-plugins-relative-to, <rprt> | Specify directory plugins resolved from. | --strict | Creates .eslintrc.json file using Next.js strict configuration. | --rulesdir, <rulesdir...> | Uses additional rules directory(s). | --fix | Automatically fix linting issues. | --fix-type <fixType> | Specify types fixes apply (e.g., problem, suggestion, layout). | --ignore-path <path> | Specify file ignore. | --no-ignore <path> | Disables --ignore-path option. | --quiet | Reports errors only. | --max-warnings [maxWarnings] | Specify number warnings triggering non-zero exit code. (default: -1) | -o, --output-file, <outputFile> | Specify file write report to. | -f, --format, <format> | Uses specific output format. | --no-inline-config | Prevents comments changing config rules. | --report-unused-disable-directives-severity <level> | Specify severity level unused eslint-disable directives. (choices: \"error\", \"off\", \"warn\") | --no-cache | Disables caching. | --cache-location, <cacheLocation> | Specify location cache. | --cache-strategy, [cacheStrategy] | Specify strategy use detecting changed files cache. (default: \"metadata\") | --error-on-unmatched-pattern | Reports errors file patterns unmatched. | -h, --help | Displays message. | next telemetry options Next.js collects completely anonymous telemetry data general usage. Participation anonymous program optional, opt-out prefer share information. following options available next telemetry command: | Option | Description | |---|---| -h, --help | Show available options. | --enable | Enables Next.js' telemetry collection. | --disable | Disables Next.js' telemetry collection. | Learn Telemetry. Examples Changing default port default, Next.js uses http://localhost:3000 development next start . default port changed -p option, like so: next dev -p 4000 using PORT environment variable: PORT=4000 next dev Good know: PORT cannot set in.env booting HTTP server happens code initialized. Using HTTPS development certain use cases like webhooks authentication, use HTTPS secure environment localhost . Next.js generate self-signed certificate next dev using --experimental-https flag: next dev --experimental-https generated certificate, Next.js development server exist https://localhost:3000 . default port 3000 used unless port specified -p , --port , PORT . also provide custom certificate key --experimental-https-key --experimental-https-cert . Optionally, provide custom CA certificate --experimental-https-ca well. next dev --experimental-https --experimental-https-key ./certificates/localhost-key.pem --experimental-https-cert ./certificates/localhost.pem next dev --experimental-https intended development creates locally trusted certificate mkcert . production, use properly issued certificates trusted authorities. Good know: deploying Vercel, HTTPS automatically configured Next.js application. Configuring timeout downstream proxies deploying Next.js behind downstream proxy (e.g. load-balancer like AWS ELB/ALB), important configure Next's underlying HTTP server keep-alive timeouts larger downstream proxy's timeouts. Otherwise, keep-alive timeout reached given TCP connection, Node.js immediately terminate connection without notifying downstream proxy. results proxy error whenever attempts reuse connection Node.js already terminated. configure timeout values production Next.js server, pass --keepAliveTimeout (in milliseconds) next start , like so: next start --keepAliveTimeout 70000 Passing Node.js arguments pass node arguments next commands. example: NODE_OPTIONS='--throw-deprecation' next NODE_OPTIONS='-r esm' next NODE_OPTIONS='--inspect' next helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/components", "title": "API Reference: Components | Next.js", "text": "Components Font Optimizing loading web fonts built-in `next/font` loaders. Form Learn use `<Form>` component handle form submissions search params updates client-side navigation. Image Optimize Images Next.js Application using built-in `next/image` Component. Link Enable fast client-side navigation built-in `next/link` component. Script Optimize third-party scripts Next.js application using built-in `next/script` Component. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/components/font", "title": "Components: Font | Next.js", "text": "Font Module API reference help understand use next/font/google next/font/local . features usage, please see Optimizing Fonts page. Font Function Arguments usage, review Google Fonts Local Fonts. | Key | font/google | font/local | Type | Required | |---|---|---|---|---| src | String Array Objects | Yes | || weight | String Array | Required/Optional | || style | String Array | - | || subsets | Array Strings | - | || axes | Array Strings | - | || display | String | - | || preload | Boolean | - | || fallback | Array Strings | - | || adjustFontFallback | Boolean String | - | || variable | String | - | || declarations | Array Objects | - | src path font file string array objects (with type Array<{path: string, weight?: string, style?: string}> ) relative directory font loader function called. Used next/font/local - Required Examples: src:'./fonts/my-font.woff2' wheremy-font.woff2 placed directory namedfonts inside theapp directorysrc:[{path: './inter/Inter-Thin.ttf', weight: '100',},{path: './inter/Inter-Regular.ttf',weight: '400',},{path: './inter/Inter-Bold-Italic.ttf', weight: '700',style: 'italic',},] - font loader function called app/page.tsx usingsrc:'../styles/fonts/my-font.ttf' , thenmy-font.ttf placed instyles/fonts root project weight font weight following possibilities: - string possible values weights available specific font range values variable font - array weight values font variable google font. applies next/font/google only. Used next/font/google next/font/local - Required font used variable Examples: weight: '400' : string single weight value - fontInter , possible values are'100' ,'200' ,'300' ,'400' ,'500' ,'600' ,'700' ,'800' ,'900' or'variable' where'variable' default)weight: '100 900' : string range between100 and900 variable fontweight: ['100','400','900'] : array 3 possible values non variable font style font style following possibilities: - string value default value 'normal' - array style values font variable google font. applies next/font/google only. Used next/font/google next/font/local - Optional Examples: style: 'italic' : string - benormal oritalic fornext/font/google style: 'oblique' : string - take value fornext/font/local expected come standard font stylesstyle: ['italic','normal'] : array 2 values fornext/font/google - values fromnormal anditalic subsets font subsets defined array string values names subset would like preloaded. Fonts specified via subsets link preload tag injected head preload option true, default. Used next/font/google - Optional Examples: subsets: ['latin'] : array subsetlatin find list subsets Google Fonts page font. axes variable fonts extra axes included. default, font weight included keep file size down. possible values axes depend specific font. Used next/font/google - Optional Examples: axes: ['slnt'] : array valueslnt theInter variable font hasslnt additionalaxes shown here. find possibleaxes values font using filter Google variable fonts page looking axes thanwght display font display possible string values 'auto' , 'block' , 'swap' , 'fallback' 'optional' default value 'swap' . Used next/font/google next/font/local - Optional Examples: display: 'optional' : string assigned theoptional value preload boolean value specifies whether font preloaded not. default true . Used next/font/google next/font/local - Optional Examples: preload: false fallback fallback font use font cannot loaded. array strings fallback fonts default. - Optional Used next/font/google next/font/local Examples: fallback: ['system-ui', 'arial'] : array setting fallback fonts tosystem-ui orarial adjustFontFallback - next/font/google : boolean value sets whether automatic fallback font used reduce Cumulative Layout Shift. default istrue . - next/font/local : string booleanfalse value sets whether automatic fallback font used reduce Cumulative Layout Shift. possible values are'Arial' ,'Times New Roman' orfalse . default is'Arial' . Used next/font/google next/font/local - Optional Examples: adjustFontFallback: false : fornext/font/google adjustFontFallback: 'Times New Roman' : fornext/font/local variable string value define CSS variable name used style applied CSS variable method. Used next/font/google next/font/local - Optional Examples: variable: '--my-font' : CSS variable--my-font declared declarations array font face descriptor key-value pairs define generated @font-face further. Used next/font/local - Optional Examples: declarations: [{ prop: 'ascent-override', value: '90%' }] Applying Styles apply font styles three ways: className Returns read-only CSS className loaded font passed HTML element. <p className={inter.className}>Hello, Next.js!</p> style Returns read-only CSS style object loaded font passed HTML element, including style.fontFamily access font family name fallback fonts. <p style={inter.style}>Hello World</p> CSS Variables would like set styles external style sheet specify additional options there, use CSS variable method. addition importing font, also import CSS file CSS variable defined set variable option font loader object follows: import { Inter } 'next/font/google' import styles '../styles/component.module.css' const inter = Inter({ variable: '--font-inter', }) use font, set className parent container text would like style font loader's variable value className text styles property external CSS file. <main className={inter.variable}> <p className={styles.text}>Hello World</p> </main> Define text selector class component.module.css CSS file follows: .text { font-family: var(--font-inter); font-weight: 200; font-style: italic; } example above, text Hello World styled using Inter font generated font fallback font-weight: 200 font-style: italic . Using font definitions file Every time call localFont Google font function, font hosted one instance application. Therefore, need use font multiple places, load one place import related font object need it. done using font definitions file. example, create fonts.ts file styles folder root app directory. Then, specify font definitions follows: import { Inter, Lora, Source_Sans_3 } 'next/font/google' import localFont 'next/font/local' // define variable fonts const inter = Inter() const lora = Lora() // define 2 weights non-variable font const sourceCodePro400 = Source_Sans_3({ weight: '400' }) const sourceCodePro700 = Source_Sans_3({ weight: '700' }) // define custom local font GreatVibes-Regular.ttf stored styles folder const greatVibes = localFont({ src: './GreatVibes-Regular.ttf' }) export { inter, lora, sourceCodePro400, sourceCodePro700, greatVibes } use definitions code follows: import { inter, lora, sourceCodePro700, greatVibes } '../styles/fonts' export default function Page() { return ( <div> <p className={inter.className}>Hello world using Inter font</p> <p style={lora.style}>Hello world using Lora font</p> <p className={sourceCodePro700.className}> Hello world using Source_Sans_3 font weight 700 </p> <p className={greatVibes.className}>My title Great Vibes font</p> </div> ) } make easier access font definitions code, define path alias tsconfig.json jsconfig.json files follows: { \"compilerOptions\": { \"paths\": { \"@/fonts\": [\"./styles/fonts\"] } } } import font definition follows: import { greatVibes, sourceCodePro400 } '@/fonts' Version Changes | Version | Changes | |---|---| v13.2.0 | @next/font renamed next/font . Installation longer required. | v13.0.0 | @next/font added. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/components/form", "title": "Components: Form | Next.js", "text": "Form <Form> component extends HTML <form> element provide prefetching loading UI, client-side navigation submission, progressive enhancement. useful forms update URL search params reduces boilerplate code needed achieve above. Basic usage: import Form 'next/form' export default function Page() { return ( <Form action=\"/search\"> {/* submission, input value appended URL, e.g. /search?query=abc */} <input name=\"query\" /> <button type=\"submit\">Submit</button> </Form> ) } Reference behavior <Form> component depends whether action prop passed string function . - action string, the<Form> behaves like native HTML form uses aGET method. form data encoded URL search params, form submitted, navigates specified URL. addition, Next.js:- Prefetches path form becomes visible, preloads shared UI (e.g. layout.js andloading.js ), resulting faster navigation. - Performs client-side navigation instead full page reload form submitted. retains shared UI client-side state. - Prefetches path form becomes visible, preloads shared UI (e.g. - action function (Server Action),<Form> behaves like React form, executing action form submitted. action (string) Props action string, <Form> component supports following props: | Prop | Example | Type | Required | |---|---|---|---| action | action=\"/search\" | string (URL relative path) | Yes | replace | replace={false} | boolean | - | scroll | scroll={true} | boolean | - | prefetch | prefetch={true} | boolean | - | action : URL path navigate form submitted.- empty string \"\" navigate route updated search params. - empty string replace : Replaces current history state instead pushing new one browser's history stack. Default isfalse .scroll : Controls scroll behavior navigation. Defaults totrue , means scroll top new route, maintain scroll position backwards forwards navigation.prefetch : Controls whether path prefetched form becomes visible user's viewport. Defaults totrue . action (function) Props action function, <Form> component supports following prop: | Prop | Example | Type | Required | |---|---|---|---| action | action={myAction} | function (Server Action) | Yes | action : Server Action called form submitted. See React docs more. Good know: action function, thereplace andscroll props ignored. Caveats formAction : used a<button> or<input type=\"submit\"> fields override theaction prop. Next.js perform client-side navigation, however, approach support prefetching.- using basePath , must also include theformAction path. e.g.formAction=\"/base-path/search\" . - using key : Passing akey prop stringaction supported. like trigger re-render perform mutation, consider using functionaction instead. onSubmit : used handle form submission logic. However, callingevent.preventDefault() override<Form> behavior navigating specified URL.method ,encType ,target : supported override<Form> behavior.- Similarly, formMethod ,formEncType , andformTarget used override themethod ,encType , andtarget props respectively, using fallback native browser behavior. - need use props, use HTML <form> element instead. - Similarly, <input type=\"file\"> : Using input type theaction string match browser behavior submitting filename instead file object. Examples Search form leads search result page create search form navigates search results page passing path action : import Form 'next/form' export default function Page() { return ( <Form action=\"/search\"> <input name=\"query\" /> <button type=\"submit\">Submit</button> </Form> ) } user updates query input field submits form, form data encoded URL search params, e.g. /search?query=abc . Good know: pass empty string \"\" toaction , form navigate route updated search params. results page, access query using searchParams page.js prop use fetch data external source. import { getSearchResults } '@/lib/search' export default async function SearchPage({ searchParams, }: { searchParams: Promise<{ [key: string]: string | string[] | undefined }> }) { const results = await getSearchResults((await searchParams).query) return <div>...</div> } <Form> becomes visible user's viewport, shared UI (such layout.js loading.js ) /search page prefetched. submission, form immediately navigate new route show loading UI results fetched. design fallback UI using loading.js : export default function Loading() { return <div>Loading...</div> } cover cases shared UI yet loaded, show instant feedback user using useFormStatus . First, create component displays loading state form pending: 'use client' import { useFormStatus } 'react-dom' export default function SearchButton() { const status = useFormStatus() return ( <button type=\"submit\">{status.pending ? 'Searching...' : 'Search'}</button> ) } Then, update search form page use SearchButton component: import Form 'next/form' import { SearchButton } '@/ui/search-button' export default function Page() { return ( <Form action=\"/search\"> <input name=\"query\" /> <SearchButton /> </Form> ) } Mutations Server Actions perform mutations passing function action prop. import Form 'next/form' import { createPost } '@/posts/actions' export default function Page() { return ( <Form action={createPost}> <input name=\"title\" /> {/* ... */} <button type=\"submit\">Create Post</button> </Form> ) } mutation, common redirect new resource. use redirect function next/navigation navigate new post page. Good know: Since \"destination\" form submission known action executed, <Form> cannot automatically prefetch shared UI. 'use server' import { redirect } 'next/navigation' export async function createPost(formData: FormData) { // Create new post // ... // Redirect new post redirect(`/posts/${data.id}`) } Then, new page, fetch data using params prop: import { getPost } '@/posts/data' export default async function PostPage({ params, }: { params: Promise<{ id: string }> }) { const data = await getPost((await params).id) return ( <div> <h1>{data.title}</h1> {/* ... */} </div> ) } See Server Actions docs examples. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/components/image", "title": "Components: Image | Next.js", "text": "Image Examples API reference help understand use props configuration options available Image Component. features usage, please see Image Component page. import Image 'next/image' export default function Page() { return ( <Image src=\"/profile.png\" width={500} height={500} alt=\"Picture author\" /> ) } Props Here's summary props available Image Component: | Prop | Example | Type | Status | |---|---|---|---| src | src=\"/profile.png\" | String | Required | width | width={500} | Integer (px) | Required | height | height={500} | Integer (px) | Required | alt | alt=\"Picture author\" | String | Required | loader | loader={imageLoader} | Function | - | fill | fill={true} | Boolean | - | sizes | sizes=\"(max-width: 768px) 100vw, 33vw\" | String | - | quality | quality={80} | Integer (1-100) | - | priority | priority={true} | Boolean | - | placeholder | placeholder=\"blur\" | String | - | style | style={{objectFit: \"contain\"}} | Object | - | onLoadingComplete | onLoadingComplete={img => done())} | Function | Deprecated | onLoad | onLoad={event => done())} | Function | - | onError | onError(event => fail()} | Function | - | loading | loading=\"lazy\" | String | - | blurDataURL | blurDataURL=\"data:image/jpeg...\" | String | - | overrideSrc | overrideSrc=\"/seo.png\" | String | - | Required Props Image Component requires following properties: src , alt , width height (or fill ). import Image 'next/image' export default function Page() { return ( <div> <Image src=\"/profile.png\" width={500} height={500} alt=\"Picture author\" /> </div> ) } src Must one following: - statically imported image file - path string. either absolute external URL, internal path depending loader prop. using default loader, also consider following source images: - src external URL, must also configure remotePatterns - src animated known format (JPEG, PNG, WebP, AVIF, GIF, TIFF) image served as-is - src SVG format, blocked unless unoptimized ordangerouslyAllowSVG enabled width width property represents intrinsic image width pixels. property used infer correct aspect ratio image avoid layout shift loading. determine rendered size image, controlled CSS, similar width attribute HTML <img> tag. Required, except statically imported images images fill property. height height property represents intrinsic image height pixels. property used infer correct aspect ratio image avoid layout shift loading. determine rendered size image, controlled CSS, similar height attribute HTML <img> tag. Required, except statically imported images images fill property. Good know: - Combined, width andheight properties used determine aspect ratio image used browsers reserve space image loads.- intrinsic size always mean rendered size browser, determined parent container. example, parent container smaller intrinsic size, image scaled fit container. - use fill property width height unknown. alt alt property used describe image screen readers search engines. also fallback text images disabled error occurs loading image. contain text could replace image without changing meaning page. meant supplement image repeat information already provided captions image. image purely decorative intended user, alt property empty string (alt=\"\" ). Optional Props <Image /> component accepts number additional properties beyond required. section describes commonly-used properties Image component. Find details rarely-used properties Advanced Props section. loader custom function used resolve image URLs. loader function returning URL string image, given following parameters: example using custom loader: 'use client' import Image 'next/image' const imageLoader = ({ src, width, quality }) => { return `https://example.com/${src}?w=${width}&q=${quality || 75}` } export default function Page() { return ( <Image loader={imageLoader} src=\"me.png\" alt=\"Picture author\" width={500} height={500} /> ) } Good know: Using props like loader , accept function, requires using Client Components serialize provided function. Alternatively, use loaderFile configuration next.config.js configure every instance next/image application, without passing prop. fill fill={true} // {true} | {false} boolean causes image fill parent element, useful width height unknown. parent element must assign position: \"relative\" , position: \"fixed\" , position: \"absolute\" style. default, img element automatically assigned position: \"absolute\" style. styles applied image, image stretch fit container. may prefer set object-fit: \"contain\" image letterboxed fit container preserve aspect ratio. Alternatively, object-fit: \"cover\" cause image fill entire container cropped preserve aspect ratio. information, see also: sizes string, similar media query, provides information wide image different breakpoints. value sizes greatly affect performance images using fill styled responsive size. sizes property serves two important purposes related image performance: - First, value sizes used browser determine size image download, fromnext/image 's automatically generatedsrcset . browser chooses, yet know size image page, selects image size larger viewport. Thesizes property allows tell browser image actually smaller full screen. specify asizes value image thefill property, default value of100vw (full screen width) used. - Second, sizes property changes behavior automatically generatedsrcset value. nosizes value present, smallsrcset generated, suitable fixed-size image (1x/2x/etc). Ifsizes defined, largesrcset generated, suitable responsive image (640w/750w/etc). thesizes property includes sizes as50vw , represent percentage viewport width, thesrcset trimmed include values small ever necessary. example, know styling cause image full-width mobile devices, 2-column layout tablets, 3-column layout desktop displays, include sizes property following: import Image 'next/image' export default function Page() { return ( <div className=\"grid-element\"> <Image fill src=\"/example.png\" sizes=\"(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw\" /> </div> ) } example sizes could dramatic effect performance metrics. Without 33vw sizes, image selected server would 3 times wide needs be. file size proportional square width, without sizes user would download image that's 9 times larger necessary. Learn srcset sizes : quality quality={75} // {number 1-100} quality optimized image, integer 1 100 , 100 best quality therefore largest file size. Defaults 75 . qualities configuration defined next.config.js , quality prop must match one values defined configuration. Good know: original source image already low quality, setting quality prop high could cause resulting optimized image larger original source image. priority priority={false} // {false} | {true} true, Next.js preload image. Lazy loading automatically disabled images using priority . loading property also used set lazy , priority property can't used. loading property meant advanced use cases. Remove loading priority needed. use priority property image detected Largest Contentful Paint (LCP) element. may appropriate multiple priority images, different images may LCP element different viewport sizes. used image visible fold. Defaults false . placeholder placeholder = 'empty' // \"empty\" | \"blur\" | \"data:image/...\" placeholder use image loading. Possible values blur , empty , data:image/... . Defaults empty . blur , blurDataURL property used placeholder. src object static import imported image .jpg , .png , .webp , .avif , blurDataURL automatically populated, except image detected animated. dynamic images, must provide blurDataURL property. Solutions Plaiceholder help base64 generation. data:image/... , Data URL used placeholder image loading. empty , placeholder image loading, empty space. Try out: - Demo blur placeholder - Demo shimmer effect data URL placeholder prop - Demo color effect blurDataURL prop Advanced Props cases, may need advanced usage. <Image /> component optionally accepts following advanced properties. style Allows passing CSS styles underlying image element. const imageStyle = { borderRadius: '50%', border: '1px solid #fff', } export default function ProfileImage() { return <Image src=\"...\" style={imageStyle} /> } Remember required width height props interact styling. use styling modify image's width, also style height auto preserve intrinsic aspect ratio, image distorted. onLoadingComplete 'use client' <Image onLoadingComplete={(img) => console.log(img.naturalWidth)} /> Warning: Deprecated since Next.js 14 favor onLoad . callback function invoked image completely loaded placeholder removed. callback function called one argument, reference underlying <img> element. Good know: Using props like onLoadingComplete , accept function, requires using Client Components serialize provided function. onLoad <Image onLoad={(e) => console.log(e.target.naturalWidth)} /> callback function invoked image completely loaded placeholder removed. callback function called one argument, Event target references underlying <img> element. Good know: Using props like onLoad , accept function, requires using Client Components serialize provided function. onError <Image onError={(e) => console.error(e.target.id)} /> callback function invoked image fails load. Good know: Using props like onError , accept function, requires using Client Components serialize provided function. loading loading = 'lazy' // {lazy} | {eager} loading behavior image. Defaults lazy . lazy , defer loading image reaches calculated distance viewport. eager , load image immediately. Learn loading attribute. blurDataURL Data URL used placeholder image src image successfully loads. takes effect combined placeholder=\"blur\" . Must base64-encoded image. enlarged blurred, small image (10px less) recommended. Including larger images placeholders may harm application performance. Try out: also generate solid color Data URL match image. unoptimized unoptimized = {false} // {false} | {true} true, source image served as-is src instead changing quality, size, format. Defaults false . useful images benefit optimization small images (less 1KB), vector images (SVG), animated images (GIF). import Image 'next/image' const UnoptimizedImage = (props) => { return <Image {...props} unoptimized /> } Since Next.js 12.3.0, prop assigned images updating next.config.js following configuration: module.exports = { images: { unoptimized: true, }, } overrideSrc providing src prop <Image> component, srcset src attributes generated automatically resulting <img> . <Image src=\"/me.jpg\" /> <img srcset=\" /_next/image?url=%2Fme.jpg&w=640&q=75 1x, /_next/image?url=%2Fme.jpg&w=828&q=75 2x \" src=\"/_next/image?url=%2Fme.jpg&w=828&q=75\" /> cases, desirable src attribute generated may wish override using overrideSrc prop. example, upgrading existing website <img> <Image> , may wish maintain src attribute SEO purposes image ranking avoiding recrawl. <Image src=\"/me.jpg\" overrideSrc=\"/override.jpg\" /> <img srcset=\" /_next/image?url=%2Fme.jpg&w=640&q=75 1x, /_next/image?url=%2Fme.jpg&w=828&q=75 2x \" src=\"/override.jpg\" /> decoding hint browser indicating wait image decoded presenting content updates not. Defaults async . Possible values following: async - Asynchronously decode image allow content rendered completes.sync - Synchronously decode image atomic presentation content.auto - preference decoding mode; browser decides what's best. Learn decoding attribute. Props properties <Image /> component passed underlying img element exception following: srcSet . Use Device Sizes instead. Configuration Options addition props, configure Image Component next.config.js . following options available: localPatterns optionally configure localPatterns next.config.js file order allow specific paths optimized block others paths. module.exports = { images: { localPatterns: [ { pathname: '/assets/images/**', search: '', }, ], }, } Good know: example ensure src property ofnext/image must start with/assets/images/ must query string. Attempting optimize path respond 400 Bad Request. remotePatterns protect application malicious users, configuration required order use external images. ensures external images account served Next.js Image Optimization API. external images configured remotePatterns property next.config.js file, shown below: module.exports = { images: { remotePatterns: [ { protocol: 'https', hostname: 'example.com', port: '', pathname: '/account123/**', search: '', }, ], }, } Good know: example ensure src property ofnext/image must start withhttps://example.com/account123/ must query string. protocol, hostname, port, unmatched path respond 400 Bad Request. example remotePatterns property next.config.js file using wildcard pattern hostname : module.exports = { images: { remotePatterns: [ { protocol: 'https', hostname: '**.example.com', port: '', search: '', }, ], }, } Good know: example ensure src property ofnext/image must start withhttps://img1.example.com orhttps://me.avatar.example.com number subdomains. cannot port query string. protocol unmatched hostname respond 400 Bad Request. Wildcard patterns used pathname hostname following syntax: * match single path segment subdomain** match number path segments end subdomains beginning ** syntax work middle pattern. Good know: omitting protocol ,port ,pathname , orsearch wildcard** implied. recommended may allow malicious actors optimize urls intend. example remotePatterns property next.config.js file using search : module.exports = { images: { remotePatterns: [ { protocol: 'https', hostname: 'assets.example.com', search: '?v=1727111025337', }, ], }, } Good know: example ensure src property ofnext/image must start withhttps://assets.example.com must exact query string?v=1727111025337 . protocol query string respond 400 Bad Request. domains Warning: Deprecated since Next.js 14 favor strict remotePatterns order protect application malicious users. usedomains content served domain. Similar remotePatterns , domains configuration used provide list allowed hostnames external images. However, domains configuration support wildcard pattern matching cannot restrict protocol, port, pathname. example domains property next.config.js file: module.exports = { images: { domains: ['assets.acme.com'], }, } loaderFile want use cloud provider optimize images instead using Next.js built-in Image Optimization API, configure loaderFile next.config.js like following: module.exports = { images: { loader: 'custom', loaderFile: './my/image/loader.js', }, } must point file relative root Next.js application. file must export default function returns string, example: 'use client' export default function myImageLoader({ src, width, quality }) { return `https://example.com/${src}?w=${width}&q=${quality || 75}` } Alternatively, use loader prop configure instance next/image . Examples: Good know: Customizing image loader file, accepts function, requires using Client Components serialize provided function. Advanced following configuration advanced use cases usually necessary. choose configure properties below, override changes Next.js defaults future updates. deviceSizes know expected device widths users, specify list device width breakpoints using deviceSizes property next.config.js . widths used next/image component uses sizes prop ensure correct image served user's device. configuration provided, default used. module.exports = { images: { deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840], }, } imageSizes specify list image widths using images.imageSizes property next.config.js file. widths concatenated array device sizes form full array sizes used generate image srcsets. reason two separate lists imageSizes used images provide sizes prop, indicates image less full width screen. Therefore, sizes imageSizes smaller smallest size deviceSizes. configuration provided, default used. module.exports = { images: { imageSizes: [16, 32, 48, 64, 96, 128, 256, 384], }, } qualities default Image Optimization API automatically allow qualities 1 100. wish restrict allowed qualities, add configuration next.config.js . module.exports = { images: { qualities: [25, 50, 75], }, } example above, three qualities allowed: 25, 50, 75. quality prop match value array, image fail 400 Bad Request. formats default Image Optimization API automatically detect browser's supported image formats via request's Accept header order determine best output format. Accept header matches one configured formats, first match array used. Therefore, array order matters. match (or source image animated), Image Optimization API fallback original image's format. configuration provided, default used. module.exports = { images: { formats: ['image/webp'], }, } enable AVIF support, fallback original format src image browser support AVIF: module.exports = { images: { formats: ['image/avif'], }, } Good know: - still recommend using WebP use cases. - AVIF generally takes 50% longer encode compresses 20% smaller compared WebP. means first time image requested, typically slower subsequent requests cached faster. - self-host Proxy/CDN front Next.js, must configure Proxy forward Accept header. Caching Behavior following describes caching algorithm default loader. loaders, please refer cloud provider's documentation. Images optimized dynamically upon request stored <distDir>/cache/images directory. optimized image file served subsequent requests expiration reached. request made matches cached expired file, expired image served stale immediately. image optimized background (also called revalidation) saved cache new expiration date. cache status image determined reading value x-nextjs-cache response header. possible values following: MISS - path cache (occurs once, first visit)STALE - path cache exceeded revalidate time updated backgroundHIT - path cache exceeded revalidate time expiration (or rather Max Age) defined either minimumCacheTTL configuration upstream image Cache-Control header, whichever larger. Specifically, max-age value Cache-Control header used. s-maxage max-age found, s-maxage preferred. max-age also passed-through downstream clients including CDNs browsers. - configure minimumCacheTTL increase cache duration upstream image includeCache-Control header value low. - configure deviceSizes andimageSizes reduce total number possible generated images. - configure formats disable multiple formats favor single image format. minimumCacheTTL configure Time Live (TTL) seconds cached optimized images. many cases, better use Static Image Import automatically hash file contents cache image forever Cache-Control header immutable . module.exports = { images: { minimumCacheTTL: 60, }, } expiration (or rather Max Age) optimized image defined either minimumCacheTTL upstream image Cache-Control header, whichever larger. need change caching behavior per image, configure headers set Cache-Control header upstream image (e.g. /some-asset.jpg , /_next/image itself). mechanism invalidate cache time, best keep minimumCacheTTL low. Otherwise may need manually change src prop delete <distDir>/cache/images . disableStaticImages default behavior allows import static files import icon './icon.png' pass src property. cases, may wish disable feature conflicts plugins expect import behave differently. disable static image imports inside next.config.js : module.exports = { images: { disableStaticImages: true, }, } dangerouslyAllowSVG default loader optimize SVG images reasons. First, SVG vector format meaning resized losslessly. Second, SVG many features HTML/CSS, lead vulnerabilities without proper Content Security Policy (CSP) headers. Therefore, recommended using unoptimized prop src prop known SVG. happens automatically src ends \".svg\" . However, need serve SVG images default Image Optimization API, set dangerouslyAllowSVG inside next.config.js : module.exports = { images: { dangerouslyAllowSVG: true, contentDispositionType: 'attachment', contentSecurityPolicy: \"default-src 'self'; script-src 'none'; sandbox;\", }, } addition, strongly recommended also set contentDispositionType force browser download image, well contentSecurityPolicy prevent scripts embedded image executing. contentDispositionType default loader sets Content-Disposition header attachment added protection since API serve arbitrary remote images. default value attachment forces browser download image visiting directly. particularly important dangerouslyAllowSVG true. optionally configure inline allow browser render image visiting directly, without downloading it. module.exports = { images: { contentDispositionType: 'inline', }, } Animated Images default loader automatically bypass Image Optimization animated images serve image as-is. Auto-detection animated files best-effort supports GIF, APNG, WebP. want explicitly bypass Image Optimization given animated image, use unoptimized prop. Responsive Images default generated srcset contains 1x 2x images order support different device pixel ratios. However, may wish render responsive image stretches viewport. case, need set sizes well style (or className ). render responsive image using one following methods below. Responsive image using static import source image dynamic, statically import create responsive image: import Image 'next/image' import '../photos/me.jpg' export default function Author() { return ( <Image src={me} alt=\"Picture author\" sizes=\"100vw\" style={{ width: '100%', height: 'auto', }} /> ) } Try out: Responsive image aspect ratio source image dynamic remote url, also need provide width height set correct aspect ratio responsive image: import Image 'next/image' export default function Page({ photoUrl }) { return ( <Image src={photoUrl} alt=\"Picture author\" sizes=\"100vw\" style={{ width: '100%', height: 'auto', }} width={500} height={300} /> ) } Try out: Responsive image fill know aspect ratio, need set fill prop set position: relative parent. Optionally, set object-fit style depending desired stretch vs crop behavior: import Image 'next/image' export default function Page({ photoUrl }) { return ( <div style={{ position: 'relative', width: '300px', height: '500px' }}> <Image src={photoUrl} alt=\"Picture author\" sizes=\"300px\" fill style={{ objectFit: 'contain', }} /> </div> ) } Try out: Theme Detection CSS want display different image light dark mode, create new component wraps two <Image> components reveals correct one based CSS media query. .imgDark { display: none; } @media (prefers-color-scheme: dark) { .imgLight { display: none; } .imgDark { display: unset; } } import styles './theme-image.module.css' import Image, { ImageProps } 'next/image' type Props = Omit<ImageProps, 'src' | 'priority' | 'loading'> & { srcLight: string srcDark: string } const ThemeImage = (props: Props) => { const { srcLight, srcDark, ...rest } = props return ( <> <Image {...rest} src={srcLight} className={styles.imgLight} /> <Image {...rest} src={srcDark} className={styles.imgDark} /> </> ) } Good know: default behavior loading=\"lazy\" ensures correct image loaded. cannot usepriority orloading=\"eager\" would cause images load. Instead, usefetchPriority=\"high\" . Try out: getImageProps advanced use cases, call getImageProps() get props would passed underlying <img> element, instead pass another component, style, canvas, etc. also avoid calling React useState() lead better performance, cannot used placeholder prop placeholder never removed. Theme Detection Picture want display different image light dark mode, use <picture> element display different image based user's preferred color scheme. import { getImageProps } 'next/image' export default function Page() { const common = { alt: 'Theme Example', width: 800, height: 400 } const { props: { srcSet: dark }, } = getImageProps({ ...common, src: '/dark.png' }) const { props: { srcSet: light, ...rest }, } = getImageProps({ ...common, src: '/light.png' }) return ( <picture> <source media=\"(prefers-color-scheme: dark)\" srcSet={dark} /> <source media=\"(prefers-color-scheme: light)\" srcSet={light} /> <img {...rest} /> </picture> ) } Art Direction want display different image mobile desktop, sometimes called Art Direction, provide different src , width , height , quality props getImageProps() . import { getImageProps } 'next/image' export default function Home() { const common = { alt: 'Art Direction Example', sizes: '100vw' } const { props: { srcSet: desktop }, } = getImageProps({ ...common, width: 1440, height: 875, quality: 80, src: '/desktop.jpg', }) const { props: { srcSet: mobile, ...rest }, } = getImageProps({ ...common, width: 750, height: 1334, quality: 70, src: '/mobile.jpg', }) return ( <picture> <source media=\"(min-width: 1000px)\" srcSet={desktop} /> <source media=\"(min-width: 500px)\" srcSet={mobile} /> <img {...rest} style={{ width: '100%', height: 'auto' }} /> </picture> ) } Background CSS even convert srcSet string image-set() CSS function optimize background image. import { getImageProps } 'next/image' function getBackgroundImage(srcSet = '') { const imageSet = srcSet .split(', ') .map((str) => { const [url, dpi] = str.split(' ') return `url(\"${url}\") ${dpi}` }) .join(', ') return `image-set(${imageSet})` } export default function Home() { const { props: { srcSet }, } = getImageProps({ alt: '', width: 128, height: 128, src: '/img.png' }) const backgroundImage = getBackgroundImage(srcSet) const style = { height: '100vh', width: '100vw', backgroundImage } return ( <main style={style}> <h1>Hello World</h1> </main> ) } Known Browser Bugs next/image component uses browser native lazy loading, may fallback eager loading older browsers Safari 15.4. using blur-up placeholder, older browsers Safari 12 fallback empty placeholder. using styles width /height auto , possible cause Layout Shift older browsers Safari 15 preserve aspect ratio. details, see MDN video. - Safari 15 - 16.3 display gray border loading. Safari 16.4 fixed issue. Possible solutions: - Use CSS @supports (font: -apple-system-body) (-webkit-appearance: none) { img[loading=\"lazy\"] { clip-path: inset(0.6px) } } - Use priority image fold - Use CSS - Firefox 67+ displays white background loading. Possible solutions: - Enable AVIF formats - Use placeholder - Enable AVIF Version History | Version | Changes | |---|---| v15.0.0 | contentDispositionType configuration default changed attachment . | v14.2.23 | qualities configuration added. | v14.2.15 | decoding prop added localPatterns configuration added. | v14.2.14 | remotePatterns.search prop added. | v14.2.0 | overrideSrc prop added. | v14.1.0 | getImageProps() stable. | v14.0.0 | onLoadingComplete prop domains config deprecated. | v13.4.14 | placeholder prop support data:/image... | v13.2.0 | contentDispositionType configuration added. | v13.0.6 | ref prop added. | v13.0.0 | next/image import renamed next/legacy/image . next/future/image import renamed next/image . codemod available safely automatically rename imports. <span> wrapper removed. layout , objectFit , objectPosition , lazyBoundary , lazyRoot props removed. alt required. onLoadingComplete receives reference img element. Built-in loader config removed. | v12.3.0 | remotePatterns unoptimized configuration stable. | v12.2.0 | Experimental remotePatterns experimental unoptimized configuration added. layout=\"raw\" removed. | v12.1.1 | style prop added. Experimental support layout=\"raw\" added. | v12.1.0 | dangerouslyAllowSVG contentSecurityPolicy configuration added. | v12.0.9 | lazyRoot prop added. | v12.0.0 | formats configuration added.AVIF support added. Wrapper <div> changed <span> . | v11.1.0 | onLoadingComplete lazyBoundary props added. | v11.0.0 | src prop support static import.placeholder prop added.blurDataURL prop added. | v10.0.5 | loader prop added. | v10.0.1 | layout prop added. | v10.0.0 | next/image introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/components/link", "title": "Components: Link | Next.js", "text": "Link <Link> React component extends HTML <a> element provide prefetching client-side navigation routes. primary way navigate routes Next.js. Basic usage: import Link 'next/link' export default function Page() { return <Link href=\"/dashboard\">Dashboard</Link> } Reference following props passed <Link> component: | Prop | Example | Type | Required | |---|---|---|---| href | href=\"/dashboard\" | String Object | Yes | replace | replace={false} | Boolean | - | scroll | scroll={false} | Boolean | - | prefetch | prefetch={false} | Boolean null | - | Good know: <a> tag attributes asclassName ortarget=\"_blank\" added to<Link> props passed underlying<a> element. href (required) path URL navigate to. import Link 'next/link' // Navigate /about?name=test export default function Page() { return ( <Link href={{ pathname: '/about', query: { name: 'test' }, }} > </Link> ) } replace Defaults false . true , next/link replace current history state instead adding new URL browser's history stack. import Link 'next/link' export default function Page() { return ( <Link href=\"/dashboard\" replace> Dashboard </Link> ) } scroll Defaults true . default scrolling behavior <Link> Next.js maintain scroll position, similar browsers handle back forwards navigation. navigate new Page, scroll position stay long Page visible viewport. However, Page visible viewport, Next.js scroll top first Page element. scroll = {false} , Next.js attempt scroll first Page element. Good know: Next.js checks scroll: false managing scroll behavior. scrolling enabled, identifies relevant DOM node navigation inspects top-level element. non-scrollable elements without rendered HTML bypassed, includes sticky fixed positioned elements, non-visible elements calculated withgetBoundingClientRect . Next.js continues siblings identifies scrollable element visible viewport. import Link 'next/link' export default function Page() { return ( <Link href=\"/dashboard\" scroll={false}> Dashboard </Link> ) } prefetch Prefetching happens <Link /> component enters user's viewport (initially scroll). Next.js prefetches loads linked route (denoted href ) data background improve performance client-side navigations. prefetched data expired time user hovers <Link /> , Next.js attempt prefetch again. Prefetching enabled production. following values passed prefetch prop: null (default): Prefetch behavior depends whether route static dynamic. static routes, full route prefetched (including data). dynamic routes, partial route nearest segment aloading.js boundary prefetched.true : full route prefetched static dynamic routes.false : Prefetching never happen entering viewport hover. import Link 'next/link' export default function Page() { return ( <Link href=\"/dashboard\" prefetch={false}> Dashboard </Link> ) } Examples following examples demonstrate use <Link> component different scenarios. Linking dynamic segments linking dynamic segments, use template literals interpolation generate list links. example, generate list blog posts: import Link 'next/link' interface Post { id: number title: string slug: string } export default function PostList({ posts }: { posts: Post[] }) { return ( <ul> {posts.map((post) => ( <li key={post.id}> <Link href={`/blog/${post.slug}`}>{post.title}</Link> </li> ))} </ul> ) } Checking active links use usePathname() determine link active. example, add class active link, check current pathname matches href link: 'use client' import { usePathname } 'next/navigation' import Link 'next/link' export function Links() { const pathname = usePathname() return ( <nav> <Link className={`link ${pathname === '/' ? 'active' : ''}`} href=\"/\"> Home </Link> <Link className={`link ${pathname === '/about' ? 'active' : ''}`} href=\"/about\" > </Link> </nav> ) } Scrolling id like scroll specific id navigation, append URL # hash link pass hash link href prop. possible since <Link> renders <a> element. <Link href=\"/dashboard#settings\">Settings</Link> // Output <a href=\"/dashboard#settings\">Settings</a> Good know: - Next.js scroll Page visible viewport upon navigation. Linking dynamic route segments dynamic route segments, handy use template literals create link's path. example, generate list links dynamic route app/blog/[slug]/page.js : import Link 'next/link' export default function Page({ posts }) { return ( <ul> {posts.map((post) => ( <li key={post.id}> <Link href={`/blog/${post.slug}`}>{post.title}</Link> </li> ))} </ul> ) } child custom component wraps <a> tag child Link custom component wraps <a> tag, must add passHref Link . necessary you\u2019re using libraries like styled-components. Without this, <a> tag href attribute, hurts site's accessibility might affect SEO. using ESLint, built-in rule next/link-passhref ensure correct usage passHref . import Link 'next/link' import styled 'styled-components' // creates custom component wraps <a> tag const RedLink = styled.a` color: red; ` function NavLink({ href, name }) { return ( <Link href={href} passHref legacyBehavior> <RedLink>{name}</RedLink> </Link> ) } export default NavLink - you\u2019re using emotion\u2019s JSX pragma feature ( @jsx jsx ), must usepassHref even use an<a> tag directly. - component support onClick property trigger navigation correctly. Nesting functional component child Link functional component, addition using passHref legacyBehavior , must wrap component React.forwardRef : import Link 'next/link' import React 'react' // Define props type MyButton interface MyButtonProps { onClick?: React.MouseEventHandler<HTMLAnchorElement> href?: string } // Use React.ForwardRefRenderFunction properly type forwarded ref const MyButton: React.ForwardRefRenderFunction< HTMLAnchorElement, MyButtonProps > = ({ onClick, href }, ref) => { return ( <a href={href} onClick={onClick} ref={ref}> Click </a> ) } // Use React.forwardRef wrap component const ForwardedMyButton = React.forwardRef(MyButton) export default function Page() { return ( <Link href=\"/about\" passHref legacyBehavior> <ForwardedMyButton /> </Link> ) } Replace URL instead push default behavior Link component push new URL history stack. use replace prop prevent adding new entry, following example: import Link 'next/link' export default function Page() { return ( <Link href=\"/about\" replace> us </Link> ) } Disable scrolling top page default scrolling behavior <Link> Next.js maintain scroll position, similar browsers handle back forwards navigation. navigate new Page, scroll position stay long Page visible viewport. However, Page visible viewport, Next.js scroll top first Page element. like disable behavior, pass scroll={false} <Link> component, scroll: false router.push() router.replace() . import Link 'next/link' export default function Page() { return ( <Link href=\"/#hashid\" scroll={false}> Disables scrolling top </Link> ) } Using router.push() router.replace() : // useRouter import { useRouter } 'next/navigation' const router = useRouter() router.push('/dashboard', { scroll: false }) Prefetching links Middleware common use Middleware authentication purposes involve rewriting user different page. order <Link /> component properly prefetch links rewrites via Middleware, need tell Next.js URL display URL prefetch. required avoid un-necessary fetches middleware know correct route prefetch. example, want serve /dashboard route authenticated visitor views, add following Middleware redirect user correct page: import { NextResponse } 'next/server' export function middleware(request: Request) { const nextUrl = request.nextUrl (nextUrl.pathname === '/dashboard') { (request.cookies.authToken) { return NextResponse.rewrite(new URL('/auth/dashboard', request.url)) } else { return NextResponse.rewrite(new URL('/public/dashboard', request.url)) } } } case, would want use following code <Link /> component: 'use client' import Link 'next/link' import useIsAuthed './hooks/useIsAuthed' // auth hook export default function Page() { const isAuthed = useIsAuthed() const path = isAuthed ? '/auth/dashboard' : '/public/dashboard' return ( <Link as=\"/dashboard\" href={path}> Dashboard </Link> ) } Version history | Version | Changes | |---|---| v13.0.0 | longer requires child <a> tag. codemod provided automatically update codebase. | v10.0.0 | href props pointing dynamic route automatically resolved longer require prop. | v8.0.0 | Improved prefetching performance. | v1.0.0 | next/link introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/components/script", "title": "Components: Script | Next.js", "text": "Script API reference help understand use props available Script Component. features usage, please see Optimizing Scripts page. import Script 'next/script' export default function Dashboard() { return ( <> <Script src=\"https://example.com/script.js\" /> </> ) } Props Here's summary props available Script Component: | Prop | Example | Type | Required | |---|---|---|---| src | src=\"http://example.com/script\" | String | Required unless inline script used | strategy | strategy=\"lazyOnload\" | String | - | onLoad | onLoad={onLoadFunc} | Function | - | onReady | onReady={onReadyFunc} | Function | - | onError | onError={onErrorFunc} | Function | - | Required Props <Script /> component requires following properties. src path string specifying URL external script. either absolute external URL internal path. src property required unless inline script used. Optional Props <Script /> component accepts number additional properties beyond required. strategy loading strategy script. four different strategies used: beforeInteractive : Load Next.js code page hydration occurs.afterInteractive : (default) Load early hydration page occurs.lazyOnload : Load browser idle time.worker : (experimental) Load web worker. beforeInteractive Scripts load beforeInteractive strategy injected initial HTML server, downloaded Next.js module, executed order placed hydration occurs page. Scripts denoted strategy preloaded fetched first-party code, execution block page hydration occurring. beforeInteractive scripts must placed inside root layout (app/layout.tsx ) designed load scripts needed entire site (i.e. script load page application loaded server-side). strategy used critical scripts need fetched part page becomes interactive. import Script 'next/script' export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body> {children} <Script src=\"https://example.com/script.js\" strategy=\"beforeInteractive\" /> </body> </html> ) } Good know: Scripts beforeInteractive always injected inside thehead HTML document regardless placed component. examples scripts loaded soon possible beforeInteractive include: - Bot detectors - Cookie consent managers afterInteractive Scripts use afterInteractive strategy injected HTML client-side load (or all) hydration occurs page. default strategy Script component used script needs load soon possible first-party Next.js code. afterInteractive scripts placed inside page layout load execute page (or group pages) opened browser. import Script 'next/script' export default function Page() { return ( <> <Script src=\"https://example.com/script.js\" strategy=\"afterInteractive\" /> </> ) } examples scripts good candidates afterInteractive include: - Tag managers - Analytics lazyOnload Scripts use lazyOnload strategy injected HTML client-side browser idle time load resources page fetched. strategy used background low priority scripts need load early. lazyOnload scripts placed inside page layout load execute page (or group pages) opened browser. import Script 'next/script' export default function Page() { return ( <> <Script src=\"https://example.com/script.js\" strategy=\"lazyOnload\" /> </> ) } Examples scripts need load immediately fetched lazyOnload include: - Chat support plugins - Social media widgets worker Warning: worker strategy yet stable yet work App Router. Use caution. Scripts use worker strategy off-loaded web worker order free main thread ensure critical, first-party resources processed it. strategy used script, advanced use case guaranteed support third-party scripts. use worker strategy, nextScriptWorkers flag must enabled next.config.js : module.exports = { experimental: { nextScriptWorkers: true, }, } worker scripts currently used pages/ directory: import Script 'next/script' export default function Home() { return ( <> <Script src=\"https://example.com/script.js\" strategy=\"worker\" /> </> ) } onLoad Warning: onLoad yet work Server Components used Client Components. Further,onLoad can't used withbeforeInteractive \u2013 consider usingonReady instead. third-party scripts require users run JavaScript code script finished loading order instantiate content call function. loading script either afterInteractive lazyOnload loading strategy, execute code loaded using onLoad property. Here's example executing lodash method library loaded. 'use client' import Script 'next/script' export default function Page() { return ( <> <Script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js\" onLoad={() => { console.log(_.sample([1, 2, 3, 4])) }} /> </> ) } onReady Warning: onReady yet work Server Components used Client Components. third-party scripts require users run JavaScript code script finished loading every time component mounted (after route navigation example). execute code script's load event first loads every subsequent component re-mount using onReady property. Here's example re-instantiate Google Maps JS embed every time component mounted: 'use client' import { useRef } 'react' import Script 'next/script' export default function Page() { const mapRef = useRef() return ( <> <div ref={mapRef}></div> <Script id=\"google-maps\" src=\"https://maps.googleapis.com/maps/api/js\" onReady={() => { new google.maps.Map(mapRef.current, { center: { lat: -34.397, lng: 150.644 }, zoom: 8, }) }} /> </> ) } onError Warning: onError yet work Server Components used Client Components.onError cannot used thebeforeInteractive loading strategy. Sometimes helpful catch script fails load. errors handled onError property: 'use client' import Script 'next/script' export default function Page() { return ( <> <Script src=\"https://example.com/script.js\" onError={(e: Error) => { console.error('Script failed load', e) }} /> </> ) } Version History | Version | Changes | |---|---| v13.0.0 | beforeInteractive afterInteractive modified support app . | v12.2.4 | onReady prop added. | v12.2.2 | Allow next/script beforeInteractive placed _document . | v11.0.0 | next/script introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/directives", "title": "API Reference: Directives | Next.js", "text": "Directives following directives available: use cache Learn use use cache directive cache data Next.js application. use client Learn use use client directive render component client. use server Learn use use server directive execute code server. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/directives/use-cache", "title": "Directives: use cache | Next.js", "text": "use cache use cache directive designates component and/or function cached. used top file indicate exports file cacheable, inline top function component inform Next.js return value cached reused subsequent requests. experimental Next.js feature, native React feature like use client use server . Usage Enable support use cache directive useCache flag next.config.ts file: import type { NextConfig } 'next' const nextConfig: NextConfig = { experimental: { useCache: true, }, } export default nextConfig Additionally, use cache directives also enabled dynamicIO flag set. Then, use use cache directive file, component, function level: // File level 'use cache' export default async function Page() { // ... } // Component level export async function MyComponent() { 'use cache' return <></> } // Function level export async function getData() { 'use cache' const data = await fetch('/api/data') return data } Good know use cache experimental Next.js feature, native React feature likeuse client oruse server .- serializable arguments (or props) passed cached function, well serializable values reads parent scope, converted format like JSON automatically become part cache key. - non-serializable arguments, props, closed-over values turn opaque references inside cached function, passed inspected modified. non-serializable values filled request time become part cache key. - example, cached function take JSX children prop return<div>{children}</div> , able introspect actualchildren object. - example, cached function take JSX - return value cacheable function must also serializable. ensures cached data stored retrieved correctly. - Functions use use cache directive must side-effects, modifying state, directly manipulating DOM, setting timers execute code intervals. - used alongside Partial Prerendering, segments use cache prerendered part static HTML shell. - Unlike unstable_cache supports JSON data,use cache cache serializable data React render, including render output components. Examples Caching entire routes use cache prerender entire route, add use cache top layout page files. segments treated separate entry points application, cached independently. 'use cache' export default function Layout({ children }: { children: ReactNode }) { return <div>{children}</div> } components imported nested page file inherit cache behavior page . 'use cache' async function Users() { const users = await fetch('/api/users') // loop users } export default function Page() { return ( <main> <Users /> </main> ) } recommended applications previously used export const dynamic = \"force-static\" option, ensure entire route prerendered. Caching component output use cache use use cache component level cache fetches computations performed within component. reuse component throughout application share cache entry long props maintain structure. props serialized form part cache key, cache entry reused long serialized props produce value instance. export async function Bookings({ type = 'haircut' }: BookingsProps) { 'use cache' async function getBookingsData() { const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`) return data } return //... } interface BookingsProps { type: string } Caching function output use cache Since add use cache asynchronous function, limited caching components routes only. might want cache network request database query compute something slow. adding use cache function containing type work becomes cacheable, reused, share cache entry. export async function getData() { 'use cache' const data = await fetch('/api/data') return data } Revalidating default, Next.js sets revalidation period 15 minutes use use cache directive. Next.js sets near-infinite expiration duration, meaning suitable content need frequent updates. revalidation period may useful content expect change often, use cacheLife cacheTag APIs configure cache behavior: APIs integrate across client server caching layers, meaning configure caching semantics one place apply everywhere. See cacheLife cacheTag docs information. Interleaving need pass non-serializable arguments cacheable function, pass children . means children reference change without affecting cache entry. export default async function Page() { const uncachedData = await getData() return ( <CacheComponent> <DynamicComponent data={uncachedData} /> </CacheComponent> ) } async function CacheComponent({ children }: { children: ReactNode }) { 'use cache' const cachedData = await fetch('/api/cached-data') return ( <div> <PrerenderedComponent data={cachedData} /> {children} </div> ) } also pass Server Actions cached components Client Components without invoking inside cacheable function. import ClientComponent './ClientComponent' export default async function Page() { const performUpdate = async () => { 'use server' // Perform server-side update await db.update(...) } return <CacheComponent performUpdate={performUpdate} /> } async function CachedComponent({ performUpdate, }: { performUpdate: () => Promise<void> }) { 'use cache' // call performUpdate return <ClientComponent action={performUpdate} /> } 'use client' export default function ClientComponent({ action, }: { action: () => Promise<void> }) { return <button onClick={action}>Update</button> } Related useCache dynamicIO cacheLife cacheTag cacheLife revalidateTag helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/directives/use-client", "title": "Directives: use client | Next.js", "text": "use client use client directive designates component rendered client side used creating interactive user interfaces (UI) require client-side JavaScript capabilities, state management, event handling, access browser APIs. React feature. Usage designate component Client Component, add use client directive top file, imports: app/components/counter.tsx 'use client' import { useState } 'react' export default function Counter() { const [count, setCount] = useState(0) return ( <div> <p>Count: {count}</p> <button onClick={() => setCount(count + 1)}>Increment</button> </div> ) } Nesting Client Components within Server Components Combining Server Client Components allows build applications performant interactive: - Server Components: Use static content, data fetching, SEO-friendly elements. - Client Components: Use interactive elements require state, effects, browser APIs. - Component composition: Nest Client Components within Server Components needed clear separation server client logic. following example: Header Server Component handling static content.Counter Client Component enabling interactivity within page. app/page.tsx import Header './header' import Counter './counter' // Client Component export default function Page() { return ( <div> <Header /> <Counter /> </div> ) } Reference See React documentation information use client . helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/directives/use-server", "title": "Directives: use server | Next.js", "text": "use server use server directive designates function file executed server side. used top file indicate functions file server-side, inline top function mark function Server Function. React feature. Using use server top file following example shows file use server directive top. functions file executed server. 'use server' import { db } '@/lib/db' // database client export async function createUser(data: { name: string; email: string }) { const user = await db.user.create({ data }) return user } Using Server Functions Client Component use Server Functions Client Components need create Server Functions dedicated file using use server directive top file. Server Functions imported Client Server Components executed. Assuming fetchUsers Server Function actions.ts : 'use server' import { db } '@/lib/db' // database client export async function fetchUsers() { const users = await db.user.findMany() return users } import fetchUsers Server Function Client Component execute client-side. 'use client' import { fetchUsers } '../actions' export default function MyButton() { return <button onClick={() => fetchUsers()}>Fetch Users</button> } Using use server inline following example, use server used inline top function mark Server Function: import { db } '@/lib/db' // database client export default function UserList() { async function fetchUsers() { 'use server' const users = await db.user.findMany() return users } return <button onClick={() => fetchUsers()}>Fetch Users</button> } Security considerations using use server directive, important ensure server-side logic secure sensitive data remains protected. Authentication authorization Always authenticate authorize users performing sensitive server-side operations. 'use server' import { db } '@/lib/db' // database client import { authenticate } '@/lib/auth' // authentication library export async function createUser( data: { name: string; email: string }, token: string ) { const user = authenticate(token) (!user) { throw new Error('Unauthorized') } const newUser = await db.user.create({ data }) return newUser } Reference See React documentation information use server . helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/edge", "title": "API Reference: Edge Runtime | Next.js", "text": "Edge Runtime Next.js Edge Runtime used Middleware supports following APIs: Network APIs | API | Description | |---|---| Blob | Represents blob | fetch | Fetches resource | FetchEvent | Represents fetch event | File | Represents file | FormData | Represents form data | Headers | Represents HTTP headers | Request | Represents HTTP request | Response | Represents HTTP response | URLSearchParams | Represents URL search parameters | WebSocket | Represents websocket connection | Encoding APIs | API | Description | |---|---| atob | Decodes base-64 encoded string | btoa | Encodes string base-64 | TextDecoder | Decodes Uint8Array string | TextDecoderStream | Chainable decoder streams | TextEncoder | Encodes string Uint8Array | TextEncoderStream | Chainable encoder streams | Stream APIs | API | Description | |---|---| ReadableStream | Represents readable stream | ReadableStreamBYOBReader | Represents reader ReadableStream | ReadableStreamDefaultReader | Represents reader ReadableStream | TransformStream | Represents transform stream | WritableStream | Represents writable stream | WritableStreamDefaultWriter | Represents writer WritableStream | Crypto APIs | API | Description | |---|---| crypto | Provides access cryptographic functionality platform | CryptoKey | Represents cryptographic key | SubtleCrypto | Provides access common cryptographic primitives, like hashing, signing, encryption decryption | Web Standard APIs | API | Description | |---|---| AbortController | Allows abort one DOM requests desired | Array | Represents array values | ArrayBuffer | Represents generic, fixed-length raw binary data buffer | Atomics | Provides atomic operations static methods | BigInt | Represents whole number arbitrary precision | BigInt64Array | Represents typed array 64-bit signed integers | BigUint64Array | Represents typed array 64-bit unsigned integers | Boolean | Represents logical entity two values: true false | clearInterval | Cancels timed, repeating action previously established call setInterval() | clearTimeout | Cancels timed, repeating action previously established call setTimeout() | console | Provides access browser's debugging console | DataView | Represents generic view ArrayBuffer | Date | Represents single moment time platform-independent format | decodeURI | Decodes Uniform Resource Identifier (URI) previously created encodeURI similar routine | decodeURIComponent | Decodes Uniform Resource Identifier (URI) component previously created encodeURIComponent similar routine | DOMException | Represents error occurs DOM | encodeURI | Encodes Uniform Resource Identifier (URI) replacing instance certain characters one, two, three, four escape sequences representing UTF-8 encoding character | encodeURIComponent | Encodes Uniform Resource Identifier (URI) component replacing instance certain characters one, two, three, four escape sequences representing UTF-8 encoding character | Error | Represents error trying execute statement accessing property | EvalError | Represents error occurs regarding global function eval() | Float32Array | Represents typed array 32-bit floating point numbers | Float64Array | Represents typed array 64-bit floating point numbers | Function | Represents function | Infinity | Represents mathematical Infinity value | Int8Array | Represents typed array 8-bit signed integers | Int16Array | Represents typed array 16-bit signed integers | Int32Array | Represents typed array 32-bit signed integers | Intl | Provides access internationalization localization functionality | isFinite | Determines whether value finite number | isNaN | Determines whether value NaN | JSON | Provides functionality convert JavaScript values JSON format | Map | Represents collection values, value may occur | Math | Provides access mathematical functions constants | Number | Represents numeric value | Object | Represents object base JavaScript objects | parseFloat | Parses string argument returns floating point number | parseInt | Parses string argument returns integer specified radix | Promise | Represents eventual completion (or failure) asynchronous operation, resulting value | Proxy | Represents object used define custom behavior fundamental operations (e.g. property lookup, assignment, enumeration, function invocation, etc) | queueMicrotask | Queues microtask executed | RangeError | Represents error value set range allowed values | ReferenceError | Represents error non-existent variable referenced | Reflect | Provides methods interceptable JavaScript operations | RegExp | Represents regular expression, allowing match combinations characters | Set | Represents collection values, value may occur | setInterval | Repeatedly calls function, fixed time delay call | setTimeout | Calls function evaluates expression specified number milliseconds | SharedArrayBuffer | Represents generic, fixed-length raw binary data buffer | String | Represents sequence characters | structuredClone | Creates deep copy value | Symbol | Represents unique immutable data type used key object property | SyntaxError | Represents error trying interpret syntactically invalid code | TypeError | Represents error value expected type | Uint8Array | Represents typed array 8-bit unsigned integers | Uint8ClampedArray | Represents typed array 8-bit unsigned integers clamped 0-255 | Uint32Array | Represents typed array 32-bit unsigned integers | URIError | Represents error global URI handling function used wrong way | URL | Represents object providing static methods used creating object URLs | URLPattern | Represents URL pattern | URLSearchParams | Represents collection key/value pairs | WeakMap | Represents collection key/value pairs keys weakly referenced | WeakSet | Represents collection objects object may occur | WebAssembly | Provides access WebAssembly | Next.js Specific Polyfills Environment Variables use process.env access Environment Variables next dev next build . Unsupported APIs Edge Runtime restrictions including: - Native Node.js APIs supported. example, can't read write filesystem. node_modules used, long implement ES Modules use native Node.js APIs.- Calling require directly allowed. Use ES Modules instead. following JavaScript language features disabled, work: | API | Description | |---|---| eval | Evaluates JavaScript code represented string | new Function(evalString) | Creates new function code provided argument | WebAssembly.compile | Compiles WebAssembly module buffer source | WebAssembly.instantiate | Compiles instantiates WebAssembly module buffer source | rare cases, code could contain (or import) dynamic code evaluation statements reached runtime removed treeshaking. relax check allow specific files Middleware configuration: export const config = { unstable_allowDynamic: [ // allows single file '/lib/utilities.js', // use glob allow anything function-bind 3rd party module '**/node_modules/function-bind/**', ], } unstable_allowDynamic glob, array globs, ignoring dynamic code evaluation specific files. globs relative application root folder. warned statements executed Edge, throw cause runtime error. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions", "title": "API Reference: File Conventions | Next.js", "text": "File Conventions default.js API Reference default.js file. error.js API reference error.js special file. forbidden.js API reference forbidden.js special file. instrumentation.js API reference instrumentation.js file. layout.js API reference layout.js file. loading.js API reference loading.js file. mdx-components.js API reference mdx-components.js file. middleware.js API reference middleware.js file. not-found.js API reference not-found.js file. page.js API reference page.js file. route.js API reference route.js special file. Route Segment Config Learn configure options Next.js route segments. template.js API Reference template.js file. unauthorized.js API reference unauthorized.js special file. Metadata Files API documentation metadata file conventions. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/default", "title": "File Conventions: default.js | Next.js", "text": "default.js default.js file used render fallback within Parallel Routes Next.js cannot recover slot's active state full-page load. soft navigation, Next.js keeps track active state (subpage) slot. However, hard navigations (full-page load), Next.js cannot recover active state. case, default.js file rendered subpages match current URL. Consider following folder structure. @team slot settings page, @analytics not. navigating /settings , @team slot render settings page maintaining currently active page @analytics slot. refresh, Next.js render default.js @analytics . default.js exist, 404 rendered instead. Additionally, since children implicit slot, also need create default.js file render fallback children Next.js cannot recover active state parent page. Reference params (optional) promise resolves object containing dynamic route parameters root segment slot's subpages. example: export default async function Default({ params, }: { params: Promise<{ artist: string }> }) { const artist = (await params).artist } | Example | URL | params | |---|---|---| app/[artist]/@sidebar/default.js | /zack | Promise<{ artist: 'zack' }> | app/[artist]/[album]/@sidebar/default.js | /zack/next | Promise<{ artist: 'zack', album: 'next' }> | - Since params prop promise. must useasync/await React'suse function access values.- version 14 earlier, params synchronous prop. help backwards compatibility, still access synchronously Next.js 15, behavior deprecated future. - version 14 earlier, Learn Parallel Routes helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/error", "title": "File Conventions: error.js | Next.js", "text": "error.js error file allows handle unexpected runtime errors display fallback UI. 'use client' // Error boundaries must Client Components import { useEffect } 'react' export default function Error({ error, reset, }: { error: Error & { digest?: string } reset: () => void }) { useEffect(() => { // Log error error reporting service console.error(error) }, [error]) return ( <div> <h2>Something went wrong!</h2> <button onClick={ // Attempt recover trying re-render segment () => reset() } > Try </button> </div> ) } error.js wraps route segment nested children React Error Boundary. error throws within boundary, error component shows fallback UI. Good know: - React DevTools allow toggle error boundaries test error states. - want errors bubble parent error boundary, throw rendering theerror component. Reference Props error instance Error object forwarded error.js Client Component. Good know: development, Error object forwarded client serialized include themessage original error easier debugging. However, behavior different production avoid leaking potentially sensitive details included error client. error.message - Errors forwarded Client Components show original Error message. - Errors forwarded Server Components show generic message identifier. prevent leaking sensitive details. use identifier, errors.digest , match corresponding server-side logs. error.digest automatically generated hash error thrown. used match corresponding error server-side logs. reset cause error sometimes temporary. cases, trying might resolve issue. error component use reset() function prompt user attempt recover error. executed, function try re-render error boundary's contents. successful, fallback error component replaced result re-render. 'use client' // Error boundaries must Client Components export default function Error({ error, reset, }: { error: Error & { digest?: string } reset: () => void }) { return ( <div> <h2>Something went wrong!</h2> <button onClick={() => reset()}>Try again</button> </div> ) } Examples Global Error less common, handle errors root layout template using global-error.js , located root app directory, even leveraging internationalization. Global error UI must define <html> <body> tags. file replaces root layout template active. 'use client' // Error boundaries must Client Components export default function GlobalError({ error, reset, }: { error: Error & { digest?: string } reset: () => void }) { return ( // global-error must include html body tags <html> <body> <h2>Something went wrong!</h2> <button onClick={() => reset()}>Try again</button> </body> </html> ) } Good know: global-error.js always displayed development, error overlay show instead. Version History | Version | Changes | |---|---| v15.2.0 | display global-error also development. | v13.1.0 | global-error introduced. | v13.0.0 | error introduced. | Learn error handling helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/forbidden", "title": "File Conventions: forbidden.js | Next.js", "text": "forbidden.js feature currently experimental subject change, recommended production. Try share feedback GitHub. forbidden file used render UI forbidden function invoked authentication. Along allowing customize UI, Next.js return 403 status code. app/forbidden.tsx import Link 'next/link' export default function Forbidden() { return ( <div> <h2>Forbidden</h2> <p>You authorized access resource.</p> <Link href=\"/\">Return Home</Link> </div> ) } Reference Props forbidden.js components accept props. Version History | Version | Changes | |---|---| v15.1.0 | forbidden.js introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/instrumentation", "title": "File Conventions: instrumentation.js | Next.js", "text": "instrumentation.js instrumentation.js|ts file used integrate observability tools application, allowing track performance behavior, debug issues production. use it, place file root application inside src folder using one. Exports register (optional) file exports register function called new Next.js server instance initiated. register async function. import { registerOTel } '@vercel/otel' export function register() { registerOTel('next-app') } onRequestError (optional) optionally export onRequestError function track server errors custom observability provider. - running async tasks onRequestError , make sure awaited.onRequestError triggered Next.js server captures error. - error instance might original error instance thrown, may processed React encountered Server Components rendering. happens, usedigest property error identify actual error type. import { type Instrumentation } 'next' export const onRequestError: Instrumentation.onRequestError = async ( err, request, context ) => { await fetch('https://.../report-error', { method: 'POST', body: JSON.stringify({ message: err.message, request, context, }), headers: { 'Content-Type': 'application/json', }, }) } Parameters function accepts three parameters: error , request , context . export function onRequestError( error: { digest: string } & Error, request: { path: string // resource path, e.g. /blog?name=foo method: string // request method. e.g. GET, POST, etc headers: { [key: string]: string } }, context: { routerKind: 'Pages Router' | 'App Router' // router type routePath: string // route file path, e.g. /app/blog/[dynamic] routeType: 'render' | 'route' | 'action' | 'middleware' // context error occurred renderSource: | 'react-server-components' | 'react-server-components-payload' | 'server-rendering' revalidateReason: 'on-demand' | 'stale' | undefined // undefined normal request without revalidation renderType: 'dynamic' | 'dynamic-resume' // 'dynamic-resume' PPR } ): void | Promise<void> error : caught error (type alwaysError ), adigest property unique ID error.request : Read-only request information associated error.context : context error occurred. type router (App Pages Router), and/or (Server Components ('render' ), Route Handlers ('route' ), Server Actions ('action' ), Middleware ('middleware' )). Specifying runtime instrumentation.js file works Node.js Edge runtime, however, use process.env.NEXT_RUNTIME target specific runtime. export function register() { (process.env.NEXT_RUNTIME === 'edge') { return require('./register.edge') } else { return require('./register.node') } } export function onRequestError() { (process.env.NEXT_RUNTIME === 'edge') { return require('./on-request-error.edge') } else { return require('./on-request-error.node') } } Version History | Version | Changes | |---|---| v15.0.0-RC | onRequestError introduced, instrumentation stable | v14.0.4 | Turbopack support instrumentation | v13.2.0 | instrumentation introduced experimental feature | Learn Instrumentation helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/layout", "title": "File Conventions: layout.js | Next.js", "text": "layout.js layout file used define layout Next.js application. export default function DashboardLayout({ children, }: { children: React.ReactNode }) { return <section>{children}</section> } root layout top-most layout root app directory. used define <html> <body> tags globally shared UI. export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body>{children}</body> </html> ) } Reference Props children (required) Layout components accept use children prop. rendering, children populated route segments layout wrapping. primarily component child Layout (if exists) Page, could also special files like Loading Error applicable. params (optional) promise resolves object containing dynamic route parameters object root segment layout. export default async function Layout({ params, }: { params: Promise<{ team: string }> }) { const team = (await params).team } | Example Route | URL | params | |---|---|---| app/dashboard/[team]/layout.js | /dashboard/1 | Promise<{ team: '1' }> | app/shop/[tag]/[item]/layout.js | /shop/1/2 | Promise<{ tag: '1', item: '2' }> | app/blog/[...slug]/layout.js | /blog/1/2 | Promise<{ slug: ['1', '2'] }> | - Since params prop promise. must useasync/await React'suse function access values.- version 14 earlier, params synchronous prop. help backwards compatibility, still access synchronously Next.js 15, behavior deprecated future. - version 14 earlier, Root Layouts app directory must include root app/layout.js . export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html> <body>{children}</body> </html> ) } - root layout must define <html> and<body> tags.- manually add <head> tags as<title> and<meta> root layouts. Instead, use Metadata API automatically handles advanced requirements streaming de-duplicating<head> elements. - manually add - use route groups create multiple root layouts. - Navigating across multiple root layouts cause full page load (as opposed client-side navigation). example, navigating /cart usesapp/(shop)/layout.js to/blog usesapp/(marketing)/layout.js cause full page load. applies multiple root layouts. - Navigating across multiple root layouts cause full page load (as opposed client-side navigation). example, navigating Caveats Layouts receive searchParams Unlike Pages, Layout components receive searchParams prop. shared layout re-rendered navigation could lead stale searchParams navigations. using client-side navigation, Next.js automatically renders part page common layout two routes. example, following directory structure, dashboard/layout.tsx common layout /dashboard/settings /dashboard/analytics : navigating /dashboard/settings /dashboard/analytics , page.tsx /dashboard/analytics rerender server, dashboard/layout.tsx rerender common UI shared two routes. performance optimization allows navigation pages share layout quicker data fetching rendering page run, instead entire route could include shared layouts fetch data. dashboard/layout.tsx re-render, searchParams prop layout Server Component might become stale navigation. Instead, use Page searchParams prop useSearchParams hook Client Component within layout, rerendered client latest searchParams . Layouts cannot access pathname Layouts cannot access pathname . layouts Server Components default, rerender client-side navigation, could lead pathname becoming stale navigations. prevent staleness, Next.js would need refetch segments route, losing benefits caching increasing RSC payload size navigation. Instead, extract logic depends pathname Client Component import layouts. Since Client Components rerender (but refetched) navigation, use Next.js hooks usePathname access current pathname prevent staleness. import { ClientComponent } '@/app/ui/ClientComponent' export default function Layout({ children }: { children: React.ReactNode }) { return ( <> <ClientComponent /> {/* Layout UI */} <main>{children}</main> </> ) } Common pathname patterns also implemented params prop. See examples section information. Examples Displaying content based params Using dynamic route segments, display fetch specific content based params prop. export default async function DashboardLayout({ children, params, }: { children: React.ReactNode params: Promise<{ team: string }> }) { const { team } = await params return ( <section> <header> <h1>Welcome {team}'s Dashboard</h1> </header> <main>{children}</main> </section> ) } Reading params Client Components use params Client Component (which cannot async ), use React's use function read promise: 'use client' import { use } 'react' export default function Page({ params, }: { params: Promise<{ slug: string }> }) { const { slug } = use(params) } Version History | Version | Changes | |---|---| v15.0.0-RC | params promise. codemod available. | v13.0.0 | layout introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/loading", "title": "File Conventions: loading.js | Next.js", "text": "loading.js loading file create instant loading states built Suspense. default, file Server Component - also used Client Component \"use client\" directive. app/feed/loading.tsx export default function Loading() { // custom loading skeleton component return <p>Loading...</p> } Loading UI components accept parameters. Good know: - designing loading UI, may find helpful use React Developer Tools manually toggle Suspense boundaries. Version History | Version | Changes | |---|---| v13.0.0 | loading introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/mdx-components", "title": "File Conventions: mdx-components.js | Next.js", "text": "mdx-components.js mdx-components.js|tsx file required use @next/mdx App Router work without it. Additionally, use customize styles. Use file mdx-components.tsx (or .js ) root project define MDX Components. example, level pages app , inside src applicable. mdx-components.tsx import type { MDXComponents } 'mdx/types' export function useMDXComponents(components: MDXComponents): MDXComponents { return { ...components, } } Exports useMDXComponents function file must export single function, either default export named useMDXComponents . mdx-components.tsx import type { MDXComponents } 'mdx/types' export function useMDXComponents(components: MDXComponents): MDXComponents { return { ...components, } } Params components defining MDX Components, export function accepts single parameter, components . parameter instance MDXComponents . - key name HTML element override. - value component render instead. Good know: Remember pass components (i.e. ...components ) overrides. Version History | Version | Changes | |---|---| v13.1.2 | MDX Components added | Learn MDX Components helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata", "title": "File Conventions: Metadata Files | Next.js", "text": "Metadata Files API Reference section docs covers Metadata file conventions. File-based metadata defined adding special metadata files route segments. file convention defined using static file (e.g. opengraph-image.jpg ), dynamic variant uses code generate file (e.g. opengraph-image.js ). file defined, Next.js automatically serve file (with hashes production caching) update relevant head elements correct metadata, asset's URL, file type, image size. Good know: - Special Route Handlers like sitemap.ts ,opengraph-image.tsx , andicon.tsx , metadata files cached default.- using along middleware.ts , configure matcher exclude metadata files. favicon, icon, apple-icon API Reference Favicon, Icon Apple Icon file conventions. manifest.json API Reference manifest.json file. opengraph-image twitter-image API Reference Open Graph Image Twitter Image file conventions. robots.txt API Reference robots.txt file. sitemap.xml API Reference sitemap.xml file. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/app-icons", "title": "Metadata Files: favicon, icon, and apple-icon | Next.js", "text": "favicon, icon, apple-icon favicon , icon , apple-icon file conventions allow set icons application. useful adding app icons appear places like web browser tabs, phone home screens, search engine results. two ways set app icons: Image files (.ico, .jpg, .png) Use image file set app icon placing favicon , icon , apple-icon image file within /app directory. favicon image located top level app/ . Next.js evaluate file automatically add appropriate tags app's <head> element. | File convention | Supported file types | Valid locations | |---|---|---| favicon | .ico | app/ | icon | .ico , .jpg , .jpeg , .png , .svg | app/**/* | apple-icon | .jpg , .jpeg , .png | app/**/* | favicon Add favicon.ico image file root /app route segment. <link rel=\"icon\" href=\"/favicon.ico\" sizes=\"any\" /> icon Add icon.(ico|jpg|jpeg|png|svg) image file. <link rel=\"icon\" href=\"/icon?<generated>\" type=\"image/<generated>\" sizes=\"<generated>\" /> apple-icon Add apple-icon.(jpg|jpeg|png) image file. <link rel=\"apple-touch-icon\" href=\"/apple-icon?<generated>\" type=\"image/<generated>\" sizes=\"<generated>\" /> Good know: - set multiple icons adding number suffix file name. example, icon1.png ,icon2.png , etc. Numbered files sort lexically.- Favicons set root /app segment. need granularity, useicon .- appropriate <link> tags attributes asrel ,href ,type , andsizes determined icon type metadata evaluated file.- example, 32 32px .png file havetype=\"image/png\" andsizes=\"32x32\" attributes.sizes=\"any\" added icons extension is.svg image size file determined. details favicon handbook. Generate icons using code (.js, .ts, .tsx) addition using literal image files, programmatically generate icons using code. Generate app icon creating icon apple-icon route default exports function. | File convention | Supported file types | |---|---| icon | .js , .ts , .tsx | apple-icon | .js , .ts , .tsx | easiest way generate icon use ImageResponse API next/og . import { ImageResponse } 'next/og' // Image metadata export const size = { width: 32, height: 32, } export const contentType = 'image/png' // Image generation export default function Icon() { return new ImageResponse( ( // ImageResponse JSX element <div style={{ fontSize: 24, background: 'black', width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'white', }} > </div> ), // ImageResponse options { // convenience, re-use exported icons size metadata // config also set ImageResponse's width height. ...size, } ) } <link rel=\"icon\" href=\"/icon?<generated>\" type=\"image/png\" sizes=\"32x32\" /> Good know: - default, generated icons statically optimized (generated build time cached) unless use Dynamic APIs uncached data. - generate multiple icons file using generateImageMetadata .- cannot generate favicon icon. Useicon favicon.ico file instead.- App icons special Route Handlers cached default unless uses Dynamic API dynamic config option. Props default export function receives following props: params (optional) object containing dynamic route parameters object root segment segment icon apple-icon colocated in. export default function Icon({ params }: { params: { slug: string } }) { // ... } | Route | URL | params | |---|---|---| app/shop/icon.js | /shop | undefined | app/shop/[slug]/icon.js | /shop/1 | { slug: '1' } | app/shop/[tag]/[item]/icon.js | /shop/1/2 | { tag: '1', item: '2' } | Returns default export function return Blob | ArrayBuffer | TypedArray | DataView | ReadableStream | Response . Good know: ImageResponse satisfies return type. Config exports optionally configure icon's metadata exporting size contentType variables icon apple-icon route. | Option | Type | |---|---| size | { width: number; height: number } | contentType | string - image MIME type | size export const size = { width: 32, height: 32 } export default function Icon() {} <link rel=\"icon\" sizes=\"32x32\" /> contentType export const contentType = 'image/png' export default function Icon() {} <link rel=\"icon\" type=\"image/png\" /> Route Segment Config icon apple-icon specialized Route Handlers use route segment configuration options Pages Layouts. Version History | Version | Changes | |---|---| v13.3.0 | favicon icon apple-icon introduced | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/manifest", "title": "Metadata Files: manifest.json | Next.js", "text": "manifest.json Add generate manifest.(json|webmanifest) file matches Web Manifest Specification root app directory provide information web application browser. Static Manifest file app/manifest.json | app/manifest.webmanifest { \"name\": \"My Next.js Application\", \"short_name\": \"Next.js App\", \"description\": \"An application built Next.js\", \"start_url\": \"/\" // ... } Generate Manifest file Add manifest.js manifest.ts file returns Manifest object. Good know: manifest.js special Route Handlers cached default unless uses Dynamic API dynamic config option. app/manifest.ts import type { MetadataRoute } 'next' export default function manifest(): MetadataRoute.Manifest { return { name: 'Next.js App', short_name: 'Next.js App', description: 'Next.js App', start_url: '/', display: 'standalone', background_color: '#fff', theme_color: '#fff', icons: [ { src: '/favicon.ico', sizes: 'any', type: 'image/x-icon', }, ], } } Manifest Object manifest object contains extensive list options may updated due new web standards. information current options, refer MetadataRoute.Manifest type code editor using TypeScript see MDN docs. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image", "title": "Metadata Files: opengraph-image and twitter-image | Next.js", "text": "opengraph-image twitter-image opengraph-image twitter-image file conventions allow set Open Graph Twitter images route segment. useful setting images appear social networks messaging apps user shares link site. two ways set Open Graph Twitter images: Image files (.jpg, .png, .gif) Use image file set route segment's shared image placing opengraph-image twitter-image image file segment. Next.js evaluate file automatically add appropriate tags app's <head> element. | File convention | Supported file types | |---|---| opengraph-image | .jpg , .jpeg , .png , .gif | twitter-image | .jpg , .jpeg , .png , .gif | opengraph-image.alt | .txt | twitter-image.alt | .txt | Good know: twitter-image file size must exceed 5MB, theopengraph-image file size must exceed 8MB. image file size exceeds limits, build fail. opengraph-image Add opengraph-image.(jpg|jpeg|png|gif) image file route segment. <meta property=\"og:image\" content=\"<generated>\" /> <meta property=\"og:image:type\" content=\"<generated>\" /> <meta property=\"og:image:width\" content=\"<generated>\" /> <meta property=\"og:image:height\" content=\"<generated>\" /> twitter-image Add twitter-image.(jpg|jpeg|png|gif) image file route segment. <meta name=\"twitter:image\" content=\"<generated>\" /> <meta name=\"twitter:image:type\" content=\"<generated>\" /> <meta name=\"twitter:image:width\" content=\"<generated>\" /> <meta name=\"twitter:image:height\" content=\"<generated>\" /> opengraph-image.alt.txt Add accompanying opengraph-image.alt.txt file route segment opengraph-image.(jpg|jpeg|png|gif) image alt text. Acme <meta property=\"og:image:alt\" content=\"About Acme\" /> twitter-image.alt.txt Add accompanying twitter-image.alt.txt file route segment twitter-image.(jpg|jpeg|png|gif) image alt text. Acme <meta property=\"twitter:image:alt\" content=\"About Acme\" /> Generate images using code (.js, .ts, .tsx) addition using literal image files, programmatically generate images using code. Generate route segment's shared image creating opengraph-image twitter-image route default exports function. | File convention | Supported file types | |---|---| opengraph-image | .js , .ts , .tsx | twitter-image | .js , .ts , .tsx | Good know: - default, generated images statically optimized (generated build time cached) unless use Dynamic APIs uncached data. - generate multiple Images file using generateImageMetadata .opengraph-image.js andtwitter-image.js special Route Handlers cached default unless uses Dynamic API dynamic config option. easiest way generate image use ImageResponse API next/og . import { ImageResponse } 'next/og' import { readFile } 'node:fs/promises' import { join } 'node:path' // Image metadata export const alt = 'About Acme' export const size = { width: 1200, height: 630, } export const contentType = 'image/png' // Image generation export default async function Image() { // Font loading, process.cwd() Next.js project directory const interSemiBold = await readFile( join(process.cwd(), 'assets/Inter-SemiBold.ttf') ) return new ImageResponse( ( // ImageResponse JSX element <div style={{ fontSize: 128, background: 'white', width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', }} > Acme </div> ), // ImageResponse options { // convenience, re-use exported opengraph-image // size config also set ImageResponse's width height. ...size, fonts: [ { name: 'Inter', data: interSemiBold, style: 'normal', weight: 400, }, ], } ) } <meta property=\"og:image\" content=\"<generated>\" /> <meta property=\"og:image:alt\" content=\"About Acme\" /> <meta property=\"og:image:type\" content=\"image/png\" /> <meta property=\"og:image:width\" content=\"1200\" /> <meta property=\"og:image:height\" content=\"630\" /> Props default export function receives following props: params (optional) object containing dynamic route parameters object root segment segment opengraph-image twitter-image colocated in. export default function Image({ params }: { params: { slug: string } }) { // ... } | Route | URL | params | |---|---|---| app/shop/opengraph-image.js | /shop | undefined | app/shop/[slug]/opengraph-image.js | /shop/1 | { slug: '1' } | app/shop/[tag]/[item]/opengraph-image.js | /shop/1/2 | { tag: '1', item: '2' } | Returns default export function return Blob | ArrayBuffer | TypedArray | DataView | ReadableStream | Response . Good know: ImageResponse satisfies return type. Config exports optionally configure image's metadata exporting alt , size , contentType variables opengraph-image twitter-image route. | Option | Type | |---|---| alt | string | size | { width: number; height: number } | contentType | string - image MIME type | alt export const alt = 'My images alt text' export default function Image() {} <meta property=\"og:image:alt\" content=\"My images alt text\" /> size export const size = { width: 1200, height: 630 } export default function Image() {} <meta property=\"og:image:width\" content=\"1200\" /> <meta property=\"og:image:height\" content=\"630\" /> contentType export const contentType = 'image/png' export default function Image() {} <meta property=\"og:image:type\" content=\"image/png\" /> Route Segment Config opengraph-image twitter-image specialized Route Handlers use route segment configuration options Pages Layouts. Examples Using external data example uses params object external data generate image. Good know: default, generated image statically optimized. configure individual fetch options route segments options change behavior. import { ImageResponse } 'next/og' export const alt = 'About Acme' export const size = { width: 1200, height: 630, } export const contentType = 'image/png' export default async function Image({ params }: { params: { slug: string } }) { const post = await fetch(`https://.../posts/${params.slug}`).then((res) => res.json() ) return new ImageResponse( ( <div style={{ fontSize: 48, background: 'white', width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', }} > {post.title} </div> ), { ...size, } ) } Using Node.js runtime local assets example uses Node.js runtime fetch local image file system passes ArrayBuffer src attribute <img> element. local asset placed relative root project, rather location example source file. import { ImageResponse } 'next/og' import { join } 'node:path' import { readFile } 'node:fs/promises' export default async function Image() { const logoData = await readFile(join(process.cwd(), 'logo.png')) const logoSrc = Uint8Array.from(logoData).buffer return new ImageResponse( ( <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', }} > <img src={logoSrc} height=\"100\" /> </div> ) ) } Version History | Version | Changes | |---|---| v13.3.0 | opengraph-image twitter-image introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/robots", "title": "Metadata Files: robots.txt | Next.js", "text": "robots.txt Add generate robots.txt file matches Robots Exclusion Standard root app directory tell search engine crawlers URLs access site. Static robots.txt app/robots.txt User-Agent: * Allow: / Disallow: /private/ Sitemap: https://acme.com/sitemap.xml Generate Robots file Add robots.js robots.ts file returns Robots object. Good know: robots.js special Route Handlers cached default unless uses Dynamic API dynamic config option. app/robots.ts import type { MetadataRoute } 'next' export default function robots(): MetadataRoute.Robots { return { rules: { userAgent: '*', allow: '/', disallow: '/private/', }, sitemap: 'https://acme.com/sitemap.xml', } } Output: User-Agent: * Allow: / Disallow: /private/ Sitemap: https://acme.com/sitemap.xml Customizing specific user agents customise individual search engine bots crawl site passing array user agents rules property. example: app/robots.ts import type { MetadataRoute } 'next' export default function robots(): MetadataRoute.Robots { return { rules: [ { userAgent: 'Googlebot', allow: ['/'], disallow: '/private/', }, { userAgent: ['Applebot', 'Bingbot'], disallow: ['/'], }, ], sitemap: 'https://acme.com/sitemap.xml', } } Output: User-Agent: Googlebot Allow: / Disallow: /private/ User-Agent: Applebot Disallow: / User-Agent: Bingbot Disallow: / Sitemap: https://acme.com/sitemap.xml Robots object type Robots = { rules: | { userAgent?: string | string[] allow?: string | string[] disallow?: string | string[] crawlDelay?: number } | Array<{ userAgent: string | string[] allow?: string | string[] disallow?: string | string[] crawlDelay?: number }> sitemap?: string | string[] host?: string } Version History | Version | Changes | |---|---| v13.3.0 | robots introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/sitemap", "title": "Metadata Files: sitemap.xml | Next.js", "text": "sitemap.xml sitemap.(xml|js|ts) special file matches Sitemaps XML format help search engine crawlers index site efficiently. Sitemap files (.xml) smaller applications, create sitemap.xml file place root app directory. <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"> <url> <loc>https://acme.com</loc> <lastmod>2023-04-06T15:02:24.021Z</lastmod> <changefreq>yearly</changefreq> <priority>1</priority> </url> <url> <loc>https://acme.com/about</loc> <lastmod>2023-04-06T15:02:24.021Z</lastmod> <changefreq>monthly</changefreq> <priority>0.8</priority> </url> <url> <loc>https://acme.com/blog</loc> <lastmod>2023-04-06T15:02:24.021Z</lastmod> <changefreq>weekly</changefreq> <priority>0.5</priority> </url> </urlset> Generating sitemap using code (.js, .ts) use sitemap.(js|ts) file convention programmatically generate sitemap exporting default function returns array URLs. using TypeScript, Sitemap type available. Good know: sitemap.js special Route Handler cached default unless uses Dynamic API dynamic config option. import type { MetadataRoute } 'next' export default function sitemap(): MetadataRoute.Sitemap { return [ { url: 'https://acme.com', lastModified: new Date(), changeFrequency: 'yearly', priority: 1, }, { url: 'https://acme.com/about', lastModified: new Date(), changeFrequency: 'monthly', priority: 0.8, }, { url: 'https://acme.com/blog', lastModified: new Date(), changeFrequency: 'weekly', priority: 0.5, }, ] } Output: <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"> <url> <loc>https://acme.com</loc> <lastmod>2023-04-06T15:02:24.021Z</lastmod> <changefreq>yearly</changefreq> <priority>1</priority> </url> <url> <loc>https://acme.com/about</loc> <lastmod>2023-04-06T15:02:24.021Z</lastmod> <changefreq>monthly</changefreq> <priority>0.8</priority> </url> <url> <loc>https://acme.com/blog</loc> <lastmod>2023-04-06T15:02:24.021Z</lastmod> <changefreq>weekly</changefreq> <priority>0.5</priority> </url> </urlset> Image Sitemaps use images property create image sitemaps. Learn details Google Developer Docs. import type { MetadataRoute } 'next' export default function sitemap(): MetadataRoute.Sitemap { return [ { url: 'https://example.com', lastModified: '2021-01-01', changeFrequency: 'weekly', priority: 0.5, images: ['https://example.com/image.jpg'], }, ] } Output: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\" > <url> <loc>https://example.com</loc> <image:image> <image:loc>https://example.com/image.jpg</image:loc> </image:image> <lastmod>2021-01-01</lastmod> <changefreq>weekly</changefreq> <priority>0.5</priority> </url> </urlset> Video Sitemaps use videos property create video sitemaps. Learn details Google Developer Docs. import type { MetadataRoute } 'next' export default function sitemap(): MetadataRoute.Sitemap { return [ { url: 'https://example.com', lastModified: '2021-01-01', changeFrequency: 'weekly', priority: 0.5, videos: [ { title: 'example', thumbnail_loc: 'https://example.com/image.jpg', description: 'this description', }, ], }, ] } Output: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\" > <url> <loc>https://example.com</loc> <video:video> <video:title>example</video:title> <video:thumbnail_loc>https://example.com/image.jpg</video:thumbnail_loc> <video:description>this description</video:description> </video:video> <lastmod>2021-01-01</lastmod> <changefreq>weekly</changefreq> <priority>0.5</priority> </url> </urlset> Generate localized Sitemap import type { MetadataRoute } 'next' export default function sitemap(): MetadataRoute.Sitemap { return [ { url: 'https://acme.com', lastModified: new Date(), alternates: { languages: { es: 'https://acme.com/es', de: 'https://acme.com/de', }, }, }, { url: 'https://acme.com/about', lastModified: new Date(), alternates: { languages: { es: 'https://acme.com/es/about', de: 'https://acme.com/de/about', }, }, }, { url: 'https://acme.com/blog', lastModified: new Date(), alternates: { languages: { es: 'https://acme.com/es/blog', de: 'https://acme.com/de/blog', }, }, }, ] } Output: <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"> <url> <loc>https://acme.com</loc> <xhtml:link rel=\"alternate\" hreflang=\"es\" href=\"https://acme.com/es\"/> <xhtml:link rel=\"alternate\" hreflang=\"de\" href=\"https://acme.com/de\"/> <lastmod>2023-04-06T15:02:24.021Z</lastmod> </url> <url> <loc>https://acme.com/about</loc> <xhtml:link rel=\"alternate\" hreflang=\"es\" href=\"https://acme.com/es/about\"/> <xhtml:link rel=\"alternate\" hreflang=\"de\" href=\"https://acme.com/de/about\"/> <lastmod>2023-04-06T15:02:24.021Z</lastmod> </url> <url> <loc>https://acme.com/blog</loc> <xhtml:link rel=\"alternate\" hreflang=\"es\" href=\"https://acme.com/es/blog\"/> <xhtml:link rel=\"alternate\" hreflang=\"de\" href=\"https://acme.com/de/blog\"/> <lastmod>2023-04-06T15:02:24.021Z</lastmod> </url> </urlset> Generating multiple sitemaps single sitemap work applications. large web applications, may need split sitemap multiple files. two ways create multiple sitemaps: - nesting sitemap.(xml|js|ts) inside multiple route segments e.g.app/sitemap.xml andapp/products/sitemap.xml . - using generateSitemaps function. example, split sitemap using generateSitemaps , return array objects sitemap id . Then, use id generate unique sitemaps. import type { MetadataRoute } 'next' import { BASE_URL } '@/app/lib/constants' export async function generateSitemaps() { // Fetch total number products calculate number sitemaps needed return [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }] } export default async function sitemap({ id, }: { id: number }): Promise<MetadataRoute.Sitemap> { // Google's limit 50,000 URLs per sitemap const start = id * 50000 const end = start + 50000 const products = await getProducts( `SELECT id, date products id ${start} ${end}` ) return products.map((product) => ({ url: `${BASE_URL}/product/${product.id}`, lastModified: product.date, })) } generated sitemaps available /.../sitemap/[id] . example, /product/sitemap/1.xml . See generateSitemaps API reference information. Returns default function exported sitemap.(xml|ts|js) return array objects following properties: type Sitemap = Array<{ url: string lastModified?: string | Date changeFrequency?: | 'always' | 'hourly' | 'daily' | 'weekly' | 'monthly' | 'yearly' | 'never' priority?: number alternates?: { languages?: Languages<string> } }> Version History | Version | Changes | |---|---| v14.2.0 | Add localizations support. | v13.4.14 | Add changeFrequency priority attributes sitemaps. | v13.3.0 | sitemap introduced. | Next Steps helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/middleware", "title": "File Conventions: middleware.js | Next.js", "text": "middleware.js middleware.js|ts file used write Middleware run code server request completed. Then, based incoming request, modify response rewriting, redirecting, modifying request response headers, responding directly. Middleware executes routes rendered. particularly useful implementing custom server-side logic like authentication, logging, handling redirects. Use file middleware.ts (or .js) root project define Middleware. example, level app pages , inside src applicable. import { NextResponse, NextRequest } 'next/server' // function marked `async` using `await` inside export function middleware(request: NextRequest) { return NextResponse.redirect(new URL('/home', request.url)) } export const config = { matcher: '/about/:path*', } Exports Middleware function file must export single function, either default export named middleware . Note multiple middleware file supported. // Example default export export default function middleware(request) { // Middleware logic } Config object (optional) Optionally, config object exported alongside Middleware function. object includes matcher specify paths Middleware applies. Matcher matcher option allows target specific paths Middleware run on. specify paths several ways: - single path: Directly use string define path, like '/about' . - multiple paths: Use array list multiple paths, matcher: ['/about', '/contact'] , applies Middleware both/about and/contact . Additionally, matcher supports complex path specifications regular expressions, matcher: ['/((?!api|_next/static|_next/image|.*\\\\.png$).*)'] , enabling precise control paths include exclude. matcher option also accepts array objects following keys: source : path pattern used match request paths. string direct path matching pattern complex matching.regexp (optional): regular expression string fine-tunes matching based source. provides additional control paths included excluded.locale (optional): boolean that, set tofalse , ignores locale-based routing path matching.has (optional): Specifies conditions based presence specific request elements headers, query parameters, cookies.missing (optional): Focuses conditions certain request elements absent, like missing headers cookies. export const config = { matcher: [ { source: '/api/*', regexp: '^/api/(.*)', locale: false, has: [ { type: 'header', key: 'Authorization', value: 'Bearer Token' }, { type: 'query', key: 'userId', value: '123' }, ], missing: [{ type: 'cookie', key: 'session', value: 'active' }], }, ], } Params request defining Middleware, default export function accepts single parameter, request . parameter instance NextRequest , represents incoming HTTP request. import type { NextRequest } 'next/server' export function middleware(request: NextRequest) { // Middleware logic goes } Good know: NextRequest type represents incoming HTTP requests Next.js Middleware, whereasNextResponse class used manipulate send back HTTP responses. NextResponse Middleware use NextResponse object extends Web Response API. returning NextResponse object, directly manipulate cookies, set headers, implement redirects, rewrite paths. Good know: redirects, also use Response.redirect instead ofNextResponse.redirect . Runtime Middleware supports Edge runtime. Node.js runtime cannot used. Version History | Version | Changes | |---|---| v13.1.0 | Advanced Middleware flags added | v13.0.0 | Middleware modify request headers, response headers, send responses | v12.2.0 | Middleware stable, please see upgrade guide | v12.0.9 | Enforce absolute URLs Edge Runtime (PR) | v12.0.0 | Middleware (Beta) added | Learn Middleware helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/not-found", "title": "File Conventions: not-found.js | Next.js", "text": "not-found.js not-found file used render UI notFound function thrown within route segment. Along serving custom UI, Next.js return 200 HTTP status code streamed responses, 404 non-streamed responses. import Link 'next/link' export default function NotFound() { return ( <div> <h2>Not Found</h2> <p>Could find requested resource</p> <Link href=\"/\">Return Home</Link> </div> ) } Reference Props not-found.js components accept props. Good know: addition catching expected notFound() errors, rootapp/not-found.js file also handles unmatched URLs whole application. means users visit URL handled app shown UI exported theapp/not-found.js file. Examples Data Fetching default, not-found Server Component. mark async fetch display data: import Link 'next/link' import { headers } 'next/headers' export default async function NotFound() { const headersList = await headers() const domain = headersList.get('host') const data = await getSiteData(domain) return ( <div> <h2>Not Found: {data.name}</h2> <p>Could find requested resource</p> <p> View <Link href=\"/blog\">all posts</Link> </p> </div> ) } need use Client Component hooks like usePathname display content based path, must fetch data client-side instead. Version History | Version | Changes | |---|---| v13.3.0 | Root app/not-found handles global unmatched URLs. | v13.0.0 | not-found introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/page", "title": "File Conventions: page.js | Next.js", "text": "page.js page file allows define UI unique route. create page default exporting component file: app/blog/[slug]/page.tsx export default function Page({ params, searchParams, }: { params: Promise<{ slug: string }> searchParams: Promise<{ [key: string]: string | string[] | undefined }> }) { return <h1>My Page</h1> } Good know - .js ,.jsx , or.tsx file extensions used forpage . - page always leaf route subtree. - page file required make route segment publicly accessible. - Pages Server Components default, set Client Component. Reference Props params (optional) promise resolves object containing dynamic route parameters root segment page. app/shop/[slug]/page.tsx export default async function Page({ params, }: { params: Promise<{ slug: string }> }) { const slug = (await params).slug } | Example Route | URL | params | |---|---|---| app/shop/[slug]/page.js | /shop/1 | Promise<{ slug: '1' }> | app/shop/[category]/[item]/page.js | /shop/1/2 | Promise<{ category: '1', item: '2' }> | app/shop/[...slug]/page.js | /shop/1/2 | Promise<{ slug: ['1', '2'] }> | - Since params prop promise. must useasync/await React'suse function access values.- version 14 earlier, params synchronous prop. help backwards compatibility, still access synchronously Next.js 15, behavior deprecated future. - version 14 earlier, searchParams (optional) promise resolves object containing search parameters current URL. example: app/shop/page.tsx export default async function Page({ searchParams, }: { searchParams: Promise<{ [key: string]: string | string[] | undefined }> }) { const filters = (await searchParams).filters } | Example URL | searchParams | |---|---| /shop?a=1 | Promise<{ a: '1' }> | /shop?a=1&b=2 | Promise<{ a: '1', b: '2' }> | /shop?a=1&a=2 | Promise<{ a: ['1', '2'] }> | - Since searchParams prop promise. must useasync/await React'suse function access values.- version 14 earlier, searchParams synchronous prop. help backwards compatibility, still access synchronously Next.js 15, behavior deprecated future. - version 14 earlier, searchParams Dynamic API whose values cannot known ahead time. Using opt page dynamic rendering request time.searchParams plain JavaScript object, aURLSearchParams instance. Examples Displaying content based params Using dynamic route segments, display fetch specific content page based params prop. app/blog/[slug]/page.tsx export default async function Page({ params, }: { params: Promise<{ slug: string }> }) { const { slug } = await params return <h1>Blog Post: {slug}</h1> } Handling filtering searchParams use searchParams prop handle filtering, pagination, sorting based query string URL. app/shop/page.tsx export default async function Page({ searchParams, }: { searchParams: Promise<{ [key: string]: string | string[] | undefined }> }) { const { page = '1', sort = 'asc', query = '' } = await searchParams return ( <div> <h1>Product Listing</h1> <p>Search query: {query}</p> <p>Current page: {page}</p> <p>Sort order: {sort}</p> </div> ) } Reading searchParams params Client Components use searchParams params Client Component (which cannot async ), use React's use function read promise: app/page.tsx 'use client' import { use } 'react' export default function Page({ params, searchParams, }: { params: Promise<{ slug: string }> searchParams: Promise<{ [key: string]: string | string[] | undefined }> }) { const { slug } = use(params) const { query } = use(searchParams) } Version History | Version | Changes | |---|---| v15.0.0-RC | params searchParams promises. codemod available. | v13.0.0 | page introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/route", "title": "File Conventions: route.js | Next.js", "text": "route.js Route Handlers allow create custom request handlers given route using Web Request Response APIs. route.ts export async function GET() { return Response.json({ message: 'Hello World' }) } Reference HTTP Methods route file allows create custom request handlers given route. following HTTP methods supported: GET , POST , PUT , PATCH , DELETE , HEAD , OPTIONS . route.ts export async function GET(request: Request) {} export async function HEAD(request: Request) {} export async function POST(request: Request) {} export async function PUT(request: Request) {} export async function DELETE(request: Request) {} export async function PATCH(request: Request) {} // `OPTIONS` defined, Next.js automatically implement `OPTIONS` set appropriate Response `Allow` header depending methods defined Route Handler. export async function OPTIONS(request: Request) {} Parameters request (optional) request object NextRequest object, extension Web Request API. NextRequest gives control incoming request, including easily accessing cookies extended, parsed, URL object nextUrl . route.ts import type { NextRequest } 'next/server' export async function GET(request: NextRequest) { const url = request.nextUrl } context (optional) params : promise resolves object containing dynamic route parameters current route. app/dashboard/[team]/route.ts export async function GET( request: Request, { params }: { params: Promise<{ team: string }> } ) { const team = (await params).team } | Example | URL | params | |---|---|---| app/dashboard/[team]/route.js | /dashboard/1 | Promise<{ team: '1' }> | app/shop/[tag]/[item]/route.js | /shop/1/2 | Promise<{ tag: '1', item: '2' }> | app/blog/[...slug]/route.js | /blog/1/2 | Promise<{ slug: ['1', '2'] }> | Examples Handling cookies route.ts import { cookies } 'next/headers' export async function GET(request: NextRequest) { const cookieStore = await cookies() const = cookieStore.get('a') const b = cookieStore.set('b', '1') const c = cookieStore.delete('c') } Version History | Version | Changes | |---|---| v15.0.0-RC | context.params promise. codemod available | v15.0.0-RC | default caching GET handlers changed static dynamic | v13.2.0 | Route Handlers introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/template", "title": "File Conventions: template.js | Next.js", "text": "template.js template file similar layout wraps layout page. Unlike layouts persist across routes maintain state, templates given unique key, meaning children Client Components reset state navigation. app/template.tsx export default function Template({ children }: { children: React.ReactNode }) { return <div>{children}</div> } less common, might choose use template layout want: - Features rely useEffect (e.g logging page views) anduseState (e.g per-page feedback form). - change default framework behavior. example, Suspense Boundaries inside layouts show fallback first time Layout loaded switching pages. templates, fallback shown navigation. Props children (required) Template accepts children prop. example: Output <Layout> {/* Note template automatically given unique key. */} <Template key={routeParam}>{children}</Template> </Layout> Good know: - default, template Server Component, also used Client Component the\"use client\" directive.- user navigates routes share template , new instance component mounted, DOM elements recreated, state preserved Client Components, effects re-synchronized. Version History | Version | Changes | |---|---| v13.0.0 | template introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized", "title": "File Conventions: unauthorized.js | Next.js", "text": "unauthorized.js feature currently experimental subject change, recommended production. Try share feedback GitHub. unauthorized file used render UI unauthorized function invoked authentication. Along allowing customize UI, Next.js return 401 status code. app/unauthorized.tsx import Login '@/app/components/Login' export default function Unauthorized() { return ( <main> <h1>401 - Unauthorized</h1> <p>Please log access page.</p> <Login /> </main> ) } Reference Props unauthorized.js components accept props. Examples Displaying login UI unauthenticated users use unauthorized function render unauthorized.js file login UI. app/dashboard/page.tsx import { verifySession } '@/app/lib/dal' import { unauthorized } 'next/navigation' export default async function DashboardPage() { const session = await verifySession() (!session) { unauthorized() } return <div>Dashboard</div> } app/unauthorized.tsx import Login '@/app/components/Login' export default function UnauthorizedPage() { return ( <main> <h1>401 - Unauthorized</h1> <p>Please log access page.</p> <Login /> </main> ) } Version History | Version | Changes | |---|---| v15.1.0 | unauthorized.js introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions", "title": "API Reference: Functions | Next.js", "text": "Functions API Reference function. cacheLife Learn use cacheLife function set cache expiration time cached function component. cacheTag Learn use cacheTag function manage cache invalidation Next.js application. connection API Reference connection function. cookies API Reference cookies function. draftMode API Reference draftMode function. fetch API reference extended fetch function. forbidden API Reference forbidden function. generateImageMetadata Learn generate multiple images single Metadata API special file. generateMetadata Learn add Metadata Next.js application improved search engine optimization (SEO) web shareability. generateSitemaps Learn use generateSiteMaps function create multiple sitemaps application. generateStaticParams API reference generateStaticParams function. generateViewport API Reference generateViewport function. headers API reference headers function. ImageResponse API Reference ImageResponse constructor. NextRequest API Reference NextRequest. NextResponse API Reference NextResponse. notFound API Reference notFound function. permanentRedirect API Reference permanentRedirect function. redirect API Reference redirect function. revalidatePath API Reference revalidatePath function. revalidateTag API Reference revalidateTag function. unauthorized API Reference unauthorized function. unstable_cache API Reference unstable_cache function. unstable_noStore API Reference unstable_noStore function. unstable_rethrow API Reference unstable_rethrow function. useParams API Reference useParams hook. usePathname API Reference usePathname hook. useReportWebVitals API Reference useReportWebVitals function. useRouter API reference useRouter hook. useSearchParams API Reference useSearchParams hook. useSelectedLayoutSegment API Reference useSelectedLayoutSegment hook. useSelectedLayoutSegments API Reference useSelectedLayoutSegments hook. userAgent userAgent helper extends Web Request API additional properties methods interact user agent object request. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/after", "title": "Functions: after | Next.js", "text": "allows schedule work executed response (or prerender) finished. useful tasks side effects block response, logging analytics. used Server Components (including generateMetadata ), Server Actions, Route Handlers, Middleware. function accepts callback executed response (or prerender) finished: import { } 'next/server' // Custom logging function import { log } '@/app/utils' export default function Layout({ children }: { children: React.ReactNode }) { after(() => { // Execute layout rendered sent user log() }) return <>{children}</> } Good know: Dynamic API calling cause route become dynamic. used within static page, callback execute build time, whenever page revalidated. Reference Parameters - callback function executed response (or prerender) finished. Duration run platform's default configured max duration route. platform supports it, configure timeout limit using maxDuration route segment config. Good know executed even response complete successfully. Including error thrown whennotFound orredirect called.- use React cache deduplicate functions called insideafter . nested inside otherafter calls, example, create utility functions wrapafter calls add additional functionality. Alternatives use case process secondary tasks without blocking primary response. similar using platform's waitUntil() removing await promise, following differences: waitUntil() : accepts promise enqueues task executed lifecycle request, whereasafter accepts callback executed response finished.- Removing await : starts executing response, uses resources. also reliable serverless environments function stops computation immediately response sent, potentially interrupting task. recommend using designed consider Next.js APIs contexts. Examples request APIs use request APIs cookies headers inside Server Actions Route Handlers. useful logging activity mutation. example: import { } 'next/server' import { cookies, headers } 'next/headers' import { logUserAction } '@/app/utils' export async function POST(request: Request) { // Perform mutation // ... // Log user activity analytics after(async () => { const userAgent = (await headers().get('user-agent')) || 'unknown' const sessionCookie = (await cookies().get('session-id'))?.value || 'anonymous' logUserAction({ sessionCookie, userAgent }) }) return new Response(JSON.stringify({ status: 'success' }), { status: 200, headers: { 'Content-Type': 'application/json' }, }) } However, cannot use request APIs inside Server Components. Next.js needs know part tree access request APIs support Partial Prerendering, runs React's rendering lifecycle. | Version History | Description | |---|---| v15.1.0 | became stable. | v15.0.0-rc | unstable_after introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/cacheLife", "title": "Functions: cacheLife | Next.js", "text": "cacheLife cacheLife function used set cache lifetime function component. used alongside use cache directive, within scope function component. Usage use cacheLife , enable dynamicIO flag next.config.js file: import type { NextConfig } 'next' const nextConfig: NextConfig = { experimental: { dynamicIO: true, }, } export default nextConfig Then, import invoke cacheLife function within scope function component: 'use cache' import { unstable_cacheLife cacheLife } 'next/cache' export default async function Page() { cacheLife('hours') return <div>Page</div> } Reference Default cache profiles Next.js provides set named cache profiles modeled various timescales. specify cache profile cacheLife function alongside use cache directive, Next.js automatically apply \u201cdefault\u201d cache profile. However, recommend always adding cache profile using use cache directive explicitly define caching behavior. | Profile | Stale | Revalidate | Expire | Description | |---|---|---|---|---| default | undefined | 15 minutes | INFINITE_CACHE | Default profile, suitable content need frequent updates | seconds | undefined | 1 second | 1 minute | rapidly changing content requiring near real-time updates | minutes | 5 minutes | 1 minute | 1 hour | content updates frequently within hour | hours | 5 minutes | 1 hour | 1 day | content updates daily slightly stale | days | 5 minutes | 1 day | 1 week | content updates weekly day old | weeks | 5 minutes | 1 week | 1 month | content updates monthly week old | max | 5 minutes | 1 month | INFINITE_CACHE | stable content rarely needs updating | string values used reference cache profiles carry inherent meaning; instead serve semantic labels. allows better understand manage cached content within codebase. Custom cache profiles configure custom cache profiles adding cacheLife option next.config.ts file. Cache profiles objects contain following properties: | Property | Value | Description | Requirement | |---|---|---|---| stale | number | Duration client cache value without checking server. | Optional | revalidate | number | Frequency cache refresh server; stale values may served revalidating. | Optional | expire | number | Maximum duration value remain stale switching dynamic fetching; must longer revalidate . | Optional - Must longer revalidate | \"stale\" property differs staleTimes setting specifically controls client-side router caching. staleTimes global setting affects instances dynamic static data, cacheLife configuration allows define \"stale\" times per-function per-route basis. Good know: \u201cstale\u201d property set Cache-control: max-age header. instead controls client-side router cache. Examples Defining reusable cache profiles create reusable cache profile defining next.config.ts file. Choose name suits use case set values stale , revalidate , expire properties. create many custom cache profiles needed. profile referenced name string value passed cacheLife function. import type { NextConfig } 'next' const nextConfig: NextConfig = { experimental: { dynamicIO: true, cacheLife: { biweekly: { stale: 60 * 60 * 24 * 14, // 14 days revalidate: 60 * 60 * 24, // 1 day expire: 60 * 60 * 24 * 14, // 14 days }, }, }, } module.exports = nextConfig example caches 14 days, checks updates daily, expires cache 14 days. reference profile throughout application name: 'use cache' import { unstable_cacheLife cacheLife } 'next/cache' export default async function Page() { cacheLife('biweekly') return <div>Page</div> } Overriding default cache profiles default cache profiles provide useful way think fresh stale given part cacheable output be, may prefer different named profiles better align applications caching strategies. override default named cache profiles creating new configuration name defaults. example shows override default \u201cdays\u201d cache profile: const nextConfig = { experimental: { dynamicIO: true, cacheLife: { days: { stale: 3600, // 1 hour revalidate: 900, // 15 minutes expire: 86400, // 1 day }, }, }, } module.exports = nextConfig Defining cache profiles inline specific use cases, set custom cache profile passing object cacheLife function: 'use cache' import { unstable_cacheLife cacheLife } 'next/cache' export default async function Page() { cacheLife({ stale: 3600, // 1 hour revalidate: 900, // 15 minutes expire: 86400, // 1 day }) return <div>Page</div> } inline cache profile applied function file created in. want reuse profile throughout application, add configuration cacheLife property next.config.ts file. Nested usage use cache cacheLife defining multiple caching behaviors route component tree, inner caches specify cacheLife profile, outer cache respect shortest cache duration among them. applies outer cache explicit cacheLife profile defined. example, add use cache directive page, without specifying cache profile, default cache profile applied implicitly (cacheLife(\u201ddefault\u201d) ). component imported page also uses use cache directive cache profile, outer inner cache profiles compared, shortest duration set profiles applied. // Parent component import { unstable_cacheLife cacheLife } 'next/cache' import { ChildComponent } './child' export async function ParentComponent() { 'use cache' cacheLife('days') return ( <div> <ChildComponent /> </div> ) } separate file, defined Child component imported: // Child component import { unstable_cacheLife cacheLife } 'next/cache' export async function ChildComponent() { 'use cache' cacheLife('hours') return <div>Child Content</div> // component's cache respect shorter 'hours' profile } Related dynamicIO use cache revalidateTag cacheTag helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/cacheTag", "title": "Functions: cacheTag | Next.js", "text": "cacheTag feature currently available canary channel subject change. Try upgrading Next.js, share feedback GitHub. cacheTag function allows tag cached data on-demand invalidation. associating tags cache entries, selectively purge revalidate specific cache entries without affecting cached data. Usage use cacheTag , enable dynamicIO flag next.config.js file: next.config.ts import type { NextConfig } 'next' const nextConfig: NextConfig = { experimental: { dynamicIO: true, }, } export default nextConfig cacheTag function takes single string value, string array. app/data.ts import { unstable_cacheTag cacheTag } 'next/cache' export async function getData() { 'use cache' cacheTag('my-data') const data = await fetch('/api/data') return data } purge cache on-demand using revalidateTag API another function, example, route handler Server Action: app/action.ts 'use server' import { revalidateTag } 'next/cache' export default async function submit() { await addPost() revalidateTag('my-data') } Good know - Idempotent Tags: Applying tag multiple times additional effect. - Multiple Tags: assign multiple tags single cache entry passing array cacheTag . cacheTag('tag-one', 'tag-two') Examples Tagging components functions Tag cached data calling cacheTag within cached function component: app/components/bookings.tsx import { unstable_cacheTag cacheTag } 'next/cache' interface BookingsProps { type: string } export async function Bookings({ type = 'haircut' }: BookingsProps) { 'use cache' cacheTag('bookings-data') async function getBookingsData() { const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`) return data } return //... } Creating tags external data use data returned async function tag cache entry. app/components/bookings.tsx import { unstable_cacheTag cacheTag } 'next/cache' interface BookingsProps { type: string } export async function Bookings({ type = 'haircut' }: BookingsProps) { async function getBookingsData() { 'use cache' const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`) cacheTag('bookings-data', data.id) return data } return //... } Invalidating tagged cache Using revalidateTag , invalidate cache specific tag needed: app/actions.ts 'use server' import { revalidateTag } 'next/cache' export async function updateBookings() { await updateBookingData() revalidateTag('bookings-data') } Related View related API references. dynamicIO Learn enable dynamicIO flag Next.js. use cache Learn use use cache directive cache data Next.js application. revalidateTag API Reference revalidateTag function. cacheLife Learn use cacheLife function set cache expiration time cached function component. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/connection", "title": "Functions: connection | Next.js", "text": "connection connection() function allows indicate rendering wait incoming user request continuing. useful component doesn\u2019t use Dynamic APIs, want dynamically rendered runtime statically rendered build time. usually occurs access external information intentionally want change result render, Math.random() new Date() . app/page.tsx import { connection } 'next/server' export default async function Page() { await connection() // Everything excluded prerendering const rand = Math.random() return <span>{rand}</span> } Reference Type function connection(): Promise<void> Parameters - function accept parameters. Returns - function returns void Promise. meant consumed. Good know connection replacesunstable_noStore better align future Next.js.- function necessary dynamic rendering required common Dynamic APIs used. Version History | Version | Changes | |---|---| v15.0.0 | connection stabilized. | v15.0.0-RC | connection introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/cookies", "title": "Functions: cookies | Next.js", "text": "cookies cookies async function allows read HTTP incoming request cookies Server Component, read/write outgoing request cookies Server Actions Route Handlers. import { cookies } 'next/headers' export default async function Page() { const cookieStore = await cookies() const theme = cookieStore.get('theme') return '...' } Reference Methods following methods available: | Method | Return Type | Description | |---|---|---| get('name') | Object | Accepts cookie name returns object name value. | getAll() | Array objects | Returns list cookies matching name. | has('name') | Boolean | Accepts cookie name returns boolean based cookie exists. | set(name, value, options) | - | Accepts cookie name, value, options sets outgoing request cookie. | delete(name) | - | Accepts cookie name deletes cookie. | clear() | - | Deletes cookies. | toString() | String | Returns string representation cookies. | Options setting cookie, following properties options object supported: | Option | Type | Description | |---|---|---| name | String | Specifies name cookie. | value | String | Specifies value stored cookie. | expires | Date | Defines exact date cookie expire. | maxAge | Number | Sets cookie\u2019s lifespan seconds. | domain | String | Specifies domain cookie available. | path | String, default: '/' | Limits cookie's scope specific path within domain. | secure | Boolean | Ensures cookie sent HTTPS connections added security. | httpOnly | Boolean | Restricts cookie HTTP requests, preventing client-side access. | sameSite | Boolean, 'lax' , 'strict' , 'none' | Controls cookie's cross-site request behavior. | priority | String (\"low\" , \"medium\" , \"high\" ) | Specifies cookie's priority | encode('value') | Function | Specifies function used encode cookie's value. | partitioned | Boolean | Indicates whether cookie partitioned. | option default value path . learn options, see MDN docs. Good know cookies asynchronous function returns promise. must useasync/await React'suse function access cookies.- version 14 earlier, cookies synchronous function. help backwards compatibility, still access synchronously Next.js 15, behavior deprecated future. - version 14 earlier, cookies Dynamic API whose returned values cannot known ahead time. Using layout page opt route dynamic rendering.- .delete method called:- Server Action Route Handler. - belongs domain .set called. wildcard domains, specific subdomain must exact match. Additionally, code must executed protocol (HTTP HTTPS) cookie want delete. - HTTP allow setting cookies streaming starts, must use .set Server Action Route Handler. Understanding Cookie Behavior Server Components working cookies Server Components, important understand cookies fundamentally client-side storage mechanism: - Reading cookies works Server Components accessing cookie data client's browser sends server HTTP request headers. - Setting cookies cannot done directly Server Component, even using Route Handler Server Action. cookies actually stored browser, server. server send instructions (via Set-Cookie headers) tell browser store cookies - actual storage happens client side. cookie operations modify state (.set , .delete , .clear ) must performed Route Handler Server Action response headers properly set. Examples Getting cookie use (await cookies()).get('name') method get single cookie: import { cookies } 'next/headers' export default async function Page() { const cookieStore = await cookies() const theme = cookieStore.get('theme') return '...' } Getting cookies use (await cookies()).getAll() method get cookies matching name. name unspecified, returns available cookies. import { cookies } 'next/headers' export default async function Page() { const cookieStore = await cookies() return cookieStore.getAll().map((cookie) => ( <div key={cookie.name}> <p>Name: {cookie.name}</p> <p>Value: {cookie.value}</p> </div> )) } Setting cookie use (await cookies()).set(name, value, options) method Server Action Route Handler set cookie. options object optional. 'use server' import { cookies } 'next/headers' export async function create(data) { const cookieStore = await cookies() cookieStore.set('name', 'lee') // cookieStore.set('name', 'lee', { secure: true }) // cookieStore.set({ name: 'name', value: 'lee', httpOnly: true, path: '/', }) } Checking cookie exists use (await cookies()).has(name) method check cookie exists: import { cookies } 'next/headers' export default async function Page() { const cookieStore = await cookies() const hasCookie = cookieStore.has('theme') return '...' } Deleting cookies three ways delete cookie. Using delete() method: 'use server' import { cookies } 'next/headers' export async function delete(data) { (await cookies()).delete('name') } Setting new cookie name empty value: 'use server' import { cookies } 'next/headers' export async function delete(data) { (await cookies()).set('name', '') } Setting maxAge 0 immediately expire cookie. maxAge accepts value seconds. 'use server' import { cookies } 'next/headers' export async function delete(data) { (await cookies()).set('name', 'value', { maxAge: 0 }) } Version History | Version | Changes | |---|---| v15.0.0-RC | cookies async function. codemod available. | v13.0.0 | cookies introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/draft-mode", "title": "Functions: draftMode | Next.js", "text": "draftMode draftMode async function allows enable disable Draft Mode, well check Draft Mode enabled Server Component. app/page.ts import { draftMode } 'next/headers' export default async function Page() { const { isEnabled } = await draftMode() } Reference following methods properties available: | Method | Description | |---|---| isEnabled | boolean value indicates Draft Mode enabled. | enable() | Enables Draft Mode Route Handler setting cookie (__prerender_bypass ). | disable() | Disables Draft Mode Route Handler deleting cookie. | Good know draftMode asynchronous function returns promise. must useasync/await React'suse function.- version 14 earlier, draftMode synchronous function. help backwards compatibility, still access synchronously Next.js 15, behavior deprecated future. - version 14 earlier, - new bypass cookie value generated time run next build . ensures bypass cookie can\u2019t guessed. - test Draft Mode locally HTTP, browser need allow third-party cookies local storage access. Examples Enabling Draft Mode enable Draft Mode, create new Route Handler call enable() method: app/draft/route.ts import { draftMode } 'next/headers' export async function GET(request: Request) { const draft = await draftMode() draft.enable() return new Response('Draft mode enabled') } Disabling Draft Mode default, Draft Mode session ends browser closed. disable Draft Mode manually, call disable() method Route Handler: app/draft/route.ts import { draftMode } 'next/headers' export async function GET(request: Request) { const draft = await draftMode() draft.disable() return new Response('Draft mode disabled') } Then, send request invoke Route Handler. calling route using <Link> component, must pass prefetch={false} prevent accidentally deleting cookie prefetch. Checking Draft Mode enabled check Draft Mode enabled Server Component isEnabled property: app/page.ts import { draftMode } 'next/headers' export default async function Page() { const { isEnabled } = await draftMode() return ( <main> <h1>My Blog Post</h1> <p>Draft Mode currently {isEnabled ? 'Enabled' : 'Disabled'}</p> </main> ) } Version History | Version | Changes | |---|---| v15.0.0-RC | draftMode async function. codemod available. | v13.4.0 | draftMode introduced. | Next Steps Learn use Draft Mode step-by-step guide. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/fetch", "title": "Functions: fetch | Next.js", "text": "fetch Next.js extends Web fetch() API allow request server set persistent caching revalidation semantics. browser, cache option indicates fetch request interact browser's HTTP cache. extension, cache indicates server-side fetch request interact framework's persistent Data Cache. call fetch async await directly within Server Components. export default async function Page() { let data = await fetch('https://api.vercel.app/blog') let posts = await data.json() return ( <ul> {posts.map((post) => ( <li key={post.id}>{post.title}</li> ))} </ul> ) } fetch(url, options) Since Next.js extends Web fetch() API, use native options available. options.cache Configure request interact Next.js Data Cache. fetch(`https://...`, { cache: 'force-cache' | 'no-store' }) auto cache (default): Next.js fetches resource remote server every request development, fetch duringnext build route statically prerendered. Dynamic APIs detected route, Next.js fetch resource every request.no-store : Next.js fetches resource remote server every request, even Dynamic APIs detected route.force-cache : Next.js looks matching request Data Cache.- match fresh, returned cache. - match stale match, Next.js fetch resource remote server update cache downloaded resource. options.next.revalidate fetch(`https://...`, { next: { revalidate: false | 0 | number } }) Set cache lifetime resource (in seconds). false - Cache resource indefinitely. Semantically equivalent torevalidate: Infinity . HTTP cache may evict older resources time.0 - Prevent resource cached.number - (in seconds) Specify resource cache lifetime mostn seconds. Good know: - individual fetch() request sets arevalidate number lower defaultrevalidate route, whole route revalidation interval decreased.- two fetch requests URL route different revalidate values, lower value used.- convenience, necessary set cache option ifrevalidate set number.- Conflicting options { revalidate: 3600, cache: 'no-store' } cause error. options.next.tags fetch(`https://...`, { next: { tags: ['collection'] } }) Set cache tags resource. Data revalidated on-demand using revalidateTag . max length custom tag 256 characters max tag items 128. Troubleshooting Fetch default auto store cache: 'no-store' showing fresh data development Next.js caches fetch responses Server Components across Hot Module Replacement (HMR) local development faster responses reduce costs billed API calls. default, HMR cache applies fetch requests, including default auto cache cache: 'no-store' option. means uncached requests show fresh data HMR refreshes. However, cache cleared navigation full-page reloads. See serverComponentsHmrCache docs information. Version History | Version | Changes | |---|---| v13.0.0 | fetch introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/forbidden", "title": "Functions: forbidden | Next.js", "text": "forbidden feature currently experimental subject change, recommended production. Try share feedback GitHub. forbidden function throws error renders Next.js 403 error page. useful handling authorization errors application. customize UI using forbidden.js file. start using forbidden , enable experimental authInterrupts configuration option next.config.js file: next.config.ts import type { NextConfig } 'next' const nextConfig: NextConfig = { experimental: { authInterrupts: true, }, } export default nextConfig forbidden invoked Server Components, Server Actions, Route Handlers. app/auth/page.tsx import { verifySession } '@/app/lib/dal' import { forbidden } 'next/navigation' export default async function AdminPage() { const session = await verifySession() // Check user 'admin' role (session.role !== 'admin') { forbidden() } // Render admin page authorized users return <></> } Good know - forbidden function cannot called root layout. Examples Role-based route protection use forbidden restrict access certain routes based user roles. ensures users authenticated lack required permissions cannot access route. app/admin/page.tsx import { verifySession } '@/app/lib/dal' import { forbidden } 'next/navigation' export default async function AdminPage() { const session = await verifySession() // Check user 'admin' role (session.role !== 'admin') { forbidden() } // Render admin page authorized users return ( <main> <h1>Admin Dashboard</h1> <p>Welcome, {session.user.name}!</p> </main> ) } Mutations Server Actions implementing mutations Server Actions, use forbidden allow users specific role update sensitive data. app/actions/update-role.ts 'use server' import { verifySession } '@/app/lib/dal' import { forbidden } 'next/navigation' import db '@/app/lib/db' export async function updateRole(formData: FormData) { const session = await verifySession() // Ensure admins update roles (session.role !== 'admin') { forbidden() } // Perform role update authorized users // ... } Version History | Version | Changes | |---|---| v15.1.0 | forbidden introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/generate-image-metadata", "title": "Functions: generateImageMetadata | Next.js", "text": "generateImageMetadata use generateImageMetadata generate different versions one image return multiple images one route segment. useful want avoid hard-coding metadata values, icons. Parameters generateImageMetadata function accepts following parameters: params (optional) object containing dynamic route parameters object root segment segment generateImageMetadata called from. export function generateImageMetadata({ params, }: { params: { slug: string } }) { // ... } | Route | URL | params | |---|---|---| app/shop/icon.js | /shop | undefined | app/shop/[slug]/icon.js | /shop/1 | { slug: '1' } | app/shop/[tag]/[item]/icon.js | /shop/1/2 | { tag: '1', item: '2' } | Returns generateImageMetadata function return array objects containing image's metadata alt size . addition, item must include id value passed props image generating function. | Image Metadata Object | Type | |---|---| id | string (required) | alt | string | size | { width: number; height: number } | contentType | string | import { ImageResponse } 'next/og' export function generateImageMetadata() { return [ { contentType: 'image/png', size: { width: 48, height: 48 }, id: 'small', }, { contentType: 'image/png', size: { width: 72, height: 72 }, id: 'medium', }, ] } export default function Icon({ id }: { id: string }) { return new ImageResponse( ( <div style={{ width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: 88, background: '#000', color: '#fafafa', }} > Icon {id} </div> ) ) } Examples Using external data example uses params object external data generate multiple Open Graph images route segment. import { ImageResponse } 'next/og' import { getCaptionForImage, getOGImages } '@/app/utils/images' export async function generateImageMetadata({ params, }: { params: { id: string } }) { const images = await getOGImages(params.id) return images.map((image, idx) => ({ id: idx, size: { width: 1200, height: 600 }, alt: image.text, contentType: 'image/png', })) } export default async function Image({ params, id, }: { params: { id: string } id: number }) { const productId = (await params).id const imageId = id const text = await getCaptionForImage(productId, imageId) return new ImageResponse( ( <div style={ { // ... } } > {text} </div> ) ) } Version History | Version | Changes | |---|---| v13.3.0 | generateImageMetadata introduced. | Next Steps helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/generate-metadata", "title": "Functions: generateMetadata | Next.js", "text": "generateMetadata page covers Config-based Metadata options generateMetadata static metadata object. import type { Metadata } 'next' // either Static metadata export const metadata: Metadata = { title: '...', } // Dynamic metadata export async function generateMetadata({ params }) { return { title: '...', } } Good know: - metadata object andgenerateMetadata function exports supported Server Components.- cannot export metadata object andgenerateMetadata function route segment. metadata object define static metadata, export Metadata object layout.js page.js file. import type { Metadata } 'next' export const metadata: Metadata = { title: '...', description: '...', } export default function Page() {} See Metadata Fields complete list supported options. generateMetadata function Dynamic metadata depends dynamic information, current route parameters, external data, metadata parent segments, set exporting generateMetadata function returns Metadata object. import type { Metadata, ResolvingMetadata } 'next' type Props = { params: Promise<{ id: string }> searchParams: Promise<{ [key: string]: string | string[] | undefined }> } export async function generateMetadata( { params, searchParams }: Props, parent: ResolvingMetadata ): Promise<Metadata> { // read route params const id = (await params).id // fetch data const product = await fetch(`https://.../${id}`).then((res) => res.json()) // optionally access extend (rather replace) parent metadata const previousImages = (await parent).openGraph?.images || [] return { title: product.title, openGraph: { images: ['/some-specific-page-image.jpg', ...previousImages], }, } } export default function Page({ params, searchParams }: Props) {} Parameters generateMetadata function accepts following parameters: - props - object containing parameters current route:- params - object containing dynamic route parameters object root segment segmentgenerateMetadata called from. Examples:Route URL params app/shop/[slug]/page.js /shop/1 { slug: '1' } app/shop/[tag]/[item]/page.js /shop/1/2 { tag: '1', item: '2' } app/shop/[...slug]/page.js /shop/1/2 { slug: ['1', '2'] } - searchParams - object containing current URL's search params. Examples:URL searchParams /shop?a=1 { a: '1' } /shop?a=1&b=2 { a: '1', b: '2' } /shop?a=1&a=2 { a: ['1', '2'] } - - parent - promise resolved metadata parent route segments. Returns generateMetadata return Metadata object containing one metadata fields. Good know: - metadata depend runtime information, defined using static metadata object rather thangenerateMetadata .fetch requests automatically memoized data acrossgenerateMetadata ,generateStaticParams , Layouts, Pages, Server Components. Reactcache used iffetch unavailable.searchParams available inpage.js segments.- redirect() andnotFound() Next.js methods also used insidegenerateMetadata . Metadata Fields title title attribute used set title document. defined simple string optional template object. String export const metadata = { title: 'Next.js', } <title>Next.js</title> Template object import type { Metadata } 'next' export const metadata: Metadata = { title: { template: '...', default: '...', absolute: '...', }, } Default title.default used provide fallback title child route segments define title . import type { Metadata } 'next' export const metadata: Metadata = { title: { default: 'Acme', }, } import type { Metadata } 'next' export const metadata: Metadata = {} // Output: <title>Acme</title> Template title.template used add prefix suffix titles defined child route segments. import type { Metadata } 'next' export const metadata: Metadata = { title: { template: '%s | Acme', default: 'Acme', // default required creating template }, } import type { Metadata } 'next' export const metadata: Metadata = { title: 'About', } // Output: <title>About | Acme</title> Good know: title.template applies child route segments segment defined in. means: title.default required add atitle.template .title.template defined inlayout.js apply atitle defined apage.js route segment.title.template defined inpage.js effect page always terminating segment (it children route segments). title.template effect route defined atitle ortitle.default . Absolute title.absolute used provide title ignores title.template set parent segments. import type { Metadata } 'next' export const metadata: Metadata = { title: { template: '%s | Acme', }, } import type { Metadata } 'next' export const metadata: Metadata = { title: { absolute: 'About', }, } // Output: <title>About</title> Good know: layout.js title (string) andtitle.default define default title child segments (that define owntitle ). augmenttitle.template closest parent segment exists.title.absolute defines default title child segments. ignorestitle.template parent segments.title.template defines new title template child segments. page.js - page define title closest parents resolved title used. title (string) defines routes title. augmenttitle.template closest parent segment exists.title.absolute defines route title. ignorestitle.template parent segments.title.template effect inpage.js page always terminating segment route. description export const metadata = { description: 'The React Framework Web', } <meta name=\"description\" content=\"The React Framework Web\" /> Basic Fields export const metadata = { generator: 'Next.js', applicationName: 'Next.js', referrer: 'origin-when-cross-origin', keywords: ['Next.js', 'React', 'JavaScript'], authors: [{ name: 'Seb' }, { name: 'Josh', url: 'https://nextjs.org' }], creator: 'Jiachi Liu', publisher: 'Sebastian Markb\u00e5ge', formatDetection: { email: false, address: false, telephone: false, }, } <meta name=\"application-name\" content=\"Next.js\" /> <meta name=\"author\" content=\"Seb\" /> <link rel=\"author\" href=\"https://nextjs.org\" /> <meta name=\"author\" content=\"Josh\" /> <meta name=\"generator\" content=\"Next.js\" /> <meta name=\"keywords\" content=\"Next.js,React,JavaScript\" /> <meta name=\"referrer\" content=\"origin-when-cross-origin\" /> <meta name=\"color-scheme\" content=\"dark\" /> <meta name=\"creator\" content=\"Jiachi Liu\" /> <meta name=\"publisher\" content=\"Sebastian Markb\u00e5ge\" /> <meta name=\"format-detection\" content=\"telephone=no, address=no, email=no\" /> metadataBase metadataBase convenience option set base URL prefix metadata fields require fully qualified URL. metadataBase allows URL-basedmetadata fields defined current route segment use relative path instead otherwise required absolute URL.- field's relative path composed metadataBase form fully qualified URL. - configured, metadataBase automatically populated default value. export const metadata = { metadataBase: new URL('https://acme.com'), alternates: { canonical: '/', languages: { 'en-US': '/en-US', 'de-DE': '/de-DE', }, }, openGraph: { images: '/og-image.png', }, } <link rel=\"canonical\" href=\"https://acme.com\" /> <link rel=\"alternate\" hreflang=\"en-US\" href=\"https://acme.com/en-US\" /> <link rel=\"alternate\" hreflang=\"de-DE\" href=\"https://acme.com/de-DE\" /> <meta property=\"og:image\" content=\"https://acme.com/og-image.png\" /> Good know: metadataBase typically set rootapp/layout.js apply URL-basedmetadata fields across routes.- URL-based metadata fields require absolute URLs configured ametadataBase option.metadataBase contain subdomain e.g.https://app.acme.com base path e.g.https://acme.com/start/from/here - metadata field provides absolute URL,metadataBase ignored.- Using relative path URL-based metadata field without configuring ametadataBase cause build error.- Next.js normalize duplicate slashes metadataBase (e.g.https://acme.com/ ) relative field (e.g./path ) single slash (e.g.https://acme.com/path ) Default value configured, metadataBase default value. Vercel: - production deployments, VERCEL_PROJECT_PRODUCTION_URL used.- preview deployments, VERCEL_BRANCH_URL take priority, fallback toVERCEL_URL present.If values present used default value metadataBase , otherwise falls back tohttp://localhost:${process.env.PORT || 3000} . allows Open Graph images work local build Vercel preview production deployments. overriding default, recommend using environment variables compute URL. allows configuring URL local development, staging, production environments.See details environment variables System Environment Variables docs. URL Composition URL composition favors developer intent default directory traversal semantics. - Trailing slashes metadataBase andmetadata fields normalized. - \"absolute\" path metadata field (that typically would replace whole URL path) treated \"relative\" path (starting end ofmetadataBase ). example, given following metadataBase : import type { Metadata } 'next' export const metadata: Metadata = { metadataBase: new URL('https://acme.com'), } metadata fields inherit metadataBase set value resolved follows: metadata field | Resolved URL | |---|---| / | https://acme.com | ./ | https://acme.com | payments | https://acme.com/payments | /payments | https://acme.com/payments | ./payments | https://acme.com/payments | ../payments | https://acme.com/payments | https://beta.acme.com/payments | https://beta.acme.com/payments | openGraph export const metadata = { openGraph: { title: 'Next.js', description: 'The React Framework Web', url: 'https://nextjs.org', siteName: 'Next.js', images: [ { url: 'https://nextjs.org/og.png', // Must absolute URL width: 800, height: 600, }, { url: 'https://nextjs.org/og-alt.png', // Must absolute URL width: 1800, height: 1600, alt: 'My custom alt', }, ], videos: [ { url: 'https://nextjs.org/video.mp4', // Must absolute URL width: 800, height: 600, }, ], audio: [ { url: 'https://nextjs.org/audio.mp3', // Must absolute URL }, ], locale: 'en_US', type: 'website', }, } <meta property=\"og:title\" content=\"Next.js\" /> <meta property=\"og:description\" content=\"The React Framework Web\" /> <meta property=\"og:url\" content=\"https://nextjs.org/\" /> <meta property=\"og:site_name\" content=\"Next.js\" /> <meta property=\"og:locale\" content=\"en_US\" /> <meta property=\"og:image\" content=\"https://nextjs.org/og.png\" /> <meta property=\"og:image:width\" content=\"800\" /> <meta property=\"og:image:height\" content=\"600\" /> <meta property=\"og:image\" content=\"https://nextjs.org/og-alt.png\" /> <meta property=\"og:image:width\" content=\"1800\" /> <meta property=\"og:image:height\" content=\"1600\" /> <meta property=\"og:image:alt\" content=\"My custom alt\" /> <meta property=\"og:video\" content=\"https://nextjs.org/video.mp4\" /> <meta property=\"og:video:width\" content=\"800\" /> <meta property=\"og:video:height\" content=\"600\" /> <meta property=\"og:audio\" content=\"https://nextjs.org/audio.mp3\" /> <meta property=\"og:type\" content=\"website\" /> export const metadata = { openGraph: { title: 'Next.js', description: 'The React Framework Web', type: 'article', publishedTime: '2023-01-01T00:00:00.000Z', authors: ['Seb', 'Josh'], }, } <meta property=\"og:title\" content=\"Next.js\" /> <meta property=\"og:description\" content=\"The React Framework Web\" /> <meta property=\"og:type\" content=\"article\" /> <meta property=\"article:published_time\" content=\"2023-01-01T00:00:00.000Z\" /> <meta property=\"article:author\" content=\"Seb\" /> <meta property=\"article:author\" content=\"Josh\" /> Good know: - may convenient use file-based Metadata API Open Graph images. Rather sync config export actual files, file-based API automatically generate correct metadata you. robots import type { Metadata } 'next' export const metadata: Metadata = { robots: { index: true, follow: true, nocache: false, googleBot: { index: true, follow: true, noimageindex: false, 'max-video-preview': -1, 'max-image-preview': 'large', 'max-snippet': -1, }, }, } <meta name=\"robots\" content=\"index, follow\" /> <meta name=\"googlebot\" content=\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\" /> icons Good know: recommend using file-based Metadata API icons possible. Rather sync config export actual files, file-based API automatically generate correct metadata you. export const metadata = { icons: { icon: '/icon.png', shortcut: '/shortcut-icon.png', apple: '/apple-icon.png', other: { rel: 'apple-touch-icon-precomposed', url: '/apple-touch-icon-precomposed.png', }, }, } <link rel=\"shortcut icon\" href=\"/shortcut-icon.png\" /> <link rel=\"icon\" href=\"/icon.png\" /> <link rel=\"apple-touch-icon\" href=\"/apple-icon.png\" /> <link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-precomposed.png\" /> export const metadata = { icons: { icon: [ { url: '/icon.png' }, new URL('/icon.png', 'https://example.com'), { url: '/icon-dark.png', media: '(prefers-color-scheme: dark)' }, ], shortcut: ['/shortcut-icon.png'], apple: [ { url: '/apple-icon.png' }, { url: '/apple-icon-x3.png', sizes: '180x180', type: 'image/png' }, ], other: [ { rel: 'apple-touch-icon-precomposed', url: '/apple-touch-icon-precomposed.png', }, ], }, } <link rel=\"shortcut icon\" href=\"/shortcut-icon.png\" /> <link rel=\"icon\" href=\"/icon.png\" /> <link rel=\"icon\" href=\"https://example.com/icon.png\" /> <link rel=\"icon\" href=\"/icon-dark.png\" media=\"(prefers-color-scheme: dark)\" /> <link rel=\"apple-touch-icon\" href=\"/apple-icon.png\" /> <link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-precomposed.png\" /> <link rel=\"apple-touch-icon\" href=\"/apple-icon-x3.png\" sizes=\"180x180\" type=\"image/png\" /> Good know: msapplication-* meta tags longer supported Chromium builds Microsoft Edge, thus longer needed. themeColor Deprecated: themeColor option inmetadata deprecated Next.js 14. Please use theviewport configuration instead. colorScheme Deprecated: colorScheme option inmetadata deprecated Next.js 14. Please use theviewport configuration instead. manifest web application manifest, defined Web Application Manifest specification. export const metadata = { manifest: 'https://nextjs.org/manifest.json', } <link rel=\"manifest\" href=\"https://nextjs.org/manifest.json\" /> twitter Twitter specification (surprisingly) used X (formerly known Twitter). Learn Twitter Card markup reference. export const metadata = { twitter: { card: 'summary_large_image', title: 'Next.js', description: 'The React Framework Web', siteId: '1467726470533754880', creator: '@nextjs', creatorId: '1467726470533754880', images: ['https://nextjs.org/og.png'], // Must absolute URL }, } <meta name=\"twitter:card\" content=\"summary_large_image\" /> <meta name=\"twitter:site:id\" content=\"1467726470533754880\" /> <meta name=\"twitter:creator\" content=\"@nextjs\" /> <meta name=\"twitter:creator:id\" content=\"1467726470533754880\" /> <meta name=\"twitter:title\" content=\"Next.js\" /> <meta name=\"twitter:description\" content=\"The React Framework Web\" /> <meta name=\"twitter:image\" content=\"https://nextjs.org/og.png\" /> export const metadata = { twitter: { card: 'app', title: 'Next.js', description: 'The React Framework Web', siteId: '1467726470533754880', creator: '@nextjs', creatorId: '1467726470533754880', images: { url: 'https://nextjs.org/og.png', alt: 'Next.js Logo', }, app: { name: 'twitter_app', id: { iphone: 'twitter_app://iphone', ipad: 'twitter_app://ipad', googleplay: 'twitter_app://googleplay', }, url: { iphone: 'https://iphone_url', ipad: 'https://ipad_url', }, }, }, } <meta name=\"twitter:site:id\" content=\"1467726470533754880\" /> <meta name=\"twitter:creator\" content=\"@nextjs\" /> <meta name=\"twitter:creator:id\" content=\"1467726470533754880\" /> <meta name=\"twitter:title\" content=\"Next.js\" /> <meta name=\"twitter:description\" content=\"The React Framework Web\" /> <meta name=\"twitter:card\" content=\"app\" /> <meta name=\"twitter:image\" content=\"https://nextjs.org/og.png\" /> <meta name=\"twitter:image:alt\" content=\"Next.js Logo\" /> <meta name=\"twitter:app:name:iphone\" content=\"twitter_app\" /> <meta name=\"twitter:app:id:iphone\" content=\"twitter_app://iphone\" /> <meta name=\"twitter:app:id:ipad\" content=\"twitter_app://ipad\" /> <meta name=\"twitter:app:id:googleplay\" content=\"twitter_app://googleplay\" /> <meta name=\"twitter:app:url:iphone\" content=\"https://iphone_url\" /> <meta name=\"twitter:app:url:ipad\" content=\"https://ipad_url\" /> <meta name=\"twitter:app:name:ipad\" content=\"twitter_app\" /> <meta name=\"twitter:app:name:googleplay\" content=\"twitter_app\" /> viewport Deprecated: viewport option inmetadata deprecated Next.js 14. Please use theviewport configuration instead. verification export const metadata = { verification: { google: 'google', yandex: 'yandex', yahoo: 'yahoo', other: { me: ['my-email', 'my-link'], }, }, } <meta name=\"google-site-verification\" content=\"google\" /> <meta name=\"y_key\" content=\"yahoo\" /> <meta name=\"yandex-verification\" content=\"yandex\" /> <meta name=\"me\" content=\"my-email\" /> <meta name=\"me\" content=\"my-link\" /> appleWebApp export const metadata = { itunes: { appId: 'myAppStoreID', appArgument: 'myAppArgument', }, appleWebApp: { title: 'Apple Web App', statusBarStyle: 'black-translucent', startupImage: [ '/assets/startup/apple-touch-startup-image-768x1004.png', { url: '/assets/startup/apple-touch-startup-image-1536x2008.png', media: '(device-width: 768px) (device-height: 1024px)', }, ], }, } <meta name=\"apple-itunes-app\" content=\"app-id=myAppStoreID, app-argument=myAppArgument\" /> <meta name=\"mobile-web-app-capable\" content=\"yes\" /> <meta name=\"apple-mobile-web-app-title\" content=\"Apple Web App\" /> <link href=\"/assets/startup/apple-touch-startup-image-768x1004.png\" rel=\"apple-touch-startup-image\" /> <link href=\"/assets/startup/apple-touch-startup-image-1536x2008.png\" media=\"(device-width: 768px) (device-height: 1024px)\" rel=\"apple-touch-startup-image\" /> <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\" /> alternates export const metadata = { alternates: { canonical: 'https://nextjs.org', languages: { 'en-US': 'https://nextjs.org/en-US', 'de-DE': 'https://nextjs.org/de-DE', }, media: { 'only screen (max-width: 600px)': 'https://nextjs.org/mobile', }, types: { 'application/rss+xml': 'https://nextjs.org/rss', }, }, } <link rel=\"canonical\" href=\"https://nextjs.org\" /> <link rel=\"alternate\" hreflang=\"en-US\" href=\"https://nextjs.org/en-US\" /> <link rel=\"alternate\" hreflang=\"de-DE\" href=\"https://nextjs.org/de-DE\" /> <link rel=\"alternate\" media=\"only screen (max-width: 600px)\" href=\"https://nextjs.org/mobile\" /> <link rel=\"alternate\" type=\"application/rss+xml\" href=\"https://nextjs.org/rss\" /> appLinks export const metadata = { appLinks: { ios: { url: 'https://nextjs.org/ios', app_store_id: 'app_store_id', }, android: { package: 'com.example.android/package', app_name: 'app_name_android', }, web: { url: 'https://nextjs.org/web', should_fallback: true, }, }, } <meta property=\"al:ios:url\" content=\"https://nextjs.org/ios\" /> <meta property=\"al:ios:app_store_id\" content=\"app_store_id\" /> <meta property=\"al:android:package\" content=\"com.example.android/package\" /> <meta property=\"al:android:app_name\" content=\"app_name_android\" /> <meta property=\"al:web:url\" content=\"https://nextjs.org/web\" /> <meta property=\"al:web:should_fallback\" content=\"true\" /> archives Describes collection records, documents, materials historical interest (source). export const metadata = { archives: ['https://nextjs.org/13'], } <link rel=\"archives\" href=\"https://nextjs.org/13\" /> assets export const metadata = { assets: ['https://nextjs.org/assets'], } <link rel=\"assets\" href=\"https://nextjs.org/assets\" /> bookmarks export const metadata = { bookmarks: ['https://nextjs.org/13'], } <link rel=\"bookmarks\" href=\"https://nextjs.org/13\" /> category export const metadata = { category: 'technology', } <meta name=\"category\" content=\"technology\" /> facebook connect Facebook app Facebook account webpage certain Facebook Social Plugins Facebook Documentation Good know: specify either appId admins, both. export const metadata = { facebook: { appId: '12345678', }, } <meta property=\"fb:app_id\" content=\"12345678\" /> export const metadata = { facebook: { admins: '12345678', }, } <meta property=\"fb:admins\" content=\"12345678\" /> want generate multiple fb:admins meta tags use array value. export const metadata = { facebook: { admins: ['12345678', '87654321'], }, } <meta property=\"fb:admins\" content=\"12345678\" /> <meta property=\"fb:admins\" content=\"87654321\" /> metadata options covered using built-in support. However, may custom metadata tags specific site, brand new metadata tags released. use option render custom metadata tag. export const metadata = { other: { custom: 'meta', }, } <meta name=\"custom\" content=\"meta\" /> want generate multiple key meta tags use array value. export const metadata = { other: { custom: ['meta1', 'meta2'], }, } <meta name=\"custom\" content=\"meta1\" /> <meta name=\"custom\" content=\"meta2\" /> Unsupported Metadata following metadata types currently built-in support. However, still rendered layout page itself. | Metadata | Recommendation | |---|---| <meta http-equiv=\"...\"> | Use appropriate HTTP Headers via redirect() , Middleware, Security Headers | <base> | Render tag layout page itself. | <noscript> | Render tag layout page itself. | <style> | Learn styling Next.js. | <script> | Learn using scripts. | <link rel=\"stylesheet\" /> | import stylesheets directly layout page itself. | <link rel=\"preload /> | Use ReactDOM preload method | <link rel=\"preconnect\" /> | Use ReactDOM preconnect method | <link rel=\"dns-prefetch\" /> | Use ReactDOM prefetchDNS method | Resource hints <link> element number rel keywords used hint browser external resource likely needed. browser uses information apply preloading optimizations depending keyword. Metadata API directly support hints, use new ReactDOM methods safely insert <head> document. 'use client' import ReactDOM 'react-dom' export function PreloadResources() { ReactDOM.preload('...', { as: '...' }) ReactDOM.preconnect('...', { crossOrigin: '...' }) ReactDOM.prefetchDNS('...') return '...' } <link rel=\"preload\"> Start loading resource early page rendering (browser) lifecycle. MDN Docs. ReactDOM.preload(href: string, options: { as: string }) <link rel=\"preload\" href=\"...\" as=\"...\" /> <link rel=\"preconnect\"> Preemptively initiate connection origin. MDN Docs. ReactDOM.preconnect(href: string, options?: { crossOrigin?: string }) <link rel=\"preconnect\" href=\"...\" crossorigin /> <link rel=\"dns-prefetch\"> Attempt resolve domain name resources get requested. MDN Docs. ReactDOM.prefetchDNS(href: string) <link rel=\"dns-prefetch\" href=\"...\" /> Good know: - methods currently supported Client Components, still Server Side Rendered initial page load. - Next.js in-built features next/font ,next/image andnext/script automatically handle relevant resource hints. Types add type safety metadata using Metadata type. using built-in TypeScript plugin IDE, need manually add type, still explicitly add want. metadata object import type { Metadata } 'next' export const metadata: Metadata = { title: 'Next.js', } generateMetadata function Regular function import type { Metadata } 'next' export function generateMetadata(): Metadata { return { title: 'Next.js', } } Async function import type { Metadata } 'next' export async function generateMetadata(): Promise<Metadata> { return { title: 'Next.js', } } segment props import type { Metadata } 'next' type Props = { params: Promise<{ id: string }> searchParams: Promise<{ [key: string]: string | string[] | undefined }> } export function generateMetadata({ params, searchParams }: Props): Metadata { return { title: 'Next.js', } } export default function Page({ params, searchParams }: Props) {} parent metadata import type { Metadata, ResolvingMetadata } 'next' export async function generateMetadata( { params, searchParams }: Props, parent: ResolvingMetadata ): Promise<Metadata> { return { title: 'Next.js', } } JavaScript Projects JavaScript projects, use JSDoc add type safety. /** @type {import(\"next\").Metadata} */ export const metadata = { title: 'Next.js', } Streaming Metadata Starting v15.2, metadata returned generateMetadata streamed client. allows Next.js inject metadata HTML soon resolved. Since page metadata often primarily targets bots & crawlers, Next.js continue block render metadata resolved HTML-limited bots. bots, like Googlebot , execute JavaScript able inspect full page DOM, meaning require blocking metadata. However, bots like Twitterbot cannot execute JavaScript crawling page\u2014they fall HTML-limited category. Next.js automatically detects user agent incoming requests determine whether serve streaming metadata fallback blocking metadata. need customize list, define manually using htmlLimitedBots option next.config.js . Next.js ensure user agents matching regex receive blocking metadata requesting web page. module.exports = { htmlLimitedBots: 'MySpecialBot|MyAnotherSpecialBot|SimpleCrawler', } Version History | Version | Changes | |---|---| v15.2.0 | introduced streaming support generateMetadata . | v13.2.0 | viewport , themeColor , colorScheme deprecated favor viewport configuration. | v13.2.0 | metadata generateMetadata introduced. | Next Steps helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/generate-sitemaps", "title": "Functions: generateSitemaps | Next.js", "text": "generateSitemaps use generateSitemaps function generate multiple sitemaps application. Returns generateSitemaps returns array objects id property. URLs generated sitemaps available /.../sitemap/[id].xml . example, /product/sitemap/1.xml . Example example, split sitemap using generateSitemaps , return array objects sitemap id . Then, use id generate unique sitemaps. app/product/sitemap.ts import { BASE_URL } '@/app/lib/constants' export async function generateSitemaps() { // Fetch total number products calculate number sitemaps needed return [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }] } export default async function sitemap({ id, }: { id: number }): Promise<MetadataRoute.Sitemap> { // Google's limit 50,000 URLs per sitemap const start = id * 50000 const end = start + 50000 const products = await getProducts( `SELECT id, date products id ${start} ${end}` ) return products.map((product) => ({ url: `${BASE_URL}/product/${product.id}`, lastModified: product.date, })) } Version History | Version | Changes | |---|---| v15.0.0 | generateSitemaps generates consistent URLs development production | v13.3.2 | generateSitemaps introduced. development, view generated sitemap /.../sitemap.xml/[id] . example, /product/sitemap.xml/1 . | Next Steps Learn create sitemaps Next.js application. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/generate-static-params", "title": "Functions: generateStaticParams | Next.js", "text": "generateStaticParams generateStaticParams function used combination dynamic route segments statically generate routes build time instead on-demand request time. // Return list `params` populate [slug] dynamic segment export async function generateStaticParams() { const posts = await fetch('https://.../posts').then((res) => res.json()) return posts.map((post) => ({ slug: post.slug, })) } // Multiple versions page statically generated // using `params` returned `generateStaticParams` export default async function Page({ params, }: { params: Promise<{ slug: string }> }) { const { slug } = await params // ... } Good know: - use dynamicParams segment config option control happens dynamic segment visited generated withgenerateStaticParams .- must return empty array generateStaticParams utilizeexport const dynamic = 'force-static' order revalidate (ISR) paths runtime.- next dev ,generateStaticParams called navigate route.- next build ,generateStaticParams runs corresponding Layouts Pages generated.- revalidation (ISR), generateStaticParams called again.generateStaticParams replaces thegetStaticPaths function Pages Router. Parameters options.params (optional) multiple dynamic segments route use generateStaticParams , child generateStaticParams function executed set params parent generates. params object contains populated params parent generateStaticParams , used generate params child segment. Returns generateStaticParams return array objects object represents populated dynamic segments single route. - property object dynamic segment filled route. - properties name segment's name, properties value segment filled with. | Example Route | generateStaticParams Return Type | |---|---| /product/[id] | { id: string }[] | /products/[category]/[product] | { category: string, product: string }[] | /products/[...slug] | { slug: string[] }[] | Single Dynamic Segment export function generateStaticParams() { return [{ id: '1' }, { id: '2' }, { id: '3' }] } // Three versions page statically generated // using `params` returned `generateStaticParams` // - /product/1 // - /product/2 // - /product/3 export default async function Page({ params, }: { params: Promise<{ id: string }> }) { const { id } = await params // ... } Multiple Dynamic Segments export function generateStaticParams() { return [ { category: 'a', product: '1' }, { category: 'b', product: '2' }, { category: 'c', product: '3' }, ] } // Three versions page statically generated // using `params` returned `generateStaticParams` // - /products/a/1 // - /products/b/2 // - /products/c/3 export default async function Page({ params, }: { params: Promise<{ category: string; product: string }> }) { const { category, product } = await params // ... } Catch-all Dynamic Segment export function generateStaticParams() { return [{ slug: ['a', '1'] }, { slug: ['b', '2'] }, { slug: ['c', '3'] }] } // Three versions page statically generated // using `params` returned `generateStaticParams` // - /product/a/1 // - /product/b/2 // - /product/c/3 export default async function Page({ params, }: { params: Promise<{ slug: string[] }> }) { const { slug } = await params // ... } Examples Static Rendering paths build time statically render paths build time, supply full list paths generateStaticParams : export async function generateStaticParams() { const posts = await fetch('https://.../posts').then((res) => res.json()) return posts.map((post) => ({ slug: post.slug, })) } Subset paths build time statically render subset paths build time, rest first time visited runtime, return partial list paths: export async function generateStaticParams() { const posts = await fetch('https://.../posts').then((res) => res.json()) // Render first 10 posts build time return posts.slice(0, 10).map((post) => ({ slug: post.slug, })) } Then, using dynamicParams segment config option, control happens dynamic segment visited generated generateStaticParams . // posts besides top 10 404 export const dynamicParams = false export async function generateStaticParams() { const posts = await fetch('https://.../posts').then((res) => res.json()) const topPosts = posts.slice(0, 10) return topPosts.map((post) => ({ slug: post.slug, })) } paths runtime statically render paths first time visited, return empty array (no paths rendered build time) utilize export const dynamic = 'force-static' : export async function generateStaticParams() { return [] } Good know: must always return array generateStaticParams , even empty. Otherwise, route dynamically rendered. export const dynamic = 'force-static' Disable rendering unspecified paths prevent unspecified paths statically rendered runtime, add export const dynamicParams = false option route segment. config option used, paths provided generateStaticParams served, unspecified routes 404 match (in case catch-all routes). Multiple Dynamic Segments Route generate params dynamic segments current layout page, below. example, given app/products/[category]/[product] route: app/products/[category]/[product]/page.js generate params both[category] and[product] .app/products/[category]/layout.js generate params for[category] . two approaches generating params route multiple dynamic segments: Generate params bottom Generate multiple dynamic segments child route segment. // Generate segments [category] [product] export async function generateStaticParams() { const products = await fetch('https://.../products').then((res) => res.json()) return products.map((product) => ({ category: product.category.slug, product: product.id, })) } export default function Page({ params, }: { params: Promise<{ category: string; product: string }> }) { // ... } Generate params top Generate parent segments first use result generate child segments. // Generate segments [category] export async function generateStaticParams() { const products = await fetch('https://.../products').then((res) => res.json()) return products.map((product) => ({ category: product.category.slug, })) } export default function Layout({ params, }: { params: Promise<{ category: string }> }) { // ... } child route segment's generateStaticParams function executed segment parent generateStaticParams generates. child generateStaticParams function use params returned parent generateStaticParams function dynamically generate segments. // Generate segments [product] using `params` passed // parent segment's `generateStaticParams` function export async function generateStaticParams({ params: { category }, }: { params: { category: string } }) { const products = await fetch( `https://.../products?category=${category}` ).then((res) => res.json()) return products.map((product) => ({ product: product.id, })) } export default function Page({ params, }: { params: Promise<{ category: string; product: string }> }) { // ... } Good know: fetch requests automatically memoized data across allgenerate -prefixed functions, Layouts, Pages, Server Components. Reactcache used iffetch unavailable. Version History | Version | Changes | |---|---| v13.0.0 | generateStaticParams introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/generate-viewport", "title": "Functions: generateViewport | Next.js", "text": "generateViewport customize initial viewport page static viewport object dynamic generateViewport function. Good know: - viewport object andgenerateViewport function exports supported Server Components.- cannot export viewport object andgenerateViewport function route segment.- coming migrating metadata exports, use metadata-to-viewport-export codemod update changes. viewport object define viewport options, export viewport object layout.jsx page.jsx file. import type { Viewport } 'next' export const viewport: Viewport = { themeColor: 'black', } export default function Page() {} generateViewport function generateViewport return Viewport object containing one viewport fields. export function generateViewport({ params }) { return { themeColor: '...', } } Good know: - viewport depend runtime information, defined using static viewport object rather thangenerateViewport . Viewport Fields themeColor Learn theme-color . Simple theme color import type { Viewport } 'next' export const viewport: Viewport = { themeColor: 'black', } <meta name=\"theme-color\" content=\"black\" /> media attribute import type { Viewport } 'next' export const viewport: Viewport = { themeColor: [ { media: '(prefers-color-scheme: light)', color: 'cyan' }, { media: '(prefers-color-scheme: dark)', color: 'black' }, ], } <meta name=\"theme-color\" media=\"(prefers-color-scheme: light)\" content=\"cyan\" /> <meta name=\"theme-color\" media=\"(prefers-color-scheme: dark)\" content=\"black\" /> width , initialScale , maximumScale userScalable Good know: viewport meta tag automatically set, manual configuration usually unnecessary default sufficient. However, information provided completeness. import type { Viewport } 'next' export const viewport: Viewport = { width: 'device-width', initialScale: 1, maximumScale: 1, userScalable: false, // Also supported less commonly used // interactiveWidget: 'resizes-visual', } <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\" /> colorScheme Learn color-scheme . import type { Viewport } 'next' export const viewport: Viewport = { colorScheme: 'dark', } <meta name=\"color-scheme\" content=\"dark\" /> Types add type safety viewport object using Viewport type. using built-in TypeScript plugin IDE, need manually add type, still explicitly add want. viewport object import type { Viewport } 'next' export const viewport: Viewport = { themeColor: 'black', } generateViewport function Regular function import type { Viewport } 'next' export function generateViewport(): Viewport { return { themeColor: 'black', } } segment props import type { Viewport } 'next' type Props = { params: Promise<{ id: string }> searchParams: Promise<{ [key: string]: string | string[] | undefined }> } export function generateViewport({ params, searchParams }: Props): Viewport { return { themeColor: 'black', } } export default function Page({ params, searchParams }: Props) {} JavaScript Projects JavaScript projects, use JSDoc add type safety. /** @type {import(\"next\").Viewport} */ export const viewport = { themeColor: 'black', } Version History | Version | Changes | |---|---| v14.0.0 | viewport generateViewport introduced. | Next Steps helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/headers", "title": "Functions: headers | Next.js", "text": "headers headers async function allows read HTTP incoming request headers Server Component. app/page.tsx import { headers } 'next/headers' export default async function Page() { const headersList = await headers() const userAgent = headersList.get('user-agent') } Reference Parameters headers take parameters. Returns headers returns read-only Web Headers object. Headers.entries() : Returns aniterator allowing go key/value pairs contained object.Headers.forEach() : Executes provided function key/value pair thisHeaders object.Headers.get() : Returns aString sequence values header within aHeaders object given name.Headers.has() : Returns boolean stating whether aHeaders object contains certain header.Headers.keys() : Returns aniterator allowing go keys key/value pairs contained object.Headers.values() : Returns aniterator allowing go values key/value pairs contained object. Good know headers asynchronous function returns promise. must useasync/await React'suse function.- version 14 earlier, headers synchronous function. help backwards compatibility, still access synchronously Next.js 15, behavior deprecated future. - version 14 earlier, - Since headers read-only, cannotset ordelete outgoing request headers. headers Dynamic API whose returned values cannot known ahead time. Using opt route dynamic rendering. Examples Using Authorization header app/page.js import { headers } 'next/headers' export default async function Page() { const authorization = (await headers()).get('authorization') const res = await fetch('...', { headers: { authorization }, // Forward authorization header }) const user = await res.json() return <h1>{user.name}</h1> } Version History | Version | Changes | |---|---| v15.0.0-RC | headers async function. codemod available. | v13.0.0 | headers introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/image-response", "title": "Functions: ImageResponse | Next.js", "text": "ImageResponse ImageResponse constructor allows generate dynamic images using JSX CSS. useful generating social media images Open Graph images, Twitter cards, more. following options available ImageResponse : import { ImageResponse } 'next/og' new ImageResponse( element: ReactElement, options: { width?: number = 1200 height?: number = 630 emoji?: 'twemoji' | 'blobmoji' | 'noto' | 'openmoji' = 'twemoji', fonts?: { name: string, data: ArrayBuffer, weight: number, style: 'normal' | 'italic' }[] debug?: boolean = false // Options passed HTTP response status?: number = 200 statusText?: string headers?: Record<string, string> }, ) Supported CSS Properties Please refer Satori\u2019s documentation list supported HTML CSS features. Version History | Version | Changes | |---|---| v14.0.0 | ImageResponse moved next/server next/og | v13.3.0 | ImageResponse imported next/server . | v13.0.0 | ImageResponse introduced via @vercel/og package. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/next-request", "title": "Functions: NextRequest | Next.js", "text": "NextRequest NextRequest extends Web Request API additional convenience methods. cookies Read mutate Set-Cookie header request. set(name, value) Given name, set cookie given value request. // Given incoming request /home // Set cookie hide banner // request `Set-Cookie:show-banner=false;path=/home` header request.cookies.set('show-banner', 'false') get(name) Given cookie name, return value cookie. cookie found, undefined returned. multiple cookies found, first one returned. // Given incoming request /home // { name: 'show-banner', value: 'false', Path: '/home' } request.cookies.get('show-banner') getAll() Given cookie name, return values cookie. name given, return cookies request. // Given incoming request /home // [ // { name: 'experiments', value: 'new-pricing-page', Path: '/home' }, // { name: 'experiments', value: 'winter-launch', Path: '/home' }, // ] request.cookies.getAll('experiments') // Alternatively, get cookies request request.cookies.getAll() delete(name) Given cookie name, delete cookie request. // Returns true deleted, false nothing deleted request.cookies.delete('experiments') has(name) Given cookie name, return true cookie exists request. // Returns true cookie exists, false request.cookies.has('experiments') clear() Remove Set-Cookie header request. request.cookies.clear() nextUrl Extends native URL API additional convenience methods, including Next.js specific properties. // Given request /home, pathname /home request.nextUrl.pathname // Given request /home?name=lee, searchParams { 'name': 'lee' } request.nextUrl.searchParams following options available: | Property | Type | Description | |---|---|---| basePath | string | base path URL. | buildId | string | undefined | build identifier Next.js application. customized. | pathname | string | pathname URL. | searchParams | Object | search parameters URL. | Note: internationalization properties Pages Router available usage App Router. Learn internationalization App Router. Version History | Version | Changes | |---|---| v15.0.0 | ip geo removed. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/next-response", "title": "Functions: NextResponse | Next.js", "text": "NextResponse NextResponse extends Web Response API additional convenience methods. cookies Read mutate Set-Cookie header response. set(name, value) Given name, set cookie given value response. // Given incoming request /home let response = NextResponse.next() // Set cookie hide banner response.cookies.set('show-banner', 'false') // Response `Set-Cookie:show-banner=false;path=/home` header return response get(name) Given cookie name, return value cookie. cookie found, undefined returned. multiple cookies found, first one returned. // Given incoming request /home let response = NextResponse.next() // { name: 'show-banner', value: 'false', Path: '/home' } response.cookies.get('show-banner') getAll() Given cookie name, return values cookie. name given, return cookies response. // Given incoming request /home let response = NextResponse.next() // [ // { name: 'experiments', value: 'new-pricing-page', Path: '/home' }, // { name: 'experiments', value: 'winter-launch', Path: '/home' }, // ] response.cookies.getAll('experiments') // Alternatively, get cookies response response.cookies.getAll() delete(name) Given cookie name, delete cookie response. // Given incoming request /home let response = NextResponse.next() // Returns true deleted, false nothing deleted response.cookies.delete('experiments') json() Produce response given JSON body. import { NextResponse } 'next/server' export async function GET(request: Request) { return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 }) } redirect() Produce response redirects URL. import { NextResponse } 'next/server' return NextResponse.redirect(new URL('/new', request.url)) URL created modified used NextResponse.redirect() method. example, use request.nextUrl property get current URL, modify redirect different URL. import { NextResponse } 'next/server' // Given incoming request... const loginUrl = new URL('/login', request.url) // Add ?from=/incoming-url /login URL loginUrl.searchParams.set('from', request.nextUrl.pathname) // redirect new URL return NextResponse.redirect(loginUrl) rewrite() Produce response rewrites (proxies) given URL preserving original URL. import { NextResponse } 'next/server' // Incoming request: /about, browser shows /about // Rewritten request: /proxy, browser shows /about return NextResponse.rewrite(new URL('/proxy', request.url)) next() next() method useful Middleware, allows return early continue routing. import { NextResponse } 'next/server' return NextResponse.next() also forward headers producing response: import { NextResponse } 'next/server' // Given incoming request... const newHeaders = new Headers(request.headers) // Add new header newHeaders.set('x-version', '123') // produce response new headers return NextResponse.next({ request: { // New request headers headers: newHeaders, }, }) helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/not-found", "title": "Functions: notFound | Next.js", "text": "notFound notFound function allows render not-found file within route segment well inject <meta name=\"robots\" content=\"noindex\" /> tag. notFound() Invoking notFound() function throws NEXT_NOT_FOUND error terminates rendering route segment thrown. Specifying not-found file allows gracefully handle errors rendering Found UI within segment. app/user/[id]/page.js import { notFound } 'next/navigation' async function fetchUser(id) { const res = await fetch('https://...') (!res.ok) return undefined return res.json() } export default async function Profile({ params }) { const user = await fetchUser((await params).id) (!user) { notFound() } // ... } Good know: notFound() require usereturn notFound() due using TypeScriptnever type. Version History | Version | Changes | |---|---| v13.0.0 | notFound introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/permanentRedirect", "title": "Functions: permanentRedirect | Next.js", "text": "permanentRedirect permanentRedirect function allows redirect user another URL. permanentRedirect used Server Components, Client Components, Route Handlers, Server Actions. used streaming context, insert meta tag emit redirect client side. used server action, serve 303 HTTP redirect response caller. Otherwise, serve 308 (Permanent) HTTP redirect response caller. resource exist, use notFound function instead. Good know: prefer return 307 (Temporary) HTTP redirect instead 308 (Permanent), use redirect function instead. Parameters permanentRedirect function accepts two arguments: permanentRedirect(path, type) | Parameter | Type | Description | |---|---|---| path | string | URL redirect to. relative absolute path. | type | 'replace' (default) 'push' (default Server Actions) | type redirect perform. | default, permanentRedirect use push (adding new entry browser history stack) Server Actions replace (replacing current URL browser history stack) everywhere else. override behavior specifying type parameter. type parameter effect used Server Components. Returns permanentRedirect return value. Example Invoking permanentRedirect() function throws NEXT_REDIRECT error terminates rendering route segment thrown. import { permanentRedirect } 'next/navigation' async function fetchTeam(id) { const res = await fetch('https://...') (!res.ok) return undefined return res.json() } export default async function Profile({ params }) { const team = await fetchTeam((await params).id) (!team) { permanentRedirect('/login') } // ... } Good know: permanentRedirect require usereturn permanentRedirect() uses TypeScriptnever type. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/redirect", "title": "Functions: redirect | Next.js", "text": "redirect redirect function allows redirect user another URL. redirect used Server Components, Route Handlers, Server Actions. used streaming context, insert meta tag emit redirect client side. used server action, serve 303 HTTP redirect response caller. Otherwise, serve 307 HTTP redirect response caller. resource exist, use notFound function instead. Good know: - Server Actions Route Handlers, redirect called thetry/catch block.- prefer return 308 (Permanent) HTTP redirect instead 307 (Temporary), use permanentRedirect function instead. Parameters redirect function accepts two arguments: redirect(path, type) | Parameter | Type | Description | |---|---|---| path | string | URL redirect to. relative absolute path. | type | 'replace' (default) 'push' (default Server Actions) | type redirect perform. | default, redirect use push (adding new entry browser history stack) Server Actions replace (replacing current URL browser history stack) everywhere else. override behavior specifying type parameter. type parameter effect used Server Components. Returns redirect return value. Example Server Component Invoking redirect() function throws NEXT_REDIRECT error terminates rendering route segment thrown. import { redirect } 'next/navigation' async function fetchTeam(id: string) { const res = await fetch('https://...') (!res.ok) return undefined return res.json() } export default async function Profile({ params, }: { params: Promise<{ id: string }> }) { const { id } = await params const team = await fetchTeam(id) (!team) { redirect('/login') } // ... } Good know: redirect require usereturn redirect() uses TypeScriptnever type. Client Component redirect used Client Component Server Action. need use event handler redirect user, use useRouter hook. 'use client' import { navigate } './actions' export function ClientRedirect() { return ( <form action={navigate}> <input type=\"text\" name=\"id\" /> <button>Submit</button> </form> ) } 'use server' import { redirect } 'next/navigation' export async function navigate(data: FormData) { redirect(`/posts/${data.get('id')}`) } FAQ redirect use 307 308? using redirect() may notice status codes used 307 temporary redirect, 308 permanent redirect. traditionally 302 used temporary redirect, 301 permanent redirect, many browsers changed request method redirect, POST GET request using 302 , regardless origins request method. Taking following example redirect /users /people , make POST request /users create new user, conforming 302 temporary redirect, request method changed POST GET request. make sense, create new user, making POST request /people , GET request. introduction 307 status code means request method preserved POST . 302 - Temporary redirect, change request method fromPOST toGET 307 - Temporary redirect, preserve request method asPOST redirect() method uses 307 default, instead 302 temporary redirect, meaning requests always preserved POST requests. Learn HTTP Redirects. Version History | Version | Changes | |---|---| v13.0.0 | redirect introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/revalidatePath", "title": "Functions: revalidatePath | Next.js", "text": "revalidatePath revalidatePath allows purge cached data on-demand specific path. Good know: revalidatePath invalidates cache included path next visited. means callingrevalidatePath dynamic route segment immediately trigger many revalidations once. invalidation happens path next visited.- Currently, revalidatePath invalidates routes client-side Router Cache used server action. behavior temporary updated future apply specific path.- Using revalidatePath invalidates specific path server-side Route Cache. Parameters revalidatePath(path: string, type?: 'page' | 'layout'): void; path : Either string representing filesystem path associated data want revalidate (for example,/product/[slug]/page ), literal route segment (for example,/product/123 ). Must less 1024 characters. value case-sensitive.type : (optional)'page' or'layout' string change type path revalidate. Ifpath contains dynamic segment (for example,/product/[slug]/page ), parameter required. path refers literal route segment, e.g.,/product/1 dynamic page (e.g.,/product/[slug]/page ), providetype . Returns revalidatePath return value. Examples Revalidating Specific URL import { revalidatePath } 'next/cache' revalidatePath('/blog/post-1') revalidate one specific URL next page visit. Revalidating Page Path import { revalidatePath } 'next/cache' revalidatePath('/blog/[slug]', 'page') // route groups revalidatePath('/(main)/blog/[slug]', 'page') revalidate URL matches provided page file next page visit. invalidate pages beneath specific page. example, /blog/[slug] invalidate /blog/[slug]/[author] . Revalidating Layout Path import { revalidatePath } 'next/cache' revalidatePath('/blog/[slug]', 'layout') // route groups revalidatePath('/(main)/post/[slug]', 'layout') revalidate URL matches provided layout file next page visit. cause pages beneath layout revalidate next visit. example, case, /blog/[slug]/[another] would also revalidate next visit. Revalidating Data import { revalidatePath } 'next/cache' revalidatePath('/', 'layout') purge Client-side Router Cache, revalidate Data Cache next page visit. Server Action 'use server' import { revalidatePath } 'next/cache' export default async function submit() { await submitForm() revalidatePath('/') } Route Handler import { revalidatePath } 'next/cache' import type { NextRequest } 'next/server' export async function GET(request: NextRequest) { const path = request.nextUrl.searchParams.get('path') (path) { revalidatePath(path) return Response.json({ revalidated: true, now: Date.now() }) } return Response.json({ revalidated: false, now: Date.now(), message: 'Missing path revalidate', }) } helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/revalidateTag", "title": "Functions: revalidateTag | Next.js", "text": "revalidateTag revalidateTag allows purge cached data on-demand specific cache tag. Good know: revalidateTag invalidates cache path next visited. means callingrevalidateTag dynamic route segment immediately trigger many revalidations once. invalidation happens path next visited. Parameters revalidateTag(tag: string): void; tag : string representing cache tag associated data want revalidate. Must less equal 256 characters. value case-sensitive. add tags fetch follows: fetch(url, { next: { tags: [...] } }); Returns revalidateTag return value. Examples Server Action app/actions.ts 'use server' import { revalidateTag } 'next/cache' export default async function submit() { await addPost() revalidateTag('posts') } Route Handler app/api/revalidate/route.ts import type { NextRequest } 'next/server' import { revalidateTag } 'next/cache' export async function GET(request: NextRequest) { const tag = request.nextUrl.searchParams.get('tag') revalidateTag(tag) return Response.json({ revalidated: true, now: Date.now() }) } helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/unauthorized", "title": "Functions: unauthorized | Next.js", "text": "unauthorized feature currently experimental subject change, recommended production. Try share feedback GitHub. unauthorized function throws error renders Next.js 401 error page. useful handling authorization errors application. customize UI using unauthorized.js file. start using unauthorized , enable experimental authInterrupts configuration option next.config.js file: next.config.ts import type { NextConfig } 'next' const nextConfig: NextConfig = { experimental: { authInterrupts: true, }, } export default nextConfig unauthorized invoked Server Components, Server Actions, Route Handlers. app/dashboard/page.tsx import { verifySession } '@/app/lib/dal' import { unauthorized } 'next/navigation' export default async function DashboardPage() { const session = await verifySession() (!session) { unauthorized() } // Render dashboard authenticated users return ( <main> <h1>Welcome Dashboard</h1> <p>Hi, {session.user.name}.</p> </main> ) } Good know - unauthorized function cannot called root layout. Examples Displaying login UI unauthenticated users use unauthorized function display unauthorized.js file login UI. app/dashboard/page.tsx import { verifySession } '@/app/lib/dal' import { unauthorized } 'next/navigation' export default async function DashboardPage() { const session = await verifySession() (!session) { unauthorized() } return <div>Dashboard</div> } app/unauthorized.tsx import Login '@/app/components/Login' export default function UnauthorizedPage() { return ( <main> <h1>401 - Unauthorized</h1> <p>Please log access page.</p> <Login /> </main> ) } Mutations Server Actions invoke unauthorized Server Actions ensure authenticated users perform specific mutations. app/actions/update-profile.ts 'use server' import { verifySession } '@/app/lib/dal' import { unauthorized } 'next/navigation' import db '@/app/lib/db' export async function updateProfile(data: FormData) { const session = await verifySession() // user authenticated, return 401 (!session) { unauthorized() } // Proceed mutation // ... } Fetching data Route Handlers use unauthorized Route Handlers ensure authenticated users access endpoint. app/api/profile/route.ts import { NextRequest, NextResponse } 'next/server' import { verifySession } '@/app/lib/dal' import { unauthorized } 'next/navigation' export async function GET(req: NextRequest): Promise<NextResponse> { // Verify user's session const session = await verifySession() // session exists, return 401 render unauthorized.tsx (!session) { unauthorized() } // Fetch data // ... } Version History | Version | Changes | |---|---| v15.1.0 | unauthorized introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/after", "title": "Functions: after | Next.js", "text": "allows schedule work executed response (or prerender) finished. useful tasks side effects block response, logging analytics. used Server Components (including generateMetadata ), Server Actions, Route Handlers, Middleware. function accepts callback executed response (or prerender) finished: import { } 'next/server' // Custom logging function import { log } '@/app/utils' export default function Layout({ children }: { children: React.ReactNode }) { after(() => { // Execute layout rendered sent user log() }) return <>{children}</> } Good know: Dynamic API calling cause route become dynamic. used within static page, callback execute build time, whenever page revalidated. Reference Parameters - callback function executed response (or prerender) finished. Duration run platform's default configured max duration route. platform supports it, configure timeout limit using maxDuration route segment config. Good know executed even response complete successfully. Including error thrown whennotFound orredirect called.- use React cache deduplicate functions called insideafter . nested inside otherafter calls, example, create utility functions wrapafter calls add additional functionality. Alternatives use case process secondary tasks without blocking primary response. similar using platform's waitUntil() removing await promise, following differences: waitUntil() : accepts promise enqueues task executed lifecycle request, whereasafter accepts callback executed response finished.- Removing await : starts executing response, uses resources. also reliable serverless environments function stops computation immediately response sent, potentially interrupting task. recommend using designed consider Next.js APIs contexts. Examples request APIs use request APIs cookies headers inside Server Actions Route Handlers. useful logging activity mutation. example: import { } 'next/server' import { cookies, headers } 'next/headers' import { logUserAction } '@/app/utils' export async function POST(request: Request) { // Perform mutation // ... // Log user activity analytics after(async () => { const userAgent = (await headers().get('user-agent')) || 'unknown' const sessionCookie = (await cookies().get('session-id'))?.value || 'anonymous' logUserAction({ sessionCookie, userAgent }) }) return new Response(JSON.stringify({ status: 'success' }), { status: 200, headers: { 'Content-Type': 'application/json' }, }) } However, cannot use request APIs inside Server Components. Next.js needs know part tree access request APIs support Partial Prerendering, runs React's rendering lifecycle. | Version History | Description | |---|---| v15.1.0 | became stable. | v15.0.0-rc | unstable_after introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/unstable_cache", "title": "Functions: unstable_cache | Next.js", "text": "unstable_cache Note: API replaced use cache reaches stability. unstable_cache allows cache results expensive operations, like database queries, reuse across multiple requests. import { getUser } './data'; import { unstable_cache } 'next/cache'; const getCachedUser = unstable_cache( async (id) => getUser(id), ['my-app-user'] ); export default async function Component({ userID }) { const user = await getCachedUser(userID); ... } Good know: - Accessing dynamic data sources headers orcookies inside cache scope supported. need data inside cached function useheaders outside cached function pass required dynamic data argument.- API uses Next.js' built-in Data Cache persist result across requests deployments. Warning: API unstable may change future. provide migration documentation codemods, needed, API stabilizes. Parameters const data = unstable_cache(fetchData, keyParts, options)() fetchData : asynchronous function fetches data want cache. must function returns aPromise .keyParts : extra array keys adds identification cache. default,unstable_cache already uses arguments stringified version function cache key. optional cases; time need use use external variables without passing parameters. However, important add closures used within function pass parameters.options : object controls cache behaves. contain following properties:tags : array tags used control cache invalidation. Next.js use uniquely identify function.revalidate : number seconds cache revalidated. Omit passfalse cache indefinitely matchingrevalidateTag() orrevalidatePath() methods called. Returns unstable_cache returns function invoked, returns Promise resolves cached data. data cache, provided function invoked, result cached returned. Example app/page.tsx import { unstable_cache } 'next/cache' export default async function Page({ params, }: { params: Promise<{ userId: string }> }) { const userId = (await params).userId const getCachedUser = unstable_cache( async () => { return { id: userId } }, [userId], // add user ID cache key { tags: ['users'], revalidate: 60, } ) //... } Version History | Version | Changes | |---|---| v14.0.0 | unstable_cache introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/unstable_noStore", "title": "Functions: unstable_noStore | Next.js", "text": "unstable_noStore legacy API longer recommended. still supported backward compatibility. version 15, recommend using connection instead unstable_noStore . unstable_noStore used declaratively opt static rendering indicate particular component cached. import { unstable_noStore noStore } 'next/cache'; export default async function ServerComponent() { noStore(); const result = await db.query(...); ... } Good know: unstable_noStore equivalent tocache: 'no-store' afetch unstable_noStore preferred overexport const dynamic = 'force-dynamic' granular used per-component basis - Using unstable_noStore insideunstable_cache opt static generation. Instead, defer cache configuration determine whether cache result not. Usage prefer pass additional options fetch , like cache: 'no-store' , next: { revalidate: 0 } cases fetch available, use noStore() replacement use cases. import { unstable_noStore noStore } 'next/cache'; export default async function ServerComponent() { noStore(); const result = await db.query(...); ... } Version History | Version | Changes | |---|---| v15.0.0 | unstable_noStore deprecated connection . | v14.0.0 | unstable_noStore introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow", "title": "Functions: unstable_rethrow | Next.js", "text": "unstable_rethrow unstable_rethrow used avoid catching internal errors thrown Next.js attempting handle errors thrown application code. example, calling notFound function throw internal Next.js error render not-found.js component. However, used inside try/catch block, error caught, preventing not-found.js rendering: import { notFound } 'next/navigation' export default async function Page() { try { const post = await fetch('https://.../posts/1').then((res) => { (res.status === 404) notFound() (!res.ok) throw new Error(res.statusText) return res.json() }) } catch (err) { console.error(err) } } use unstable_rethrow API re-throw internal error continue expected behavior: import { notFound, unstable_rethrow } 'next/navigation' export default async function Page() { try { const post = await fetch('https://.../posts/1').then((res) => { (res.status === 404) notFound() (!res.ok) throw new Error(res.statusText) return res.json() }) } catch (err) { unstable_rethrow(err) console.error(err) } } following Next.js APIs rely throwing error rethrown handled Next.js itself: route segment marked throw error unless static, Dynamic API call also throw error similarly caught developer. Note Partial Prerendering (PPR) affects behavior well. APIs are: cookies headers searchParams fetch(..., { cache: 'no-store' }) fetch(..., { next: { revalidate: 0 } }) Good know: - method called top catch block, passing error object argument. also used within .catch handler promise.- ensure calls APIs throw wrapped try/catch need use unstable_rethrow - resource cleanup (like clearing intervals, timers, etc) would either happen prior call unstable_rethrow within afinally block. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-params", "title": "Functions: useParams | Next.js", "text": "useParams useParams Client Component hook lets read route's dynamic params filled current URL. app/example-client-component.tsx 'use client' import { useParams } 'next/navigation' export default function ExampleClientComponent() { const params = useParams<{ tag: string; item: string }>() // Route -> /shop/[tag]/[item] // URL -> /shop/shoes/nike-air-max-97 // `params` -> { tag: 'shoes', item: 'nike-air-max-97' } console.log(params) return '...' } Parameters const params = useParams() useParams take parameters. Returns useParams returns object containing current route's filled dynamic parameters. - property object active dynamic segment. - properties name segment's name, properties value segment filled with. - properties value either string array ofstring 's depending type dynamic segment. - route contains dynamic parameters, useParams returns empty object. - used Pages Router, useParams returnnull initial render updates properties following rules router ready. example: | Route | URL | useParams() | |---|---|---| app/shop/page.js | /shop | {} | app/shop/[slug]/page.js | /shop/1 | { slug: '1' } | app/shop/[tag]/[item]/page.js | /shop/1/2 | { tag: '1', item: '2' } | app/shop/[...slug]/page.js | /shop/1/2 | { slug: ['1', '2'] } | Version History | Version | Changes | |---|---| v13.3.0 | useParams introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-pathname", "title": "Functions: usePathname | Next.js", "text": "usePathname usePathname Client Component hook lets read current URL's pathname. app/example-client-component.tsx 'use client' import { usePathname } 'next/navigation' export default function ExampleClientComponent() { const pathname = usePathname() return <p>Current pathname: {pathname}</p> } usePathname intentionally requires using Client Component. important note Client Components de-optimization. integral part Server Components architecture. example, Client Component usePathname rendered HTML initial page load. navigating new route, component need re-fetched. Instead, component downloaded (in client JavaScript bundle), re-renders based current state. Good know: - Reading current URL Server Component supported. design intentional support layout state preserved across page navigations. - Compatibility mode: usePathname returnnull fallback route rendered apages directory page automatically statically optimized Next.js router ready.- using usePathname rewrites innext.config orMiddleware ,useState anduseEffect must also used order avoid hydration mismatch errors. See rewrites example information.- Next.js automatically update types detects app andpages directory project. Parameters const pathname = usePathname() usePathname take parameters. Returns usePathname returns string current URL's pathname. example: | URL | Returned value | |---|---| / | '/' | /dashboard | '/dashboard' | /dashboard?v=2 | '/dashboard' | /blog/hello-world | '/blog/hello-world' | Examples something response route change app/example-client-component.tsx 'use client' import { usePathname, useSearchParams } 'next/navigation' function ExampleClientComponent() { const pathname = usePathname() const searchParams = useSearchParams() useEffect(() => { // something here... }, [pathname, searchParams]) } | Version | Changes | |---|---| v13.0.0 | usePathname introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-report-web-vitals", "title": "Functions: useReportWebVitals | Next.js", "text": "useReportWebVitals useReportWebVitals hook allows report Core Web Vitals, used combination analytics service. 'use client' import { useReportWebVitals } 'next/web-vitals' export function WebVitals() { useReportWebVitals((metric) => { console.log(metric) }) return null } import { WebVitals } './_components/web-vitals' export default function Layout({ children }) { return ( <html> <body> <WebVitals /> {children} </body> </html> ) } Since useReportWebVitals hook requires the\"use client\" directive, performant approach create separate component root layout imports. confines client boundary exclusively theWebVitals component. useReportWebVitals metric object passed hook's argument consists number properties: id : Unique identifier metric context current page loadname : name performance metric. Possible values include names Web Vitals metrics (TTFB, FCP, LCP, FID, CLS) specific web application.delta : difference current value previous value metric. value typically milliseconds represents change metric's value time.entries : array Performance Entries associated metric. entries provide detailed information performance events related metric.navigationType : Indicates type navigation triggered metric collection. Possible values include\"navigate\" ,\"reload\" ,\"back_forward\" , and\"prerender\" .rating : qualitative rating metric value, providing assessment performance. Possible values are\"good\" ,\"needs-improvement\" , and\"poor\" . rating typically determined comparing metric value predefined thresholds indicate acceptable suboptimal performance.value : actual value duration performance entry, typically milliseconds. value provides quantitative measure performance aspect tracked metric. source value depends specific metric measured come various Performance APIs. Web Vitals Web Vitals set useful metrics aim capture user experience web page. following web vitals included: - Time First Byte (TTFB) - First Contentful Paint (FCP) - Largest Contentful Paint (LCP) - First Input Delay (FID) - Cumulative Layout Shift (CLS) - Interaction Next Paint (INP) handle results metrics using name property. 'use client' import { useReportWebVitals } 'next/web-vitals' export function WebVitals() { useReportWebVitals((metric) => { switch (metric.name) { case 'FCP': { // handle FCP results } case 'LCP': { // handle LCP results } // ... } }) } Usage Vercel Vercel Speed Insights useReportWebVitals , @vercel/speed-insights package instead. useReportWebVitals hook useful local development, using different service collecting Web Vitals. Sending results external systems send results endpoint measure track real user performance site. example: useReportWebVitals((metric) => { const body = JSON.stringify(metric) const url = 'https://example.com/analytics' // Use `navigator.sendBeacon()` available, falling back `fetch()`. (navigator.sendBeacon) { navigator.sendBeacon(url, body) } else { fetch(url, { body, method: 'POST', keepalive: true }) } }) Good know: use Google Analytics, using id value allow construct metric distributions manually (to calculate percentiles, etc.) useReportWebVitals(metric => { // Use `window.gtag` initialized Google Analytics example: // https://github.com/vercel/next.js/blob/canary/examples/with-google-analytics window.gtag('event', metric.name, { value: Math.round(metric.name === 'CLS' ? metric.value * 1000 : metric.value), // values must integers event_label: metric.id, // id unique current page load non_interaction: true, // avoids affecting bounce rate. }); } Read sending results Google Analytics. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-router", "title": "Functions: useRouter | Next.js", "text": "useRouter useRouter hook allows programmatically change routes inside Client Components. Recommendation: Use <Link> component navigation unless specific requirement usinguseRouter . 'use client' import { useRouter } 'next/navigation' export default function Page() { const router = useRouter() return ( <button type=\"button\" onClick={() => router.push('/dashboard')}> Dashboard </button> ) } useRouter() router.push(href: string, { scroll: boolean }) : Perform client-side navigation provided route. Adds new entry browser\u2019s history stack.router.replace(href: string, { scroll: boolean }) : Perform client-side navigation provided route without adding new entry browser\u2019s history stack.router.refresh() : Refresh current route. Making new request server, re-fetching data requests, re-rendering Server Components. client merge updated React Server Component payload without losing unaffected client-side React (e.g.useState ) browser state (e.g. scroll position).router.prefetch(href: string) : Prefetch provided route faster client-side transitions.router.back() : Navigate back previous route browser\u2019s history stack.router.forward() : Navigate forwards next page browser\u2019s history stack. Good know: - must send untrusted unsanitized URLs router.push orrouter.replace , open site cross-site scripting (XSS) vulnerabilities. example,javascript: URLs sent torouter.push orrouter.replace executed context page.- <Link> component automatically prefetch routes become visible viewport.refresh() could re-produce result fetch requests cached. Dynamic APIs likecookies andheaders could also change response. Migrating next/router - useRouter hook imported fromnext/navigation notnext/router using App Router - pathname string removed replaced byusePathname() - query object removed replaced byuseSearchParams() router.events replaced. See below. View full migration guide. Examples Router events listen page changes composing Client Component hooks like usePathname useSearchParams . 'use client' import { useEffect } 'react' import { usePathname, useSearchParams } 'next/navigation' export function NavigationEvents() { const pathname = usePathname() const searchParams = useSearchParams() useEffect(() => { const url = `${pathname}?${searchParams}` console.log(url) // use current URL // ... }, [pathname, searchParams]) return '...' } imported layout. import { Suspense } 'react' import { NavigationEvents } './components/navigation-events' export default function Layout({ children }) { return ( <html lang=\"en\"> <body> {children} <Suspense fallback={null}> <NavigationEvents /> </Suspense> </body> </html> ) } Good know: <NavigationEvents> wrapped aSuspense boundary becauseuseSearchParams() causes client-side rendering closestSuspense boundary static rendering. Learn more. Disabling scroll top default, Next.js scroll top page navigating new route. disable behavior passing scroll: false router.push() router.replace() . 'use client' import { useRouter } 'next/navigation' export default function Page() { const router = useRouter() return ( <button type=\"button\" onClick={() => router.push('/dashboard', { scroll: false })} > Dashboard </button> ) } Version History | Version | Changes | |---|---| v13.0.0 | useRouter next/navigation introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-search-params", "title": "Functions: useSearchParams | Next.js", "text": "useSearchParams useSearchParams Client Component hook lets read current URL's query string. useSearchParams returns read-only version URLSearchParams interface. 'use client' import { useSearchParams } 'next/navigation' export default function SearchBar() { const searchParams = useSearchParams() const search = searchParams.get('search') // URL -> `/dashboard?search=my-project` // `search` -> 'my-project' return <>Search: {search}</> } Parameters const searchParams = useSearchParams() useSearchParams take parameters. Returns useSearchParams returns read-only version URLSearchParams interface, includes utility methods reading URL's query string: - URLSearchParams.get() : Returns first value associated search parameter. example:URL searchParams.get(\"a\") /dashboard?a=1 '1' /dashboard?a= '' /dashboard?b=3 null /dashboard?a=1&a=2 '1' - usegetAll() get values - URLSearchParams.has() : Returns boolean value indicating given parameter exists. example:URL searchParams.has(\"a\") /dashboard?a=1 true /dashboard?b=3 false - Learn read-only methods URLSearchParams , including thegetAll() ,keys() ,values() ,entries() ,forEach() , andtoString() . Good know: useSearchParams Client Component hook supported Server Components prevent stale values partial rendering.- application includes /pages directory,useSearchParams returnReadonlyURLSearchParams | null . Thenull value compatibility migration since search params cannot known pre-rendering page usegetServerSideProps Behavior Static Rendering route statically rendered, calling useSearchParams cause Client Component tree closest Suspense boundary client-side rendered. allows part route statically rendered dynamic part uses useSearchParams client-side rendered. recommend wrapping Client Component uses useSearchParams <Suspense/> boundary. allow Client Components statically rendered sent part initial HTML. Example. example: 'use client' import { useSearchParams } 'next/navigation' export default function SearchBar() { const searchParams = useSearchParams() const search = searchParams.get('search') // logged server using static rendering console.log(search) return <>Search: {search}</> } import { Suspense } 'react' import SearchBar './search-bar' // component passed fallback Suspense boundary // rendered place search bar initial HTML. // value available React hydration fallback // replaced `<SearchBar>` component. function SearchBarFallback() { return <>placeholder</> } export default function Page() { return ( <> <nav> <Suspense fallback={<SearchBarFallback />}> <SearchBar /> </Suspense> </nav> <h1>Dashboard</h1> </> ) } Dynamic Rendering route dynamically rendered, useSearchParams available server initial server render Client Component. example: 'use client' import { useSearchParams } 'next/navigation' export default function SearchBar() { const searchParams = useSearchParams() const search = searchParams.get('search') // logged server initial render // client subsequent navigations. console.log(search) return <>Search: {search}</> } import SearchBar './search-bar' export const dynamic = 'force-dynamic' export default function Page() { return ( <> <nav> <SearchBar /> </nav> <h1>Dashboard</h1> </> ) } Good know: Setting dynamic route segment config option toforce-dynamic used force dynamic rendering. Server Components Pages access search params Pages (Server Components), use searchParams prop. Layouts Unlike Pages, Layouts (Server Components) receive searchParams prop. shared layout re-rendered navigation could lead stale searchParams navigations. View detailed explanation. Instead, use Page searchParams prop useSearchParams hook Client Component, re-rendered client latest searchParams . Examples Updating searchParams use useRouter Link set new searchParams . navigation performed, current page.js receive updated searchParams prop. 'use client' export default function ExampleClientComponent() { const router = useRouter() const pathname = usePathname() const searchParams = useSearchParams() // Get new searchParams string merging current // searchParams provided key/value pair const createQueryString = useCallback( (name: string, value: string) => { const params = new URLSearchParams(searchParams.toString()) params.set(name, value) return params.toString() }, [searchParams] ) return ( <> <p>Sort By</p> {/* using useRouter */} <button onClick={() => { // <pathname>?sort=asc router.push(pathname + '?' + createQueryString('sort', 'asc')) }} > ASC </button> {/* using <Link> */} <Link href={ // <pathname>?sort=desc pathname + '?' + createQueryString('sort', 'desc') } > DESC </Link> </> ) } Version History | Version | Changes | |---|---| v13.0.0 | useSearchParams introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segment", "title": "Functions: useSelectedLayoutSegment | Next.js", "text": "useSelectedLayoutSegment useSelectedLayoutSegment Client Component hook lets read active route segment one level Layout called from. useful navigation UI, tabs inside parent layout change style depending active child segment. 'use client' import { useSelectedLayoutSegment } 'next/navigation' export default function ExampleClientComponent() { const segment = useSelectedLayoutSegment() return <p>Active segment: {segment}</p> } Good know: - Since useSelectedLayoutSegment Client Component hook, Layouts Server Components default,useSelectedLayoutSegment usually called via Client Component imported Layout.useSelectedLayoutSegment returns segment one level down. return active segments, seeuseSelectedLayoutSegments Parameters const segment = useSelectedLayoutSegment(parallelRoutesKey?: string) useSelectedLayoutSegment optionally accepts parallelRoutesKey , allows read active route segment within slot. Returns useSelectedLayoutSegment returns string active segment null one exist. example, given Layouts URLs below, returned segment would be: | Layout | Visited URL | Returned Segment | |---|---|---| app/layout.js | / | null | app/layout.js | /dashboard | 'dashboard' | app/dashboard/layout.js | /dashboard | null | app/dashboard/layout.js | /dashboard/settings | 'settings' | app/dashboard/layout.js | /dashboard/analytics | 'analytics' | app/dashboard/layout.js | /dashboard/analytics/monthly | 'analytics' | Examples Creating active link component use useSelectedLayoutSegment create active link component changes style depending active segment. example, featured posts list sidebar blog: 'use client' import Link 'next/link' import { useSelectedLayoutSegment } 'next/navigation' // *client* component imported blog layout export default function BlogNavLink({ slug, children, }: { slug: string children: React.ReactNode }) { // Navigating `/blog/hello-world` return 'hello-world' // selected layout segment const segment = useSelectedLayoutSegment() const isActive = slug === segment return ( <Link href={`/blog/${slug}`} // Change style depending whether link active style={{ fontWeight: isActive ? 'bold' : 'normal' }} > {children} </Link> ) } // Import Client Component parent Layout (Server Component) import { BlogNavLink } './blog-nav-link' import getFeaturedPosts './get-featured-posts' export default async function Layout({ children, }: { children: React.ReactNode }) { const featuredPosts = await getFeaturedPosts() return ( <div> {featuredPosts.map((post) => ( <div key={post.id}> <BlogNavLink slug={post.slug}>{post.title}</BlogNavLink> </div> ))} <div>{children}</div> </div> ) } Version History | Version | Changes | |---|---| v13.0.0 | useSelectedLayoutSegment introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segments", "title": "Functions: useSelectedLayoutSegments | Next.js", "text": "useSelectedLayoutSegments useSelectedLayoutSegments Client Component hook lets read active route segments Layout called from. useful creating UI parent Layouts need knowledge active child segments breadcrumbs. app/example-client-component.tsx 'use client' import { useSelectedLayoutSegments } 'next/navigation' export default function ExampleClientComponent() { const segments = useSelectedLayoutSegments() return ( <ul> {segments.map((segment, index) => ( <li key={index}>{segment}</li> ))} </ul> ) } Good know: - Since useSelectedLayoutSegments Client Component hook, Layouts Server Components default,useSelectedLayoutSegments usually called via Client Component imported Layout.- returned segments include Route Groups, might want included UI. use filter() array method remove items start bracket. Parameters const segments = useSelectedLayoutSegments(parallelRoutesKey?: string) useSelectedLayoutSegments optionally accepts parallelRoutesKey , allows read active route segment within slot. Returns useSelectedLayoutSegments returns array strings containing active segments one level layout hook called from. empty array none exist. example, given Layouts URLs below, returned segments would be: | Layout | Visited URL | Returned Segments | |---|---|---| app/layout.js | / | [] | app/layout.js | /dashboard | ['dashboard'] | app/layout.js | /dashboard/settings | ['dashboard', 'settings'] | app/dashboard/layout.js | /dashboard | [] | app/dashboard/layout.js | /dashboard/settings | ['settings'] | Version History | Version | Changes | |---|---| v13.0.0 | useSelectedLayoutSegments introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/userAgent", "title": "Functions: userAgent | Next.js", "text": "userAgent userAgent helper extends Web Request API additional properties methods interact user agent object request. middleware.ts import { NextRequest, NextResponse, userAgent } 'next/server' export function middleware(request: NextRequest) { const url = request.nextUrl const { device } = userAgent(request) const viewport = device.type === 'mobile' ? 'mobile' : 'desktop' url.searchParams.set('viewport', viewport) return NextResponse.rewrite(url) } isBot boolean indicating whether request comes known bot. browser object containing information browser used request. name : string representing browser's name, orundefined identifiable.version : string representing browser's version, orundefined . device object containing information device used request. model : string representing model device, orundefined .type : string representing type device, asconsole ,mobile ,tablet ,smarttv ,wearable ,embedded , orundefined .vendor : string representing vendor device, orundefined . engine object containing information browser's engine. name : string representing engine's name. Possible values include:Amaya ,Blink ,EdgeHTML ,Flow ,Gecko ,Goanna ,iCab ,KHTML ,Links ,Lynx ,NetFront ,NetSurf ,Presto ,Tasman ,Trident ,w3m ,WebKit orundefined .version : string representing engine's version, orundefined . os object containing information operating system. name : string representing name OS, orundefined .version : string representing version OS, orundefined . cpu object containing information CPU architecture. architecture : string representing architecture CPU. Possible values include:68k ,amd64 ,arm ,arm64 ,armhf ,avr ,ia32 ,ia64 ,irix ,irix64 ,mips ,mips64 ,pa-risc ,ppc ,sparc ,sparc64 orundefined helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/turbopack", "title": "API Reference: Turbopack | Next.js", "text": "Turbopack Turbopack incremental bundler optimized JavaScript TypeScript, written Rust, built Next.js. Turbopack used Next.js pages app directories faster local development. enable Turbopack, use --turbopack flag running Next.js development server. { \"scripts\": { \"dev\": \"next dev --turbopack\", \"build\": \"next build\", \"start\": \"next start\", \"lint\": \"next lint\" } } Reference Supported features Turbopack Next.js requires zero-configuration users extended advanced use cases. learn currently supported features Turbopack, view API Reference. Unsupported features Turbopack currently supports next dev support next build . currently working support builds move closer towards stability. features currently supported: - Turbopack leverages Lightning CSS support low usage CSS Modules features :local and:global standalone pseudo classes. function variant supported, example::global(a) .- @value rule superseded CSS variables. :import and:export ICSS rules. - Invalid CSS comment syntax // - CSS comments written /* comment */ per specification. - Preprocessors Sass support alternative syntax comments. - CSS comments written webpack() configuration innext.config.js - Turbopack replaces Webpack, means webpack configuration supported. - configure Turbopack, see documentation. - subset Webpack loaders supported Turbopack. - Babel ( .babelrc )- Turbopack leverages SWC compiler transpilation optimizations. means Babel included default. - .babelrc file, might longer need Next.js includes common Babel plugins SWC transforms enabled. read compiler documentation. - still need use Babel verifying particular use case covered, leverage Turbopack's support custom webpack loaders include babel-loader . - Creating root layout automatically App Router. - behavior currently supported since changes input files, instead, error shown manually add root layout desired location. @next/font (legacy font support).@next/font deprecated favor ofnext/font .next/font fully supported Turbopack. - Relay transforms - planning implement future. - Blocking .css imports inpages/_document.tsx - Currently webpack Next.js blocks importing .css files inpages/_document.tsx - planning implement warning future. - Currently webpack Next.js blocks importing experimental.typedRoutes - planning implement future. experimental.nextScriptWorkers - planning implement future. experimental.sri.algorithm - planning implement future. experimental.fallbackNodePolyfills - planning implement future. experimental.esmExternals - currently planning support legacy esmExternals configuration Next.js Turbopack. - AMP. - currently planning support AMP Next.js Turbopack. - Yarn PnP - currently planning support Yarn PnP Next.js Turbopack. experimental.urlImports - currently planning support experimental.urlImports Next.js Turbopack. - currently planning support :import and:export ICSS rules- currently planning support :import and:export ICSS rules Next.js Turbopack Lightning CSS CSS parser Turbopack uses support rules. - currently planning support unstable_allowDynamic configuration edge runtime Examples Generating Trace Files Trace files allow Next.js team investigate improve performance metrics memory usage. generate trace file, append NEXT_TURBOPACK_TRACING=1 next dev --turbopack command, generate .next/trace-turbopack file. reporting issues related Turbopack performance memory usage, please include trace file GitHub issue. helpful?"},
{"source": "https://nextjs.org/docs/app/examples", "title": "App Router: Examples | Next.js", "text": "Examples Data Fetching - Using fetch API - Using ORM database client - Reading search params server - Reading search params client Revalidating Data Forms - Showing pending state submitting form - Server-side form validation - Handling expected errors - Handling unexpected exceptions - Showing optimistic UI updates - Programmatic form submission Server Actions Metadata - Creating RSS feed - Creating Open Graph image - Creating sitemap - Creating robots.txt file - Creating custom 404 page - Creating custom 500 page Auth - Creating sign-up form - Stateless, cookie-based session management - Stateful, database-backed session management - Managing authorization Testing Deployment helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started", "title": "App Router: Getting Started | Next.js", "text": "Getting Started Installation Create new Next.js application `create-next-app` CLI, set TypeScript, ESLint, Module Path Aliases. Project Structure overview folder file conventions Next.js, organize project. Layouts Pages Create first pages layouts, link them. Images Fonts Learn optimize images fonts. CSS Learn different ways add CSS application, including CSS Modules, Global CSS, Tailwind CSS, more. Fetching Data Start fetching data streaming content application. Updating Data Learn update data Next.js application. Error Handling Learn display expected errors handle uncaught exceptions. helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/css", "title": "Getting Started: CSS | Next.js", "text": "use CSS application Next.js provides several ways use CSS application, including: page guide use approaches. CSS Modules CSS Modules locally scope CSS generating unique class names. allows use class different files without worrying collisions. start using CSS Modules, create new file extension .module.css import component inside app directory: .blog { padding: 24px; } import styles './styles.module.css' export default function Page({ children }: { children: React.ReactNode }) { return <main className={styles.blog}>{children}</main> } Global CSS use global CSS apply styles across application. use global styles, create new CSS file, example app/global.css : body { padding: 20px 20px 60px; max-width: 680px; margin: 0 auto; } Import file root layout (app/layout.js ) apply styles every route application: // styles apply every route application import './global.css' export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body>{children}</body> </html> ) } Good know: Global styles imported layout, page, component inside app directory. However, since Next.js uses React's built-in support stylesheets integrate Suspense. built-in support currently remove stylesheets navigate routes. Therefore, recommend using global styles truly global CSS, CSS Modules scoped CSS. Tailwind CSS Tailwind CSS utility-first CSS framework integrates seamlessly Next.js. Installing Tailwind start using Tailwind, install necessary Tailwind CSS packages: npm install -D tailwindcss @tailwindcss/postcss postcss Configuring Tailwind Create postcss.config.mjs file root project add @tailwindcss/postcss plugin PostCSS configuration: /** @type {import('tailwindcss').Config} */ export default { plugins: { '@tailwindcss/postcss': {}, }, } Using Tailwind Add Tailwind directives Global Stylesheet: @import 'tailwindcss'; Then, import styles root layout: import type { Metadata } 'next' // styles apply every route application import './globals.css' export const metadata: Metadata = { title: 'Create Next App', description: 'Generated create next app', } export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body>{children}</body> </html> ) } Lastly, start writing Tailwind's utility classes application. export default function Page() { return <h1 className=\"text-3xl font-bold underline\">Hello, Next.js!</h1> } Sass Next.js integrates Sass using .scss .sass extensions syntax. also use component-level Sass via CSS Modules .module.scss .module.sass extension. Installing Sass start using Sass, install sass package: npm install --save-dev sass Customizing Sass options want configure Sass options, use sassOptions option next.config.js . import type { NextConfig } 'next' const nextConfig: NextConfig = { sassOptions: { additionalData: `$var: red;`, }, } export default nextConfig CSS-in-JS Warning: CSS-in-JS libraries require runtime JavaScript currently supported React Server Components. Using CSS-in-JS newer React features like Server Components Streaming requires library authors support latest version React. following libraries supported Client Components app directory (alphabetical): ant-design chakra-ui @fluentui/react-components kuma-ui @mui/material @mui/joy pandacss styled-jsx styled-components stylex tamagui tss-react vanilla-extract following currently working support: want style Server Components, recommend using CSS Modules solutions output CSS files, like Tailwind CSS. Configuring CSS-in-JS configure CSS-in-JS, need to: - Create style registry collect CSS rules render. - Use useServerInsertedHTML hook inject rules content might use them. - Create Client Component wraps app style registry initial server-side rendering. styled-jsx configure styled-jsx application, create new registry: 'use client' import React, { useState } 'react' import { useServerInsertedHTML } 'next/navigation' import { StyleRegistry, createStyleRegistry } 'styled-jsx' export default function StyledJsxRegistry({ children, }: { children: React.ReactNode }) { // create stylesheet lazy initial state // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state const [jsxStyleRegistry] = useState(() => createStyleRegistry()) useServerInsertedHTML(() => { const styles = jsxStyleRegistry.styles() jsxStyleRegistry.flush() return <>{styles}</> }) return <StyleRegistry registry={jsxStyleRegistry}>{children}</StyleRegistry> } Then, wrap root layout registry: import StyledJsxRegistry './registry' export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html> <body> <StyledJsxRegistry>{children}</StyledJsxRegistry> </body> </html> ) } styled-components use styled-components , enable next.config.js : import type { NextConfig } 'next' const nextConfig: NextConfig = { compiler: { styledComponents: true, }, } export default nextConfig Then, use styled-components API create global registry component collect CSS style rules generated render, function return rules. use useServerInsertedHTML hook inject styles collected registry <head> HTML tag root layout. 'use client' import React, { useState } 'react' import { useServerInsertedHTML } 'next/navigation' import { ServerStyleSheet, StyleSheetManager } 'styled-components' export default function StyledComponentsRegistry({ children, }: { children: React.ReactNode }) { // create stylesheet lazy initial state // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state const [styledComponentsStyleSheet] = useState(() => new ServerStyleSheet()) useServerInsertedHTML(() => { const styles = styledComponentsStyleSheet.getStyleElement() styledComponentsStyleSheet.instance.clearTag() return <>{styles}</> }) (typeof window !== 'undefined') return <>{children}</> return ( <StyleSheetManager sheet={styledComponentsStyleSheet.instance}> {children} </StyleSheetManager> ) } Wrap children root layout style registry component: import StyledComponentsRegistry './lib/registry' export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html> <body> <StyledComponentsRegistry>{children}</StyledComponentsRegistry> </body> </html> ) } External stylesheets Stylesheets published external packages imported anywhere app directory, including colocated components: import 'bootstrap/dist/css/bootstrap.css' export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body className=\"container\">{children}</body> </html> ) } External stylesheets must directly imported npm package downloaded colocated codebase. cannot use <link rel=\"stylesheet\" /> . API Reference helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/error-handling", "title": "Getting Started: Error Handling | Next.js", "text": "handle errors Errors divided two categories: expected errors uncaught exceptions. page walk handle errors Next.js application. Handling expected errors Expected errors occur normal operation application, server-side form validation failed requests. errors handled explicitly returned client. Server Actions use useActionState hook manage state Server Functions handle expected errors. Avoid using try /catch blocks expected errors. Instead, model expected errors return values, thrown exceptions. 'use server' export async function createPost(prevState: any, formData: FormData) { const title = formData.get('title') const content = formData.get('content') const res = await fetch('https://api.vercel.app/posts', { method: 'POST', body: { title, content }, }) const json = await res.json() (!res.ok) { return { message: 'Failed create post' } } } Then, pass action useActionState hook use returned state display error message. 'use client' import { useActionState } 'react' import { createPost } '@/app/actions' const initialState = { message: '', } export function Form() { const [state, formAction, pending] = useActionState(createPost, initialState) return ( <form action={formAction}> <label htmlFor=\"title\">Title</label> <input type=\"text\" id=\"title\" name=\"title\" required /> <label htmlFor=\"content\">Content</label> <textarea id=\"content\" name=\"content\" required /> {state?.message && <p aria-live=\"polite\">{state.message}</p>} <button disabled={pending}>Create Post</button> </form> ) } Server Components fetching data inside Server Component, use response conditionally render error message redirect . export default async function Page() { const res = await fetch(`https://...`) const data = await res.json() (!res.ok) { return 'There error.' } return '...' } found call notFound function within route segment use not-found.js file show 404 UI. import { getPostBySlug } '@/lib/posts' export default async function Page({ params }: { params: { slug: string } }) { const post = getPostBySlug((await params).slug) (!post) { notFound() } return <div>{post.title}</div> } export default function NotFound() { return <div>404 - Page Found</div> } Handling uncaught exceptions Uncaught exceptions unexpected errors indicate bugs issues occur normal flow application. handled throwing errors, caught error boundaries. Nested error boundaries Next.js uses error boundaries handle uncaught exceptions. Error boundaries catch errors child components display fallback UI instead component tree crashed. Create error boundary adding error.js file inside route segment exporting React component: 'use client' // Error boundaries must Client Components import { useEffect } 'react' export default function Error({ error, reset, }: { error: Error & { digest?: string } reset: () => void }) { useEffect(() => { // Log error error reporting service console.error(error) }, [error]) return ( <div> <h2>Something went wrong!</h2> <button onClick={ // Attempt recover trying re-render segment () => reset() } > Try </button> </div> ) } Errors bubble nearest parent error boundary. allows granular error handling placing error.tsx files different levels route hierarchy. Global errors less common, handle errors root layout using global-error.js file, located root app directory, even leveraging internationalization. Global error UI must define <html> <body> tags, since replacing root layout template active. 'use client' // Error boundaries must Client Components export default function GlobalError({ error, reset, }: { error: Error & { digest?: string } reset: () => void }) { return ( // global-error must include html body tags <html> <body> <h2>Something went wrong!</h2> <button onClick={() => reset()}>Try again</button> </body> </html> ) } API Reference helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/fetching-data", "title": "Getting Started: Fetching Data | Next.js", "text": "fetch data stream page walk fetch data Server Components Client Components. well stream content depends data. Fetching data Server Components fetch data Server Components using: - fetch API - ORM database fetch API fetch data fetch API, turn component asynchronous function, await fetch call. example: export default async function Page() { const data = await fetch('https://api.vercel.app/blog') const posts = await data.json() return ( <ul> {posts.map((post) => ( <li key={post.id}>{post.title}</li> ))} </ul> ) } ORM database fetch data ORM database turning component asynchronous function, awaiting call: import { db, posts } '@/lib/db' export default async function Page() { const allPosts = await db.select().from(posts) return ( <ul> {allPosts.map((post) => ( <li key={post.id}>{post.title}</li> ))} </ul> ) } Client Components two ways fetch data Client Components, using: - React's use hook - community library like SWR React Query use hook use React's use hook stream data server client. Start fetching data Server component, pass promise Client Component prop: import Posts '@/app/ui/posts import { Suspense } 'react' export default function Page() { // await data fetching function const posts = getPosts() return ( <Suspense fallback={<div>Loading...</div>}> <Posts posts={posts} /> </Suspense> ) } Then, Client Component, use use hook read promise: 'use client' import { use } 'react' export default function Posts({ posts, }: { posts: Promise<{ id: string; title: string }[]> }) { const allPosts = use(posts) return ( <ul> {allPosts.map((post) => ( <li key={post.id}>{post.title}</li> ))} </ul> ) } example above, need wrap <Posts /> component <Suspense> boundary. means fallback shown promise resolved. Learn streaming. Community libraries use community library like SWR React Query fetch data Client Components. libraries semantics caching, streaming, features. example, SWR: 'use client' import useSWR 'swr' const fetcher = (url) => fetch(url).then((r) => r.json()) export default function BlogPage() { const { data, error, isLoading } = useSWR( 'https://api.vercel.app/blog', fetcher ) (isLoading) return <div>Loading...</div> (error) return <div>Error: {error.message}</div> return ( <ul> {data.map((post: { id: string; title: string }) => ( <li key={post.id}>{post.title}</li> ))} </ul> ) } Streaming Warning: content assumes dynamicIO config option enabled application. flag introduced Next.js 15 canary. using async/await Server Components, Next.js opt dynamic rendering. means data fetched rendered server every user request. slow data requests, whole route blocked rendering. improve initial load time user experience, use streaming break page's HTML smaller chunks progressively send chunks server client. two ways implement streaming application: - loading.js file - React's <Suspense> component loading.js create loading.js file folder page stream entire page data fetched. example, stream app/blog/page.js , add file inside app/blog folder. export default function Loading() { // Define Loading UI return <div>Loading...</div> } navigation, user immediately see layout loading state page rendered. new content automatically swapped rendering complete. Behind-the-scenes, loading.js nested inside layout.js , automatically wrap page.js file children <Suspense> boundary. approach works well route segments (layouts pages), granular streaming, use <Suspense> . <Suspense> <Suspense> allows granular parts page stream. example, immediately show page content falls outside <Suspense> boundary, stream list blog posts inside boundary. import { Suspense } 'react' import BlogList '@/components/BlogList' import BlogListSkeleton '@/components/BlogListSkeleton' export default function BlogPage() { return ( <div> {/* content sent client immediately */} <header> <h1>Welcome Blog</h1> <p>Read latest posts below.</p> </header> <main> {/* content wrapped <Suspense> boundary streamed */} <Suspense fallback={<BlogListSkeleton />}> <BlogList /> </Suspense> </main> </div> ) } Creating meaningful loading states instant loading state fallback UI shown immediately user navigation. best user experience, recommend designing loading states meaningful help users understand app responding. example, use skeletons spinners, small meaningful part future screens cover photo, title, etc. development, preview inspect loading state components using React Devtools. API Reference helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/images-and-fonts", "title": "Getting Started: Images and Fonts | Next.js", "text": "optimize images fonts Next.js comes automatic image font optimization better performance user experience. page guide start using them. Handling static assets store static files, like images fonts, folder called public root directory. Files inside public referenced code starting base URL (/ ). Optimizing images Next.js <Image> component extends HTML <img> element provide: - Size optimization: Automatically serving correctly sized images device, using modern image formats like WebP. - Visual stability: Preventing layout shift automatically images loading. - Faster page loads: loading images enter viewport using native browser lazy loading, optional blur-up placeholders. - Asset flexibility: Resizing images on-demand, even images stored remote servers. start using <Image> , import next/image render within component. import Image 'next/image' export default function Page() { return <Image src=\"\" alt=\"\" /> } src property local remote image. Local images use local image, import .jpg , .png , .webp image files public folder. import Image 'next/image' import profilePic './me.png' export default function Page() { return ( <Image src={profilePic} alt=\"Picture author\" // width={500} automatically provided // height={500} automatically provided // blurDataURL=\"data:...\" automatically provided // placeholder=\"blur\" // Optional blur-up loading /> ) } Next.js automatically determine intrinsic width height image based imported file. values used determine image ratio prevent Cumulative Layout Shift image loading. Remote images use remote image, provide URL string src property. import Image 'next/image' export default function Page() { return ( <Image src=\"https://s3.amazonaws.com/my-bucket/profile.png\" alt=\"Picture author\" width={500} height={500} /> ) } Since Next.js access remote files build process, need provide width , height optional blurDataURL props manually. width height attributes used infer correct aspect ratio image avoid layout shift image loading in. Then, safely allow images remote servers, need define list supported URL patterns next.config.js . specific possible prevent malicious usage. example, following configuration allow images specific AWS S3 bucket: import { NextConfig } 'next' const config: NextConfig = { images: { remotePatterns: [ { protocol: 'https', hostname: 's3.amazonaws.com', port: '', pathname: '/my-bucket/**', search: '', }, ], }, } export default config Optimizing fonts next/font module automatically optimizes fonts removes external network requests improved privacy performance. includes built-in automatic self-hosting font file. means optimally load web fonts layout shift. start using next/font , import next/font/local next/font/google , call function appropriate options, set className element want apply font to. example: import { Geist } 'next/font/google' const geist = Geist({ subsets: ['latin'], }) export default function Layout({ children }: { children: React.ReactNode }) { return ( <html lang=\"en\" className={geist.className}> <body>{children}</body> </html> ) } Google fonts automatically self-host Google Font. Fonts included deployment served domain deployment, meaning requests sent Google browser user visits site. start using Google Font, import chosen font next/font/google : import { Geist } 'next/font/google' const geist = Geist({ subsets: ['latin'], }) export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\" className={geist.className}> <body>{children}</body> </html> ) } recommend using variable fonts best performance flexibility. can't use variable font, need specify weight: import { Roboto } 'next/font/google' const roboto = Roboto({ weight: '400', subsets: ['latin'], }) export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\" className={roboto.className}> <body>{children}</body> </html> ) } Local fonts use local font, import font next/font/local specify src local font file public folder. import localFont 'next/font/local' const myFont = localFont({ src: './my-font.woff2', }) export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\" className={myFont.className}> <body>{children}</body> </html> ) } want use multiple files single font family, src array: const roboto = localFont({ src: [ { path: './Roboto-Regular.woff2', weight: '400', style: 'normal', }, { path: './Roboto-Italic.woff2', weight: '400', style: 'italic', }, { path: './Roboto-Bold.woff2', weight: '700', style: 'normal', }, { path: './Roboto-BoldItalic.woff2', weight: '700', style: 'italic', }, ], }) API Reference helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/installation", "title": "Getting Started: Installation | Next.js", "text": "set new Next.js project System requirements - Node.js 18.18 later. - macOS, Windows (including WSL), Linux supported. Automatic installation recommend starting new Next.js app using create-next-app , sets everything automatically you. create project, run: npx create-next-app@latest installation, see following prompts: project named? my-app Would like use TypeScript? / Yes Would like use ESLint? / Yes Would like use Tailwind CSS? / Yes Would like code inside `src/` directory? / Yes Would like use App Router? (recommended) / Yes Would like use Turbopack `next dev`? / Yes Would like customize import alias (`@/*` default)? / Yes import alias would like configured? @/* prompts, create-next-app create folder project name install required dependencies. Manual installation manually create new Next.js app, install required packages: npm install next@latest react@latest react-dom@latest Open package.json file add following scripts : { \"scripts\": { \"dev\": \"next dev\", \"build\": \"next build\", \"start\": \"next start\", \"lint\": \"next lint\" } } scripts refer different stages developing application: dev : runsnext dev start Next.js development mode.build : runsnext build build application production usage.start : runsnext start start Next.js production server.lint : runsnext lint set Next.js' built-in ESLint configuration. Create app directory Next.js uses file-system routing, means routes application determined structure files. Create app folder, add layout.tsx page.tsx file. rendered user visits root application (/ ). Create root layout inside app/layout.tsx required <html> <body> tags: export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body>{children}</body> </html> ) } Finally, create home page app/page.tsx initial content: export default function Page() { return <h1>Hello, Next.js!</h1> } Good know: - forget create layout.tsx , Next.js automatically create file running development server withnext dev .- optionally use src directory root project separate application's code configuration files. Create public folder (optional) optionally create public folder root project store static assets images, fonts, etc. Files inside public referenced code starting base URL (/ ). Run development server - Run npm run dev start development server. - Visit http://localhost:3000 view application. - Edit app/page.tsx file save see updated result browser. Set TypeScript Minimum TypeScript version: v4.5.2 Next.js comes built-in TypeScript support. add TypeScript project, rename file .ts / .tsx . Run next dev , Next.js automatically install necessary dependencies add tsconfig.json file recommended config options. IDE Plugin Next.js includes custom TypeScript plugin type checker, VSCode code editors use advanced type-checking auto-completion. enable plugin VS Code by: - Opening command palette ( Ctrl/\u2318 +Shift +P ) - Searching \"TypeScript: Select TypeScript Version\" - Selecting \"Use Workspace Version\" Now, editing files, custom plugin enabled. running next build , custom type checker used. See TypeScript configuration page information use TypeScript project. Set ESLint Next.js comes built-in ESLint, automatically installing necessary packages configuring proper settings create new project create-next-app . add ESLint existing project, add next lint script package.json : { \"scripts\": { \"lint\": \"next lint\" } } Then, run npm run lint guided installation configuration process. npm run lint see prompt like this: ? would like configure ESLint? \u276f Strict (recommended) Base Cancel - Strict: Includes Next.js' base ESLint configuration along stricter Core Web Vitals rule-set. recommended configuration developers setting ESLint first time. - Base: Includes Next.js' base ESLint configuration. - Cancel: include ESLint configuration. select option plan setting custom ESLint configuration. either two configuration options selected, Next.js automatically install eslint eslint-config-next dependencies application create .eslintrc.json file root project includes selected configuration. run next lint every time want run ESLint catch errors. ESLint set up, also automatically run every build (next build ). Errors fail build, warnings not. See ESLint Plugin page information configure ESLint project. Set Absolute Imports Module Path Aliases Next.js in-built support \"paths\" \"baseUrl\" options tsconfig.json jsconfig.json files. options allow alias project directories absolute paths, making easier import modules. example: // import { Button } '../../../components/button' // import { Button } '@/components/button' configure absolute imports, add baseUrl configuration option tsconfig.json jsconfig.json file. example: { \"compilerOptions\": { \"baseUrl\": \"src/\" } } addition configuring baseUrl path, use \"paths\" option \"alias\" module paths. example, following configuration maps @/components/* components/* : { \"compilerOptions\": { \"baseUrl\": \"src/\", \"paths\": { \"@/styles/*\": [\"styles/*\"], \"@/components/*\": [\"components/*\"] } } } \"paths\" relative baseUrl location. example: import Button '@/components/button' import '@/styles/styles.css' export default function HomePage() { return ( <div> <h1>Hello World</h1> <Button /> </div> ) } helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/layouts-and-pages", "title": "Getting Started: Layouts and Pages | Next.js", "text": "create layouts pages Next.js uses file-system based routing, meaning use folders files define routes. page guide create layouts pages, link them. Creating page page UI rendered specific route. create page, add page file inside app directory default export React component. example, create index page (/ ): export default function Page() { return <h1>Hello Next.js!</h1> } Creating layout layout UI shared multiple pages. navigation, layouts preserve state, remain interactive, rerender. define layout default exporting React component layout file. component accept children prop page another layout. example, create layout accepts index page child, add layout file inside app directory: export default function DashboardLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body> {/* Layout UI */} {/* Place children want render page nested layout */} <main>{children}</main> </body> </html> ) } layout called root layout defined root app directory. root layout required must contain html body tags. Creating nested route nested route route composed multiple URL segments. example, /blog/[slug] route composed three segments: / (Root Segment)blog (Segment)[slug] (Leaf Segment) Next.js: - Folders used define route segments map URL segments. - Files (like page andlayout ) used create UI shown segment. create nested routes, nest folders inside other. example, add route /blog , create folder called blog app directory. Then, make /blog publicly accessible, add page file: import { getPosts } '@/lib/posts' import { Post } '@/ui/post' export default async function Page() { const posts = await getPosts() return ( <ul> {posts.map((post) => ( <Post key={post.id} post={post} /> ))} </ul> ) } continue nesting folders create nested routes. example, create route specific blog post, create new [slug] folder inside blog add page file: function generateStaticParams() {} export default function Page() { return <h1>Hello, Blog Post Page!</h1> } Good know: Wrapping folder name square brackets (e.g. [slug] ) creates special dynamic route segment used generate multiple pages data. useful blog posts, product pages, etc. Nesting layouts default, layouts folder hierarchy also nested, means wrap child layouts via children prop. nest layouts adding layout inside specific route segments (folders). example, create layout /blog route, add new layout file inside blog folder. export default function BlogLayout({ children, }: { children: React.ReactNode }) { return <section>{children}</section> } combine two layouts above, root layout (app/layout.js ) would wrap blog layout (app/blog/layout.js ), would wrap blog (app/blog/page.js ) blog post page (app/blog/[slug]/page.js ). Linking pages use <Link> component navigate routes. <Link> built-in Next.js component extends HTML <a> tag provide prefetching client-side navigation. example, generate list blog posts, import <Link> next/link pass href prop component: import Link 'next/link' export default async function Post({ post }) { const posts = await getPosts() return ( <ul> {posts.map((post) => ( <li key={post.slug}> <Link href={`/blog/${post.slug}`}>{post.title}</Link> </li> ))} </ul> ) } <Link> primary recommended way navigate routes Next.js application. However, also use useRouter hook advanced navigation. API Reference helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/project-structure", "title": "Getting Started: Project Structure | Next.js", "text": "Project structure organization page provides overview folder file conventions Next.js, well tips organizing project. Folder file conventions Top-level folders Top-level folders used organize application's code static assets. Top-level files Top-level files used configure application, manage dependencies, run middleware, integrate monitoring tools, define environment variables. | Next.js | | next.config.js | Configuration file Next.js | package.json | Project dependencies scripts | instrumentation.ts | OpenTelemetry Instrumentation file | middleware.ts | Next.js request middleware | .env | Environment variables | .env.local | Local environment variables | .env.production | Production environment variables | .env.development | Development environment variables | .eslintrc.json | Configuration file ESLint | .gitignore | Git files folders ignore | next-env.d.ts | TypeScript declaration file Next.js | tsconfig.json | Configuration file TypeScript | jsconfig.json | Configuration file JavaScript | Routing Files layout | .js .jsx .tsx | Layout | page | .js .jsx .tsx | Page | loading | .js .jsx .tsx | Loading UI | not-found | .js .jsx .tsx | found UI | error | .js .jsx .tsx | Error UI | global-error | .js .jsx .tsx | Global error UI | route | .js .ts | API endpoint | template | .js .jsx .tsx | Re-rendered layout | default | .js .jsx .tsx | Parallel route fallback page | Nested routes folder | Route segment | folder/folder | Nested route segment | Dynamic routes [folder] | Dynamic route segment | [...folder] | Catch-all route segment | [[...folder]] | Optional catch-all route segment | Route Groups private folders (folder) | Group routes without affecting routing | _folder | Opt folder child segments routing | Parallel Intercepted Routes @folder | Named slot | (.)folder | Intercept level | (..)folder | Intercept one level | (..)(..)folder | Intercept two levels | (...)folder | Intercept root | Metadata file conventions App icons favicon | .ico | Favicon file | icon | .ico .jpg .jpeg .png .svg | App Icon file | icon | .js .ts .tsx | Generated App Icon | apple-icon | .jpg .jpeg , .png | Apple App Icon file | apple-icon | .js .ts .tsx | Generated Apple App Icon | Open Graph Twitter images opengraph-image | .jpg .jpeg .png .gif | Open Graph image file | opengraph-image | .js .ts .tsx | Generated Open Graph image | twitter-image | .jpg .jpeg .png .gif | Twitter image file | twitter-image | .js .ts .tsx | Generated Twitter image | SEO sitemap | .xml | Sitemap file | sitemap | .js .ts | Generated Sitemap | robots | .txt | Robots file | robots | .js .ts | Generated Robots file | Component hierarchy React components defined special files route segment rendered specific hierarchy: layout.js template.js error.js (React error boundary)loading.js (React suspense boundary)not-found.js (React error boundary)page.js nestedlayout.js nested route, components segment nested inside components parent segment. Organizing project Apart folder file conventions, Next.js unopinionated organize colocate project files. provide several features help organize project. Colocation app directory, nested folders define route structure. folder represents route segment mapped corresponding segment URL path. However, even though route structure defined folders, route publicly accessible page.js route.js file added route segment. And, even route made publicly accessible, content returned page.js route.js sent client. means project files safely colocated inside route segments app directory without accidentally routable. Good know: - colocate project files app to. prefer, keep outside theapp directory. Private folders Private folders created prefixing folder underscore: _folderName indicates folder private implementation detail considered routing system, thereby opting folder subfolders routing. Since files app directory safely colocated default, private folders required colocation. However, useful for: - Separating UI logic routing logic. - Consistently organizing internal files across project Next.js ecosystem. - Sorting grouping files code editors. - Avoiding potential naming conflicts future Next.js file conventions. Good know: - framework convention, might also consider marking files outside private folders \"private\" using underscore pattern. - create URL segments start underscore prefixing folder name %5F (the URL-encoded form underscore):%5FfolderName .- use private folders, would helpful know Next.js special file conventions prevent unexpected naming conflicts. Route groups Route groups created wrapping folder parenthesis: (folderName) indicates folder organizational purposes included route's URL path. Route groups useful for: - Organizing routes groups e.g. site section, intent, team. - Enabling nested layouts route segment level: src directory Next.js supports storing application code (including app ) inside optional src directory. separates application code project configuration files mostly live root project. Common strategies following section lists high-level overview common strategies. simplest takeaway choose strategy works team consistent across project. Good know: examples below, using components andlib folders generalized placeholders, naming special framework significance projects might use folders likeui ,utils ,hooks ,styles , etc. Store project files outside app strategy stores application code shared folders root project keeps app directory purely routing purposes. Store project files top-level folders inside app strategy stores application code shared folders root app directory. Split project files feature route strategy stores globally shared application code root app directory splits specific application code route segments use them. helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/updating-data", "title": "Getting Started: Updating Data | Next.js", "text": "update data update data Next.js using React's Server Functions. page go create invoke Server Functions. Creating Server Functions Server Function defined using use server directive. place directive top asynchronous function mark function Server Function, top separate file mark exports file. recommend using separate file instances. 'use server' export async function createPost(formData: FormData) {} export async function deletePost(formData: FormData) {} Server Components Server Functions inlined Server Components adding \"use server\" directive top function body: export default function Page() { // Server Action async function createPost() { 'use server' // Update data // ... return <></> } Client Components possible define Server Functions Client Components. However, invoke Client Components importing file \"use server\" directive top it: 'use server' export async function createPost() {} 'use client' import { createPost } '@/app/actions' export function Button() { return <button formAction={createPost}>Create</button> } Invoking Server Functions two main ways invoke Server Function: - Forms Server Client Components - Event Handlers Client Components Forms React extends HTML <form> element allow Server Function invoked HTML action prop. invoked form, function automatically receives FormData object. extract data using native FormData methods: import { createPost } '@/app/actions' export function Form() { return ( <form action={createPost}> <input type=\"text\" name=\"title\" /> <input type=\"text\" name=\"content\" /> <button type=\"submit\">Create</button> </form> ) } 'use server' export async function createPost(formData: FormData) { const title = formData.get('title') const content = formData.get('content') // Update data // Revalidate cache } Good know: passed action prop, Server Functions also known Server Actions. Event Handlers invoke Server Function Client Component using event handlers onClick . 'use client' import { incrementLike } './actions' import { useState } 'react' export default function LikeButton({ initialLikes }: { initialLikes: number }) { const [likes, setLikes] = useState(initialLikes) return ( <> <p>Total Likes: {likes}</p> <button onClick={async () => { const updatedLikes = await incrementLike() setLikes(updatedLikes) }} > Like </button> </> ) } Showing pending state executing Server Function, show loading indicator React's useActionState hook. hook returns pending boolean: 'use client' import { useActionState } 'react' import { createPost } '@/app/actions' import { LoadingSpinner } '@/app/ui/loading-spinner' export function Button() { const [state, action, pending] = useActionState(createPost, false) return ( <button onClick={async () => action()}> {pending ? <LoadingSpinner /> : 'Create Post'} </button> ) } Revalidating cache performing update, revalidate Next.js cache show updated data calling revalidatePath revalidateTag within Server Function: 'use server' import { revalidatePath } 'next/cache' export async function createPost(formData: FormData) { // Update data // ... revalidatePath('/posts') } Redirecting may want redirect user different page performing update. calling redirect within Server Function: 'use server' import { redirect } 'next/navigation' export async function createPost(formData: FormData) { // Update data // ... redirect('/posts') } API Reference helpful?"}]