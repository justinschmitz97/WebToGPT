[{"source": "https://nextjs.org/docs/app/api-reference", "title": "App Router: API Reference | Next.js", "text": "API Reference\nThe Next.js API reference is divided into the following sections:\nDirectives\nDirectives are used to modify the behavior of your Next.js application.\nComponents\nAPI Reference for Next.js built-in components.\nFile Conventions\nAPI Reference for Next.js File Conventions.\nFunctions\nAPI Reference for Next.js Functions and Hooks.\nConfiguration\nLearn how to configure Next.js applications.\nCLI\nAPI Reference for the Next.js Command Line Interface (CLI) tools.\nEdge Runtime\nAPI Reference for the Edge Runtime.\nTurbopack\nTurbopack is an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js.\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/cli", "title": "API Reference: CLI | Next.js", "text": "CLI\nNext.js comes with two Command Line Interface (CLI) tools:\ncreate-next-app\n: Quickly create a new Next.js application using the default template or an example from a public GitHub repository.next\n: Run the Next.js development server, build your application, and more.\ncreate-next-app\nCreate Next.js apps using one command with the create-next-app CLI.\nnext CLI\nLearn how to run and build your application with the Next.js CLI.\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/cli/create-next-app", "title": "CLI: create-next-app | Next.js", "text": "create-next-app\nThe create-next-app\nCLI allow you to create a new Next.js application using the default template or an example from a public GitHub repository. It is the easiest way to get started with Next.js.\nBasic usage:\nnpx create-next-app@latest [project-name] [options]\nReference\nThe following options are available:\n| Options | Description |\n|---|---|\n-h or --help | Show all available options |\n-v or --version | Output the version number |\n--no-* | Negate default options. E.g. --no-eslint |\n--ts or --typescript | Initialize as a TypeScript project (default) |\n--js or --javascript | Initialize as a JavaScript project |\n--tailwind | Initialize with Tailwind CSS config (default) |\n--eslint | Initialize with ESLint config |\n--app | Initialize as an App Router project |\n--src-dir | Initialize inside a src/ directory |\n--turbopack | Enable Turbopack by default for development |\n--import-alias <alias-to-configure> | Specify import alias to use (default \"@/*\") |\n--empty | Initialize an empty project |\n--use-npm | Explicitly tell the CLI to bootstrap the application using npm |\n--use-pnpm | Explicitly tell the CLI to bootstrap the application using pnpm |\n--use-yarn | Explicitly tell the CLI to bootstrap the application using Yarn |\n--use-bun | Explicitly tell the CLI to bootstrap the application using Bun |\n-e or --example [name] [github-url] | An example to bootstrap the app with |\n--example-path <path-to-example> | Specify the path to the example separately |\n--reset-preferences | Explicitly tell the CLI to reset any stored preferences |\n--skip-install | Explicitly tell the CLI to skip installing packages |\n--yes | Use previous preferences or defaults for all options |\nExamples\nWith the default template\nTo create a new app using the default template, run the following command in your terminal:\nnpx create-next-app@latest\nYou will then be asked the following prompts:\nWhat is your project named? my-app\nWould you like to use TypeScript? No / Yes\nWould you like to use ESLint? No / Yes\nWould you like to use Tailwind CSS? No / Yes\nWould you like your code inside a `src/` directory? No / Yes\nWould you like to use App Router? (recommended) No / Yes\nWould you like to use Turbopack for `next dev`? No / Yes\nWould you like to customize the import alias (`@/*` by default)? No / Yes\nOnce you've answered the prompts, a new project will be created with your chosen configuration.\nWith an official Next.js example\nTo create a new app using an official Next.js example, use the --example\nflag. For example:\nnpx create-next-app@latest --example [example-name] [your-project-name]\nYou can view a list of all available examples along with setup instructions in the Next.js repository.\nWith any public GitHub example\nTo create a new app using any public GitHub example, use the --example\noption with the GitHub repo's URL. For example:\nnpx create-next-app@latest --example \"https://github.com/.../\" [your-project-name]\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/cli/next", "title": "CLI: next CLI | Next.js", "text": "next CLI\nThe Next.js CLI allows you to develop, build, start your application, and more.\nBasic usage:\nnpx next [command] [options]\nReference\nThe following options are available:\n| Options | Description |\n|---|---|\n-h or --help | Shows all available options |\n-v or --version | Outputs the Next.js version number |\nCommands\nThe following commands are available:\n| Command | Description |\n|---|---|\ndev | Starts Next.js in development mode with Hot Module Reloading, error reporting, and more. |\nbuild | Creates an optimized production build of your application. Displaying information about each route. |\nstart | Starts Next.js in production mode. The application should be compiled with next build first. |\ninfo | Prints relevant details about the current system which can be used to report Next.js bugs. |\nlint | Runs ESLint for all files in the /src , /app , /pages , /components , and /lib directories. It also provides a guided setup to install any required dependencies if ESLint it is not already configured in your application. |\ntelemetry | Allows you to enable or disable Next.js' completely anonymous telemetry collection. |\nGood to know: Running\nnext\nwithout a command is an alias fornext dev\n.\nnext dev\noptions\nnext dev\nstarts the application in development mode with Hot Module Reloading (HMR), error reporting, and more. The following options are available when running next dev\n:\n| Option | Description |\n|---|---|\n-h, --help | Show all available options. |\n[directory] | A directory in which to build the application. If not provided, current directory is used. |\n--turbopack | Starts development mode using Turbopack. |\n-p or --port <port> | Specify a port number on which to start the application. Default: 3000, env: PORT |\n-H or --hostname <hostname> | Specify a hostname on which to start the application. Useful for making the application available for other devices on the network. Default: 0.0.0.0 |\n--experimental-https | Starts the server with HTTPS and generates a self-signed certificate. |\n--experimental-https-key <path> | Path to a HTTPS key file. |\n--experimental-https-cert <path> | Path to a HTTPS certificate file. |\n--experimental-https-ca <path> | Path to a HTTPS certificate authority file. |\n--experimental-upload-trace <traceUrl> | Reports a subset of the debugging trace to a remote HTTP URL. |\nnext build\noptions\nnext build\ncreates an optimized production build of your application. The output displays information about each route. For example:\nRoute (app) Size First Load JS\n\u250c \u25cb /_not-found 0 B 0 kB\n\u2514 \u0192 /products/[id] 0 B 0 kB\n\u25cb (Static) prerendered as static content\n\u0192 (Dynamic) server-rendered on demand\n- Size: The size of assets downloaded when navigating to the page client-side. The size for each route only includes its dependencies.\n- First Load JS: The size of assets downloaded when visiting the page from the server. The amount of JS shared by all is shown as a separate metric.\nBoth of these values are compressed with gzip. The first load is indicated by green, yellow, or red. Aim for green for performant applications.\nThe following options are available for the next build\ncommand:\n| Option | Description |\n|---|---|\n-h, --help | Show all available options. |\n[directory] | A directory on which to build the application. If not provided, the current directory will be used. |\n-d or --debug | Enables a more verbose build output. With this flag enabled additional build output like rewrites, redirects, and headers will be shown. |\n--profile | Enables production profiling for React. |\n--no-lint | Disables linting. |\n--no-mangling | Disables mangling. This may affect performance and should only be used for debugging purposes. |\n--experimental-app-only | Builds only App Router routes. |\n--experimental-build-mode [mode] | Uses an experimental build mode. (choices: \"compile\", \"generate\", default: \"default\") |\nnext start\noptions\nnext start\nstarts the application in production mode. The application should be compiled with next build\nfirst.\nThe following options are available for the next start\ncommand:\n| Option | Description |\n|---|---|\n-h or --help | Show all available options. |\n[directory] | A directory on which to start the application. If no directory is provided, the current directory will be used. |\n-p or --port <port> | Specify a port number on which to start the application. (default: 3000, env: PORT) |\n-H or --hostname <hostname> | Specify a hostname on which to start the application (default: 0.0.0.0). |\n--keepAliveTimeout <keepAliveTimeout> | Specify the maximum amount of milliseconds to wait before closing the inactive connections. |\nnext info\noptions\nnext info\nprints relevant details about the current system which can be used to report Next.js bugs when opening a GitHub issue. This information includes Operating System platform/arch/version, Binaries (Node.js, npm, Yarn, pnpm), package versions (next\n, react\n, react-dom\n), and more.\nThe output should look like this:\nOperating System:\nPlatform: darwin\nArch: arm64\nVersion: Darwin Kernel Version 23.6.0\nAvailable memory (MB): 65536\nAvailable CPU cores: 10\nBinaries:\nNode: 20.12.0\nnpm: 10.5.0\nYarn: 1.22.19\npnpm: 9.6.0\nRelevant Packages:\nnext: 15.0.0-canary.115 // Latest available version is detected (15.0.0-canary.115).\neslint-config-next: 14.2.5\nreact: 19.0.0-rc\nreact-dom: 19.0.0\ntypescript: 5.5.4\nNext.js Config:\noutput: N/A\nThe following options are available for the next info\ncommand:\n| Option | Description |\n|---|---|\n-h or --help | Show all available options |\n--verbose | Collects additional information for debugging. |\nnext lint\noptions\nnext lint\nruns ESLint for all files in the pages/\n, app/\n, components/\n, lib/\n, and src/\ndirectories. It also provides a guided setup to install any required dependencies if ESLint is not already configured in your application.\nThe following options are available for the next lint\ncommand:\n| Option | Description |\n|---|---|\n[directory] | A base directory on which to lint the application. If not provided, the current directory will be used. |\n-d, --dir, <dirs...> | Include directory, or directories, to run ESLint. |\n--file, <files...> | Include file, or files, to run ESLint. |\n--ext, [exts...] | Specify JavaScript file extensions. (default: [\".js\", \".mjs\", \".cjs\", \".jsx\", \".ts\", \".mts\", \".cts\", \".tsx\"]) |\n-c, --config, <config> | Uses this configuration file, overriding all other configuration options. |\n--resolve-plugins-relative-to, <rprt> | Specify a directory where plugins should be resolved from. |\n--strict | Creates a .eslintrc.json file using the Next.js strict configuration. |\n--rulesdir, <rulesdir...> | Uses additional rules from this directory(s). |\n--fix | Automatically fix linting issues. |\n--fix-type <fixType> | Specify the types of fixes to apply (e.g., problem, suggestion, layout). |\n--ignore-path <path> | Specify a file to ignore. |\n--no-ignore <path> | Disables the --ignore-path option. |\n--quiet | Reports errors only. |\n--max-warnings [maxWarnings] | Specify the number of warnings before triggering a non-zero exit code. (default: -1) |\n-o, --output-file, <outputFile> | Specify a file to write report to. |\n-f, --format, <format> | Uses a specific output format. |\n--no-inline-config | Prevents comments from changing config or rules. |\n--report-unused-disable-directives-severity <level> | Specify severity level for unused eslint-disable directives. (choices: \"error\", \"off\", \"warn\") |\n--no-cache | Disables caching. |\n--cache-location, <cacheLocation> | Specify a location for cache. |\n--cache-strategy, [cacheStrategy] | Specify a strategy to use for detecting changed files in the cache. (default: \"metadata\") |\n--error-on-unmatched-pattern | Reports errors when any file patterns are unmatched. |\n-h, --help | Displays this message. |\nnext telemetry\noptions\nNext.js collects completely anonymous telemetry data about general usage. Participation in this anonymous program is optional, and you can opt-out if you prefer not to share information.\nThe following options are available for the next telemetry\ncommand:\n| Option | Description |\n|---|---|\n-h, --help | Show all available options. |\n--enable | Enables Next.js' telemetry collection. |\n--disable | Disables Next.js' telemetry collection. |\nLearn more about Telemetry.\nExamples\nChanging the default port\nBy default, Next.js uses http://localhost:3000\nduring development and with next start\n. The default port can be changed with the -p\noption, like so:\nnext dev -p 4000\nOr using the PORT\nenvironment variable:\nPORT=4000 next dev\nGood to know:\nPORT\ncannot be set in.env\nas booting up the HTTP server happens before any other code is initialized.\nUsing HTTPS during development\nFor certain use cases like webhooks or authentication, you can use HTTPS to have a secure environment on localhost\n. Next.js can generate a self-signed certificate with next dev\nusing the --experimental-https\nflag:\nnext dev --experimental-https\nWith the generated certificate, the Next.js development server will exist at https://localhost:3000\n. The default port 3000\nis used unless a port is specified with -p\n, --port\n, or PORT\n.\nYou can also provide a custom certificate and key with --experimental-https-key\nand --experimental-https-cert\n. Optionally, you can provide a custom CA certificate with --experimental-https-ca\nas well.\nnext dev --experimental-https --experimental-https-key ./certificates/localhost-key.pem --experimental-https-cert ./certificates/localhost.pem\nnext dev --experimental-https\nis only intended for development and creates a locally trusted certificate with mkcert\n. In production, use properly issued certificates from trusted authorities.\nGood to know: When deploying to Vercel, HTTPS is automatically configured for your Next.js application.\nConfiguring a timeout for downstream proxies\nWhen deploying Next.js behind a downstream proxy (e.g. a load-balancer like AWS ELB/ALB), it's important to configure Next's underlying HTTP server with keep-alive timeouts that are larger than the downstream proxy's timeouts. Otherwise, once a keep-alive timeout is reached for a given TCP connection, Node.js will immediately terminate that connection without notifying the downstream proxy. This results in a proxy error whenever it attempts to reuse a connection that Node.js has already terminated.\nTo configure the timeout values for the production Next.js server, pass --keepAliveTimeout\n(in milliseconds) to next start\n, like so:\nnext start --keepAliveTimeout 70000\nPassing Node.js arguments\nYou can pass any node arguments to next\ncommands. For example:\nNODE_OPTIONS='--throw-deprecation' next\nNODE_OPTIONS='-r esm' next\nNODE_OPTIONS='--inspect' next\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/components", "title": "API Reference: Components | Next.js", "text": "Components\nFont\nOptimizing loading web fonts with the built-in `next/font` loaders.\n<Form>\nLearn how to use the `<Form>` component to handle form submissions and search params updates with client-side navigation.\n<Image>\nOptimize Images in your Next.js Application using the built-in `next/image` Component.\n<Link>\nEnable fast client-side navigation with the built-in `next/link` component.\n<Script>\nOptimize third-party scripts in your Next.js application using the built-in `next/script` Component.\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/components/font", "title": "Components: Font | Next.js", "text": "Font Module\nThis API reference will help you understand how to use next/font/google\nand next/font/local\n. For features and usage, please see the Optimizing Fonts page.\nFont Function Arguments\nFor usage, review Google Fonts and Local Fonts.\n| Key | font/google | font/local | Type | Required |\n|---|---|---|---|---|\nsrc | String or Array of Objects | Yes | ||\nweight | String or Array | Required/Optional | ||\nstyle | String or Array | - | ||\nsubsets | Array of Strings | - | ||\naxes | Array of Strings | - | ||\ndisplay | String | - | ||\npreload | Boolean | - | ||\nfallback | Array of Strings | - | ||\nadjustFontFallback | Boolean or String | - | ||\nvariable | String | - | ||\ndeclarations | Array of Objects | - |\nsrc\nThe path of the font file as a string or an array of objects (with type Array<{path: string, weight?: string, style?: string}>\n) relative to the directory where the font loader function is called.\nUsed in next/font/local\n- Required\nExamples:\nsrc:'./fonts/my-font.woff2'\nwheremy-font.woff2\nis placed in a directory namedfonts\ninside theapp\ndirectorysrc:[{path: './inter/Inter-Thin.ttf', weight: '100',},{path: './inter/Inter-Regular.ttf',weight: '400',},{path: './inter/Inter-Bold-Italic.ttf', weight: '700',style: 'italic',},]\n- if the font loader function is called in\napp/page.tsx\nusingsrc:'../styles/fonts/my-font.ttf'\n, thenmy-font.ttf\nis placed instyles/fonts\nat the root of the project\nweight\nThe font weight\nwith the following possibilities:\n- A string with possible values of the weights available for the specific font or a range of values if it's a variable font\n- An array of weight values if the font is not a variable google font. It applies to\nnext/font/google\nonly.\nUsed in next/font/google\nand next/font/local\n- Required if the font being used is not variable\nExamples:\nweight: '400'\n: A string for a single weight value - for the fontInter\n, the possible values are'100'\n,'200'\n,'300'\n,'400'\n,'500'\n,'600'\n,'700'\n,'800'\n,'900'\nor'variable'\nwhere'variable'\nis the default)weight: '100 900'\n: A string for the range between100\nand900\nfor a variable fontweight: ['100','400','900']\n: An array of 3 possible values for a non variable font\nstyle\nThe font style\nwith the following possibilities:\n- A string value with default value of\n'normal'\n- An array of style values if the font is not a variable google font. It applies to\nnext/font/google\nonly.\nUsed in next/font/google\nand next/font/local\n- Optional\nExamples:\nstyle: 'italic'\n: A string - it can benormal\noritalic\nfornext/font/google\nstyle: 'oblique'\n: A string - it can take any value fornext/font/local\nbut is expected to come from standard font stylesstyle: ['italic','normal']\n: An array of 2 values fornext/font/google\n- the values are fromnormal\nanditalic\nsubsets\nThe font subsets\ndefined by an array of string values with the names of each subset you would like to be preloaded. Fonts specified via subsets\nwill have a link preload tag injected into the head when the preload\noption is true, which is the default.\nUsed in next/font/google\n- Optional\nExamples:\nsubsets: ['latin']\n: An array with the subsetlatin\nYou can find a list of all subsets on the Google Fonts page for your font.\naxes\nSome variable fonts have extra axes\nthat can be included. By default, only the font weight is included to keep the file size down. The possible values of axes\ndepend on the specific font.\nUsed in next/font/google\n- Optional\nExamples:\naxes: ['slnt']\n: An array with valueslnt\nfor theInter\nvariable font which hasslnt\nas additionalaxes\nas shown here. You can find the possibleaxes\nvalues for your font by using the filter on the Google variable fonts page and looking for axes other thanwght\ndisplay\nThe font display\nwith possible string values of 'auto'\n, 'block'\n, 'swap'\n, 'fallback'\nor 'optional'\nwith default value of 'swap'\n.\nUsed in next/font/google\nand next/font/local\n- Optional\nExamples:\ndisplay: 'optional'\n: A string assigned to theoptional\nvalue\npreload\nA boolean value that specifies whether the font should be preloaded or not. The default is true\n.\nUsed in next/font/google\nand next/font/local\n- Optional\nExamples:\npreload: false\nfallback\nThe fallback font to use if the font cannot be loaded. An array of strings of fallback fonts with no default.\n- Optional\nUsed in next/font/google\nand next/font/local\nExamples:\nfallback: ['system-ui', 'arial']\n: An array setting the fallback fonts tosystem-ui\norarial\nadjustFontFallback\n- For\nnext/font/google\n: A boolean value that sets whether an automatic fallback font should be used to reduce Cumulative Layout Shift. The default istrue\n. - For\nnext/font/local\n: A string or booleanfalse\nvalue that sets whether an automatic fallback font should be used to reduce Cumulative Layout Shift. The possible values are'Arial'\n,'Times New Roman'\norfalse\n. The default is'Arial'\n.\nUsed in next/font/google\nand next/font/local\n- Optional\nExamples:\nadjustFontFallback: false\n: fornext/font/google\nadjustFontFallback: 'Times New Roman'\n: fornext/font/local\nvariable\nA string value to define the CSS variable name to be used if the style is applied with the CSS variable method.\nUsed in next/font/google\nand next/font/local\n- Optional\nExamples:\nvariable: '--my-font'\n: The CSS variable--my-font\nis declared\ndeclarations\nAn array of font face descriptor key-value pairs that define the generated @font-face\nfurther.\nUsed in next/font/local\n- Optional\nExamples:\ndeclarations: [{ prop: 'ascent-override', value: '90%' }]\nApplying Styles\nYou can apply the font styles in three ways:\nclassName\nReturns a read-only CSS className\nfor the loaded font to be passed to an HTML element.\n<p className={inter.className}>Hello, Next.js!</p>\nstyle\nReturns a read-only CSS style\nobject for the loaded font to be passed to an HTML element, including style.fontFamily\nto access the font family name and fallback fonts.\n<p style={inter.style}>Hello World</p>\nCSS Variables\nIf you would like to set your styles in an external style sheet and specify additional options there, use the CSS variable method.\nIn addition to importing the font, also import the CSS file where the CSS variable is defined and set the variable option of the font loader object as follows:\nimport { Inter } from 'next/font/google'\nimport styles from '../styles/component.module.css'\nconst inter = Inter({\nvariable: '--font-inter',\n})\nTo use the font, set the className\nof the parent container of the text you would like to style to the font loader's variable\nvalue and the className\nof the text to the styles\nproperty from the external CSS file.\n<main className={inter.variable}>\n<p className={styles.text}>Hello World</p>\n</main>\nDefine the text\nselector class in the component.module.css\nCSS file as follows:\n.text {\nfont-family: var(--font-inter);\nfont-weight: 200;\nfont-style: italic;\n}\nIn the example above, the text Hello World\nis styled using the Inter\nfont and the generated font fallback with font-weight: 200\nand font-style: italic\n.\nUsing a font definitions file\nEvery time you call the localFont\nor Google font function, that font will be hosted as one instance in your application. Therefore, if you need to use the same font in multiple places, you should load it in one place and import the related font object where you need it. This is done using a font definitions file.\nFor example, create a fonts.ts\nfile in a styles\nfolder at the root of your app directory.\nThen, specify your font definitions as follows:\nimport { Inter, Lora, Source_Sans_3 } from 'next/font/google'\nimport localFont from 'next/font/local'\n// define your variable fonts\nconst inter = Inter()\nconst lora = Lora()\n// define 2 weights of a non-variable font\nconst sourceCodePro400 = Source_Sans_3({ weight: '400' })\nconst sourceCodePro700 = Source_Sans_3({ weight: '700' })\n// define a custom local font where GreatVibes-Regular.ttf is stored in the styles folder\nconst greatVibes = localFont({ src: './GreatVibes-Regular.ttf' })\nexport { inter, lora, sourceCodePro400, sourceCodePro700, greatVibes }\nYou can now use these definitions in your code as follows:\nimport { inter, lora, sourceCodePro700, greatVibes } from '../styles/fonts'\nexport default function Page() {\nreturn (\n<div>\n<p className={inter.className}>Hello world using Inter font</p>\n<p style={lora.style}>Hello world using Lora font</p>\n<p className={sourceCodePro700.className}>\nHello world using Source_Sans_3 font with weight 700\n</p>\n<p className={greatVibes.className}>My title in Great Vibes font</p>\n</div>\n)\n}\nTo make it easier to access the font definitions in your code, you can define a path alias in your tsconfig.json\nor jsconfig.json\nfiles as follows:\n{\n\"compilerOptions\": {\n\"paths\": {\n\"@/fonts\": [\"./styles/fonts\"]\n}\n}\n}\nYou can now import any font definition as follows:\nimport { greatVibes, sourceCodePro400 } from '@/fonts'\nVersion Changes\n| Version | Changes |\n|---|---|\nv13.2.0 | @next/font renamed to next/font . Installation no longer required. |\nv13.0.0 | @next/font was added. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/components/form", "title": "Components: <Form> | Next.js", "text": "<Form>\nThe <Form>\ncomponent extends the HTML <form>\nelement to provide prefetching of loading UI, client-side navigation on submission, and progressive enhancement.\nIt's useful for forms that update URL search params as it reduces the boilerplate code needed to achieve the above.\nBasic usage:\nimport Form from 'next/form'\nexport default function Page() {\nreturn (\n<Form action=\"/search\">\n{/* On submission, the input value will be appended to\nthe URL, e.g. /search?query=abc */}\n<input name=\"query\" />\n<button type=\"submit\">Submit</button>\n</Form>\n)\n}\nReference\nThe behavior of the <Form>\ncomponent depends on whether the action\nprop is passed a string\nor function\n.\n- When\naction\nis a string, the<Form>\nbehaves like a native HTML form that uses aGET\nmethod. The form data is encoded into the URL as search params, and when the form is submitted, it navigates to the specified URL. In addition, Next.js:- Prefetches the path when the form becomes visible, this preloads shared UI (e.g.\nlayout.js\nandloading.js\n), resulting in faster navigation. - Performs a client-side navigation instead of a full page reload when the form is submitted. This retains shared UI and client-side state.\n- Prefetches the path when the form becomes visible, this preloads shared UI (e.g.\n- When\naction\nis a function (Server Action),<Form>\nbehaves like a React form, executing the action when the form is submitted.\naction\n(string) Props\nWhen action\nis a string, the <Form>\ncomponent supports the following props:\n| Prop | Example | Type | Required |\n|---|---|---|---|\naction | action=\"/search\" | string (URL or relative path) | Yes |\nreplace | replace={false} | boolean | - |\nscroll | scroll={true} | boolean | - |\nprefetch | prefetch={true} | boolean | - |\naction\n: The URL or path to navigate to when the form is submitted.- An empty string\n\"\"\nwill navigate to the same route with updated search params.\n- An empty string\nreplace\n: Replaces the current history state instead of pushing a new one to the browser's history stack. Default isfalse\n.scroll\n: Controls the scroll behavior during navigation. Defaults totrue\n, this means it will scroll to the top of the new route, and maintain the scroll position for backwards and forwards navigation.prefetch\n: Controls whether the path should be prefetched when the form becomes visible in the user's viewport. Defaults totrue\n.\naction\n(function) Props\nWhen action\nis a function, the <Form>\ncomponent supports the following prop:\n| Prop | Example | Type | Required |\n|---|---|---|---|\naction | action={myAction} | function (Server Action) | Yes |\naction\n: The Server Action to be called when the form is submitted. See the React docs for more.\nGood to know: When\naction\nis a function, thereplace\nandscroll\nprops are ignored.\nCaveats\nformAction\n: Can be used in a<button>\nor<input type=\"submit\">\nfields to override theaction\nprop. Next.js will perform a client-side navigation, however, this approach doesn't support prefetching.- When using\nbasePath\n, you must also include it in theformAction\npath. e.g.formAction=\"/base-path/search\"\n.\n- When using\nkey\n: Passing akey\nprop to a stringaction\nis not supported. If you'd like to trigger a re-render or perform a mutation, consider using a functionaction\ninstead.\nonSubmit\n: Can be used to handle form submission logic. However, callingevent.preventDefault()\nwill override<Form>\nbehavior such as navigating to the specified URL.method\n,encType\n,target\n: Are not supported as they override<Form>\nbehavior.- Similarly,\nformMethod\n,formEncType\n, andformTarget\ncan be used to override themethod\n,encType\n, andtarget\nprops respectively, and using them will fallback to native browser behavior. - If you need to use these props, use the HTML\n<form>\nelement instead.\n- Similarly,\n<input type=\"file\">\n: Using this input type when theaction\nis a string will match browser behavior by submitting the filename instead of the file object.\nExamples\nSearch form that leads to a search result page\nYou can create a search form that navigates to a search results page by passing the path as an action\n:\nimport Form from 'next/form'\nexport default function Page() {\nreturn (\n<Form action=\"/search\">\n<input name=\"query\" />\n<button type=\"submit\">Submit</button>\n</Form>\n)\n}\nWhen the user updates the query input field and submits the form, the form data will be encoded into the URL as search params, e.g. /search?query=abc\n.\nGood to know: If you pass an empty string\n\"\"\ntoaction\n, the form will navigate to the same route with updated search params.\nOn the results page, you can access the query using the searchParams\npage.js\nprop and use it to fetch data from an external source.\nimport { getSearchResults } from '@/lib/search'\nexport default async function SearchPage({\nsearchParams,\n}: {\nsearchParams: { [key: string]: string | string[] | undefined }\n}) {\nconst results = await getSearchResults(searchParams.query)\nreturn <div>...</div>\n}\nWhen the <Form>\nbecomes visible in the user's viewport, shared UI (such as layout.js\nand loading.js\n) on the /search\npage will be prefetched. On submission, the form will immediately navigate to the new route and show loading UI while the results are being fetched. You can design the fallback UI using loading.js\n:\nexport default function Loading() {\nreturn <div>Loading...</div>\n}\nTo cover cases when shared UI hasn't yet loaded, you can show instant feedback to the user using useFormStatus\n.\nFirst, create a component that displays a loading state when the form is pending:\n'use client'\nimport { useFormStatus } from 'react-dom'\nexport default function SearchButton() {\nconst status = useFormStatus()\nreturn (\n<button type=\"submit\">{status.pending ? 'Searching...' : 'Search'}</button>\n)\n}\nThen, update the search form page to use the SearchButton\ncomponent:\nimport Form from 'next/form'\nimport { SearchButton } from '@/ui/search-button'\nexport default function Page() {\nreturn (\n<Form action=\"/search\">\n<input name=\"query\" />\n<SearchButton />\n</Form>\n)\n}\nMutations with Server Actions\nYou can perform mutations by passing a function to the action\nprop.\nimport Form from 'next/form'\nimport { createPost } from '@/posts/actions'\nexport default function Page() {\nreturn (\n<Form action={createPost}>\n<input name=\"title\" />\n{/* ... */}\n<button type=\"submit\">Create Post</button>\n</Form>\n)\n}\nAfter a mutation, it's common to redirect to the new resource. You can use the redirect\nfunction from next/navigation\nto navigate to the new post page.\nGood to know: Since the \"destination\" of the form submission is not known until the action is executed,\n<Form>\ncannot automatically prefetch shared UI.\n'use server'\nimport { redirect } from 'next/navigation'\nexport async function createPost(formData: FormData) {\n// Create a new post\n// ...\n// Redirect to the new post\nredirect(`/posts/${data.id}`)\n}\nThen, in the new page, you can fetch data using the params\nprop:\nimport { getPost } from '@/posts/data'\nexport default async function PostPage({\nparams,\n}: {\nparams: Promise<{ id: string }>\n}) {\nconst data = await getPost((await params).id)\nreturn (\n<div>\n<h1>{data.title}</h1>\n{/* ... */}\n</div>\n)\n}\nSee the Server Actions docs for more examples.\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/components/image", "title": "Components: <Image> | Next.js", "text": "<Image>\nExamples\nThis API reference will help you understand how to use props and configuration options available for the Image Component. For features and usage, please see the Image Component page.\nimport Image from 'next/image'\nexport default function Page() {\nreturn (\n<Image\nsrc=\"/profile.png\"\nwidth={500}\nheight={500}\nalt=\"Picture of the author\"\n/>\n)\n}\nProps\nHere's a summary of the props available for the Image Component:\n| Prop | Example | Type | Status |\n|---|---|---|---|\nsrc | src=\"/profile.png\" | String | Required |\nwidth | width={500} | Integer (px) | Required |\nheight | height={500} | Integer (px) | Required |\nalt | alt=\"Picture of the author\" | String | Required |\nloader | loader={imageLoader} | Function | - |\nfill | fill={true} | Boolean | - |\nsizes | sizes=\"(max-width: 768px) 100vw, 33vw\" | String | - |\nquality | quality={80} | Integer (1-100) | - |\npriority | priority={true} | Boolean | - |\nplaceholder | placeholder=\"blur\" | String | - |\nstyle | style={{objectFit: \"contain\"}} | Object | - |\nonLoadingComplete | onLoadingComplete={img => done())} | Function | Deprecated |\nonLoad | onLoad={event => done())} | Function | - |\nonError | onError(event => fail()} | Function | - |\nloading | loading=\"lazy\" | String | - |\nblurDataURL | blurDataURL=\"data:image/jpeg...\" | String | - |\noverrideSrc | overrideSrc=\"/seo.png\" | String | - |\nRequired Props\nThe Image Component requires the following properties: src\n, alt\n, width\nand height\n(or fill\n).\nimport Image from 'next/image'\nexport default function Page() {\nreturn (\n<div>\n<Image\nsrc=\"/profile.png\"\nwidth={500}\nheight={500}\nalt=\"Picture of the author\"\n/>\n</div>\n)\n}\nsrc\nMust be one of the following:\n- A statically imported image file\n- A path string. This can be either an absolute external URL, or an internal path depending on the loader prop.\nWhen using the default loader, also consider the following for source images:\n- When src is an external URL, you must also configure remotePatterns\n- When src is animated or not a known format (JPEG, PNG, WebP, AVIF, GIF, TIFF) the image will be served as-is\n- When src is SVG format, it will be blocked unless\nunoptimized\nordangerouslyAllowSVG\nis enabled\nwidth\nThe width\nproperty represents the intrinsic image width in pixels. This property is used to infer the correct aspect ratio of the image and avoid layout shift during loading. It does not determine the rendered size of the image, which is controlled by CSS, similar to the width\nattribute in the HTML <img>\ntag.\nRequired, except for statically imported images or images with the fill\nproperty.\nheight\nThe height\nproperty represents the intrinsic image height in pixels. This property is used to infer the correct aspect ratio of the image and avoid layout shift during loading. It does not determine the rendered size of the image, which is controlled by CSS, similar to the height\nattribute in the HTML <img>\ntag.\nRequired, except for statically imported images or images with the fill\nproperty.\nGood to know:\n- Combined, both\nwidth\nandheight\nproperties are used to determine the aspect ratio of the image which used by browsers to reserve space for the image before it loads.- The intrinsic size does not always mean the rendered size in the browser, which will be determined by the parent container. For example, if the parent container is smaller than the intrinsic size, the image will be scaled down to fit the container.\n- You can use the\nfill\nproperty when the width and height are unknown.\nalt\nThe alt\nproperty is used to describe the image for screen readers and search engines. It is also the fallback text if images have been disabled or an error occurs while loading the image.\nIt should contain text that could replace the image without changing the meaning of the page. It is not meant to supplement the image and should not repeat information that is already provided in the captions above or below the image.\nIf the image is purely decorative or not intended for the user, the alt\nproperty should be an empty string (alt=\"\"\n).\nOptional Props\nThe <Image />\ncomponent accepts a number of additional properties beyond those which are required. This section describes the most commonly-used properties of the Image component. Find details about more rarely-used properties in the Advanced Props section.\nloader\nA custom function used to resolve image URLs.\nA loader\nis a function returning a URL string for the image, given the following parameters:\nHere is an example of using a custom loader:\n'use client'\nimport Image from 'next/image'\nconst imageLoader = ({ src, width, quality }) => {\nreturn `https://example.com/${src}?w=${width}&q=${quality || 75}`\n}\nexport default function Page() {\nreturn (\n<Image\nloader={imageLoader}\nsrc=\"me.png\"\nalt=\"Picture of the author\"\nwidth={500}\nheight={500}\n/>\n)\n}\nGood to know: Using props like\nloader\n, which accept a function, requires using Client Components to serialize the provided function.\nAlternatively, you can use the loaderFile configuration in next.config.js\nto configure every instance of next/image\nin your application, without passing a prop.\nfill\nfill={true} // {true} | {false}\nA boolean that causes the image to fill the parent element, which is useful when the width\nand height\nare unknown.\nThe parent element must assign position: \"relative\"\n, position: \"fixed\"\n, or position: \"absolute\"\nstyle.\nBy default, the img element will automatically be assigned the position: \"absolute\"\nstyle.\nIf no styles are applied to the image, the image will stretch to fit the container. You may prefer to set object-fit: \"contain\"\nfor an image which is letterboxed to fit the container and preserve aspect ratio.\nAlternatively, object-fit: \"cover\"\nwill cause the image to fill the entire container and be cropped to preserve aspect ratio.\nFor more information, see also:\nsizes\nA string, similar to a media query, that provides information about how wide the image will be at different breakpoints. The value of sizes\nwill greatly affect performance for images using fill\nor which are styled to have a responsive size.\nThe sizes\nproperty serves two important purposes related to image performance:\n- First, the value of\nsizes\nis used by the browser to determine which size of the image to download, fromnext/image\n's automatically generatedsrcset\n. When the browser chooses, it does not yet know the size of the image on the page, so it selects an image that is the same size or larger than the viewport. Thesizes\nproperty allows you to tell the browser that the image will actually be smaller than full screen. If you don't specify asizes\nvalue in an image with thefill\nproperty, a default value of100vw\n(full screen width) is used. - Second, the\nsizes\nproperty changes the behavior of the automatically generatedsrcset\nvalue. If nosizes\nvalue is present, a smallsrcset\nis generated, suitable for a fixed-size image (1x/2x/etc). Ifsizes\nis defined, a largesrcset\nis generated, suitable for a responsive image (640w/750w/etc). If thesizes\nproperty includes sizes such as50vw\n, which represent a percentage of the viewport width, then thesrcset\nis trimmed to not include any values which are too small to ever be necessary.\nFor example, if you know your styling will cause an image to be full-width on mobile devices, in a 2-column layout on tablets, and a 3-column layout on desktop displays, you should include a sizes property such as the following:\nimport Image from 'next/image'\nexport default function Page() {\nreturn (\n<div className=\"grid-element\">\n<Image\nfill\nsrc=\"/example.png\"\nsizes=\"(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw\"\n/>\n</div>\n)\n}\nThis example sizes\ncould have a dramatic effect on performance metrics. Without the 33vw\nsizes, the image selected from the server would be 3 times as wide as it needs to be. Because file size is proportional to the square of the width, without sizes\nthe user would download an image that's 9 times larger than necessary.\nLearn more about srcset\nand sizes\n:\nquality\nquality={75} // {number 1-100}\nThe quality of the optimized image, an integer between 1\nand 100\n, where 100\nis the best quality and therefore largest file size. Defaults to 75\n.\nIf the qualities\nconfiguration is defined in next.config.js\n, the quality\nprop must match one of the values defined in the configuration.\nGood to know: If the original source image was already low quality, setting the quality prop too high could cause the resulting optimized image to be larger than the original source image.\npriority\npriority={false} // {false} | {true}\nWhen true, the image will be considered high priority and\npreload. Lazy loading is automatically disabled for images using priority\n. If the loading\nproperty is also used and set to lazy\n, the priority\nproperty can't be used. The loading\nproperty is only meant for advanced use cases. Remove loading\nwhen priority\nis needed.\nYou should use the priority\nproperty on any image detected as the Largest Contentful Paint (LCP) element. It may be appropriate to have multiple priority images, as different images may be the LCP element for different viewport sizes.\nShould only be used when the image is visible above the fold. Defaults to false\n.\nplaceholder\nplaceholder = 'empty' // \"empty\" | \"blur\" | \"data:image/...\"\nA placeholder to use while the image is loading. Possible values are blur\n, empty\n, or data:image/...\n. Defaults to empty\n.\nWhen blur\n, the blurDataURL\nproperty will be used as the placeholder. If src\nis an object from a static import and the imported image is .jpg\n, .png\n, .webp\n, or .avif\n, then blurDataURL\nwill be automatically populated, except when the image is detected to be animated.\nFor dynamic images, you must provide the blurDataURL\nproperty. Solutions such as Plaiceholder can help with base64\ngeneration.\nWhen data:image/...\n, the Data URL will be used as the placeholder while the image is loading.\nWhen empty\n, there will be no placeholder while the image is loading, only empty space.\nTry it out:\n- Demo the\nblur\nplaceholder - Demo the shimmer effect with data URL\nplaceholder\nprop - Demo the color effect with\nblurDataURL\nprop\nAdvanced Props\nIn some cases, you may need more advanced usage. The <Image />\ncomponent optionally accepts the following advanced properties.\nstyle\nAllows passing CSS styles to the underlying image element.\nconst imageStyle = {\nborderRadius: '50%',\nborder: '1px solid #fff',\n}\nexport default function ProfileImage() {\nreturn <Image src=\"...\" style={imageStyle} />\n}\nRemember that the required width and height props can interact with your styling. If you use styling to modify an image's width, you should also style its height to auto\nto preserve its intrinsic aspect ratio, or your image will be distorted.\nonLoadingComplete\n'use client'\n<Image onLoadingComplete={(img) => console.log(img.naturalWidth)} />\nWarning: Deprecated since Next.js 14 in favor of\nonLoad\n.\nA callback function that is invoked once the image is completely loaded and the placeholder has been removed.\nThe callback function will be called with one argument, a reference to the underlying <img>\nelement.\nGood to know: Using props like\nonLoadingComplete\n, which accept a function, requires using Client Components to serialize the provided function.\nonLoad\n<Image onLoad={(e) => console.log(e.target.naturalWidth)} />\nA callback function that is invoked once the image is completely loaded and the placeholder has been removed.\nThe callback function will be called with one argument, the Event which has a target\nthat references the underlying <img>\nelement.\nGood to know: Using props like\nonLoad\n, which accept a function, requires using Client Components to serialize the provided function.\nonError\n<Image onError={(e) => console.error(e.target.id)} />\nA callback function that is invoked if the image fails to load.\nGood to know: Using props like\nonError\n, which accept a function, requires using Client Components to serialize the provided function.\nloading\nloading = 'lazy' // {lazy} | {eager}\nThe loading behavior of the image. Defaults to lazy\n.\nWhen lazy\n, defer loading the image until it reaches a calculated distance from\nthe viewport.\nWhen eager\n, load the image immediately.\nLearn more about the loading\nattribute.\nblurDataURL\nA Data URL to\nbe used as a placeholder image before the src\nimage successfully loads. Only takes effect when combined\nwith placeholder=\"blur\"\n.\nMust be a base64-encoded image. It will be enlarged and blurred, so a very small image (10px or less) is recommended. Including larger images as placeholders may harm your application performance.\nTry it out:\nYou can also generate a solid color Data URL to match the image.\nunoptimized\nunoptimized = {false} // {false} | {true}\nWhen true, the source image will be served as-is from the src\ninstead of changing quality, size, or format. Defaults to false\n.\nThis is useful for images that do not benefit from optimization such as small images (less than 1KB), vector images (SVG), or animated images (GIF).\nimport Image from 'next/image'\nconst UnoptimizedImage = (props) => {\nreturn <Image {...props} unoptimized />\n}\nSince Next.js 12.3.0, this prop can be assigned to all images by updating next.config.js\nwith the following configuration:\nmodule.exports = {\nimages: {\nunoptimized: true,\n},\n}\noverrideSrc\nWhen providing the src\nprop to the <Image>\ncomponent, both the srcset\nand src\nattributes are generated automatically for the resulting <img>\n.\n<Image src=\"/me.jpg\" />\n<img\nsrcset=\"\n/_next/image?url=%2Fme.jpg&w=640&q=75 1x,\n/_next/image?url=%2Fme.jpg&w=828&q=75 2x\n\"\nsrc=\"/_next/image?url=%2Fme.jpg&w=828&q=75\"\n/>\nIn some cases, it is not desirable to have the src\nattribute generated and you may wish to override it using the overrideSrc\nprop.\nFor example, when upgrading an existing website from <img>\nto <Image>\n, you may wish to maintain the same src\nattribute for SEO purposes such as image ranking or avoiding recrawl.\n<Image src=\"/me.jpg\" overrideSrc=\"/override.jpg\" />\n<img\nsrcset=\"\n/_next/image?url=%2Fme.jpg&w=640&q=75 1x,\n/_next/image?url=%2Fme.jpg&w=828&q=75 2x\n\"\nsrc=\"/override.jpg\"\n/>\ndecoding\nA hint to the browser indicating if it should wait for the image to be decoded before presenting other content updates or not. Defaults to async\n.\nPossible values are the following:\nasync\n- Asynchronously decode the image and allow other content to be rendered before it completes.sync\n- Synchronously decode the image for atomic presentation with other content.auto\n- No preference for the decoding mode; the browser decides what's best.\nLearn more about the decoding\nattribute.\nOther Props\nOther properties on the <Image />\ncomponent will be passed to the underlying\nimg\nelement with the exception of the following:\nsrcSet\n. Use Device Sizes instead.\nConfiguration Options\nIn addition to props, you can configure the Image Component in next.config.js\n. The following options are available:\nlocalPatterns\nYou can optionally configure localPatterns\nin your next.config.js\nfile in order to allow specific paths to be optimized and block all others paths.\nmodule.exports = {\nimages: {\nlocalPatterns: [\n{\npathname: '/assets/images/**',\nsearch: '',\n},\n],\n},\n}\nGood to know: The example above will ensure the\nsrc\nproperty ofnext/image\nmust start with/assets/images/\nand must not have a query string. Attempting to optimize any other path will respond with 400 Bad Request.\nremotePatterns\nTo protect your application from malicious users, configuration is required in order to use external images. This ensures that only external images from your account can be served from the Next.js Image Optimization API. These external images can be configured with the remotePatterns\nproperty in your next.config.js\nfile, as shown below:\nmodule.exports = {\nimages: {\nremotePatterns: [\n{\nprotocol: 'https',\nhostname: 'example.com',\nport: '',\npathname: '/account123/**',\nsearch: '',\n},\n],\n},\n}\nGood to know: The example above will ensure the\nsrc\nproperty ofnext/image\nmust start withhttps://example.com/account123/\nand must not have a query string. Any other protocol, hostname, port, or unmatched path will respond with 400 Bad Request.\nBelow is an example of the remotePatterns\nproperty in the next.config.js\nfile using a wildcard pattern in the hostname\n:\nmodule.exports = {\nimages: {\nremotePatterns: [\n{\nprotocol: 'https',\nhostname: '**.example.com',\nport: '',\nsearch: '',\n},\n],\n},\n}\nGood to know: The example above will ensure the\nsrc\nproperty ofnext/image\nmust start withhttps://img1.example.com\norhttps://me.avatar.example.com\nor any number of subdomains. It cannot have a port or query string. Any other protocol or unmatched hostname will respond with 400 Bad Request.\nWildcard patterns can be used for both pathname\nand hostname\nand have the following syntax:\n*\nmatch a single path segment or subdomain**\nmatch any number of path segments at the end or subdomains at the beginning\nThe **\nsyntax does not work in the middle of the pattern.\nGood to know: When omitting\nprotocol\n,port\n,pathname\n, orsearch\nthen the wildcard**\nis implied. This is not recommended because it may allow malicious actors to optimize urls you did not intend.\nBelow is an example of the remotePatterns\nproperty in the next.config.js\nfile using search\n:\nmodule.exports = {\nimages: {\nremotePatterns: [\n{\nprotocol: 'https',\nhostname: 'assets.example.com',\nsearch: '?v=1727111025337',\n},\n],\n},\n}\nGood to know: The example above will ensure the\nsrc\nproperty ofnext/image\nmust start withhttps://assets.example.com\nand must have the exact query string?v=1727111025337\n. Any other protocol or query string will respond with 400 Bad Request.\ndomains\nWarning: Deprecated since Next.js 14 in favor of strict\nremotePatterns\nin order to protect your application from malicious users. Only usedomains\nif you own all the content served from the domain.\nSimilar to remotePatterns\n, the domains\nconfiguration can be used to provide a list of allowed hostnames for external images.\nHowever, the domains\nconfiguration does not support wildcard pattern matching and it cannot restrict protocol, port, or pathname.\nBelow is an example of the domains\nproperty in the next.config.js\nfile:\nmodule.exports = {\nimages: {\ndomains: ['assets.acme.com'],\n},\n}\nloaderFile\nIf you want to use a cloud provider to optimize images instead of using the Next.js built-in Image Optimization API, you can configure the loaderFile\nin your next.config.js\nlike the following:\nmodule.exports = {\nimages: {\nloader: 'custom',\nloaderFile: './my/image/loader.js',\n},\n}\nThis must point to a file relative to the root of your Next.js application. The file must export a default function that returns a string, for example:\n'use client'\nexport default function myImageLoader({ src, width, quality }) {\nreturn `https://example.com/${src}?w=${width}&q=${quality || 75}`\n}\nAlternatively, you can use the loader\nprop to configure each instance of next/image\n.\nExamples:\nGood to know: Customizing the image loader file, which accepts a function, requires using Client Components to serialize the provided function.\nAdvanced\nThe following configuration is for advanced use cases and is usually not necessary. If you choose to configure the properties below, you will override any changes to the Next.js defaults in future updates.\ndeviceSizes\nIf you know the expected device widths of your users, you can specify a list of device width breakpoints using the deviceSizes\nproperty in next.config.js\n. These widths are used when the next/image\ncomponent uses sizes\nprop to ensure the correct image is served for user's device.\nIf no configuration is provided, the default below is used.\nmodule.exports = {\nimages: {\ndeviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],\n},\n}\nimageSizes\nYou can specify a list of image widths using the images.imageSizes\nproperty in your next.config.js\nfile. These widths are concatenated with the array of device sizes to form the full array of sizes used to generate image srcsets.\nThe reason there are two separate lists is that imageSizes is only used for images which provide a sizes\nprop, which indicates that the image is less than the full width of the screen. Therefore, the sizes in imageSizes should all be smaller than the smallest size in deviceSizes.\nIf no configuration is provided, the default below is used.\nmodule.exports = {\nimages: {\nimageSizes: [16, 32, 48, 64, 96, 128, 256, 384],\n},\n}\nqualities\nThe default Image Optimization API will automatically allow all qualities from 1 to 100. If you wish to restrict the allowed qualities, you can add configuration to next.config.js\n.\nmodule.exports = {\nimages: {\nqualities: [25, 50, 75],\n},\n}\nIn this example above, only three qualities are allowed: 25, 50, and 75. If the quality\nprop does not match a value in this array, the image will fail with 400 Bad Request.\nformats\nThe default Image Optimization API will automatically detect the browser's supported image formats via the request's Accept\nheader in order to determine the best output format.\nIf the Accept\nheader matches more than one of the configured formats, the first match in the array is used. Therefore, the array order matters. If there is no match (or the source image is animated), the Image Optimization API will fallback to the original image's format.\nIf no configuration is provided, the default below is used.\nmodule.exports = {\nimages: {\nformats: ['image/webp'],\n},\n}\nYou can enable AVIF support and still fallback to WebP with the following configuration.\nmodule.exports = {\nimages: {\nformats: ['image/avif', 'image/webp'],\n},\n}\nGood to know:\n- AVIF generally takes 50% longer to encode but it compresses 20% smaller compared to WebP. This means that the first time an image is requested, it will typically be slower and then subsequent requests that are cached will be faster.\n- If you self-host with a Proxy/CDN in front of Next.js, you must configure the Proxy to forward the\nAccept\nheader.\nCaching Behavior\nThe following describes the caching algorithm for the default loader. For all other loaders, please refer to your cloud provider's documentation.\nImages are optimized dynamically upon request and stored in the <distDir>/cache/images\ndirectory. The optimized image file will be served for subsequent requests until the expiration is reached. When a request is made that matches a cached but expired file, the expired image is served stale immediately. Then the image is optimized again in the background (also called revalidation) and saved to the cache with the new expiration date.\nThe cache status of an image can be determined by reading the value of the x-nextjs-cache\nresponse header. The possible values are the following:\nMISS\n- the path is not in the cache (occurs at most once, on the first visit)STALE\n- the path is in the cache but exceeded the revalidate time so it will be updated in the backgroundHIT\n- the path is in the cache and has not exceeded the revalidate time\nThe expiration (or rather Max Age) is defined by either the minimumCacheTTL\nconfiguration or the upstream image Cache-Control\nheader, whichever is larger. Specifically, the max-age\nvalue of the Cache-Control\nheader is used. If both s-maxage\nand max-age\nare found, then s-maxage\nis preferred. The max-age\nis also passed-through to any downstream clients including CDNs and browsers.\n- You can configure\nminimumCacheTTL\nto increase the cache duration when the upstream image does not includeCache-Control\nheader or the value is very low. - You can configure\ndeviceSizes\nandimageSizes\nto reduce the total number of possible generated images. - You can configure formats to disable multiple formats in favor of a single image format.\nminimumCacheTTL\nYou can configure the Time to Live (TTL) in seconds for cached optimized images. In many cases, it's better to use a Static Image Import which will automatically hash the file contents and cache the image forever with a Cache-Control\nheader of immutable\n.\nmodule.exports = {\nimages: {\nminimumCacheTTL: 60,\n},\n}\nThe expiration (or rather Max Age) of the optimized image is defined by either the minimumCacheTTL\nor the upstream image Cache-Control\nheader, whichever is larger.\nIf you need to change the caching behavior per image, you can configure headers\nto set the Cache-Control\nheader on the upstream image (e.g. /some-asset.jpg\n, not /_next/image\nitself).\nThere is no mechanism to invalidate the cache at this time, so its best to keep minimumCacheTTL\nlow. Otherwise you may need to manually change the src\nprop or delete <distDir>/cache/images\n.\ndisableStaticImages\nThe default behavior allows you to import static files such as import icon from './icon.png'\nand then pass that to the src\nproperty.\nIn some cases, you may wish to disable this feature if it conflicts with other plugins that expect the import to behave differently.\nYou can disable static image imports inside your next.config.js\n:\nmodule.exports = {\nimages: {\ndisableStaticImages: true,\n},\n}\ndangerouslyAllowSVG\nThe default loader does not optimize SVG images for a few reasons. First, SVG is a vector format meaning it can be resized losslessly. Second, SVG has many of the same features as HTML/CSS, which can lead to vulnerabilities without proper Content Security Policy (CSP) headers.\nTherefore, we recommended using the unoptimized\nprop when the src\nprop is known to be SVG. This happens automatically when src\nends with \".svg\"\n.\nHowever, if you need to serve SVG images with the default Image Optimization API, you can set dangerouslyAllowSVG\ninside your next.config.js\n:\nmodule.exports = {\nimages: {\ndangerouslyAllowSVG: true,\ncontentDispositionType: 'attachment',\ncontentSecurityPolicy: \"default-src 'self'; script-src 'none'; sandbox;\",\n},\n}\nIn addition, it is strongly recommended to also set contentDispositionType\nto force the browser to download the image, as well as contentSecurityPolicy\nto prevent scripts embedded in the image from executing.\ncontentDispositionType\nThe default loader sets the Content-Disposition\nheader to attachment\nfor added protection since the API can serve arbitrary remote images.\nThe default value is attachment\nwhich forces the browser to download the image when visiting directly. This is particularly important when dangerouslyAllowSVG\nis true.\nYou can optionally configure inline\nto allow the browser to render the image when visiting directly, without downloading it.\nmodule.exports = {\nimages: {\ncontentDispositionType: 'inline',\n},\n}\nAnimated Images\nThe default loader will automatically bypass Image Optimization for animated images and serve the image as-is.\nAuto-detection for animated files is best-effort and supports GIF, APNG, and WebP. If you want to explicitly bypass Image Optimization for a given animated image, use the unoptimized prop.\nResponsive Images\nThe default generated srcset\ncontains 1x\nand 2x\nimages in order to support different device pixel ratios. However, you may wish to render a responsive image that stretches with the viewport. In that case, you'll need to set sizes\nas well as style\n(or className\n).\nYou can render a responsive image using one of the following methods below.\nResponsive image using a static import\nIf the source image is not dynamic, you can statically import to create a responsive image:\nimport Image from 'next/image'\nimport me from '../photos/me.jpg'\nexport default function Author() {\nreturn (\n<Image\nsrc={me}\nalt=\"Picture of the author\"\nsizes=\"100vw\"\nstyle={{\nwidth: '100%',\nheight: 'auto',\n}}\n/>\n)\n}\nTry it out:\nResponsive image with aspect ratio\nIf the source image is a dynamic or a remote url, you will also need to provide width\nand height\nto set the correct aspect ratio of the responsive image:\nimport Image from 'next/image'\nexport default function Page({ photoUrl }) {\nreturn (\n<Image\nsrc={photoUrl}\nalt=\"Picture of the author\"\nsizes=\"100vw\"\nstyle={{\nwidth: '100%',\nheight: 'auto',\n}}\nwidth={500}\nheight={300}\n/>\n)\n}\nTry it out:\nResponsive image with fill\nIf you don't know the aspect ratio, you will need to set the fill\nprop and set position: relative\non the parent. Optionally, you can set object-fit\nstyle depending on the desired stretch vs crop behavior:\nimport Image from 'next/image'\nexport default function Page({ photoUrl }) {\nreturn (\n<div style={{ position: 'relative', width: '300px', height: '500px' }}>\n<Image\nsrc={photoUrl}\nalt=\"Picture of the author\"\nsizes=\"300px\"\nfill\nstyle={{\nobjectFit: 'contain',\n}}\n/>\n</div>\n)\n}\nTry it out:\nTheme Detection CSS\nIf you want to display a different image for light and dark mode, you can create a new component that wraps two <Image>\ncomponents and reveals the correct one based on a CSS media query.\n.imgDark {\ndisplay: none;\n}\n@media (prefers-color-scheme: dark) {\n.imgLight {\ndisplay: none;\n}\n.imgDark {\ndisplay: unset;\n}\n}\nimport styles from './theme-image.module.css'\nimport Image, { ImageProps } from 'next/image'\ntype Props = Omit<ImageProps, 'src' | 'priority' | 'loading'> & {\nsrcLight: string\nsrcDark: string\n}\nconst ThemeImage = (props: Props) => {\nconst { srcLight, srcDark, ...rest } = props\nreturn (\n<>\n<Image {...rest} src={srcLight} className={styles.imgLight} />\n<Image {...rest} src={srcDark} className={styles.imgDark} />\n</>\n)\n}\nGood to know: The default behavior of\nloading=\"lazy\"\nensures that only the correct image is loaded. You cannot usepriority\norloading=\"eager\"\nbecause that would cause both images to load. Instead, you can usefetchPriority=\"high\"\n.\nTry it out:\ngetImageProps\nFor more advanced use cases, you can call getImageProps()\nto get the props that would be passed to the underlying <img>\nelement, and instead pass to them to another component, style, canvas, etc.\nThis also avoid calling React useState()\nso it can lead to better performance, but it cannot be used with the placeholder\nprop because the placeholder will never be removed.\nTheme Detection Picture\nIf you want to display a different image for light and dark mode, you can use the <picture>\nelement to display a different image based on the user's preferred color scheme.\nimport { getImageProps } from 'next/image'\nexport default function Page() {\nconst common = { alt: 'Theme Example', width: 800, height: 400 }\nconst {\nprops: { srcSet: dark },\n} = getImageProps({ ...common, src: '/dark.png' })\nconst {\nprops: { srcSet: light, ...rest },\n} = getImageProps({ ...common, src: '/light.png' })\nreturn (\n<picture>\n<source media=\"(prefers-color-scheme: dark)\" srcSet={dark} />\n<source media=\"(prefers-color-scheme: light)\" srcSet={light} />\n<img {...rest} />\n</picture>\n)\n}\nArt Direction\nIf you want to display a different image for mobile and desktop, sometimes called Art Direction, you can provide different src\n, width\n, height\n, and quality\nprops to getImageProps()\n.\nimport { getImageProps } from 'next/image'\nexport default function Home() {\nconst common = { alt: 'Art Direction Example', sizes: '100vw' }\nconst {\nprops: { srcSet: desktop },\n} = getImageProps({\n...common,\nwidth: 1440,\nheight: 875,\nquality: 80,\nsrc: '/desktop.jpg',\n})\nconst {\nprops: { srcSet: mobile, ...rest },\n} = getImageProps({\n...common,\nwidth: 750,\nheight: 1334,\nquality: 70,\nsrc: '/mobile.jpg',\n})\nreturn (\n<picture>\n<source media=\"(min-width: 1000px)\" srcSet={desktop} />\n<source media=\"(min-width: 500px)\" srcSet={mobile} />\n<img {...rest} style={{ width: '100%', height: 'auto' }} />\n</picture>\n)\n}\nBackground CSS\nYou can even convert the srcSet\nstring to the image-set()\nCSS function to optimize a background image.\nimport { getImageProps } from 'next/image'\nfunction getBackgroundImage(srcSet = '') {\nconst imageSet = srcSet\n.split(', ')\n.map((str) => {\nconst [url, dpi] = str.split(' ')\nreturn `url(\"${url}\") ${dpi}`\n})\n.join(', ')\nreturn `image-set(${imageSet})`\n}\nexport default function Home() {\nconst {\nprops: { srcSet },\n} = getImageProps({ alt: '', width: 128, height: 128, src: '/img.png' })\nconst backgroundImage = getBackgroundImage(srcSet)\nconst style = { height: '100vh', width: '100vw', backgroundImage }\nreturn (\n<main style={style}>\n<h1>Hello World</h1>\n</main>\n)\n}\nKnown Browser Bugs\nThis next/image\ncomponent uses browser native lazy loading, which may fallback to eager loading for older browsers before Safari 15.4. When using the blur-up placeholder, older browsers before Safari 12 will fallback to empty placeholder. When using styles with width\n/height\nof auto\n, it is possible to cause Layout Shift on older browsers before Safari 15 that don't preserve the aspect ratio. For more details, see this MDN video.\n- Safari 15 - 16.3 display a gray border while loading. Safari 16.4 fixed this issue. Possible solutions:\n- Use CSS\n@supports (font: -apple-system-body) and (-webkit-appearance: none) { img[loading=\"lazy\"] { clip-path: inset(0.6px) } }\n- Use\npriority\nif the image is above the fold\n- Use CSS\n- Firefox 67+ displays a white background while loading. Possible solutions:\n- Enable AVIF\nformats\n- Use\nplaceholder\n- Enable AVIF\nVersion History\n| Version | Changes |\n|---|---|\nv15.0.0 | contentDispositionType configuration default changed to attachment . |\nv14.2.23 | qualities configuration added. |\nv14.2.15 | decoding prop added and localPatterns configuration added. |\nv14.2.14 | remotePatterns.search prop added. |\nv14.2.0 | overrideSrc prop added. |\nv14.1.0 | getImageProps() is stable. |\nv14.0.0 | onLoadingComplete prop and domains config deprecated. |\nv13.4.14 | placeholder prop support for data:/image... |\nv13.2.0 | contentDispositionType configuration added. |\nv13.0.6 | ref prop added. |\nv13.0.0 | The next/image import was renamed to next/legacy/image . The next/future/image import was renamed to next/image . A codemod is available to safely and automatically rename your imports. <span> wrapper removed. layout , objectFit , objectPosition , lazyBoundary , lazyRoot props removed. alt is required. onLoadingComplete receives reference to img element. Built-in loader config removed. |\nv12.3.0 | remotePatterns and unoptimized configuration is stable. |\nv12.2.0 | Experimental remotePatterns and experimental unoptimized configuration added. layout=\"raw\" removed. |\nv12.1.1 | style prop added. Experimental support for layout=\"raw\" added. |\nv12.1.0 | dangerouslyAllowSVG and contentSecurityPolicy configuration added. |\nv12.0.9 | lazyRoot prop added. |\nv12.0.0 | formats configuration added.AVIF support added. Wrapper <div> changed to <span> . |\nv11.1.0 | onLoadingComplete and lazyBoundary props added. |\nv11.0.0 | src prop support for static import.placeholder prop added.blurDataURL prop added. |\nv10.0.5 | loader prop added. |\nv10.0.1 | layout prop added. |\nv10.0.0 | next/image introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/components/link", "title": "Components: <Link> | Next.js", "text": "<Link>\n<Link>\nis a React component that extends the HTML <a>\nelement to provide prefetching and client-side navigation between routes. It is the primary way to navigate between routes in Next.js.\nBasic usage:\nimport Link from 'next/link'\nexport default function Page() {\nreturn <Link href=\"/dashboard\">Dashboard</Link>\n}\nReference\nThe following props can be passed to the <Link>\ncomponent:\n| Prop | Example | Type | Required |\n|---|---|---|---|\nhref | href=\"/dashboard\" | String or Object | Yes |\nreplace | replace={false} | Boolean | - |\nscroll | scroll={false} | Boolean | - |\nprefetch | prefetch={false} | Boolean or null | - |\nGood to know:\n<a>\ntag attributes such asclassName\nortarget=\"_blank\"\ncan be added to<Link>\nas props and will be passed to the underlying<a>\nelement.\nhref\n(required)\nThe path or URL to navigate to.\nimport Link from 'next/link'\n// Navigate to /about?name=test\nexport default function Page() {\nreturn (\n<Link\nhref={{\npathname: '/about',\nquery: { name: 'test' },\n}}\n>\nAbout\n</Link>\n)\n}\nreplace\nDefaults to false\n. When true\n, next/link\nwill replace the current history state instead of adding a new URL into the browser's history stack.\nimport Link from 'next/link'\nexport default function Page() {\nreturn (\n<Link href=\"/dashboard\" replace>\nDashboard\n</Link>\n)\n}\nscroll\nDefaults to true\n. The default scrolling behavior of <Link>\nin Next.js is to maintain scroll position, similar to how browsers handle back and forwards navigation. When you navigate to a new Page, scroll position will stay the same as long as the Page is visible in the viewport. However, if the Page is not visible in the viewport, Next.js will scroll to the top of the first Page element.\nWhen scroll = {false}\n, Next.js will not attempt to scroll to the first Page element.\nGood to know: Next.js checks if\nscroll: false\nbefore managing scroll behavior. If scrolling is enabled, it identifies the relevant DOM node for navigation and inspects each top-level element. All non-scrollable elements and those without rendered HTML are bypassed, this includes sticky or fixed positioned elements, and non-visible elements such as those calculated withgetBoundingClientRect\n. Next.js then continues through siblings until it identifies a scrollable element that is visible in the viewport.\nimport Link from 'next/link'\nexport default function Page() {\nreturn (\n<Link href=\"/dashboard\" scroll={false}>\nDashboard\n</Link>\n)\n}\nprefetch\nPrefetching happens when a <Link />\ncomponent enters the user's viewport (initially or through scroll). Next.js prefetches and loads the linked route (denoted by the href\n) and its data in the background to improve the performance of client-side navigations. If the prefetched data has expired by the time the user hovers over a <Link />\n, Next.js will attempt to prefetch it again. Prefetching is only enabled in production.\nThe following values can be passed to the prefetch\nprop:\nnull\n(default): Prefetch behavior depends on whether the route is static or dynamic. For static routes, the full route will be prefetched (including all its data). For dynamic routes, the partial route down to the nearest segment with aloading.js\nboundary will be prefetched.true\n: The full route will be prefetched for both static and dynamic routes.false\n: Prefetching will never happen both on entering the viewport and on hover.\nimport Link from 'next/link'\nexport default function Page() {\nreturn (\n<Link href=\"/dashboard\" prefetch={false}>\nDashboard\n</Link>\n)\n}\nExamples\nThe following examples demonstrate how to use the <Link>\ncomponent in different scenarios.\nLinking to dynamic segments\nWhen linking to dynamic segments, you can use template literals and interpolation to generate a list of links. For example, to generate a list of blog posts:\nimport Link from 'next/link'\ninterface Post {\nid: number\ntitle: string\nslug: string\n}\nexport default function PostList({ posts }: { posts: Post[] }) {\nreturn (\n<ul>\n{posts.map((post) => (\n<li key={post.id}>\n<Link href={`/blog/${post.slug}`}>{post.title}</Link>\n</li>\n))}\n</ul>\n)\n}\nChecking active links\nYou can use usePathname()\nto determine if a link is active. For example, to add a class to the active link, you can check if the current pathname\nmatches the href\nof the link:\n'use client'\nimport { usePathname } from 'next/navigation'\nimport Link from 'next/link'\nexport function Links() {\nconst pathname = usePathname()\nreturn (\n<nav>\n<Link className={`link ${pathname === '/' ? 'active' : ''}`} href=\"/\">\nHome\n</Link>\n<Link\nclassName={`link ${pathname === '/about' ? 'active' : ''}`}\nhref=\"/about\"\n>\nAbout\n</Link>\n</nav>\n)\n}\nScrolling to an id\nIf you'd like to scroll to a specific id\non navigation, you can append your URL with a #\nhash link or just pass a hash link to the href\nprop. This is possible since <Link>\nrenders to an <a>\nelement.\n<Link href=\"/dashboard#settings\">Settings</Link>\n// Output\n<a href=\"/dashboard#settings\">Settings</a>\nGood to know:\n- Next.js will scroll to the Page if it is not visible in the viewport upon navigation.\nLinking to dynamic route segments\nFor dynamic route segments, it can be handy to use template literals to create the link's path.\nFor example, you can generate a list of links to the dynamic route app/blog/[slug]/page.js\n:\nimport Link from 'next/link'\nexport default function Page({ posts }) {\nreturn (\n<ul>\n{posts.map((post) => (\n<li key={post.id}>\n<Link href={`/blog/${post.slug}`}>{post.title}</Link>\n</li>\n))}\n</ul>\n)\n}\nIf the child is a custom component that wraps an <a>\ntag\nIf the child of Link\nis a custom component that wraps an <a>\ntag, you must add passHref\nto Link\n. This is necessary if you\u2019re using libraries like styled-components. Without this, the <a>\ntag will not have the href\nattribute, which hurts your site's accessibility and might affect SEO. If you're using ESLint, there is a built-in rule next/link-passhref\nto ensure correct usage of passHref\n.\nimport Link from 'next/link'\nimport styled from 'styled-components'\n// This creates a custom component that wraps an <a> tag\nconst RedLink = styled.a`\ncolor: red;\n`\nfunction NavLink({ href, name }) {\nreturn (\n<Link href={href} passHref legacyBehavior>\n<RedLink>{name}</RedLink>\n</Link>\n)\n}\nexport default NavLink\n- If you\u2019re using emotion\u2019s JSX pragma feature (\n@jsx jsx\n), you must usepassHref\neven if you use an<a>\ntag directly. - The component should support\nonClick\nproperty to trigger navigation correctly.\nNesting a functional component\nIf the child of Link\nis a functional component, in addition to using passHref\nand legacyBehavior\n, you must wrap the component in React.forwardRef\n:\nimport Link from 'next/link'\nimport React from 'react'\n// Define the props type for MyButton\ninterface MyButtonProps {\nonClick?: React.MouseEventHandler<HTMLAnchorElement>\nhref?: string\n}\n// Use React.ForwardRefRenderFunction to properly type the forwarded ref\nconst MyButton: React.ForwardRefRenderFunction<\nHTMLAnchorElement,\nMyButtonProps\n> = ({ onClick, href }, ref) => {\nreturn (\n<a href={href} onClick={onClick} ref={ref}>\nClick Me\n</a>\n)\n}\n// Use React.forwardRef to wrap the component\nconst ForwardedMyButton = React.forwardRef(MyButton)\nexport default function Page() {\nreturn (\n<Link href=\"/about\" passHref legacyBehavior>\n<ForwardedMyButton />\n</Link>\n)\n}\nReplace the URL instead of push\nThe default behavior of the Link\ncomponent is to push\na new URL into the history\nstack. You can use the replace\nprop to prevent adding a new entry, as in the following example:\nimport Link from 'next/link'\nexport default function Page() {\nreturn (\n<Link href=\"/about\" replace>\nAbout us\n</Link>\n)\n}\nDisable scrolling to the top of the page\nThe default scrolling behavior of <Link>\nin Next.js is to maintain scroll position, similar to how browsers handle back and forwards navigation. When you navigate to a new Page, scroll position will stay the same as long as the Page is visible in the viewport.\nHowever, if the Page is not visible in the viewport, Next.js will scroll to the top of the first Page element. If you'd like to disable this behavior, you can pass scroll={false}\nto the <Link>\ncomponent, or scroll: false\nto router.push()\nor router.replace()\n.\nimport Link from 'next/link'\nexport default function Page() {\nreturn (\n<Link href=\"/#hashid\" scroll={false}>\nDisables scrolling to the top\n</Link>\n)\n}\nUsing router.push()\nor router.replace()\n:\n// useRouter\nimport { useRouter } from 'next/navigation'\nconst router = useRouter()\nrouter.push('/dashboard', { scroll: false })\nPrefetching links in Middleware\nIt's common to use Middleware for authentication or other purposes that involve rewriting the user to a different page. In order for the <Link />\ncomponent to properly prefetch links with rewrites via Middleware, you need to tell Next.js both the URL to display and the URL to prefetch. This is required to avoid un-necessary fetches to middleware to know the correct route to prefetch.\nFor example, if you want to serve a /dashboard\nroute that has authenticated and visitor views, you can add the following in your Middleware to redirect the user to the correct page:\nimport { NextResponse } from 'next/server'\nexport function middleware(request: Request) {\nconst nextUrl = request.nextUrl\nif (nextUrl.pathname === '/dashboard') {\nif (request.cookies.authToken) {\nreturn NextResponse.rewrite(new URL('/auth/dashboard', request.url))\n} else {\nreturn NextResponse.rewrite(new URL('/public/dashboard', request.url))\n}\n}\n}\nIn this case, you would want to use the following code in your <Link />\ncomponent:\n'use client'\nimport Link from 'next/link'\nimport useIsAuthed from './hooks/useIsAuthed' // Your auth hook\nexport default function Page() {\nconst isAuthed = useIsAuthed()\nconst path = isAuthed ? '/auth/dashboard' : '/public/dashboard'\nreturn (\n<Link as=\"/dashboard\" href={path}>\nDashboard\n</Link>\n)\n}\nVersion history\n| Version | Changes |\n|---|---|\nv13.0.0 | No longer requires a child <a> tag. A codemod is provided to automatically update your codebase. |\nv10.0.0 | href props pointing to a dynamic route are automatically resolved and no longer require an as prop. |\nv8.0.0 | Improved prefetching performance. |\nv1.0.0 | next/link introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/components/script", "title": "Components: <Script> | Next.js", "text": "<Script>\nThis API reference will help you understand how to use props available for the Script Component. For features and usage, please see the Optimizing Scripts page.\nimport Script from 'next/script'\nexport default function Dashboard() {\nreturn (\n<>\n<Script src=\"https://example.com/script.js\" />\n</>\n)\n}\nProps\nHere's a summary of the props available for the Script Component:\n| Prop | Example | Type | Required |\n|---|---|---|---|\nsrc | src=\"http://example.com/script\" | String | Required unless inline script is used |\nstrategy | strategy=\"lazyOnload\" | String | - |\nonLoad | onLoad={onLoadFunc} | Function | - |\nonReady | onReady={onReadyFunc} | Function | - |\nonError | onError={onErrorFunc} | Function | - |\nRequired Props\nThe <Script />\ncomponent requires the following properties.\nsrc\nA path string specifying the URL of an external script. This can be either an absolute external URL or an internal path. The src\nproperty is required unless an inline script is used.\nOptional Props\nThe <Script />\ncomponent accepts a number of additional properties beyond those which are required.\nstrategy\nThe loading strategy of the script. There are four different strategies that can be used:\nbeforeInteractive\n: Load before any Next.js code and before any page hydration occurs.afterInteractive\n: (default) Load early but after some hydration on the page occurs.lazyOnload\n: Load during browser idle time.worker\n: (experimental) Load in a web worker.\nbeforeInteractive\nScripts that load with the beforeInteractive\nstrategy are injected into the initial HTML from the server, downloaded before any Next.js module, and executed in the order they are placed before any hydration occurs on the page.\nScripts denoted with this strategy are preloaded and fetched before any first-party code, but their execution does not block page hydration from occurring.\nbeforeInteractive\nscripts must be placed inside the root layout (app/layout.tsx\n) and are designed to load scripts that are needed by the entire site (i.e. the script will load when any page in the application has been loaded server-side).\nThis strategy should only be used for critical scripts that need to be fetched before any part of the page becomes interactive.\nimport Script from 'next/script'\nexport default function RootLayout({\nchildren,\n}: {\nchildren: React.ReactNode\n}) {\nreturn (\n<html lang=\"en\">\n<body>\n{children}\n<Script\nsrc=\"https://example.com/script.js\"\nstrategy=\"beforeInteractive\"\n/>\n</body>\n</html>\n)\n}\nGood to know: Scripts with\nbeforeInteractive\nwill always be injected inside thehead\nof the HTML document regardless of where it's placed in the component.\nSome examples of scripts that should be loaded as soon as possible with beforeInteractive\ninclude:\n- Bot detectors\n- Cookie consent managers\nafterInteractive\nScripts that use the afterInteractive\nstrategy are injected into the HTML client-side and will load after some (or all) hydration occurs on the page. This is the default strategy of the Script component and should be used for any script that needs to load as soon as possible but not before any first-party Next.js code.\nafterInteractive\nscripts can be placed inside of any page or layout and will only load and execute when that page (or group of pages) is opened in the browser.\nimport Script from 'next/script'\nexport default function Page() {\nreturn (\n<>\n<Script src=\"https://example.com/script.js\" strategy=\"afterInteractive\" />\n</>\n)\n}\nSome examples of scripts that are good candidates for afterInteractive\ninclude:\n- Tag managers\n- Analytics\nlazyOnload\nScripts that use the lazyOnload\nstrategy are injected into the HTML client-side during browser idle time and will load after all resources on the page have been fetched. This strategy should be used for any background or low priority scripts that do not need to load early.\nlazyOnload\nscripts can be placed inside of any page or layout and will only load and execute when that page (or group of pages) is opened in the browser.\nimport Script from 'next/script'\nexport default function Page() {\nreturn (\n<>\n<Script src=\"https://example.com/script.js\" strategy=\"lazyOnload\" />\n</>\n)\n}\nExamples of scripts that do not need to load immediately and can be fetched with lazyOnload\ninclude:\n- Chat support plugins\n- Social media widgets\nworker\nWarning: The\nworker\nstrategy is not yet stable and does not yet work with the App Router. Use with caution.\nScripts that use the worker\nstrategy are off-loaded to a web worker in order to free up the main thread and ensure that only critical, first-party resources are processed on it. While this strategy can be used for any script, it is an advanced use case that is not guaranteed to support all third-party scripts.\nTo use worker\nas a strategy, the nextScriptWorkers\nflag must be enabled in next.config.js\n:\nmodule.exports = {\nexperimental: {\nnextScriptWorkers: true,\n},\n}\nworker\nscripts can only currently be used in the pages/\ndirectory:\nimport Script from 'next/script'\nexport default function Home() {\nreturn (\n<>\n<Script src=\"https://example.com/script.js\" strategy=\"worker\" />\n</>\n)\n}\nonLoad\nWarning:\nonLoad\ndoes not yet work with Server Components and can only be used in Client Components. Further,onLoad\ncan't be used withbeforeInteractive\n\u2013 consider usingonReady\ninstead.\nSome third-party scripts require users to run JavaScript code once after the script has finished loading in order to instantiate content or call a function. If you are loading a script with either afterInteractive\nor lazyOnload\nas a loading strategy, you can execute code after it has loaded using the onLoad\nproperty.\nHere's an example of executing a lodash method only after the library has been loaded.\n'use client'\nimport Script from 'next/script'\nexport default function Page() {\nreturn (\n<>\n<Script\nsrc=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js\"\nonLoad={() => {\nconsole.log(_.sample([1, 2, 3, 4]))\n}}\n/>\n</>\n)\n}\nonReady\nWarning:\nonReady\ndoes not yet work with Server Components and can only be used in Client Components.\nSome third-party scripts require users to run JavaScript code after the script has finished loading and every time the component is mounted (after a route navigation for example). You can execute code after the script's load event when it first loads and then after every subsequent component re-mount using the onReady\nproperty.\nHere's an example of how to re-instantiate a Google Maps JS embed every time the component is mounted:\n'use client'\nimport { useRef } from 'react'\nimport Script from 'next/script'\nexport default function Page() {\nconst mapRef = useRef()\nreturn (\n<>\n<div ref={mapRef}></div>\n<Script\nid=\"google-maps\"\nsrc=\"https://maps.googleapis.com/maps/api/js\"\nonReady={() => {\nnew google.maps.Map(mapRef.current, {\ncenter: { lat: -34.397, lng: 150.644 },\nzoom: 8,\n})\n}}\n/>\n</>\n)\n}\nonError\nWarning:\nonError\ndoes not yet work with Server Components and can only be used in Client Components.onError\ncannot be used with thebeforeInteractive\nloading strategy.\nSometimes it is helpful to catch when a script fails to load. These errors can be handled with the onError\nproperty:\n'use client'\nimport Script from 'next/script'\nexport default function Page() {\nreturn (\n<>\n<Script\nsrc=\"https://example.com/script.js\"\nonError={(e: Error) => {\nconsole.error('Script failed to load', e)\n}}\n/>\n</>\n)\n}\nVersion History\n| Version | Changes |\n|---|---|\nv13.0.0 | beforeInteractive and afterInteractive is modified to support app . |\nv12.2.4 | onReady prop added. |\nv12.2.2 | Allow next/script with beforeInteractive to be placed in _document . |\nv11.0.0 | next/script introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/directives", "title": "API Reference: Directives | Next.js", "text": "Directives\nThe following directives are available:\nuse cache\nLearn how to use the use cache directive to cache data in your Next.js application.\nuse client\nLearn how to use the use client directive to render a component on the client.\nuse server\nLearn how to use the use server directive to execute code on the server.\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/directives/use-cache", "title": "Directives: use cache | Next.js", "text": "use cache\nThe use cache\ndirective designates a component and/or a function to be cached. It can be used at the top of a file to indicate that all exports in the file are cacheable, or inline at the top of a function or component to inform Next.js the return value should be cached and reused for subsequent requests. This is an experimental Next.js feature, and not a native React feature like use client\nor use server\n.\nUsage\nEnable support for the use cache\ndirective with the dynamicIO\nflag in your next.config.ts\nfile:\nimport type { NextConfig } from 'next'\nconst nextConfig: NextConfig = {\nexperimental: {\ndynamicIO: true,\n},\n}\nexport default nextConfig\nThen, you can use the use cache\ndirective at the file, component, or function level:\n// File level\n'use cache'\nexport default async function Page() {\n// ...\n}\n// Component level\nexport async function MyComponent() {\n'use cache'\nreturn <></>\n}\n// Function level\nexport async function getData() {\n'use cache'\nconst data = await fetch('/api/data')\nreturn data\n}\nGood to know\nuse cache\nis an experimental Next.js feature, and not a native React feature likeuse client\noruse server\n.- Any serializable arguments (or props) passed to the cached function, as well as any serializable values it reads from the parent scope, will be converted to a format like JSON and automatically become a part of the cache key.\n- Any non-serializable arguments, props, or closed-over values will turn into opaque references inside the cached function, and can be only passed through and not inspected nor modified. These non-serializable values will be filled in at the request time and won't become a part of the cache key.\n- For example, a cached function can take in JSX as a\nchildren\nprop and return<div>{children}</div>\n, but it won't be able to introspect the actualchildren\nobject.\n- For example, a cached function can take in JSX as a\n- The return value of the cacheable function must also be serializable. This ensures that the cached data can be stored and retrieved correctly.\n- Functions that use the\nuse cache\ndirective must not have any side-effects, such as modifying state, directly manipulating the DOM, or setting timers to execute code at intervals. - If used alongside Partial Prerendering, segments that have\nuse cache\nwill be prerendered as part of the static HTML shell. - The\nuse cache\ndirective will be available separately from thedynamicIO\nflag in the future. - Unlike\nunstable_cache\nwhich only supports JSON data,use cache\ncan cache any serializable data React can render, including the render output of components.\nExamples\nCaching entire routes with use cache\nTo prerender an entire route, add use cache\nto the top both the layout\nand page\nfiles. Each of these segments are treated as separate entry points in your application, and will be cached independently.\n'use cache'\nimport { unstable_cacheLife as cacheLife } from 'next/cache'\nexport default function Layout({ children }: { children: ReactNode }) {\nreturn <div>{children}</div>\n}\nAny components imported and nested in page\nfile will inherit the cache behavior of page\n.\n'use cache'\nimport { unstable_cacheLife as cacheLife } from 'next/cache'\nasync function Users() {\nconst users = await fetch('/api/users')\n// loop through users\n}\nexport default function Page() {\nreturn (\n<main>\n<Users />\n</main>\n)\n}\nThis is recommended for applications that previously used the\nexport const dynamic = \"force-static\"\noption, and will ensure the entire route is prerendered.\nCaching component output with use cache\nYou can use use cache\nat the component level to cache any fetches or computations performed within that component. When you reuse the component throughout your application it can share the same cache entry as long as the props maintain the same structure.\nThe props are serialized and form part of the cache key, and the cache entry will be reused as long as the serialized props produce the same value in each instance.\nexport async function Bookings({ type = 'haircut' }: BookingsProps) {\n'use cache'\nasync function getBookingsData() {\nconst data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)\nreturn data\n}\nreturn //...\n}\ninterface BookingsProps {\ntype: string\n}\nCaching function output with use cache\nSince you can add use cache\nto any asynchronous function, you aren't limited to caching components or routes only. You might want to cache a network request or database query or compute something that is very slow. By adding use cache\nto a function containing this type of work it becomes cacheable, and when reused, will share the same cache entry.\nexport async function getData() {\n'use cache'\nconst data = await fetch('/api/data')\nreturn data\n}\nRevalidating\nBy default, Next.js sets a revalidation period of 15 minutes when you use the use cache\ndirective. Next.js sets a near-infinite expiration duration, meaning it's suitable for content that doesn't need frequent updates.\nWhile this revalidation period may be useful for content you don't expect to change often, you can use the cacheLife\nand cacheTag\nAPIs to configure the cache behavior:\nBoth of these APIs integrate across the client and server caching layers, meaning you can configure your caching semantics in one place and have them apply everywhere.\nSee the cacheLife\nand cacheTag\ndocs for more information.\nInterleaving\nIf you need to pass non-serializable arguments to a cacheable function, you can pass them as children\n. This means the children\nreference can change without affecting the cache entry.\nexport default async function Page() {\nconst uncachedData = await getData()\nreturn (\n<CacheComponent>\n<DynamicComponent data={uncachedData} />\n</CacheComponent>\n)\n}\nasync function CacheComponent({ children }: { children: ReactNode }) {\n'use cache'\nconst cachedData = await fetch('/api/cached-data')\nreturn (\n<div>\n<PrerenderedComponent data={cachedData} />\n{children}\n</div>\n)\n}\nYou can also pass Server Actions through cached components to Client Components without invoking them inside the cacheable function.\nimport ClientComponent from './ClientComponent'\nexport default async function Page() {\nconst performUpdate = async () => {\n'use server'\n// Perform some server-side update\nawait db.update(...)\n}\nreturn <CacheComponent performUpdate={performUpdate} />\n}\nasync function CachedComponent({\nperformUpdate,\n}: {\nperformUpdate: () => Promise<void>\n}) {\n'use cache'\n// Do not call performUpdate here\nreturn <ClientComponent action={performUpdate} />\n}\n'use client'\nexport default function ClientComponent({\naction,\n}: {\naction: () => Promise<void>\n}) {\nreturn <button onClick={action}>Update</button>\n}\nRelated\ndynamicIO\ncacheLife\ncacheTag\ncacheLife\nrevalidateTag\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/directives/use-client", "title": "Directives: use client | Next.js", "text": "use client\nThe use client\ndirective designates a component to be rendered on the client side and should be used when creating interactive user interfaces (UI) that require client-side JavaScript capabilities, such as state management, event handling, and access to browser APIs. This is a React feature.\nUsage\nTo designate a component as a Client Component, add the use client\ndirective at the top of the file, before any imports:\napp/components/counter.tsx\n'use client'\nimport { useState } from 'react'\nexport default function Counter() {\nconst [count, setCount] = useState(0)\nreturn (\n<div>\n<p>Count: {count}</p>\n<button onClick={() => setCount(count + 1)}>Increment</button>\n</div>\n)\n}\nNesting Client Components within Server Components\nCombining Server and Client Components allows you to build applications that are both performant and interactive:\n- Server Components: Use for static content, data fetching, and SEO-friendly elements.\n- Client Components: Use for interactive elements that require state, effects, or browser APIs.\n- Component composition: Nest Client Components within Server Components as needed for a clear separation of server and client logic.\nIn the following example:\nHeader\nis a Server Component handling static content.Counter\nis a Client Component enabling interactivity within the page.\napp/page.tsx\nimport Header from './header'\nimport Counter from './counter' // This is a Client Component\nexport default function Page() {\nreturn (\n<div>\n<Header />\n<Counter />\n</div>\n)\n}\nReference\nSee the React documentation for more information on use client\n.\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/directives/use-server", "title": "Directives: use server | Next.js", "text": "use server\nThe use server\ndirective designates a function or file to be executed on the server side. It can be used at the top of a file to indicate that all functions in the file are server-side, or inline at the top of a function to mark the function as a Server Function. This is a React feature.\nUsing use server\nat the top of a file\nThe following example shows a file with a use server\ndirective at the top. All functions in the file are executed on the server.\n'use server'\nimport { db } from '@/lib/db' // Your database client\nexport async function createUser(data: { name: string; email: string }) {\nconst user = await db.user.create({ data })\nreturn user\n}\nUsing Server Functions in a Client Component\nTo use Server Functions in Client Components you need to create your Server Functions in a dedicated file using the use server\ndirective at the top of the file. These Server Functions can then be imported into Client and Server Components and executed.\nAssuming you have a fetchUsers\nServer Function in actions.ts\n:\n'use server'\nimport { db } from '@/lib/db' // Your database client\nexport async function fetchUsers() {\nconst users = await db.user.findMany()\nreturn users\n}\nThen you can import the fetchUsers\nServer Function into a Client Component and execute it on the client-side.\n'use client'\nimport { fetchUsers } from '../actions'\nexport default function MyButton() {\nreturn <button onClick={() => fetchUsers()}>Fetch Users</button>\n}\nUsing use server\ninline\nIn the following example, use server\nis used inline at the top of a function to mark it as a Server Function:\nimport { db } from '@/lib/db' // Your database client\nexport default function UserList() {\nasync function fetchUsers() {\n'use server'\nconst users = await db.user.findMany()\nreturn users\n}\nreturn <button onClick={() => fetchUsers()}>Fetch Users</button>\n}\nSecurity considerations\nWhen using the use server\ndirective, it's important to ensure that all server-side logic is secure and that sensitive data remains protected.\nAuthentication and authorization\nAlways authenticate and authorize users before performing sensitive server-side operations.\n'use server'\nimport { db } from '@/lib/db' // Your database client\nimport { authenticate } from '@/lib/auth' // Your authentication library\nexport async function createUser(\ndata: { name: string; email: string },\ntoken: string\n) {\nconst user = authenticate(token)\nif (!user) {\nthrow new Error('Unauthorized')\n}\nconst newUser = await db.user.create({ data })\nreturn newUser\n}\nReference\nSee the React documentation for more information on use server\n.\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/edge", "title": "API Reference: Edge Runtime | Next.js", "text": "Edge Runtime\nThe Next.js Edge Runtime is used for Middleware and supports the following APIs:\nNetwork APIs\n| API | Description |\n|---|---|\nBlob | Represents a blob |\nfetch | Fetches a resource |\nFetchEvent | Represents a fetch event |\nFile | Represents a file |\nFormData | Represents form data |\nHeaders | Represents HTTP headers |\nRequest | Represents an HTTP request |\nResponse | Represents an HTTP response |\nURLSearchParams | Represents URL search parameters |\nWebSocket | Represents a websocket connection |\nEncoding APIs\n| API | Description |\n|---|---|\natob | Decodes a base-64 encoded string |\nbtoa | Encodes a string in base-64 |\nTextDecoder | Decodes a Uint8Array into a string |\nTextDecoderStream | Chainable decoder for streams |\nTextEncoder | Encodes a string into a Uint8Array |\nTextEncoderStream | Chainable encoder for streams |\nStream APIs\n| API | Description |\n|---|---|\nReadableStream | Represents a readable stream |\nReadableStreamBYOBReader | Represents a reader of a ReadableStream |\nReadableStreamDefaultReader | Represents a reader of a ReadableStream |\nTransformStream | Represents a transform stream |\nWritableStream | Represents a writable stream |\nWritableStreamDefaultWriter | Represents a writer of a WritableStream |\nCrypto APIs\n| API | Description |\n|---|---|\ncrypto | Provides access to the cryptographic functionality of the platform |\nCryptoKey | Represents a cryptographic key |\nSubtleCrypto | Provides access to common cryptographic primitives, like hashing, signing, encryption or decryption |\nWeb Standard APIs\n| API | Description |\n|---|---|\nAbortController | Allows you to abort one or more DOM requests as and when desired |\nArray | Represents an array of values |\nArrayBuffer | Represents a generic, fixed-length raw binary data buffer |\nAtomics | Provides atomic operations as static methods |\nBigInt | Represents a whole number with arbitrary precision |\nBigInt64Array | Represents a typed array of 64-bit signed integers |\nBigUint64Array | Represents a typed array of 64-bit unsigned integers |\nBoolean | Represents a logical entity and can have two values: true and false |\nclearInterval | Cancels a timed, repeating action which was previously established by a call to setInterval() |\nclearTimeout | Cancels a timed, repeating action which was previously established by a call to setTimeout() |\nconsole | Provides access to the browser's debugging console |\nDataView | Represents a generic view of an ArrayBuffer |\nDate | Represents a single moment in time in a platform-independent format |\ndecodeURI | Decodes a Uniform Resource Identifier (URI) previously created by encodeURI or by a similar routine |\ndecodeURIComponent | Decodes a Uniform Resource Identifier (URI) component previously created by encodeURIComponent or by a similar routine |\nDOMException | Represents an error that occurs in the DOM |\nencodeURI | Encodes a Uniform Resource Identifier (URI) by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character |\nencodeURIComponent | Encodes a Uniform Resource Identifier (URI) component by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character |\nError | Represents an error when trying to execute a statement or accessing a property |\nEvalError | Represents an error that occurs regarding the global function eval() |\nFloat32Array | Represents a typed array of 32-bit floating point numbers |\nFloat64Array | Represents a typed array of 64-bit floating point numbers |\nFunction | Represents a function |\nInfinity | Represents the mathematical Infinity value |\nInt8Array | Represents a typed array of 8-bit signed integers |\nInt16Array | Represents a typed array of 16-bit signed integers |\nInt32Array | Represents a typed array of 32-bit signed integers |\nIntl | Provides access to internationalization and localization functionality |\nisFinite | Determines whether a value is a finite number |\nisNaN | Determines whether a value is NaN or not |\nJSON | Provides functionality to convert JavaScript values to and from the JSON format |\nMap | Represents a collection of values, where each value may occur only once |\nMath | Provides access to mathematical functions and constants |\nNumber | Represents a numeric value |\nObject | Represents the object that is the base of all JavaScript objects |\nparseFloat | Parses a string argument and returns a floating point number |\nparseInt | Parses a string argument and returns an integer of the specified radix |\nPromise | Represents the eventual completion (or failure) of an asynchronous operation, and its resulting value |\nProxy | Represents an object that is used to define custom behavior for fundamental operations (e.g. property lookup, assignment, enumeration, function invocation, etc) |\nqueueMicrotask | Queues a microtask to be executed |\nRangeError | Represents an error when a value is not in the set or range of allowed values |\nReferenceError | Represents an error when a non-existent variable is referenced |\nReflect | Provides methods for interceptable JavaScript operations |\nRegExp | Represents a regular expression, allowing you to match combinations of characters |\nSet | Represents a collection of values, where each value may occur only once |\nsetInterval | Repeatedly calls a function, with a fixed time delay between each call |\nsetTimeout | Calls a function or evaluates an expression after a specified number of milliseconds |\nSharedArrayBuffer | Represents a generic, fixed-length raw binary data buffer |\nString | Represents a sequence of characters |\nstructuredClone | Creates a deep copy of a value |\nSymbol | Represents a unique and immutable data type that is used as the key of an object property |\nSyntaxError | Represents an error when trying to interpret syntactically invalid code |\nTypeError | Represents an error when a value is not of the expected type |\nUint8Array | Represents a typed array of 8-bit unsigned integers |\nUint8ClampedArray | Represents a typed array of 8-bit unsigned integers clamped to 0-255 |\nUint32Array | Represents a typed array of 32-bit unsigned integers |\nURIError | Represents an error when a global URI handling function was used in a wrong way |\nURL | Represents an object providing static methods used for creating object URLs |\nURLPattern | Represents a URL pattern |\nURLSearchParams | Represents a collection of key/value pairs |\nWeakMap | Represents a collection of key/value pairs in which the keys are weakly referenced |\nWeakSet | Represents a collection of objects in which each object may occur only once |\nWebAssembly | Provides access to WebAssembly |\nNext.js Specific Polyfills\nEnvironment Variables\nYou can use process.env\nto access Environment Variables for both next dev\nand next build\n.\nUnsupported APIs\nThe Edge Runtime has some restrictions including:\n- Native Node.js APIs are not supported. For example, you can't read or write to the filesystem.\nnode_modules\ncan be used, as long as they implement ES Modules and do not use native Node.js APIs.- Calling\nrequire\ndirectly is not allowed. Use ES Modules instead.\nThe following JavaScript language features are disabled, and will not work:\n| API | Description |\n|---|---|\neval | Evaluates JavaScript code represented as a string |\nnew Function(evalString) | Creates a new function with the code provided as an argument |\nWebAssembly.compile | Compiles a WebAssembly module from a buffer source |\nWebAssembly.instantiate | Compiles and instantiates a WebAssembly module from a buffer source |\nIn rare cases, your code could contain (or import) some dynamic code evaluation statements which can not be reached at runtime and which can not be removed by treeshaking. You can relax the check to allow specific files with your Middleware configuration:\nexport const config = {\nunstable_allowDynamic: [\n// allows a single file\n'/lib/utilities.js',\n// use a glob to allow anything in the function-bind 3rd party module\n'**/node_modules/function-bind/**',\n],\n}\nunstable_allowDynamic\nis a glob, or an array of globs, ignoring dynamic code evaluation for specific files. The globs are relative to your application root folder.\nBe warned that if these statements are executed on the Edge, they will throw and cause a runtime error.\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions", "title": "API Reference: File Conventions | Next.js", "text": "File Conventions\ndefault.js\nAPI Reference for the default.js file.\nerror.js\nAPI reference for the error.js special file.\nforbidden.js\nAPI reference for the forbidden.js special file.\ninstrumentation.js\nAPI reference for the instrumentation.js file.\nlayout.js\nAPI reference for the layout.js file.\nloading.js\nAPI reference for the loading.js file.\nmdx-components.js\nAPI reference for the mdx-components.js file.\nmiddleware.js\nAPI reference for the middleware.js file.\nnot-found.js\nAPI reference for the not-found.js file.\npage.js\nAPI reference for the page.js file.\nroute.js\nAPI reference for the route.js special file.\nRoute Segment Config\nLearn about how to configure options for Next.js route segments.\ntemplate.js\nAPI Reference for the template.js file.\nunauthorized.js\nAPI reference for the unauthorized.js special file.\nMetadata Files\nAPI documentation for the metadata file conventions.\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/default", "title": "File Conventions: default.js | Next.js", "text": "default.js\nThe default.js\nfile is used to render a fallback within Parallel Routes when Next.js cannot recover a slot's active state after a full-page load.\nDuring soft navigation, Next.js keeps track of the active state (subpage) for each slot. However, for hard navigations (full-page load), Next.js cannot recover the active state. In this case, a default.js\nfile can be rendered for subpages that don't match the current URL.\nConsider the following folder structure. The @team\nslot has a settings\npage, but @analytics\ndoes not.\nWhen navigating to /settings\n, the @team\nslot will render the settings\npage while maintaining the currently active page for the @analytics\nslot.\nOn refresh, Next.js will render a default.js\nfor @analytics\n. If default.js\ndoesn't exist, a 404\nis rendered instead.\nAdditionally, since children\nis an implicit slot, you also need to create a default.js\nfile to render a fallback for children\nwhen Next.js cannot recover the active state of the parent page.\nReference\nparams\n(optional)\nA promise that resolves to an object containing the dynamic route parameters from the root segment down to the slot's subpages. For example:\nexport default async function Default({\nparams,\n}: {\nparams: Promise<{ artist: string }>\n}) {\nconst artist = (await params).artist\n}\n| Example | URL | params |\n|---|---|---|\napp/[artist]/@sidebar/default.js | /zack | Promise<{ artist: 'zack' }> |\napp/[artist]/[album]/@sidebar/default.js | /zack/next | Promise<{ artist: 'zack', album: 'next' }> |\n- Since the\nparams\nprop is a promise. You must useasync/await\nor React'suse\nfunction to access the values.- In version 14 and earlier,\nparams\nwas a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.\n- In version 14 and earlier,\nLearn more about Parallel Routes\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/error", "title": "File Conventions: error.js | Next.js", "text": "error.js\nAn error file allows you to handle unexpected runtime errors and display fallback UI.\n'use client' // Error boundaries must be Client Components\nimport { useEffect } from 'react'\nexport default function Error({\nerror,\nreset,\n}: {\nerror: Error & { digest?: string }\nreset: () => void\n}) {\nuseEffect(() => {\n// Log the error to an error reporting service\nconsole.error(error)\n}, [error])\nreturn (\n<div>\n<h2>Something went wrong!</h2>\n<button\nonClick={\n// Attempt to recover by trying to re-render the segment\n() => reset()\n}\n>\nTry again\n</button>\n</div>\n)\n}\nHow error.js\nWorks\nerror.js\nwraps a route segment and its nested children in a React Error Boundary. When an error throws within the boundary, the error\ncomponent shows as the fallback UI.\nGood to know:\n- The React DevTools allow you to toggle error boundaries to test error states.\nProps\nerror\nAn instance of an Error\nobject forwarded to the error.js\nClient Component.\nGood to know: During development, the\nError\nobject forwarded to the client will be serialized and include themessage\nof the original error for easier debugging. However, this behavior is different in production to avoid leaking potentially sensitive details included in the error to the client.\nerror.message\n- Errors forwarded from Client Components show the original\nError\nmessage. - Errors forwarded from Server Components show a generic message with an identifier. This is to prevent leaking sensitive details. You can use the identifier, under\nerrors.digest\n, to match the corresponding server-side logs.\nerror.digest\nAn automatically generated hash of the error thrown. It can be used to match the corresponding error in server-side logs.\nreset\nThe cause of an error can sometimes be temporary. In these cases, trying again might resolve the issue.\nAn error component can use the reset()\nfunction to prompt the user to attempt to recover from the error. When executed, the function will try to re-render the error boundary's contents. If successful, the fallback error component is replaced with the result of the re-render.\n'use client' // Error boundaries must be Client Components\nexport default function Error({\nerror,\nreset,\n}: {\nerror: Error & { digest?: string }\nreset: () => void\n}) {\nreturn (\n<div>\n<h2>Something went wrong!</h2>\n<button onClick={() => reset()}>Try again</button>\n</div>\n)\n}\nglobal-error.js\nWhile less common, you can handle errors in the root layout or template using app/global-error.js\n, located in the root app directory, even when leveraging internationalization. Global error UI must define its own <html>\nand <body>\ntags. This file replaces the root layout or template when active.\n'use client' // Error boundaries must be Client Components\nexport default function GlobalError({\nerror,\nreset,\n}: {\nerror: Error & { digest?: string }\nreset: () => void\n}) {\nreturn (\n// global-error must include html and body tags\n<html>\n<body>\n<h2>Something went wrong!</h2>\n<button onClick={() => reset()}>Try again</button>\n</body>\n</html>\n)\n}\nGood to know:\nglobal-error.js\nis only enabled in production. In development, our error overlay will show instead.\nnot-found.js\nThe not-found\nfile shows UI when calling the notFound()\nfunction within a route segment.\nVersion History\n| Version | Changes |\n|---|---|\nv13.1.0 | global-error introduced. |\nv13.0.0 | error introduced. |\nLearn more about error handling\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/forbidden", "title": "File Conventions: forbidden.js | Next.js", "text": "forbidden.js\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\nThe forbidden file is used to render UI when the forbidden\nfunction is invoked during authentication. Along with allowing you to customize the UI, Next.js will return a 403\nstatus code.\napp/forbidden.tsx\nimport Link from 'next/link'\nexport default function Forbidden() {\nreturn (\n<div>\n<h2>Forbidden</h2>\n<p>You are not authorized to access this resource.</p>\n<Link href=\"/\">Return Home</Link>\n</div>\n)\n}\nReference\nProps\nforbidden.js\ncomponents do not accept any props.\nVersion History\n| Version | Changes |\n|---|---|\nv15.1.0 | forbidden.js introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/instrumentation", "title": "File Conventions: instrumentation.js | Next.js", "text": "instrumentation.js\nThe instrumentation.js|ts\nfile is used to integrate observability tools into your application, allowing you to track the performance and behavior, and to debug issues in production.\nTo use it, place the file in the root of your application or inside a src\nfolder if using one.\nExports\nregister\n(optional)\nThe file exports a register\nfunction that is called once when a new Next.js server instance is initiated. register\ncan be an async function.\nimport { registerOTel } from '@vercel/otel'\nexport function register() {\nregisterOTel('next-app')\n}\nonRequestError\n(optional)\nYou can optionally export an onRequestError\nfunction to track server errors to any custom observability provider.\n- If you're running any async tasks in\nonRequestError\n, make sure they're awaited.onRequestError\nwill be triggered when the Next.js server captures the error. - The\nerror\ninstance might not be the original error instance thrown, as it may be processed by React if encountered during Server Components rendering. If this happens, you can usedigest\nproperty on an error to identify the actual error type.\nimport { type Instrumentation } from 'next'\nexport const onRequestError: Instrumentation.onRequestError = async (\nerr,\nrequest,\ncontext\n) => {\nawait fetch('https://.../report-error', {\nmethod: 'POST',\nbody: JSON.stringify({\nmessage: err.message,\nrequest,\ncontext,\n}),\nheaders: {\n'Content-Type': 'application/json',\n},\n})\n}\nParameters\nThe function accepts three parameters: error\n, request\n, and context\n.\nexport function onRequestError(\nerror: { digest: string } & Error,\nrequest: {\npath: string // resource path, e.g. /blog?name=foo\nmethod: string // request method. e.g. GET, POST, etc\nheaders: { [key: string]: string }\n},\ncontext: {\nrouterKind: 'Pages Router' | 'App Router' // the router type\nroutePath: string // the route file path, e.g. /app/blog/[dynamic]\nrouteType: 'render' | 'route' | 'action' | 'middleware' // the context in which the error occurred\nrenderSource:\n| 'react-server-components'\n| 'react-server-components-payload'\n| 'server-rendering'\nrevalidateReason: 'on-demand' | 'stale' | undefined // undefined is a normal request without revalidation\nrenderType: 'dynamic' | 'dynamic-resume' // 'dynamic-resume' for PPR\n}\n): void | Promise<void>\nerror\n: The caught error itself (type is alwaysError\n), and adigest\nproperty which is the unique ID of the error.request\n: Read-only request information associated with the error.context\n: The context in which the error occurred. This can be the type of router (App or Pages Router), and/or (Server Components ('render'\n), Route Handlers ('route'\n), Server Actions ('action'\n), or Middleware ('middleware'\n)).\nSpecifying the runtime\nThe instrumentation.js\nfile works in both the Node.js and Edge runtime, however, you can use process.env.NEXT_RUNTIME\nto target a specific runtime.\nexport function register() {\nif (process.env.NEXT_RUNTIME === 'edge') {\nreturn require('./register.edge')\n} else {\nreturn require('./register.node')\n}\n}\nexport function onRequestError() {\nif (process.env.NEXT_RUNTIME === 'edge') {\nreturn require('./on-request-error.edge')\n} else {\nreturn require('./on-request-error.node')\n}\n}\nVersion History\n| Version | Changes |\n|---|---|\nv15.0.0-RC | onRequestError introduced, instrumentation stable |\nv14.0.4 | Turbopack support for instrumentation |\nv13.2.0 | instrumentation introduced as an experimental feature |\nLearn more about Instrumentation\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/layout", "title": "File Conventions: layout.js | Next.js", "text": "layout.js\nThe layout\nfile is used to define a layout in your Next.js application.\nexport default function DashboardLayout({\nchildren,\n}: {\nchildren: React.ReactNode\n}) {\nreturn <section>{children}</section>\n}\nA root layout is the top-most layout in the root app\ndirectory. It is used to define the <html>\nand <body>\ntags and other globally shared UI.\nexport default function RootLayout({\nchildren,\n}: {\nchildren: React.ReactNode\n}) {\nreturn (\n<html lang=\"en\">\n<body>{children}</body>\n</html>\n)\n}\nReference\nProps\nchildren\n(required)\nLayout components should accept and use a children\nprop. During rendering, children\nwill be populated with the route segments the layout is wrapping. These will primarily be the component of a child Layout (if it exists) or Page, but could also be other special files like Loading or Error when applicable.\nparams\n(optional)\nA promise that resolves to an object containing the dynamic route parameters object from the root segment down to that layout.\nexport default async function Layout({\nparams,\n}: {\nparams: Promise<{ team: string }>\n}) {\nconst team = (await params).team\n}\n| Example Route | URL | params |\n|---|---|---|\napp/dashboard/[team]/layout.js | /dashboard/1 | Promise<{ team: '1' }> |\napp/shop/[tag]/[item]/layout.js | /shop/1/2 | Promise<{ tag: '1', item: '2' }> |\napp/blog/[...slug]/layout.js | /blog/1/2 | Promise<{ slug: ['1', '2'] }> |\n- Since the\nparams\nprop is a promise. You must useasync/await\nor React'suse\nfunction to access the values.- In version 14 and earlier,\nparams\nwas a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.\n- In version 14 and earlier,\nRoot Layouts\nThe app\ndirectory must include a root app/layout.js\n.\nexport default function RootLayout({\nchildren,\n}: {\nchildren: React.ReactNode\n}) {\nreturn (\n<html>\n<body>{children}</body>\n</html>\n)\n}\n- The root layout must define\n<html>\nand<body>\ntags.- You should not manually add\n<head>\ntags such as<title>\nand<meta>\nto root layouts. Instead, you should use the Metadata API which automatically handles advanced requirements such as streaming and de-duplicating<head>\nelements.\n- You should not manually add\n- You can use route groups to create multiple root layouts.\n- Navigating across multiple root layouts will cause a full page load (as opposed to a client-side navigation). For example, navigating from\n/cart\nthat usesapp/(shop)/layout.js\nto/blog\nthat usesapp/(marketing)/layout.js\nwill cause a full page load. This only applies to multiple root layouts.\n- Navigating across multiple root layouts will cause a full page load (as opposed to a client-side navigation). For example, navigating from\nCaveats\nLayouts do not receive searchParams\nUnlike Pages, Layout components do not receive the searchParams\nprop. This is because a shared layout is not re-rendered during navigation which could lead to stale searchParams\nbetween navigations.\nWhen using client-side navigation, Next.js automatically only renders the part of the page below the common layout between two routes.\nFor example, in the following directory structure, dashboard/layout.tsx\nis the common layout for both /dashboard/settings\nand /dashboard/analytics\n:\nWhen navigating from /dashboard/settings\nto /dashboard/analytics\n, page.tsx\nin /dashboard/analytics\nwill rerender on the server, while dashboard/layout.tsx\nwill not rerender because it's a common UI shared between the two routes.\nThis performance optimization allows navigation between pages that share a layout to be quicker as only the data fetching and rendering for the page has to run, instead of the entire route that could include shared layouts that fetch their own data.\nBecause dashboard/layout.tsx\ndoesn't re-render, the searchParams\nprop in the layout Server Component might become stale after navigation.\nInstead, use the Page searchParams\nprop or the useSearchParams\nhook in a Client Component within the layout, which is rerendered on the client with the latest searchParams\n.\nLayouts cannot access pathname\nLayouts cannot access pathname\n. This is because layouts are Server Components by default, and don't rerender during client-side navigation, which could lead to pathname\nbecoming stale between navigations. To prevent staleness, Next.js would need to refetch all segments of a route, losing the benefits of caching and increasing the RSC payload size on navigation.\nInstead, you can extract the logic that depends on pathname into a Client Component and import it into your layouts. Since Client Components rerender (but are not refetched) during navigation, you can use Next.js hooks such as usePathname\nto access the current pathname and prevent staleness.\nimport { ClientComponent } from '@/app/ui/ClientComponent'\nexport default function Layout({ children }: { children: React.ReactNode }) {\nreturn (\n<>\n<ClientComponent />\n{/* Other Layout UI */}\n<main>{children}</main>\n</>\n)\n}\nCommon pathname\npatterns can also be implemented with params\nprop.\nSee the examples section for more information.\nExamples\nDisplaying content based on params\nUsing dynamic route segments, you can display or fetch specific content based on the params\nprop.\nexport default async function DashboardLayout({\nchildren,\nparams,\n}: {\nchildren: React.ReactNode\nparams: Promise<{ team: string }>\n}) {\nconst { team } = await params\nreturn (\n<section>\n<header>\n<h1>Welcome to {team}'s Dashboard</h1>\n</header>\n<main>{children}</main>\n</section>\n)\n}\nReading params\nin Client Components\nTo use params\nin a Client Component (which cannot be async\n), you can use React's use\nfunction to read the promise:\n'use client'\nimport { use } from 'react'\nexport default function Page({\nparams,\n}: {\nparams: Promise<{ slug: string }>\n}) {\nconst { slug } = use(params)\n}\nVersion History\n| Version | Changes |\n|---|---|\nv15.0.0-RC | params is now a promise. A codemod is available. |\nv13.0.0 | layout introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/loading", "title": "File Conventions: loading.js | Next.js", "text": "loading.js\nA loading file can create instant loading states built on Suspense.\nBy default, this file is a Server Component - but can also be used as a Client Component through the \"use client\"\ndirective.\napp/feed/loading.tsx\nexport default function Loading() {\n// Or a custom loading skeleton component\nreturn <p>Loading...</p>\n}\nLoading UI components do not accept any parameters.\nGood to know:\n- While designing loading UI, you may find it helpful to use the React Developer Tools to manually toggle Suspense boundaries.\nVersion History\n| Version | Changes |\n|---|---|\nv13.0.0 | loading introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/mdx-components", "title": "File Conventions: mdx-components.js | Next.js", "text": "mdx-components.js\nThe mdx-components.js|tsx\nfile is required to use @next/mdx\nwith App Router and will not work without it. Additionally, you can use it to customize styles.\nUse the file mdx-components.tsx\n(or .js\n) in the root of your project to define MDX Components. For example, at the same level as pages\nor app\n, or inside src\nif applicable.\nmdx-components.tsx\nimport type { MDXComponents } from 'mdx/types'\nexport function useMDXComponents(components: MDXComponents): MDXComponents {\nreturn {\n...components,\n}\n}\nExports\nuseMDXComponents\nfunction\nThe file must export a single function, either as a default export or named useMDXComponents\n.\nmdx-components.tsx\nimport type { MDXComponents } from 'mdx/types'\nexport function useMDXComponents(components: MDXComponents): MDXComponents {\nreturn {\n...components,\n}\n}\nParams\ncomponents\nWhen defining MDX Components, the export function accepts a single parameter, components\n. This parameter is an instance of MDXComponents\n.\n- The key is the name of the HTML element to override.\n- The value is the component to render instead.\nGood to know: Remember to pass all other components (i.e.\n...components\n) that do not have overrides.\nVersion History\n| Version | Changes |\n|---|---|\nv13.1.2 | MDX Components added |\nLearn more about MDX Components\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata", "title": "File Conventions: Metadata Files | Next.js", "text": "Metadata Files API Reference\nThis section of the docs covers Metadata file conventions. File-based metadata can be defined by adding special metadata files to route segments.\nEach file convention can be defined using a static file (e.g. opengraph-image.jpg\n), or a dynamic variant that uses code to generate the file (e.g. opengraph-image.js\n).\nOnce a file is defined, Next.js will automatically serve the file (with hashes in production for caching) and update the relevant head elements with the correct metadata, such as the asset's URL, file type, and image size.\nGood to know:\n- Special Route Handlers like\nsitemap.ts\n,opengraph-image.tsx\n, andicon.tsx\n, and other metadata files are cached by default.- If using along with\nmiddleware.ts\n, configure the matcher to exclude the metadata files.\nfavicon, icon, and apple-icon\nAPI Reference for the Favicon, Icon and Apple Icon file conventions.\nmanifest.json\nAPI Reference for manifest.json file.\nopengraph-image and twitter-image\nAPI Reference for the Open Graph Image and Twitter Image file conventions.\nrobots.txt\nAPI Reference for robots.txt file.\nsitemap.xml\nAPI Reference for the sitemap.xml file.\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/app-icons", "title": "Metadata Files: favicon, icon, and apple-icon | Next.js", "text": "favicon, icon, and apple-icon\nThe favicon\n, icon\n, or apple-icon\nfile conventions allow you to set icons for your application.\nThey are useful for adding app icons that appear in places like web browser tabs, phone home screens, and search engine results.\nThere are two ways to set app icons:\nImage files (.ico, .jpg, .png)\nUse an image file to set an app icon by placing a favicon\n, icon\n, or apple-icon\nimage file within your /app\ndirectory.\nThe favicon\nimage can only be located in the top level of app/\n.\nNext.js will evaluate the file and automatically add the appropriate tags to your app's <head>\nelement.\n| File convention | Supported file types | Valid locations |\n|---|---|---|\nfavicon | .ico | app/ |\nicon | .ico , .jpg , .jpeg , .png , .svg | app/**/* |\napple-icon | .jpg , .jpeg , .png | app/**/* |\nfavicon\nAdd a favicon.ico\nimage file to the root /app\nroute segment.\n<link rel=\"icon\" href=\"/favicon.ico\" sizes=\"any\" />\nicon\nAdd an icon.(ico|jpg|jpeg|png|svg)\nimage file.\n<link\nrel=\"icon\"\nhref=\"/icon?<generated>\"\ntype=\"image/<generated>\"\nsizes=\"<generated>\"\n/>\napple-icon\nAdd an apple-icon.(jpg|jpeg|png)\nimage file.\n<link\nrel=\"apple-touch-icon\"\nhref=\"/apple-icon?<generated>\"\ntype=\"image/<generated>\"\nsizes=\"<generated>\"\n/>\nGood to know:\n- You can set multiple icons by adding a number suffix to the file name. For example,\nicon1.png\n,icon2.png\n, etc. Numbered files will sort lexically.- Favicons can only be set in the root\n/app\nsegment. If you need more granularity, you can useicon\n.- The appropriate\n<link>\ntags and attributes such asrel\n,href\n,type\n, andsizes\nare determined by the icon type and metadata of the evaluated file.- For example, a 32 by 32px\n.png\nfile will havetype=\"image/png\"\nandsizes=\"32x32\"\nattributes.sizes=\"any\"\nis added to icons when the extension is.svg\nor the image size of the file is not determined. More details in this favicon handbook.\nGenerate icons using code (.js, .ts, .tsx)\nIn addition to using literal image files, you can programmatically generate icons using code.\nGenerate an app icon by creating an icon\nor apple-icon\nroute that default exports a function.\n| File convention | Supported file types |\n|---|---|\nicon | .js , .ts , .tsx |\napple-icon | .js , .ts , .tsx |\nThe easiest way to generate an icon is to use the ImageResponse\nAPI from next/og\n.\nimport { ImageResponse } from 'next/og'\n// Image metadata\nexport const size = {\nwidth: 32,\nheight: 32,\n}\nexport const contentType = 'image/png'\n// Image generation\nexport default function Icon() {\nreturn new ImageResponse(\n(\n// ImageResponse JSX element\n<div\nstyle={{\nfontSize: 24,\nbackground: 'black',\nwidth: '100%',\nheight: '100%',\ndisplay: 'flex',\nalignItems: 'center',\njustifyContent: 'center',\ncolor: 'white',\n}}\n>\nA\n</div>\n),\n// ImageResponse options\n{\n// For convenience, we can re-use the exported icons size metadata\n// config to also set the ImageResponse's width and height.\n...size,\n}\n)\n}\n<link rel=\"icon\" href=\"/icon?<generated>\" type=\"image/png\" sizes=\"32x32\" />\nGood to know:\n- By default, generated icons are statically optimized (generated at build time and cached) unless they use Dynamic APIs or uncached data.\n- You can generate multiple icons in the same file using\ngenerateImageMetadata\n.- You cannot generate a\nfavicon\nicon. Useicon\nor a favicon.ico file instead.- App icons are special Route Handlers that is cached by default unless it uses a Dynamic API or dynamic config option.\nProps\nThe default export function receives the following props:\nparams\n(optional)\nAn object containing the dynamic route parameters object from the root segment down to the segment icon\nor apple-icon\nis colocated in.\nexport default function Icon({ params }: { params: { slug: string } }) {\n// ...\n}\n| Route | URL | params |\n|---|---|---|\napp/shop/icon.js | /shop | undefined |\napp/shop/[slug]/icon.js | /shop/1 | { slug: '1' } |\napp/shop/[tag]/[item]/icon.js | /shop/1/2 | { tag: '1', item: '2' } |\nReturns\nThe default export function should return a Blob\n| ArrayBuffer\n| TypedArray\n| DataView\n| ReadableStream\n| Response\n.\nGood to know:\nImageResponse\nsatisfies this return type.\nConfig exports\nYou can optionally configure the icon's metadata by exporting size\nand contentType\nvariables from the icon\nor apple-icon\nroute.\n| Option | Type |\n|---|---|\nsize | { width: number; height: number } |\ncontentType | string - image MIME type |\nsize\nexport const size = { width: 32, height: 32 }\nexport default function Icon() {}\n<link rel=\"icon\" sizes=\"32x32\" />\ncontentType\nexport const contentType = 'image/png'\nexport default function Icon() {}\n<link rel=\"icon\" type=\"image/png\" />\nRoute Segment Config\nicon\nand apple-icon\nare specialized Route Handlers that can use the same route segment configuration options as Pages and Layouts.\nVersion History\n| Version | Changes |\n|---|---|\nv13.3.0 | favicon icon and apple-icon introduced |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/manifest", "title": "Metadata Files: manifest.json | Next.js", "text": "manifest.json\nAdd or generate a manifest.(json|webmanifest)\nfile that matches the Web Manifest Specification in the root of app\ndirectory to provide information about your web application for the browser.\nStatic Manifest file\napp/manifest.json | app/manifest.webmanifest\n{\n\"name\": \"My Next.js Application\",\n\"short_name\": \"Next.js App\",\n\"description\": \"An application built with Next.js\",\n\"start_url\": \"/\"\n// ...\n}\nGenerate a Manifest file\nAdd a manifest.js\nor manifest.ts\nfile that returns a Manifest\nobject.\nGood to know:\nmanifest.js\nis special Route Handlers that is cached by default unless it uses a Dynamic API or dynamic config option.\napp/manifest.ts\nimport type { MetadataRoute } from 'next'\nexport default function manifest(): MetadataRoute.Manifest {\nreturn {\nname: 'Next.js App',\nshort_name: 'Next.js App',\ndescription: 'Next.js App',\nstart_url: '/',\ndisplay: 'standalone',\nbackground_color: '#fff',\ntheme_color: '#fff',\nicons: [\n{\nsrc: '/favicon.ico',\nsizes: 'any',\ntype: 'image/x-icon',\n},\n],\n}\n}\nManifest Object\nThe manifest object contains an extensive list of options that may be updated due to new web standards. For information on all the current options, refer to the MetadataRoute.Manifest\ntype in your code editor if using TypeScript or see the MDN docs.\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image", "title": "Metadata Files: opengraph-image and twitter-image | Next.js", "text": "opengraph-image and twitter-image\nThe opengraph-image\nand twitter-image\nfile conventions allow you to set Open Graph and Twitter images for a route segment.\nThey are useful for setting the images that appear on social networks and messaging apps when a user shares a link to your site.\nThere are two ways to set Open Graph and Twitter images:\nImage files (.jpg, .png, .gif)\nUse an image file to set a route segment's shared image by placing an opengraph-image\nor twitter-image\nimage file in the segment.\nNext.js will evaluate the file and automatically add the appropriate tags to your app's <head>\nelement.\n| File convention | Supported file types |\n|---|---|\nopengraph-image | .jpg , .jpeg , .png , .gif |\ntwitter-image | .jpg , .jpeg , .png , .gif |\nopengraph-image.alt | .txt |\ntwitter-image.alt | .txt |\nGood to know:\nThe\ntwitter-image\nfile size must not exceed 5MB, and theopengraph-image\nfile size must not exceed 8MB. If the image file size exceeds these limits, the build will fail.\nopengraph-image\nAdd an opengraph-image.(jpg|jpeg|png|gif)\nimage file to any route segment.\n<meta property=\"og:image\" content=\"<generated>\" />\n<meta property=\"og:image:type\" content=\"<generated>\" />\n<meta property=\"og:image:width\" content=\"<generated>\" />\n<meta property=\"og:image:height\" content=\"<generated>\" />\ntwitter-image\nAdd a twitter-image.(jpg|jpeg|png|gif)\nimage file to any route segment.\n<meta name=\"twitter:image\" content=\"<generated>\" />\n<meta name=\"twitter:image:type\" content=\"<generated>\" />\n<meta name=\"twitter:image:width\" content=\"<generated>\" />\n<meta name=\"twitter:image:height\" content=\"<generated>\" />\nopengraph-image.alt.txt\nAdd an accompanying opengraph-image.alt.txt\nfile in the same route segment as the opengraph-image.(jpg|jpeg|png|gif)\nimage it's alt text.\nAbout Acme\n<meta property=\"og:image:alt\" content=\"About Acme\" />\ntwitter-image.alt.txt\nAdd an accompanying twitter-image.alt.txt\nfile in the same route segment as the twitter-image.(jpg|jpeg|png|gif)\nimage it's alt text.\nAbout Acme\n<meta property=\"twitter:image:alt\" content=\"About Acme\" />\nGenerate images using code (.js, .ts, .tsx)\nIn addition to using literal image files, you can programmatically generate images using code.\nGenerate a route segment's shared image by creating an opengraph-image\nor twitter-image\nroute that default exports a function.\n| File convention | Supported file types |\n|---|---|\nopengraph-image | .js , .ts , .tsx |\ntwitter-image | .js , .ts , .tsx |\nGood to know:\n- By default, generated images are statically optimized (generated at build time and cached) unless they use Dynamic APIs or uncached data.\n- You can generate multiple Images in the same file using\ngenerateImageMetadata\n.opengraph-image.js\nandtwitter-image.js\nare special Route Handlers that is cached by default unless it uses a Dynamic API or dynamic config option.\nThe easiest way to generate an image is to use the ImageResponse API from next/og\n.\nimport { ImageResponse } from 'next/og'\nexport const runtime = 'edge'\n// Image metadata\nexport const alt = 'About Acme'\nexport const size = {\nwidth: 1200,\nheight: 630,\n}\nexport const contentType = 'image/png'\n// Image generation\nexport default async function Image() {\n// Font\nconst interSemiBold = fetch(\nnew URL('./Inter-SemiBold.ttf', import.meta.url)\n).then((res) => res.arrayBuffer())\nreturn new ImageResponse(\n(\n// ImageResponse JSX element\n<div\nstyle={{\nfontSize: 128,\nbackground: 'white',\nwidth: '100%',\nheight: '100%',\ndisplay: 'flex',\nalignItems: 'center',\njustifyContent: 'center',\n}}\n>\nAbout Acme\n</div>\n),\n// ImageResponse options\n{\n// For convenience, we can re-use the exported opengraph-image\n// size config to also set the ImageResponse's width and height.\n...size,\nfonts: [\n{\nname: 'Inter',\ndata: await interSemiBold,\nstyle: 'normal',\nweight: 400,\n},\n],\n}\n)\n}\n<meta property=\"og:image\" content=\"<generated>\" />\n<meta property=\"og:image:alt\" content=\"About Acme\" />\n<meta property=\"og:image:type\" content=\"image/png\" />\n<meta property=\"og:image:width\" content=\"1200\" />\n<meta property=\"og:image:height\" content=\"630\" />\nProps\nThe default export function receives the following props:\nparams\n(optional)\nAn object containing the dynamic route parameters object from the root segment down to the segment opengraph-image\nor twitter-image\nis colocated in.\nexport default function Image({ params }: { params: { slug: string } }) {\n// ...\n}\n| Route | URL | params |\n|---|---|---|\napp/shop/opengraph-image.js | /shop | undefined |\napp/shop/[slug]/opengraph-image.js | /shop/1 | { slug: '1' } |\napp/shop/[tag]/[item]/opengraph-image.js | /shop/1/2 | { tag: '1', item: '2' } |\nReturns\nThe default export function should return a Blob\n| ArrayBuffer\n| TypedArray\n| DataView\n| ReadableStream\n| Response\n.\nGood to know:\nImageResponse\nsatisfies this return type.\nConfig exports\nYou can optionally configure the image's metadata by exporting alt\n, size\n, and contentType\nvariables from opengraph-image\nor twitter-image\nroute.\n| Option | Type |\n|---|---|\nalt | string |\nsize | { width: number; height: number } |\ncontentType | string - image MIME type |\nalt\nexport const alt = 'My images alt text'\nexport default function Image() {}\n<meta property=\"og:image:alt\" content=\"My images alt text\" />\nsize\nexport const size = { width: 1200, height: 630 }\nexport default function Image() {}\n<meta property=\"og:image:width\" content=\"1200\" />\n<meta property=\"og:image:height\" content=\"630\" />\ncontentType\nexport const contentType = 'image/png'\nexport default function Image() {}\n<meta property=\"og:image:type\" content=\"image/png\" />\nRoute Segment Config\nopengraph-image\nand twitter-image\nare specialized Route Handlers that can use the same route segment configuration options as Pages and Layouts.\nExamples\nUsing external data\nThis example uses the params\nobject and external data to generate the image.\nGood to know: By default, this generated image will be statically optimized. You can configure the individual\nfetch\noptions\nor route segments options to change this behavior.\nimport { ImageResponse } from 'next/og'\nexport const alt = 'About Acme'\nexport const size = {\nwidth: 1200,\nheight: 630,\n}\nexport const contentType = 'image/png'\nexport default async function Image({ params }: { params: { slug: string } }) {\nconst post = await fetch(`https://.../posts/${params.slug}`).then((res) =>\nres.json()\n)\nreturn new ImageResponse(\n(\n<div\nstyle={{\nfontSize: 48,\nbackground: 'white',\nwidth: '100%',\nheight: '100%',\ndisplay: 'flex',\nalignItems: 'center',\njustifyContent: 'center',\n}}\n>\n{post.title}\n</div>\n),\n{\n...size,\n}\n)\n}\nUsing Edge runtime with local assets\nThis example uses the Edge runtime to fetch a local image on the file system and passes it as an ArrayBuffer\nto the src\nattribute of an <img>\nelement. The local asset should be placed relative to the example source file location.\nimport { ImageResponse } from 'next/og'\nexport const runtime = 'edge'\nexport default async function Image() {\nconst logoSrc = await fetch(new URL('./logo.png', import.meta.url)).then(\n(res) => res.arrayBuffer()\n)\nreturn new ImageResponse(\n(\n<div\nstyle={{\ndisplay: 'flex',\nalignItems: 'center',\njustifyContent: 'center',\n}}\n>\n<img src={logoSrc} height=\"100\" />\n</div>\n)\n)\n}\nUsing Node.js runtime with local assets\nThis example uses the Node.js runtime to fetch a local image on the file system and passes it as an ArrayBuffer\nto the src\nattribute of an <img>\nelement. The local asset should be placed relative to the root of your project, rather than the location of the example source file.\nimport { ImageResponse } from 'next/og'\nimport { join } from 'node:path'\nimport { readFile } from 'node:fs/promises'\nexport default async function Image() {\nconst logoData = await readFile(join(process.cwd(), 'logo.png'))\nconst logoSrc = Uint8Array.from(logoData).buffer\nreturn new ImageResponse(\n(\n<div\nstyle={{\ndisplay: 'flex',\nalignItems: 'center',\njustifyContent: 'center',\n}}\n>\n<img src={logoSrc} height=\"100\" />\n</div>\n)\n)\n}\nVersion History\n| Version | Changes |\n|---|---|\nv13.3.0 | opengraph-image and twitter-image introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/robots", "title": "Metadata Files: robots.txt | Next.js", "text": "robots.txt\nAdd or generate a robots.txt\nfile that matches the Robots Exclusion Standard in the root of app\ndirectory to tell search engine crawlers which URLs they can access on your site.\nStatic robots.txt\napp/robots.txt\nUser-Agent: *\nAllow: /\nDisallow: /private/\nSitemap: https://acme.com/sitemap.xml\nGenerate a Robots file\nAdd a robots.js\nor robots.ts\nfile that returns a Robots\nobject.\nGood to know:\nrobots.js\nis a special Route Handlers that is cached by default unless it uses a Dynamic API or dynamic config option.\napp/robots.ts\nimport type { MetadataRoute } from 'next'\nexport default function robots(): MetadataRoute.Robots {\nreturn {\nrules: {\nuserAgent: '*',\nallow: '/',\ndisallow: '/private/',\n},\nsitemap: 'https://acme.com/sitemap.xml',\n}\n}\nOutput:\nUser-Agent: *\nAllow: /\nDisallow: /private/\nSitemap: https://acme.com/sitemap.xml\nCustomizing specific user agents\nYou can customise how individual search engine bots crawl your site by passing an array of user agents to the rules\nproperty. For example:\napp/robots.ts\nimport type { MetadataRoute } from 'next'\nexport default function robots(): MetadataRoute.Robots {\nreturn {\nrules: [\n{\nuserAgent: 'Googlebot',\nallow: ['/'],\ndisallow: '/private/',\n},\n{\nuserAgent: ['Applebot', 'Bingbot'],\ndisallow: ['/'],\n},\n],\nsitemap: 'https://acme.com/sitemap.xml',\n}\n}\nOutput:\nUser-Agent: Googlebot\nAllow: /\nDisallow: /private/\nUser-Agent: Applebot\nDisallow: /\nUser-Agent: Bingbot\nDisallow: /\nSitemap: https://acme.com/sitemap.xml\nRobots object\ntype Robots = {\nrules:\n| {\nuserAgent?: string | string[]\nallow?: string | string[]\ndisallow?: string | string[]\ncrawlDelay?: number\n}\n| Array<{\nuserAgent: string | string[]\nallow?: string | string[]\ndisallow?: string | string[]\ncrawlDelay?: number\n}>\nsitemap?: string | string[]\nhost?: string\n}\nVersion History\n| Version | Changes |\n|---|---|\nv13.3.0 | robots introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/sitemap", "title": "Metadata Files: sitemap.xml | Next.js", "text": "sitemap.xml\nsitemap.(xml|js|ts)\nis a special file that matches the Sitemaps XML format to help search engine crawlers index your site more efficiently.\nSitemap files (.xml)\nFor smaller applications, you can create a sitemap.xml\nfile and place it in the root of your app\ndirectory.\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n<url>\n<loc>https://acme.com</loc>\n<lastmod>2023-04-06T15:02:24.021Z</lastmod>\n<changefreq>yearly</changefreq>\n<priority>1</priority>\n</url>\n<url>\n<loc>https://acme.com/about</loc>\n<lastmod>2023-04-06T15:02:24.021Z</lastmod>\n<changefreq>monthly</changefreq>\n<priority>0.8</priority>\n</url>\n<url>\n<loc>https://acme.com/blog</loc>\n<lastmod>2023-04-06T15:02:24.021Z</lastmod>\n<changefreq>weekly</changefreq>\n<priority>0.5</priority>\n</url>\n</urlset>\nGenerating a sitemap using code (.js, .ts)\nYou can use the sitemap.(js|ts)\nfile convention to programmatically generate a sitemap by exporting a default function that returns an array of URLs. If using TypeScript, a Sitemap\ntype is available.\nGood to know:\nsitemap.js\nis a special Route Handler that is cached by default unless it uses a Dynamic API or dynamic config option.\nimport type { MetadataRoute } from 'next'\nexport default function sitemap(): MetadataRoute.Sitemap {\nreturn [\n{\nurl: 'https://acme.com',\nlastModified: new Date(),\nchangeFrequency: 'yearly',\npriority: 1,\n},\n{\nurl: 'https://acme.com/about',\nlastModified: new Date(),\nchangeFrequency: 'monthly',\npriority: 0.8,\n},\n{\nurl: 'https://acme.com/blog',\nlastModified: new Date(),\nchangeFrequency: 'weekly',\npriority: 0.5,\n},\n]\n}\nOutput:\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n<url>\n<loc>https://acme.com</loc>\n<lastmod>2023-04-06T15:02:24.021Z</lastmod>\n<changefreq>yearly</changefreq>\n<priority>1</priority>\n</url>\n<url>\n<loc>https://acme.com/about</loc>\n<lastmod>2023-04-06T15:02:24.021Z</lastmod>\n<changefreq>monthly</changefreq>\n<priority>0.8</priority>\n</url>\n<url>\n<loc>https://acme.com/blog</loc>\n<lastmod>2023-04-06T15:02:24.021Z</lastmod>\n<changefreq>weekly</changefreq>\n<priority>0.5</priority>\n</url>\n</urlset>\nImage Sitemaps\nYou can use images\nproperty to create image sitemaps. Learn more details in the Google Developer Docs.\nimport type { MetadataRoute } from 'next'\nexport default function sitemap(): MetadataRoute.Sitemap {\nreturn [\n{\nurl: 'https://example.com',\nlastModified: '2021-01-01',\nchangeFrequency: 'weekly',\npriority: 0.5,\nimages: ['https://example.com/image.jpg'],\n},\n]\n}\nOutput:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset\nxmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\nxmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\"\n>\n<url>\n<loc>https://example.com</loc>\n<image:image>\n<image:loc>https://example.com/image.jpg</image:loc>\n</image:image>\n<lastmod>2021-01-01</lastmod>\n<changefreq>weekly</changefreq>\n<priority>0.5</priority>\n</url>\n</urlset>\nVideo Sitemaps\nYou can use videos\nproperty to create video sitemaps. Learn more details in the Google Developer Docs.\nimport type { MetadataRoute } from 'next'\nexport default function sitemap(): MetadataRoute.Sitemap {\nreturn [\n{\nurl: 'https://example.com',\nlastModified: '2021-01-01',\nchangeFrequency: 'weekly',\npriority: 0.5,\nvideos: [\n{\ntitle: 'example',\nthumbnail_loc: 'https://example.com/image.jpg',\ndescription: 'this is the description',\n},\n],\n},\n]\n}\nOutput:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset\nxmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\nxmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\"\n>\n<url>\n<loc>https://example.com</loc>\n<video:video>\n<video:title>example</video:title>\n<video:thumbnail_loc>https://example.com/image.jpg</video:thumbnail_loc>\n<video:description>this is the description</video:description>\n</video:video>\n<lastmod>2021-01-01</lastmod>\n<changefreq>weekly</changefreq>\n<priority>0.5</priority>\n</url>\n</urlset>\nGenerate a localized Sitemap\nimport type { MetadataRoute } from 'next'\nexport default function sitemap(): MetadataRoute.Sitemap {\nreturn [\n{\nurl: 'https://acme.com',\nlastModified: new Date(),\nalternates: {\nlanguages: {\nes: 'https://acme.com/es',\nde: 'https://acme.com/de',\n},\n},\n},\n{\nurl: 'https://acme.com/about',\nlastModified: new Date(),\nalternates: {\nlanguages: {\nes: 'https://acme.com/es/about',\nde: 'https://acme.com/de/about',\n},\n},\n},\n{\nurl: 'https://acme.com/blog',\nlastModified: new Date(),\nalternates: {\nlanguages: {\nes: 'https://acme.com/es/blog',\nde: 'https://acme.com/de/blog',\n},\n},\n},\n]\n}\nOutput:\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\">\n<url>\n<loc>https://acme.com</loc>\n<xhtml:link\nrel=\"alternate\"\nhreflang=\"es\"\nhref=\"https://acme.com/es\"/>\n<xhtml:link\nrel=\"alternate\"\nhreflang=\"de\"\nhref=\"https://acme.com/de\"/>\n<lastmod>2023-04-06T15:02:24.021Z</lastmod>\n</url>\n<url>\n<loc>https://acme.com/about</loc>\n<xhtml:link\nrel=\"alternate\"\nhreflang=\"es\"\nhref=\"https://acme.com/es/about\"/>\n<xhtml:link\nrel=\"alternate\"\nhreflang=\"de\"\nhref=\"https://acme.com/de/about\"/>\n<lastmod>2023-04-06T15:02:24.021Z</lastmod>\n</url>\n<url>\n<loc>https://acme.com/blog</loc>\n<xhtml:link\nrel=\"alternate\"\nhreflang=\"es\"\nhref=\"https://acme.com/es/blog\"/>\n<xhtml:link\nrel=\"alternate\"\nhreflang=\"de\"\nhref=\"https://acme.com/de/blog\"/>\n<lastmod>2023-04-06T15:02:24.021Z</lastmod>\n</url>\n</urlset>\nGenerating multiple sitemaps\nWhile a single sitemap will work for most applications. For large web applications, you may need to split a sitemap into multiple files.\nThere are two ways you can create multiple sitemaps:\n- By nesting\nsitemap.(xml|js|ts)\ninside multiple route segments e.g.app/sitemap.xml\nandapp/products/sitemap.xml\n. - By using the\ngenerateSitemaps\nfunction.\nFor example, to split a sitemap using generateSitemaps\n, return an array of objects with the sitemap id\n. Then, use the id\nto generate the unique sitemaps.\nimport type { MetadataRoute } from 'next'\nimport { BASE_URL } from '@/app/lib/constants'\nexport async function generateSitemaps() {\n// Fetch the total number of products and calculate the number of sitemaps needed\nreturn [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }]\n}\nexport default async function sitemap({\nid,\n}: {\nid: number\n}): Promise<MetadataRoute.Sitemap> {\n// Google's limit is 50,000 URLs per sitemap\nconst start = id * 50000\nconst end = start + 50000\nconst products = await getProducts(\n`SELECT id, date FROM products WHERE id BETWEEN ${start} AND ${end}`\n)\nreturn products.map((product) => ({\nurl: `${BASE_URL}/product/${product.id}`,\nlastModified: product.date,\n}))\n}\nYour generated sitemaps will be available at /.../sitemap/[id]\n. For example, /product/sitemap/1.xml\n.\nSee the generateSitemaps\nAPI reference for more information.\nReturns\nThe default function exported from sitemap.(xml|ts|js)\nshould return an array of objects with the following properties:\ntype Sitemap = Array<{\nurl: string\nlastModified?: string | Date\nchangeFrequency?:\n| 'always'\n| 'hourly'\n| 'daily'\n| 'weekly'\n| 'monthly'\n| 'yearly'\n| 'never'\npriority?: number\nalternates?: {\nlanguages?: Languages<string>\n}\n}>\nVersion History\n| Version | Changes |\n|---|---|\nv14.2.0 | Add localizations support. |\nv13.4.14 | Add changeFrequency and priority attributes to sitemaps. |\nv13.3.0 | sitemap introduced. |\nNext Steps\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/middleware", "title": "File Conventions: middleware.js | Next.js", "text": "middleware.js\nThe middleware.js|ts\nfile is used to write Middleware and run code on the server before a request is completed. Then, based on the incoming request, you can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly.\nMiddleware executes before routes are rendered. It's particularly useful for implementing custom server-side logic like authentication, logging, or handling redirects.\nUse the file middleware.ts\n(or .js) in the root of your project to define Middleware. For example, at the same level as app\nor pages\n, or inside src\nif applicable.\nimport { NextResponse, NextRequest } from 'next/server'\n// This function can be marked `async` if using `await` inside\nexport function middleware(request: NextRequest) {\nreturn NextResponse.redirect(new URL('/home', request.url))\n}\nexport const config = {\nmatcher: '/about/:path*',\n}\nExports\nMiddleware function\nThe file must export a single function, either as a default export or named middleware\n. Note that multiple middleware from the same file are not supported.\n// Example of default export\nexport default function middleware(request) {\n// Middleware logic\n}\nConfig object (optional)\nOptionally, a config object can be exported alongside the Middleware function. This object includes the matcher to specify paths where the Middleware applies.\nMatcher\nThe matcher\noption allows you to target specific paths for the Middleware to run on. You can specify these paths in several ways:\n- For a single path: Directly use a string to define the path, like\n'/about'\n. - For multiple paths: Use an array to list multiple paths, such as\nmatcher: ['/about', '/contact']\n, which applies the Middleware to both/about\nand/contact\n.\nAdditionally, matcher\nsupports complex path specifications through regular expressions, such as matcher: ['/((?!api|_next/static|_next/image|.*\\\\.png$).*)']\n, enabling precise control over which paths to include or exclude.\nThe matcher\noption also accepts an array of objects with the following keys:\nsource\n: The path or pattern used to match the request paths. It can be a string for direct path matching or a pattern for more complex matching.regexp\n(optional): A regular expression string that fine-tunes the matching based on the source. It provides additional control over which paths are included or excluded.locale\n(optional): A boolean that, when set tofalse\n, ignores locale-based routing in path matching.has\n(optional): Specifies conditions based on the presence of specific request elements such as headers, query parameters, or cookies.missing\n(optional): Focuses on conditions where certain request elements are absent, like missing headers or cookies.\nexport const config = {\nmatcher: [\n{\nsource: '/api/*',\nregexp: '^/api/(.*)',\nlocale: false,\nhas: [\n{ type: 'header', key: 'Authorization', value: 'Bearer Token' },\n{ type: 'query', key: 'userId', value: '123' },\n],\nmissing: [{ type: 'cookie', key: 'session', value: 'active' }],\n},\n],\n}\nParams\nrequest\nWhen defining Middleware, the default export function accepts a single parameter, request\n. This parameter is an instance of NextRequest\n, which represents the incoming HTTP request.\nimport type { NextRequest } from 'next/server'\nexport function middleware(request: NextRequest) {\n// Middleware logic goes here\n}\nGood to know:\nNextRequest\nis a type that represents incoming HTTP requests in Next.js Middleware, whereasNextResponse\nis a class used to manipulate and send back HTTP responses.\nNextResponse\nMiddleware can use the NextResponse\nobject which extends the Web Response API. By returning a NextResponse\nobject, you can directly manipulate cookies, set headers, implement redirects, and rewrite paths.\nGood to know: For redirects, you can also use\nResponse.redirect\ninstead ofNextResponse.redirect\n.\nRuntime\nMiddleware only supports the Edge runtime. The Node.js runtime cannot be used.\nVersion History\n| Version | Changes |\n|---|---|\nv13.1.0 | Advanced Middleware flags added |\nv13.0.0 | Middleware can modify request headers, response headers, and send responses |\nv12.2.0 | Middleware is stable, please see the upgrade guide |\nv12.0.9 | Enforce absolute URLs in Edge Runtime (PR) |\nv12.0.0 | Middleware (Beta) added |\nLearn more about Middleware\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/not-found", "title": "File Conventions: not-found.js | Next.js", "text": "not-found.js\nThe not-found file is used to render UI when the notFound\nfunction is thrown within a route segment. Along with serving a custom UI, Next.js will return a 200\nHTTP status code for streamed responses, and 404\nfor non-streamed responses.\nimport Link from 'next/link'\nexport default function NotFound() {\nreturn (\n<div>\n<h2>Not Found</h2>\n<p>Could not find requested resource</p>\n<Link href=\"/\">Return Home</Link>\n</div>\n)\n}\nReference\nProps\nnot-found.js\ncomponents do not accept any props.\nGood to know: In addition to catching expected\nnotFound()\nerrors, the rootapp/not-found.js\nfile also handles any unmatched URLs for your whole application. This means users that visit a URL that is not handled by your app will be shown the UI exported by theapp/not-found.js\nfile.\nExamples\nData Fetching\nBy default, not-found\nis a Server Component. You can mark it as async\nto fetch and display data:\nimport Link from 'next/link'\nimport { headers } from 'next/headers'\nexport default async function NotFound() {\nconst headersList = await headers()\nconst domain = headersList.get('host')\nconst data = await getSiteData(domain)\nreturn (\n<div>\n<h2>Not Found: {data.name}</h2>\n<p>Could not find requested resource</p>\n<p>\nView <Link href=\"/blog\">all posts</Link>\n</p>\n</div>\n)\n}\nIf you need to use Client Component hooks like usePathname\nto display content based on the path, you must fetch data on the client-side instead.\nVersion History\n| Version | Changes |\n|---|---|\nv13.3.0 | Root app/not-found handles global unmatched URLs. |\nv13.0.0 | not-found introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/page", "title": "File Conventions: page.js | Next.js", "text": "page.js\nThe page\nfile allows you to define UI that is unique to a route. You can create a page by default exporting a component from the file:\napp/blog/[slug]/page.tsx\nexport default function Page({\nparams,\nsearchParams,\n}: {\nparams: Promise<{ slug: string }>\nsearchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}) {\nreturn <h1>My Page</h1>\n}\nGood to know\n- The\n.js\n,.jsx\n, or.tsx\nfile extensions can be used forpage\n. - A\npage\nis always the leaf of the route subtree. - A\npage\nfile is required to make a route segment publicly accessible. - Pages are Server Components by default, but can be set to a Client Component.\nReference\nProps\nparams\n(optional)\nA promise that resolves to an object containing the dynamic route parameters from the root segment down to that page.\napp/shop/[slug]/page.tsx\nexport default async function Page({\nparams,\n}: {\nparams: Promise<{ slug: string }>\n}) {\nconst slug = (await params).slug\n}\n| Example Route | URL | params |\n|---|---|---|\napp/shop/[slug]/page.js | /shop/1 | Promise<{ slug: '1' }> |\napp/shop/[category]/[item]/page.js | /shop/1/2 | Promise<{ category: '1', item: '2' }> |\napp/shop/[...slug]/page.js | /shop/1/2 | Promise<{ slug: ['1', '2'] }> |\n- Since the\nparams\nprop is a promise. You must useasync/await\nor React'suse\nfunction to access the values.- In version 14 and earlier,\nparams\nwas a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.\n- In version 14 and earlier,\nsearchParams\n(optional)\nA promise that resolves to an object containing the search parameters of the current URL. For example:\napp/shop/page.tsx\nexport default async function Page({\nsearchParams,\n}: {\nsearchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}) {\nconst filters = (await searchParams).filters\n}\n| Example URL | searchParams |\n|---|---|\n/shop?a=1 | Promise<{ a: '1' }> |\n/shop?a=1&b=2 | Promise<{ a: '1', b: '2' }> |\n/shop?a=1&a=2 | Promise<{ a: ['1', '2'] }> |\n- Since the\nsearchParams\nprop is a promise. You must useasync/await\nor React'suse\nfunction to access the values.- In version 14 and earlier,\nsearchParams\nwas a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.\n- In version 14 and earlier,\nsearchParams\nis a Dynamic API whose values cannot be known ahead of time. Using it will opt the page into dynamic rendering at request time.searchParams\nis a plain JavaScript object, not aURLSearchParams\ninstance.\nExamples\nDisplaying content based on params\nUsing dynamic route segments, you can display or fetch specific content for the page based on the params\nprop.\napp/blog/[slug]/page.tsx\nexport default async function Page({\nparams,\n}: {\nparams: Promise<{ slug: string }>\n}) {\nconst { slug } = await params\nreturn <h1>Blog Post: {slug}</h1>\n}\nHandling filtering with searchParams\nYou can use the searchParams\nprop to handle filtering, pagination, or sorting based on the query string of the URL.\napp/shop/page.tsx\nexport default async function Page({\nsearchParams,\n}: {\nsearchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}) {\nconst { page = '1', sort = 'asc', query = '' } = await searchParams\nreturn (\n<div>\n<h1>Product Listing</h1>\n<p>Search query: {query}</p>\n<p>Current page: {page}</p>\n<p>Sort order: {sort}</p>\n</div>\n)\n}\nReading searchParams\nand params\nin Client Components\nTo use searchParams\nand params\nin a Client Component (which cannot be async\n), you can use React's use\nfunction to read the promise:\napp/page.tsx\n'use client'\nimport { use } from 'react'\nexport default function Page({\nparams,\nsearchParams,\n}: {\nparams: Promise<{ slug: string }>\nsearchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}) {\nconst { slug } = use(params)\nconst { query } = use(searchParams)\n}\nVersion History\n| Version | Changes |\n|---|---|\nv15.0.0-RC | params and searchParams are now promises. A codemod is available. |\nv13.0.0 | page introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/route", "title": "File Conventions: route.js | Next.js", "text": "route.js\nRoute Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs.\nroute.ts\nexport async function GET() {\nreturn Response.json({ message: 'Hello World' })\n}\nReference\nHTTP Methods\nA route file allows you to create custom request handlers for a given route. The following HTTP methods are supported: GET\n, POST\n, PUT\n, PATCH\n, DELETE\n, HEAD\n, and OPTIONS\n.\nroute.ts\nexport async function GET(request: Request) {}\nexport async function HEAD(request: Request) {}\nexport async function POST(request: Request) {}\nexport async function PUT(request: Request) {}\nexport async function DELETE(request: Request) {}\nexport async function PATCH(request: Request) {}\n// If `OPTIONS` is not defined, Next.js will automatically implement `OPTIONS` and set the appropriate Response `Allow` header depending on the other methods defined in the Route Handler.\nexport async function OPTIONS(request: Request) {}\nParameters\nrequest\n(optional)\nThe request\nobject is a NextRequest object, which is an extension of the Web Request API. NextRequest\ngives you further control over the incoming request, including easily accessing cookies\nand an extended, parsed, URL object nextUrl\n.\nroute.ts\nimport type { NextRequest } from 'next/server'\nexport async function GET(request: NextRequest) {\nconst url = request.nextUrl\n}\ncontext\n(optional)\nparams\n: a promise that resolves to an object containing the dynamic route parameters for the current route.\napp/dashboard/[team]/route.ts\nexport async function GET(\nrequest: Request,\n{ params }: { params: Promise<{ team: string }> }\n) {\nconst team = (await params).team\n}\n| Example | URL | params |\n|---|---|---|\napp/dashboard/[team]/route.js | /dashboard/1 | Promise<{ team: '1' }> |\napp/shop/[tag]/[item]/route.js | /shop/1/2 | Promise<{ tag: '1', item: '2' }> |\napp/blog/[...slug]/route.js | /blog/1/2 | Promise<{ slug: ['1', '2'] }> |\nExamples\nHandling cookies\nroute.ts\nimport { cookies } from 'next/headers'\nexport async function GET(request: NextRequest) {\nconst cookieStore = await cookies()\nconst a = cookieStore.get('a')\nconst b = cookieStore.set('b', '1')\nconst c = cookieStore.delete('c')\n}\nVersion History\n| Version | Changes |\n|---|---|\nv15.0.0-RC | context.params is now a promise. A codemod is available |\nv15.0.0-RC | The default caching for GET handlers was changed from static to dynamic |\nv13.2.0 | Route Handlers are introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/template", "title": "File Conventions: template.js | Next.js", "text": "template.js\nA template file is similar to a layout in that it wraps a layout or page. Unlike layouts that persist across routes and maintain state, templates are given a unique key, meaning children Client Components reset their state on navigation.\napp/template.tsx\nexport default function Template({ children }: { children: React.ReactNode }) {\nreturn <div>{children}</div>\n}\nWhile less common, you might choose to use a template over a layout if you want:\n- Features that rely on\nuseEffect\n(e.g logging page views) anduseState\n(e.g a per-page feedback form). - To change the default framework behavior. For example, Suspense Boundaries inside layouts only show the fallback the first time the Layout is loaded and not when switching pages. For templates, the fallback is shown on each navigation.\nProps\nchildren\n(required)\nTemplate accepts a children\nprop. For example:\nOutput\n<Layout>\n{/* Note that the template is automatically given a unique key. */}\n<Template key={routeParam}>{children}</Template>\n</Layout>\nGood to know:\n- By default,\ntemplate\nis a Server Component, but can also be used as a Client Component through the\"use client\"\ndirective.- When a user navigates between routes that share a\ntemplate\n, a new instance of the component is mounted, DOM elements are recreated, state is not preserved in Client Components, and effects are re-synchronized.\nVersion History\n| Version | Changes |\n|---|---|\nv13.0.0 | template introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized", "title": "File Conventions: unauthorized.js | Next.js", "text": "unauthorized.js\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\nThe unauthorized file is used to render UI when the unauthorized\nfunction is invoked during authentication. Along with allowing you to customize the UI, Next.js will return a 401\nstatus code.\napp/unauthorized.tsx\nimport Login from '@/app/components/Login'\nexport default function Unauthorized() {\nreturn (\n<main>\n<h1>401 - Unauthorized</h1>\n<p>Please log in to access this page.</p>\n<Login />\n</main>\n)\n}\nReference\nProps\nunauthorized.js\ncomponents do not accept any props.\nExamples\nDisplaying login UI to unauthenticated users\nYou can use unauthorized\nfunction to render the unauthorized.js\nfile with a login UI.\napp/dashboard/page.tsx\nimport { verifySession } from '@/app/lib/dal'\nimport { unauthorized } from 'next/server'\nexport default async function DashboardPage() {\nconst session = await verifySession()\nif (!session) {\nunauthorized()\n}\nreturn <div>Dashboard</div>\n}\napp/unauthorized.tsx\nimport Login from '@/app/components/Login'\nexport default function UnauthorizedPage() {\nreturn (\n<main>\n<h1>401 - Unauthorized</h1>\n<p>Please log in to access this page.</p>\n<Login />\n</main>\n)\n}\nVersion History\n| Version | Changes |\n|---|---|\nv15.1.0 | unauthorized.js introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions", "title": "API Reference: Functions | Next.js", "text": "Functions\nafter\nAPI Reference for the after function.\ncacheLife\nLearn how to use the cacheLife function to set the cache expiration time for a cached function or component.\ncacheTag\nLearn how to use the cacheTag function to manage cache invalidation in your Next.js application.\nconnection\nAPI Reference for the connection function.\ncookies\nAPI Reference for the cookies function.\ndraftMode\nAPI Reference for the draftMode function.\nfetch\nAPI reference for the extended fetch function.\nforbidden\nAPI Reference for the forbidden function.\ngenerateImageMetadata\nLearn how to generate multiple images in a single Metadata API special file.\ngenerateMetadata\nLearn how to add Metadata to your Next.js application for improved search engine optimization (SEO) and web shareability.\ngenerateSitemaps\nLearn how to use the generateSiteMaps function to create multiple sitemaps for your application.\ngenerateStaticParams\nAPI reference for the generateStaticParams function.\ngenerateViewport\nAPI Reference for the generateViewport function.\nheaders\nAPI reference for the headers function.\nImageResponse\nAPI Reference for the ImageResponse constructor.\nNextRequest\nAPI Reference for NextRequest.\nNextResponse\nAPI Reference for NextResponse.\nnotFound\nAPI Reference for the notFound function.\npermanentRedirect\nAPI Reference for the permanentRedirect function.\nredirect\nAPI Reference for the redirect function.\nrevalidatePath\nAPI Reference for the revalidatePath function.\nrevalidateTag\nAPI Reference for the revalidateTag function.\nunauthorized\nAPI Reference for the unauthorized function.\nunstable_cache\nAPI Reference for the unstable_cache function.\nunstable_expirePath\nAPI Reference for the unstable_expirePath function.\nunstable_expireTag\nAPI Reference for the unstable_expireTag function.\nunstable_noStore\nAPI Reference for the unstable_noStore function.\nunstable_rethrow\nAPI Reference for the unstable_rethrow function.\nuseParams\nAPI Reference for the useParams hook.\nusePathname\nAPI Reference for the usePathname hook.\nuseReportWebVitals\nAPI Reference for the useReportWebVitals function.\nuseRouter\nAPI reference for the useRouter hook.\nuseSearchParams\nAPI Reference for the useSearchParams hook.\nuseSelectedLayoutSegment\nAPI Reference for the useSelectedLayoutSegment hook.\nuseSelectedLayoutSegments\nAPI Reference for the useSelectedLayoutSegments hook.\nuserAgent\nThe userAgent helper extends the Web Request API with additional properties and methods to interact with the user agent object from the request.\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/after", "title": "Functions: after | Next.js", "text": "after\nafter\nallows you to schedule work to be executed after a response (or prerender) is finished. This is useful for tasks and other side effects that should not block the response, such as logging and analytics.\nIt can be used in Server Components (including generateMetadata\n), Server Actions, Route Handlers, and Middleware.\nThe function accepts a callback that will be executed after the response (or prerender) is finished:\nimport { after } from 'next/server'\n// Custom logging function\nimport { log } from '@/app/utils'\nexport default function Layout({ children }: { children: React.ReactNode }) {\nafter(() => {\n// Execute after the layout is rendered and sent to the user\nlog()\n})\nreturn <>{children}</>\n}\nGood to know:\nafter\nis not a Dynamic API and calling it does not cause a route to become dynamic. If it's used within a static page, the callback will execute at build time, or whenever a page is revalidated.\nReference\nParameters\n- A callback function which will be executed after the response (or prerender) is finished.\nDuration\nafter\nwill run for the platform's default or configured max duration of your route. If your platform supports it, you can configure the timeout limit using the maxDuration\nroute segment config.\nGood to know\nafter\nwill be executed even if the response didn't complete successfully. Including when an error is thrown or whennotFound\norredirect\nis called.- You can use React\ncache\nto deduplicate functions called insideafter\n. after\ncan be nested inside otherafter\ncalls, for example, you can create utility functions that wrapafter\ncalls to add additional functionality.\nAlternatives\nThe use case for after\nis to process secondary tasks without blocking the primary response. It's similar to using the platform's waitUntil()\nor removing await\nfrom a promise, but with the following differences:\nwaitUntil()\n: accepts a promise and enqueues a task to be executed during the lifecycle of the request, whereasafter\naccepts a callback that will be executed after the response is finished.- Removing\nawait\n: starts executing during the response, which uses resources. It's also not reliable in serverless environments as the function stops computation immediately after the response is sent, potentially interrupting the task.\nWe recommend using after\nas it has been designed to consider other Next.js APIs and contexts.\nExamples\nWith request APIs\nYou can use request APIs such as cookies\nand headers\ninside after\nin Server Actions and Route Handlers. This is useful for logging activity after a mutation. For example:\nimport { after } from 'next/server'\nimport { cookies, headers } from 'next/headers'\nimport { logUserAction } from '@/app/utils'\nexport async function POST(request: Request) {\n// Perform mutation\n// ...\n// Log user activity for analytics\nafter(async () => {\nconst userAgent = (await headers().get('user-agent')) || 'unknown'\nconst sessionCookie =\n(await cookies().get('session-id'))?.value || 'anonymous'\nlogUserAction({ sessionCookie, userAgent })\n})\nreturn new Response(JSON.stringify({ status: 'success' }), {\nstatus: 200,\nheaders: { 'Content-Type': 'application/json' },\n})\n}\nHowever, you cannot use these request APIs inside after\nin Server Components. This is because Next.js needs to know which part of the tree access the request APIs to support Partial Prerendering, but after\nruns after React's rendering lifecycle.\n| Version History | Description |\n|---|---|\nv15.1.0 | after became stable. |\nv15.0.0-rc | unstable_after introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/cacheLife", "title": "Functions: cacheLife | Next.js", "text": "cacheLife\nThe cacheLife\nfunction is used to set the cache lifetime of a function or component. It should be used alongside the use cache\ndirective, and within the scope of the function or component.\nUsage\nTo use cacheLife\n, enable the dynamicIO\nflag in your next.config.js\nfile:\nimport type { NextConfig } from 'next'\nconst nextConfig: NextConfig = {\nexperimental: {\ndynamicIO: true,\n},\n}\nexport default nextConfig\nThen, import and invoke the cacheLife\nfunction within the scope of the function or component:\n'use cache'\nimport { unstable_cacheLife as cacheLife } from 'next/cache'\nexport default async function Page() {\ncacheLife('hours')\nreturn <div>Page</div>\n}\nReference\nDefault cache profiles\nNext.js provides a set of named cache profiles modeled on various timescales. If you don't specify a cache profile in the cacheLife\nfunction alongside the use cache\ndirective, Next.js will automatically apply the \u201cdefault\u201d cache profile.\nHowever, we recommend always adding a cache profile when using the use cache\ndirective to explicitly define caching behavior.\n| Profile | Stale | Revalidate | Expire | Description |\n|---|---|---|---|---|\ndefault | undefined | 15 minutes | INFINITE_CACHE | Default profile, suitable for content that doesn't need frequent updates |\nseconds | undefined | 1 second | 1 minute | For rapidly changing content requiring near real-time updates |\nminutes | 5 minutes | 1 minute | 1 hour | For content that updates frequently within an hour |\nhours | 5 minutes | 1 hour | 1 day | For content that updates daily but can be slightly stale |\ndays | 5 minutes | 1 day | 1 week | For content that updates weekly but can be a day old |\nweeks | 5 minutes | 1 week | 1 month | For content that updates monthly but can be a week old |\nmax | 5 minutes | 1 month | INFINITE_CACHE | For very stable content that rarely needs updating |\nThe string values used to reference cache profiles don't carry inherent meaning; instead they serve as semantic labels. This allows you to better understand and manage your cached content within your codebase.\nCustom cache profiles\nYou can configure custom cache profiles by adding them to the cacheLife\noption in your next.config.ts\nfile.\nCache profiles are objects that contain the following properties:\n| Property | Value | Description | Requirement |\n|---|---|---|---|\nstale | number | Duration the client should cache a value without checking the server. | Optional |\nrevalidate | number | Frequency at which the cache should refresh on the server; stale values may be served while revalidating. | Optional |\nexpire | number | Maximum duration for which a value can remain stale before switching to dynamic fetching; must be longer than revalidate . | Optional - Must be longer than revalidate |\nThe \"stale\" property differs from the staleTimes\nsetting in that it specifically controls client-side router caching. While staleTimes\nis a global setting that affects all instances of both dynamic and static data, the cacheLife\nconfiguration allows you to define \"stale\" times on a per-function or per-route basis.\nGood to know: The \u201cstale\u201d property does not set the\nCache-control: max-age\nheader. It instead controls the client-side router cache.\nExamples\nDefining reusable cache profiles\nYou can create a reusable cache profile by defining them in your next.config.ts\nfile. Choose a name that suits your use case and set values for the stale\n, revalidate\n, and expire\nproperties. You can create as many custom cache profiles as needed. Each profile can be referenced by its name as a string value passed to the cacheLife\nfunction.\nimport type { NextConfig } from 'next'\nconst nextConfig: NextConfig = {\nexperimental: {\ndynamicIO: true,\ncacheLife: {\nbiweekly: {\nstale: 60 * 60 * 24 * 14, // 14 days\nrevalidate: 60 * 60 * 24, // 1 day\nexpire: 60 * 60 * 24 * 14, // 14 days\n},\n},\n},\n}\nmodule.exports = nextConfig\nThe example above caches for 14 days, checks for updates daily, and expires the cache after 14 days. You can then reference this profile throughout your application by its name:\n'use cache'\nimport { unstable_cacheLife as cacheLife } from 'next/cache'\nexport default async function Page() {\ncacheLife('biweekly')\nreturn <div>Page</div>\n}\nOverriding the default cache profiles\nWhile the default cache profiles provide a useful way to think about how fresh or stale any given part of cacheable output can be, you may prefer different named profiles to better align with your applications caching strategies.\nYou can override the default named cache profiles by creating a new configuration with the same name as the defaults.\nThe example below shows how to override the default \u201cdays\u201d cache profile:\nconst nextConfig = {\nexperimental: {\ndynamicIO: true,\ncacheLife: {\ndays: {\nstale: 3600, // 1 hour\nrevalidate: 900, // 15 minutes\nexpire: 86400, // 1 day\n},\n},\n},\n}\nmodule.exports = nextConfig\nDefining cache profiles inline\nFor specific use cases, you can set a custom cache profile by passing an object to the cacheLife\nfunction:\n'use cache'\nimport { unstable_cacheLife as cacheLife } from 'next/cache'\nexport default async function Page() {\ncacheLife({\nstale: 3600, // 1 hour\nrevalidate: 900, // 15 minutes\nexpire: 86400, // 1 day\n})\nreturn <div>Page</div>\n}\nThis inline cache profile will only be applied to the function or file it was created in. If you want to reuse the same profile throughout your application, you can add the configuration to the cacheLife\nproperty of your next.config.ts\nfile.\nNested usage of use cache\nand cacheLife\nWhen defining multiple caching behaviors in the same route or component tree, if the inner caches specify their own cacheLife\nprofile, the outer cache will respect the shortest cache duration among them. This applies only if the outer cache does not have its own explicit cacheLife\nprofile defined.\nFor example, if you add the use cache\ndirective to your page, without specifying a cache profile, the default cache profile will be applied implicitly (cacheLife(\u201ddefault\u201d)\n). If a component imported into the page also uses the use cache\ndirective with its own cache profile, the outer and inner cache profiles are compared, and shortest duration set in the profiles will be applied.\n// Parent component\nimport { unstable_cacheLife as cacheLife } from 'next/cache'\nimport { ChildComponent } from './child'\nexport async function ParentComponent() {\n'use cache'\ncacheLife('days')\nreturn (\n<div>\n<ChildComponent />\n</div>\n)\n}\nAnd in a separate file, we defined the Child component that was imported:\n// Child component\nimport { unstable_cacheLife as cacheLife } from 'next/cache'\nexport async function ChildComponent() {\n'use cache'\ncacheLife('hours')\nreturn <div>Child Content</div>\n// This component's cache will respect the shorter 'hours' profile\n}\nRelated\ndynamicIO\nuse cache\nrevalidateTag\ncacheTag\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/cacheTag", "title": "Functions: cacheTag | Next.js", "text": "cacheTag\nThis feature is currently available in the canary channel and subject to change. Try it out by upgrading Next.js, and share your feedback on GitHub.\nThe cacheTag\nfunction allows you to tag cached data for on-demand invalidation. By associating tags with cache entries, you can selectively purge or revalidate specific cache entries without affecting other cached data.\nUsage\nTo use cacheTag\n, enable the dynamicIO\nflag in your next.config.js\nfile:\nnext.config.ts\nimport type { NextConfig } from 'next'\nconst nextConfig: NextConfig = {\nexperimental: {\ndynamicIO: true,\n},\n}\nexport default nextConfig\nThe cacheTag\nfunction takes a single string value, or a string array.\napp/data.ts\nimport { unstable_cacheTag as cacheTag } from 'next/cache'\nexport async function getData() {\n'use cache'\ncacheTag('my-data')\nconst data = await fetch('/api/data')\nreturn data\n}\nYou can then purge the cache on-demand using revalidateTag\nAPI in another function, for example, a route handler or Server Action:\napp/action.ts\n'use server'\nimport { revalidateTag } from 'next/cache'\nexport default async function submit() {\nawait addPost()\nrevalidateTag('my-data')\n}\nGood to know\n- Idempotent Tags: Applying the same tag multiple times has no additional effect.\n- Multiple Tags: You can assign multiple tags to a single cache entry by passing an array to\ncacheTag\n.\ncacheTag('tag-one', 'tag-two')\nExamples\nTagging components or functions\nTag your cached data by calling cacheTag\nwithin a cached function or component:\napp/components/bookings.tsx\nimport { unstable_cacheTag as cacheTag } from 'next/cache'\ninterface BookingsProps {\ntype: string\n}\nexport async function Bookings({ type = 'haircut' }: BookingsProps) {\n'use cache'\ncacheTag('bookings-data')\nasync function getBookingsData() {\nconst data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)\nreturn data\n}\nreturn //...\n}\nCreating tags from external data\nYou can use the data returned from an async function to tag the cache entry.\napp/components/bookings.tsx\nimport { unstable_cacheTag as cacheTag } from 'next/cache'\ninterface BookingsProps {\ntype: string\n}\nexport async function Bookings({ type = 'haircut' }: BookingsProps) {\nasync function getBookingsData() {\n'use cache'\nconst data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)\ncacheTag('bookings-data', data.id)\nreturn data\n}\nreturn //...\n}\nInvalidating tagged cache\nUsing revalidateTag\n, you can invalidate the cache for a specific tag when needed:\napp/actions.ts\n'use server'\nimport { revalidateTag } from 'next/cache'\nexport async function updateBookings() {\nawait updateBookingData()\nrevalidateTag('bookings-data')\n}\nRelated\nView related API references.\ndynamicIO\nLearn how to enable the dynamicIO flag in Next.js.\nuse cache\nLearn how to use the use cache directive to cache data in your Next.js application.\nrevalidateTag\nAPI Reference for the revalidateTag function.\ncacheLife\nLearn how to use the cacheLife function to set the cache expiration time for a cached function or component.\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/connection", "title": "Functions: connection | Next.js", "text": "connection\nThe connection()\nfunction allows you to indicate rendering should wait for an incoming user request before continuing.\nIt's useful when a component doesn\u2019t use Dynamic APIs, but you want it to be dynamically rendered at runtime and not statically rendered at build time. This usually occurs when you access external information that you intentionally want to change the result of a render, such as Math.random()\nor new Date()\n.\napp/page.tsx\nimport { connection } from 'next/server'\nexport default async function Page() {\nawait connection()\n// Everything below will be excluded from prerendering\nconst rand = Math.random()\nreturn <span>{rand}</span>\n}\nReference\nType\nfunction connection(): Promise<void>\nParameters\n- The function does not accept any parameters.\nReturns\n- The function returns a\nvoid\nPromise. It is not meant to be consumed.\nGood to know\nconnection\nreplacesunstable_noStore\nto better align with the future of Next.js.- The function is only necessary when dynamic rendering is required and common Dynamic APIs are not used.\nVersion History\n| Version | Changes |\n|---|---|\nv15.0.0 | connection stabilized. |\nv15.0.0-RC | connection introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/cookies", "title": "Functions: cookies | Next.js", "text": "cookies\ncookies\nis an async function that allows you to read the HTTP incoming request cookies in Server Component, and read/write outgoing request cookies in Server Actions or Route Handlers.\nimport { cookies } from 'next/headers'\nexport default async function Page() {\nconst cookieStore = await cookies()\nconst theme = cookieStore.get('theme')\nreturn '...'\n}\nReference\nMethods\nThe following methods are available:\n| Method | Return Type | Description |\n|---|---|---|\nget('name') | Object | Accepts a cookie name and returns an object with the name and value. |\ngetAll() | Array of objects | Returns a list of all the cookies with a matching name. |\nhas('name') | Boolean | Accepts a cookie name and returns a boolean based on if the cookie exists. |\nset(name, value, options) | - | Accepts a cookie name, value, and options and sets the outgoing request cookie. |\ndelete(name) | - | Accepts a cookie name and deletes the cookie. |\nclear() | - | Deletes all cookies. |\ntoString() | String | Returns a string representation of the cookies. |\nOptions\nWhen setting a cookie, the following properties from the options\nobject are supported:\n| Option | Type | Description |\n|---|---|---|\nname | String | Specifies the name of the cookie. |\nvalue | String | Specifies the value to be stored in the cookie. |\nexpires | Date | Defines the exact date when the cookie will expire. |\nmaxAge | Number | Sets the cookie\u2019s lifespan in seconds. |\ndomain | String | Specifies the domain where the cookie is available. |\npath | String, default: '/' | Limits the cookie's scope to a specific path within the domain. |\nsecure | Boolean | Ensures the cookie is sent only over HTTPS connections for added security. |\nhttpOnly | Boolean | Restricts the cookie to HTTP requests, preventing client-side access. |\nsameSite | Boolean, 'lax' , 'strict' , 'none' | Controls the cookie's cross-site request behavior. |\npriority | String (\"low\" , \"medium\" , \"high\" ) | Specifies the cookie's priority |\nencode('value') | Function | Specifies a function that will be used to encode a cookie's value. |\npartitioned | Boolean | Indicates whether the cookie is partitioned. |\nThe only option with a default value is path\n.\nTo learn more about these options, see the MDN docs.\nGood to know\ncookies\nis an asynchronous function that returns a promise. You must useasync/await\nor React'suse\nfunction to access cookies.- In version 14 and earlier,\ncookies\nwas a synchronous function. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.\n- In version 14 and earlier,\ncookies\nis a Dynamic API whose returned values cannot be known ahead of time. Using it in a layout or page will opt a route into dynamic rendering.- The\n.delete\nmethod can only be called:- In a Server Action or Route Handler.\n- If it belongs to the same domain from which\n.set\nis called. Additionally, the code must be executed on the same protocol (HTTP or HTTPS) as the cookie you want to delete.\n- HTTP does not allow setting cookies after streaming starts, so you must use\n.set\nin a Server Action or Route Handler.\nUnderstanding Cookie Behavior in Server Components\nWhen working with cookies in Server Components, it's important to understand that cookies are fundamentally a client-side storage mechanism:\n- Reading cookies works in Server Components because you're accessing the cookie data that the client's browser sends to the server in the HTTP request headers.\n- Setting cookies cannot be done directly in a Server Component, even when using a Route Handler or Server Action. This is because cookies are actually stored by the browser, not the server.\nThe server can only send instructions (via Set-Cookie\nheaders) to tell the browser to store cookies - the actual storage happens on the client side. This is why cookie operations that modify state (.set\n, .delete\n, .clear\n) must be performed in a Route Handler or Server Action where the response headers can be properly set.\nExamples\nGetting a cookie\nYou can use the (await cookies()).get('name')\nmethod to get a single cookie:\nimport { cookies } from 'next/headers'\nexport default async function Page() {\nconst cookieStore = await cookies()\nconst theme = cookieStore.get('theme')\nreturn '...'\n}\nGetting all cookies\nYou can use the (await cookies()).getAll()\nmethod to get all cookies with a matching name. If name\nis unspecified, it returns all the available cookies.\nimport { cookies } from 'next/headers'\nexport default async function Page() {\nconst cookieStore = await cookies()\nreturn cookieStore.getAll().map((cookie) => (\n<div key={cookie.name}>\n<p>Name: {cookie.name}</p>\n<p>Value: {cookie.value}</p>\n</div>\n))\n}\nSetting a cookie\nYou can use the (await cookies()).set(name, value, options)\nmethod in a Server Action or Route Handler to set a cookie. The options\nobject is optional.\n'use server'\nimport { cookies } from 'next/headers'\nexport async function create(data) {\nconst cookieStore = await cookies()\ncookieStore.set('name', 'lee')\n// or\ncookieStore.set('name', 'lee', { secure: true })\n// or\ncookieStore.set({\nname: 'name',\nvalue: 'lee',\nhttpOnly: true,\npath: '/',\n})\n}\nChecking if a cookie exists\nYou can use the (await cookies()).has(name)\nmethod to check if a cookie exists:\nimport { cookies } from 'next/headers'\nexport default async function Page() {\nconst cookieStore = await cookies()\nconst hasCookie = cookieStore.has('theme')\nreturn '...'\n}\nDeleting cookies\nThere are three ways you can delete a cookie.\nUsing the delete()\nmethod:\n'use server'\nimport { cookies } from 'next/headers'\nexport async function delete(data) {\n(await cookies()).delete('name')\n}\nSetting a new cookie with the same name and an empty value:\n'use server'\nimport { cookies } from 'next/headers'\nexport async function delete(data) {\n(await cookies()).set('name', '')\n}\nSetting the maxAge\nto 0 will immediately expire a cookie. maxAge\naccepts a value in seconds.\n'use server'\nimport { cookies } from 'next/headers'\nexport async function delete(data) {\n(await cookies()).set('name', 'value', { maxAge: 0 })\n}\nVersion History\n| Version | Changes |\n|---|---|\nv15.0.0-RC | cookies is now an async function. A codemod is available. |\nv13.0.0 | cookies introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/draft-mode", "title": "Functions: draftMode | Next.js", "text": "draftMode\ndraftMode\nis an async function allows you to enable and disable Draft Mode, as well as check if Draft Mode is enabled in a Server Component.\napp/page.ts\nimport { draftMode } from 'next/headers'\nexport default async function Page() {\nconst { isEnabled } = await draftMode()\n}\nReference\nThe following methods and properties are available:\n| Method | Description |\n|---|---|\nisEnabled | A boolean value that indicates if Draft Mode is enabled. |\nenable() | Enables Draft Mode in a Route Handler by setting a cookie (__prerender_bypass ). |\ndisable() | Disables Draft Mode in a Route Handler by deleting a cookie. |\nGood to know\ndraftMode\nis an asynchronous function that returns a promise. You must useasync/await\nor React'suse\nfunction.- In version 14 and earlier,\ndraftMode\nwas a synchronous function. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.\n- In version 14 and earlier,\n- A new bypass cookie value will be generated each time you run\nnext build\n. This ensures that the bypass cookie can\u2019t be guessed. - To test Draft Mode locally over HTTP, your browser will need to allow third-party cookies and local storage access.\nExamples\nEnabling Draft Mode\nTo enable Draft Mode, create a new Route Handler and call the enable()\nmethod:\napp/draft/route.ts\nimport { draftMode } from 'next/headers'\nexport async function GET(request: Request) {\nconst draft = await draftMode()\ndraft().enable()\nreturn new Response('Draft mode is enabled')\n}\nDisabling Draft Mode\nBy default, the Draft Mode session ends when the browser is closed.\nTo disable Draft Mode manually, call the disable()\nmethod in your Route Handler:\napp/draft/route.ts\nimport { draftMode } from 'next/headers'\nexport async function GET(request: Request) {\nconst draft = await draftMode()\ndraft().disable()\nreturn new Response('Draft mode is disabled')\n}\nThen, send a request to invoke the Route Handler. If calling the route using the <Link>\ncomponent, you must pass prefetch={false}\nto prevent accidentally deleting the cookie on prefetch.\nChecking if Draft Mode is enabled\nYou can check if Draft Mode is enabled in a Server Component with the isEnabled\nproperty:\napp/page.ts\nimport { draftMode } from 'next/headers'\nexport default async function Page() {\nconst { isEnabled } = await draftMode()\nreturn (\n<main>\n<h1>My Blog Post</h1>\n<p>Draft Mode is currently {isEnabled ? 'Enabled' : 'Disabled'}</p>\n</main>\n)\n}\nVersion History\n| Version | Changes |\n|---|---|\nv15.0.0-RC | draftMode is now an async function. A codemod is available. |\nv13.4.0 | draftMode introduced. |\nNext Steps\nLearn how to use Draft Mode with this step-by-step guide.\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/fetch", "title": "Functions: fetch | Next.js", "text": "fetch\nNext.js extends the Web fetch()\nAPI to allow each request on the server to set its own persistent caching and revalidation semantics.\nIn the browser, the cache\noption indicates how a fetch request will interact with the browser's HTTP cache. With this extension, cache\nindicates how a server-side fetch request will interact with the framework's persistent Data Cache.\nYou can call fetch\nwith async\nand await\ndirectly within Server Components.\nexport default async function Page() {\nlet data = await fetch('https://api.vercel.app/blog')\nlet posts = await data.json()\nreturn (\n<ul>\n{posts.map((post) => (\n<li key={post.id}>{post.title}</li>\n))}\n</ul>\n)\n}\nfetch(url, options)\nSince Next.js extends the Web fetch()\nAPI, you can use any of the native options available.\noptions.cache\nConfigure how the request should interact with Next.js Data Cache.\nfetch(`https://...`, { cache: 'force-cache' | 'no-store' })\nauto no cache\n(default): Next.js fetches the resource from the remote server on every request in development, but will fetch once duringnext build\nbecause the route will be statically prerendered. If Dynamic APIs are detected on the route, Next.js will fetch the resource on every request.no-store\n: Next.js fetches the resource from the remote server on every request, even if Dynamic APIs are not detected on the route.force-cache\n: Next.js looks for a matching request in its Data Cache.- If there is a match and it is fresh, it will be returned from the cache.\n- If there is no match or a stale match, Next.js will fetch the resource from the remote server and update the cache with the downloaded resource.\noptions.next.revalidate\nfetch(`https://...`, { next: { revalidate: false | 0 | number } })\nSet the cache lifetime of a resource (in seconds).\nfalse\n- Cache the resource indefinitely. Semantically equivalent torevalidate: Infinity\n. The HTTP cache may evict older resources over time.0\n- Prevent the resource from being cached.number\n- (in seconds) Specify the resource should have a cache lifetime of at mostn\nseconds.\nGood to know:\n- If an individual\nfetch()\nrequest sets arevalidate\nnumber lower than the defaultrevalidate\nof a route, the whole route revalidation interval will be decreased.- If two fetch requests with the same URL in the same route have different\nrevalidate\nvalues, the lower value will be used.- As a convenience, it is not necessary to set the\ncache\noption ifrevalidate\nis set to a number.- Conflicting options such as\n{ revalidate: 3600, cache: 'no-store' }\nwill cause an error.\noptions.next.tags\nfetch(`https://...`, { next: { tags: ['collection'] } })\nSet the cache tags of a resource. Data can then be revalidated on-demand using revalidateTag\n. The max length for a custom tag is 256 characters and the max tag items is 128.\nTroubleshooting\nFetch default auto no store\nand cache: 'no-store'\nnot showing fresh data in development\nNext.js caches fetch\nresponses in Server Components across Hot Module Replacement (HMR) in local development for faster responses and to reduce costs for billed API calls.\nBy default, the HMR cache applies to all fetch requests, including those with the default auto no cache\nand cache: 'no-store'\noption. This means uncached requests will not show fresh data between HMR refreshes. However, the cache will be cleared on navigation or full-page reloads.\nSee the serverComponentsHmrCache\ndocs for more information.\nVersion History\n| Version | Changes |\n|---|---|\nv13.0.0 | fetch introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/forbidden", "title": "Functions: forbidden | Next.js", "text": "forbidden\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\nThe forbidden\nfunction throws an error that renders a Next.js 403 error page. It's useful for handling authorization errors in your application. You can customize the UI using the forbidden.js\nfile.\nTo start using forbidden\n, enable the experimental authInterrupts\nconfiguration option in your next.config.js\nfile:\nnext.config.ts\nimport type { NextConfig } from 'next'\nconst nextConfig: NextConfig = {\nexperimental: {\nauthInterrupts: true,\n},\n}\nexport default nextConfig\nforbidden\ncan be invoked in Server Components, Server Actions, and Route Handlers.\napp/auth/page.tsx\nimport { verifySession } from '@/app/lib/dal'\nimport { forbidden } from 'next/navigation'\nexport default async function AdminPage() {\nconst session = await verifySession()\n// Check if the user has the 'admin' role\nif (session.role !== 'admin') {\nforbidden()\n}\n// Render the admin page for authorized users\nreturn <></>\n}\nGood to know\n- The\nforbidden\nfunction cannot be called in the root layout.\nExamples\nRole-based route protection\nYou can use forbidden\nto restrict access to certain routes based on user roles. This ensures that users who are authenticated but lack the required permissions cannot access the route.\napp/admin/page.tsx\nimport { verifySession } from '@/app/lib/dal'\nimport { forbidden } from 'next/navigation'\nexport default async function AdminPage() {\nconst session = await verifySession()\n// Check if the user has the 'admin' role\nif (session.role !== 'admin') {\nforbidden()\n}\n// Render the admin page for authorized users\nreturn (\n<main>\n<h1>Admin Dashboard</h1>\n<p>Welcome, {session.user.name}!</p>\n</main>\n)\n}\nMutations with Server Actions\nWhen implementing mutations in Server Actions, you can use forbidden\nto only allow users with a specific role to update sensitive data.\napp/actions/update-role.ts\n'use server'\nimport { verifySession } from '@/app/lib/dal'\nimport { forbidden } from 'next/navigation'\nimport db from '@/app/lib/db'\nexport async function updateRole(formData: FormData) {\nconst session = await verifySession()\n// Ensure only admins can update roles\nif (session.role !== 'admin') {\nforbidden()\n}\n// Perform the role update for authorized users\n// ...\n}\nVersion History\n| Version | Changes |\n|---|---|\nv15.1.0 | forbidden introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/generate-image-metadata", "title": "Functions: generateImageMetadata | Next.js", "text": "generateImageMetadata\nYou can use generateImageMetadata\nto generate different versions of one image or return multiple images for one route segment. This is useful for when you want to avoid hard-coding metadata values, such as for icons.\nParameters\ngenerateImageMetadata\nfunction accepts the following parameters:\nparams\n(optional)\nAn object containing the dynamic route parameters object from the root segment down to the segment generateImageMetadata\nis called from.\nexport function generateImageMetadata({\nparams,\n}: {\nparams: { slug: string }\n}) {\n// ...\n}\n| Route | URL | params |\n|---|---|---|\napp/shop/icon.js | /shop | undefined |\napp/shop/[slug]/icon.js | /shop/1 | { slug: '1' } |\napp/shop/[tag]/[item]/icon.js | /shop/1/2 | { tag: '1', item: '2' } |\nReturns\nThe generateImageMetadata\nfunction should return an array\nof objects containing the image's metadata such as alt\nand size\n. In addition, each item must include an id\nvalue which will be passed to the props of the image generating function.\n| Image Metadata Object | Type |\n|---|---|\nid | string (required) |\nalt | string |\nsize | { width: number; height: number } |\ncontentType | string |\nimport { ImageResponse } from 'next/og'\nexport function generateImageMetadata() {\nreturn [\n{\ncontentType: 'image/png',\nsize: { width: 48, height: 48 },\nid: 'small',\n},\n{\ncontentType: 'image/png',\nsize: { width: 72, height: 72 },\nid: 'medium',\n},\n]\n}\nexport default function Icon({ id }: { id: string }) {\nreturn new ImageResponse(\n(\n<div\nstyle={{\nwidth: '100%',\nheight: '100%',\ndisplay: 'flex',\nalignItems: 'center',\njustifyContent: 'center',\nfontSize: 88,\nbackground: '#000',\ncolor: '#fafafa',\n}}\n>\nIcon {id}\n</div>\n)\n)\n}\nExamples\nUsing external data\nThis example uses the params\nobject and external data to generate multiple Open Graph images for a route segment.\nimport { ImageResponse } from 'next/og'\nimport { getCaptionForImage, getOGImages } from '@/app/utils/images'\nexport async function generateImageMetadata({\nparams,\n}: {\nparams: { id: string }\n}) {\nconst images = await getOGImages(params.id)\nreturn images.map((image, idx) => ({\nid: idx,\nsize: { width: 1200, height: 600 },\nalt: image.text,\ncontentType: 'image/png',\n}))\n}\nexport default async function Image({\nparams,\nid,\n}: {\nparams: { id: string }\nid: number\n}) {\nconst productId = (await params).id\nconst imageId = id\nconst text = await getCaptionForImage(productId, imageId)\nreturn new ImageResponse(\n(\n<div\nstyle={\n{\n// ...\n}\n}\n>\n{text}\n</div>\n)\n)\n}\nVersion History\n| Version | Changes |\n|---|---|\nv13.3.0 | generateImageMetadata introduced. |\nNext Steps\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/generate-metadata", "title": "Functions: generateMetadata | Next.js", "text": "generateMetadata\nThis page covers all Config-based Metadata options with generateMetadata\nand the static metadata object.\nimport type { Metadata } from 'next'\n// either Static metadata\nexport const metadata: Metadata = {\ntitle: '...',\n}\n// or Dynamic metadata\nexport async function generateMetadata({ params }) {\nreturn {\ntitle: '...',\n}\n}\nGood to know:\n- The\nmetadata\nobject andgenerateMetadata\nfunction exports are only supported in Server Components.- You cannot export both the\nmetadata\nobject andgenerateMetadata\nfunction from the same route segment.- On the initial load, streaming is blocked until\ngenerateMetadata\nhas fully resolved, including any content fromloading.js\n.\nThe metadata\nobject\nTo define static metadata, export a Metadata\nobject from a layout.js\nor page.js\nfile.\nimport type { Metadata } from 'next'\nexport const metadata: Metadata = {\ntitle: '...',\ndescription: '...',\n}\nexport default function Page() {}\nSee the Metadata Fields for a complete list of supported options.\ngenerateMetadata\nfunction\nDynamic metadata depends on dynamic information, such as the current route parameters, external data, or metadata\nin parent segments, can be set by exporting a generateMetadata\nfunction that returns a Metadata\nobject.\nimport type { Metadata, ResolvingMetadata } from 'next'\ntype Props = {\nparams: Promise<{ id: string }>\nsearchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}\nexport async function generateMetadata(\n{ params, searchParams }: Props,\nparent: ResolvingMetadata\n): Promise<Metadata> {\n// read route params\nconst id = (await params).id\n// fetch data\nconst product = await fetch(`https://.../${id}`).then((res) => res.json())\n// optionally access and extend (rather than replace) parent metadata\nconst previousImages = (await parent).openGraph?.images || []\nreturn {\ntitle: product.title,\nopenGraph: {\nimages: ['/some-specific-page-image.jpg', ...previousImages],\n},\n}\n}\nexport default function Page({ params, searchParams }: Props) {}\nParameters\ngenerateMetadata\nfunction accepts the following parameters:\n-\nprops\n- An object containing the parameters of the current route:-\nparams\n- An object containing the dynamic route parameters object from the root segment down to the segmentgenerateMetadata\nis called from. Examples:Route URL params\napp/shop/[slug]/page.js\n/shop/1\n{ slug: '1' }\napp/shop/[tag]/[item]/page.js\n/shop/1/2\n{ tag: '1', item: '2' }\napp/shop/[...slug]/page.js\n/shop/1/2\n{ slug: ['1', '2'] }\n-\nsearchParams\n- An object containing the current URL's search params. Examples:URL searchParams\n/shop?a=1\n{ a: '1' }\n/shop?a=1&b=2\n{ a: '1', b: '2' }\n/shop?a=1&a=2\n{ a: ['1', '2'] }\n-\n-\nparent\n- A promise of the resolved metadata from parent route segments.\nReturns\ngenerateMetadata\nshould return a Metadata\nobject containing one or more metadata fields.\nGood to know:\n- If metadata doesn't depend on runtime information, it should be defined using the static\nmetadata\nobject rather thangenerateMetadata\n.fetch\nrequests are automatically memoized for the same data acrossgenerateMetadata\n,generateStaticParams\n, Layouts, Pages, and Server Components. Reactcache\ncan be used iffetch\nis unavailable.searchParams\nare only available inpage.js\nsegments.- The\nredirect()\nandnotFound()\nNext.js methods can also be used insidegenerateMetadata\n.\nMetadata Fields\ntitle\nThe title\nattribute is used to set the title of the document. It can be defined as a simple string or an optional template object.\nString\nexport const metadata = {\ntitle: 'Next.js',\n}\n<title>Next.js</title>\nTemplate object\nimport type { Metadata } from 'next'\nexport const metadata: Metadata = {\ntitle: {\ntemplate: '...',\ndefault: '...',\nabsolute: '...',\n},\n}\nDefault\ntitle.default\ncan be used to provide a fallback title to child route segments that don't define a title\n.\nimport type { Metadata } from 'next'\nexport const metadata: Metadata = {\ntitle: {\ndefault: 'Acme',\n},\n}\nimport type { Metadata } from 'next'\nexport const metadata: Metadata = {}\n// Output: <title>Acme</title>\nTemplate\ntitle.template\ncan be used to add a prefix or a suffix to titles\ndefined in child route segments.\nimport type { Metadata } from 'next'\nexport const metadata: Metadata = {\ntitle: {\ntemplate: '%s | Acme',\ndefault: 'Acme', // a default is required when creating a template\n},\n}\nimport type { Metadata } from 'next'\nexport const metadata: Metadata = {\ntitle: 'About',\n}\n// Output: <title>About | Acme</title>\nGood to know:\ntitle.template\napplies to child route segments and not the segment it's defined in. This means:\ntitle.default\nis required when you add atitle.template\n.title.template\ndefined inlayout.js\nwill not apply to atitle\ndefined in apage.js\nof the same route segment.title.template\ndefined inpage.js\nhas no effect because a page is always the terminating segment (it doesn't have any children route segments).\ntitle.template\nhas no effect if a route has not defined atitle\nortitle.default\n.\nAbsolute\ntitle.absolute\ncan be used to provide a title that ignores title.template\nset in parent segments.\nimport type { Metadata } from 'next'\nexport const metadata: Metadata = {\ntitle: {\ntemplate: '%s | Acme',\n},\n}\nimport type { Metadata } from 'next'\nexport const metadata: Metadata = {\ntitle: {\nabsolute: 'About',\n},\n}\n// Output: <title>About</title>\nGood to know:\nlayout.js\ntitle\n(string) andtitle.default\ndefine the default title for child segments (that do not define their owntitle\n). It will augmenttitle.template\nfrom the closest parent segment if it exists.title.absolute\ndefines the default title for child segments. It ignorestitle.template\nfrom parent segments.title.template\ndefines a new title template for child segments.\npage.js\n- If a page does not define its own title the closest parents resolved title will be used.\ntitle\n(string) defines the routes title. It will augmenttitle.template\nfrom the closest parent segment if it exists.title.absolute\ndefines the route title. It ignorestitle.template\nfrom parent segments.title.template\nhas no effect inpage.js\nbecause a page is always the terminating segment of a route.\ndescription\nexport const metadata = {\ndescription: 'The React Framework for the Web',\n}\n<meta name=\"description\" content=\"The React Framework for the Web\" />\nBasic Fields\nexport const metadata = {\ngenerator: 'Next.js',\napplicationName: 'Next.js',\nreferrer: 'origin-when-cross-origin',\nkeywords: ['Next.js', 'React', 'JavaScript'],\nauthors: [{ name: 'Seb' }, { name: 'Josh', url: 'https://nextjs.org' }],\ncreator: 'Jiachi Liu',\npublisher: 'Sebastian Markb\u00e5ge',\nformatDetection: {\nemail: false,\naddress: false,\ntelephone: false,\n},\n}\n<meta name=\"application-name\" content=\"Next.js\" />\n<meta name=\"author\" content=\"Seb\" />\n<link rel=\"author\" href=\"https://nextjs.org\" />\n<meta name=\"author\" content=\"Josh\" />\n<meta name=\"generator\" content=\"Next.js\" />\n<meta name=\"keywords\" content=\"Next.js,React,JavaScript\" />\n<meta name=\"referrer\" content=\"origin-when-cross-origin\" />\n<meta name=\"color-scheme\" content=\"dark\" />\n<meta name=\"creator\" content=\"Jiachi Liu\" />\n<meta name=\"publisher\" content=\"Sebastian Markb\u00e5ge\" />\n<meta name=\"format-detection\" content=\"telephone=no, address=no, email=no\" />\nmetadataBase\nmetadataBase\nis a convenience option to set a base URL prefix for metadata\nfields that require a fully qualified URL.\nmetadataBase\nallows URL-basedmetadata\nfields defined in the current route segment and below to use a relative path instead of an otherwise required absolute URL.- The field's relative path will be composed with\nmetadataBase\nto form a fully qualified URL. - If not configured,\nmetadataBase\nis automatically populated with a default value.\nexport const metadata = {\nmetadataBase: new URL('https://acme.com'),\nalternates: {\ncanonical: '/',\nlanguages: {\n'en-US': '/en-US',\n'de-DE': '/de-DE',\n},\n},\nopenGraph: {\nimages: '/og-image.png',\n},\n}\n<link rel=\"canonical\" href=\"https://acme.com\" />\n<link rel=\"alternate\" hreflang=\"en-US\" href=\"https://acme.com/en-US\" />\n<link rel=\"alternate\" hreflang=\"de-DE\" href=\"https://acme.com/de-DE\" />\n<meta property=\"og:image\" content=\"https://acme.com/og-image.png\" />\nGood to know:\nmetadataBase\nis typically set in rootapp/layout.js\nto apply to URL-basedmetadata\nfields across all routes.- All URL-based\nmetadata\nfields that require absolute URLs can be configured with ametadataBase\noption.metadataBase\ncan contain a subdomain e.g.https://app.acme.com\nor base path e.g.https://acme.com/start/from/here\n- If a\nmetadata\nfield provides an absolute URL,metadataBase\nwill be ignored.- Using a relative path in a URL-based\nmetadata\nfield without configuring ametadataBase\nwill cause a build error.- Next.js will normalize duplicate slashes between\nmetadataBase\n(e.g.https://acme.com/\n) and a relative field (e.g./path\n) to a single slash (e.g.https://acme.com/path\n)\nDefault value\nIf not configured, metadataBase\nhas a default value.\nOn Vercel:\n- For production deployments,\nVERCEL_PROJECT_PRODUCTION_URL\nwill be used.- For preview deployments,\nVERCEL_BRANCH_URL\nwill take priority, and fallback toVERCEL_URL\nif it's not present.If these values are present they will be used as the default value of\nmetadataBase\n, otherwise it falls back tohttp://localhost:${process.env.PORT || 3000}\n. This allows Open Graph images to work on both local build and Vercel preview and production deployments. When overriding the default, we recommend using environment variables to compute the URL. This allows configuring a URL for local development, staging, and production environments.See more details about these environment variables in the System Environment Variables docs.\nURL Composition\nURL composition favors developer intent over default directory traversal semantics.\n- Trailing slashes between\nmetadataBase\nandmetadata\nfields are normalized. - An \"absolute\" path in a\nmetadata\nfield (that typically would replace the whole URL path) is treated as a \"relative\" path (starting from the end ofmetadataBase\n).\nFor example, given the following metadataBase\n:\nimport type { Metadata } from 'next'\nexport const metadata: Metadata = {\nmetadataBase: new URL('https://acme.com'),\n}\nAny metadata\nfields that inherit the above metadataBase\nand set their own value will be resolved as follows:\nmetadata field | Resolved URL |\n|---|---|\n/ | https://acme.com |\n./ | https://acme.com |\npayments | https://acme.com/payments |\n/payments | https://acme.com/payments |\n./payments | https://acme.com/payments |\n../payments | https://acme.com/payments |\nhttps://beta.acme.com/payments | https://beta.acme.com/payments |\nopenGraph\nexport const metadata = {\nopenGraph: {\ntitle: 'Next.js',\ndescription: 'The React Framework for the Web',\nurl: 'https://nextjs.org',\nsiteName: 'Next.js',\nimages: [\n{\nurl: 'https://nextjs.org/og.png', // Must be an absolute URL\nwidth: 800,\nheight: 600,\n},\n{\nurl: 'https://nextjs.org/og-alt.png', // Must be an absolute URL\nwidth: 1800,\nheight: 1600,\nalt: 'My custom alt',\n},\n],\nvideos: [\n{\nurl: 'https://nextjs.org/video.mp4', // Must be an absolute URL\nwidth: 800,\nheight: 600,\n},\n],\naudio: [\n{\nurl: 'https://nextjs.org/audio.mp3', // Must be an absolute URL\n},\n],\nlocale: 'en_US',\ntype: 'website',\n},\n}\n<meta property=\"og:title\" content=\"Next.js\" />\n<meta property=\"og:description\" content=\"The React Framework for the Web\" />\n<meta property=\"og:url\" content=\"https://nextjs.org/\" />\n<meta property=\"og:site_name\" content=\"Next.js\" />\n<meta property=\"og:locale\" content=\"en_US\" />\n<meta property=\"og:image\" content=\"https://nextjs.org/og.png\" />\n<meta property=\"og:image:width\" content=\"800\" />\n<meta property=\"og:image:height\" content=\"600\" />\n<meta property=\"og:image\" content=\"https://nextjs.org/og-alt.png\" />\n<meta property=\"og:image:width\" content=\"1800\" />\n<meta property=\"og:image:height\" content=\"1600\" />\n<meta property=\"og:image:alt\" content=\"My custom alt\" />\n<meta property=\"og:video\" content=\"https://nextjs.org/video.mp4\" />\n<meta property=\"og:video:width\" content=\"800\" />\n<meta property=\"og:video:height\" content=\"600\" />\n<meta property=\"og:audio\" content=\"https://nextjs.org/audio.mp3\" />\n<meta property=\"og:type\" content=\"website\" />\nexport const metadata = {\nopenGraph: {\ntitle: 'Next.js',\ndescription: 'The React Framework for the Web',\ntype: 'article',\npublishedTime: '2023-01-01T00:00:00.000Z',\nauthors: ['Seb', 'Josh'],\n},\n}\n<meta property=\"og:title\" content=\"Next.js\" />\n<meta property=\"og:description\" content=\"The React Framework for the Web\" />\n<meta property=\"og:type\" content=\"article\" />\n<meta property=\"article:published_time\" content=\"2023-01-01T00:00:00.000Z\" />\n<meta property=\"article:author\" content=\"Seb\" />\n<meta property=\"article:author\" content=\"Josh\" />\nGood to know:\n- It may be more convenient to use the file-based Metadata API for Open Graph images. Rather than having to sync the config export with actual files, the file-based API will automatically generate the correct metadata for you.\nrobots\nimport type { Metadata } from 'next'\nexport const metadata: Metadata = {\nrobots: {\nindex: false,\nfollow: true,\nnocache: true,\ngoogleBot: {\nindex: true,\nfollow: false,\nnoimageindex: true,\n'max-video-preview': -1,\n'max-image-preview': 'large',\n'max-snippet': -1,\n},\n},\n}\n<meta name=\"robots\" content=\"noindex, follow, nocache\" />\n<meta\nname=\"googlebot\"\ncontent=\"index, nofollow, noimageindex, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"\n/>\nicons\nGood to know: We recommend using the file-based Metadata API for icons where possible. Rather than having to sync the config export with actual files, the file-based API will automatically generate the correct metadata for you.\nexport const metadata = {\nicons: {\nicon: '/icon.png',\nshortcut: '/shortcut-icon.png',\napple: '/apple-icon.png',\nother: {\nrel: 'apple-touch-icon-precomposed',\nurl: '/apple-touch-icon-precomposed.png',\n},\n},\n}\n<link rel=\"shortcut icon\" href=\"/shortcut-icon.png\" />\n<link rel=\"icon\" href=\"/icon.png\" />\n<link rel=\"apple-touch-icon\" href=\"/apple-icon.png\" />\n<link\nrel=\"apple-touch-icon-precomposed\"\nhref=\"/apple-touch-icon-precomposed.png\"\n/>\nexport const metadata = {\nicons: {\nicon: [\n{ url: '/icon.png' },\nnew URL('/icon.png', 'https://example.com'),\n{ url: '/icon-dark.png', media: '(prefers-color-scheme: dark)' },\n],\nshortcut: ['/shortcut-icon.png'],\napple: [\n{ url: '/apple-icon.png' },\n{ url: '/apple-icon-x3.png', sizes: '180x180', type: 'image/png' },\n],\nother: [\n{\nrel: 'apple-touch-icon-precomposed',\nurl: '/apple-touch-icon-precomposed.png',\n},\n],\n},\n}\n<link rel=\"shortcut icon\" href=\"/shortcut-icon.png\" />\n<link rel=\"icon\" href=\"/icon.png\" />\n<link rel=\"icon\" href=\"https://example.com/icon.png\" />\n<link rel=\"icon\" href=\"/icon-dark.png\" media=\"(prefers-color-scheme: dark)\" />\n<link rel=\"apple-touch-icon\" href=\"/apple-icon.png\" />\n<link\nrel=\"apple-touch-icon-precomposed\"\nhref=\"/apple-touch-icon-precomposed.png\"\n/>\n<link\nrel=\"apple-touch-icon\"\nhref=\"/apple-icon-x3.png\"\nsizes=\"180x180\"\ntype=\"image/png\"\n/>\nGood to know: The\nmsapplication-*\nmeta tags are no longer supported in Chromium builds of Microsoft Edge, and thus no longer needed.\nthemeColor\nDeprecated: The\nthemeColor\noption inmetadata\nis deprecated as of Next.js 14. Please use theviewport\nconfiguration instead.\nmanifest\nA web application manifest, as defined in the Web Application Manifest specification.\nexport const metadata = {\nmanifest: 'https://nextjs.org/manifest.json',\n}\n<link rel=\"manifest\" href=\"https://nextjs.org/manifest.json\" />\ntwitter\nThe Twitter specification is (surprisingly) used for more than just X (formerly known as Twitter).\nLearn more about the Twitter Card markup reference.\nexport const metadata = {\ntwitter: {\ncard: 'summary_large_image',\ntitle: 'Next.js',\ndescription: 'The React Framework for the Web',\nsiteId: '1467726470533754880',\ncreator: '@nextjs',\ncreatorId: '1467726470533754880',\nimages: ['https://nextjs.org/og.png'], // Must be an absolute URL\n},\n}\n<meta name=\"twitter:card\" content=\"summary_large_image\" />\n<meta name=\"twitter:site:id\" content=\"1467726470533754880\" />\n<meta name=\"twitter:creator\" content=\"@nextjs\" />\n<meta name=\"twitter:creator:id\" content=\"1467726470533754880\" />\n<meta name=\"twitter:title\" content=\"Next.js\" />\n<meta name=\"twitter:description\" content=\"The React Framework for the Web\" />\n<meta name=\"twitter:image\" content=\"https://nextjs.org/og.png\" />\nexport const metadata = {\ntwitter: {\ncard: 'app',\ntitle: 'Next.js',\ndescription: 'The React Framework for the Web',\nsiteId: '1467726470533754880',\ncreator: '@nextjs',\ncreatorId: '1467726470533754880',\nimages: {\nurl: 'https://nextjs.org/og.png',\nalt: 'Next.js Logo',\n},\napp: {\nname: 'twitter_app',\nid: {\niphone: 'twitter_app://iphone',\nipad: 'twitter_app://ipad',\ngoogleplay: 'twitter_app://googleplay',\n},\nurl: {\niphone: 'https://iphone_url',\nipad: 'https://ipad_url',\n},\n},\n},\n}\n<meta name=\"twitter:site:id\" content=\"1467726470533754880\" />\n<meta name=\"twitter:creator\" content=\"@nextjs\" />\n<meta name=\"twitter:creator:id\" content=\"1467726470533754880\" />\n<meta name=\"twitter:title\" content=\"Next.js\" />\n<meta name=\"twitter:description\" content=\"The React Framework for the Web\" />\n<meta name=\"twitter:card\" content=\"app\" />\n<meta name=\"twitter:image\" content=\"https://nextjs.org/og.png\" />\n<meta name=\"twitter:image:alt\" content=\"Next.js Logo\" />\n<meta name=\"twitter:app:name:iphone\" content=\"twitter_app\" />\n<meta name=\"twitter:app:id:iphone\" content=\"twitter_app://iphone\" />\n<meta name=\"twitter:app:id:ipad\" content=\"twitter_app://ipad\" />\n<meta name=\"twitter:app:id:googleplay\" content=\"twitter_app://googleplay\" />\n<meta name=\"twitter:app:url:iphone\" content=\"https://iphone_url\" />\n<meta name=\"twitter:app:url:ipad\" content=\"https://ipad_url\" />\n<meta name=\"twitter:app:name:ipad\" content=\"twitter_app\" />\n<meta name=\"twitter:app:name:googleplay\" content=\"twitter_app\" />\nviewport\nDeprecated: The\nviewport\noption inmetadata\nis deprecated as of Next.js 14. Please use theviewport\nconfiguration instead.\nverification\nexport const metadata = {\nverification: {\ngoogle: 'google',\nyandex: 'yandex',\nyahoo: 'yahoo',\nother: {\nme: ['my-email', 'my-link'],\n},\n},\n}\n<meta name=\"google-site-verification\" content=\"google\" />\n<meta name=\"y_key\" content=\"yahoo\" />\n<meta name=\"yandex-verification\" content=\"yandex\" />\n<meta name=\"me\" content=\"my-email\" />\n<meta name=\"me\" content=\"my-link\" />\nappleWebApp\nexport const metadata = {\nitunes: {\nappId: 'myAppStoreID',\nappArgument: 'myAppArgument',\n},\nappleWebApp: {\ntitle: 'Apple Web App',\nstatusBarStyle: 'black-translucent',\nstartupImage: [\n'/assets/startup/apple-touch-startup-image-768x1004.png',\n{\nurl: '/assets/startup/apple-touch-startup-image-1536x2008.png',\nmedia: '(device-width: 768px) and (device-height: 1024px)',\n},\n],\n},\n}\n<meta\nname=\"apple-itunes-app\"\ncontent=\"app-id=myAppStoreID, app-argument=myAppArgument\"\n/>\n<meta name=\"mobile-web-app-capable\" content=\"yes\" />\n<meta name=\"apple-mobile-web-app-title\" content=\"Apple Web App\" />\n<link\nhref=\"/assets/startup/apple-touch-startup-image-768x1004.png\"\nrel=\"apple-touch-startup-image\"\n/>\n<link\nhref=\"/assets/startup/apple-touch-startup-image-1536x2008.png\"\nmedia=\"(device-width: 768px) and (device-height: 1024px)\"\nrel=\"apple-touch-startup-image\"\n/>\n<meta\nname=\"apple-mobile-web-app-status-bar-style\"\ncontent=\"black-translucent\"\n/>\nalternates\nexport const metadata = {\nalternates: {\ncanonical: 'https://nextjs.org',\nlanguages: {\n'en-US': 'https://nextjs.org/en-US',\n'de-DE': 'https://nextjs.org/de-DE',\n},\nmedia: {\n'only screen and (max-width: 600px)': 'https://nextjs.org/mobile',\n},\ntypes: {\n'application/rss+xml': 'https://nextjs.org/rss',\n},\n},\n}\n<link rel=\"canonical\" href=\"https://nextjs.org\" />\n<link rel=\"alternate\" hreflang=\"en-US\" href=\"https://nextjs.org/en-US\" />\n<link rel=\"alternate\" hreflang=\"de-DE\" href=\"https://nextjs.org/de-DE\" />\n<link\nrel=\"alternate\"\nmedia=\"only screen and (max-width: 600px)\"\nhref=\"https://nextjs.org/mobile\"\n/>\n<link\nrel=\"alternate\"\ntype=\"application/rss+xml\"\nhref=\"https://nextjs.org/rss\"\n/>\nappLinks\nexport const metadata = {\nappLinks: {\nios: {\nurl: 'https://nextjs.org/ios',\napp_store_id: 'app_store_id',\n},\nandroid: {\npackage: 'com.example.android/package',\napp_name: 'app_name_android',\n},\nweb: {\nurl: 'https://nextjs.org/web',\nshould_fallback: true,\n},\n},\n}\n<meta property=\"al:ios:url\" content=\"https://nextjs.org/ios\" />\n<meta property=\"al:ios:app_store_id\" content=\"app_store_id\" />\n<meta property=\"al:android:package\" content=\"com.example.android/package\" />\n<meta property=\"al:android:app_name\" content=\"app_name_android\" />\n<meta property=\"al:web:url\" content=\"https://nextjs.org/web\" />\n<meta property=\"al:web:should_fallback\" content=\"true\" />\narchives\nDescribes a collection of records, documents, or other materials of historical interest (source).\nexport const metadata = {\narchives: ['https://nextjs.org/13'],\n}\n<link rel=\"archives\" href=\"https://nextjs.org/13\" />\nassets\nexport const metadata = {\nassets: ['https://nextjs.org/assets'],\n}\n<link rel=\"assets\" href=\"https://nextjs.org/assets\" />\nbookmarks\nexport const metadata = {\nbookmarks: ['https://nextjs.org/13'],\n}\n<link rel=\"bookmarks\" href=\"https://nextjs.org/13\" />\ncategory\nexport const metadata = {\ncategory: 'technology',\n}\n<meta name=\"category\" content=\"technology\" />\nfacebook\nYou can connect a Facebook app or Facebook account to you webpage for certain Facebook Social Plugins Facebook Documentation\nGood to know: You can specify either appId or admins, but not both.\nexport const metadata = {\nfacebook: {\nappId: '12345678',\n},\n}\n<meta property=\"fb:app_id\" content=\"12345678\" />\nexport const metadata = {\nfacebook: {\nadmins: '12345678',\n},\n}\n<meta property=\"fb:admins\" content=\"12345678\" />\nIf you want to generate multiple fb:admins meta tags you can use array value.\nexport const metadata = {\nfacebook: {\nadmins: ['12345678', '87654321'],\n},\n}\n<meta property=\"fb:admins\" content=\"12345678\" />\n<meta property=\"fb:admins\" content=\"87654321\" />\nother\nAll metadata options should be covered using the built-in support. However, there may be custom metadata tags specific to your site, or brand new metadata tags just released. You can use the other\noption to render any custom metadata tag.\nexport const metadata = {\nother: {\ncustom: 'meta',\n},\n}\n<meta name=\"custom\" content=\"meta\" />\nIf you want to generate multiple same key meta tags you can use array value.\nexport const metadata = {\nother: {\ncustom: ['meta1', 'meta2'],\n},\n}\n<meta name=\"custom\" content=\"meta1\" /> <meta name=\"custom\" content=\"meta2\" />\nUnsupported Metadata\nThe following metadata types do not currently have built-in support. However, they can still be rendered in the layout or page itself.\n| Metadata | Recommendation |\n|---|---|\n<meta http-equiv=\"...\"> | Use appropriate HTTP Headers via redirect() , Middleware, Security Headers |\n<base> | Render the tag in the layout or page itself. |\n<noscript> | Render the tag in the layout or page itself. |\n<style> | Learn more about styling in Next.js. |\n<script> | Learn more about using scripts. |\n<link rel=\"stylesheet\" /> | import stylesheets directly in the layout or page itself. |\n<link rel=\"preload /> | Use ReactDOM preload method |\n<link rel=\"preconnect\" /> | Use ReactDOM preconnect method |\n<link rel=\"dns-prefetch\" /> | Use ReactDOM prefetchDNS method |\nResource hints\nThe <link>\nelement has a number of rel\nkeywords that can be used to hint to the browser that an external resource is likely to be needed. The browser uses this information to apply preloading optimizations depending on the keyword.\nWhile the Metadata API doesn't directly support these hints, you can use new ReactDOM\nmethods to safely insert them into the <head>\nof the document.\n'use client'\nimport ReactDOM from 'react-dom'\nexport function PreloadResources() {\nReactDOM.preload('...', { as: '...' })\nReactDOM.preconnect('...', { crossOrigin: '...' })\nReactDOM.prefetchDNS('...')\nreturn '...'\n}\n<link rel=\"preload\">\nStart loading a resource early in the page rendering (browser) lifecycle. MDN Docs.\nReactDOM.preload(href: string, options: { as: string })\n<link rel=\"preload\" href=\"...\" as=\"...\" />\n<link rel=\"preconnect\">\nPreemptively initiate a connection to an origin. MDN Docs.\nReactDOM.preconnect(href: string, options?: { crossOrigin?: string })\n<link rel=\"preconnect\" href=\"...\" crossorigin />\n<link rel=\"dns-prefetch\">\nAttempt to resolve a domain name before resources get requested. MDN Docs.\nReactDOM.prefetchDNS(href: string)\n<link rel=\"dns-prefetch\" href=\"...\" />\nGood to know:\n- These methods are currently only supported in Client Components, which are still Server Side Rendered on initial page load.\n- Next.js in-built features such as\nnext/font\n,next/image\nandnext/script\nautomatically handle relevant resource hints.\nTypes\nYou can add type safety to your metadata by using the Metadata\ntype. If you are using the built-in TypeScript plugin in your IDE, you do not need to manually add the type, but you can still explicitly add it if you want.\nmetadata\nobject\nimport type { Metadata } from 'next'\nexport const metadata: Metadata = {\ntitle: 'Next.js',\n}\ngenerateMetadata\nfunction\nRegular function\nimport type { Metadata } from 'next'\nexport function generateMetadata(): Metadata {\nreturn {\ntitle: 'Next.js',\n}\n}\nAsync function\nimport type { Metadata } from 'next'\nexport async function generateMetadata(): Promise<Metadata> {\nreturn {\ntitle: 'Next.js',\n}\n}\nWith segment props\nimport type { Metadata } from 'next'\ntype Props = {\nparams: Promise<{ id: string }>\nsearchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}\nexport function generateMetadata({ params, searchParams }: Props): Metadata {\nreturn {\ntitle: 'Next.js',\n}\n}\nexport default function Page({ params, searchParams }: Props) {}\nWith parent metadata\nimport type { Metadata, ResolvingMetadata } from 'next'\nexport async function generateMetadata(\n{ params, searchParams }: Props,\nparent: ResolvingMetadata\n): Promise<Metadata> {\nreturn {\ntitle: 'Next.js',\n}\n}\nJavaScript Projects\nFor JavaScript projects, you can use JSDoc to add type safety.\n/** @type {import(\"next\").Metadata} */\nexport const metadata = {\ntitle: 'Next.js',\n}\nVersion History\n| Version | Changes |\n|---|---|\nv13.2.0 | viewport , themeColor , and colorScheme deprecated in favor of the viewport configuration. |\nv13.2.0 | metadata and generateMetadata introduced. |\nNext Steps\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/generate-sitemaps", "title": "Functions: generateSitemaps | Next.js", "text": "generateSitemaps\nYou can use the generateSitemaps\nfunction to generate multiple sitemaps for your application.\nReturns\nThe generateSitemaps\nreturns an array of objects with an id\nproperty.\nURLs\nYour generated sitemaps will be available at /.../sitemap/[id].xml\n. For example, /product/sitemap/1.xml\n.\nExample\nFor example, to split a sitemap using generateSitemaps\n, return an array of objects with the sitemap id\n. Then, use the id\nto generate the unique sitemaps.\napp/product/sitemap.ts\nimport { BASE_URL } from '@/app/lib/constants'\nexport async function generateSitemaps() {\n// Fetch the total number of products and calculate the number of sitemaps needed\nreturn [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }]\n}\nexport default async function sitemap({\nid,\n}: {\nid: number\n}): Promise<MetadataRoute.Sitemap> {\n// Google's limit is 50,000 URLs per sitemap\nconst start = id * 50000\nconst end = start + 50000\nconst products = await getProducts(\n`SELECT id, date FROM products WHERE id BETWEEN ${start} AND ${end}`\n)\nreturn products.map((product) => ({\nurl: `${BASE_URL}/product/${product.id}`,\nlastModified: product.date,\n}))\n}\nVersion History\n| Version | Changes |\n|---|---|\nv15.0.0 | generateSitemaps now generates consistent URLs between development and production |\nv13.3.2 | generateSitemaps introduced. In development, you can view the generated sitemap on /.../sitemap.xml/[id] . For example, /product/sitemap.xml/1 . |\nNext Steps\nLearn how to create sitemaps for your Next.js application.\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/generate-static-params", "title": "Functions: generateStaticParams | Next.js", "text": "generateStaticParams\nThe generateStaticParams\nfunction can be used in combination with dynamic route segments to statically generate routes at build time instead of on-demand at request time.\n// Return a list of `params` to populate the [slug] dynamic segment\nexport async function generateStaticParams() {\nconst posts = await fetch('https://.../posts').then((res) => res.json())\nreturn posts.map((post) => ({\nslug: post.slug,\n}))\n}\n// Multiple versions of this page will be statically generated\n// using the `params` returned by `generateStaticParams`\nexport default async function Page({\nparams,\n}: {\nparams: Promise<{ slug: string }>\n}) {\nconst { slug } = await params\n// ...\n}\nGood to know:\n- You can use the\ndynamicParams\nsegment config option to control what happens when a dynamic segment is visited that was not generated withgenerateStaticParams\n.- You must return an empty array from\ngenerateStaticParams\nor utilizeexport const dynamic = 'force-static'\nin order to revalidate (ISR) paths at runtime.- During\nnext dev\n,generateStaticParams\nwill be called when you navigate to a route.- During\nnext build\n,generateStaticParams\nruns before the corresponding Layouts or Pages are generated.- During revalidation (ISR),\ngenerateStaticParams\nwill not be called again.generateStaticParams\nreplaces thegetStaticPaths\nfunction in the Pages Router.\nParameters\noptions.params\n(optional)\nIf multiple dynamic segments in a route use generateStaticParams\n, the child generateStaticParams\nfunction is executed once for each set of params\nthe parent generates.\nThe params\nobject contains the populated params\nfrom the parent generateStaticParams\n, which can be used to generate the params\nin a child segment.\nReturns\ngenerateStaticParams\nshould return an array of objects where each object represents the populated dynamic segments of a single route.\n- Each property in the object is a dynamic segment to be filled in for the route.\n- The properties name is the segment's name, and the properties value is what that segment should be filled in with.\n| Example Route | generateStaticParams Return Type |\n|---|---|\n/product/[id] | { id: string }[] |\n/products/[category]/[product] | { category: string, product: string }[] |\n/products/[...slug] | { slug: string[] }[] |\nSingle Dynamic Segment\nexport function generateStaticParams() {\nreturn [{ id: '1' }, { id: '2' }, { id: '3' }]\n}\n// Three versions of this page will be statically generated\n// using the `params` returned by `generateStaticParams`\n// - /product/1\n// - /product/2\n// - /product/3\nexport default async function Page({\nparams,\n}: {\nparams: Promise<{ id: string }>\n}) {\nconst { id } = await params\n// ...\n}\nMultiple Dynamic Segments\nexport function generateStaticParams() {\nreturn [\n{ category: 'a', product: '1' },\n{ category: 'b', product: '2' },\n{ category: 'c', product: '3' },\n]\n}\n// Three versions of this page will be statically generated\n// using the `params` returned by `generateStaticParams`\n// - /products/a/1\n// - /products/b/2\n// - /products/c/3\nexport default async function Page({\nparams,\n}: {\nparams: Promise<{ category: string; product: string }>\n}) {\nconst { category, product } = await params\n// ...\n}\nCatch-all Dynamic Segment\nexport function generateStaticParams() {\nreturn [{ slug: ['a', '1'] }, { slug: ['b', '2'] }, { slug: ['c', '3'] }]\n}\n// Three versions of this page will be statically generated\n// using the `params` returned by `generateStaticParams`\n// - /product/a/1\n// - /product/b/2\n// - /product/c/3\nexport default async function Page({\nparams,\n}: {\nparams: Promise<{ slug: string[] }>\n}) {\nconst { slug } = await params\n// ...\n}\nExamples\nStatic Rendering\nAll paths at build time\nTo statically render all paths at build time, supply the full list of paths to generateStaticParams\n:\nexport async function generateStaticParams() {\nconst posts = await fetch('https://.../posts').then((res) => res.json())\nreturn posts.map((post) => ({\nslug: post.slug,\n}))\n}\nSubset of paths at build time\nTo statically render a subset of paths at build time, and the rest the first time they're visited at runtime, return a partial list of paths:\nexport async function generateStaticParams() {\nconst posts = await fetch('https://.../posts').then((res) => res.json())\n// Render the first 10 posts at build time\nreturn posts.slice(0, 10).map((post) => ({\nslug: post.slug,\n}))\n}\nThen, by using the dynamicParams\nsegment config option, you can control what happens when a dynamic segment is visited that was not generated with generateStaticParams\n.\n// All posts besides the top 10 will be a 404\nexport const dynamicParams = false\nexport async function generateStaticParams() {\nconst posts = await fetch('https://.../posts').then((res) => res.json())\nconst topPosts = posts.slice(0, 10)\nreturn topPosts.map((post) => ({\nslug: post.slug,\n}))\n}\nAll paths at runtime\nTo statically render all paths the first time they're visited, return an empty array (no paths will be rendered at build time) or utilize export const dynamic = 'force-static'\n:\nexport async function generateStaticParams() {\nreturn []\n}\nGood to know: You must always return an array from\ngenerateStaticParams\n, even if it's empty. Otherwise, the route will be dynamically rendered.\nexport const dynamic = 'force-static'\nDisable rendering for unspecified paths\nTo prevent unspecified paths from being statically rendered at runtime, add the export const dynamicParams = false\noption in a route segment. When this config option is used, only paths provided by generateStaticParams\nwill be served, and unspecified routes will 404 or match (in the case of catch-all routes).\nMultiple Dynamic Segments in a Route\nYou can generate params for dynamic segments above the current layout or page, but not below. For example, given the app/products/[category]/[product]\nroute:\napp/products/[category]/[product]/page.js\ncan generate params for both[category]\nand[product]\n.app/products/[category]/layout.js\ncan only generate params for[category]\n.\nThere are two approaches to generating params for a route with multiple dynamic segments:\nGenerate params from the bottom up\nGenerate multiple dynamic segments from the child route segment.\n// Generate segments for both [category] and [product]\nexport async function generateStaticParams() {\nconst products = await fetch('https://.../products').then((res) => res.json())\nreturn products.map((product) => ({\ncategory: product.category.slug,\nproduct: product.id,\n}))\n}\nexport default function Page({\nparams,\n}: {\nparams: Promise<{ category: string; product: string }>\n}) {\n// ...\n}\nGenerate params from the top down\nGenerate the parent segments first and use the result to generate the child segments.\n// Generate segments for [category]\nexport async function generateStaticParams() {\nconst products = await fetch('https://.../products').then((res) => res.json())\nreturn products.map((product) => ({\ncategory: product.category.slug,\n}))\n}\nexport default function Layout({\nparams,\n}: {\nparams: Promise<{ category: string }>\n}) {\n// ...\n}\nA child route segment's generateStaticParams\nfunction is executed once for each segment a parent generateStaticParams\ngenerates.\nThe child generateStaticParams\nfunction can use the params\nreturned from the parent generateStaticParams\nfunction to dynamically generate its own segments.\n// Generate segments for [product] using the `params` passed from\n// the parent segment's `generateStaticParams` function\nexport async function generateStaticParams({\nparams: { category },\n}: {\nparams: { category: string }\n}) {\nconst products = await fetch(\n`https://.../products?category=${category}`\n).then((res) => res.json())\nreturn products.map((product) => ({\nproduct: product.id,\n}))\n}\nexport default function Page({\nparams,\n}: {\nparams: Promise<{ category: string; product: string }>\n}) {\n// ...\n}\nGood to know:\nfetch\nrequests are automatically memoized for the same data across allgenerate\n-prefixed functions, Layouts, Pages, and Server Components. Reactcache\ncan be used iffetch\nis unavailable.\nVersion History\n| Version | Changes |\n|---|---|\nv13.0.0 | generateStaticParams introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/generate-viewport", "title": "Functions: generateViewport | Next.js", "text": "generateViewport\nYou can customize the initial viewport of the page with the static viewport\nobject or the dynamic generateViewport\nfunction.\nGood to know:\n- The\nviewport\nobject andgenerateViewport\nfunction exports are only supported in Server Components.- You cannot export both the\nviewport\nobject andgenerateViewport\nfunction from the same route segment.- If you're coming from migrating\nmetadata\nexports, you can use metadata-to-viewport-export codemod to update your changes.\nThe viewport\nobject\nTo define the viewport options, export a viewport\nobject from a layout.jsx\nor page.jsx\nfile.\nimport type { Viewport } from 'next'\nexport const viewport: Viewport = {\nthemeColor: 'black',\n}\nexport default function Page() {}\ngenerateViewport\nfunction\ngenerateViewport\nshould return a Viewport\nobject containing one or more viewport fields.\nexport function generateViewport({ params }) {\nreturn {\nthemeColor: '...',\n}\n}\nGood to know:\n- If the viewport doesn't depend on runtime information, it should be defined using the static\nviewport\nobject rather thangenerateViewport\n.\nViewport Fields\nthemeColor\nLearn more about theme-color\n.\nSimple theme color\nimport type { Viewport } from 'next'\nexport const viewport: Viewport = {\nthemeColor: 'black',\n}\n<meta name=\"theme-color\" content=\"black\" />\nWith media attribute\nimport type { Viewport } from 'next'\nexport const viewport: Viewport = {\nthemeColor: [\n{ media: '(prefers-color-scheme: light)', color: 'cyan' },\n{ media: '(prefers-color-scheme: dark)', color: 'black' },\n],\n}\n<meta name=\"theme-color\" media=\"(prefers-color-scheme: light)\" content=\"cyan\" />\n<meta name=\"theme-color\" media=\"(prefers-color-scheme: dark)\" content=\"black\" />\nwidth\n, initialScale\n, maximumScale\nand userScalable\nGood to know: The\nviewport\nmeta tag is automatically set, and manual configuration is usually unnecessary as the default is sufficient. However, the information is provided for completeness.\nimport type { Viewport } from 'next'\nexport const viewport: Viewport = {\nwidth: 'device-width',\ninitialScale: 1,\nmaximumScale: 1,\nuserScalable: false,\n// Also supported but less commonly used\n// interactiveWidget: 'resizes-visual',\n}\n<meta\nname=\"viewport\"\ncontent=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\"\n/>\ncolorScheme\nLearn more about color-scheme\n.\nimport type { Viewport } from 'next'\nexport const viewport: Viewport = {\ncolorScheme: 'dark',\n}\n<meta name=\"color-scheme\" content=\"dark\" />\nTypes\nYou can add type safety to your viewport object by using the Viewport\ntype. If you are using the built-in TypeScript plugin in your IDE, you do not need to manually add the type, but you can still explicitly add it if you want.\nviewport\nobject\nimport type { Viewport } from 'next'\nexport const viewport: Viewport = {\nthemeColor: 'black',\n}\ngenerateViewport\nfunction\nRegular function\nimport type { Viewport } from 'next'\nexport function generateViewport(): Viewport {\nreturn {\nthemeColor: 'black',\n}\n}\nWith segment props\nimport type { Viewport } from 'next'\ntype Props = {\nparams: Promise<{ id: string }>\nsearchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}\nexport function generateViewport({ params, searchParams }: Props): Viewport {\nreturn {\nthemeColor: 'black',\n}\n}\nexport default function Page({ params, searchParams }: Props) {}\nJavaScript Projects\nFor JavaScript projects, you can use JSDoc to add type safety.\n/** @type {import(\"next\").Viewport} */\nexport const viewport = {\nthemeColor: 'black',\n}\nVersion History\n| Version | Changes |\n|---|---|\nv14.0.0 | viewport and generateViewport introduced. |\nNext Steps\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/headers", "title": "Functions: headers | Next.js", "text": "headers\nheaders\nis an async function that allows you to read the HTTP incoming request headers from a Server Component.\napp/page.tsx\nimport { headers } from 'next/headers'\nexport default async function Page() {\nconst headersList = await headers()\nconst userAgent = headersList.get('user-agent')\n}\nReference\nParameters\nheaders\ndoes not take any parameters.\nReturns\nheaders\nreturns a read-only Web Headers object.\nHeaders.entries()\n: Returns aniterator\nallowing to go through all key/value pairs contained in this object.Headers.forEach()\n: Executes a provided function once for each key/value pair in thisHeaders\nobject.Headers.get()\n: Returns aString\nsequence of all the values of a header within aHeaders\nobject with a given name.Headers.has()\n: Returns a boolean stating whether aHeaders\nobject contains a certain header.Headers.keys()\n: Returns aniterator\nallowing you to go through all keys of the key/value pairs contained in this object.Headers.values()\n: Returns aniterator\nallowing you to go through all values of the key/value pairs contained in this object.\nGood to know\nheaders\nis an asynchronous function that returns a promise. You must useasync/await\nor React'suse\nfunction.- In version 14 and earlier,\nheaders\nwas a synchronous function. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.\n- In version 14 and earlier,\n- Since\nheaders\nis read-only, you cannotset\nordelete\nthe outgoing request headers. headers\nis a Dynamic API whose returned values cannot be known ahead of time. Using it in will opt a route into dynamic rendering.\nExamples\nUsing the Authorization header\napp/page.js\nimport { headers } from 'next/headers'\nexport default async function Page() {\nconst authorization = (await headers()).get('authorization')\nconst res = await fetch('...', {\nheaders: { authorization }, // Forward the authorization header\n})\nconst user = await res.json()\nreturn <h1>{user.name}</h1>\n}\nVersion History\n| Version | Changes |\n|---|---|\nv15.0.0-RC | headers is now an async function. A codemod is available. |\nv13.0.0 | headers introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/image-response", "title": "Functions: ImageResponse | Next.js", "text": "ImageResponse\nThe ImageResponse\nconstructor allows you to generate dynamic images using JSX and CSS. This is useful for generating social media images such as Open Graph images, Twitter cards, and more.\nThe following options are available for ImageResponse\n:\nimport { ImageResponse } from 'next/og'\nnew ImageResponse(\nelement: ReactElement,\noptions: {\nwidth?: number = 1200\nheight?: number = 630\nemoji?: 'twemoji' | 'blobmoji' | 'noto' | 'openmoji' = 'twemoji',\nfonts?: {\nname: string,\ndata: ArrayBuffer,\nweight: number,\nstyle: 'normal' | 'italic'\n}[]\ndebug?: boolean = false\n// Options that will be passed to the HTTP response\nstatus?: number = 200\nstatusText?: string\nheaders?: Record<string, string>\n},\n)\nSupported CSS Properties\nPlease refer to Satori\u2019s documentation for a list of supported HTML and CSS features.\nVersion History\n| Version | Changes |\n|---|---|\nv14.0.0 | ImageResponse moved from next/server to next/og |\nv13.3.0 | ImageResponse can be imported from next/server . |\nv13.0.0 | ImageResponse introduced via @vercel/og package. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/next-request", "title": "Functions: NextRequest | Next.js", "text": "NextRequest\nNextRequest extends the Web Request API with additional convenience methods.\ncookies\nRead or mutate the Set-Cookie\nheader of the request.\nset(name, value)\nGiven a name, set a cookie with the given value on the request.\n// Given incoming request /home\n// Set a cookie to hide the banner\n// request will have a `Set-Cookie:show-banner=false;path=/home` header\nrequest.cookies.set('show-banner', 'false')\nget(name)\nGiven a cookie name, return the value of the cookie. If the cookie is not found, undefined\nis returned. If multiple cookies are found, the first one is returned.\n// Given incoming request /home\n// { name: 'show-banner', value: 'false', Path: '/home' }\nrequest.cookies.get('show-banner')\ngetAll()\nGiven a cookie name, return the values of the cookie. If no name is given, return all cookies on the request.\n// Given incoming request /home\n// [\n// { name: 'experiments', value: 'new-pricing-page', Path: '/home' },\n// { name: 'experiments', value: 'winter-launch', Path: '/home' },\n// ]\nrequest.cookies.getAll('experiments')\n// Alternatively, get all cookies for the request\nrequest.cookies.getAll()\ndelete(name)\nGiven a cookie name, delete the cookie from the request.\n// Returns true for deleted, false is nothing is deleted\nrequest.cookies.delete('experiments')\nhas(name)\nGiven a cookie name, return true\nif the cookie exists on the request.\n// Returns true if cookie exists, false if it does not\nrequest.cookies.has('experiments')\nclear()\nRemove the Set-Cookie\nheader from the request.\nrequest.cookies.clear()\nnextUrl\nExtends the native URL\nAPI with additional convenience methods, including Next.js specific properties.\n// Given a request to /home, pathname is /home\nrequest.nextUrl.pathname\n// Given a request to /home?name=lee, searchParams is { 'name': 'lee' }\nrequest.nextUrl.searchParams\nThe following options are available:\n| Property | Type | Description |\n|---|---|---|\nbasePath | string | The base path of the URL. |\nbuildId | string | undefined | The build identifier of the Next.js application. Can be customized. |\npathname | string | The pathname of the URL. |\nsearchParams | Object | The search parameters of the URL. |\nNote: The internationalization properties from the Pages Router are not available for usage in the App Router. Learn more about internationalization with the App Router.\nVersion History\n| Version | Changes |\n|---|---|\nv15.0.0 | ip and geo removed. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/next-response", "title": "Functions: NextResponse | Next.js", "text": "NextResponse\nNextResponse extends the Web Response API with additional convenience methods.\ncookies\nRead or mutate the Set-Cookie\nheader of the response.\nset(name, value)\nGiven a name, set a cookie with the given value on the response.\n// Given incoming request /home\nlet response = NextResponse.next()\n// Set a cookie to hide the banner\nresponse.cookies.set('show-banner', 'false')\n// Response will have a `Set-Cookie:show-banner=false;path=/home` header\nreturn response\nget(name)\nGiven a cookie name, return the value of the cookie. If the cookie is not found, undefined\nis returned. If multiple cookies are found, the first one is returned.\n// Given incoming request /home\nlet response = NextResponse.next()\n// { name: 'show-banner', value: 'false', Path: '/home' }\nresponse.cookies.get('show-banner')\ngetAll()\nGiven a cookie name, return the values of the cookie. If no name is given, return all cookies on the response.\n// Given incoming request /home\nlet response = NextResponse.next()\n// [\n// { name: 'experiments', value: 'new-pricing-page', Path: '/home' },\n// { name: 'experiments', value: 'winter-launch', Path: '/home' },\n// ]\nresponse.cookies.getAll('experiments')\n// Alternatively, get all cookies for the response\nresponse.cookies.getAll()\ndelete(name)\nGiven a cookie name, delete the cookie from the response.\n// Given incoming request /home\nlet response = NextResponse.next()\n// Returns true for deleted, false is nothing is deleted\nresponse.cookies.delete('experiments')\njson()\nProduce a response with the given JSON body.\nimport { NextResponse } from 'next/server'\nexport async function GET(request: Request) {\nreturn NextResponse.json({ error: 'Internal Server Error' }, { status: 500 })\n}\nredirect()\nProduce a response that redirects to a URL.\nimport { NextResponse } from 'next/server'\nreturn NextResponse.redirect(new URL('/new', request.url))\nThe URL can be created and modified before being used in the NextResponse.redirect()\nmethod. For example, you can use the request.nextUrl\nproperty to get the current URL, and then modify it to redirect to a different URL.\nimport { NextResponse } from 'next/server'\n// Given an incoming request...\nconst loginUrl = new URL('/login', request.url)\n// Add ?from=/incoming-url to the /login URL\nloginUrl.searchParams.set('from', request.nextUrl.pathname)\n// And redirect to the new URL\nreturn NextResponse.redirect(loginUrl)\nrewrite()\nProduce a response that rewrites (proxies) the given URL while preserving the original URL.\nimport { NextResponse } from 'next/server'\n// Incoming request: /about, browser shows /about\n// Rewritten request: /proxy, browser shows /about\nreturn NextResponse.rewrite(new URL('/proxy', request.url))\nnext()\nThe next()\nmethod is useful for Middleware, as it allows you to return early and continue routing.\nimport { NextResponse } from 'next/server'\nreturn NextResponse.next()\nYou can also forward headers\nwhen producing the response:\nimport { NextResponse } from 'next/server'\n// Given an incoming request...\nconst newHeaders = new Headers(request.headers)\n// Add a new header\nnewHeaders.set('x-version', '123')\n// And produce a response with the new headers\nreturn NextResponse.next({\nrequest: {\n// New request headers\nheaders: newHeaders,\n},\n})\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/not-found", "title": "Functions: notFound | Next.js", "text": "notFound\nThe notFound\nfunction allows you to render the not-found file\nwithin a route segment as well as inject a <meta name=\"robots\" content=\"noindex\" />\ntag.\nnotFound()\nInvoking the notFound()\nfunction throws a NEXT_NOT_FOUND\nerror and terminates rendering of the route segment in which it was thrown. Specifying a not-found file allows you to gracefully handle such errors by rendering a Not Found UI within the segment.\napp/user/[id]/page.js\nimport { notFound } from 'next/navigation'\nasync function fetchUser(id) {\nconst res = await fetch('https://...')\nif (!res.ok) return undefined\nreturn res.json()\n}\nexport default async function Profile({ params }) {\nconst user = await fetchUser(params.id)\nif (!user) {\nnotFound()\n}\n// ...\n}\nGood to know:\nnotFound()\ndoes not require you to usereturn notFound()\ndue to using the TypeScriptnever\ntype.\nVersion History\n| Version | Changes |\n|---|---|\nv13.0.0 | notFound introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/permanentRedirect", "title": "Functions: permanentRedirect | Next.js", "text": "permanentRedirect\nThe permanentRedirect\nfunction allows you to redirect the user to another URL. permanentRedirect\ncan be used in Server Components, Client Components, Route Handlers, and Server Actions.\nWhen used in a streaming context, this will insert a meta tag to emit the redirect on the client side. When used in a server action, it will serve a 303 HTTP redirect response to the caller. Otherwise, it will serve a 308 (Permanent) HTTP redirect response to the caller.\nIf a resource doesn't exist, you can use the notFound\nfunction instead.\nGood to know: If you prefer to return a 307 (Temporary) HTTP redirect instead of 308 (Permanent), you can use the\nredirect\nfunction instead.\nParameters\nThe permanentRedirect\nfunction accepts two arguments:\npermanentRedirect(path, type)\n| Parameter | Type | Description |\n|---|---|---|\npath | string | The URL to redirect to. Can be a relative or absolute path. |\ntype | 'replace' (default) or 'push' (default in Server Actions) | The type of redirect to perform. |\nBy default, permanentRedirect\nwill use push\n(adding a new entry to the browser history stack) in Server Actions and replace\n(replacing the current URL in the browser history stack) everywhere else. You can override this behavior by specifying the type\nparameter.\nThe type\nparameter has no effect when used in Server Components.\nReturns\npermanentRedirect\ndoes not return a value.\nExample\nInvoking the permanentRedirect()\nfunction throws a NEXT_REDIRECT\nerror and terminates rendering of the route segment in which it was thrown.\nimport { permanentRedirect } from 'next/navigation'\nasync function fetchTeam(id) {\nconst res = await fetch('https://...')\nif (!res.ok) return undefined\nreturn res.json()\n}\nexport default async function Profile({ params }) {\nconst team = await fetchTeam(params.id)\nif (!team) {\npermanentRedirect('/login')\n}\n// ...\n}\nGood to know:\npermanentRedirect\ndoes not require you to usereturn permanentRedirect()\nas it uses the TypeScriptnever\ntype.\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/redirect", "title": "Functions: redirect | Next.js", "text": "redirect\nThe redirect\nfunction allows you to redirect the user to another URL. redirect\ncan be used in Server Components, Route Handlers, and Server Actions.\nWhen used in a streaming context, this will insert a meta tag to emit the redirect on the client side. When used in a server action, it will serve a 303 HTTP redirect response to the caller. Otherwise, it will serve a 307 HTTP redirect response to the caller.\nIf a resource doesn't exist, you can use the notFound\nfunction instead.\nGood to know:\n- In Server Actions and Route Handlers,\nredirect\nshould be called after thetry/catch\nblock.- If you prefer to return a 308 (Permanent) HTTP redirect instead of 307 (Temporary), you can use the\npermanentRedirect\nfunction instead.\nParameters\nThe redirect\nfunction accepts two arguments:\nredirect(path, type)\n| Parameter | Type | Description |\n|---|---|---|\npath | string | The URL to redirect to. Can be a relative or absolute path. |\ntype | 'replace' (default) or 'push' (default in Server Actions) | The type of redirect to perform. |\nBy default, redirect\nwill use push\n(adding a new entry to the browser history stack) in Server Actions and replace\n(replacing the current URL in the browser history stack) everywhere else. You can override this behavior by specifying the type\nparameter.\nThe type\nparameter has no effect when used in Server Components.\nReturns\nredirect\ndoes not return a value.\nExample\nServer Component\nInvoking the redirect()\nfunction throws a NEXT_REDIRECT\nerror and terminates rendering of the route segment in which it was thrown.\nimport { redirect } from 'next/navigation'\nasync function fetchTeam(id: string) {\nconst res = await fetch('https://...')\nif (!res.ok) return undefined\nreturn res.json()\n}\nexport default async function Profile({\nparams,\n}: {\nparams: Promise<{ id: string }>\n}) {\nconst { id } = await params\nconst team = await fetchTeam(id)\nif (!team) {\nredirect('/login')\n}\n// ...\n}\nGood to know:\nredirect\ndoes not require you to usereturn redirect()\nas it uses the TypeScriptnever\ntype.\nClient Component\nredirect\ncan be used in a Client Component through a Server Action. If you need to use an event handler to redirect the user, you can use the useRouter\nhook.\n'use client'\nimport { navigate } from './actions'\nexport function ClientRedirect() {\nreturn (\n<form action={navigate}>\n<input type=\"text\" name=\"id\" />\n<button>Submit</button>\n</form>\n)\n}\n'use server'\nimport { redirect } from 'next/navigation'\nexport async function navigate(data: FormData) {\nredirect(`/posts/${data.get('id')}`)\n}\nFAQ\nWhy does redirect\nuse 307 and 308?\nWhen using redirect()\nyou may notice that the status codes used are 307\nfor a temporary redirect, and 308\nfor a permanent redirect. While traditionally a 302\nwas used for a temporary redirect, and a 301\nfor a permanent redirect, many browsers changed the request method of the redirect, from a POST\nto GET\nrequest when using a 302\n, regardless of the origins request method.\nTaking the following example of a redirect from /users\nto /people\n, if you make a POST\nrequest to /users\nto create a new user, and are conforming to a 302\ntemporary redirect, the request method will be changed from a POST\nto a GET\nrequest. This doesn't make sense, as to create a new user, you should be making a POST\nrequest to /people\n, and not a GET\nrequest.\nThe introduction of the 307\nstatus code means that the request method is preserved as POST\n.\n302\n- Temporary redirect, will change the request method fromPOST\ntoGET\n307\n- Temporary redirect, will preserve the request method asPOST\nThe redirect()\nmethod uses a 307\nby default, instead of a 302\ntemporary redirect, meaning your requests will always be preserved as POST\nrequests.\nLearn more about HTTP Redirects.\nVersion History\n| Version | Changes |\n|---|---|\nv13.0.0 | redirect introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/revalidatePath", "title": "Functions: revalidatePath | Next.js", "text": "revalidatePath\nrevalidatePath\nallows you to purge cached data on-demand for a specific path.\nGood to know:\nrevalidatePath\nis available in both Node.js and Edge runtimes.revalidatePath\nonly invalidates the cache when the included path is next visited. This means callingrevalidatePath\nwith a dynamic route segment will not immediately trigger many revalidations at once. The invalidation only happens when the path is next visited.- Currently,\nrevalidatePath\ninvalidates all the routes in the client-side Router Cache when used in a server action. This behavior is temporary and will be updated in the future to apply only to the specific path.- Using\nrevalidatePath\ninvalidates only the specific path in the server-side Route Cache.\nParameters\nrevalidatePath(path: string, type?: 'page' | 'layout'): void;\npath\n: Either a string representing the filesystem path associated with the data you want to revalidate (for example,/product/[slug]/page\n), or the literal route segment (for example,/product/123\n). Must be less than 1024 characters. This value is case-sensitive.type\n: (optional)'page'\nor'layout'\nstring to change the type of path to revalidate. Ifpath\ncontains a dynamic segment (for example,/product/[slug]/page\n), this parameter is required. If path refers to the literal route segment, e.g.,/product/1\nfor a dynamic page (e.g.,/product/[slug]/page\n), you should not providetype\n.\nReturns\nrevalidatePath\ndoes not return a value.\nExamples\nRevalidating A Specific URL\nimport { revalidatePath } from 'next/cache'\nrevalidatePath('/blog/post-1')\nThis will revalidate one specific URL on the next page visit.\nRevalidating A Page Path\nimport { revalidatePath } from 'next/cache'\nrevalidatePath('/blog/[slug]', 'page')\n// or with route groups\nrevalidatePath('/(main)/blog/[slug]', 'page')\nThis will revalidate any URL that matches the provided page\nfile on the next page visit. This will not invalidate pages beneath the specific page. For example, /blog/[slug]\nwon't invalidate /blog/[slug]/[author]\n.\nRevalidating A Layout Path\nimport { revalidatePath } from 'next/cache'\nrevalidatePath('/blog/[slug]', 'layout')\n// or with route groups\nrevalidatePath('/(main)/post/[slug]', 'layout')\nThis will revalidate any URL that matches the provided layout\nfile on the next page visit. This will cause pages beneath with the same layout to revalidate on the next visit. For example, in the above case, /blog/[slug]/[another]\nwould also revalidate on the next visit.\nRevalidating All Data\nimport { revalidatePath } from 'next/cache'\nrevalidatePath('/', 'layout')\nThis will purge the Client-side Router Cache, and revalidate the Data Cache on the next page visit.\nServer Action\n'use server'\nimport { revalidatePath } from 'next/cache'\nexport default async function submit() {\nawait submitForm()\nrevalidatePath('/')\n}\nRoute Handler\nimport { revalidatePath } from 'next/cache'\nimport type { NextRequest } from 'next/server'\nexport async function GET(request: NextRequest) {\nconst path = request.nextUrl.searchParams.get('path')\nif (path) {\nrevalidatePath(path)\nreturn Response.json({ revalidated: true, now: Date.now() })\n}\nreturn Response.json({\nrevalidated: false,\nnow: Date.now(),\nmessage: 'Missing path to revalidate',\n})\n}\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/revalidateTag", "title": "Functions: revalidateTag | Next.js", "text": "revalidateTag\nrevalidateTag\nallows you to purge cached data on-demand for a specific cache tag.\nGood to know:\nrevalidateTag\nis available in both Node.js and Edge runtimes.revalidateTag\nonly invalidates the cache when the path is next visited. This means callingrevalidateTag\nwith a dynamic route segment will not immediately trigger many revalidations at once. The invalidation only happens when the path is next visited.\nParameters\nrevalidateTag(tag: string): void;\ntag\n: A string representing the cache tag associated with the data you want to revalidate. Must be less than or equal to 256 characters. This value is case-sensitive.\nYou can add tags to fetch\nas follows:\nfetch(url, { next: { tags: [...] } });\nReturns\nrevalidateTag\ndoes not return a value.\nExamples\nServer Action\napp/actions.ts\n'use server'\nimport { revalidateTag } from 'next/cache'\nexport default async function submit() {\nawait addPost()\nrevalidateTag('posts')\n}\nRoute Handler\napp/api/revalidate/route.ts\nimport type { NextRequest } from 'next/server'\nimport { revalidateTag } from 'next/cache'\nexport async function GET(request: NextRequest) {\nconst tag = request.nextUrl.searchParams.get('tag')\nrevalidateTag(tag)\nreturn Response.json({ revalidated: true, now: Date.now() })\n}\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/unauthorized", "title": "Functions: unauthorized | Next.js", "text": "unauthorized\nThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.\nThe unauthorized\nfunction throws an error that renders a Next.js 401 error page. It's useful for handling authorization errors in your application. You can customize the UI using the unauthorized.js\nfile.\nTo start using unauthorized\n, enable the experimental authInterrupts\nconfiguration option in your next.config.js\nfile:\nnext.config.ts\nimport type { NextConfig } from 'next'\nconst nextConfig: NextConfig = {\nexperimental: {\nauthInterrupts: true,\n},\n}\nexport default nextConfig\nunauthorized\ncan be invoked in Server Components, Server Actions, and Route Handlers.\napp/dashboard/page.tsx\nimport { verifySession } from '@/app/lib/dal'\nimport { unauthorized } from 'next/navigation'\nexport default async function DashboardPage() {\nconst session = await verifySession()\nif (!session) {\nunauthorized()\n}\n// Render the dashboard for authenticated users\nreturn (\n<main>\n<h1>Welcome to the Dashboard</h1>\n<p>Hi, {session.user.name}.</p>\n</main>\n)\n}\nGood to know\n- The\nunauthorized\nfunction cannot be called in the root layout.\nExamples\nDisplaying login UI to unauthenticated users\nYou can use unauthorized\nfunction to display the unauthorized.js\nfile with a login UI.\napp/dashboard/page.tsx\nimport { verifySession } from '@/app/lib/dal'\nimport { unauthorized } from 'next/navigation'\nexport default async function DashboardPage() {\nconst session = await verifySession()\nif (!session) {\nunauthorized()\n}\nreturn <div>Dashboard</div>\n}\napp/unauthorized.tsx\nimport Login from '@/app/components/Login'\nexport default function UnauthorizedPage() {\nreturn (\n<main>\n<h1>401 - Unauthorized</h1>\n<p>Please log in to access this page.</p>\n<Login />\n</main>\n)\n}\nMutations with Server Actions\nYou can invoke unauthorized\nin Server Actions to ensure only authenticated users can perform specific mutations.\napp/actions/update-profile.ts\n'use server'\nimport { verifySession } from '@/app/lib/dal'\nimport { unauthorized } from 'next/navigation'\nimport db from '@/app/lib/db'\nexport async function updateProfile(data: FormData) {\nconst session = await verifySession()\n// If the user is not authenticated, return a 401\nif (!session) {\nunauthorized()\n}\n// Proceed with mutation\n// ...\n}\nFetching data with Route Handlers\nYou can use unauthorized\nin Route Handlers to ensure only authenticated users can access the endpoint.\napp/api/profile/route.ts\nimport { NextRequest, NextResponse } from 'next/server'\nimport { verifySession } from '@/app/lib/dal'\nimport { unauthorized } from 'next/navigation'\nexport async function GET(req: NextRequest): Promise<NextResponse> {\n// Verify the user's session\nconst session = await verifySession()\n// If no session exists, return a 401 and render unauthorized.tsx\nif (!session) {\nunauthorized()\n}\n// Fetch data\n// ...\n}\nVersion History\n| Version | Changes |\n|---|---|\nv15.1.0 | unauthorized introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/after", "title": "Functions: after | Next.js", "text": "after\nafter\nallows you to schedule work to be executed after a response (or prerender) is finished. This is useful for tasks and other side effects that should not block the response, such as logging and analytics.\nIt can be used in Server Components (including generateMetadata\n), Server Actions, Route Handlers, and Middleware.\nThe function accepts a callback that will be executed after the response (or prerender) is finished:\nimport { after } from 'next/server'\n// Custom logging function\nimport { log } from '@/app/utils'\nexport default function Layout({ children }: { children: React.ReactNode }) {\nafter(() => {\n// Execute after the layout is rendered and sent to the user\nlog()\n})\nreturn <>{children}</>\n}\nGood to know:\nafter\nis not a Dynamic API and calling it does not cause a route to become dynamic. If it's used within a static page, the callback will execute at build time, or whenever a page is revalidated.\nReference\nParameters\n- A callback function which will be executed after the response (or prerender) is finished.\nDuration\nafter\nwill run for the platform's default or configured max duration of your route. If your platform supports it, you can configure the timeout limit using the maxDuration\nroute segment config.\nGood to know\nafter\nwill be executed even if the response didn't complete successfully. Including when an error is thrown or whennotFound\norredirect\nis called.- You can use React\ncache\nto deduplicate functions called insideafter\n. after\ncan be nested inside otherafter\ncalls, for example, you can create utility functions that wrapafter\ncalls to add additional functionality.\nAlternatives\nThe use case for after\nis to process secondary tasks without blocking the primary response. It's similar to using the platform's waitUntil()\nor removing await\nfrom a promise, but with the following differences:\nwaitUntil()\n: accepts a promise and enqueues a task to be executed during the lifecycle of the request, whereasafter\naccepts a callback that will be executed after the response is finished.- Removing\nawait\n: starts executing during the response, which uses resources. It's also not reliable in serverless environments as the function stops computation immediately after the response is sent, potentially interrupting the task.\nWe recommend using after\nas it has been designed to consider other Next.js APIs and contexts.\nExamples\nWith request APIs\nYou can use request APIs such as cookies\nand headers\ninside after\nin Server Actions and Route Handlers. This is useful for logging activity after a mutation. For example:\nimport { after } from 'next/server'\nimport { cookies, headers } from 'next/headers'\nimport { logUserAction } from '@/app/utils'\nexport async function POST(request: Request) {\n// Perform mutation\n// ...\n// Log user activity for analytics\nafter(async () => {\nconst userAgent = (await headers().get('user-agent')) || 'unknown'\nconst sessionCookie =\n(await cookies().get('session-id'))?.value || 'anonymous'\nlogUserAction({ sessionCookie, userAgent })\n})\nreturn new Response(JSON.stringify({ status: 'success' }), {\nstatus: 200,\nheaders: { 'Content-Type': 'application/json' },\n})\n}\nHowever, you cannot use these request APIs inside after\nin Server Components. This is because Next.js needs to know which part of the tree access the request APIs to support Partial Prerendering, but after\nruns after React's rendering lifecycle.\n| Version History | Description |\n|---|---|\nv15.1.0 | after became stable. |\nv15.0.0-rc | unstable_after introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/unstable_cache", "title": "Functions: unstable_cache | Next.js", "text": "unstable_cache\nThis is a legacy API and no longer recommended. It's still supported for backward compatibility.\nIn version 15, we recommend using the use cache\ndirective instead.\nunstable_cache\nallows you to cache the results of expensive operations, like database queries, and reuse them across multiple requests.\nimport { getUser } from './data';\nimport { unstable_cache } from 'next/cache';\nconst getCachedUser = unstable_cache(\nasync (id) => getUser(id),\n['my-app-user']\n);\nexport default async function Component({ userID }) {\nconst user = await getCachedUser(userID);\n...\n}\nGood to know:\n- Accessing dynamic data sources such as\nheaders\norcookies\ninside a cache scope is not supported. If you need this data inside a cached function useheaders\noutside of the cached function and pass the required dynamic data in as an argument.- This API uses Next.js' built-in Data Cache to persist the result across requests and deployments.\nWarning: This API is unstable and may change in the future. We will provide migration documentation and codemods, if needed, as this API stabilizes.\nParameters\nconst data = unstable_cache(fetchData, keyParts, options)()\nfetchData\n: This is an asynchronous function that fetches the data you want to cache. It must be a function that returns aPromise\n.keyParts\n: This is an extra array of keys that further adds identification to the cache. By default,unstable_cache\nalready uses the arguments and the stringified version of your function as the cache key. It is optional in most cases; the only time you need to use it is when you use external variables without passing them as parameters. However, it is important to add closures used within the function if you do not pass them as parameters.options\n: This is an object that controls how the cache behaves. It can contain the following properties:tags\n: An array of tags that can be used to control cache invalidation. Next.js will not use this to uniquely identify the function.revalidate\n: The number of seconds after which the cache should be revalidated. Omit or passfalse\nto cache indefinitely or until matchingrevalidateTag()\norrevalidatePath()\nmethods are called.\nReturns\nunstable_cache\nreturns a function that when invoked, returns a Promise that resolves to the cached data. If the data is not in the cache, the provided function will be invoked, and its result will be cached and returned.\nExample\napp/page.tsx\nimport { unstable_cache } from 'next/cache'\nexport default async function Page({ params }: { params: { userId: string } }) {\nconst getCachedUser = unstable_cache(\nasync () => {\nreturn { id: params.userId }\n},\n[params.userId], // add the user ID to the cache key\n{\ntags: ['users'],\nrevalidate: 60,\n}\n)\n//...\n}\nVersion History\n| Version | Changes |\n|---|---|\nv14.0.0 | unstable_cache introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/revalidatePath", "title": "Functions: revalidatePath | Next.js", "text": "revalidatePath\nrevalidatePath\nallows you to purge cached data on-demand for a specific path.\nGood to know:\nrevalidatePath\nis available in both Node.js and Edge runtimes.revalidatePath\nonly invalidates the cache when the included path is next visited. This means callingrevalidatePath\nwith a dynamic route segment will not immediately trigger many revalidations at once. The invalidation only happens when the path is next visited.- Currently,\nrevalidatePath\ninvalidates all the routes in the client-side Router Cache when used in a server action. This behavior is temporary and will be updated in the future to apply only to the specific path.- Using\nrevalidatePath\ninvalidates only the specific path in the server-side Route Cache.\nParameters\nrevalidatePath(path: string, type?: 'page' | 'layout'): void;\npath\n: Either a string representing the filesystem path associated with the data you want to revalidate (for example,/product/[slug]/page\n), or the literal route segment (for example,/product/123\n). Must be less than 1024 characters. This value is case-sensitive.type\n: (optional)'page'\nor'layout'\nstring to change the type of path to revalidate. Ifpath\ncontains a dynamic segment (for example,/product/[slug]/page\n), this parameter is required. If path refers to the literal route segment, e.g.,/product/1\nfor a dynamic page (e.g.,/product/[slug]/page\n), you should not providetype\n.\nReturns\nrevalidatePath\ndoes not return a value.\nExamples\nRevalidating A Specific URL\nimport { revalidatePath } from 'next/cache'\nrevalidatePath('/blog/post-1')\nThis will revalidate one specific URL on the next page visit.\nRevalidating A Page Path\nimport { revalidatePath } from 'next/cache'\nrevalidatePath('/blog/[slug]', 'page')\n// or with route groups\nrevalidatePath('/(main)/blog/[slug]', 'page')\nThis will revalidate any URL that matches the provided page\nfile on the next page visit. This will not invalidate pages beneath the specific page. For example, /blog/[slug]\nwon't invalidate /blog/[slug]/[author]\n.\nRevalidating A Layout Path\nimport { revalidatePath } from 'next/cache'\nrevalidatePath('/blog/[slug]', 'layout')\n// or with route groups\nrevalidatePath('/(main)/post/[slug]', 'layout')\nThis will revalidate any URL that matches the provided layout\nfile on the next page visit. This will cause pages beneath with the same layout to revalidate on the next visit. For example, in the above case, /blog/[slug]/[another]\nwould also revalidate on the next visit.\nRevalidating All Data\nimport { revalidatePath } from 'next/cache'\nrevalidatePath('/', 'layout')\nThis will purge the Client-side Router Cache, and revalidate the Data Cache on the next page visit.\nServer Action\n'use server'\nimport { revalidatePath } from 'next/cache'\nexport default async function submit() {\nawait submitForm()\nrevalidatePath('/')\n}\nRoute Handler\nimport { revalidatePath } from 'next/cache'\nimport type { NextRequest } from 'next/server'\nexport async function GET(request: NextRequest) {\nconst path = request.nextUrl.searchParams.get('path')\nif (path) {\nrevalidatePath(path)\nreturn Response.json({ revalidated: true, now: Date.now() })\n}\nreturn Response.json({\nrevalidated: false,\nnow: Date.now(),\nmessage: 'Missing path to revalidate',\n})\n}\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/revalidateTag", "title": "Functions: revalidateTag | Next.js", "text": "revalidateTag\nrevalidateTag\nallows you to purge cached data on-demand for a specific cache tag.\nGood to know:\nrevalidateTag\nis available in both Node.js and Edge runtimes.revalidateTag\nonly invalidates the cache when the path is next visited. This means callingrevalidateTag\nwith a dynamic route segment will not immediately trigger many revalidations at once. The invalidation only happens when the path is next visited.\nParameters\nrevalidateTag(tag: string): void;\ntag\n: A string representing the cache tag associated with the data you want to revalidate. Must be less than or equal to 256 characters. This value is case-sensitive.\nYou can add tags to fetch\nas follows:\nfetch(url, { next: { tags: [...] } });\nReturns\nrevalidateTag\ndoes not return a value.\nExamples\nServer Action\napp/actions.ts\n'use server'\nimport { revalidateTag } from 'next/cache'\nexport default async function submit() {\nawait addPost()\nrevalidateTag('posts')\n}\nRoute Handler\napp/api/revalidate/route.ts\nimport type { NextRequest } from 'next/server'\nimport { revalidateTag } from 'next/cache'\nexport async function GET(request: NextRequest) {\nconst tag = request.nextUrl.searchParams.get('tag')\nrevalidateTag(tag)\nreturn Response.json({ revalidated: true, now: Date.now() })\n}\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/unstable_noStore", "title": "Functions: unstable_noStore | Next.js", "text": "unstable_noStore\nThis is a legacy API and no longer recommended. It's still supported for backward compatibility.\nIn version 15, we recommend using connection\ninstead of unstable_noStore\n.\nunstable_noStore\ncan be used to declaratively opt out of static rendering and indicate a particular component should not be cached.\nimport { unstable_noStore as noStore } from 'next/cache';\nexport default async function ServerComponent() {\nnoStore();\nconst result = await db.query(...);\n...\n}\nGood to know:\nunstable_noStore\nis equivalent tocache: 'no-store'\non afetch\nunstable_noStore\nis preferred overexport const dynamic = 'force-dynamic'\nas it is more granular and can be used on a per-component basis\n- Using\nunstable_noStore\ninsideunstable_cache\nwill not opt out of static generation. Instead, it will defer to the cache configuration to determine whether to cache the result or not.\nUsage\nIf you prefer not to pass additional options to fetch\n, like cache: 'no-store'\n, next: { revalidate: 0 }\nor in cases where fetch\nis not available, you can use noStore()\nas a replacement for all of these use cases.\nimport { unstable_noStore as noStore } from 'next/cache';\nexport default async function ServerComponent() {\nnoStore();\nconst result = await db.query(...);\n...\n}\nVersion History\n| Version | Changes |\n|---|---|\nv15.0.0 | unstable_noStore deprecated for connection . |\nv14.0.0 | unstable_noStore introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow", "title": "Functions: unstable_rethrow | Next.js", "text": "unstable_rethrow\nunstable_rethrow\ncan be used to avoid catching internal errors thrown by Next.js when attempting to handle errors thrown in your application code.\nFor example, calling the notFound\nfunction will throw an internal Next.js error and render the not-found.js\ncomponent. However, if used inside a try/catch\nblock, the error will be caught, preventing not-found.js\nfrom rendering:\nimport { notFound } from 'next/navigation'\nexport default async function Page() {\ntry {\nconst post = await fetch('https://.../posts/1').then((res) => {\nif (res.status === 404) notFound()\nif (!res.ok) throw new Error(res.statusText)\nreturn res.json()\n})\n} catch (err) {\nconsole.error(err)\n}\n}\nYou can use unstable_rethrow\nAPI to re-throw the internal error and continue with the expected behavior:\nimport { notFound, unstable_rethrow } from 'next/navigation'\nexport default async function Page() {\ntry {\nconst post = await fetch('https://.../posts/1').then((res) => {\nif (res.status === 404) notFound()\nif (!res.ok) throw new Error(res.statusText)\nreturn res.json()\n})\n} catch (err) {\nunstable_rethrow(err)\nconsole.error(err)\n}\n}\nThe following Next.js APIs rely on throwing an error which should be rethrown and handled by Next.js itself:\nIf a route segment is marked to throw an error unless it's static, a Dynamic API call will also throw an error that should similarly not be caught by the developer. Note that Partial Prerendering (PPR) affects this behavior as well. These APIs are:\ncookies\nheaders\nsearchParams\nfetch(..., { cache: 'no-store' })\nfetch(..., { next: { revalidate: 0 } })\nGood to know:\n- This method should be called at the top of the catch block, passing the error object as its only argument. It can also be used within a\n.catch\nhandler of a promise.- If you ensure that your calls to APIs that throw are not wrapped in a try/catch then you don't need to use\nunstable_rethrow\n- Any resource cleanup (like clearing intervals, timers, etc) would have to either happen prior to the call to\nunstable_rethrow\nor within afinally\nblock.\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-params", "title": "Functions: useParams | Next.js", "text": "useParams\nuseParams\nis a Client Component hook that lets you read a route's dynamic params filled in by the current URL.\napp/example-client-component.tsx\n'use client'\nimport { useParams } from 'next/navigation'\nexport default function ExampleClientComponent() {\nconst params = useParams<{ tag: string; item: string }>()\n// Route -> /shop/[tag]/[item]\n// URL -> /shop/shoes/nike-air-max-97\n// `params` -> { tag: 'shoes', item: 'nike-air-max-97' }\nconsole.log(params)\nreturn '...'\n}\nParameters\nconst params = useParams()\nuseParams\ndoes not take any parameters.\nReturns\nuseParams\nreturns an object containing the current route's filled in dynamic parameters.\n- Each property in the object is an active dynamic segment.\n- The properties name is the segment's name, and the properties value is what the segment is filled in with.\n- The properties value will either be a\nstring\nor array ofstring\n's depending on the type of dynamic segment. - If the route contains no dynamic parameters,\nuseParams\nreturns an empty object. - If used in Pages Router,\nuseParams\nwill returnnull\non the initial render and updates with properties following the rules above once the router is ready.\nFor example:\n| Route | URL | useParams() |\n|---|---|---|\napp/shop/page.js | /shop | {} |\napp/shop/[slug]/page.js | /shop/1 | { slug: '1' } |\napp/shop/[tag]/[item]/page.js | /shop/1/2 | { tag: '1', item: '2' } |\napp/shop/[...slug]/page.js | /shop/1/2 | { slug: ['1', '2'] } |\nVersion History\n| Version | Changes |\n|---|---|\nv13.3.0 | useParams introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-pathname", "title": "Functions: usePathname | Next.js", "text": "usePathname\nusePathname\nis a Client Component hook that lets you read the current URL's pathname.\napp/example-client-component.tsx\n'use client'\nimport { usePathname } from 'next/navigation'\nexport default function ExampleClientComponent() {\nconst pathname = usePathname()\nreturn <p>Current pathname: {pathname}</p>\n}\nusePathname\nintentionally requires using a Client Component. It's important to note Client Components are not a de-optimization. They are an integral part of the Server Components architecture.\nFor example, a Client Component with usePathname\nwill be rendered into HTML on the initial page load. When navigating to a new route, this component does not need to be re-fetched. Instead, the component is downloaded once (in the client JavaScript bundle), and re-renders based on the current state.\nGood to know:\n- Reading the current URL from a Server Component is not supported. This design is intentional to support layout state being preserved across page navigations.\n- Compatibility mode:\nusePathname\ncan returnnull\nwhen a fallback route is being rendered or when apages\ndirectory page has been automatically statically optimized by Next.js and the router is not ready.- When using\nusePathname\nwith rewrites innext.config\norMiddleware\n,useState\nanduseEffect\nmust also be used in order to avoid hydration mismatch errors. See the rewrites example for more information.- Next.js will automatically update your types if it detects both an\napp\nandpages\ndirectory in your project.\nParameters\nconst pathname = usePathname()\nusePathname\ndoes not take any parameters.\nReturns\nusePathname\nreturns a string of the current URL's pathname. For example:\n| URL | Returned value |\n|---|---|\n/ | '/' |\n/dashboard | '/dashboard' |\n/dashboard?v=2 | '/dashboard' |\n/blog/hello-world | '/blog/hello-world' |\nExamples\nDo something in response to a route change\napp/example-client-component.tsx\n'use client'\nimport { usePathname, useSearchParams } from 'next/navigation'\nfunction ExampleClientComponent() {\nconst pathname = usePathname()\nconst searchParams = useSearchParams()\nuseEffect(() => {\n// Do something here...\n}, [pathname, searchParams])\n}\n| Version | Changes |\n|---|---|\nv13.0.0 | usePathname introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-report-web-vitals", "title": "Functions: useReportWebVitals | Next.js", "text": "useReportWebVitals\nThe useReportWebVitals\nhook allows you to report Core Web Vitals, and can be used in combination with your analytics service.\n'use client'\nimport { useReportWebVitals } from 'next/web-vitals'\nexport function WebVitals() {\nuseReportWebVitals((metric) => {\nconsole.log(metric)\n})\nreturn null\n}\nimport { WebVitals } from './_components/web-vitals'\nexport default function Layout({ children }) {\nreturn (\n<html>\n<body>\n<WebVitals />\n{children}\n</body>\n</html>\n)\n}\nSince the\nuseReportWebVitals\nhook requires the\"use client\"\ndirective, the most performant approach is to create a separate component that the root layout imports. This confines the client boundary exclusively to theWebVitals\ncomponent.\nuseReportWebVitals\nThe metric\nobject passed as the hook's argument consists of a number of properties:\nid\n: Unique identifier for the metric in the context of the current page loadname\n: The name of the performance metric. Possible values include names of Web Vitals metrics (TTFB, FCP, LCP, FID, CLS) specific to a web application.delta\n: The difference between the current value and the previous value of the metric. The value is typically in milliseconds and represents the change in the metric's value over time.entries\n: An array of Performance Entries associated with the metric. These entries provide detailed information about the performance events related to the metric.navigationType\n: Indicates the type of navigation that triggered the metric collection. Possible values include\"navigate\"\n,\"reload\"\n,\"back_forward\"\n, and\"prerender\"\n.rating\n: A qualitative rating of the metric value, providing an assessment of the performance. Possible values are\"good\"\n,\"needs-improvement\"\n, and\"poor\"\n. The rating is typically determined by comparing the metric value against predefined thresholds that indicate acceptable or suboptimal performance.value\n: The actual value or duration of the performance entry, typically in milliseconds. The value provides a quantitative measure of the performance aspect being tracked by the metric. The source of the value depends on the specific metric being measured and can come from various Performance APIs.\nWeb Vitals\nWeb Vitals are a set of useful metrics that aim to capture the user experience of a web page. The following web vitals are all included:\n- Time to First Byte (TTFB)\n- First Contentful Paint (FCP)\n- Largest Contentful Paint (LCP)\n- First Input Delay (FID)\n- Cumulative Layout Shift (CLS)\n- Interaction to Next Paint (INP)\nYou can handle all the results of these metrics using the name\nproperty.\n'use client'\nimport { useReportWebVitals } from 'next/web-vitals'\nexport function WebVitals() {\nuseReportWebVitals((metric) => {\nswitch (metric.name) {\ncase 'FCP': {\n// handle FCP results\n}\ncase 'LCP': {\n// handle LCP results\n}\n// ...\n}\n})\n}\nUsage on Vercel\nVercel Speed Insights does not useReportWebVitals\n, but @vercel/speed-insights\npackage instead.\nuseReportWebVitals\nhook is useful in local development, or if you're using a different service for collecting Web Vitals.\nSending results to external systems\nYou can send results to any endpoint to measure and track real user performance on your site. For example:\nuseReportWebVitals((metric) => {\nconst body = JSON.stringify(metric)\nconst url = 'https://example.com/analytics'\n// Use `navigator.sendBeacon()` if available, falling back to `fetch()`.\nif (navigator.sendBeacon) {\nnavigator.sendBeacon(url, body)\n} else {\nfetch(url, { body, method: 'POST', keepalive: true })\n}\n})\nGood to know: If you use Google Analytics, using the\nid\nvalue can allow you to construct metric distributions manually (to calculate percentiles, etc.)\nuseReportWebVitals(metric => { // Use `window.gtag` if you initialized Google Analytics as this example: // https://github.com/vercel/next.js/blob/canary/examples/with-google-analytics window.gtag('event', metric.name, { value: Math.round(metric.name === 'CLS' ? metric.value * 1000 : metric.value), // values must be integers event_label: metric.id, // id unique to current page load non_interaction: true, // avoids affecting bounce rate. }); }\nRead more about sending results to Google Analytics.\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-router", "title": "Functions: useRouter | Next.js", "text": "useRouter\nThe useRouter\nhook allows you to programmatically change routes inside Client Components.\nRecommendation: Use the\n<Link>\ncomponent for navigation unless you have a specific requirement for usinguseRouter\n.\n'use client'\nimport { useRouter } from 'next/navigation'\nexport default function Page() {\nconst router = useRouter()\nreturn (\n<button type=\"button\" onClick={() => router.push('/dashboard')}>\nDashboard\n</button>\n)\n}\nuseRouter()\nrouter.push(href: string, { scroll: boolean })\n: Perform a client-side navigation to the provided route. Adds a new entry into the browser\u2019s history stack.router.replace(href: string, { scroll: boolean })\n: Perform a client-side navigation to the provided route without adding a new entry into the browser\u2019s history stack.router.refresh()\n: Refresh the current route. Making a new request to the server, re-fetching data requests, and re-rendering Server Components. The client will merge the updated React Server Component payload without losing unaffected client-side React (e.g.useState\n) or browser state (e.g. scroll position).router.prefetch(href: string)\n: Prefetch the provided route for faster client-side transitions.router.back()\n: Navigate back to the previous route in the browser\u2019s history stack.router.forward()\n: Navigate forwards to the next page in the browser\u2019s history stack.\nGood to know:\n- You must not send untrusted or unsanitized URLs to\nrouter.push\norrouter.replace\n, as this can open your site to cross-site scripting (XSS) vulnerabilities. For example,javascript:\nURLs sent torouter.push\norrouter.replace\nwill be executed in the context of your page.- The\n<Link>\ncomponent automatically prefetch routes as they become visible in the viewport.refresh()\ncould re-produce the same result if fetch requests are cached. Other Dynamic APIs likecookies\nandheaders\ncould also change the response.\nMigrating from next/router\n- The\nuseRouter\nhook should be imported fromnext/navigation\nand notnext/router\nwhen using the App Router - The\npathname\nstring has been removed and is replaced byusePathname()\n- The\nquery\nobject has been removed and is replaced byuseSearchParams()\nrouter.events\nhas been replaced. See below.\nView the full migration guide.\nExamples\nRouter events\nYou can listen for page changes by composing other Client Component hooks like usePathname\nand useSearchParams\n.\n'use client'\nimport { useEffect } from 'react'\nimport { usePathname, useSearchParams } from 'next/navigation'\nexport function NavigationEvents() {\nconst pathname = usePathname()\nconst searchParams = useSearchParams()\nuseEffect(() => {\nconst url = `${pathname}?${searchParams}`\nconsole.log(url)\n// You can now use the current URL\n// ...\n}, [pathname, searchParams])\nreturn '...'\n}\nWhich can be imported into a layout.\nimport { Suspense } from 'react'\nimport { NavigationEvents } from './components/navigation-events'\nexport default function Layout({ children }) {\nreturn (\n<html lang=\"en\">\n<body>\n{children}\n<Suspense fallback={null}>\n<NavigationEvents />\n</Suspense>\n</body>\n</html>\n)\n}\nGood to know:\n<NavigationEvents>\nis wrapped in aSuspense\nboundary becauseuseSearchParams()\ncauses client-side rendering up to the closestSuspense\nboundary during static rendering. Learn more.\nDisabling scroll to top\nBy default, Next.js will scroll to the top of the page when navigating to a new route. You can disable this behavior by passing scroll: false\nto router.push()\nor router.replace()\n.\n'use client'\nimport { useRouter } from 'next/navigation'\nexport default function Page() {\nconst router = useRouter()\nreturn (\n<button\ntype=\"button\"\nonClick={() => router.push('/dashboard', { scroll: false })}\n>\nDashboard\n</button>\n)\n}\nVersion History\n| Version | Changes |\n|---|---|\nv13.0.0 | useRouter from next/navigation introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-search-params", "title": "Functions: useSearchParams | Next.js", "text": "useSearchParams\nuseSearchParams\nis a Client Component hook that lets you read the current URL's query string.\nuseSearchParams\nreturns a read-only version of the URLSearchParams\ninterface.\n'use client'\nimport { useSearchParams } from 'next/navigation'\nexport default function SearchBar() {\nconst searchParams = useSearchParams()\nconst search = searchParams.get('search')\n// URL -> `/dashboard?search=my-project`\n// `search` -> 'my-project'\nreturn <>Search: {search}</>\n}\nParameters\nconst searchParams = useSearchParams()\nuseSearchParams\ndoes not take any parameters.\nReturns\nuseSearchParams\nreturns a read-only version of the URLSearchParams\ninterface, which includes utility methods for reading the URL's query string:\n-\nURLSearchParams.get()\n: Returns the first value associated with the search parameter. For example:URL searchParams.get(\"a\")\n/dashboard?a=1\n'1'\n/dashboard?a=\n''\n/dashboard?b=3\nnull\n/dashboard?a=1&a=2\n'1'\n- usegetAll()\nto get all values -\nURLSearchParams.has()\n: Returns a boolean value indicating if the given parameter exists. For example:URL searchParams.has(\"a\")\n/dashboard?a=1\ntrue\n/dashboard?b=3\nfalse\n-\nLearn more about other read-only methods of\nURLSearchParams\n, including thegetAll()\n,keys()\n,values()\n,entries()\n,forEach()\n, andtoString()\n.\nGood to know:\nuseSearchParams\nis a Client Component hook and is not supported in Server Components to prevent stale values during partial rendering.- If an application includes the\n/pages\ndirectory,useSearchParams\nwill returnReadonlyURLSearchParams | null\n. Thenull\nvalue is for compatibility during migration since search params cannot be known during pre-rendering of a page that doesn't usegetServerSideProps\nBehavior\nStatic Rendering\nIf a route is statically rendered, calling useSearchParams\nwill cause the Client Component tree up to the closest Suspense\nboundary to be client-side rendered.\nThis allows a part of the route to be statically rendered while the dynamic part that uses useSearchParams\nis client-side rendered.\nWe recommend wrapping the Client Component that uses useSearchParams\nin a <Suspense/>\nboundary. This will allow any Client Components above it to be statically rendered and sent as part of initial HTML. Example.\nFor example:\n'use client'\nimport { useSearchParams } from 'next/navigation'\nexport default function SearchBar() {\nconst searchParams = useSearchParams()\nconst search = searchParams.get('search')\n// This will not be logged on the server when using static rendering\nconsole.log(search)\nreturn <>Search: {search}</>\n}\nimport { Suspense } from 'react'\nimport SearchBar from './search-bar'\n// This component passed as a fallback to the Suspense boundary\n// will be rendered in place of the search bar in the initial HTML.\n// When the value is available during React hydration the fallback\n// will be replaced with the `<SearchBar>` component.\nfunction SearchBarFallback() {\nreturn <>placeholder</>\n}\nexport default function Page() {\nreturn (\n<>\n<nav>\n<Suspense fallback={<SearchBarFallback />}>\n<SearchBar />\n</Suspense>\n</nav>\n<h1>Dashboard</h1>\n</>\n)\n}\nDynamic Rendering\nIf a route is dynamically rendered, useSearchParams\nwill be available on the server during the initial server render of the Client Component.\nFor example:\n'use client'\nimport { useSearchParams } from 'next/navigation'\nexport default function SearchBar() {\nconst searchParams = useSearchParams()\nconst search = searchParams.get('search')\n// This will be logged on the server during the initial render\n// and on the client on subsequent navigations.\nconsole.log(search)\nreturn <>Search: {search}</>\n}\nimport SearchBar from './search-bar'\nexport const dynamic = 'force-dynamic'\nexport default function Page() {\nreturn (\n<>\n<nav>\n<SearchBar />\n</nav>\n<h1>Dashboard</h1>\n</>\n)\n}\nGood to know: Setting the\ndynamic\nroute segment config option toforce-dynamic\ncan be used to force dynamic rendering.\nServer Components\nPages\nTo access search params in Pages (Server Components), use the searchParams\nprop.\nLayouts\nUnlike Pages, Layouts (Server Components) do not receive the searchParams\nprop. This is because a shared layout is not re-rendered during navigation which could lead to stale searchParams\nbetween navigations. View detailed explanation.\nInstead, use the Page searchParams\nprop or the useSearchParams\nhook in a Client Component, which is re-rendered on the client with the latest searchParams\n.\nExamples\nUpdating searchParams\nYou can use useRouter\nor Link\nto set new searchParams\n. After a navigation is performed, the current page.js\nwill receive an updated searchParams\nprop.\n'use client'\nexport default function ExampleClientComponent() {\nconst router = useRouter()\nconst pathname = usePathname()\nconst searchParams = useSearchParams()\n// Get a new searchParams string by merging the current\n// searchParams with a provided key/value pair\nconst createQueryString = useCallback(\n(name: string, value: string) => {\nconst params = new URLSearchParams(searchParams.toString())\nparams.set(name, value)\nreturn params.toString()\n},\n[searchParams]\n)\nreturn (\n<>\n<p>Sort By</p>\n{/* using useRouter */}\n<button\nonClick={() => {\n// <pathname>?sort=asc\nrouter.push(pathname + '?' + createQueryString('sort', 'asc'))\n}}\n>\nASC\n</button>\n{/* using <Link> */}\n<Link\nhref={\n// <pathname>?sort=desc\npathname + '?' + createQueryString('sort', 'desc')\n}\n>\nDESC\n</Link>\n</>\n)\n}\nVersion History\n| Version | Changes |\n|---|---|\nv13.0.0 | useSearchParams introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segment", "title": "Functions: useSelectedLayoutSegment | Next.js", "text": "useSelectedLayoutSegment\nuseSelectedLayoutSegment\nis a Client Component hook that lets you read the active route segment one level below the Layout it is called from.\nIt is useful for navigation UI, such as tabs inside a parent layout that change style depending on the active child segment.\n'use client'\nimport { useSelectedLayoutSegment } from 'next/navigation'\nexport default function ExampleClientComponent() {\nconst segment = useSelectedLayoutSegment()\nreturn <p>Active segment: {segment}</p>\n}\nGood to know:\n- Since\nuseSelectedLayoutSegment\nis a Client Component hook, and Layouts are Server Components by default,useSelectedLayoutSegment\nis usually called via a Client Component that is imported into a Layout.useSelectedLayoutSegment\nonly returns the segment one level down. To return all active segments, seeuseSelectedLayoutSegments\nParameters\nconst segment = useSelectedLayoutSegment(parallelRoutesKey?: string)\nuseSelectedLayoutSegment\noptionally accepts a parallelRoutesKey\n, which allows you to read the active route segment within that slot.\nReturns\nuseSelectedLayoutSegment\nreturns a string of the active segment or null\nif one doesn't exist.\nFor example, given the Layouts and URLs below, the returned segment would be:\n| Layout | Visited URL | Returned Segment |\n|---|---|---|\napp/layout.js | / | null |\napp/layout.js | /dashboard | 'dashboard' |\napp/dashboard/layout.js | /dashboard | null |\napp/dashboard/layout.js | /dashboard/settings | 'settings' |\napp/dashboard/layout.js | /dashboard/analytics | 'analytics' |\napp/dashboard/layout.js | /dashboard/analytics/monthly | 'analytics' |\nExamples\nCreating an active link component\nYou can use useSelectedLayoutSegment\nto create an active link component that changes style depending on the active segment. For example, a featured posts list in the sidebar of a blog:\n'use client'\nimport Link from 'next/link'\nimport { useSelectedLayoutSegment } from 'next/navigation'\n// This *client* component will be imported into a blog layout\nexport default function BlogNavLink({\nslug,\nchildren,\n}: {\nslug: string\nchildren: React.ReactNode\n}) {\n// Navigating to `/blog/hello-world` will return 'hello-world'\n// for the selected layout segment\nconst segment = useSelectedLayoutSegment()\nconst isActive = slug === segment\nreturn (\n<Link\nhref={`/blog/${slug}`}\n// Change style depending on whether the link is active\nstyle={{ fontWeight: isActive ? 'bold' : 'normal' }}\n>\n{children}\n</Link>\n)\n}\n// Import the Client Component into a parent Layout (Server Component)\nimport { BlogNavLink } from './blog-nav-link'\nimport getFeaturedPosts from './get-featured-posts'\nexport default async function Layout({\nchildren,\n}: {\nchildren: React.ReactNode\n}) {\nconst featuredPosts = await getFeaturedPosts()\nreturn (\n<div>\n{featuredPosts.map((post) => (\n<div key={post.id}>\n<BlogNavLink slug={post.slug}>{post.title}</BlogNavLink>\n</div>\n))}\n<div>{children}</div>\n</div>\n)\n}\nVersion History\n| Version | Changes |\n|---|---|\nv13.0.0 | useSelectedLayoutSegment introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segments", "title": "Functions: useSelectedLayoutSegments | Next.js", "text": "useSelectedLayoutSegments\nuseSelectedLayoutSegments\nis a Client Component hook that lets you read the active route segments below the Layout it is called from.\nIt is useful for creating UI in parent Layouts that need knowledge of active child segments such as breadcrumbs.\napp/example-client-component.tsx\n'use client'\nimport { useSelectedLayoutSegments } from 'next/navigation'\nexport default function ExampleClientComponent() {\nconst segments = useSelectedLayoutSegments()\nreturn (\n<ul>\n{segments.map((segment, index) => (\n<li key={index}>{segment}</li>\n))}\n</ul>\n)\n}\nGood to know:\n- Since\nuseSelectedLayoutSegments\nis a Client Component hook, and Layouts are Server Components by default,useSelectedLayoutSegments\nis usually called via a Client Component that is imported into a Layout.- The returned segments include Route Groups, which you might not want to be included in your UI. You can use the\nfilter()\narray method to remove items that start with a bracket.\nParameters\nconst segments = useSelectedLayoutSegments(parallelRoutesKey?: string)\nuseSelectedLayoutSegments\noptionally accepts a parallelRoutesKey\n, which allows you to read the active route segment within that slot.\nReturns\nuseSelectedLayoutSegments\nreturns an array of strings containing the active segments one level down from the layout the hook was called from. Or an empty array if none exist.\nFor example, given the Layouts and URLs below, the returned segments would be:\n| Layout | Visited URL | Returned Segments |\n|---|---|---|\napp/layout.js | / | [] |\napp/layout.js | /dashboard | ['dashboard'] |\napp/layout.js | /dashboard/settings | ['dashboard', 'settings'] |\napp/dashboard/layout.js | /dashboard | [] |\napp/dashboard/layout.js | /dashboard/settings | ['settings'] |\nVersion History\n| Version | Changes |\n|---|---|\nv13.0.0 | useSelectedLayoutSegments introduced. |\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/userAgent", "title": "Functions: userAgent | Next.js", "text": "userAgent\nThe userAgent\nhelper extends the Web Request API with additional properties and methods to interact with the user agent object from the request.\nmiddleware.ts\nimport { NextRequest, NextResponse, userAgent } from 'next/server'\nexport function middleware(request: NextRequest) {\nconst url = request.nextUrl\nconst { device } = userAgent(request)\nconst viewport = device.type === 'mobile' ? 'mobile' : 'desktop'\nurl.searchParams.set('viewport', viewport)\nreturn NextResponse.rewrite(url)\n}\nisBot\nA boolean indicating whether the request comes from a known bot.\nbrowser\nAn object containing information about the browser used in the request.\nname\n: A string representing the browser's name, orundefined\nif not identifiable.version\n: A string representing the browser's version, orundefined\n.\ndevice\nAn object containing information about the device used in the request.\nmodel\n: A string representing the model of the device, orundefined\n.type\n: A string representing the type of the device, such asconsole\n,mobile\n,tablet\n,smarttv\n,wearable\n,embedded\n, orundefined\n.vendor\n: A string representing the vendor of the device, orundefined\n.\nengine\nAn object containing information about the browser's engine.\nname\n: A string representing the engine's name. Possible values include:Amaya\n,Blink\n,EdgeHTML\n,Flow\n,Gecko\n,Goanna\n,iCab\n,KHTML\n,Links\n,Lynx\n,NetFront\n,NetSurf\n,Presto\n,Tasman\n,Trident\n,w3m\n,WebKit\norundefined\n.version\n: A string representing the engine's version, orundefined\n.\nos\nAn object containing information about the operating system.\nname\n: A string representing the name of the OS, orundefined\n.version\n: A string representing the version of the OS, orundefined\n.\ncpu\nAn object containing information about the CPU architecture.\narchitecture\n: A string representing the architecture of the CPU. Possible values include:68k\n,amd64\n,arm\n,arm64\n,armhf\n,avr\n,ia32\n,ia64\n,irix\n,irix64\n,mips\n,mips64\n,pa-risc\n,ppc\n,sparc\n,sparc64\norundefined\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/turbopack", "title": "API Reference: Turbopack | Next.js", "text": "Turbopack\nTurbopack is an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js. Turbopack can be used in Next.js in both the pages\nand app\ndirectories for faster local development.\nTo enable Turbopack, use the --turbopack\nflag when running the Next.js development server.\n{\n\"scripts\": {\n\"dev\": \"next dev --turbopack\",\n\"build\": \"next build\",\n\"start\": \"next start\",\n\"lint\": \"next lint\"\n}\n}\nReference\nSupported features\nTurbopack in Next.js requires zero-configuration for most users and can be extended for more advanced use cases. To learn more about the currently supported features for Turbopack, view the API Reference.\nUnsupported features\nTurbopack currently only supports next dev\nand does not support next build\n. We are currently working on support for builds as we move closer towards stability.\nThese features are currently not supported:\n- Turbopack leverages Lightning CSS which doesn't support some low usage CSS Modules features\n:local\nand:global\nas standalone pseudo classes. Only the function variant is supported, for example::global(a)\n.- The @value rule which has been superseded by CSS variables.\n:import\nand:export\nICSS rules.\n- Invalid CSS comment syntax such as\n//\n- CSS comments should be written as\n/* comment */\nper the specification. - Preprocessors such as Sass do support this alternative syntax for comments.\n- CSS comments should be written as\nwebpack()\nconfiguration innext.config.js\n- Turbopack replaces Webpack, this means that webpack configuration is not supported.\n- To configure Turbopack, see the documentation.\n- A subset of Webpack loaders are supported in Turbopack.\n- Babel (\n.babelrc\n)- Turbopack leverages the SWC compiler for all transpilation and optimizations. This means that Babel is not included by default.\n- If you have a\n.babelrc\nfile, you might no longer need it because Next.js includes common Babel plugins as SWC transforms that can be enabled. You can read more about this in the compiler documentation. - If you still need to use Babel after verifying your particular use case is not covered, you can leverage Turbopack's support for custom webpack loaders to include\nbabel-loader\n.\n- Creating a root layout automatically in App Router.\n- This behavior is currently not supported since it changes input files, instead, an error will be shown for you to manually add a root layout in the desired location.\n@next/font\n(legacy font support).@next/font\nis deprecated in favor ofnext/font\n.next/font\nis fully supported with Turbopack.\n- Relay transforms\n- We are planning to implement this in the future.\n- Blocking\n.css\nimports inpages/_document.tsx\n- Currently with webpack Next.js blocks importing\n.css\nfiles inpages/_document.tsx\n- We are planning to implement this warning in the future.\n- Currently with webpack Next.js blocks importing\nexperimental.typedRoutes\n- We are planning to implement this in the future.\nexperimental.nextScriptWorkers\n- We are planning to implement this in the future.\nexperimental.sri.algorithm\n- We are planning to implement this in the future.\nexperimental.fallbackNodePolyfills\n- We are planning to implement this in the future.\nexperimental.esmExternals\n- We are currently not planning to support the legacy esmExternals configuration in Next.js with Turbopack.\n- AMP.\n- We are currently not planning to support AMP in Next.js with Turbopack.\n- Yarn PnP\n- We are currently not planning to support Yarn PnP in Next.js with Turbopack.\nexperimental.urlImports\n- We are currently not planning to support\nexperimental.urlImports\nin Next.js with Turbopack.\n- We are currently not planning to support\n:import\nand:export\nICSS rules- We are currently not planning to support\n:import\nand:export\nICSS rules in Next.js with Turbopack as Lightning CSS the CSS parser Turbopack uses does not support these rules.\n- We are currently not planning to support\nunstable_allowDynamic\nconfiguration in edge runtime\nExamples\nGenerating Trace Files\nTrace files allow the Next.js team to investigate and improve performance metrics and memory usage. To generate a trace file, append NEXT_TURBOPACK_TRACING=1\nto the next dev --turbopack\ncommand, this will generate a .next/trace-turbopack\nfile.\nWhen reporting issues related to Turbopack performance and memory usage, please include the trace file in your GitHub issue.\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/examples", "title": "App Router: Examples | Next.js", "text": "Examples\nData Fetching\n- Using the\nfetch\nAPI - Using an ORM or database client\n- Reading search params on the server\n- Reading search params on the client\nRevalidating Data\nForms\n- Showing a pending state while submitting a form\n- Server-side form validation\n- Handling expected errors\n- Handling unexpected exceptions\n- Showing optimistic UI updates\n- Programmatic form submission\nServer Actions\nMetadata\n- Creating an RSS feed\n- Creating an Open Graph image\n- Creating a sitemap\n- Creating a robots.txt file\n- Creating a custom 404 page\n- Creating a custom 500 page\nAuth\n- Creating a sign-up form\n- Stateless, cookie-based session management\n- Stateful, database-backed session management\n- Managing authorization\nTesting\nDeployment\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started", "title": "App Router: Getting Started | Next.js", "text": "Getting Started\nInstallation\nCreate a new Next.js application with the `create-next-app` CLI, and set up TypeScript, ESLint, and Module Path Aliases.\nProject Structure\nAn overview of the folder and file conventions in Next.js, and how to organize your project.\nLayouts and Pages\nCreate your first pages and layouts, and link between them.\nImages and Fonts\nLearn how to optimize images and fonts.\nCSS and Styling\nLearn about the different ways to add CSS to your application, including CSS Modules, Global CSS, Tailwind CSS, and more.\nFetching data and streaming\nStart fetching data and streaming content in your application.\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/css-and-styling", "title": "Getting Started: CSS and Styling | Next.js", "text": "How to use CSS in your application\nNext.js provides several ways to use CSS in your application, including:\nThis page will guide you through how to use each of these approaches.\nCSS Modules\nCSS Modules locally scope CSS by generating unique class names. This allows you to use the same class in different files without worrying about collisions.\nTo start using CSS Modules, create a new file with the extension .module.css\nand import it into any component inside the app\ndirectory:\n.blog {\npadding: 24px;\n}\nimport styles from './styles.module.css'\nexport default function Page({ children }: { children: React.ReactNode }) {\nreturn <main className={styles.blog}>{children}</main>\n}\nGlobal CSS\nYou can use global CSS to apply styles across your application.\nTo use global styles, create a new CSS file, for example app/global.css\n:\nbody {\npadding: 20px 20px 60px;\nmax-width: 680px;\nmargin: 0 auto;\n}\nImport the file in the root layout (app/layout.js\n) to apply the styles to every route in your application:\n// These styles apply to every route in the application\nimport './global.css'\nexport default function RootLayout({\nchildren,\n}: {\nchildren: React.ReactNode\n}) {\nreturn (\n<html lang=\"en\">\n<body>{children}</body>\n</html>\n)\n}\nGood to know: Global styles can be imported into any layout, page, or component inside the\napp\ndirectory. However, since Next.js uses React's built-in support for stylesheets to integrate with Suspense. This built-in support currently does not remove stylesheets as you navigate between routes. Therefore, we recommend using global styles for truly global CSS, and CSS Modules for scoped CSS.\nTailwind CSS\nTailwind CSS is a utility-first CSS framework that integrates seamlessly with Next.js.\nInstalling Tailwind\nTo start using Tailwind, install the Tailwind CSS packages and run the init\ncommand to generate both the tailwind.config.js\nand postcss.config.js\nfiles:\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\nConfiguring Tailwind\nInside your Tailwind configuration file, add paths to the files that will use the Tailwind class names:\nimport type { Config } from 'tailwindcss'\nexport default {\ncontent: [\n'./app/**/*.{js,ts,jsx,tsx,mdx}',\n// Or if using `src` directory:\n'./src/**/*.{js,ts,jsx,tsx,mdx}',\n],\ntheme: {\nextend: {},\n},\nplugins: [],\n} satisfies Config\nUsing Tailwind\nAdd the Tailwind directives to your Global Stylesheet:\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\nThen, import the styles in the root layout:\nimport type { Metadata } from 'next'\n// These styles apply to every route in the application\nimport './globals.css'\nexport const metadata: Metadata = {\ntitle: 'Create Next App',\ndescription: 'Generated by create next app',\n}\nexport default function RootLayout({\nchildren,\n}: {\nchildren: React.ReactNode\n}) {\nreturn (\n<html lang=\"en\">\n<body>{children}</body>\n</html>\n)\n}\nLastly, you can start writing Tailwind's utility classes in your application.\nexport default function Page() {\nreturn <h1 className=\"text-3xl font-bold underline\">Hello, Next.js!</h1>\n}\nSass\nNext.js integrates with Sass using both the .scss\nand .sass\nextensions and syntax.\nYou can also use component-level Sass via CSS Modules and the .module.scss\nor .module.sass\nextension.\nInstalling Sass\nTo start using Sass, install the sass\npackage:\nnpm install --save-dev sass\nCustomizing Sass options\nIf you want to configure your Sass options, use the sassOptions\noption in next.config.js\n.\nimport type { NextConfig } from 'next'\nconst nextConfig: NextConfig = {\nsassOptions: {\nadditionalData: `$var: red;`,\n},\n}\nexport default nextConfig\nCSS-in-JS\nWarning: CSS-in-JS libraries which require runtime JavaScript are not currently supported in React Server Components. Using CSS-in-JS with newer React features like Server Components and Streaming requires library authors to support the latest version of React.\nThe following libraries are supported in Client Components in the app\ndirectory (alphabetical):\nant-design\nchakra-ui\n@fluentui/react-components\nkuma-ui\n@mui/material\n@mui/joy\npandacss\nstyled-jsx\nstyled-components\nstylex\ntamagui\ntss-react\nvanilla-extract\nThe following are currently working on support:\nIf you want to style Server Components, we recommend using CSS Modules or other solutions that output CSS files, like Tailwind CSS.\nConfiguring CSS-in-JS\nTo configure CSS-in-JS, you need to:\n- Create a style registry to collect all CSS rules in a render.\n- Use the\nuseServerInsertedHTML\nhook to inject rules before any content that might use them. - Create a Client Component that wraps your app with the style registry during initial server-side rendering.\nstyled-jsx\nTo configure styled-jsx\nfor your application, create a new registry:\n'use client'\nimport React, { useState } from 'react'\nimport { useServerInsertedHTML } from 'next/navigation'\nimport { StyleRegistry, createStyleRegistry } from 'styled-jsx'\nexport default function StyledJsxRegistry({\nchildren,\n}: {\nchildren: React.ReactNode\n}) {\n// Only create stylesheet once with lazy initial state\n// x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\nconst [jsxStyleRegistry] = useState(() => createStyleRegistry())\nuseServerInsertedHTML(() => {\nconst styles = jsxStyleRegistry.styles()\njsxStyleRegistry.flush()\nreturn <>{styles}</>\n})\nreturn <StyleRegistry registry={jsxStyleRegistry}>{children}</StyleRegistry>\n}\nThen, wrap your root layout with the registry:\nimport StyledJsxRegistry from './registry'\nexport default function RootLayout({\nchildren,\n}: {\nchildren: React.ReactNode\n}) {\nreturn (\n<html>\n<body>\n<StyledJsxRegistry>{children}</StyledJsxRegistry>\n</body>\n</html>\n)\n}\nstyled-components\nTo use styled-components\n, enable it in next.config.js\n:\nimport type { NextConfig } from 'next'\nconst nextConfig: NextConfig = {\ncompiler: {\nstyledComponents: true,\n},\n}\nexport default nextConfig\nThen, use the styled-components\nAPI to create a global registry component to collect all CSS style rules generated during a render, and a function to return those rules. Then use the useServerInsertedHTML\nhook to inject the styles collected in the registry into the <head>\nHTML tag in the root layout.\n'use client'\nimport React, { useState } from 'react'\nimport { useServerInsertedHTML } from 'next/navigation'\nimport { ServerStyleSheet, StyleSheetManager } from 'styled-components'\nexport default function StyledComponentsRegistry({\nchildren,\n}: {\nchildren: React.ReactNode\n}) {\n// Only create stylesheet once with lazy initial state\n// x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\nconst [styledComponentsStyleSheet] = useState(() => new ServerStyleSheet())\nuseServerInsertedHTML(() => {\nconst styles = styledComponentsStyleSheet.getStyleElement()\nstyledComponentsStyleSheet.instance.clearTag()\nreturn <>{styles}</>\n})\nif (typeof window !== 'undefined') return <>{children}</>\nreturn (\n<StyleSheetManager sheet={styledComponentsStyleSheet.instance}>\n{children}\n</StyleSheetManager>\n)\n}\nWrap the children\nof the root layout with the style registry component:\nimport StyledComponentsRegistry from './lib/registry'\nexport default function RootLayout({\nchildren,\n}: {\nchildren: React.ReactNode\n}) {\nreturn (\n<html>\n<body>\n<StyledComponentsRegistry>{children}</StyledComponentsRegistry>\n</body>\n</html>\n)\n}\nExternal stylesheets\nStylesheets published by external packages can be imported anywhere in the app\ndirectory, including colocated components:\nimport 'bootstrap/dist/css/bootstrap.css'\nexport default function RootLayout({\nchildren,\n}: {\nchildren: React.ReactNode\n}) {\nreturn (\n<html lang=\"en\">\n<body className=\"container\">{children}</body>\n</html>\n)\n}\nExternal stylesheets must be directly imported from an npm package or downloaded and colocated with your codebase. You cannot use <link rel=\"stylesheet\" />\n.\nAPI Reference\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/data-fetching-and-streaming", "title": "Getting Started: Fetching data and streaming | Next.js", "text": "How to fetch data and stream\nThis page will walk you through how you can fetch data in Server Components and Client Components. As well as how to to stream content that depends on data.\nFetching data\nServer Components\nYou can fetch data in Server Components using:\n- The\nfetch\nAPI - An ORM or database\nWith the fetch\nAPI\nTo fetch data with the fetch\nAPI, turn your component into an asynchronous function, and await the fetch\ncall. For example:\nexport default async function Page() {\nconst data = await fetch('https://api.vercel.app/blog')\nconst posts = await data.json()\nreturn (\n<ul>\n{posts.map((post) => (\n<li key={post.id}>{post.title}</li>\n))}\n</ul>\n)\n}\nWith an ORM or database\nYou can fetch data with an ORM or database by turning your component into an asynchronous function, and awaiting the call:\nimport { db, posts } from '@/lib/db'\nexport default async function Page() {\nconst allPosts = await db.select().from(posts)\nreturn (\n<ul>\n{allPosts.map((post) => (\n<li key={post.id}>{post.title}</li>\n))}\n</ul>\n)\n}\nClient Components\nThere are two ways to fetch data in Client Components, using:\n- React's\nuse\nhook - A community library like SWR or React Query\nWith the use\nhook\nYou can use React's use\nhook to stream data from the server to client. Start by fetching data in your Server component, and pass the promise to your Client Component as prop:\nimport Posts from '@/app/ui/posts\nimport { Suspense } from 'react'\nexport default function Page() {\n// Don't await the data fetching function\nconst posts = getPosts()\nreturn (\n<Suspense fallback={<div>Loading...</div>}>\n<Posts posts={posts} />\n</Suspense>\n)\n}\nThen, in your Client Component, use the use\nhook read the promise:\n'use client'\nimport { use } from 'react'\nexport default function Posts({\nposts,\n}: {\nposts: Promise<{ id: string; title: string }[]>\n}) {\nconst posts = use(posts)\nreturn (\n<ul>\n{posts.map((post) => (\n<li key={post.id}>{post.title}</li>\n))}\n</ul>\n)\n}\nIn the example above, you need to wrap the <Posts />\ncomponent in a <Suspense>\nboundary. This means the fallback will be shown while the promise is being resolved. Learn more about streaming.\nCommunity libraries\nYou can use a community library like SWR or React Query to fetch data in Client Components. These libraries have their own semantics for caching, streaming, and other features. For example, with SWR:\n'use client'\nimport useSWR from 'swr'\nconst fetcher = (url) => fetch(url).then((r) => r.json())\nexport default function BlogPage() {\nconst { data, error, isLoading } = useSWR(\n'https://api.vercel.app/blog',\nfetcher\n)\nif (isLoading) return <div>Loading...</div>\nif (error) return <div>Error: {error.message}</div>\nreturn (\n<ul>\n{data.map((post: { id: string; title: string }) => (\n<li key={post.id}>{post.title}</li>\n))}\n</ul>\n)\n}\nStreaming\nWarning: The content below assumes the\ndynamicIO\nconfig option is enabled in your application. The flag was introduced in Next.js 15 canary.\nWhen using async/await\nin Server Components, Next.js will opt into dynamic rendering. This means the data will be fetched and rendered on the server for every user request. If there are any slow data requests, the whole route will be blocked from rendering.\nTo improve the initial load time and user experience, you can use streaming to break up the page's HTML into smaller chunks and progressively send those chunks from the server to the client.\nThere are two ways you can implement streaming in your application:\n- With the\nloading.js\nfile - With React's\n<Suspense>\ncomponent\nWith loading.js\nYou can create a loading.js\nfile in the same folder as your page to stream the entire page while the data is being fetched. For example, to stream app/blog/page.js\n, add the file inside the app/blog\nfolder.\nexport default function Loading() {\n// Define the Loading UI here\nreturn <div>Loading...</div>\n}\nOn navigation, the user will immediately see the layout and a loading state while the page is being rendered. The new content will then be automatically swapped in once rendering is complete.\nBehind-the-scenes, loading.js\nwill be nested inside layout.js\n, and will automatically wrap the page.js\nfile and any children below in a <Suspense>\nboundary.\nThis approach works well for route segments (layouts and pages), but for more granular streaming, you can use <Suspense>\n.\nWith <Suspense>\n<Suspense>\nallows you to be more granular about what parts of the page to stream. For example, you can immediately show any page content that falls outside of the <Suspense>\nboundary, and stream in the list of blog posts inside the boundary.\nimport { Suspense } from 'react'\nimport BlogList from '@/components/BlogList'\nimport BlogListSkeleton from '@/components/BlogListSkeleton'\nexport default function BlogPage() {\nreturn (\n<div>\n{/* This content will be sent to the client immediately */}\n<header>\n<h1>Welcome to the Blog</h1>\n<p>Read the latest posts below.</p>\n</header>\n<main>\n{/* Any content wrapped in a <Suspense> boundary will be streamed */}\n<Suspense fallback={<BlogListSkeleton />}>\n<BlogList />\n</Suspense>\n</main>\n</div>\n)\n}\nCreating meaningful loading states\nAn instant loading state is fallback UI that is shown immediately to the user after navigation. For the best user experience, we recommend designing loading states that are meaningful and help users understand the app is responding. For example, you can use skeletons and spinners, or a small but meaningful part of future screens such as a cover photo, title, etc.\nIn development, you can preview and inspect the loading state of your components using the React Devtools.\nAPI Reference\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/images-and-fonts", "title": "Getting Started: Images and Fonts | Next.js", "text": "How to optimize images and fonts\nNext.js comes with automatic image and font optimization for better performance and user experience. This page will guide you through how to start using them.\nHandling static assets\nYou can store static files, like images and fonts, under a folder called public\nin the root directory. Files inside public\ncan then be referenced by your code starting from the base URL (/\n).\nOptimizing images\nThe Next.js <Image>\ncomponent extends the HTML <img>\nelement to provide:\n- Size optimization: Automatically serving correctly sized images for each device, using modern image formats like WebP and AVIF.\n- Visual stability: Preventing layout shift automatically when images are loading.\n- Faster page loads: Only loading images when they enter the viewport using native browser lazy loading, with optional blur-up placeholders.\n- Asset flexibility: Resizing images on-demand, even images stored on remote servers.\nTo start using <Image>\n, import it from next/image\nand render it within your component.\nimport Image from 'next/image'\nexport default function Page() {\nreturn <Image src=\"\" alt=\"\" />\n}\nThe src\nproperty can be a local or remote image.\nLocal images\nTo use a local image, import\nyour .jpg\n, .png\n, or .webp\nimage files from your public\nfolder.\nimport Image from 'next/image'\nimport profilePic from './me.png'\nexport default function Page() {\nreturn (\n<Image\nsrc={profilePic}\nalt=\"Picture of the author\"\n// width={500} automatically provided\n// height={500} automatically provided\n// blurDataURL=\"data:...\" automatically provided\n// placeholder=\"blur\" // Optional blur-up while loading\n/>\n)\n}\nNext.js will automatically determine the intrinsic width\nand height\nof your image based on the imported file. These values are used to determine the image ratio and prevent Cumulative Layout Shift while your image is loading.\nRemote images\nTo use a remote image, you can provide a URL string for the src\nproperty.\nimport Image from 'next/image'\nexport default function Page() {\nreturn (\n<Image\nsrc=\"https://s3.amazonaws.com/my-bucket/profile.png\"\nalt=\"Picture of the author\"\nwidth={500}\nheight={500}\n/>\n)\n}\nSince Next.js does not have access to remote files during the build process, you'll need to provide the width\n, height\nand optional blurDataURL\nprops manually. The width\nand height\nattributes are used to infer the correct aspect ratio of image and avoid layout shift from the image loading in.\nThen, to safely allow images from remote servers, you need to define a list of supported URL patterns in next.config.js\n. Be as specific as possible to prevent malicious usage. For example, the following configuration will only allow images from a specific AWS S3 bucket:\nimport { NextConfig } from 'next'\nconst config: NextConfig = {\nimages: {\nremotePatterns: [\n{\nprotocol: 'https',\nhostname: 's3.amazonaws.com',\nport: '',\npathname: '/my-bucket/**',\nsearch: '',\n},\n],\n},\n}\nexport default config\nOptimizing fonts\nThe next/font\nmodule automatically optimizes your fonts and removes external network requests for improved privacy and performance.\nIt includes built-in automatic self-hosting for any font file. This means you can optimally load web fonts with no layout shift.\nTo start using next/font\n, import it from next/font/local\nor next/font/google\n, call it as a function with the appropriate options, and set the className\nof the element you want to apply the font to. For example:\nimport { Geist } from 'next/font/google'\nconst geist = Geist({\nsubsets: ['latin'],\n})\nexport default function Layout({ children }: { children: React.ReactNode }) {\nreturn (\n<html lang=\"en\" className={geist.className}>\n<body>{children}</body>\n</html>\n)\n}\nGoogle fonts\nYou can automatically self-host any Google Font. Fonts are included in the deployment and served from the same domain as your deployment, meaning no requests are sent to Google by the browser when the user visits your site.\nTo start using a Google Font, import your chosen font from next/font/google\n:\nimport { Geist } from 'next/font/google'\nconst geist = Geist({\nsubsets: ['latin'],\n})\nexport default function RootLayout({\nchildren,\n}: {\nchildren: React.ReactNode\n}) {\nreturn (\n<html lang=\"en\" className={geist.className}>\n<body>{children}</body>\n</html>\n)\n}\nWe recommend using variable fonts for the best performance and flexibility. But if you can't use a variable font, you will need to specify a weight:\nimport { Roboto } from 'next/font/google'\nconst roboto = Roboto({\nweight: '400',\nsubsets: ['latin'],\n})\nexport default function RootLayout({\nchildren,\n}: {\nchildren: React.ReactNode\n}) {\nreturn (\n<html lang=\"en\" className={roboto.className}>\n<body>{children}</body>\n</html>\n)\n}\nLocal fonts\nTo use a local font, import your font from next/font/local\nand specify the src\nof your local font file in the public\nfolder.\nimport localFont from 'next/font/local'\nconst myFont = localFont({\nsrc: './my-font.woff2',\n})\nexport default function RootLayout({\nchildren,\n}: {\nchildren: React.ReactNode\n}) {\nreturn (\n<html lang=\"en\" className={myFont.className}>\n<body>{children}</body>\n</html>\n)\n}\nIf you want to use multiple files for a single font family, src\ncan be an array:\nconst roboto = localFont({\nsrc: [\n{\npath: './Roboto-Regular.woff2',\nweight: '400',\nstyle: 'normal',\n},\n{\npath: './Roboto-Italic.woff2',\nweight: '400',\nstyle: 'italic',\n},\n{\npath: './Roboto-Bold.woff2',\nweight: '700',\nstyle: 'normal',\n},\n{\npath: './Roboto-BoldItalic.woff2',\nweight: '700',\nstyle: 'italic',\n},\n],\n})\nAPI Reference\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/installation", "title": "Getting Started: Installation | Next.js", "text": "How to set up a new Next.js project\nSystem requirements\n- Node.js 18.18 or later.\n- macOS, Windows (including WSL), and Linux are supported.\nAutomatic installation\nWe recommend starting a new Next.js app using create-next-app\n, which sets up everything automatically for you. To create a project, run:\nnpx create-next-app@latest\nOn installation, you'll see the following prompts:\nWhat is your project named? my-app\nWould you like to use TypeScript? No / Yes\nWould you like to use ESLint? No / Yes\nWould you like to use Tailwind CSS? No / Yes\nWould you like your code inside a `src/` directory? No / Yes\nWould you like to use App Router? (recommended) No / Yes\nWould you like to use Turbopack for `next dev`? No / Yes\nWould you like to customize the import alias (`@/*` by default)? No / Yes\nWhat import alias would you like configured? @/*\nAfter the prompts, create-next-app\nwill create a folder with your project name and install the required dependencies.\nManual installation\nTo manually create a new Next.js app, install the required packages:\nnpm install next@latest react@latest react-dom@latest\nOpen your package.json\nfile and add the following scripts\n:\n{\n\"scripts\": {\n\"dev\": \"next dev\",\n\"build\": \"next build\",\n\"start\": \"next start\",\n\"lint\": \"next lint\"\n}\n}\nThese scripts refer to the different stages of developing an application:\ndev\n: runsnext dev\nto start Next.js in development mode.build\n: runsnext build\nto build the application for production usage.start\n: runsnext start\nto start a Next.js production server.lint\n: runsnext lint\nto set up Next.js' built-in ESLint configuration.\nCreate the app\ndirectory\nNext.js uses file-system routing, which means the routes in your application are determined by how you structure your files.\nCreate an app\nfolder, then add a layout.tsx\nand page.tsx\nfile. These will be rendered when the user visits the root of your application (/\n).\nCreate a root layout inside app/layout.tsx\nwith the required <html>\nand <body>\ntags:\nexport default function RootLayout({\nchildren,\n}: {\nchildren: React.ReactNode\n}) {\nreturn (\n<html lang=\"en\">\n<body>{children}</body>\n</html>\n)\n}\nFinally, create a home page app/page.tsx\nwith some initial content:\nexport default function Page() {\nreturn <h1>Hello, Next.js!</h1>\n}\nGood to know:\n- If you forget to create\nlayout.tsx\n, Next.js will automatically create this file when running the development server withnext dev\n.- You can optionally use a\nsrc\ndirectory in the root of your project to separate your application's code from configuration files.\nCreate the public\nfolder (optional)\nYou can optionally create a public\nfolder at the root of your project to store static assets such as images, fonts, etc. Files inside public\ncan then be referenced by your code starting from the base URL (/\n).\nRun the development server\n- Run\nnpm run dev\nto start the development server. - Visit\nhttp://localhost:3000\nto view your application. - Edit the\napp/page.tsx\nfile and save it to see the updated result in your browser.\nSet up TypeScript\nMinimum TypeScript version:\nv4.5.2\nNext.js comes with built-in TypeScript support. To add TypeScript to your project, rename a file to .ts\n/ .tsx\n. Run next dev\n, Next.js will automatically install the necessary dependencies and add a tsconfig.json\nfile with the recommended config options.\nIDE Plugin\nNext.js includes a custom TypeScript plugin and type checker, which VSCode and other code editors can use for advanced type-checking and auto-completion.\nYou can enable the plugin in VS Code by:\n- Opening the command palette (\nCtrl/\u2318\n+Shift\n+P\n) - Searching for \"TypeScript: Select TypeScript Version\"\n- Selecting \"Use Workspace Version\"\nNow, when editing files, the custom plugin will be enabled. When running next build\n, the custom type checker will be used.\nSee the TypeScript configuration page for more information on how to use TypeScript in your project.\nSet up ESLint\nNext.js comes with built-in ESLint, automatically installing the necessary packages and configuring the proper settings when you create a new project with create-next-app\n.\nTo add ESLint to an existing project, add next lint\nas a script to package.json\n:\n{\n\"scripts\": {\n\"lint\": \"next lint\"\n}\n}\nThen, run npm run lint\nand you will be guided through the installation and configuration process.\npnpm lint\nYou'll see a prompt like this:\n? How would you like to configure ESLint?\n\u276f Strict (recommended)\nBase\nCancel\n- Strict: Includes Next.js' base ESLint configuration along with a stricter Core Web Vitals rule-set. This is the recommended configuration for developers setting up ESLint for the first time.\n- Base: Includes Next.js' base ESLint configuration.\n- Cancel: Does not include any ESLint configuration. Only select this option if you plan on setting up your own custom ESLint configuration.\nIf either of the two configuration options are selected, Next.js will automatically install eslint\nand eslint-config-next\nas dependencies in your application and create an .eslintrc.json\nfile in the root of your project that includes your selected configuration.\nYou can now run next lint\nevery time you want to run ESLint to catch errors. Once ESLint has been set up, it will also automatically run during every build (next build\n). Errors will fail the build, while warnings will not.\nSee the ESLint Plugin page for more information on how to configure ESLint in your project.\nSet up Absolute Imports and Module Path Aliases\nNext.js has in-built support for the \"paths\"\nand \"baseUrl\"\noptions of tsconfig.json\nand jsconfig.json\nfiles. These options allow you to alias project directories to absolute paths, making it easier to import modules. For example:\n// Before\nimport { Button } from '../../../components/button'\n// After\nimport { Button } from '@/components/button'\nTo configure absolute imports, add the baseUrl\nconfiguration option to your tsconfig.json\nor jsconfig.json\nfile. For example:\n{\n\"compilerOptions\": {\n\"baseUrl\": \"src/\"\n}\n}\nIn addition to configuring the baseUrl\npath, you can use the \"paths\"\noption to \"alias\"\nmodule paths.\nFor example, the following configuration maps @/components/*\nto components/*\n:\n{\n\"compilerOptions\": {\n\"baseUrl\": \"src/\",\n\"paths\": {\n\"@/styles/*\": [\"styles/*\"],\n\"@/components/*\": [\"components/*\"]\n}\n}\n}\nEach of the \"paths\"\nare relative to the baseUrl\nlocation. For example:\nimport Button from '@/components/button'\nimport '@/styles/styles.css'\nexport default function HomePage() {\nreturn (\n<div>\n<h1>Hello World</h1>\n<Button />\n</div>\n)\n}\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/layouts-and-pages", "title": "Getting Started: Layouts and Pages | Next.js", "text": "How to create layouts and pages\nNext.js uses file-system based routing, meaning you can use folders and files to define routes. This page will guide you through how to create layouts and pages, and link between them.\nCreating a page\nA page is UI that is rendered on a specific route. To create a page, add a page\nfile inside the app\ndirectory and default export a React component. For example, to create an index page (/\n):\nexport default function Page() {\nreturn <h1>Hello Next.js!</h1>\n}\nCreating a layout\nA layout is UI that is shared between multiple pages. On navigation, layouts preserve state, remain interactive, and do not rerender.\nYou can define a layout by default exporting a React component from a layout\nfile. The component should accept a children\nprop which can be a page or another layout.\nFor example, to create a layout that accepts your index page as child, add a layout\nfile inside the app\ndirectory:\nexport default function DashboardLayout({\nchildren,\n}: {\nchildren: React.ReactNode\n}) {\nreturn (\n<html lang=\"en\">\n<body>\n{/* Layout UI */}\n{/* Place children where you want to render a page or nested layout */}\n<main>{children}</main>\n</body>\n</html>\n)\n}\nThe layout above is called a root layout because it's defined at the root of the app\ndirectory. The root layout is required and must contain html\nand body\ntags.\nCreating a nested route\nA nested route is a route composed of multiple URL segments. For example, the /blog/[slug]\nroute is composed of three segments:\n/\n(Root Segment)blog\n(Segment)[slug]\n(Leaf Segment)\nIn Next.js:\n- Folders are used to define the route segments that map to URL segments.\n- Files (like\npage\nandlayout\n) are used to create UI that is shown for a segment.\nTo create nested routes, you can nest folders inside each other. For example, to add a route for /blog\n, create a folder called blog\nin the app\ndirectory. Then, to make /blog\npublicly accessible, add a page\nfile:\nimport { getPosts } from '@/lib/posts'\nimport { Post } from '@/ui/post'\nexport default async function Page() {\nconst posts = await getPosts()\nreturn (\n<ul>\n{posts.map((post) => (\n<Post key={post.id} post={post} />\n))}\n</ul>\n)\n}\nYou can continue nesting folders to create nested routes. For example, to create a route for a specific blog post, create a new [slug]\nfolder inside blog\nand add a page\nfile:\nfunction generateStaticParams() {}\nexport default function Page() {\nreturn <h1>Hello, Blog Post Page!</h1>\n}\nGood to know: Wrapping a folder name in square brackets (e.g.\n[slug]\n) creates a special dynamic route segment used to generate multiple pages from data. This is useful for blog posts, product pages, etc.\nNesting layouts\nBy default, layouts in the folder hierarchy are also nested, which means they wrap child layouts via their children\nprop. You can nest layouts by adding layout\ninside specific route segments (folders).\nFor example, to create a layout for the /blog\nroute, add a new layout\nfile inside the blog\nfolder.\nexport default function BlogLayout({\nchildren,\n}: {\nchildren: React.ReactNode\n}) {\nreturn <section>{children}</section>\n}\nIf you were to combine the two layouts above, the root layout (app/layout.js\n) would wrap the blog layout (app/blog/layout.js\n), which would wrap the blog (app/blog/page.js\n) and blog post page (app/blog/[slug]/page.js\n).\nLinking between pages\nYou can use the <Link>\ncomponent to navigate between routes. <Link>\nis a built-in Next.js component that extends the HTML <a>\ntag to provide prefetching and client-side navigation.\nFor example, to generate a list of blog posts, import <Link>\nfrom next/link\nand pass a href\nprop to the component:\nimport Link from 'next/link'\nexport default async function Post({ post }) {\nconst posts = await getPosts()\nreturn (\n<ul>\n{posts.map((post) => (\n<li key={post.slug}>\n<Link href={`/blog/${post.slug}`}>{post.title}</Link>\n</li>\n))}\n</ul>\n)\n}\n<Link>\nis the primary and recommended way to navigate between routes in your Next.js application. However, you can also use the useRouter\nhook for more advanced navigation.\nAPI Reference\nWas this helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/project-structure", "title": "Getting Started: Project Structure | Next.js", "text": "Project structure and organization\nThis page provides an overview of the folder and file conventions in Next.js, as well as tips for organizing your project.\nFolder and file conventions\nTop-level folders\nTop-level folders are used to organize your application's code and static assets.\nTop-level files\nTop-level files are used to configure your application, manage dependencies, run middleware, integrate monitoring tools, and define environment variables.\n| Next.js | |\nnext.config.js | Configuration file for Next.js |\npackage.json | Project dependencies and scripts |\ninstrumentation.ts | OpenTelemetry and Instrumentation file |\nmiddleware.ts | Next.js request middleware |\n.env | Environment variables |\n.env.local | Local environment variables |\n.env.production | Production environment variables |\n.env.development | Development environment variables |\n.eslintrc.json | Configuration file for ESLint |\n.gitignore | Git files and folders to ignore |\nnext-env.d.ts | TypeScript declaration file for Next.js |\ntsconfig.json | Configuration file for TypeScript |\njsconfig.json | Configuration file for JavaScript |\nRouting Files\nlayout | .js .jsx .tsx | Layout |\npage | .js .jsx .tsx | Page |\nloading | .js .jsx .tsx | Loading UI |\nnot-found | .js .jsx .tsx | Not found UI |\nerror | .js .jsx .tsx | Error UI |\nglobal-error | .js .jsx .tsx | Global error UI |\nroute | .js .ts | API endpoint |\ntemplate | .js .jsx .tsx | Re-rendered layout |\ndefault | .js .jsx .tsx | Parallel route fallback page |\nNested routes\nfolder | Route segment |\nfolder/folder | Nested route segment |\nDynamic routes\n[folder] | Dynamic route segment |\n[...folder] | Catch-all route segment |\n[[...folder]] | Optional catch-all route segment |\nRoute Groups and private folders\n(folder) | Group routes without affecting routing |\n_folder | Opt folder and all child segments out of routing |\nParallel and Intercepted Routes\n@folder | Named slot |\n(.)folder | Intercept same level |\n(..)folder | Intercept one level above |\n(..)(..)folder | Intercept two levels above |\n(...)folder | Intercept from root |\nMetadata file conventions\nApp icons\nfavicon | .ico | Favicon file |\nicon | .ico .jpg .jpeg .png .svg | App Icon file |\nicon | .js .ts .tsx | Generated App Icon |\napple-icon | .jpg .jpeg , .png | Apple App Icon file |\napple-icon | .js .ts .tsx | Generated Apple App Icon |\nOpen Graph and Twitter images\nopengraph-image | .jpg .jpeg .png .gif | Open Graph image file |\nopengraph-image | .js .ts .tsx | Generated Open Graph image |\ntwitter-image | .jpg .jpeg .png .gif | Twitter image file |\ntwitter-image | .js .ts .tsx | Generated Twitter image |\nSEO\nsitemap | .xml | Sitemap file |\nsitemap | .js .ts | Generated Sitemap |\nrobots | .txt | Robots file |\nrobots | .js .ts | Generated Robots file |\nComponent hierarchy\nThe React components defined in special files of a route segment are rendered in a specific hierarchy:\nlayout.js\ntemplate.js\nerror.js\n(React error boundary)loading.js\n(React suspense boundary)not-found.js\n(React error boundary)page.js\nor nestedlayout.js\nIn a nested route, the components of a segment will be nested inside the components of its parent segment.\nOrganizing your project\nApart from folder and file conventions, Next.js is unopinionated about how you organize and colocate your project files. But it does provide several features to help you organize your project.\nColocation\nIn the app\ndirectory, nested folders define route structure. Each folder represents a route segment that is mapped to a corresponding segment in a URL path.\nHowever, even though route structure is defined through folders, a route is not publicly accessible until a page.js\nor route.js\nfile is added to a route segment.\nAnd, even when a route is made publicly accessible, only the content returned by page.js\nor route.js\nis sent to the client.\nThis means that project files can be safely colocated inside route segments in the app\ndirectory without accidentally being routable.\nGood to know:\n- While you can colocate your project files in\napp\nyou don't have to. If you prefer, you can keep them outside theapp\ndirectory.\nPrivate folders\nPrivate folders can be created by prefixing a folder with an underscore: _folderName\nThis indicates the folder is a private implementation detail and should not be considered by the routing system, thereby opting the folder and all its subfolders out of routing.\nSince files in the app\ndirectory can be safely colocated by default, private folders are not required for colocation. However, they can be useful for:\n- Separating UI logic from routing logic.\n- Consistently organizing internal files across a project and the Next.js ecosystem.\n- Sorting and grouping files in code editors.\n- Avoiding potential naming conflicts with future Next.js file conventions.\nGood to know:\n- While not a framework convention, you might also consider marking files outside private folders as \"private\" using the same underscore pattern.\n- You can create URL segments that start with an underscore by prefixing the folder name with\n%5F\n(the URL-encoded form of an underscore):%5FfolderName\n.- If you don't use private folders, it would be helpful to know Next.js special file conventions to prevent unexpected naming conflicts.\nRoute groups\nRoute groups can be created by wrapping a folder in parenthesis: (folderName)\nThis indicates the folder is for organizational purposes and should not be included in the route's URL path.\nRoute groups are useful for:\n- Organizing routes into groups e.g. by site section, intent, or team.\n- Enabling nested layouts in the same route segment level:\nsrc\ndirectory\nNext.js supports storing application code (including app\n) inside an optional src\ndirectory. This separates application code from project configuration files which mostly live in the root of a project.\nCommon strategies\nThe following section lists a very high-level overview of common strategies. The simplest takeaway is to choose a strategy that works for you and your team and be consistent across the project.\nGood to know: In our examples below, we're using\ncomponents\nandlib\nfolders as generalized placeholders, their naming has no special framework significance and your projects might use other folders likeui\n,utils\n,hooks\n,styles\n, etc.\nStore project files outside of app\nThis strategy stores all application code in shared folders in the root of your project and keeps the app\ndirectory purely for routing purposes.\nStore project files in top-level folders inside of app\nThis strategy stores all application code in shared folders in the root of the app\ndirectory.\nSplit project files by feature or route\nThis strategy stores globally shared application code in the root app\ndirectory and splits more specific application code into the route segments that use them.\nWas this helpful?"}]