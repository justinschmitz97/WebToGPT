[{"source": "https://nextjs.org/docs/app/api-reference", "title": "App Router: API Reference | Next.js", "text": "API Reference Next.js API reference divided following sections: Directives Directives used modify behavior Next.js application. Components API Reference Next.js built-in components. File Conventions API Reference Next.js File Conventions. Functions API Reference Next.js Functions Hooks. Configuration Learn configure Next.js applications. CLI API Reference Next.js Command Line Interface (CLI) tools. Edge Runtime API Reference Edge Runtime. Turbopack Turbopack incremental bundler optimized JavaScript TypeScript, written Rust, built Next.js. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/cli", "title": "API Reference: CLI | Next.js", "text": "CLI Next.js comes two Command Line Interface (CLI) tools: create-next-app : Quickly create new Next.js application using default template example public GitHub repository.next : Run Next.js development server, build application, more. create-next-app Create Next.js apps using one command create-next-app CLI. next CLI Learn run build application Next.js CLI. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/cli/create-next-app", "title": "CLI: create-next-app | Next.js", "text": "create-next-app create-next-app CLI allow create new Next.js application using default template example public GitHub repository. easiest way get started Next.js. Basic usage: npx create-next-app@latest [project-name] [options] Reference following options available: | Options | Description | |---|---| -h --help | Show available options | -v --version | Output version number | --no-* | Negate default options. E.g. --no-eslint | --ts --typescript | Initialize TypeScript project (default) | --js --javascript | Initialize JavaScript project | --tailwind | Initialize Tailwind CSS config (default) | --eslint | Initialize ESLint config | --app | Initialize App Router project | --src-dir | Initialize inside src/ directory | --turbopack | Enable Turbopack default development | --import-alias <alias-to-configure> | Specify import alias use (default \"@/*\") | --empty | Initialize empty project | --use-npm | Explicitly tell CLI bootstrap application using npm | --use-pnpm | Explicitly tell CLI bootstrap application using pnpm | --use-yarn | Explicitly tell CLI bootstrap application using Yarn | --use-bun | Explicitly tell CLI bootstrap application using Bun | -e --example [name] [github-url] | example bootstrap app | --example-path <path-to-example> | Specify path example separately | --reset-preferences | Explicitly tell CLI reset stored preferences | --skip-install | Explicitly tell CLI skip installing packages | --yes | Use previous preferences defaults options | Examples default template create new app using default template, run following command terminal: npx create-next-app@latest asked following prompts: project named? my-app Would like use TypeScript? / Yes Would like use ESLint? / Yes Would like use Tailwind CSS? / Yes Would like code inside `src/` directory? / Yes Would like use App Router? (recommended) / Yes Would like use Turbopack `next dev`? / Yes Would like customize import alias (`@/*` default)? / Yes answered prompts, new project created chosen configuration. official Next.js example create new app using official Next.js example, use --example flag. example: npx create-next-app@latest --example [example-name] [your-project-name] view list available examples along setup instructions Next.js repository. public GitHub example create new app using public GitHub example, use --example option GitHub repo's URL. example: npx create-next-app@latest --example \"https://github.com/.../\" [your-project-name] helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/cli/next", "title": "CLI: next CLI | Next.js", "text": "next CLI Next.js CLI allows develop, build, start application, more. Basic usage: npx next [command] [options] Reference following options available: | Options | Description | |---|---| -h --help | Shows available options | -v --version | Outputs Next.js version number | Commands following commands available: | Command | Description | |---|---| dev | Starts Next.js development mode Hot Module Reloading, error reporting, more. | build | Creates optimized production build application. Displaying information route. | start | Starts Next.js production mode. application compiled next build first. | info | Prints relevant details current system used report Next.js bugs. | lint | Runs ESLint files /src , /app , /pages , /components , /lib directories. also provides guided setup install required dependencies ESLint already configured application. | telemetry | Allows enable disable Next.js' completely anonymous telemetry collection. | Good know: Running next without command alias fornext dev . next dev options next dev starts application development mode Hot Module Reloading (HMR), error reporting, more. following options available running next dev : | Option | Description | |---|---| -h, --help | Show available options. | [directory] | directory build application. provided, current directory used. | --turbopack | Starts development mode using Turbopack. | -p --port <port> | Specify port number start application. Default: 3000, env: PORT | -H --hostname <hostname> | Specify hostname start application. Useful making application available devices network. Default: 0.0.0.0 | --experimental-https | Starts server HTTPS generates self-signed certificate. | --experimental-https-key <path> | Path HTTPS key file. | --experimental-https-cert <path> | Path HTTPS certificate file. | --experimental-https-ca <path> | Path HTTPS certificate authority file. | --experimental-upload-trace <traceUrl> | Reports subset debugging trace remote HTTP URL. | next build options next build creates optimized production build application. output displays information route. example: Route (app) Size First Load JS \u250c \u25cb /_not-found 0 B 0 kB \u2514 \u0192 /products/[id] 0 B 0 kB \u25cb (Static) prerendered static content \u0192 (Dynamic) server-rendered demand - Size: size assets downloaded navigating page client-side. size route includes dependencies. - First Load JS: size assets downloaded visiting page server. amount JS shared shown separate metric. values compressed gzip. first load indicated green, yellow, red. Aim green performant applications. following options available next build command: | Option | Description | |---|---| -h, --help | Show available options. | [directory] | directory build application. provided, current directory used. | -d --debug | Enables verbose build output. flag enabled additional build output like rewrites, redirects, headers shown. | --profile | Enables production profiling React. | --no-lint | Disables linting. | --no-mangling | Disables mangling. may affect performance used debugging purposes. | --experimental-app-only | Builds App Router routes. | --experimental-build-mode [mode] | Uses experimental build mode. (choices: \"compile\", \"generate\", default: \"default\") | next start options next start starts application production mode. application compiled next build first. following options available next start command: | Option | Description | |---|---| -h --help | Show available options. | [directory] | directory start application. directory provided, current directory used. | -p --port <port> | Specify port number start application. (default: 3000, env: PORT) | -H --hostname <hostname> | Specify hostname start application (default: 0.0.0.0). | --keepAliveTimeout <keepAliveTimeout> | Specify maximum amount milliseconds wait closing inactive connections. | next info options next info prints relevant details current system used report Next.js bugs opening GitHub issue. information includes Operating System platform/arch/version, Binaries (Node.js, npm, Yarn, pnpm), package versions (next , react , react-dom ), more. output look like this: Operating System: Platform: darwin Arch: arm64 Version: Darwin Kernel Version 23.6.0 Available memory (MB): 65536 Available CPU cores: 10 Binaries: Node: 20.12.0 npm: 10.5.0 Yarn: 1.22.19 pnpm: 9.6.0 Relevant Packages: next: 15.0.0-canary.115 // Latest available version detected (15.0.0-canary.115). eslint-config-next: 14.2.5 react: 19.0.0-rc react-dom: 19.0.0 typescript: 5.5.4 Next.js Config: output: N/A following options available next info command: | Option | Description | |---|---| -h --help | Show available options | --verbose | Collects additional information debugging. | next lint options next lint runs ESLint files pages/ , app/ , components/ , lib/ , src/ directories. also provides guided setup install required dependencies ESLint already configured application. following options available next lint command: | Option | Description | |---|---| [directory] | base directory lint application. provided, current directory used. | -d, --dir, <dirs...> | Include directory, directories, run ESLint. | --file, <files...> | Include file, files, run ESLint. | --ext, [exts...] | Specify JavaScript file extensions. (default: [\".js\", \".mjs\", \".cjs\", \".jsx\", \".ts\", \".mts\", \".cts\", \".tsx\"]) | -c, --config, <config> | Uses configuration file, overriding configuration options. | --resolve-plugins-relative-to, <rprt> | Specify directory plugins resolved from. | --strict | Creates .eslintrc.json file using Next.js strict configuration. | --rulesdir, <rulesdir...> | Uses additional rules directory(s). | --fix | Automatically fix linting issues. | --fix-type <fixType> | Specify types fixes apply (e.g., problem, suggestion, layout). | --ignore-path <path> | Specify file ignore. | --no-ignore <path> | Disables --ignore-path option. | --quiet | Reports errors only. | --max-warnings [maxWarnings] | Specify number warnings triggering non-zero exit code. (default: -1) | -o, --output-file, <outputFile> | Specify file write report to. | -f, --format, <format> | Uses specific output format. | --no-inline-config | Prevents comments changing config rules. | --report-unused-disable-directives-severity <level> | Specify severity level unused eslint-disable directives. (choices: \"error\", \"off\", \"warn\") | --no-cache | Disables caching. | --cache-location, <cacheLocation> | Specify location cache. | --cache-strategy, [cacheStrategy] | Specify strategy use detecting changed files cache. (default: \"metadata\") | --error-on-unmatched-pattern | Reports errors file patterns unmatched. | -h, --help | Displays message. | next telemetry options Next.js collects completely anonymous telemetry data general usage. Participation anonymous program optional, opt-out prefer share information. following options available next telemetry command: | Option | Description | |---|---| -h, --help | Show available options. | --enable | Enables Next.js' telemetry collection. | --disable | Disables Next.js' telemetry collection. | Learn Telemetry. Examples Changing default port default, Next.js uses http://localhost:3000 development next start . default port changed -p option, like so: next dev -p 4000 using PORT environment variable: PORT=4000 next dev Good know: PORT cannot set in.env booting HTTP server happens code initialized. Using HTTPS development certain use cases like webhooks authentication, use HTTPS secure environment localhost . Next.js generate self-signed certificate next dev using --experimental-https flag: next dev --experimental-https generated certificate, Next.js development server exist https://localhost:3000 . default port 3000 used unless port specified -p , --port , PORT . also provide custom certificate key --experimental-https-key --experimental-https-cert . Optionally, provide custom CA certificate --experimental-https-ca well. next dev --experimental-https --experimental-https-key ./certificates/localhost-key.pem --experimental-https-cert ./certificates/localhost.pem next dev --experimental-https intended development creates locally trusted certificate mkcert . production, use properly issued certificates trusted authorities. Good know: deploying Vercel, HTTPS automatically configured Next.js application. Configuring timeout downstream proxies deploying Next.js behind downstream proxy (e.g. load-balancer like AWS ELB/ALB), important configure Next's underlying HTTP server keep-alive timeouts larger downstream proxy's timeouts. Otherwise, keep-alive timeout reached given TCP connection, Node.js immediately terminate connection without notifying downstream proxy. results proxy error whenever attempts reuse connection Node.js already terminated. configure timeout values production Next.js server, pass --keepAliveTimeout (in milliseconds) next start , like so: next start --keepAliveTimeout 70000 Passing Node.js arguments pass node arguments next commands. example: NODE_OPTIONS='--throw-deprecation' next NODE_OPTIONS='-r esm' next NODE_OPTIONS='--inspect' next helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/components", "title": "API Reference: Components | Next.js", "text": "Components Font Optimizing loading web fonts built-in `next/font` loaders. Form Learn use `<Form>` component handle form submissions search params updates client-side navigation. Image Optimize Images Next.js Application using built-in `next/image` Component. Link Enable fast client-side navigation built-in `next/link` component. Script Optimize third-party scripts Next.js application using built-in `next/script` Component. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/components/font", "title": "Components: Font | Next.js", "text": "Font Module API reference help understand use next/font/google next/font/local . features usage, please see Optimizing Fonts page. Font Function Arguments usage, review Google Fonts Local Fonts. | Key | font/google | font/local | Type | Required | |---|---|---|---|---| src | String Array Objects | Yes | || weight | String Array | Required/Optional | || style | String Array | - | || subsets | Array Strings | - | || axes | Array Strings | - | || display | String | - | || preload | Boolean | - | || fallback | Array Strings | - | || adjustFontFallback | Boolean String | - | || variable | String | - | || declarations | Array Objects | - | src path font file string array objects (with type Array<{path: string, weight?: string, style?: string}> ) relative directory font loader function called. Used next/font/local - Required Examples: src:'./fonts/my-font.woff2' wheremy-font.woff2 placed directory namedfonts inside theapp directorysrc:[{path: './inter/Inter-Thin.ttf', weight: '100',},{path: './inter/Inter-Regular.ttf',weight: '400',},{path: './inter/Inter-Bold-Italic.ttf', weight: '700',style: 'italic',},] - font loader function called app/page.tsx usingsrc:'../styles/fonts/my-font.ttf' , thenmy-font.ttf placed instyles/fonts root project weight font weight following possibilities: - string possible values weights available specific font range values variable font - array weight values font variable google font. applies next/font/google only. Used next/font/google next/font/local - Required font used variable Examples: weight: '400' : string single weight value - fontInter , possible values are'100' ,'200' ,'300' ,'400' ,'500' ,'600' ,'700' ,'800' ,'900' or'variable' where'variable' default)weight: '100 900' : string range between100 and900 variable fontweight: ['100','400','900'] : array 3 possible values non variable font style font style following possibilities: - string value default value 'normal' - array style values font variable google font. applies next/font/google only. Used next/font/google next/font/local - Optional Examples: style: 'italic' : string - benormal oritalic fornext/font/google style: 'oblique' : string - take value fornext/font/local expected come standard font stylesstyle: ['italic','normal'] : array 2 values fornext/font/google - values fromnormal anditalic subsets font subsets defined array string values names subset would like preloaded. Fonts specified via subsets link preload tag injected head preload option true, default. Used next/font/google - Optional Examples: subsets: ['latin'] : array subsetlatin find list subsets Google Fonts page font. axes variable fonts extra axes included. default, font weight included keep file size down. possible values axes depend specific font. Used next/font/google - Optional Examples: axes: ['slnt'] : array valueslnt theInter variable font hasslnt additionalaxes shown here. find possibleaxes values font using filter Google variable fonts page looking axes thanwght display font display possible string values 'auto' , 'block' , 'swap' , 'fallback' 'optional' default value 'swap' . Used next/font/google next/font/local - Optional Examples: display: 'optional' : string assigned theoptional value preload boolean value specifies whether font preloaded not. default true . Used next/font/google next/font/local - Optional Examples: preload: false fallback fallback font use font cannot loaded. array strings fallback fonts default. - Optional Used next/font/google next/font/local Examples: fallback: ['system-ui', 'arial'] : array setting fallback fonts tosystem-ui orarial adjustFontFallback - next/font/google : boolean value sets whether automatic fallback font used reduce Cumulative Layout Shift. default istrue . - next/font/local : string booleanfalse value sets whether automatic fallback font used reduce Cumulative Layout Shift. possible values are'Arial' ,'Times New Roman' orfalse . default is'Arial' . Used next/font/google next/font/local - Optional Examples: adjustFontFallback: false : fornext/font/google adjustFontFallback: 'Times New Roman' : fornext/font/local variable string value define CSS variable name used style applied CSS variable method. Used next/font/google next/font/local - Optional Examples: variable: '--my-font' : CSS variable--my-font declared declarations array font face descriptor key-value pairs define generated @font-face further. Used next/font/local - Optional Examples: declarations: [{ prop: 'ascent-override', value: '90%' }] Applying Styles apply font styles three ways: className Returns read-only CSS className loaded font passed HTML element. <p className={inter.className}>Hello, Next.js!</p> style Returns read-only CSS style object loaded font passed HTML element, including style.fontFamily access font family name fallback fonts. <p style={inter.style}>Hello World</p> CSS Variables would like set styles external style sheet specify additional options there, use CSS variable method. addition importing font, also import CSS file CSS variable defined set variable option font loader object follows: import { Inter } 'next/font/google' import styles '../styles/component.module.css' const inter = Inter({ variable: '--font-inter', }) use font, set className parent container text would like style font loader's variable value className text styles property external CSS file. <main className={inter.variable}> <p className={styles.text}>Hello World</p> </main> Define text selector class component.module.css CSS file follows: .text { font-family: var(--font-inter); font-weight: 200; font-style: italic; } example above, text Hello World styled using Inter font generated font fallback font-weight: 200 font-style: italic . Using font definitions file Every time call localFont Google font function, font hosted one instance application. Therefore, need use font multiple places, load one place import related font object need it. done using font definitions file. example, create fonts.ts file styles folder root app directory. Then, specify font definitions follows: import { Inter, Lora, Source_Sans_3 } 'next/font/google' import localFont 'next/font/local' // define variable fonts const inter = Inter() const lora = Lora() // define 2 weights non-variable font const sourceCodePro400 = Source_Sans_3({ weight: '400' }) const sourceCodePro700 = Source_Sans_3({ weight: '700' }) // define custom local font GreatVibes-Regular.ttf stored styles folder const greatVibes = localFont({ src: './GreatVibes-Regular.ttf' }) export { inter, lora, sourceCodePro400, sourceCodePro700, greatVibes } use definitions code follows: import { inter, lora, sourceCodePro700, greatVibes } '../styles/fonts' export default function Page() { return ( <div> <p className={inter.className}>Hello world using Inter font</p> <p style={lora.style}>Hello world using Lora font</p> <p className={sourceCodePro700.className}> Hello world using Source_Sans_3 font weight 700 </p> <p className={greatVibes.className}>My title Great Vibes font</p> </div> ) } make easier access font definitions code, define path alias tsconfig.json jsconfig.json files follows: { \"compilerOptions\": { \"paths\": { \"@/fonts\": [\"./styles/fonts\"] } } } import font definition follows: import { greatVibes, sourceCodePro400 } '@/fonts' Version Changes | Version | Changes | |---|---| v13.2.0 | @next/font renamed next/font . Installation longer required. | v13.0.0 | @next/font added. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/components/form", "title": "Components: Form | Next.js", "text": "Form <Form> component extends HTML <form> element provide prefetching loading UI, client-side navigation submission, progressive enhancement. useful forms update URL search params reduces boilerplate code needed achieve above. Basic usage: import Form 'next/form' export default function Page() { return ( <Form action=\"/search\"> {/* submission, input value appended URL, e.g. /search?query=abc */} <input name=\"query\" /> <button type=\"submit\">Submit</button> </Form> ) } Reference behavior <Form> component depends whether action prop passed string function . - action string, the<Form> behaves like native HTML form uses aGET method. form data encoded URL search params, form submitted, navigates specified URL. addition, Next.js:- Prefetches path form becomes visible, preloads shared UI (e.g. layout.js andloading.js ), resulting faster navigation. - Performs client-side navigation instead full page reload form submitted. retains shared UI client-side state. - Prefetches path form becomes visible, preloads shared UI (e.g. - action function (Server Action),<Form> behaves like React form, executing action form submitted. action (string) Props action string, <Form> component supports following props: | Prop | Example | Type | Required | |---|---|---|---| action | action=\"/search\" | string (URL relative path) | Yes | replace | replace={false} | boolean | - | scroll | scroll={true} | boolean | - | prefetch | prefetch={true} | boolean | - | action : URL path navigate form submitted.- empty string \"\" navigate route updated search params. - empty string replace : Replaces current history state instead pushing new one browser's history stack. Default isfalse .scroll : Controls scroll behavior navigation. Defaults totrue , means scroll top new route, maintain scroll position backwards forwards navigation.prefetch : Controls whether path prefetched form becomes visible user's viewport. Defaults totrue . action (function) Props action function, <Form> component supports following prop: | Prop | Example | Type | Required | |---|---|---|---| action | action={myAction} | function (Server Action) | Yes | action : Server Action called form submitted. See React docs more. Good know: action function, thereplace andscroll props ignored. Caveats formAction : used a<button> or<input type=\"submit\"> fields override theaction prop. Next.js perform client-side navigation, however, approach support prefetching.- using basePath , must also include theformAction path. e.g.formAction=\"/base-path/search\" . - using key : Passing akey prop stringaction supported. like trigger re-render perform mutation, consider using functionaction instead. onSubmit : used handle form submission logic. However, callingevent.preventDefault() override<Form> behavior navigating specified URL.method ,encType ,target : supported override<Form> behavior.- Similarly, formMethod ,formEncType , andformTarget used override themethod ,encType , andtarget props respectively, using fallback native browser behavior. - need use props, use HTML <form> element instead. - Similarly, <input type=\"file\"> : Using input type theaction string match browser behavior submitting filename instead file object. Examples Search form leads search result page create search form navigates search results page passing path action : import Form 'next/form' export default function Page() { return ( <Form action=\"/search\"> <input name=\"query\" /> <button type=\"submit\">Submit</button> </Form> ) } user updates query input field submits form, form data encoded URL search params, e.g. /search?query=abc . Good know: pass empty string \"\" toaction , form navigate route updated search params. results page, access query using searchParams page.js prop use fetch data external source. import { getSearchResults } '@/lib/search' export default async function SearchPage({ searchParams, }: { searchParams: Promise<{ [key: string]: string | string[] | undefined }> }) { const results = await getSearchResults((await searchParams).query) return <div>...</div> } <Form> becomes visible user's viewport, shared UI (such layout.js loading.js ) /search page prefetched. submission, form immediately navigate new route show loading UI results fetched. design fallback UI using loading.js : export default function Loading() { return <div>Loading...</div> } cover cases shared UI yet loaded, show instant feedback user using useFormStatus . First, create component displays loading state form pending: 'use client' import { useFormStatus } 'react-dom' export default function SearchButton() { const status = useFormStatus() return ( <button type=\"submit\">{status.pending ? 'Searching...' : 'Search'}</button> ) } Then, update search form page use SearchButton component: import Form 'next/form' import { SearchButton } '@/ui/search-button' export default function Page() { return ( <Form action=\"/search\"> <input name=\"query\" /> <SearchButton /> </Form> ) } Mutations Server Actions perform mutations passing function action prop. import Form 'next/form' import { createPost } '@/posts/actions' export default function Page() { return ( <Form action={createPost}> <input name=\"title\" /> {/* ... */} <button type=\"submit\">Create Post</button> </Form> ) } mutation, common redirect new resource. use redirect function next/navigation navigate new post page. Good know: Since \"destination\" form submission known action executed, <Form> cannot automatically prefetch shared UI. 'use server' import { redirect } 'next/navigation' export async function createPost(formData: FormData) { // Create new post // ... // Redirect new post redirect(`/posts/${data.id}`) } Then, new page, fetch data using params prop: import { getPost } '@/posts/data' export default async function PostPage({ params, }: { params: Promise<{ id: string }> }) { const data = await getPost((await params).id) return ( <div> <h1>{data.title}</h1> {/* ... */} </div> ) } See Server Actions docs examples. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/components/image", "title": "Components: Image | Next.js", "text": "Image Examples API reference help understand use props configuration options available Image Component. features usage, please see Image Component page. import Image 'next/image' export default function Page() { return ( <Image src=\"/profile.png\" width={500} height={500} alt=\"Picture author\" /> ) } Props Here's summary props available Image Component: | Prop | Example | Type | Status | |---|---|---|---| src | src=\"/profile.png\" | String | Required | width | width={500} | Integer (px) | Required | height | height={500} | Integer (px) | Required | alt | alt=\"Picture author\" | String | Required | loader | loader={imageLoader} | Function | - | fill | fill={true} | Boolean | - | sizes | sizes=\"(max-width: 768px) 100vw, 33vw\" | String | - | quality | quality={80} | Integer (1-100) | - | priority | priority={true} | Boolean | - | placeholder | placeholder=\"blur\" | String | - | style | style={{objectFit: \"contain\"}} | Object | - | onLoadingComplete | onLoadingComplete={img => done())} | Function | Deprecated | onLoad | onLoad={event => done())} | Function | - | onError | onError(event => fail()} | Function | - | loading | loading=\"lazy\" | String | - | blurDataURL | blurDataURL=\"data:image/jpeg...\" | String | - | overrideSrc | overrideSrc=\"/seo.png\" | String | - | Required Props Image Component requires following properties: src , alt , width height (or fill ). import Image 'next/image' export default function Page() { return ( <div> <Image src=\"/profile.png\" width={500} height={500} alt=\"Picture author\" /> </div> ) } src Must one following: - statically imported image file - path string. either absolute external URL, internal path depending loader prop. using default loader, also consider following source images: - src external URL, must also configure remotePatterns - src animated known format (JPEG, PNG, WebP, AVIF, GIF, TIFF) image served as-is - src SVG format, blocked unless unoptimized ordangerouslyAllowSVG enabled width width property represents intrinsic image width pixels. property used infer correct aspect ratio image avoid layout shift loading. determine rendered size image, controlled CSS, similar width attribute HTML <img> tag. Required, except statically imported images images fill property. height height property represents intrinsic image height pixels. property used infer correct aspect ratio image avoid layout shift loading. determine rendered size image, controlled CSS, similar height attribute HTML <img> tag. Required, except statically imported images images fill property. Good know: - Combined, width andheight properties used determine aspect ratio image used browsers reserve space image loads.- intrinsic size always mean rendered size browser, determined parent container. example, parent container smaller intrinsic size, image scaled fit container. - use fill property width height unknown. alt alt property used describe image screen readers search engines. also fallback text images disabled error occurs loading image. contain text could replace image without changing meaning page. meant supplement image repeat information already provided captions image. image purely decorative intended user, alt property empty string (alt=\"\" ). Optional Props <Image /> component accepts number additional properties beyond required. section describes commonly-used properties Image component. Find details rarely-used properties Advanced Props section. loader custom function used resolve image URLs. loader function returning URL string image, given following parameters: example using custom loader: 'use client' import Image 'next/image' const imageLoader = ({ src, width, quality }) => { return `https://example.com/${src}?w=${width}&q=${quality || 75}` } export default function Page() { return ( <Image loader={imageLoader} src=\"me.png\" alt=\"Picture author\" width={500} height={500} /> ) } Good know: Using props like loader , accept function, requires using Client Components serialize provided function. Alternatively, use loaderFile configuration next.config.js configure every instance next/image application, without passing prop. fill fill={true} // {true} | {false} boolean causes image fill parent element, useful width height unknown. parent element must assign position: \"relative\" , position: \"fixed\" , position: \"absolute\" style. default, img element automatically assigned position: \"absolute\" style. styles applied image, image stretch fit container. may prefer set object-fit: \"contain\" image letterboxed fit container preserve aspect ratio. Alternatively, object-fit: \"cover\" cause image fill entire container cropped preserve aspect ratio. information, see also: sizes string, similar media query, provides information wide image different breakpoints. value sizes greatly affect performance images using fill styled responsive size. sizes property serves two important purposes related image performance: - First, value sizes used browser determine size image download, fromnext/image 's automatically generatedsrcset . browser chooses, yet know size image page, selects image size larger viewport. Thesizes property allows tell browser image actually smaller full screen. specify asizes value image thefill property, default value of100vw (full screen width) used. - Second, sizes property changes behavior automatically generatedsrcset value. nosizes value present, smallsrcset generated, suitable fixed-size image (1x/2x/etc). Ifsizes defined, largesrcset generated, suitable responsive image (640w/750w/etc). thesizes property includes sizes as50vw , represent percentage viewport width, thesrcset trimmed include values small ever necessary. example, know styling cause image full-width mobile devices, 2-column layout tablets, 3-column layout desktop displays, include sizes property following: import Image 'next/image' export default function Page() { return ( <div className=\"grid-element\"> <Image fill src=\"/example.png\" sizes=\"(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw\" /> </div> ) } example sizes could dramatic effect performance metrics. Without 33vw sizes, image selected server would 3 times wide needs be. file size proportional square width, without sizes user would download image that's 9 times larger necessary. Learn srcset sizes : quality quality={75} // {number 1-100} quality optimized image, integer 1 100 , 100 best quality therefore largest file size. Defaults 75 . qualities configuration defined next.config.js , quality prop must match one values defined configuration. Good know: original source image already low quality, setting quality prop high could cause resulting optimized image larger original source image. priority priority={false} // {false} | {true} true, Next.js preload image. Lazy loading automatically disabled images using priority . loading property also used set lazy , priority property can't used. loading property meant advanced use cases. Remove loading priority needed. use priority property image detected Largest Contentful Paint (LCP) element. may appropriate multiple priority images, different images may LCP element different viewport sizes. used image visible fold. Defaults false . placeholder placeholder = 'empty' // \"empty\" | \"blur\" | \"data:image/...\" placeholder use image loading. Possible values blur , empty , data:image/... . Defaults empty . blur , blurDataURL property used placeholder. src object static import imported image .jpg , .png , .webp , .avif , blurDataURL automatically populated, except image detected animated. dynamic images, must provide blurDataURL property. Solutions Plaiceholder help base64 generation. data:image/... , Data URL used placeholder image loading. empty , placeholder image loading, empty space. Try out: - Demo blur placeholder - Demo shimmer effect data URL placeholder prop - Demo color effect blurDataURL prop Advanced Props cases, may need advanced usage. <Image /> component optionally accepts following advanced properties. style Allows passing CSS styles underlying image element. const imageStyle = { borderRadius: '50%', border: '1px solid #fff', } export default function ProfileImage() { return <Image src=\"...\" style={imageStyle} /> } Remember required width height props interact styling. use styling modify image's width, also style height auto preserve intrinsic aspect ratio, image distorted. onLoadingComplete 'use client' <Image onLoadingComplete={(img) => console.log(img.naturalWidth)} /> Warning: Deprecated since Next.js 14 favor onLoad . callback function invoked image completely loaded placeholder removed. callback function called one argument, reference underlying <img> element. Good know: Using props like onLoadingComplete , accept function, requires using Client Components serialize provided function. onLoad <Image onLoad={(e) => console.log(e.target.naturalWidth)} /> callback function invoked image completely loaded placeholder removed. callback function called one argument, Event target references underlying <img> element. Good know: Using props like onLoad , accept function, requires using Client Components serialize provided function. onError <Image onError={(e) => console.error(e.target.id)} /> callback function invoked image fails load. Good know: Using props like onError , accept function, requires using Client Components serialize provided function. loading loading = 'lazy' // {lazy} | {eager} loading behavior image. Defaults lazy . lazy , defer loading image reaches calculated distance viewport. eager , load image immediately. Learn loading attribute. blurDataURL Data URL used placeholder image src image successfully loads. takes effect combined placeholder=\"blur\" . Must base64-encoded image. enlarged blurred, small image (10px less) recommended. Including larger images placeholders may harm application performance. Try out: also generate solid color Data URL match image. unoptimized unoptimized = {false} // {false} | {true} true, source image served as-is src instead changing quality, size, format. Defaults false . useful images benefit optimization small images (less 1KB), vector images (SVG), animated images (GIF). import Image 'next/image' const UnoptimizedImage = (props) => { return <Image {...props} unoptimized /> } Since Next.js 12.3.0, prop assigned images updating next.config.js following configuration: module.exports = { images: { unoptimized: true, }, } overrideSrc providing src prop <Image> component, srcset src attributes generated automatically resulting <img> . <Image src=\"/me.jpg\" /> <img srcset=\" /_next/image?url=%2Fme.jpg&w=640&q=75 1x, /_next/image?url=%2Fme.jpg&w=828&q=75 2x \" src=\"/_next/image?url=%2Fme.jpg&w=828&q=75\" /> cases, desirable src attribute generated may wish override using overrideSrc prop. example, upgrading existing website <img> <Image> , may wish maintain src attribute SEO purposes image ranking avoiding recrawl. <Image src=\"/me.jpg\" overrideSrc=\"/override.jpg\" /> <img srcset=\" /_next/image?url=%2Fme.jpg&w=640&q=75 1x, /_next/image?url=%2Fme.jpg&w=828&q=75 2x \" src=\"/override.jpg\" /> decoding hint browser indicating wait image decoded presenting content updates not. Defaults async . Possible values following: async - Asynchronously decode image allow content rendered completes.sync - Synchronously decode image atomic presentation content.auto - preference decoding mode; browser decides what's best. Learn decoding attribute. Props properties <Image /> component passed underlying img element exception following: srcSet . Use Device Sizes instead. Configuration Options addition props, configure Image Component next.config.js . following options available: localPatterns optionally configure localPatterns next.config.js file order allow specific paths optimized block others paths. module.exports = { images: { localPatterns: [ { pathname: '/assets/images/**', search: '', }, ], }, } Good know: example ensure src property ofnext/image must start with/assets/images/ must query string. Attempting optimize path respond 400 Bad Request. remotePatterns protect application malicious users, configuration required order use external images. ensures external images account served Next.js Image Optimization API. external images configured remotePatterns property next.config.js file, shown below: module.exports = { images: { remotePatterns: [ { protocol: 'https', hostname: 'example.com', port: '', pathname: '/account123/**', search: '', }, ], }, } Good know: example ensure src property ofnext/image must start withhttps://example.com/account123/ must query string. protocol, hostname, port, unmatched path respond 400 Bad Request. example remotePatterns property next.config.js file using wildcard pattern hostname : module.exports = { images: { remotePatterns: [ { protocol: 'https', hostname: '**.example.com', port: '', search: '', }, ], }, } Good know: example ensure src property ofnext/image must start withhttps://img1.example.com orhttps://me.avatar.example.com number subdomains. cannot port query string. protocol unmatched hostname respond 400 Bad Request. Wildcard patterns used pathname hostname following syntax: * match single path segment subdomain** match number path segments end subdomains beginning ** syntax work middle pattern. Good know: omitting protocol ,port ,pathname , orsearch wildcard** implied. recommended may allow malicious actors optimize urls intend. example remotePatterns property next.config.js file using search : module.exports = { images: { remotePatterns: [ { protocol: 'https', hostname: 'assets.example.com', search: '?v=1727111025337', }, ], }, } Good know: example ensure src property ofnext/image must start withhttps://assets.example.com must exact query string?v=1727111025337 . protocol query string respond 400 Bad Request. domains Warning: Deprecated since Next.js 14 favor strict remotePatterns order protect application malicious users. usedomains content served domain. Similar remotePatterns , domains configuration used provide list allowed hostnames external images. However, domains configuration support wildcard pattern matching cannot restrict protocol, port, pathname. example domains property next.config.js file: module.exports = { images: { domains: ['assets.acme.com'], }, } loaderFile want use cloud provider optimize images instead using Next.js built-in Image Optimization API, configure loaderFile next.config.js like following: module.exports = { images: { loader: 'custom', loaderFile: './my/image/loader.js', }, } must point file relative root Next.js application. file must export default function returns string, example: 'use client' export default function myImageLoader({ src, width, quality }) { return `https://example.com/${src}?w=${width}&q=${quality || 75}` } Alternatively, use loader prop configure instance next/image . Examples: Good know: Customizing image loader file, accepts function, requires using Client Components serialize provided function. Advanced following configuration advanced use cases usually necessary. choose configure properties below, override changes Next.js defaults future updates. deviceSizes know expected device widths users, specify list device width breakpoints using deviceSizes property next.config.js . widths used next/image component uses sizes prop ensure correct image served user's device. configuration provided, default used. module.exports = { images: { deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840], }, } imageSizes specify list image widths using images.imageSizes property next.config.js file. widths concatenated array device sizes form full array sizes used generate image srcsets. reason two separate lists imageSizes used images provide sizes prop, indicates image less full width screen. Therefore, sizes imageSizes smaller smallest size deviceSizes. configuration provided, default used. module.exports = { images: { imageSizes: [16, 32, 48, 64, 96, 128, 256, 384], }, } qualities default Image Optimization API automatically allow qualities 1 100. wish restrict allowed qualities, add configuration next.config.js . module.exports = { images: { qualities: [25, 50, 75], }, } example above, three qualities allowed: 25, 50, 75. quality prop match value array, image fail 400 Bad Request. formats default Image Optimization API automatically detect browser's supported image formats via request's Accept header order determine best output format. Accept header matches one configured formats, first match array used. Therefore, array order matters. match (or source image animated), Image Optimization API fallback original image's format. configuration provided, default used. module.exports = { images: { formats: ['image/webp'], }, } enable AVIF support, fallback original format src image browser support AVIF: module.exports = { images: { formats: ['image/avif'], }, } Good know: - still recommend using WebP use cases. - AVIF generally takes 50% longer encode compresses 20% smaller compared WebP. means first time image requested, typically slower subsequent requests cached faster. - self-host Proxy/CDN front Next.js, must configure Proxy forward Accept header. Caching Behavior following describes caching algorithm default loader. loaders, please refer cloud provider's documentation. Images optimized dynamically upon request stored <distDir>/cache/images directory. optimized image file served subsequent requests expiration reached. request made matches cached expired file, expired image served stale immediately. image optimized background (also called revalidation) saved cache new expiration date. cache status image determined reading value x-nextjs-cache response header. possible values following: MISS - path cache (occurs once, first visit)STALE - path cache exceeded revalidate time updated backgroundHIT - path cache exceeded revalidate time expiration (or rather Max Age) defined either minimumCacheTTL configuration upstream image Cache-Control header, whichever larger. Specifically, max-age value Cache-Control header used. s-maxage max-age found, s-maxage preferred. max-age also passed-through downstream clients including CDNs browsers. - configure minimumCacheTTL increase cache duration upstream image includeCache-Control header value low. - configure deviceSizes andimageSizes reduce total number possible generated images. - configure formats disable multiple formats favor single image format. minimumCacheTTL configure Time Live (TTL) seconds cached optimized images. many cases, better use Static Image Import automatically hash file contents cache image forever Cache-Control header immutable . module.exports = { images: { minimumCacheTTL: 60, }, } expiration (or rather Max Age) optimized image defined either minimumCacheTTL upstream image Cache-Control header, whichever larger. need change caching behavior per image, configure headers set Cache-Control header upstream image (e.g. /some-asset.jpg , /_next/image itself). mechanism invalidate cache time, best keep minimumCacheTTL low. Otherwise may need manually change src prop delete <distDir>/cache/images . disableStaticImages default behavior allows import static files import icon './icon.png' pass src property. cases, may wish disable feature conflicts plugins expect import behave differently. disable static image imports inside next.config.js : module.exports = { images: { disableStaticImages: true, }, } dangerouslyAllowSVG default loader optimize SVG images reasons. First, SVG vector format meaning resized losslessly. Second, SVG many features HTML/CSS, lead vulnerabilities without proper Content Security Policy (CSP) headers. Therefore, recommended using unoptimized prop src prop known SVG. happens automatically src ends \".svg\" . However, need serve SVG images default Image Optimization API, set dangerouslyAllowSVG inside next.config.js : module.exports = { images: { dangerouslyAllowSVG: true, contentDispositionType: 'attachment', contentSecurityPolicy: \"default-src 'self'; script-src 'none'; sandbox;\", }, } addition, strongly recommended also set contentDispositionType force browser download image, well contentSecurityPolicy prevent scripts embedded image executing. contentDispositionType default loader sets Content-Disposition header attachment added protection since API serve arbitrary remote images. default value attachment forces browser download image visiting directly. particularly important dangerouslyAllowSVG true. optionally configure inline allow browser render image visiting directly, without downloading it. module.exports = { images: { contentDispositionType: 'inline', }, } Animated Images default loader automatically bypass Image Optimization animated images serve image as-is. Auto-detection animated files best-effort supports GIF, APNG, WebP. want explicitly bypass Image Optimization given animated image, use unoptimized prop. Responsive Images default generated srcset contains 1x 2x images order support different device pixel ratios. However, may wish render responsive image stretches viewport. case, need set sizes well style (or className ). render responsive image using one following methods below. Responsive image using static import source image dynamic, statically import create responsive image: import Image 'next/image' import '../photos/me.jpg' export default function Author() { return ( <Image src={me} alt=\"Picture author\" sizes=\"100vw\" style={{ width: '100%', height: 'auto', }} /> ) } Try out: Responsive image aspect ratio source image dynamic remote url, also need provide width height set correct aspect ratio responsive image: import Image 'next/image' export default function Page({ photoUrl }) { return ( <Image src={photoUrl} alt=\"Picture author\" sizes=\"100vw\" style={{ width: '100%', height: 'auto', }} width={500} height={300} /> ) } Try out: Responsive image fill know aspect ratio, need set fill prop set position: relative parent. Optionally, set object-fit style depending desired stretch vs crop behavior: import Image 'next/image' export default function Page({ photoUrl }) { return ( <div style={{ position: 'relative', width: '300px', height: '500px' }}> <Image src={photoUrl} alt=\"Picture author\" sizes=\"300px\" fill style={{ objectFit: 'contain', }} /> </div> ) } Try out: Theme Detection CSS want display different image light dark mode, create new component wraps two <Image> components reveals correct one based CSS media query. .imgDark { display: none; } @media (prefers-color-scheme: dark) { .imgLight { display: none; } .imgDark { display: unset; } } import styles './theme-image.module.css' import Image, { ImageProps } 'next/image' type Props = Omit<ImageProps, 'src' | 'priority' | 'loading'> & { srcLight: string srcDark: string } const ThemeImage = (props: Props) => { const { srcLight, srcDark, ...rest } = props return ( <> <Image {...rest} src={srcLight} className={styles.imgLight} /> <Image {...rest} src={srcDark} className={styles.imgDark} /> </> ) } Good know: default behavior loading=\"lazy\" ensures correct image loaded. cannot usepriority orloading=\"eager\" would cause images load. Instead, usefetchPriority=\"high\" . Try out: getImageProps advanced use cases, call getImageProps() get props would passed underlying <img> element, instead pass another component, style, canvas, etc. also avoid calling React useState() lead better performance, cannot used placeholder prop placeholder never removed. Theme Detection Picture want display different image light dark mode, use <picture> element display different image based user's preferred color scheme. import { getImageProps } 'next/image' export default function Page() { const common = { alt: 'Theme Example', width: 800, height: 400 } const { props: { srcSet: dark }, } = getImageProps({ ...common, src: '/dark.png' }) const { props: { srcSet: light, ...rest }, } = getImageProps({ ...common, src: '/light.png' }) return ( <picture> <source media=\"(prefers-color-scheme: dark)\" srcSet={dark} /> <source media=\"(prefers-color-scheme: light)\" srcSet={light} /> <img {...rest} /> </picture> ) } Art Direction want display different image mobile desktop, sometimes called Art Direction, provide different src , width , height , quality props getImageProps() . import { getImageProps } 'next/image' export default function Home() { const common = { alt: 'Art Direction Example', sizes: '100vw' } const { props: { srcSet: desktop }, } = getImageProps({ ...common, width: 1440, height: 875, quality: 80, src: '/desktop.jpg', }) const { props: { srcSet: mobile, ...rest }, } = getImageProps({ ...common, width: 750, height: 1334, quality: 70, src: '/mobile.jpg', }) return ( <picture> <source media=\"(min-width: 1000px)\" srcSet={desktop} /> <source media=\"(min-width: 500px)\" srcSet={mobile} /> <img {...rest} style={{ width: '100%', height: 'auto' }} /> </picture> ) } Background CSS even convert srcSet string image-set() CSS function optimize background image. import { getImageProps } 'next/image' function getBackgroundImage(srcSet = '') { const imageSet = srcSet .split(', ') .map((str) => { const [url, dpi] = str.split(' ') return `url(\"${url}\") ${dpi}` }) .join(', ') return `image-set(${imageSet})` } export default function Home() { const { props: { srcSet }, } = getImageProps({ alt: '', width: 128, height: 128, src: '/img.png' }) const backgroundImage = getBackgroundImage(srcSet) const style = { height: '100vh', width: '100vw', backgroundImage } return ( <main style={style}> <h1>Hello World</h1> </main> ) } Known Browser Bugs next/image component uses browser native lazy loading, may fallback eager loading older browsers Safari 15.4. using blur-up placeholder, older browsers Safari 12 fallback empty placeholder. using styles width /height auto , possible cause Layout Shift older browsers Safari 15 preserve aspect ratio. details, see MDN video. - Safari 15 - 16.3 display gray border loading. Safari 16.4 fixed issue. Possible solutions: - Use CSS @supports (font: -apple-system-body) (-webkit-appearance: none) { img[loading=\"lazy\"] { clip-path: inset(0.6px) } } - Use priority image fold - Use CSS - Firefox 67+ displays white background loading. Possible solutions: - Enable AVIF formats - Use placeholder - Enable AVIF Version History | Version | Changes | |---|---| v15.0.0 | contentDispositionType configuration default changed attachment . | v14.2.23 | qualities configuration added. | v14.2.15 | decoding prop added localPatterns configuration added. | v14.2.14 | remotePatterns.search prop added. | v14.2.0 | overrideSrc prop added. | v14.1.0 | getImageProps() stable. | v14.0.0 | onLoadingComplete prop domains config deprecated. | v13.4.14 | placeholder prop support data:/image... | v13.2.0 | contentDispositionType configuration added. | v13.0.6 | ref prop added. | v13.0.0 | next/image import renamed next/legacy/image . next/future/image import renamed next/image . codemod available safely automatically rename imports. <span> wrapper removed. layout , objectFit , objectPosition , lazyBoundary , lazyRoot props removed. alt required. onLoadingComplete receives reference img element. Built-in loader config removed. | v12.3.0 | remotePatterns unoptimized configuration stable. | v12.2.0 | Experimental remotePatterns experimental unoptimized configuration added. layout=\"raw\" removed. | v12.1.1 | style prop added. Experimental support layout=\"raw\" added. | v12.1.0 | dangerouslyAllowSVG contentSecurityPolicy configuration added. | v12.0.9 | lazyRoot prop added. | v12.0.0 | formats configuration added.AVIF support added. Wrapper <div> changed <span> . | v11.1.0 | onLoadingComplete lazyBoundary props added. | v11.0.0 | src prop support static import.placeholder prop added.blurDataURL prop added. | v10.0.5 | loader prop added. | v10.0.1 | layout prop added. | v10.0.0 | next/image introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/components/link", "title": "Components: Link | Next.js", "text": "Link <Link> React component extends HTML <a> element provide prefetching client-side navigation routes. primary way navigate routes Next.js. Basic usage: import Link 'next/link' export default function Page() { return <Link href=\"/dashboard\">Dashboard</Link> } Reference following props passed <Link> component: | Prop | Example | Type | Required | |---|---|---|---| href | href=\"/dashboard\" | String Object | Yes | replace | replace={false} | Boolean | - | scroll | scroll={false} | Boolean | - | prefetch | prefetch={false} | Boolean null | - | Good know: <a> tag attributes asclassName ortarget=\"_blank\" added to<Link> props passed underlying<a> element. href (required) path URL navigate to. import Link 'next/link' // Navigate /about?name=test export default function Page() { return ( <Link href={{ pathname: '/about', query: { name: 'test' }, }} > </Link> ) } replace Defaults false . true , next/link replace current history state instead adding new URL browser's history stack. import Link 'next/link' export default function Page() { return ( <Link href=\"/dashboard\" replace> Dashboard </Link> ) } scroll Defaults true . default scrolling behavior <Link> Next.js maintain scroll position, similar browsers handle back forwards navigation. navigate new Page, scroll position stay long Page visible viewport. However, Page visible viewport, Next.js scroll top first Page element. scroll = {false} , Next.js attempt scroll first Page element. Good know: Next.js checks scroll: false managing scroll behavior. scrolling enabled, identifies relevant DOM node navigation inspects top-level element. non-scrollable elements without rendered HTML bypassed, includes sticky fixed positioned elements, non-visible elements calculated withgetBoundingClientRect . Next.js continues siblings identifies scrollable element visible viewport. import Link 'next/link' export default function Page() { return ( <Link href=\"/dashboard\" scroll={false}> Dashboard </Link> ) } prefetch Prefetching happens <Link /> component enters user's viewport (initially scroll). Next.js prefetches loads linked route (denoted href ) data background improve performance client-side navigations. prefetched data expired time user hovers <Link /> , Next.js attempt prefetch again. Prefetching enabled production. following values passed prefetch prop: null (default): Prefetch behavior depends whether route static dynamic. static routes, full route prefetched (including data). dynamic routes, partial route nearest segment aloading.js boundary prefetched.true : full route prefetched static dynamic routes.false : Prefetching never happen entering viewport hover. import Link 'next/link' export default function Page() { return ( <Link href=\"/dashboard\" prefetch={false}> Dashboard </Link> ) } Examples following examples demonstrate use <Link> component different scenarios. Linking dynamic segments linking dynamic segments, use template literals interpolation generate list links. example, generate list blog posts: import Link 'next/link' interface Post { id: number title: string slug: string } export default function PostList({ posts }: { posts: Post[] }) { return ( <ul> {posts.map((post) => ( <li key={post.id}> <Link href={`/blog/${post.slug}`}>{post.title}</Link> </li> ))} </ul> ) } Checking active links use usePathname() determine link active. example, add class active link, check current pathname matches href link: 'use client' import { usePathname } 'next/navigation' import Link 'next/link' export function Links() { const pathname = usePathname() return ( <nav> <Link className={`link ${pathname === '/' ? 'active' : ''}`} href=\"/\"> Home </Link> <Link className={`link ${pathname === '/about' ? 'active' : ''}`} href=\"/about\" > </Link> </nav> ) } Scrolling id like scroll specific id navigation, append URL # hash link pass hash link href prop. possible since <Link> renders <a> element. <Link href=\"/dashboard#settings\">Settings</Link> // Output <a href=\"/dashboard#settings\">Settings</a> Good know: - Next.js scroll Page visible viewport upon navigation. Linking dynamic route segments dynamic route segments, handy use template literals create link's path. example, generate list links dynamic route app/blog/[slug]/page.js : import Link 'next/link' export default function Page({ posts }) { return ( <ul> {posts.map((post) => ( <li key={post.id}> <Link href={`/blog/${post.slug}`}>{post.title}</Link> </li> ))} </ul> ) } child custom component wraps <a> tag child Link custom component wraps <a> tag, must add passHref Link . necessary you\u2019re using libraries like styled-components. Without this, <a> tag href attribute, hurts site's accessibility might affect SEO. using ESLint, built-in rule next/link-passhref ensure correct usage passHref . import Link 'next/link' import styled 'styled-components' // creates custom component wraps <a> tag const RedLink = styled.a` color: red; ` function NavLink({ href, name }) { return ( <Link href={href} passHref legacyBehavior> <RedLink>{name}</RedLink> </Link> ) } export default NavLink - you\u2019re using emotion\u2019s JSX pragma feature ( @jsx jsx ), must usepassHref even use an<a> tag directly. - component support onClick property trigger navigation correctly. Nesting functional component child Link functional component, addition using passHref legacyBehavior , must wrap component React.forwardRef : import Link 'next/link' import React 'react' // Define props type MyButton interface MyButtonProps { onClick?: React.MouseEventHandler<HTMLAnchorElement> href?: string } // Use React.ForwardRefRenderFunction properly type forwarded ref const MyButton: React.ForwardRefRenderFunction< HTMLAnchorElement, MyButtonProps > = ({ onClick, href }, ref) => { return ( <a href={href} onClick={onClick} ref={ref}> Click </a> ) } // Use React.forwardRef wrap component const ForwardedMyButton = React.forwardRef(MyButton) export default function Page() { return ( <Link href=\"/about\" passHref legacyBehavior> <ForwardedMyButton /> </Link> ) } Replace URL instead push default behavior Link component push new URL history stack. use replace prop prevent adding new entry, following example: import Link 'next/link' export default function Page() { return ( <Link href=\"/about\" replace> us </Link> ) } Disable scrolling top page default scrolling behavior <Link> Next.js maintain scroll position, similar browsers handle back forwards navigation. navigate new Page, scroll position stay long Page visible viewport. However, Page visible viewport, Next.js scroll top first Page element. like disable behavior, pass scroll={false} <Link> component, scroll: false router.push() router.replace() . import Link 'next/link' export default function Page() { return ( <Link href=\"/#hashid\" scroll={false}> Disables scrolling top </Link> ) } Using router.push() router.replace() : // useRouter import { useRouter } 'next/navigation' const router = useRouter() router.push('/dashboard', { scroll: false }) Prefetching links Middleware common use Middleware authentication purposes involve rewriting user different page. order <Link /> component properly prefetch links rewrites via Middleware, need tell Next.js URL display URL prefetch. required avoid un-necessary fetches middleware know correct route prefetch. example, want serve /dashboard route authenticated visitor views, add following Middleware redirect user correct page: import { NextResponse } 'next/server' export function middleware(request: Request) { const nextUrl = request.nextUrl (nextUrl.pathname === '/dashboard') { (request.cookies.authToken) { return NextResponse.rewrite(new URL('/auth/dashboard', request.url)) } else { return NextResponse.rewrite(new URL('/public/dashboard', request.url)) } } } case, would want use following code <Link /> component: 'use client' import Link 'next/link' import useIsAuthed './hooks/useIsAuthed' // auth hook export default function Page() { const isAuthed = useIsAuthed() const path = isAuthed ? '/auth/dashboard' : '/public/dashboard' return ( <Link as=\"/dashboard\" href={path}> Dashboard </Link> ) } Version history | Version | Changes | |---|---| v13.0.0 | longer requires child <a> tag. codemod provided automatically update codebase. | v10.0.0 | href props pointing dynamic route automatically resolved longer require prop. | v8.0.0 | Improved prefetching performance. | v1.0.0 | next/link introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/components/script", "title": "Components: Script | Next.js", "text": "Script API reference help understand use props available Script Component. features usage, please see Optimizing Scripts page. import Script 'next/script' export default function Dashboard() { return ( <> <Script src=\"https://example.com/script.js\" /> </> ) } Props Here's summary props available Script Component: | Prop | Example | Type | Required | |---|---|---|---| src | src=\"http://example.com/script\" | String | Required unless inline script used | strategy | strategy=\"lazyOnload\" | String | - | onLoad | onLoad={onLoadFunc} | Function | - | onReady | onReady={onReadyFunc} | Function | - | onError | onError={onErrorFunc} | Function | - | Required Props <Script /> component requires following properties. src path string specifying URL external script. either absolute external URL internal path. src property required unless inline script used. Optional Props <Script /> component accepts number additional properties beyond required. strategy loading strategy script. four different strategies used: beforeInteractive : Load Next.js code page hydration occurs.afterInteractive : (default) Load early hydration page occurs.lazyOnload : Load browser idle time.worker : (experimental) Load web worker. beforeInteractive Scripts load beforeInteractive strategy injected initial HTML server, downloaded Next.js module, executed order placed hydration occurs page. Scripts denoted strategy preloaded fetched first-party code, execution block page hydration occurring. beforeInteractive scripts must placed inside root layout (app/layout.tsx ) designed load scripts needed entire site (i.e. script load page application loaded server-side). strategy used critical scripts need fetched part page becomes interactive. import Script 'next/script' export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body> {children} <Script src=\"https://example.com/script.js\" strategy=\"beforeInteractive\" /> </body> </html> ) } Good know: Scripts beforeInteractive always injected inside thehead HTML document regardless placed component. examples scripts loaded soon possible beforeInteractive include: - Bot detectors - Cookie consent managers afterInteractive Scripts use afterInteractive strategy injected HTML client-side load (or all) hydration occurs page. default strategy Script component used script needs load soon possible first-party Next.js code. afterInteractive scripts placed inside page layout load execute page (or group pages) opened browser. import Script 'next/script' export default function Page() { return ( <> <Script src=\"https://example.com/script.js\" strategy=\"afterInteractive\" /> </> ) } examples scripts good candidates afterInteractive include: - Tag managers - Analytics lazyOnload Scripts use lazyOnload strategy injected HTML client-side browser idle time load resources page fetched. strategy used background low priority scripts need load early. lazyOnload scripts placed inside page layout load execute page (or group pages) opened browser. import Script 'next/script' export default function Page() { return ( <> <Script src=\"https://example.com/script.js\" strategy=\"lazyOnload\" /> </> ) } Examples scripts need load immediately fetched lazyOnload include: - Chat support plugins - Social media widgets worker Warning: worker strategy yet stable yet work App Router. Use caution. Scripts use worker strategy off-loaded web worker order free main thread ensure critical, first-party resources processed it. strategy used script, advanced use case guaranteed support third-party scripts. use worker strategy, nextScriptWorkers flag must enabled next.config.js : module.exports = { experimental: { nextScriptWorkers: true, }, } worker scripts currently used pages/ directory: import Script 'next/script' export default function Home() { return ( <> <Script src=\"https://example.com/script.js\" strategy=\"worker\" /> </> ) } onLoad Warning: onLoad yet work Server Components used Client Components. Further,onLoad can't used withbeforeInteractive \u2013 consider usingonReady instead. third-party scripts require users run JavaScript code script finished loading order instantiate content call function. loading script either afterInteractive lazyOnload loading strategy, execute code loaded using onLoad property. Here's example executing lodash method library loaded. 'use client' import Script 'next/script' export default function Page() { return ( <> <Script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js\" onLoad={() => { console.log(_.sample([1, 2, 3, 4])) }} /> </> ) } onReady Warning: onReady yet work Server Components used Client Components. third-party scripts require users run JavaScript code script finished loading every time component mounted (after route navigation example). execute code script's load event first loads every subsequent component re-mount using onReady property. Here's example re-instantiate Google Maps JS embed every time component mounted: 'use client' import { useRef } 'react' import Script 'next/script' export default function Page() { const mapRef = useRef() return ( <> <div ref={mapRef}></div> <Script id=\"google-maps\" src=\"https://maps.googleapis.com/maps/api/js\" onReady={() => { new google.maps.Map(mapRef.current, { center: { lat: -34.397, lng: 150.644 }, zoom: 8, }) }} /> </> ) } onError Warning: onError yet work Server Components used Client Components.onError cannot used thebeforeInteractive loading strategy. Sometimes helpful catch script fails load. errors handled onError property: 'use client' import Script 'next/script' export default function Page() { return ( <> <Script src=\"https://example.com/script.js\" onError={(e: Error) => { console.error('Script failed load', e) }} /> </> ) } Version History | Version | Changes | |---|---| v13.0.0 | beforeInteractive afterInteractive modified support app . | v12.2.4 | onReady prop added. | v12.2.2 | Allow next/script beforeInteractive placed _document . | v11.0.0 | next/script introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/directives", "title": "API Reference: Directives | Next.js", "text": "Directives following directives available: use cache Learn use use cache directive cache data Next.js application. use client Learn use use client directive render component client. use server Learn use use server directive execute code server. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/directives/use-cache", "title": "Directives: use cache | Next.js", "text": "use cache use cache directive designates component and/or function cached. used top file indicate exports file cacheable, inline top function component inform Next.js return value cached reused subsequent requests. experimental Next.js feature, native React feature like use client use server . Usage Enable support use cache directive useCache flag next.config.ts file: import type { NextConfig } 'next' const nextConfig: NextConfig = { experimental: { useCache: true, }, } export default nextConfig Additionally, use cache directives also enabled dynamicIO flag set. Then, use use cache directive file, component, function level: // File level 'use cache' export default async function Page() { // ... } // Component level export async function MyComponent() { 'use cache' return <></> } // Function level export async function getData() { 'use cache' const data = await fetch('/api/data') return data } Good know use cache experimental Next.js feature, native React feature likeuse client oruse server .- serializable arguments (or props) passed cached function, well serializable values reads parent scope, converted format like JSON automatically become part cache key. - non-serializable arguments, props, closed-over values turn opaque references inside cached function, passed inspected modified. non-serializable values filled request time become part cache key. - example, cached function take JSX children prop return<div>{children}</div> , able introspect actualchildren object. - example, cached function take JSX - return value cacheable function must also serializable. ensures cached data stored retrieved correctly. - Functions use use cache directive must side-effects, modifying state, directly manipulating DOM, setting timers execute code intervals. - used alongside Partial Prerendering, segments use cache prerendered part static HTML shell. - Unlike unstable_cache supports JSON data,use cache cache serializable data React render, including render output components. Examples Caching entire routes use cache prerender entire route, add use cache top layout page files. segments treated separate entry points application, cached independently. 'use cache' export default function Layout({ children }: { children: ReactNode }) { return <div>{children}</div> } components imported nested page file inherit cache behavior page . 'use cache' async function Users() { const users = await fetch('/api/users') // loop users } export default function Page() { return ( <main> <Users /> </main> ) } recommended applications previously used export const dynamic = \"force-static\" option, ensure entire route prerendered. Caching component output use cache use use cache component level cache fetches computations performed within component. reuse component throughout application share cache entry long props maintain structure. props serialized form part cache key, cache entry reused long serialized props produce value instance. export async function Bookings({ type = 'haircut' }: BookingsProps) { 'use cache' async function getBookingsData() { const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`) return data } return //... } interface BookingsProps { type: string } Caching function output use cache Since add use cache asynchronous function, limited caching components routes only. might want cache network request database query compute something slow. adding use cache function containing type work becomes cacheable, reused, share cache entry. export async function getData() { 'use cache' const data = await fetch('/api/data') return data } Revalidating default, Next.js sets revalidation period 15 minutes use use cache directive. Next.js sets near-infinite expiration duration, meaning suitable content need frequent updates. revalidation period may useful content expect change often, use cacheLife cacheTag APIs configure cache behavior: APIs integrate across client server caching layers, meaning configure caching semantics one place apply everywhere. See cacheLife cacheTag docs information. Interleaving need pass non-serializable arguments cacheable function, pass children . means children reference change without affecting cache entry. export default async function Page() { const uncachedData = await getData() return ( <CacheComponent> <DynamicComponent data={uncachedData} /> </CacheComponent> ) } async function CacheComponent({ children }: { children: ReactNode }) { 'use cache' const cachedData = await fetch('/api/cached-data') return ( <div> <PrerenderedComponent data={cachedData} /> {children} </div> ) } also pass Server Actions cached components Client Components without invoking inside cacheable function. import ClientComponent './ClientComponent' export default async function Page() { const performUpdate = async () => { 'use server' // Perform server-side update await db.update(...) } return <CacheComponent performUpdate={performUpdate} /> } async function CachedComponent({ performUpdate, }: { performUpdate: () => Promise<void> }) { 'use cache' // call performUpdate return <ClientComponent action={performUpdate} /> } 'use client' export default function ClientComponent({ action, }: { action: () => Promise<void> }) { return <button onClick={action}>Update</button> } Related useCache dynamicIO cacheLife cacheTag cacheLife revalidateTag helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/directives/use-client", "title": "Directives: use client | Next.js", "text": "use client use client directive designates component rendered client side used creating interactive user interfaces (UI) require client-side JavaScript capabilities, state management, event handling, access browser APIs. React feature. Usage designate component Client Component, add use client directive top file, imports: app/components/counter.tsx 'use client' import { useState } 'react' export default function Counter() { const [count, setCount] = useState(0) return ( <div> <p>Count: {count}</p> <button onClick={() => setCount(count + 1)}>Increment</button> </div> ) } Nesting Client Components within Server Components Combining Server Client Components allows build applications performant interactive: - Server Components: Use static content, data fetching, SEO-friendly elements. - Client Components: Use interactive elements require state, effects, browser APIs. - Component composition: Nest Client Components within Server Components needed clear separation server client logic. following example: Header Server Component handling static content.Counter Client Component enabling interactivity within page. app/page.tsx import Header './header' import Counter './counter' // Client Component export default function Page() { return ( <div> <Header /> <Counter /> </div> ) } Reference See React documentation information use client . helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/directives/use-server", "title": "Directives: use server | Next.js", "text": "use server use server directive designates function file executed server side. used top file indicate functions file server-side, inline top function mark function Server Function. React feature. Using use server top file following example shows file use server directive top. functions file executed server. 'use server' import { db } '@/lib/db' // database client export async function createUser(data: { name: string; email: string }) { const user = await db.user.create({ data }) return user } Using Server Functions Client Component use Server Functions Client Components need create Server Functions dedicated file using use server directive top file. Server Functions imported Client Server Components executed. Assuming fetchUsers Server Function actions.ts : 'use server' import { db } '@/lib/db' // database client export async function fetchUsers() { const users = await db.user.findMany() return users } import fetchUsers Server Function Client Component execute client-side. 'use client' import { fetchUsers } '../actions' export default function MyButton() { return <button onClick={() => fetchUsers()}>Fetch Users</button> } Using use server inline following example, use server used inline top function mark Server Function: import { db } '@/lib/db' // database client export default function UserList() { async function fetchUsers() { 'use server' const users = await db.user.findMany() return users } return <button onClick={() => fetchUsers()}>Fetch Users</button> } Security considerations using use server directive, important ensure server-side logic secure sensitive data remains protected. Authentication authorization Always authenticate authorize users performing sensitive server-side operations. 'use server' import { db } '@/lib/db' // database client import { authenticate } '@/lib/auth' // authentication library export async function createUser( data: { name: string; email: string }, token: string ) { const user = authenticate(token) (!user) { throw new Error('Unauthorized') } const newUser = await db.user.create({ data }) return newUser } Reference See React documentation information use server . helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/edge", "title": "API Reference: Edge Runtime | Next.js", "text": "Edge Runtime Next.js Edge Runtime used Middleware supports following APIs: Network APIs | API | Description | |---|---| Blob | Represents blob | fetch | Fetches resource | FetchEvent | Represents fetch event | File | Represents file | FormData | Represents form data | Headers | Represents HTTP headers | Request | Represents HTTP request | Response | Represents HTTP response | URLSearchParams | Represents URL search parameters | WebSocket | Represents websocket connection | Encoding APIs | API | Description | |---|---| atob | Decodes base-64 encoded string | btoa | Encodes string base-64 | TextDecoder | Decodes Uint8Array string | TextDecoderStream | Chainable decoder streams | TextEncoder | Encodes string Uint8Array | TextEncoderStream | Chainable encoder streams | Stream APIs | API | Description | |---|---| ReadableStream | Represents readable stream | ReadableStreamBYOBReader | Represents reader ReadableStream | ReadableStreamDefaultReader | Represents reader ReadableStream | TransformStream | Represents transform stream | WritableStream | Represents writable stream | WritableStreamDefaultWriter | Represents writer WritableStream | Crypto APIs | API | Description | |---|---| crypto | Provides access cryptographic functionality platform | CryptoKey | Represents cryptographic key | SubtleCrypto | Provides access common cryptographic primitives, like hashing, signing, encryption decryption | Web Standard APIs | API | Description | |---|---| AbortController | Allows abort one DOM requests desired | Array | Represents array values | ArrayBuffer | Represents generic, fixed-length raw binary data buffer | Atomics | Provides atomic operations static methods | BigInt | Represents whole number arbitrary precision | BigInt64Array | Represents typed array 64-bit signed integers | BigUint64Array | Represents typed array 64-bit unsigned integers | Boolean | Represents logical entity two values: true false | clearInterval | Cancels timed, repeating action previously established call setInterval() | clearTimeout | Cancels timed, repeating action previously established call setTimeout() | console | Provides access browser's debugging console | DataView | Represents generic view ArrayBuffer | Date | Represents single moment time platform-independent format | decodeURI | Decodes Uniform Resource Identifier (URI) previously created encodeURI similar routine | decodeURIComponent | Decodes Uniform Resource Identifier (URI) component previously created encodeURIComponent similar routine | DOMException | Represents error occurs DOM | encodeURI | Encodes Uniform Resource Identifier (URI) replacing instance certain characters one, two, three, four escape sequences representing UTF-8 encoding character | encodeURIComponent | Encodes Uniform Resource Identifier (URI) component replacing instance certain characters one, two, three, four escape sequences representing UTF-8 encoding character | Error | Represents error trying execute statement accessing property | EvalError | Represents error occurs regarding global function eval() | Float32Array | Represents typed array 32-bit floating point numbers | Float64Array | Represents typed array 64-bit floating point numbers | Function | Represents function | Infinity | Represents mathematical Infinity value | Int8Array | Represents typed array 8-bit signed integers | Int16Array | Represents typed array 16-bit signed integers | Int32Array | Represents typed array 32-bit signed integers | Intl | Provides access internationalization localization functionality | isFinite | Determines whether value finite number | isNaN | Determines whether value NaN | JSON | Provides functionality convert JavaScript values JSON format | Map | Represents collection values, value may occur | Math | Provides access mathematical functions constants | Number | Represents numeric value | Object | Represents object base JavaScript objects | parseFloat | Parses string argument returns floating point number | parseInt | Parses string argument returns integer specified radix | Promise | Represents eventual completion (or failure) asynchronous operation, resulting value | Proxy | Represents object used define custom behavior fundamental operations (e.g. property lookup, assignment, enumeration, function invocation, etc) | queueMicrotask | Queues microtask executed | RangeError | Represents error value set range allowed values | ReferenceError | Represents error non-existent variable referenced | Reflect | Provides methods interceptable JavaScript operations | RegExp | Represents regular expression, allowing match combinations characters | Set | Represents collection values, value may occur | setInterval | Repeatedly calls function, fixed time delay call | setTimeout | Calls function evaluates expression specified number milliseconds | SharedArrayBuffer | Represents generic, fixed-length raw binary data buffer | String | Represents sequence characters | structuredClone | Creates deep copy value | Symbol | Represents unique immutable data type used key object property | SyntaxError | Represents error trying interpret syntactically invalid code | TypeError | Represents error value expected type | Uint8Array | Represents typed array 8-bit unsigned integers | Uint8ClampedArray | Represents typed array 8-bit unsigned integers clamped 0-255 | Uint32Array | Represents typed array 32-bit unsigned integers | URIError | Represents error global URI handling function used wrong way | URL | Represents object providing static methods used creating object URLs | URLPattern | Represents URL pattern | URLSearchParams | Represents collection key/value pairs | WeakMap | Represents collection key/value pairs keys weakly referenced | WeakSet | Represents collection objects object may occur | WebAssembly | Provides access WebAssembly | Next.js Specific Polyfills Environment Variables use process.env access Environment Variables next dev next build . Unsupported APIs Edge Runtime restrictions including: - Native Node.js APIs supported. example, can't read write filesystem. node_modules used, long implement ES Modules use native Node.js APIs.- Calling require directly allowed. Use ES Modules instead. following JavaScript language features disabled, work: | API | Description | |---|---| eval | Evaluates JavaScript code represented string | new Function(evalString) | Creates new function code provided argument | WebAssembly.compile | Compiles WebAssembly module buffer source | WebAssembly.instantiate | Compiles instantiates WebAssembly module buffer source | rare cases, code could contain (or import) dynamic code evaluation statements reached runtime removed treeshaking. relax check allow specific files Middleware configuration: export const config = { unstable_allowDynamic: [ // allows single file '/lib/utilities.js', // use glob allow anything function-bind 3rd party module '**/node_modules/function-bind/**', ], } unstable_allowDynamic glob, array globs, ignoring dynamic code evaluation specific files. globs relative application root folder. warned statements executed Edge, throw cause runtime error. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions", "title": "API Reference: File Conventions | Next.js", "text": "File Conventions default.js API Reference default.js file. error.js API reference error.js special file. forbidden.js API reference forbidden.js special file. instrumentation.js API reference instrumentation.js file. layout.js API reference layout.js file. loading.js API reference loading.js file. mdx-components.js API reference mdx-components.js file. middleware.js API reference middleware.js file. not-found.js API reference not-found.js file. page.js API reference page.js file. route.js API reference route.js special file. Route Segment Config Learn configure options Next.js route segments. template.js API Reference template.js file. unauthorized.js API reference unauthorized.js special file. Metadata Files API documentation metadata file conventions. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/default", "title": "File Conventions: default.js | Next.js", "text": "default.js default.js file used render fallback within Parallel Routes Next.js cannot recover slot's active state full-page load. soft navigation, Next.js keeps track active state (subpage) slot. However, hard navigations (full-page load), Next.js cannot recover active state. case, default.js file rendered subpages match current URL. Consider following folder structure. @team slot settings page, @analytics not. navigating /settings , @team slot render settings page maintaining currently active page @analytics slot. refresh, Next.js render default.js @analytics . default.js exist, 404 rendered instead. Additionally, since children implicit slot, also need create default.js file render fallback children Next.js cannot recover active state parent page. Reference params (optional) promise resolves object containing dynamic route parameters root segment slot's subpages. example: export default async function Default({ params, }: { params: Promise<{ artist: string }> }) { const artist = (await params).artist } | Example | URL | params | |---|---|---| app/[artist]/@sidebar/default.js | /zack | Promise<{ artist: 'zack' }> | app/[artist]/[album]/@sidebar/default.js | /zack/next | Promise<{ artist: 'zack', album: 'next' }> | - Since params prop promise. must useasync/await React'suse function access values.- version 14 earlier, params synchronous prop. help backwards compatibility, still access synchronously Next.js 15, behavior deprecated future. - version 14 earlier, Learn Parallel Routes helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/error", "title": "File Conventions: error.js | Next.js", "text": "error.js error file allows handle unexpected runtime errors display fallback UI. 'use client' // Error boundaries must Client Components import { useEffect } 'react' export default function Error({ error, reset, }: { error: Error & { digest?: string } reset: () => void }) { useEffect(() => { // Log error error reporting service console.error(error) }, [error]) return ( <div> <h2>Something went wrong!</h2> <button onClick={ // Attempt recover trying re-render segment () => reset() } > Try </button> </div> ) } error.js wraps route segment nested children React Error Boundary. error throws within boundary, error component shows fallback UI. Good know: - React DevTools allow toggle error boundaries test error states. - want errors bubble parent error boundary, throw rendering theerror component. Reference Props error instance Error object forwarded error.js Client Component. Good know: development, Error object forwarded client serialized include themessage original error easier debugging. However, behavior different production avoid leaking potentially sensitive details included error client. error.message - Errors forwarded Client Components show original Error message. - Errors forwarded Server Components show generic message identifier. prevent leaking sensitive details. use identifier, errors.digest , match corresponding server-side logs. error.digest automatically generated hash error thrown. used match corresponding error server-side logs. reset cause error sometimes temporary. cases, trying might resolve issue. error component use reset() function prompt user attempt recover error. executed, function try re-render error boundary's contents. successful, fallback error component replaced result re-render. 'use client' // Error boundaries must Client Components export default function Error({ error, reset, }: { error: Error & { digest?: string } reset: () => void }) { return ( <div> <h2>Something went wrong!</h2> <button onClick={() => reset()}>Try again</button> </div> ) } Examples Global Error less common, handle errors root layout template using global-error.js , located root app directory, even leveraging internationalization. Global error UI must define <html> <body> tags. file replaces root layout template active. 'use client' // Error boundaries must Client Components export default function GlobalError({ error, reset, }: { error: Error & { digest?: string } reset: () => void }) { return ( // global-error must include html body tags <html> <body> <h2>Something went wrong!</h2> <button onClick={() => reset()}>Try again</button> </body> </html> ) } Good know: global-error.js always displayed development, error overlay show instead. Version History | Version | Changes | |---|---| v15.2.0 | display global-error also development. | v13.1.0 | global-error introduced. | v13.0.0 | error introduced. | Learn error handling helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/forbidden", "title": "File Conventions: forbidden.js | Next.js", "text": "forbidden.js feature currently experimental subject change, recommended production. Try share feedback GitHub. forbidden file used render UI forbidden function invoked authentication. Along allowing customize UI, Next.js return 403 status code. app/forbidden.tsx import Link 'next/link' export default function Forbidden() { return ( <div> <h2>Forbidden</h2> <p>You authorized access resource.</p> <Link href=\"/\">Return Home</Link> </div> ) } Reference Props forbidden.js components accept props. Version History | Version | Changes | |---|---| v15.1.0 | forbidden.js introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/instrumentation", "title": "File Conventions: instrumentation.js | Next.js", "text": "instrumentation.js instrumentation.js|ts file used integrate observability tools application, allowing track performance behavior, debug issues production. use it, place file root application inside src folder using one. Exports register (optional) file exports register function called new Next.js server instance initiated. register async function. import { registerOTel } '@vercel/otel' export function register() { registerOTel('next-app') } onRequestError (optional) optionally export onRequestError function track server errors custom observability provider. - running async tasks onRequestError , make sure awaited.onRequestError triggered Next.js server captures error. - error instance might original error instance thrown, may processed React encountered Server Components rendering. happens, usedigest property error identify actual error type. import { type Instrumentation } 'next' export const onRequestError: Instrumentation.onRequestError = async ( err, request, context ) => { await fetch('https://.../report-error', { method: 'POST', body: JSON.stringify({ message: err.message, request, context, }), headers: { 'Content-Type': 'application/json', }, }) } Parameters function accepts three parameters: error , request , context . export function onRequestError( error: { digest: string } & Error, request: { path: string // resource path, e.g. /blog?name=foo method: string // request method. e.g. GET, POST, etc headers: { [key: string]: string } }, context: { routerKind: 'Pages Router' | 'App Router' // router type routePath: string // route file path, e.g. /app/blog/[dynamic] routeType: 'render' | 'route' | 'action' | 'middleware' // context error occurred renderSource: | 'react-server-components' | 'react-server-components-payload' | 'server-rendering' revalidateReason: 'on-demand' | 'stale' | undefined // undefined normal request without revalidation renderType: 'dynamic' | 'dynamic-resume' // 'dynamic-resume' PPR } ): void | Promise<void> error : caught error (type alwaysError ), adigest property unique ID error.request : Read-only request information associated error.context : context error occurred. type router (App Pages Router), and/or (Server Components ('render' ), Route Handlers ('route' ), Server Actions ('action' ), Middleware ('middleware' )). Specifying runtime instrumentation.js file works Node.js Edge runtime, however, use process.env.NEXT_RUNTIME target specific runtime. export function register() { (process.env.NEXT_RUNTIME === 'edge') { return require('./register.edge') } else { return require('./register.node') } } export function onRequestError() { (process.env.NEXT_RUNTIME === 'edge') { return require('./on-request-error.edge') } else { return require('./on-request-error.node') } } Version History | Version | Changes | |---|---| v15.0.0-RC | onRequestError introduced, instrumentation stable | v14.0.4 | Turbopack support instrumentation | v13.2.0 | instrumentation introduced experimental feature | Learn Instrumentation helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/instrumentation-client", "title": "File-system conventions: instrumentation-client.js | Next.js", "text": "instrumentation-client.js instrumentation-client.js|ts file allows add monitoring analytics code runs application's frontend code starts executing. useful setting performance tracking, error monitoring, client-side observability tools. use it, place file root application inside src folder. Usage Unlike server-side instrumentation, need export specific functions. write monitoring code directly file: instrumentation-client.ts // Set performance monitoring performance.mark('app-init') // Initialize analytics console.log('Analytics initialized') // Set error tracking window.addEventListener('error', (event) => { // Send error tracking service reportError(event.error) }) Version History | Version | Changes | |---|---| v15.3 | instrumentation-client introduced | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/intercepting-routes", "title": "File-system conventions: Intercepting Routes | Next.js", "text": "Intercepting Routes Intercepting routes allows load route another part application within current layout. routing paradigm useful want display content route without user switching different context. example, clicking photo feed, display photo modal, overlaying feed. case, Next.js intercepts /photo/123 route, masks URL, overlays /feed . However, navigating photo clicking shareable URL refreshing page, entire photo page render instead modal. route interception occur. Convention Intercepting routes defined (..) convention, similar relative path convention ../ segments. use: (.) match segments level(..) match segments one level above(..)(..) match segments two levels above(...) match segments rootapp directory example, intercept photo segment within feed segment creating (..)photo directory. Note (..) convention based route segments, file-system. Examples Modals Intercepting Routes used together Parallel Routes create modals. allows solve common challenges building modals, as: - Making modal content shareable URL. - Preserving context page refreshed, instead closing modal. - Closing modal backwards navigation rather going previous route. - Reopening modal forwards navigation. Consider following UI pattern, user open photo modal gallery using client-side navigation, navigate photo page directly shareable URL: example, path photo segment use (..) matcher since @modal slot segment. means photo route one segment level higher, despite two file-system levels higher. See Parallel Routes documentation step-by-step example, see image gallery example. Good know: - examples could include opening login modal top navbar also dedicated /login page, opening shopping cart side modal. Next Steps helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/layout", "title": "File Conventions: layout.js | Next.js", "text": "layout.js layout file used define layout Next.js application. export default function DashboardLayout({ children, }: { children: React.ReactNode }) { return <section>{children}</section> } root layout top-most layout root app directory. used define <html> <body> tags globally shared UI. export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body>{children}</body> </html> ) } Reference Props children (required) Layout components accept use children prop. rendering, children populated route segments layout wrapping. primarily component child Layout (if exists) Page, could also special files like Loading Error applicable. params (optional) promise resolves object containing dynamic route parameters object root segment layout. export default async function Layout({ params, }: { params: Promise<{ team: string }> }) { const team = (await params).team } | Example Route | URL | params | |---|---|---| app/dashboard/[team]/layout.js | /dashboard/1 | Promise<{ team: '1' }> | app/shop/[tag]/[item]/layout.js | /shop/1/2 | Promise<{ tag: '1', item: '2' }> | app/blog/[...slug]/layout.js | /blog/1/2 | Promise<{ slug: ['1', '2'] }> | - Since params prop promise. must useasync/await React'suse function access values.- version 14 earlier, params synchronous prop. help backwards compatibility, still access synchronously Next.js 15, behavior deprecated future. - version 14 earlier, Root Layouts app directory must include root app/layout.js . export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html> <body>{children}</body> </html> ) } - root layout must define <html> and<body> tags.- manually add <head> tags as<title> and<meta> root layouts. Instead, use Metadata API automatically handles advanced requirements streaming de-duplicating<head> elements. - manually add - use route groups create multiple root layouts. - Navigating across multiple root layouts cause full page load (as opposed client-side navigation). example, navigating /cart usesapp/(shop)/layout.js to/blog usesapp/(marketing)/layout.js cause full page load. applies multiple root layouts. - Navigating across multiple root layouts cause full page load (as opposed client-side navigation). example, navigating Caveats Layouts receive searchParams Unlike Pages, Layout components receive searchParams prop. shared layout re-rendered navigation could lead stale searchParams navigations. using client-side navigation, Next.js automatically renders part page common layout two routes. example, following directory structure, dashboard/layout.tsx common layout /dashboard/settings /dashboard/analytics : navigating /dashboard/settings /dashboard/analytics , page.tsx /dashboard/analytics rerender server, dashboard/layout.tsx rerender common UI shared two routes. performance optimization allows navigation pages share layout quicker data fetching rendering page run, instead entire route could include shared layouts fetch data. dashboard/layout.tsx re-render, searchParams prop layout Server Component might become stale navigation. Instead, use Page searchParams prop useSearchParams hook Client Component within layout, rerendered client latest searchParams . Layouts cannot access pathname Layouts cannot access pathname . layouts Server Components default, rerender client-side navigation, could lead pathname becoming stale navigations. prevent staleness, Next.js would need refetch segments route, losing benefits caching increasing RSC payload size navigation. Instead, extract logic depends pathname Client Component import layouts. Since Client Components rerender (but refetched) navigation, use Next.js hooks usePathname access current pathname prevent staleness. import { ClientComponent } '@/app/ui/ClientComponent' export default function Layout({ children }: { children: React.ReactNode }) { return ( <> <ClientComponent /> {/* Layout UI */} <main>{children}</main> </> ) } Common pathname patterns also implemented params prop. See examples section information. Examples Displaying content based params Using dynamic route segments, display fetch specific content based params prop. export default async function DashboardLayout({ children, params, }: { children: React.ReactNode params: Promise<{ team: string }> }) { const { team } = await params return ( <section> <header> <h1>Welcome {team}'s Dashboard</h1> </header> <main>{children}</main> </section> ) } Reading params Client Components use params Client Component (which cannot async ), use React's use function read promise: 'use client' import { use } 'react' export default function Page({ params, }: { params: Promise<{ slug: string }> }) { const { slug } = use(params) } Version History | Version | Changes | |---|---| v15.0.0-RC | params promise. codemod available. | v13.0.0 | layout introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/loading", "title": "File Conventions: loading.js | Next.js", "text": "loading.js loading file create instant loading states built Suspense. default, file Server Component - also used Client Component \"use client\" directive. app/feed/loading.tsx export default function Loading() { // custom loading skeleton component return <p>Loading...</p> } Loading UI components accept parameters. Good know: - designing loading UI, may find helpful use React Developer Tools manually toggle Suspense boundaries. Version History | Version | Changes | |---|---| v13.0.0 | loading introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/mdx-components", "title": "File Conventions: mdx-components.js | Next.js", "text": "mdx-components.js mdx-components.js|tsx file required use @next/mdx App Router work without it. Additionally, use customize styles. Use file mdx-components.tsx (or .js ) root project define MDX Components. example, level pages app , inside src applicable. mdx-components.tsx import type { MDXComponents } 'mdx/types' export function useMDXComponents(components: MDXComponents): MDXComponents { return { ...components, } } Exports useMDXComponents function file must export single function, either default export named useMDXComponents . mdx-components.tsx import type { MDXComponents } 'mdx/types' export function useMDXComponents(components: MDXComponents): MDXComponents { return { ...components, } } Params components defining MDX Components, export function accepts single parameter, components . parameter instance MDXComponents . - key name HTML element override. - value component render instead. Good know: Remember pass components (i.e. ...components ) overrides. Version History | Version | Changes | |---|---| v13.1.2 | MDX Components added | Learn MDX Components helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata", "title": "File Conventions: Metadata Files | Next.js", "text": "Metadata Files API Reference section docs covers Metadata file conventions. File-based metadata defined adding special metadata files route segments. file convention defined using static file (e.g. opengraph-image.jpg ), dynamic variant uses code generate file (e.g. opengraph-image.js ). file defined, Next.js automatically serve file (with hashes production caching) update relevant head elements correct metadata, asset's URL, file type, image size. Good know: - Special Route Handlers like sitemap.ts ,opengraph-image.tsx , andicon.tsx , metadata files cached default.- using along middleware.ts , configure matcher exclude metadata files. favicon, icon, apple-icon API Reference Favicon, Icon Apple Icon file conventions. manifest.json API Reference manifest.json file. opengraph-image twitter-image API Reference Open Graph Image Twitter Image file conventions. robots.txt API Reference robots.txt file. sitemap.xml API Reference sitemap.xml file. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/app-icons", "title": "Metadata Files: favicon, icon, and apple-icon | Next.js", "text": "favicon, icon, apple-icon favicon , icon , apple-icon file conventions allow set icons application. useful adding app icons appear places like web browser tabs, phone home screens, search engine results. two ways set app icons: Image files (.ico, .jpg, .png) Use image file set app icon placing favicon , icon , apple-icon image file within /app directory. favicon image located top level app/ . Next.js evaluate file automatically add appropriate tags app's <head> element. | File convention | Supported file types | Valid locations | |---|---|---| favicon | .ico | app/ | icon | .ico , .jpg , .jpeg , .png , .svg | app/**/* | apple-icon | .jpg , .jpeg , .png | app/**/* | favicon Add favicon.ico image file root /app route segment. <link rel=\"icon\" href=\"/favicon.ico\" sizes=\"any\" /> icon Add icon.(ico|jpg|jpeg|png|svg) image file. <link rel=\"icon\" href=\"/icon?<generated>\" type=\"image/<generated>\" sizes=\"<generated>\" /> apple-icon Add apple-icon.(jpg|jpeg|png) image file. <link rel=\"apple-touch-icon\" href=\"/apple-icon?<generated>\" type=\"image/<generated>\" sizes=\"<generated>\" /> Good know: - set multiple icons adding number suffix file name. example, icon1.png ,icon2.png , etc. Numbered files sort lexically.- Favicons set root /app segment. need granularity, useicon .- appropriate <link> tags attributes asrel ,href ,type , andsizes determined icon type metadata evaluated file.- example, 32 32px .png file havetype=\"image/png\" andsizes=\"32x32\" attributes.sizes=\"any\" added icons extension is.svg image size file determined. details favicon handbook. Generate icons using code (.js, .ts, .tsx) addition using literal image files, programmatically generate icons using code. Generate app icon creating icon apple-icon route default exports function. | File convention | Supported file types | |---|---| icon | .js , .ts , .tsx | apple-icon | .js , .ts , .tsx | easiest way generate icon use ImageResponse API next/og . import { ImageResponse } 'next/og' // Image metadata export const size = { width: 32, height: 32, } export const contentType = 'image/png' // Image generation export default function Icon() { return new ImageResponse( ( // ImageResponse JSX element <div style={{ fontSize: 24, background: 'black', width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'white', }} > </div> ), // ImageResponse options { // convenience, re-use exported icons size metadata // config also set ImageResponse's width height. ...size, } ) } <link rel=\"icon\" href=\"/icon?<generated>\" type=\"image/png\" sizes=\"32x32\" /> Good know: - default, generated icons statically optimized (generated build time cached) unless use Dynamic APIs uncached data. - generate multiple icons file using generateImageMetadata .- cannot generate favicon icon. Useicon favicon.ico file instead.- App icons special Route Handlers cached default unless uses Dynamic API dynamic config option. Props default export function receives following props: params (optional) object containing dynamic route parameters object root segment segment icon apple-icon colocated in. export default function Icon({ params }: { params: { slug: string } }) { // ... } | Route | URL | params | |---|---|---| app/shop/icon.js | /shop | undefined | app/shop/[slug]/icon.js | /shop/1 | { slug: '1' } | app/shop/[tag]/[item]/icon.js | /shop/1/2 | { tag: '1', item: '2' } | Returns default export function return Blob | ArrayBuffer | TypedArray | DataView | ReadableStream | Response . Good know: ImageResponse satisfies return type. Config exports optionally configure icon's metadata exporting size contentType variables icon apple-icon route. | Option | Type | |---|---| size | { width: number; height: number } | contentType | string - image MIME type | size export const size = { width: 32, height: 32 } export default function Icon() {} <link rel=\"icon\" sizes=\"32x32\" /> contentType export const contentType = 'image/png' export default function Icon() {} <link rel=\"icon\" type=\"image/png\" /> Route Segment Config icon apple-icon specialized Route Handlers use route segment configuration options Pages Layouts. Version History | Version | Changes | |---|---| v13.3.0 | favicon icon apple-icon introduced | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/manifest", "title": "Metadata Files: manifest.json | Next.js", "text": "manifest.json Add generate manifest.(json|webmanifest) file matches Web Manifest Specification root app directory provide information web application browser. Static Manifest file app/manifest.json | app/manifest.webmanifest { \"name\": \"My Next.js Application\", \"short_name\": \"Next.js App\", \"description\": \"An application built Next.js\", \"start_url\": \"/\" // ... } Generate Manifest file Add manifest.js manifest.ts file returns Manifest object. Good know: manifest.js special Route Handlers cached default unless uses Dynamic API dynamic config option. app/manifest.ts import type { MetadataRoute } 'next' export default function manifest(): MetadataRoute.Manifest { return { name: 'Next.js App', short_name: 'Next.js App', description: 'Next.js App', start_url: '/', display: 'standalone', background_color: '#fff', theme_color: '#fff', icons: [ { src: '/favicon.ico', sizes: 'any', type: 'image/x-icon', }, ], } } Manifest Object manifest object contains extensive list options may updated due new web standards. information current options, refer MetadataRoute.Manifest type code editor using TypeScript see MDN docs. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image", "title": "Metadata Files: opengraph-image and twitter-image | Next.js", "text": "opengraph-image twitter-image opengraph-image twitter-image file conventions allow set Open Graph Twitter images route segment. useful setting images appear social networks messaging apps user shares link site. two ways set Open Graph Twitter images: Image files (.jpg, .png, .gif) Use image file set route segment's shared image placing opengraph-image twitter-image image file segment. Next.js evaluate file automatically add appropriate tags app's <head> element. | File convention | Supported file types | |---|---| opengraph-image | .jpg , .jpeg , .png , .gif | twitter-image | .jpg , .jpeg , .png , .gif | opengraph-image.alt | .txt | twitter-image.alt | .txt | Good know: twitter-image file size must exceed 5MB, theopengraph-image file size must exceed 8MB. image file size exceeds limits, build fail. opengraph-image Add opengraph-image.(jpg|jpeg|png|gif) image file route segment. <meta property=\"og:image\" content=\"<generated>\" /> <meta property=\"og:image:type\" content=\"<generated>\" /> <meta property=\"og:image:width\" content=\"<generated>\" /> <meta property=\"og:image:height\" content=\"<generated>\" /> twitter-image Add twitter-image.(jpg|jpeg|png|gif) image file route segment. <meta name=\"twitter:image\" content=\"<generated>\" /> <meta name=\"twitter:image:type\" content=\"<generated>\" /> <meta name=\"twitter:image:width\" content=\"<generated>\" /> <meta name=\"twitter:image:height\" content=\"<generated>\" /> opengraph-image.alt.txt Add accompanying opengraph-image.alt.txt file route segment opengraph-image.(jpg|jpeg|png|gif) image alt text. Acme <meta property=\"og:image:alt\" content=\"About Acme\" /> twitter-image.alt.txt Add accompanying twitter-image.alt.txt file route segment twitter-image.(jpg|jpeg|png|gif) image alt text. Acme <meta property=\"twitter:image:alt\" content=\"About Acme\" /> Generate images using code (.js, .ts, .tsx) addition using literal image files, programmatically generate images using code. Generate route segment's shared image creating opengraph-image twitter-image route default exports function. | File convention | Supported file types | |---|---| opengraph-image | .js , .ts , .tsx | twitter-image | .js , .ts , .tsx | Good know: - default, generated images statically optimized (generated build time cached) unless use Dynamic APIs uncached data. - generate multiple Images file using generateImageMetadata .opengraph-image.js andtwitter-image.js special Route Handlers cached default unless uses Dynamic API dynamic config option. easiest way generate image use ImageResponse API next/og . import { ImageResponse } 'next/og' import { readFile } 'node:fs/promises' import { join } 'node:path' // Image metadata export const alt = 'About Acme' export const size = { width: 1200, height: 630, } export const contentType = 'image/png' // Image generation export default async function Image() { // Font loading, process.cwd() Next.js project directory const interSemiBold = await readFile( join(process.cwd(), 'assets/Inter-SemiBold.ttf') ) return new ImageResponse( ( // ImageResponse JSX element <div style={{ fontSize: 128, background: 'white', width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', }} > Acme </div> ), // ImageResponse options { // convenience, re-use exported opengraph-image // size config also set ImageResponse's width height. ...size, fonts: [ { name: 'Inter', data: interSemiBold, style: 'normal', weight: 400, }, ], } ) } <meta property=\"og:image\" content=\"<generated>\" /> <meta property=\"og:image:alt\" content=\"About Acme\" /> <meta property=\"og:image:type\" content=\"image/png\" /> <meta property=\"og:image:width\" content=\"1200\" /> <meta property=\"og:image:height\" content=\"630\" /> Props default export function receives following props: params (optional) object containing dynamic route parameters object root segment segment opengraph-image twitter-image colocated in. export default function Image({ params }: { params: { slug: string } }) { // ... } | Route | URL | params | |---|---|---| app/shop/opengraph-image.js | /shop | undefined | app/shop/[slug]/opengraph-image.js | /shop/1 | { slug: '1' } | app/shop/[tag]/[item]/opengraph-image.js | /shop/1/2 | { tag: '1', item: '2' } | Returns default export function return Blob | ArrayBuffer | TypedArray | DataView | ReadableStream | Response . Good know: ImageResponse satisfies return type. Config exports optionally configure image's metadata exporting alt , size , contentType variables opengraph-image twitter-image route. | Option | Type | |---|---| alt | string | size | { width: number; height: number } | contentType | string - image MIME type | alt export const alt = 'My images alt text' export default function Image() {} <meta property=\"og:image:alt\" content=\"My images alt text\" /> size export const size = { width: 1200, height: 630 } export default function Image() {} <meta property=\"og:image:width\" content=\"1200\" /> <meta property=\"og:image:height\" content=\"630\" /> contentType export const contentType = 'image/png' export default function Image() {} <meta property=\"og:image:type\" content=\"image/png\" /> Route Segment Config opengraph-image twitter-image specialized Route Handlers use route segment configuration options Pages Layouts. Examples Using external data example uses params object external data generate image. Good know: default, generated image statically optimized. configure individual fetch options route segments options change behavior. import { ImageResponse } 'next/og' export const alt = 'About Acme' export const size = { width: 1200, height: 630, } export const contentType = 'image/png' export default async function Image({ params }: { params: { slug: string } }) { const post = await fetch(`https://.../posts/${params.slug}`).then((res) => res.json() ) return new ImageResponse( ( <div style={{ fontSize: 48, background: 'white', width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', }} > {post.title} </div> ), { ...size, } ) } Using Node.js runtime local assets example uses Node.js runtime fetch local image file system passes ArrayBuffer src attribute <img> element. local asset placed relative root project, rather location example source file. import { ImageResponse } 'next/og' import { join } 'node:path' import { readFile } 'node:fs/promises' export default async function Image() { const logoData = await readFile(join(process.cwd(), 'logo.png')) const logoSrc = Uint8Array.from(logoData).buffer return new ImageResponse( ( <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', }} > <img src={logoSrc} height=\"100\" /> </div> ) ) } Version History | Version | Changes | |---|---| v13.3.0 | opengraph-image twitter-image introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/robots", "title": "Metadata Files: robots.txt | Next.js", "text": "robots.txt Add generate robots.txt file matches Robots Exclusion Standard root app directory tell search engine crawlers URLs access site. Static robots.txt app/robots.txt User-Agent: * Allow: / Disallow: /private/ Sitemap: https://acme.com/sitemap.xml Generate Robots file Add robots.js robots.ts file returns Robots object. Good know: robots.js special Route Handlers cached default unless uses Dynamic API dynamic config option. app/robots.ts import type { MetadataRoute } 'next' export default function robots(): MetadataRoute.Robots { return { rules: { userAgent: '*', allow: '/', disallow: '/private/', }, sitemap: 'https://acme.com/sitemap.xml', } } Output: User-Agent: * Allow: / Disallow: /private/ Sitemap: https://acme.com/sitemap.xml Customizing specific user agents customise individual search engine bots crawl site passing array user agents rules property. example: app/robots.ts import type { MetadataRoute } 'next' export default function robots(): MetadataRoute.Robots { return { rules: [ { userAgent: 'Googlebot', allow: ['/'], disallow: '/private/', }, { userAgent: ['Applebot', 'Bingbot'], disallow: ['/'], }, ], sitemap: 'https://acme.com/sitemap.xml', } } Output: User-Agent: Googlebot Allow: / Disallow: /private/ User-Agent: Applebot Disallow: / User-Agent: Bingbot Disallow: / Sitemap: https://acme.com/sitemap.xml Robots object type Robots = { rules: | { userAgent?: string | string[] allow?: string | string[] disallow?: string | string[] crawlDelay?: number } | Array<{ userAgent: string | string[] allow?: string | string[] disallow?: string | string[] crawlDelay?: number }> sitemap?: string | string[] host?: string } Version History | Version | Changes | |---|---| v13.3.0 | robots introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/sitemap", "title": "Metadata Files: sitemap.xml | Next.js", "text": "sitemap.xml sitemap.(xml|js|ts) special file matches Sitemaps XML format help search engine crawlers index site efficiently. Sitemap files (.xml) smaller applications, create sitemap.xml file place root app directory. <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"> <url> <loc>https://acme.com</loc> <lastmod>2023-04-06T15:02:24.021Z</lastmod> <changefreq>yearly</changefreq> <priority>1</priority> </url> <url> <loc>https://acme.com/about</loc> <lastmod>2023-04-06T15:02:24.021Z</lastmod> <changefreq>monthly</changefreq> <priority>0.8</priority> </url> <url> <loc>https://acme.com/blog</loc> <lastmod>2023-04-06T15:02:24.021Z</lastmod> <changefreq>weekly</changefreq> <priority>0.5</priority> </url> </urlset> Generating sitemap using code (.js, .ts) use sitemap.(js|ts) file convention programmatically generate sitemap exporting default function returns array URLs. using TypeScript, Sitemap type available. Good know: sitemap.js special Route Handler cached default unless uses Dynamic API dynamic config option. import type { MetadataRoute } 'next' export default function sitemap(): MetadataRoute.Sitemap { return [ { url: 'https://acme.com', lastModified: new Date(), changeFrequency: 'yearly', priority: 1, }, { url: 'https://acme.com/about', lastModified: new Date(), changeFrequency: 'monthly', priority: 0.8, }, { url: 'https://acme.com/blog', lastModified: new Date(), changeFrequency: 'weekly', priority: 0.5, }, ] } Output: <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"> <url> <loc>https://acme.com</loc> <lastmod>2023-04-06T15:02:24.021Z</lastmod> <changefreq>yearly</changefreq> <priority>1</priority> </url> <url> <loc>https://acme.com/about</loc> <lastmod>2023-04-06T15:02:24.021Z</lastmod> <changefreq>monthly</changefreq> <priority>0.8</priority> </url> <url> <loc>https://acme.com/blog</loc> <lastmod>2023-04-06T15:02:24.021Z</lastmod> <changefreq>weekly</changefreq> <priority>0.5</priority> </url> </urlset> Image Sitemaps use images property create image sitemaps. Learn details Google Developer Docs. import type { MetadataRoute } 'next' export default function sitemap(): MetadataRoute.Sitemap { return [ { url: 'https://example.com', lastModified: '2021-01-01', changeFrequency: 'weekly', priority: 0.5, images: ['https://example.com/image.jpg'], }, ] } Output: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\" > <url> <loc>https://example.com</loc> <image:image> <image:loc>https://example.com/image.jpg</image:loc> </image:image> <lastmod>2021-01-01</lastmod> <changefreq>weekly</changefreq> <priority>0.5</priority> </url> </urlset> Video Sitemaps use videos property create video sitemaps. Learn details Google Developer Docs. import type { MetadataRoute } 'next' export default function sitemap(): MetadataRoute.Sitemap { return [ { url: 'https://example.com', lastModified: '2021-01-01', changeFrequency: 'weekly', priority: 0.5, videos: [ { title: 'example', thumbnail_loc: 'https://example.com/image.jpg', description: 'this description', }, ], }, ] } Output: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\" > <url> <loc>https://example.com</loc> <video:video> <video:title>example</video:title> <video:thumbnail_loc>https://example.com/image.jpg</video:thumbnail_loc> <video:description>this description</video:description> </video:video> <lastmod>2021-01-01</lastmod> <changefreq>weekly</changefreq> <priority>0.5</priority> </url> </urlset> Generate localized Sitemap import type { MetadataRoute } 'next' export default function sitemap(): MetadataRoute.Sitemap { return [ { url: 'https://acme.com', lastModified: new Date(), alternates: { languages: { es: 'https://acme.com/es', de: 'https://acme.com/de', }, }, }, { url: 'https://acme.com/about', lastModified: new Date(), alternates: { languages: { es: 'https://acme.com/es/about', de: 'https://acme.com/de/about', }, }, }, { url: 'https://acme.com/blog', lastModified: new Date(), alternates: { languages: { es: 'https://acme.com/es/blog', de: 'https://acme.com/de/blog', }, }, }, ] } Output: <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"> <url> <loc>https://acme.com</loc> <xhtml:link rel=\"alternate\" hreflang=\"es\" href=\"https://acme.com/es\"/> <xhtml:link rel=\"alternate\" hreflang=\"de\" href=\"https://acme.com/de\"/> <lastmod>2023-04-06T15:02:24.021Z</lastmod> </url> <url> <loc>https://acme.com/about</loc> <xhtml:link rel=\"alternate\" hreflang=\"es\" href=\"https://acme.com/es/about\"/> <xhtml:link rel=\"alternate\" hreflang=\"de\" href=\"https://acme.com/de/about\"/> <lastmod>2023-04-06T15:02:24.021Z</lastmod> </url> <url> <loc>https://acme.com/blog</loc> <xhtml:link rel=\"alternate\" hreflang=\"es\" href=\"https://acme.com/es/blog\"/> <xhtml:link rel=\"alternate\" hreflang=\"de\" href=\"https://acme.com/de/blog\"/> <lastmod>2023-04-06T15:02:24.021Z</lastmod> </url> </urlset> Generating multiple sitemaps single sitemap work applications. large web applications, may need split sitemap multiple files. two ways create multiple sitemaps: - nesting sitemap.(xml|js|ts) inside multiple route segments e.g.app/sitemap.xml andapp/products/sitemap.xml . - using generateSitemaps function. example, split sitemap using generateSitemaps , return array objects sitemap id . Then, use id generate unique sitemaps. import type { MetadataRoute } 'next' import { BASE_URL } '@/app/lib/constants' export async function generateSitemaps() { // Fetch total number products calculate number sitemaps needed return [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }] } export default async function sitemap({ id, }: { id: number }): Promise<MetadataRoute.Sitemap> { // Google's limit 50,000 URLs per sitemap const start = id * 50000 const end = start + 50000 const products = await getProducts( `SELECT id, date products id ${start} ${end}` ) return products.map((product) => ({ url: `${BASE_URL}/product/${product.id}`, lastModified: product.date, })) } generated sitemaps available /.../sitemap/[id] . example, /product/sitemap/1.xml . See generateSitemaps API reference information. Returns default function exported sitemap.(xml|ts|js) return array objects following properties: type Sitemap = Array<{ url: string lastModified?: string | Date changeFrequency?: | 'always' | 'hourly' | 'daily' | 'weekly' | 'monthly' | 'yearly' | 'never' priority?: number alternates?: { languages?: Languages<string> } }> Version History | Version | Changes | |---|---| v14.2.0 | Add localizations support. | v13.4.14 | Add changeFrequency priority attributes sitemaps. | v13.3.0 | sitemap introduced. | Next Steps helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/middleware", "title": "File Conventions: middleware.js | Next.js", "text": "middleware.js middleware.js|ts file used write Middleware run code server request completed. Then, based incoming request, modify response rewriting, redirecting, modifying request response headers, responding directly. Middleware executes routes rendered. particularly useful implementing custom server-side logic like authentication, logging, handling redirects. Use file middleware.ts (or .js) root project define Middleware. example, level app pages , inside src applicable. import { NextResponse, NextRequest } 'next/server' // function marked `async` using `await` inside export function middleware(request: NextRequest) { return NextResponse.redirect(new URL('/home', request.url)) } export const config = { matcher: '/about/:path*', } Exports Middleware function file must export single function, either default export named middleware . Note multiple middleware file supported. // Example default export export default function middleware(request) { // Middleware logic } Config object (optional) Optionally, config object exported alongside Middleware function. object includes matcher specify paths Middleware applies. Matcher matcher option allows target specific paths Middleware run on. specify paths several ways: - single path: Directly use string define path, like '/about' . - multiple paths: Use array list multiple paths, matcher: ['/about', '/contact'] , applies Middleware both/about and/contact . Additionally, matcher supports complex path specifications regular expressions, matcher: ['/((?!api|_next/static|_next/image|.*\\\\.png$).*)'] , enabling precise control paths include exclude. matcher option also accepts array objects following keys: source : path pattern used match request paths. string direct path matching pattern complex matching.regexp (optional): regular expression string fine-tunes matching based source. provides additional control paths included excluded.locale (optional): boolean that, set tofalse , ignores locale-based routing path matching.has (optional): Specifies conditions based presence specific request elements headers, query parameters, cookies.missing (optional): Focuses conditions certain request elements absent, like missing headers cookies. export const config = { matcher: [ { source: '/api/*', regexp: '^/api/(.*)', locale: false, has: [ { type: 'header', key: 'Authorization', value: 'Bearer Token' }, { type: 'query', key: 'userId', value: '123' }, ], missing: [{ type: 'cookie', key: 'session', value: 'active' }], }, ], } Params request defining Middleware, default export function accepts single parameter, request . parameter instance NextRequest , represents incoming HTTP request. import type { NextRequest } 'next/server' export function middleware(request: NextRequest) { // Middleware logic goes } Good know: NextRequest type represents incoming HTTP requests Next.js Middleware, whereasNextResponse class used manipulate send back HTTP responses. NextResponse Middleware use NextResponse object extends Web Response API. returning NextResponse object, directly manipulate cookies, set headers, implement redirects, rewrite paths. Good know: redirects, also use Response.redirect instead ofNextResponse.redirect . Runtime Middleware supports Edge runtime. Node.js runtime cannot used. Version History | Version | Changes | |---|---| v13.1.0 | Advanced Middleware flags added | v13.0.0 | Middleware modify request headers, response headers, send responses | v12.2.0 | Middleware stable, please see upgrade guide | v12.0.9 | Enforce absolute URLs Edge Runtime (PR) | v12.0.0 | Middleware (Beta) added | Learn Middleware helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/not-found", "title": "File Conventions: not-found.js | Next.js", "text": "not-found.js not-found file used render UI notFound function thrown within route segment. Along serving custom UI, Next.js return 200 HTTP status code streamed responses, 404 non-streamed responses. import Link 'next/link' export default function NotFound() { return ( <div> <h2>Not Found</h2> <p>Could find requested resource</p> <Link href=\"/\">Return Home</Link> </div> ) } Reference Props not-found.js components accept props. Good know: addition catching expected notFound() errors, rootapp/not-found.js file also handles unmatched URLs whole application. means users visit URL handled app shown UI exported theapp/not-found.js file. Examples Data Fetching default, not-found Server Component. mark async fetch display data: import Link 'next/link' import { headers } 'next/headers' export default async function NotFound() { const headersList = await headers() const domain = headersList.get('host') const data = await getSiteData(domain) return ( <div> <h2>Not Found: {data.name}</h2> <p>Could find requested resource</p> <p> View <Link href=\"/blog\">all posts</Link> </p> </div> ) } need use Client Component hooks like usePathname display content based path, must fetch data client-side instead. Version History | Version | Changes | |---|---| v13.3.0 | Root app/not-found handles global unmatched URLs. | v13.0.0 | not-found introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/page", "title": "File Conventions: page.js | Next.js", "text": "page.js page file allows define UI unique route. create page default exporting component file: app/blog/[slug]/page.tsx export default function Page({ params, searchParams, }: { params: Promise<{ slug: string }> searchParams: Promise<{ [key: string]: string | string[] | undefined }> }) { return <h1>My Page</h1> } Good know - .js ,.jsx , or.tsx file extensions used forpage . - page always leaf route subtree. - page file required make route segment publicly accessible. - Pages Server Components default, set Client Component. Reference Props params (optional) promise resolves object containing dynamic route parameters root segment page. app/shop/[slug]/page.tsx export default async function Page({ params, }: { params: Promise<{ slug: string }> }) { const slug = (await params).slug } | Example Route | URL | params | |---|---|---| app/shop/[slug]/page.js | /shop/1 | Promise<{ slug: '1' }> | app/shop/[category]/[item]/page.js | /shop/1/2 | Promise<{ category: '1', item: '2' }> | app/shop/[...slug]/page.js | /shop/1/2 | Promise<{ slug: ['1', '2'] }> | - Since params prop promise. must useasync/await React'suse function access values.- version 14 earlier, params synchronous prop. help backwards compatibility, still access synchronously Next.js 15, behavior deprecated future. - version 14 earlier, searchParams (optional) promise resolves object containing search parameters current URL. example: app/shop/page.tsx export default async function Page({ searchParams, }: { searchParams: Promise<{ [key: string]: string | string[] | undefined }> }) { const filters = (await searchParams).filters } | Example URL | searchParams | |---|---| /shop?a=1 | Promise<{ a: '1' }> | /shop?a=1&b=2 | Promise<{ a: '1', b: '2' }> | /shop?a=1&a=2 | Promise<{ a: ['1', '2'] }> | - Since searchParams prop promise. must useasync/await React'suse function access values.- version 14 earlier, searchParams synchronous prop. help backwards compatibility, still access synchronously Next.js 15, behavior deprecated future. - version 14 earlier, searchParams Dynamic API whose values cannot known ahead time. Using opt page dynamic rendering request time.searchParams plain JavaScript object, aURLSearchParams instance. Examples Displaying content based params Using dynamic route segments, display fetch specific content page based params prop. app/blog/[slug]/page.tsx export default async function Page({ params, }: { params: Promise<{ slug: string }> }) { const { slug } = await params return <h1>Blog Post: {slug}</h1> } Handling filtering searchParams use searchParams prop handle filtering, pagination, sorting based query string URL. app/shop/page.tsx export default async function Page({ searchParams, }: { searchParams: Promise<{ [key: string]: string | string[] | undefined }> }) { const { page = '1', sort = 'asc', query = '' } = await searchParams return ( <div> <h1>Product Listing</h1> <p>Search query: {query}</p> <p>Current page: {page}</p> <p>Sort order: {sort}</p> </div> ) } Reading searchParams params Client Components use searchParams params Client Component (which cannot async ), use React's use function read promise: app/page.tsx 'use client' import { use } 'react' export default function Page({ params, searchParams, }: { params: Promise<{ slug: string }> searchParams: Promise<{ [key: string]: string | string[] | undefined }> }) { const { slug } = use(params) const { query } = use(searchParams) } Version History | Version | Changes | |---|---| v15.0.0-RC | params searchParams promises. codemod available. | v13.0.0 | page introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/parallel-routes", "title": "File-system conventions: Parallel Routes | Next.js", "text": "Parallel Routes Parallel Routes allows simultaneously conditionally render one pages within layout. useful highly dynamic sections app, dashboards feeds social sites. example, considering dashboard, use parallel routes simultaneously render team analytics pages: Convention Slots Parallel routes created using named slots. Slots defined @folder convention. example, following file structure defines two slots: @analytics @team : Slots passed props shared parent layout. example above, component app/layout.js accepts @analytics @team slots props, render parallel alongside children prop: export default function Layout({ children, team, analytics, }: { children: React.ReactNode analytics: React.ReactNode team: React.ReactNode }) { return ( <> {children} {team} {analytics} </> ) } However, slots route segments affect URL structure. example, /@analytics/views , URL /views since @analytics slot. Slots combined regular Page component form final page associated route segment. this, cannot separate static dynamic slots route segment level. one slot dynamic, slots level must dynamic. Good know: - children prop implicit slot need mapped folder. meansapp/page.js equivalent toapp/@children/page.js . default.js define default.js file render fallback unmatched slots initial load full-page reload. Consider following folder structure. @team slot /settings page, @analytics not. navigating /settings , @team slot render /settings page maintaining currently active page @analytics slot. refresh, Next.js render default.js @analytics . default.js exist, 404 rendered instead. Additionally, since children implicit slot, also need create default.js file render fallback children Next.js cannot recover active state parent page. Behavior default, Next.js keeps track active state (or subpage) slot. However, content rendered within slot depend type navigation: - Soft Navigation: client-side navigation, Next.js perform partial render, changing subpage within slot, maintaining slot's active subpages, even match current URL. - Hard Navigation: full-page load (browser refresh), Next.js cannot determine active state slots match current URL. Instead, render default.js file unmatched slots, or404 ifdefault.js exist. Good know: - 404 unmatched routes helps ensure accidentally render parallel route page intended for. Examples useSelectedLayoutSegment(s) useSelectedLayoutSegment useSelectedLayoutSegments accept parallelRoutesKey parameter, allows read active route segment within slot. 'use client' import { useSelectedLayoutSegment } 'next/navigation' export default function Layout({ auth }: { auth: React.ReactNode }) { const loginSegment = useSelectedLayoutSegment('auth') // ... } user navigates app/@auth/login (or /login URL bar), loginSegment equal string \"login\" . Conditional Routes use Parallel Routes conditionally render routes based certain conditions, user role. example, render different dashboard page /admin /user roles: import { checkUserRole } '@/lib/auth' export default function Layout({ user, admin, }: { user: React.ReactNode admin: React.ReactNode }) { const role = checkUserRole() return role === 'admin' ? admin : user } Tab Groups add layout inside slot allow users navigate slot independently. useful creating tabs. example, @analytics slot two subpages: /page-views /visitors . Within @analytics , create layout file share tabs two pages: import Link 'next/link' export default function Layout({ children }: { children: React.ReactNode }) { return ( <> <nav> <Link href=\"/page-views\">Page Views</Link> <Link href=\"/visitors\">Visitors</Link> </nav> <div>{children}</div> </> ) } Modals Parallel Routes used together Intercepting Routes create modals support deep linking. allows solve common challenges building modals, as: - Making modal content shareable URL. - Preserving context page refreshed, instead closing modal. - Closing modal backwards navigation rather going previous route. - Reopening modal forwards navigation. Consider following UI pattern, user open login modal layout using client-side navigation, access separate /login page: implement pattern, start creating /login route renders main login page. import { Login } '@/app/ui/login' export default function Page() { return <Login /> } Then, inside @auth slot, add default.js file returns null . ensures modal rendered active. export default function Default() { return null } Inside @auth slot, intercept /login route updating /(.)login folder. Import <Modal> component children /(.)login/page.tsx file: import { Modal } '@/app/ui/modal' import { Login } '@/app/ui/login' export default function Page() { return ( <Modal> <Login /> </Modal> ) } Good know: - convention used intercept route, e.g. (.) , depends file-system structure. See Intercepting Routes convention.- separating <Modal> functionality modal content (<Login> ), ensure content inside modal, e.g. forms, Server Components. See Interleaving Client Server Components information. Opening modal Now, leverage Next.js router open close modal. ensures URL correctly updated modal open, navigating backwards forwards. open modal, pass @auth slot prop parent layout render alongside children prop. import Link 'next/link' export default function Layout({ auth, children, }: { auth: React.ReactNode children: React.ReactNode }) { return ( <> <nav> <Link href=\"/login\">Open modal</Link> </nav> <div>{auth}</div> <div>{children}</div> </> ) } user clicks <Link> , modal open instead navigating /login page. However, refresh initial load, navigating /login take user main login page. Closing modal close modal calling router.back() using Link component. 'use client' import { useRouter } 'next/navigation' export function Modal({ children }: { children: React.ReactNode }) { const router = useRouter() return ( <> <button onClick={() => { router.back() }} > Close modal </button> <div>{children}</div> </> ) } using Link component navigate away page render @auth slot anymore, need make sure parallel route matches component returns null . example, navigating back root page, create @auth/page.tsx component: import Link 'next/link' export function Modal({ children }: { children: React.ReactNode }) { return ( <> <Link href=\"/\">Close modal</Link> <div>{children}</div> </> ) } export default function Page() { return null } navigating page (such /foo , /foo/bar , etc), use catch-all slot: export default function CatchAll() { return null } Good know: - use catch-all route @auth slot close modal parallel routes behave(#behavior). Since client-side navigations route longer match slot remain visible, need match slot route returnsnull close modal.- examples could include opening photo modal gallery also dedicated /photo/[id] page, opening shopping cart side modal.- View example modals Intercepted Parallel Routes. Loading Error UI Parallel Routes streamed independently, allowing define independent error loading states route: See Loading UI Error Handling documentation information. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/public-folder", "title": "File-system conventions: public | Next.js", "text": "public Folder Next.js serve static files, like images, folder called public root directory. Files inside public referenced code starting base URL (/ ). example, file public/avatars/me.png viewed visiting /avatars/me.png path. code display image might look like: avatar.js import Image 'next/image' export function Avatar({ id, alt }) { return <Image src={`/avatars/${id}.png`} alt={alt} width=\"64\" height=\"64\" /> } export function AvatarOfMe() { return <Avatar id=\"me\" alt=\"A portrait me\" /> } Caching Next.js cannot safely cache assets public folder may change. default caching headers applied are: Cache-Control: public, max-age=0 Robots, Favicons, others static metadata files, robots.txt , favicon.ico , etc, use special metadata files inside app folder. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/route", "title": "File Conventions: route.js | Next.js", "text": "route.js Route Handlers allow create custom request handlers given route using Web Request Response APIs. route.ts export async function GET() { return Response.json({ message: 'Hello World' }) } Reference HTTP Methods route file allows create custom request handlers given route. following HTTP methods supported: GET , POST , PUT , PATCH , DELETE , HEAD , OPTIONS . route.ts export async function GET(request: Request) {} export async function HEAD(request: Request) {} export async function POST(request: Request) {} export async function PUT(request: Request) {} export async function DELETE(request: Request) {} export async function PATCH(request: Request) {} // `OPTIONS` defined, Next.js automatically implement `OPTIONS` set appropriate Response `Allow` header depending methods defined Route Handler. export async function OPTIONS(request: Request) {} Parameters request (optional) request object NextRequest object, extension Web Request API. NextRequest gives control incoming request, including easily accessing cookies extended, parsed, URL object nextUrl . route.ts import type { NextRequest } 'next/server' export async function GET(request: NextRequest) { const url = request.nextUrl } context (optional) params : promise resolves object containing dynamic route parameters current route. app/dashboard/[team]/route.ts export async function GET( request: Request, { params }: { params: Promise<{ team: string }> } ) { const team = (await params).team } | Example | URL | params | |---|---|---| app/dashboard/[team]/route.js | /dashboard/1 | Promise<{ team: '1' }> | app/shop/[tag]/[item]/route.js | /shop/1/2 | Promise<{ tag: '1', item: '2' }> | app/blog/[...slug]/route.js | /blog/1/2 | Promise<{ slug: ['1', '2'] }> | Examples Handling cookies route.ts import { cookies } 'next/headers' export async function GET(request: NextRequest) { const cookieStore = await cookies() const = cookieStore.get('a') const b = cookieStore.set('b', '1') const c = cookieStore.delete('c') } Version History | Version | Changes | |---|---| v15.0.0-RC | context.params promise. codemod available | v15.0.0-RC | default caching GET handlers changed static dynamic | v13.2.0 | Route Handlers introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/src-folder", "title": "File-system conventions: src | Next.js", "text": "src Folder alternative special Next.js app pages directories root project, Next.js also supports common pattern placing application code src folder. separates application code project configuration files mostly live root project, preferred individuals teams. use src folder, move app Router folder pages Router folder src/app src/pages respectively. Good know: - /public directory remain root project.- Config files like package.json ,next.config.js andtsconfig.json remain root project..env.* files remain root project.src/app orsrc/pages ignored ifapp orpages present root directory.- using src , probably also move application folders as/components or/lib .- using Middleware, ensure placed inside src folder.- using Tailwind CSS, need add /src prefix thetailwind.config.js file content section.- using TypeScript paths imports @/* , update thepaths object intsconfig.json includesrc/ . helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/template", "title": "File Conventions: template.js | Next.js", "text": "template.js template file similar layout wraps layout page. Unlike layouts persist across routes maintain state, templates given unique key, meaning children Client Components reset state navigation. app/template.tsx export default function Template({ children }: { children: React.ReactNode }) { return <div>{children}</div> } less common, might choose use template layout want: - Features rely useEffect (e.g logging page views) anduseState (e.g per-page feedback form). - change default framework behavior. example, Suspense Boundaries inside layouts show fallback first time Layout loaded switching pages. templates, fallback shown navigation. Props children (required) Template accepts children prop. example: Output <Layout> {/* Note template automatically given unique key. */} <Template key={routeParam}>{children}</Template> </Layout> Good know: - default, template Server Component, also used Client Component the\"use client\" directive.- user navigates routes share template , new instance component mounted, DOM elements recreated, state preserved Client Components, effects re-synchronized. Version History | Version | Changes | |---|---| v13.0.0 | template introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized", "title": "File Conventions: unauthorized.js | Next.js", "text": "unauthorized.js feature currently experimental subject change, recommended production. Try share feedback GitHub. unauthorized file used render UI unauthorized function invoked authentication. Along allowing customize UI, Next.js return 401 status code. app/unauthorized.tsx import Login '@/app/components/Login' export default function Unauthorized() { return ( <main> <h1>401 - Unauthorized</h1> <p>Please log access page.</p> <Login /> </main> ) } Reference Props unauthorized.js components accept props. Examples Displaying login UI unauthenticated users use unauthorized function render unauthorized.js file login UI. app/dashboard/page.tsx import { verifySession } '@/app/lib/dal' import { unauthorized } 'next/navigation' export default async function DashboardPage() { const session = await verifySession() (!session) { unauthorized() } return <div>Dashboard</div> } app/unauthorized.tsx import Login '@/app/components/Login' export default function UnauthorizedPage() { return ( <main> <h1>401 - Unauthorized</h1> <p>Please log access page.</p> <Login /> </main> ) } Version History | Version | Changes | |---|---| v15.1.0 | unauthorized.js introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions", "title": "API Reference: Functions | Next.js", "text": "Functions API Reference function. cacheLife Learn use cacheLife function set cache expiration time cached function component. cacheTag Learn use cacheTag function manage cache invalidation Next.js application. connection API Reference connection function. cookies API Reference cookies function. draftMode API Reference draftMode function. fetch API reference extended fetch function. forbidden API Reference forbidden function. generateImageMetadata Learn generate multiple images single Metadata API special file. generateMetadata Learn add Metadata Next.js application improved search engine optimization (SEO) web shareability. generateSitemaps Learn use generateSiteMaps function create multiple sitemaps application. generateStaticParams API reference generateStaticParams function. generateViewport API Reference generateViewport function. headers API reference headers function. ImageResponse API Reference ImageResponse constructor. NextRequest API Reference NextRequest. NextResponse API Reference NextResponse. notFound API Reference notFound function. permanentRedirect API Reference permanentRedirect function. redirect API Reference redirect function. revalidatePath API Reference revalidatePath function. revalidateTag API Reference revalidateTag function. unauthorized API Reference unauthorized function. unstable_cache API Reference unstable_cache function. unstable_noStore API Reference unstable_noStore function. unstable_rethrow API Reference unstable_rethrow function. useParams API Reference useParams hook. usePathname API Reference usePathname hook. useReportWebVitals API Reference useReportWebVitals function. useRouter API reference useRouter hook. useSearchParams API Reference useSearchParams hook. useSelectedLayoutSegment API Reference useSelectedLayoutSegment hook. useSelectedLayoutSegments API Reference useSelectedLayoutSegments hook. userAgent userAgent helper extends Web Request API additional properties methods interact user agent object request. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/after", "title": "Functions: after | Next.js", "text": "allows schedule work executed response (or prerender) finished. useful tasks side effects block response, logging analytics. used Server Components (including generateMetadata ), Server Actions, Route Handlers, Middleware. function accepts callback executed response (or prerender) finished: import { } 'next/server' // Custom logging function import { log } '@/app/utils' export default function Layout({ children }: { children: React.ReactNode }) { after(() => { // Execute layout rendered sent user log() }) return <>{children}</> } Good know: Dynamic API calling cause route become dynamic. used within static page, callback execute build time, whenever page revalidated. Reference Parameters - callback function executed response (or prerender) finished. Duration run platform's default configured max duration route. platform supports it, configure timeout limit using maxDuration route segment config. Good know executed even response complete successfully. Including error thrown whennotFound orredirect called.- use React cache deduplicate functions called insideafter . nested inside otherafter calls, example, create utility functions wrapafter calls add additional functionality. Alternatives use case process secondary tasks without blocking primary response. similar using platform's waitUntil() removing await promise, following differences: waitUntil() : accepts promise enqueues task executed lifecycle request, whereasafter accepts callback executed response finished.- Removing await : starts executing response, uses resources. also reliable serverless environments function stops computation immediately response sent, potentially interrupting task. recommend using designed consider Next.js APIs contexts. Examples request APIs use request APIs cookies headers inside Server Actions Route Handlers. useful logging activity mutation. example: import { } 'next/server' import { cookies, headers } 'next/headers' import { logUserAction } '@/app/utils' export async function POST(request: Request) { // Perform mutation // ... // Log user activity analytics after(async () => { const userAgent = (await headers().get('user-agent')) || 'unknown' const sessionCookie = (await cookies().get('session-id'))?.value || 'anonymous' logUserAction({ sessionCookie, userAgent }) }) return new Response(JSON.stringify({ status: 'success' }), { status: 200, headers: { 'Content-Type': 'application/json' }, }) } However, cannot use request APIs inside Server Components. Next.js needs know part tree access request APIs support Partial Prerendering, runs React's rendering lifecycle. | Version History | Description | |---|---| v15.1.0 | became stable. | v15.0.0-rc | unstable_after introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/cacheLife", "title": "Functions: cacheLife | Next.js", "text": "cacheLife cacheLife function used set cache lifetime function component. used alongside use cache directive, within scope function component. Usage use cacheLife , enable dynamicIO flag next.config.js file: import type { NextConfig } 'next' const nextConfig: NextConfig = { experimental: { dynamicIO: true, }, } export default nextConfig Then, import invoke cacheLife function within scope function component: 'use cache' import { unstable_cacheLife cacheLife } 'next/cache' export default async function Page() { cacheLife('hours') return <div>Page</div> } Reference Default cache profiles Next.js provides set named cache profiles modeled various timescales. specify cache profile cacheLife function alongside use cache directive, Next.js automatically apply \u201cdefault\u201d cache profile. However, recommend always adding cache profile using use cache directive explicitly define caching behavior. | Profile | Stale | Revalidate | Expire | Description | |---|---|---|---|---| default | undefined | 15 minutes | INFINITE_CACHE | Default profile, suitable content need frequent updates | seconds | undefined | 1 second | 1 minute | rapidly changing content requiring near real-time updates | minutes | 5 minutes | 1 minute | 1 hour | content updates frequently within hour | hours | 5 minutes | 1 hour | 1 day | content updates daily slightly stale | days | 5 minutes | 1 day | 1 week | content updates weekly day old | weeks | 5 minutes | 1 week | 1 month | content updates monthly week old | max | 5 minutes | 1 month | INFINITE_CACHE | stable content rarely needs updating | string values used reference cache profiles carry inherent meaning; instead serve semantic labels. allows better understand manage cached content within codebase. Custom cache profiles configure custom cache profiles adding cacheLife option next.config.ts file. Cache profiles objects contain following properties: | Property | Value | Description | Requirement | |---|---|---|---| stale | number | Duration client cache value without checking server. | Optional | revalidate | number | Frequency cache refresh server; stale values may served revalidating. | Optional | expire | number | Maximum duration value remain stale switching dynamic fetching; must longer revalidate . | Optional - Must longer revalidate | \"stale\" property differs staleTimes setting specifically controls client-side router caching. staleTimes global setting affects instances dynamic static data, cacheLife configuration allows define \"stale\" times per-function per-route basis. Good know: \u201cstale\u201d property set Cache-control: max-age header. instead controls client-side router cache. Examples Defining reusable cache profiles create reusable cache profile defining next.config.ts file. Choose name suits use case set values stale , revalidate , expire properties. create many custom cache profiles needed. profile referenced name string value passed cacheLife function. import type { NextConfig } 'next' const nextConfig: NextConfig = { experimental: { dynamicIO: true, cacheLife: { biweekly: { stale: 60 * 60 * 24 * 14, // 14 days revalidate: 60 * 60 * 24, // 1 day expire: 60 * 60 * 24 * 14, // 14 days }, }, }, } module.exports = nextConfig example caches 14 days, checks updates daily, expires cache 14 days. reference profile throughout application name: 'use cache' import { unstable_cacheLife cacheLife } 'next/cache' export default async function Page() { cacheLife('biweekly') return <div>Page</div> } Overriding default cache profiles default cache profiles provide useful way think fresh stale given part cacheable output be, may prefer different named profiles better align applications caching strategies. override default named cache profiles creating new configuration name defaults. example shows override default \u201cdays\u201d cache profile: const nextConfig = { experimental: { dynamicIO: true, cacheLife: { days: { stale: 3600, // 1 hour revalidate: 900, // 15 minutes expire: 86400, // 1 day }, }, }, } module.exports = nextConfig Defining cache profiles inline specific use cases, set custom cache profile passing object cacheLife function: 'use cache' import { unstable_cacheLife cacheLife } 'next/cache' export default async function Page() { cacheLife({ stale: 3600, // 1 hour revalidate: 900, // 15 minutes expire: 86400, // 1 day }) return <div>Page</div> } inline cache profile applied function file created in. want reuse profile throughout application, add configuration cacheLife property next.config.ts file. Nested usage use cache cacheLife defining multiple caching behaviors route component tree, inner caches specify cacheLife profile, outer cache respect shortest cache duration among them. applies outer cache explicit cacheLife profile defined. example, add use cache directive page, without specifying cache profile, default cache profile applied implicitly (cacheLife(\u201ddefault\u201d) ). component imported page also uses use cache directive cache profile, outer inner cache profiles compared, shortest duration set profiles applied. // Parent component import { unstable_cacheLife cacheLife } 'next/cache' import { ChildComponent } './child' export async function ParentComponent() { 'use cache' cacheLife('days') return ( <div> <ChildComponent /> </div> ) } separate file, defined Child component imported: // Child component import { unstable_cacheLife cacheLife } 'next/cache' export async function ChildComponent() { 'use cache' cacheLife('hours') return <div>Child Content</div> // component's cache respect shorter 'hours' profile } Related dynamicIO use cache revalidateTag cacheTag helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/cacheTag", "title": "Functions: cacheTag | Next.js", "text": "cacheTag feature currently available canary channel subject change. Try upgrading Next.js, share feedback GitHub. cacheTag function allows tag cached data on-demand invalidation. associating tags cache entries, selectively purge revalidate specific cache entries without affecting cached data. Usage use cacheTag , enable dynamicIO flag next.config.js file: next.config.ts import type { NextConfig } 'next' const nextConfig: NextConfig = { experimental: { dynamicIO: true, }, } export default nextConfig cacheTag function takes single string value, string array. app/data.ts import { unstable_cacheTag cacheTag } 'next/cache' export async function getData() { 'use cache' cacheTag('my-data') const data = await fetch('/api/data') return data } purge cache on-demand using revalidateTag API another function, example, route handler Server Action: app/action.ts 'use server' import { revalidateTag } 'next/cache' export default async function submit() { await addPost() revalidateTag('my-data') } Good know - Idempotent Tags: Applying tag multiple times additional effect. - Multiple Tags: assign multiple tags single cache entry passing array cacheTag . cacheTag('tag-one', 'tag-two') Examples Tagging components functions Tag cached data calling cacheTag within cached function component: app/components/bookings.tsx import { unstable_cacheTag cacheTag } 'next/cache' interface BookingsProps { type: string } export async function Bookings({ type = 'haircut' }: BookingsProps) { 'use cache' cacheTag('bookings-data') async function getBookingsData() { const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`) return data } return //... } Creating tags external data use data returned async function tag cache entry. app/components/bookings.tsx import { unstable_cacheTag cacheTag } 'next/cache' interface BookingsProps { type: string } export async function Bookings({ type = 'haircut' }: BookingsProps) { async function getBookingsData() { 'use cache' const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`) cacheTag('bookings-data', data.id) return data } return //... } Invalidating tagged cache Using revalidateTag , invalidate cache specific tag needed: app/actions.ts 'use server' import { revalidateTag } 'next/cache' export async function updateBookings() { await updateBookingData() revalidateTag('bookings-data') } Related View related API references. dynamicIO Learn enable dynamicIO flag Next.js. use cache Learn use use cache directive cache data Next.js application. revalidateTag API Reference revalidateTag function. cacheLife Learn use cacheLife function set cache expiration time cached function component. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/connection", "title": "Functions: connection | Next.js", "text": "connection connection() function allows indicate rendering wait incoming user request continuing. useful component doesn\u2019t use Dynamic APIs, want dynamically rendered runtime statically rendered build time. usually occurs access external information intentionally want change result render, Math.random() new Date() . app/page.tsx import { connection } 'next/server' export default async function Page() { await connection() // Everything excluded prerendering const rand = Math.random() return <span>{rand}</span> } Reference Type function connection(): Promise<void> Parameters - function accept parameters. Returns - function returns void Promise. meant consumed. Good know connection replacesunstable_noStore better align future Next.js.- function necessary dynamic rendering required common Dynamic APIs used. Version History | Version | Changes | |---|---| v15.0.0 | connection stabilized. | v15.0.0-RC | connection introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/cookies", "title": "Functions: cookies | Next.js", "text": "cookies cookies async function allows read HTTP incoming request cookies Server Component, read/write outgoing request cookies Server Actions Route Handlers. import { cookies } 'next/headers' export default async function Page() { const cookieStore = await cookies() const theme = cookieStore.get('theme') return '...' } Reference Methods following methods available: | Method | Return Type | Description | |---|---|---| get('name') | Object | Accepts cookie name returns object name value. | getAll() | Array objects | Returns list cookies matching name. | has('name') | Boolean | Accepts cookie name returns boolean based cookie exists. | set(name, value, options) | - | Accepts cookie name, value, options sets outgoing request cookie. | delete(name) | - | Accepts cookie name deletes cookie. | clear() | - | Deletes cookies. | toString() | String | Returns string representation cookies. | Options setting cookie, following properties options object supported: | Option | Type | Description | |---|---|---| name | String | Specifies name cookie. | value | String | Specifies value stored cookie. | expires | Date | Defines exact date cookie expire. | maxAge | Number | Sets cookie\u2019s lifespan seconds. | domain | String | Specifies domain cookie available. | path | String, default: '/' | Limits cookie's scope specific path within domain. | secure | Boolean | Ensures cookie sent HTTPS connections added security. | httpOnly | Boolean | Restricts cookie HTTP requests, preventing client-side access. | sameSite | Boolean, 'lax' , 'strict' , 'none' | Controls cookie's cross-site request behavior. | priority | String (\"low\" , \"medium\" , \"high\" ) | Specifies cookie's priority | encode('value') | Function | Specifies function used encode cookie's value. | partitioned | Boolean | Indicates whether cookie partitioned. | option default value path . learn options, see MDN docs. Good know cookies asynchronous function returns promise. must useasync/await React'suse function access cookies.- version 14 earlier, cookies synchronous function. help backwards compatibility, still access synchronously Next.js 15, behavior deprecated future. - version 14 earlier, cookies Dynamic API whose returned values cannot known ahead time. Using layout page opt route dynamic rendering.- .delete method called:- Server Action Route Handler. - belongs domain .set called. wildcard domains, specific subdomain must exact match. Additionally, code must executed protocol (HTTP HTTPS) cookie want delete. - HTTP allow setting cookies streaming starts, must use .set Server Action Route Handler. Understanding Cookie Behavior Server Components working cookies Server Components, important understand cookies fundamentally client-side storage mechanism: - Reading cookies works Server Components accessing cookie data client's browser sends server HTTP request headers. - Setting cookies cannot done directly Server Component, even using Route Handler Server Action. cookies actually stored browser, server. server send instructions (via Set-Cookie headers) tell browser store cookies - actual storage happens client side. cookie operations modify state (.set , .delete , .clear ) must performed Route Handler Server Action response headers properly set. Examples Getting cookie use (await cookies()).get('name') method get single cookie: import { cookies } 'next/headers' export default async function Page() { const cookieStore = await cookies() const theme = cookieStore.get('theme') return '...' } Getting cookies use (await cookies()).getAll() method get cookies matching name. name unspecified, returns available cookies. import { cookies } 'next/headers' export default async function Page() { const cookieStore = await cookies() return cookieStore.getAll().map((cookie) => ( <div key={cookie.name}> <p>Name: {cookie.name}</p> <p>Value: {cookie.value}</p> </div> )) } Setting cookie use (await cookies()).set(name, value, options) method Server Action Route Handler set cookie. options object optional. 'use server' import { cookies } 'next/headers' export async function create(data) { const cookieStore = await cookies() cookieStore.set('name', 'lee') // cookieStore.set('name', 'lee', { secure: true }) // cookieStore.set({ name: 'name', value: 'lee', httpOnly: true, path: '/', }) } Checking cookie exists use (await cookies()).has(name) method check cookie exists: import { cookies } 'next/headers' export default async function Page() { const cookieStore = await cookies() const hasCookie = cookieStore.has('theme') return '...' } Deleting cookies three ways delete cookie. Using delete() method: 'use server' import { cookies } 'next/headers' export async function delete(data) { (await cookies()).delete('name') } Setting new cookie name empty value: 'use server' import { cookies } 'next/headers' export async function delete(data) { (await cookies()).set('name', '') } Setting maxAge 0 immediately expire cookie. maxAge accepts value seconds. 'use server' import { cookies } 'next/headers' export async function delete(data) { (await cookies()).set('name', 'value', { maxAge: 0 }) } Version History | Version | Changes | |---|---| v15.0.0-RC | cookies async function. codemod available. | v13.0.0 | cookies introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/draft-mode", "title": "Functions: draftMode | Next.js", "text": "draftMode draftMode async function allows enable disable Draft Mode, well check Draft Mode enabled Server Component. app/page.ts import { draftMode } 'next/headers' export default async function Page() { const { isEnabled } = await draftMode() } Reference following methods properties available: | Method | Description | |---|---| isEnabled | boolean value indicates Draft Mode enabled. | enable() | Enables Draft Mode Route Handler setting cookie (__prerender_bypass ). | disable() | Disables Draft Mode Route Handler deleting cookie. | Good know draftMode asynchronous function returns promise. must useasync/await React'suse function.- version 14 earlier, draftMode synchronous function. help backwards compatibility, still access synchronously Next.js 15, behavior deprecated future. - version 14 earlier, - new bypass cookie value generated time run next build . ensures bypass cookie can\u2019t guessed. - test Draft Mode locally HTTP, browser need allow third-party cookies local storage access. Examples Enabling Draft Mode enable Draft Mode, create new Route Handler call enable() method: app/draft/route.ts import { draftMode } 'next/headers' export async function GET(request: Request) { const draft = await draftMode() draft.enable() return new Response('Draft mode enabled') } Disabling Draft Mode default, Draft Mode session ends browser closed. disable Draft Mode manually, call disable() method Route Handler: app/draft/route.ts import { draftMode } 'next/headers' export async function GET(request: Request) { const draft = await draftMode() draft.disable() return new Response('Draft mode disabled') } Then, send request invoke Route Handler. calling route using <Link> component, must pass prefetch={false} prevent accidentally deleting cookie prefetch. Checking Draft Mode enabled check Draft Mode enabled Server Component isEnabled property: app/page.ts import { draftMode } 'next/headers' export default async function Page() { const { isEnabled } = await draftMode() return ( <main> <h1>My Blog Post</h1> <p>Draft Mode currently {isEnabled ? 'Enabled' : 'Disabled'}</p> </main> ) } Version History | Version | Changes | |---|---| v15.0.0-RC | draftMode async function. codemod available. | v13.4.0 | draftMode introduced. | Next Steps Learn use Draft Mode step-by-step guide. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/fetch", "title": "Functions: fetch | Next.js", "text": "fetch Next.js extends Web fetch() API allow request server set persistent caching revalidation semantics. browser, cache option indicates fetch request interact browser's HTTP cache. extension, cache indicates server-side fetch request interact framework's persistent Data Cache. call fetch async await directly within Server Components. export default async function Page() { let data = await fetch('https://api.vercel.app/blog') let posts = await data.json() return ( <ul> {posts.map((post) => ( <li key={post.id}>{post.title}</li> ))} </ul> ) } fetch(url, options) Since Next.js extends Web fetch() API, use native options available. options.cache Configure request interact Next.js Data Cache. fetch(`https://...`, { cache: 'force-cache' | 'no-store' }) auto cache (default): Next.js fetches resource remote server every request development, fetch duringnext build route statically prerendered. Dynamic APIs detected route, Next.js fetch resource every request.no-store : Next.js fetches resource remote server every request, even Dynamic APIs detected route.force-cache : Next.js looks matching request Data Cache.- match fresh, returned cache. - match stale match, Next.js fetch resource remote server update cache downloaded resource. options.next.revalidate fetch(`https://...`, { next: { revalidate: false | 0 | number } }) Set cache lifetime resource (in seconds). false - Cache resource indefinitely. Semantically equivalent torevalidate: Infinity . HTTP cache may evict older resources time.0 - Prevent resource cached.number - (in seconds) Specify resource cache lifetime mostn seconds. Good know: - individual fetch() request sets arevalidate number lower defaultrevalidate route, whole route revalidation interval decreased.- two fetch requests URL route different revalidate values, lower value used.- convenience, necessary set cache option ifrevalidate set number.- Conflicting options { revalidate: 3600, cache: 'no-store' } cause error. options.next.tags fetch(`https://...`, { next: { tags: ['collection'] } }) Set cache tags resource. Data revalidated on-demand using revalidateTag . max length custom tag 256 characters max tag items 128. Troubleshooting Fetch default auto store cache: 'no-store' showing fresh data development Next.js caches fetch responses Server Components across Hot Module Replacement (HMR) local development faster responses reduce costs billed API calls. default, HMR cache applies fetch requests, including default auto cache cache: 'no-store' option. means uncached requests show fresh data HMR refreshes. However, cache cleared navigation full-page reloads. See serverComponentsHmrCache docs information. Version History | Version | Changes | |---|---| v13.0.0 | fetch introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/forbidden", "title": "Functions: forbidden | Next.js", "text": "forbidden feature currently experimental subject change, recommended production. Try share feedback GitHub. forbidden function throws error renders Next.js 403 error page. useful handling authorization errors application. customize UI using forbidden.js file. start using forbidden , enable experimental authInterrupts configuration option next.config.js file: next.config.ts import type { NextConfig } 'next' const nextConfig: NextConfig = { experimental: { authInterrupts: true, }, } export default nextConfig forbidden invoked Server Components, Server Actions, Route Handlers. app/auth/page.tsx import { verifySession } '@/app/lib/dal' import { forbidden } 'next/navigation' export default async function AdminPage() { const session = await verifySession() // Check user 'admin' role (session.role !== 'admin') { forbidden() } // Render admin page authorized users return <></> } Good know - forbidden function cannot called root layout. Examples Role-based route protection use forbidden restrict access certain routes based user roles. ensures users authenticated lack required permissions cannot access route. app/admin/page.tsx import { verifySession } '@/app/lib/dal' import { forbidden } 'next/navigation' export default async function AdminPage() { const session = await verifySession() // Check user 'admin' role (session.role !== 'admin') { forbidden() } // Render admin page authorized users return ( <main> <h1>Admin Dashboard</h1> <p>Welcome, {session.user.name}!</p> </main> ) } Mutations Server Actions implementing mutations Server Actions, use forbidden allow users specific role update sensitive data. app/actions/update-role.ts 'use server' import { verifySession } '@/app/lib/dal' import { forbidden } 'next/navigation' import db '@/app/lib/db' export async function updateRole(formData: FormData) { const session = await verifySession() // Ensure admins update roles (session.role !== 'admin') { forbidden() } // Perform role update authorized users // ... } Version History | Version | Changes | |---|---| v15.1.0 | forbidden introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/generate-image-metadata", "title": "Functions: generateImageMetadata | Next.js", "text": "generateImageMetadata use generateImageMetadata generate different versions one image return multiple images one route segment. useful want avoid hard-coding metadata values, icons. Parameters generateImageMetadata function accepts following parameters: params (optional) object containing dynamic route parameters object root segment segment generateImageMetadata called from. export function generateImageMetadata({ params, }: { params: { slug: string } }) { // ... } | Route | URL | params | |---|---|---| app/shop/icon.js | /shop | undefined | app/shop/[slug]/icon.js | /shop/1 | { slug: '1' } | app/shop/[tag]/[item]/icon.js | /shop/1/2 | { tag: '1', item: '2' } | Returns generateImageMetadata function return array objects containing image's metadata alt size . addition, item must include id value passed props image generating function. | Image Metadata Object | Type | |---|---| id | string (required) | alt | string | size | { width: number; height: number } | contentType | string | import { ImageResponse } 'next/og' export function generateImageMetadata() { return [ { contentType: 'image/png', size: { width: 48, height: 48 }, id: 'small', }, { contentType: 'image/png', size: { width: 72, height: 72 }, id: 'medium', }, ] } export default function Icon({ id }: { id: string }) { return new ImageResponse( ( <div style={{ width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: 88, background: '#000', color: '#fafafa', }} > Icon {id} </div> ) ) } Examples Using external data example uses params object external data generate multiple Open Graph images route segment. import { ImageResponse } 'next/og' import { getCaptionForImage, getOGImages } '@/app/utils/images' export async function generateImageMetadata({ params, }: { params: { id: string } }) { const images = await getOGImages(params.id) return images.map((image, idx) => ({ id: idx, size: { width: 1200, height: 600 }, alt: image.text, contentType: 'image/png', })) } export default async function Image({ params, id, }: { params: { id: string } id: number }) { const productId = (await params).id const imageId = id const text = await getCaptionForImage(productId, imageId) return new ImageResponse( ( <div style={ { // ... } } > {text} </div> ) ) } Version History | Version | Changes | |---|---| v13.3.0 | generateImageMetadata introduced. | Next Steps helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/generate-metadata", "title": "Functions: generateMetadata | Next.js", "text": "generateMetadata page covers Config-based Metadata options generateMetadata static metadata object. import type { Metadata } 'next' // either Static metadata export const metadata: Metadata = { title: '...', } // Dynamic metadata export async function generateMetadata({ params }) { return { title: '...', } } Good know: - metadata object andgenerateMetadata function exports supported Server Components.- cannot export metadata object andgenerateMetadata function route segment. metadata object define static metadata, export Metadata object layout.js page.js file. import type { Metadata } 'next' export const metadata: Metadata = { title: '...', description: '...', } export default function Page() {} See Metadata Fields complete list supported options. generateMetadata function Dynamic metadata depends dynamic information, current route parameters, external data, metadata parent segments, set exporting generateMetadata function returns Metadata object. import type { Metadata, ResolvingMetadata } 'next' type Props = { params: Promise<{ id: string }> searchParams: Promise<{ [key: string]: string | string[] | undefined }> } export async function generateMetadata( { params, searchParams }: Props, parent: ResolvingMetadata ): Promise<Metadata> { // read route params const id = (await params).id // fetch data const product = await fetch(`https://.../${id}`).then((res) => res.json()) // optionally access extend (rather replace) parent metadata const previousImages = (await parent).openGraph?.images || [] return { title: product.title, openGraph: { images: ['/some-specific-page-image.jpg', ...previousImages], }, } } export default function Page({ params, searchParams }: Props) {} Parameters generateMetadata function accepts following parameters: - props - object containing parameters current route:- params - object containing dynamic route parameters object root segment segmentgenerateMetadata called from. Examples:Route URL params app/shop/[slug]/page.js /shop/1 { slug: '1' } app/shop/[tag]/[item]/page.js /shop/1/2 { tag: '1', item: '2' } app/shop/[...slug]/page.js /shop/1/2 { slug: ['1', '2'] } - searchParams - object containing current URL's search params. Examples:URL searchParams /shop?a=1 { a: '1' } /shop?a=1&b=2 { a: '1', b: '2' } /shop?a=1&a=2 { a: ['1', '2'] } - - parent - promise resolved metadata parent route segments. Returns generateMetadata return Metadata object containing one metadata fields. Good know: - metadata depend runtime information, defined using static metadata object rather thangenerateMetadata .fetch requests automatically memoized data acrossgenerateMetadata ,generateStaticParams , Layouts, Pages, Server Components. Reactcache used iffetch unavailable.searchParams available inpage.js segments.- redirect() andnotFound() Next.js methods also used insidegenerateMetadata . Metadata Fields title title attribute used set title document. defined simple string optional template object. String export const metadata = { title: 'Next.js', } <title>Next.js</title> Template object import type { Metadata } 'next' export const metadata: Metadata = { title: { template: '...', default: '...', absolute: '...', }, } Default title.default used provide fallback title child route segments define title . import type { Metadata } 'next' export const metadata: Metadata = { title: { default: 'Acme', }, } import type { Metadata } 'next' export const metadata: Metadata = {} // Output: <title>Acme</title> Template title.template used add prefix suffix titles defined child route segments. import type { Metadata } 'next' export const metadata: Metadata = { title: { template: '%s | Acme', default: 'Acme', // default required creating template }, } import type { Metadata } 'next' export const metadata: Metadata = { title: 'About', } // Output: <title>About | Acme</title> Good know: title.template applies child route segments segment defined in. means: title.default required add atitle.template .title.template defined inlayout.js apply atitle defined apage.js route segment.title.template defined inpage.js effect page always terminating segment (it children route segments). title.template effect route defined atitle ortitle.default . Absolute title.absolute used provide title ignores title.template set parent segments. import type { Metadata } 'next' export const metadata: Metadata = { title: { template: '%s | Acme', }, } import type { Metadata } 'next' export const metadata: Metadata = { title: { absolute: 'About', }, } // Output: <title>About</title> Good know: layout.js title (string) andtitle.default define default title child segments (that define owntitle ). augmenttitle.template closest parent segment exists.title.absolute defines default title child segments. ignorestitle.template parent segments.title.template defines new title template child segments. page.js - page define title closest parents resolved title used. title (string) defines routes title. augmenttitle.template closest parent segment exists.title.absolute defines route title. ignorestitle.template parent segments.title.template effect inpage.js page always terminating segment route. description export const metadata = { description: 'The React Framework Web', } <meta name=\"description\" content=\"The React Framework Web\" /> Basic Fields export const metadata = { generator: 'Next.js', applicationName: 'Next.js', referrer: 'origin-when-cross-origin', keywords: ['Next.js', 'React', 'JavaScript'], authors: [{ name: 'Seb' }, { name: 'Josh', url: 'https://nextjs.org' }], creator: 'Jiachi Liu', publisher: 'Sebastian Markb\u00e5ge', formatDetection: { email: false, address: false, telephone: false, }, } <meta name=\"application-name\" content=\"Next.js\" /> <meta name=\"author\" content=\"Seb\" /> <link rel=\"author\" href=\"https://nextjs.org\" /> <meta name=\"author\" content=\"Josh\" /> <meta name=\"generator\" content=\"Next.js\" /> <meta name=\"keywords\" content=\"Next.js,React,JavaScript\" /> <meta name=\"referrer\" content=\"origin-when-cross-origin\" /> <meta name=\"color-scheme\" content=\"dark\" /> <meta name=\"creator\" content=\"Jiachi Liu\" /> <meta name=\"publisher\" content=\"Sebastian Markb\u00e5ge\" /> <meta name=\"format-detection\" content=\"telephone=no, address=no, email=no\" /> metadataBase metadataBase convenience option set base URL prefix metadata fields require fully qualified URL. metadataBase allows URL-basedmetadata fields defined current route segment use relative path instead otherwise required absolute URL.- field's relative path composed metadataBase form fully qualified URL. - configured, metadataBase automatically populated default value. export const metadata = { metadataBase: new URL('https://acme.com'), alternates: { canonical: '/', languages: { 'en-US': '/en-US', 'de-DE': '/de-DE', }, }, openGraph: { images: '/og-image.png', }, } <link rel=\"canonical\" href=\"https://acme.com\" /> <link rel=\"alternate\" hreflang=\"en-US\" href=\"https://acme.com/en-US\" /> <link rel=\"alternate\" hreflang=\"de-DE\" href=\"https://acme.com/de-DE\" /> <meta property=\"og:image\" content=\"https://acme.com/og-image.png\" /> Good know: metadataBase typically set rootapp/layout.js apply URL-basedmetadata fields across routes.- URL-based metadata fields require absolute URLs configured ametadataBase option.metadataBase contain subdomain e.g.https://app.acme.com base path e.g.https://acme.com/start/from/here - metadata field provides absolute URL,metadataBase ignored.- Using relative path URL-based metadata field without configuring ametadataBase cause build error.- Next.js normalize duplicate slashes metadataBase (e.g.https://acme.com/ ) relative field (e.g./path ) single slash (e.g.https://acme.com/path ) Default value configured, metadataBase default value. Vercel: - production deployments, VERCEL_PROJECT_PRODUCTION_URL used.- preview deployments, VERCEL_BRANCH_URL take priority, fallback toVERCEL_URL present.If values present used default value metadataBase , otherwise falls back tohttp://localhost:${process.env.PORT || 3000} . allows Open Graph images work local build Vercel preview production deployments. overriding default, recommend using environment variables compute URL. allows configuring URL local development, staging, production environments.See details environment variables System Environment Variables docs. URL Composition URL composition favors developer intent default directory traversal semantics. - Trailing slashes metadataBase andmetadata fields normalized. - \"absolute\" path metadata field (that typically would replace whole URL path) treated \"relative\" path (starting end ofmetadataBase ). example, given following metadataBase : import type { Metadata } 'next' export const metadata: Metadata = { metadataBase: new URL('https://acme.com'), } metadata fields inherit metadataBase set value resolved follows: metadata field | Resolved URL | |---|---| / | https://acme.com | ./ | https://acme.com | payments | https://acme.com/payments | /payments | https://acme.com/payments | ./payments | https://acme.com/payments | ../payments | https://acme.com/payments | https://beta.acme.com/payments | https://beta.acme.com/payments | openGraph export const metadata = { openGraph: { title: 'Next.js', description: 'The React Framework Web', url: 'https://nextjs.org', siteName: 'Next.js', images: [ { url: 'https://nextjs.org/og.png', // Must absolute URL width: 800, height: 600, }, { url: 'https://nextjs.org/og-alt.png', // Must absolute URL width: 1800, height: 1600, alt: 'My custom alt', }, ], videos: [ { url: 'https://nextjs.org/video.mp4', // Must absolute URL width: 800, height: 600, }, ], audio: [ { url: 'https://nextjs.org/audio.mp3', // Must absolute URL }, ], locale: 'en_US', type: 'website', }, } <meta property=\"og:title\" content=\"Next.js\" /> <meta property=\"og:description\" content=\"The React Framework Web\" /> <meta property=\"og:url\" content=\"https://nextjs.org/\" /> <meta property=\"og:site_name\" content=\"Next.js\" /> <meta property=\"og:locale\" content=\"en_US\" /> <meta property=\"og:image\" content=\"https://nextjs.org/og.png\" /> <meta property=\"og:image:width\" content=\"800\" /> <meta property=\"og:image:height\" content=\"600\" /> <meta property=\"og:image\" content=\"https://nextjs.org/og-alt.png\" /> <meta property=\"og:image:width\" content=\"1800\" /> <meta property=\"og:image:height\" content=\"1600\" /> <meta property=\"og:image:alt\" content=\"My custom alt\" /> <meta property=\"og:video\" content=\"https://nextjs.org/video.mp4\" /> <meta property=\"og:video:width\" content=\"800\" /> <meta property=\"og:video:height\" content=\"600\" /> <meta property=\"og:audio\" content=\"https://nextjs.org/audio.mp3\" /> <meta property=\"og:type\" content=\"website\" /> export const metadata = { openGraph: { title: 'Next.js', description: 'The React Framework Web', type: 'article', publishedTime: '2023-01-01T00:00:00.000Z', authors: ['Seb', 'Josh'], }, } <meta property=\"og:title\" content=\"Next.js\" /> <meta property=\"og:description\" content=\"The React Framework Web\" /> <meta property=\"og:type\" content=\"article\" /> <meta property=\"article:published_time\" content=\"2023-01-01T00:00:00.000Z\" /> <meta property=\"article:author\" content=\"Seb\" /> <meta property=\"article:author\" content=\"Josh\" /> Good know: - may convenient use file-based Metadata API Open Graph images. Rather sync config export actual files, file-based API automatically generate correct metadata you. robots import type { Metadata } 'next' export const metadata: Metadata = { robots: { index: true, follow: true, nocache: false, googleBot: { index: true, follow: true, noimageindex: false, 'max-video-preview': -1, 'max-image-preview': 'large', 'max-snippet': -1, }, }, } <meta name=\"robots\" content=\"index, follow\" /> <meta name=\"googlebot\" content=\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\" /> icons Good know: recommend using file-based Metadata API icons possible. Rather sync config export actual files, file-based API automatically generate correct metadata you. export const metadata = { icons: { icon: '/icon.png', shortcut: '/shortcut-icon.png', apple: '/apple-icon.png', other: { rel: 'apple-touch-icon-precomposed', url: '/apple-touch-icon-precomposed.png', }, }, } <link rel=\"shortcut icon\" href=\"/shortcut-icon.png\" /> <link rel=\"icon\" href=\"/icon.png\" /> <link rel=\"apple-touch-icon\" href=\"/apple-icon.png\" /> <link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-precomposed.png\" /> export const metadata = { icons: { icon: [ { url: '/icon.png' }, new URL('/icon.png', 'https://example.com'), { url: '/icon-dark.png', media: '(prefers-color-scheme: dark)' }, ], shortcut: ['/shortcut-icon.png'], apple: [ { url: '/apple-icon.png' }, { url: '/apple-icon-x3.png', sizes: '180x180', type: 'image/png' }, ], other: [ { rel: 'apple-touch-icon-precomposed', url: '/apple-touch-icon-precomposed.png', }, ], }, } <link rel=\"shortcut icon\" href=\"/shortcut-icon.png\" /> <link rel=\"icon\" href=\"/icon.png\" /> <link rel=\"icon\" href=\"https://example.com/icon.png\" /> <link rel=\"icon\" href=\"/icon-dark.png\" media=\"(prefers-color-scheme: dark)\" /> <link rel=\"apple-touch-icon\" href=\"/apple-icon.png\" /> <link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-precomposed.png\" /> <link rel=\"apple-touch-icon\" href=\"/apple-icon-x3.png\" sizes=\"180x180\" type=\"image/png\" /> Good know: msapplication-* meta tags longer supported Chromium builds Microsoft Edge, thus longer needed. themeColor Deprecated: themeColor option inmetadata deprecated Next.js 14. Please use theviewport configuration instead. colorScheme Deprecated: colorScheme option inmetadata deprecated Next.js 14. Please use theviewport configuration instead. manifest web application manifest, defined Web Application Manifest specification. export const metadata = { manifest: 'https://nextjs.org/manifest.json', } <link rel=\"manifest\" href=\"https://nextjs.org/manifest.json\" /> twitter Twitter specification (surprisingly) used X (formerly known Twitter). Learn Twitter Card markup reference. export const metadata = { twitter: { card: 'summary_large_image', title: 'Next.js', description: 'The React Framework Web', siteId: '1467726470533754880', creator: '@nextjs', creatorId: '1467726470533754880', images: ['https://nextjs.org/og.png'], // Must absolute URL }, } <meta name=\"twitter:card\" content=\"summary_large_image\" /> <meta name=\"twitter:site:id\" content=\"1467726470533754880\" /> <meta name=\"twitter:creator\" content=\"@nextjs\" /> <meta name=\"twitter:creator:id\" content=\"1467726470533754880\" /> <meta name=\"twitter:title\" content=\"Next.js\" /> <meta name=\"twitter:description\" content=\"The React Framework Web\" /> <meta name=\"twitter:image\" content=\"https://nextjs.org/og.png\" /> export const metadata = { twitter: { card: 'app', title: 'Next.js', description: 'The React Framework Web', siteId: '1467726470533754880', creator: '@nextjs', creatorId: '1467726470533754880', images: { url: 'https://nextjs.org/og.png', alt: 'Next.js Logo', }, app: { name: 'twitter_app', id: { iphone: 'twitter_app://iphone', ipad: 'twitter_app://ipad', googleplay: 'twitter_app://googleplay', }, url: { iphone: 'https://iphone_url', ipad: 'https://ipad_url', }, }, }, } <meta name=\"twitter:site:id\" content=\"1467726470533754880\" /> <meta name=\"twitter:creator\" content=\"@nextjs\" /> <meta name=\"twitter:creator:id\" content=\"1467726470533754880\" /> <meta name=\"twitter:title\" content=\"Next.js\" /> <meta name=\"twitter:description\" content=\"The React Framework Web\" /> <meta name=\"twitter:card\" content=\"app\" /> <meta name=\"twitter:image\" content=\"https://nextjs.org/og.png\" /> <meta name=\"twitter:image:alt\" content=\"Next.js Logo\" /> <meta name=\"twitter:app:name:iphone\" content=\"twitter_app\" /> <meta name=\"twitter:app:id:iphone\" content=\"twitter_app://iphone\" /> <meta name=\"twitter:app:id:ipad\" content=\"twitter_app://ipad\" /> <meta name=\"twitter:app:id:googleplay\" content=\"twitter_app://googleplay\" /> <meta name=\"twitter:app:url:iphone\" content=\"https://iphone_url\" /> <meta name=\"twitter:app:url:ipad\" content=\"https://ipad_url\" /> <meta name=\"twitter:app:name:ipad\" content=\"twitter_app\" /> <meta name=\"twitter:app:name:googleplay\" content=\"twitter_app\" /> viewport Deprecated: viewport option inmetadata deprecated Next.js 14. Please use theviewport configuration instead. verification export const metadata = { verification: { google: 'google', yandex: 'yandex', yahoo: 'yahoo', other: { me: ['my-email', 'my-link'], }, }, } <meta name=\"google-site-verification\" content=\"google\" /> <meta name=\"y_key\" content=\"yahoo\" /> <meta name=\"yandex-verification\" content=\"yandex\" /> <meta name=\"me\" content=\"my-email\" /> <meta name=\"me\" content=\"my-link\" /> appleWebApp export const metadata = { itunes: { appId: 'myAppStoreID', appArgument: 'myAppArgument', }, appleWebApp: { title: 'Apple Web App', statusBarStyle: 'black-translucent', startupImage: [ '/assets/startup/apple-touch-startup-image-768x1004.png', { url: '/assets/startup/apple-touch-startup-image-1536x2008.png', media: '(device-width: 768px) (device-height: 1024px)', }, ], }, } <meta name=\"apple-itunes-app\" content=\"app-id=myAppStoreID, app-argument=myAppArgument\" /> <meta name=\"mobile-web-app-capable\" content=\"yes\" /> <meta name=\"apple-mobile-web-app-title\" content=\"Apple Web App\" /> <link href=\"/assets/startup/apple-touch-startup-image-768x1004.png\" rel=\"apple-touch-startup-image\" /> <link href=\"/assets/startup/apple-touch-startup-image-1536x2008.png\" media=\"(device-width: 768px) (device-height: 1024px)\" rel=\"apple-touch-startup-image\" /> <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\" /> alternates export const metadata = { alternates: { canonical: 'https://nextjs.org', languages: { 'en-US': 'https://nextjs.org/en-US', 'de-DE': 'https://nextjs.org/de-DE', }, media: { 'only screen (max-width: 600px)': 'https://nextjs.org/mobile', }, types: { 'application/rss+xml': 'https://nextjs.org/rss', }, }, } <link rel=\"canonical\" href=\"https://nextjs.org\" /> <link rel=\"alternate\" hreflang=\"en-US\" href=\"https://nextjs.org/en-US\" /> <link rel=\"alternate\" hreflang=\"de-DE\" href=\"https://nextjs.org/de-DE\" /> <link rel=\"alternate\" media=\"only screen (max-width: 600px)\" href=\"https://nextjs.org/mobile\" /> <link rel=\"alternate\" type=\"application/rss+xml\" href=\"https://nextjs.org/rss\" /> appLinks export const metadata = { appLinks: { ios: { url: 'https://nextjs.org/ios', app_store_id: 'app_store_id', }, android: { package: 'com.example.android/package', app_name: 'app_name_android', }, web: { url: 'https://nextjs.org/web', should_fallback: true, }, }, } <meta property=\"al:ios:url\" content=\"https://nextjs.org/ios\" /> <meta property=\"al:ios:app_store_id\" content=\"app_store_id\" /> <meta property=\"al:android:package\" content=\"com.example.android/package\" /> <meta property=\"al:android:app_name\" content=\"app_name_android\" /> <meta property=\"al:web:url\" content=\"https://nextjs.org/web\" /> <meta property=\"al:web:should_fallback\" content=\"true\" /> archives Describes collection records, documents, materials historical interest (source). export const metadata = { archives: ['https://nextjs.org/13'], } <link rel=\"archives\" href=\"https://nextjs.org/13\" /> assets export const metadata = { assets: ['https://nextjs.org/assets'], } <link rel=\"assets\" href=\"https://nextjs.org/assets\" /> bookmarks export const metadata = { bookmarks: ['https://nextjs.org/13'], } <link rel=\"bookmarks\" href=\"https://nextjs.org/13\" /> category export const metadata = { category: 'technology', } <meta name=\"category\" content=\"technology\" /> facebook connect Facebook app Facebook account webpage certain Facebook Social Plugins Facebook Documentation Good know: specify either appId admins, both. export const metadata = { facebook: { appId: '12345678', }, } <meta property=\"fb:app_id\" content=\"12345678\" /> export const metadata = { facebook: { admins: '12345678', }, } <meta property=\"fb:admins\" content=\"12345678\" /> want generate multiple fb:admins meta tags use array value. export const metadata = { facebook: { admins: ['12345678', '87654321'], }, } <meta property=\"fb:admins\" content=\"12345678\" /> <meta property=\"fb:admins\" content=\"87654321\" /> metadata options covered using built-in support. However, may custom metadata tags specific site, brand new metadata tags released. use option render custom metadata tag. export const metadata = { other: { custom: 'meta', }, } <meta name=\"custom\" content=\"meta\" /> want generate multiple key meta tags use array value. export const metadata = { other: { custom: ['meta1', 'meta2'], }, } <meta name=\"custom\" content=\"meta1\" /> <meta name=\"custom\" content=\"meta2\" /> Unsupported Metadata following metadata types currently built-in support. However, still rendered layout page itself. | Metadata | Recommendation | |---|---| <meta http-equiv=\"...\"> | Use appropriate HTTP Headers via redirect() , Middleware, Security Headers | <base> | Render tag layout page itself. | <noscript> | Render tag layout page itself. | <style> | Learn styling Next.js. | <script> | Learn using scripts. | <link rel=\"stylesheet\" /> | import stylesheets directly layout page itself. | <link rel=\"preload /> | Use ReactDOM preload method | <link rel=\"preconnect\" /> | Use ReactDOM preconnect method | <link rel=\"dns-prefetch\" /> | Use ReactDOM prefetchDNS method | Resource hints <link> element number rel keywords used hint browser external resource likely needed. browser uses information apply preloading optimizations depending keyword. Metadata API directly support hints, use new ReactDOM methods safely insert <head> document. 'use client' import ReactDOM 'react-dom' export function PreloadResources() { ReactDOM.preload('...', { as: '...' }) ReactDOM.preconnect('...', { crossOrigin: '...' }) ReactDOM.prefetchDNS('...') return '...' } <link rel=\"preload\"> Start loading resource early page rendering (browser) lifecycle. MDN Docs. ReactDOM.preload(href: string, options: { as: string }) <link rel=\"preload\" href=\"...\" as=\"...\" /> <link rel=\"preconnect\"> Preemptively initiate connection origin. MDN Docs. ReactDOM.preconnect(href: string, options?: { crossOrigin?: string }) <link rel=\"preconnect\" href=\"...\" crossorigin /> <link rel=\"dns-prefetch\"> Attempt resolve domain name resources get requested. MDN Docs. ReactDOM.prefetchDNS(href: string) <link rel=\"dns-prefetch\" href=\"...\" /> Good know: - methods currently supported Client Components, still Server Side Rendered initial page load. - Next.js in-built features next/font ,next/image andnext/script automatically handle relevant resource hints. Types add type safety metadata using Metadata type. using built-in TypeScript plugin IDE, need manually add type, still explicitly add want. metadata object import type { Metadata } 'next' export const metadata: Metadata = { title: 'Next.js', } generateMetadata function Regular function import type { Metadata } 'next' export function generateMetadata(): Metadata { return { title: 'Next.js', } } Async function import type { Metadata } 'next' export async function generateMetadata(): Promise<Metadata> { return { title: 'Next.js', } } segment props import type { Metadata } 'next' type Props = { params: Promise<{ id: string }> searchParams: Promise<{ [key: string]: string | string[] | undefined }> } export function generateMetadata({ params, searchParams }: Props): Metadata { return { title: 'Next.js', } } export default function Page({ params, searchParams }: Props) {} parent metadata import type { Metadata, ResolvingMetadata } 'next' export async function generateMetadata( { params, searchParams }: Props, parent: ResolvingMetadata ): Promise<Metadata> { return { title: 'Next.js', } } JavaScript Projects JavaScript projects, use JSDoc add type safety. /** @type {import(\"next\").Metadata} */ export const metadata = { title: 'Next.js', } Streaming Metadata Starting v15.2, metadata returned generateMetadata streamed client. allows Next.js inject metadata HTML soon resolved. Since page metadata often primarily targets bots & crawlers, Next.js continue block render metadata resolved HTML-limited bots. bots, like Googlebot , execute JavaScript able inspect full page DOM, meaning require blocking metadata. However, bots like Twitterbot cannot execute JavaScript crawling page\u2014they fall HTML-limited category. Next.js automatically detects user agent incoming requests determine whether serve streaming metadata fallback blocking metadata. need customize list, define manually using htmlLimitedBots option next.config.js . Next.js ensure user agents matching regex receive blocking metadata requesting web page. module.exports = { htmlLimitedBots: 'MySpecialBot|MyAnotherSpecialBot|SimpleCrawler', } Version History | Version | Changes | |---|---| v15.2.0 | introduced streaming support generateMetadata . | v13.2.0 | viewport , themeColor , colorScheme deprecated favor viewport configuration. | v13.2.0 | metadata generateMetadata introduced. | Next Steps helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/generate-sitemaps", "title": "Functions: generateSitemaps | Next.js", "text": "generateSitemaps use generateSitemaps function generate multiple sitemaps application. Returns generateSitemaps returns array objects id property. URLs generated sitemaps available /.../sitemap/[id].xml . example, /product/sitemap/1.xml . Example example, split sitemap using generateSitemaps , return array objects sitemap id . Then, use id generate unique sitemaps. app/product/sitemap.ts import { BASE_URL } '@/app/lib/constants' export async function generateSitemaps() { // Fetch total number products calculate number sitemaps needed return [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }] } export default async function sitemap({ id, }: { id: number }): Promise<MetadataRoute.Sitemap> { // Google's limit 50,000 URLs per sitemap const start = id * 50000 const end = start + 50000 const products = await getProducts( `SELECT id, date products id ${start} ${end}` ) return products.map((product) => ({ url: `${BASE_URL}/product/${product.id}`, lastModified: product.date, })) } Version History | Version | Changes | |---|---| v15.0.0 | generateSitemaps generates consistent URLs development production | v13.3.2 | generateSitemaps introduced. development, view generated sitemap /.../sitemap.xml/[id] . example, /product/sitemap.xml/1 . | Next Steps Learn create sitemaps Next.js application. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/generate-static-params", "title": "Functions: generateStaticParams | Next.js", "text": "generateStaticParams generateStaticParams function used combination dynamic route segments statically generate routes build time instead on-demand request time. // Return list `params` populate [slug] dynamic segment export async function generateStaticParams() { const posts = await fetch('https://.../posts').then((res) => res.json()) return posts.map((post) => ({ slug: post.slug, })) } // Multiple versions page statically generated // using `params` returned `generateStaticParams` export default async function Page({ params, }: { params: Promise<{ slug: string }> }) { const { slug } = await params // ... } Good know: - use dynamicParams segment config option control happens dynamic segment visited generated withgenerateStaticParams .- must return empty array generateStaticParams utilizeexport const dynamic = 'force-static' order revalidate (ISR) paths runtime.- next dev ,generateStaticParams called navigate route.- next build ,generateStaticParams runs corresponding Layouts Pages generated.- revalidation (ISR), generateStaticParams called again.generateStaticParams replaces thegetStaticPaths function Pages Router. Parameters options.params (optional) multiple dynamic segments route use generateStaticParams , child generateStaticParams function executed set params parent generates. params object contains populated params parent generateStaticParams , used generate params child segment. Returns generateStaticParams return array objects object represents populated dynamic segments single route. - property object dynamic segment filled route. - properties name segment's name, properties value segment filled with. | Example Route | generateStaticParams Return Type | |---|---| /product/[id] | { id: string }[] | /products/[category]/[product] | { category: string, product: string }[] | /products/[...slug] | { slug: string[] }[] | Single Dynamic Segment export function generateStaticParams() { return [{ id: '1' }, { id: '2' }, { id: '3' }] } // Three versions page statically generated // using `params` returned `generateStaticParams` // - /product/1 // - /product/2 // - /product/3 export default async function Page({ params, }: { params: Promise<{ id: string }> }) { const { id } = await params // ... } Multiple Dynamic Segments export function generateStaticParams() { return [ { category: 'a', product: '1' }, { category: 'b', product: '2' }, { category: 'c', product: '3' }, ] } // Three versions page statically generated // using `params` returned `generateStaticParams` // - /products/a/1 // - /products/b/2 // - /products/c/3 export default async function Page({ params, }: { params: Promise<{ category: string; product: string }> }) { const { category, product } = await params // ... } Catch-all Dynamic Segment export function generateStaticParams() { return [{ slug: ['a', '1'] }, { slug: ['b', '2'] }, { slug: ['c', '3'] }] } // Three versions page statically generated // using `params` returned `generateStaticParams` // - /product/a/1 // - /product/b/2 // - /product/c/3 export default async function Page({ params, }: { params: Promise<{ slug: string[] }> }) { const { slug } = await params // ... } Examples Static Rendering paths build time statically render paths build time, supply full list paths generateStaticParams : export async function generateStaticParams() { const posts = await fetch('https://.../posts').then((res) => res.json()) return posts.map((post) => ({ slug: post.slug, })) } Subset paths build time statically render subset paths build time, rest first time visited runtime, return partial list paths: export async function generateStaticParams() { const posts = await fetch('https://.../posts').then((res) => res.json()) // Render first 10 posts build time return posts.slice(0, 10).map((post) => ({ slug: post.slug, })) } Then, using dynamicParams segment config option, control happens dynamic segment visited generated generateStaticParams . // posts besides top 10 404 export const dynamicParams = false export async function generateStaticParams() { const posts = await fetch('https://.../posts').then((res) => res.json()) const topPosts = posts.slice(0, 10) return topPosts.map((post) => ({ slug: post.slug, })) } paths runtime statically render paths first time visited, return empty array (no paths rendered build time) utilize export const dynamic = 'force-static' : export async function generateStaticParams() { return [] } Good know: must always return array generateStaticParams , even empty. Otherwise, route dynamically rendered. export const dynamic = 'force-static' Disable rendering unspecified paths prevent unspecified paths statically rendered runtime, add export const dynamicParams = false option route segment. config option used, paths provided generateStaticParams served, unspecified routes 404 match (in case catch-all routes). Multiple Dynamic Segments Route generate params dynamic segments current layout page, below. example, given app/products/[category]/[product] route: app/products/[category]/[product]/page.js generate params both[category] and[product] .app/products/[category]/layout.js generate params for[category] . two approaches generating params route multiple dynamic segments: Generate params bottom Generate multiple dynamic segments child route segment. // Generate segments [category] [product] export async function generateStaticParams() { const products = await fetch('https://.../products').then((res) => res.json()) return products.map((product) => ({ category: product.category.slug, product: product.id, })) } export default function Page({ params, }: { params: Promise<{ category: string; product: string }> }) { // ... } Generate params top Generate parent segments first use result generate child segments. // Generate segments [category] export async function generateStaticParams() { const products = await fetch('https://.../products').then((res) => res.json()) return products.map((product) => ({ category: product.category.slug, })) } export default function Layout({ params, }: { params: Promise<{ category: string }> }) { // ... } child route segment's generateStaticParams function executed segment parent generateStaticParams generates. child generateStaticParams function use params returned parent generateStaticParams function dynamically generate segments. // Generate segments [product] using `params` passed // parent segment's `generateStaticParams` function export async function generateStaticParams({ params: { category }, }: { params: { category: string } }) { const products = await fetch( `https://.../products?category=${category}` ).then((res) => res.json()) return products.map((product) => ({ product: product.id, })) } export default function Page({ params, }: { params: Promise<{ category: string; product: string }> }) { // ... } Good know: fetch requests automatically memoized data across allgenerate -prefixed functions, Layouts, Pages, Server Components. Reactcache used iffetch unavailable. Version History | Version | Changes | |---|---| v13.0.0 | generateStaticParams introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/generate-viewport", "title": "Functions: generateViewport | Next.js", "text": "generateViewport customize initial viewport page static viewport object dynamic generateViewport function. Good know: - viewport object andgenerateViewport function exports supported Server Components.- cannot export viewport object andgenerateViewport function route segment.- coming migrating metadata exports, use metadata-to-viewport-export codemod update changes. viewport object define viewport options, export viewport object layout.jsx page.jsx file. import type { Viewport } 'next' export const viewport: Viewport = { themeColor: 'black', } export default function Page() {} generateViewport function generateViewport return Viewport object containing one viewport fields. export function generateViewport({ params }) { return { themeColor: '...', } } Good know: - viewport depend runtime information, defined using static viewport object rather thangenerateViewport . Viewport Fields themeColor Learn theme-color . Simple theme color import type { Viewport } 'next' export const viewport: Viewport = { themeColor: 'black', } <meta name=\"theme-color\" content=\"black\" /> media attribute import type { Viewport } 'next' export const viewport: Viewport = { themeColor: [ { media: '(prefers-color-scheme: light)', color: 'cyan' }, { media: '(prefers-color-scheme: dark)', color: 'black' }, ], } <meta name=\"theme-color\" media=\"(prefers-color-scheme: light)\" content=\"cyan\" /> <meta name=\"theme-color\" media=\"(prefers-color-scheme: dark)\" content=\"black\" /> width , initialScale , maximumScale userScalable Good know: viewport meta tag automatically set, manual configuration usually unnecessary default sufficient. However, information provided completeness. import type { Viewport } 'next' export const viewport: Viewport = { width: 'device-width', initialScale: 1, maximumScale: 1, userScalable: false, // Also supported less commonly used // interactiveWidget: 'resizes-visual', } <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\" /> colorScheme Learn color-scheme . import type { Viewport } 'next' export const viewport: Viewport = { colorScheme: 'dark', } <meta name=\"color-scheme\" content=\"dark\" /> Types add type safety viewport object using Viewport type. using built-in TypeScript plugin IDE, need manually add type, still explicitly add want. viewport object import type { Viewport } 'next' export const viewport: Viewport = { themeColor: 'black', } generateViewport function Regular function import type { Viewport } 'next' export function generateViewport(): Viewport { return { themeColor: 'black', } } segment props import type { Viewport } 'next' type Props = { params: Promise<{ id: string }> searchParams: Promise<{ [key: string]: string | string[] | undefined }> } export function generateViewport({ params, searchParams }: Props): Viewport { return { themeColor: 'black', } } export default function Page({ params, searchParams }: Props) {} JavaScript Projects JavaScript projects, use JSDoc add type safety. /** @type {import(\"next\").Viewport} */ export const viewport = { themeColor: 'black', } Version History | Version | Changes | |---|---| v14.0.0 | viewport generateViewport introduced. | Next Steps helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/headers", "title": "Functions: headers | Next.js", "text": "headers headers async function allows read HTTP incoming request headers Server Component. app/page.tsx import { headers } 'next/headers' export default async function Page() { const headersList = await headers() const userAgent = headersList.get('user-agent') } Reference Parameters headers take parameters. Returns headers returns read-only Web Headers object. Headers.entries() : Returns aniterator allowing go key/value pairs contained object.Headers.forEach() : Executes provided function key/value pair thisHeaders object.Headers.get() : Returns aString sequence values header within aHeaders object given name.Headers.has() : Returns boolean stating whether aHeaders object contains certain header.Headers.keys() : Returns aniterator allowing go keys key/value pairs contained object.Headers.values() : Returns aniterator allowing go values key/value pairs contained object. Good know headers asynchronous function returns promise. must useasync/await React'suse function.- version 14 earlier, headers synchronous function. help backwards compatibility, still access synchronously Next.js 15, behavior deprecated future. - version 14 earlier, - Since headers read-only, cannotset ordelete outgoing request headers. headers Dynamic API whose returned values cannot known ahead time. Using opt route dynamic rendering. Examples Using Authorization header app/page.js import { headers } 'next/headers' export default async function Page() { const authorization = (await headers()).get('authorization') const res = await fetch('...', { headers: { authorization }, // Forward authorization header }) const user = await res.json() return <h1>{user.name}</h1> } Version History | Version | Changes | |---|---| v15.0.0-RC | headers async function. codemod available. | v13.0.0 | headers introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/image-response", "title": "Functions: ImageResponse | Next.js", "text": "ImageResponse ImageResponse constructor allows generate dynamic images using JSX CSS. useful generating social media images Open Graph images, Twitter cards, more. following options available ImageResponse : import { ImageResponse } 'next/og' new ImageResponse( element: ReactElement, options: { width?: number = 1200 height?: number = 630 emoji?: 'twemoji' | 'blobmoji' | 'noto' | 'openmoji' = 'twemoji', fonts?: { name: string, data: ArrayBuffer, weight: number, style: 'normal' | 'italic' }[] debug?: boolean = false // Options passed HTTP response status?: number = 200 statusText?: string headers?: Record<string, string> }, ) Supported CSS Properties Please refer Satori\u2019s documentation list supported HTML CSS features. Version History | Version | Changes | |---|---| v14.0.0 | ImageResponse moved next/server next/og | v13.3.0 | ImageResponse imported next/server . | v13.0.0 | ImageResponse introduced via @vercel/og package. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/next-request", "title": "Functions: NextRequest | Next.js", "text": "NextRequest NextRequest extends Web Request API additional convenience methods. cookies Read mutate Set-Cookie header request. set(name, value) Given name, set cookie given value request. // Given incoming request /home // Set cookie hide banner // request `Set-Cookie:show-banner=false;path=/home` header request.cookies.set('show-banner', 'false') get(name) Given cookie name, return value cookie. cookie found, undefined returned. multiple cookies found, first one returned. // Given incoming request /home // { name: 'show-banner', value: 'false', Path: '/home' } request.cookies.get('show-banner') getAll() Given cookie name, return values cookie. name given, return cookies request. // Given incoming request /home // [ // { name: 'experiments', value: 'new-pricing-page', Path: '/home' }, // { name: 'experiments', value: 'winter-launch', Path: '/home' }, // ] request.cookies.getAll('experiments') // Alternatively, get cookies request request.cookies.getAll() delete(name) Given cookie name, delete cookie request. // Returns true deleted, false nothing deleted request.cookies.delete('experiments') has(name) Given cookie name, return true cookie exists request. // Returns true cookie exists, false request.cookies.has('experiments') clear() Remove Set-Cookie header request. request.cookies.clear() nextUrl Extends native URL API additional convenience methods, including Next.js specific properties. // Given request /home, pathname /home request.nextUrl.pathname // Given request /home?name=lee, searchParams { 'name': 'lee' } request.nextUrl.searchParams following options available: | Property | Type | Description | |---|---|---| basePath | string | base path URL. | buildId | string | undefined | build identifier Next.js application. customized. | pathname | string | pathname URL. | searchParams | Object | search parameters URL. | Note: internationalization properties Pages Router available usage App Router. Learn internationalization App Router. Version History | Version | Changes | |---|---| v15.0.0 | ip geo removed. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/next-response", "title": "Functions: NextResponse | Next.js", "text": "NextResponse NextResponse extends Web Response API additional convenience methods. cookies Read mutate Set-Cookie header response. set(name, value) Given name, set cookie given value response. // Given incoming request /home let response = NextResponse.next() // Set cookie hide banner response.cookies.set('show-banner', 'false') // Response `Set-Cookie:show-banner=false;path=/home` header return response get(name) Given cookie name, return value cookie. cookie found, undefined returned. multiple cookies found, first one returned. // Given incoming request /home let response = NextResponse.next() // { name: 'show-banner', value: 'false', Path: '/home' } response.cookies.get('show-banner') getAll() Given cookie name, return values cookie. name given, return cookies response. // Given incoming request /home let response = NextResponse.next() // [ // { name: 'experiments', value: 'new-pricing-page', Path: '/home' }, // { name: 'experiments', value: 'winter-launch', Path: '/home' }, // ] response.cookies.getAll('experiments') // Alternatively, get cookies response response.cookies.getAll() delete(name) Given cookie name, delete cookie response. // Given incoming request /home let response = NextResponse.next() // Returns true deleted, false nothing deleted response.cookies.delete('experiments') json() Produce response given JSON body. import { NextResponse } 'next/server' export async function GET(request: Request) { return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 }) } redirect() Produce response redirects URL. import { NextResponse } 'next/server' return NextResponse.redirect(new URL('/new', request.url)) URL created modified used NextResponse.redirect() method. example, use request.nextUrl property get current URL, modify redirect different URL. import { NextResponse } 'next/server' // Given incoming request... const loginUrl = new URL('/login', request.url) // Add ?from=/incoming-url /login URL loginUrl.searchParams.set('from', request.nextUrl.pathname) // redirect new URL return NextResponse.redirect(loginUrl) rewrite() Produce response rewrites (proxies) given URL preserving original URL. import { NextResponse } 'next/server' // Incoming request: /about, browser shows /about // Rewritten request: /proxy, browser shows /about return NextResponse.rewrite(new URL('/proxy', request.url)) next() next() method useful Middleware, allows return early continue routing. import { NextResponse } 'next/server' return NextResponse.next() also forward headers producing response: import { NextResponse } 'next/server' // Given incoming request... const newHeaders = new Headers(request.headers) // Add new header newHeaders.set('x-version', '123') // produce response new headers return NextResponse.next({ request: { // New request headers headers: newHeaders, }, }) helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/not-found", "title": "Functions: notFound | Next.js", "text": "notFound notFound function allows render not-found file within route segment well inject <meta name=\"robots\" content=\"noindex\" /> tag. notFound() Invoking notFound() function throws NEXT_NOT_FOUND error terminates rendering route segment thrown. Specifying not-found file allows gracefully handle errors rendering Found UI within segment. app/user/[id]/page.js import { notFound } 'next/navigation' async function fetchUser(id) { const res = await fetch('https://...') (!res.ok) return undefined return res.json() } export default async function Profile({ params }) { const user = await fetchUser((await params).id) (!user) { notFound() } // ... } Good know: notFound() require usereturn notFound() due using TypeScriptnever type. Version History | Version | Changes | |---|---| v13.0.0 | notFound introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/permanentRedirect", "title": "Functions: permanentRedirect | Next.js", "text": "permanentRedirect permanentRedirect function allows redirect user another URL. permanentRedirect used Server Components, Client Components, Route Handlers, Server Actions. used streaming context, insert meta tag emit redirect client side. used server action, serve 303 HTTP redirect response caller. Otherwise, serve 308 (Permanent) HTTP redirect response caller. resource exist, use notFound function instead. Good know: prefer return 307 (Temporary) HTTP redirect instead 308 (Permanent), use redirect function instead. Parameters permanentRedirect function accepts two arguments: permanentRedirect(path, type) | Parameter | Type | Description | |---|---|---| path | string | URL redirect to. relative absolute path. | type | 'replace' (default) 'push' (default Server Actions) | type redirect perform. | default, permanentRedirect use push (adding new entry browser history stack) Server Actions replace (replacing current URL browser history stack) everywhere else. override behavior specifying type parameter. type parameter effect used Server Components. Returns permanentRedirect return value. Example Invoking permanentRedirect() function throws NEXT_REDIRECT error terminates rendering route segment thrown. import { permanentRedirect } 'next/navigation' async function fetchTeam(id) { const res = await fetch('https://...') (!res.ok) return undefined return res.json() } export default async function Profile({ params }) { const team = await fetchTeam((await params).id) (!team) { permanentRedirect('/login') } // ... } Good know: permanentRedirect require usereturn permanentRedirect() uses TypeScriptnever type. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/redirect", "title": "Functions: redirect | Next.js", "text": "redirect redirect function allows redirect user another URL. redirect used Server Components, Route Handlers, Server Actions. used streaming context, insert meta tag emit redirect client side. used server action, serve 303 HTTP redirect response caller. Otherwise, serve 307 HTTP redirect response caller. resource exist, use notFound function instead. Good know: - Server Actions Route Handlers, redirect called thetry/catch block.- prefer return 308 (Permanent) HTTP redirect instead 307 (Temporary), use permanentRedirect function instead. Parameters redirect function accepts two arguments: redirect(path, type) | Parameter | Type | Description | |---|---|---| path | string | URL redirect to. relative absolute path. | type | 'replace' (default) 'push' (default Server Actions) | type redirect perform. | default, redirect use push (adding new entry browser history stack) Server Actions replace (replacing current URL browser history stack) everywhere else. override behavior specifying type parameter. type parameter effect used Server Components. Returns redirect return value. Example Server Component Invoking redirect() function throws NEXT_REDIRECT error terminates rendering route segment thrown. import { redirect } 'next/navigation' async function fetchTeam(id: string) { const res = await fetch('https://...') (!res.ok) return undefined return res.json() } export default async function Profile({ params, }: { params: Promise<{ id: string }> }) { const { id } = await params const team = await fetchTeam(id) (!team) { redirect('/login') } // ... } Good know: redirect require usereturn redirect() uses TypeScriptnever type. Client Component redirect used Client Component Server Action. need use event handler redirect user, use useRouter hook. 'use client' import { navigate } './actions' export function ClientRedirect() { return ( <form action={navigate}> <input type=\"text\" name=\"id\" /> <button>Submit</button> </form> ) } 'use server' import { redirect } 'next/navigation' export async function navigate(data: FormData) { redirect(`/posts/${data.get('id')}`) } FAQ redirect use 307 308? using redirect() may notice status codes used 307 temporary redirect, 308 permanent redirect. traditionally 302 used temporary redirect, 301 permanent redirect, many browsers changed request method redirect, POST GET request using 302 , regardless origins request method. Taking following example redirect /users /people , make POST request /users create new user, conforming 302 temporary redirect, request method changed POST GET request. make sense, create new user, making POST request /people , GET request. introduction 307 status code means request method preserved POST . 302 - Temporary redirect, change request method fromPOST toGET 307 - Temporary redirect, preserve request method asPOST redirect() method uses 307 default, instead 302 temporary redirect, meaning requests always preserved POST requests. Learn HTTP Redirects. Version History | Version | Changes | |---|---| v13.0.0 | redirect introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/revalidatePath", "title": "Functions: revalidatePath | Next.js", "text": "revalidatePath revalidatePath allows purge cached data on-demand specific path. Good know: revalidatePath invalidates cache included path next visited. means callingrevalidatePath dynamic route segment immediately trigger many revalidations once. invalidation happens path next visited.- Currently, revalidatePath invalidates routes client-side Router Cache used server action. behavior temporary updated future apply specific path.- Using revalidatePath invalidates specific path server-side Route Cache. Parameters revalidatePath(path: string, type?: 'page' | 'layout'): void; path : Either string representing filesystem path associated data want revalidate (for example,/product/[slug]/page ), literal route segment (for example,/product/123 ). Must less 1024 characters. value case-sensitive.type : (optional)'page' or'layout' string change type path revalidate. Ifpath contains dynamic segment (for example,/product/[slug]/page ), parameter required. path refers literal route segment, e.g.,/product/1 dynamic page (e.g.,/product/[slug]/page ), providetype . Returns revalidatePath return value. Examples Revalidating Specific URL import { revalidatePath } 'next/cache' revalidatePath('/blog/post-1') revalidate one specific URL next page visit. Revalidating Page Path import { revalidatePath } 'next/cache' revalidatePath('/blog/[slug]', 'page') // route groups revalidatePath('/(main)/blog/[slug]', 'page') revalidate URL matches provided page file next page visit. invalidate pages beneath specific page. example, /blog/[slug] invalidate /blog/[slug]/[author] . Revalidating Layout Path import { revalidatePath } 'next/cache' revalidatePath('/blog/[slug]', 'layout') // route groups revalidatePath('/(main)/post/[slug]', 'layout') revalidate URL matches provided layout file next page visit. cause pages beneath layout revalidate next visit. example, case, /blog/[slug]/[another] would also revalidate next visit. Revalidating Data import { revalidatePath } 'next/cache' revalidatePath('/', 'layout') purge Client-side Router Cache, revalidate Data Cache next page visit. Server Action 'use server' import { revalidatePath } 'next/cache' export default async function submit() { await submitForm() revalidatePath('/') } Route Handler import { revalidatePath } 'next/cache' import type { NextRequest } 'next/server' export async function GET(request: NextRequest) { const path = request.nextUrl.searchParams.get('path') (path) { revalidatePath(path) return Response.json({ revalidated: true, now: Date.now() }) } return Response.json({ revalidated: false, now: Date.now(), message: 'Missing path revalidate', }) } helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/revalidateTag", "title": "Functions: revalidateTag | Next.js", "text": "revalidateTag revalidateTag allows purge cached data on-demand specific cache tag. Good know: revalidateTag invalidates cache path next visited. means callingrevalidateTag dynamic route segment immediately trigger many revalidations once. invalidation happens path next visited. Parameters revalidateTag(tag: string): void; tag : string representing cache tag associated data want revalidate. Must less equal 256 characters. value case-sensitive. add tags fetch follows: fetch(url, { next: { tags: [...] } }); Returns revalidateTag return value. Examples Server Action app/actions.ts 'use server' import { revalidateTag } 'next/cache' export default async function submit() { await addPost() revalidateTag('posts') } Route Handler app/api/revalidate/route.ts import type { NextRequest } 'next/server' import { revalidateTag } 'next/cache' export async function GET(request: NextRequest) { const tag = request.nextUrl.searchParams.get('tag') revalidateTag(tag) return Response.json({ revalidated: true, now: Date.now() }) } helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/unauthorized", "title": "Functions: unauthorized | Next.js", "text": "unauthorized feature currently experimental subject change, recommended production. Try share feedback GitHub. unauthorized function throws error renders Next.js 401 error page. useful handling authorization errors application. customize UI using unauthorized.js file. start using unauthorized , enable experimental authInterrupts configuration option next.config.js file: next.config.ts import type { NextConfig } 'next' const nextConfig: NextConfig = { experimental: { authInterrupts: true, }, } export default nextConfig unauthorized invoked Server Components, Server Actions, Route Handlers. app/dashboard/page.tsx import { verifySession } '@/app/lib/dal' import { unauthorized } 'next/navigation' export default async function DashboardPage() { const session = await verifySession() (!session) { unauthorized() } // Render dashboard authenticated users return ( <main> <h1>Welcome Dashboard</h1> <p>Hi, {session.user.name}.</p> </main> ) } Good know - unauthorized function cannot called root layout. Examples Displaying login UI unauthenticated users use unauthorized function display unauthorized.js file login UI. app/dashboard/page.tsx import { verifySession } '@/app/lib/dal' import { unauthorized } 'next/navigation' export default async function DashboardPage() { const session = await verifySession() (!session) { unauthorized() } return <div>Dashboard</div> } app/unauthorized.tsx import Login '@/app/components/Login' export default function UnauthorizedPage() { return ( <main> <h1>401 - Unauthorized</h1> <p>Please log access page.</p> <Login /> </main> ) } Mutations Server Actions invoke unauthorized Server Actions ensure authenticated users perform specific mutations. app/actions/update-profile.ts 'use server' import { verifySession } '@/app/lib/dal' import { unauthorized } 'next/navigation' import db '@/app/lib/db' export async function updateProfile(data: FormData) { const session = await verifySession() // user authenticated, return 401 (!session) { unauthorized() } // Proceed mutation // ... } Fetching data Route Handlers use unauthorized Route Handlers ensure authenticated users access endpoint. app/api/profile/route.ts import { NextRequest, NextResponse } 'next/server' import { verifySession } '@/app/lib/dal' import { unauthorized } 'next/navigation' export async function GET(req: NextRequest): Promise<NextResponse> { // Verify user's session const session = await verifySession() // session exists, return 401 render unauthorized.tsx (!session) { unauthorized() } // Fetch data // ... } Version History | Version | Changes | |---|---| v15.1.0 | unauthorized introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/after", "title": "Functions: after | Next.js", "text": "allows schedule work executed response (or prerender) finished. useful tasks side effects block response, logging analytics. used Server Components (including generateMetadata ), Server Actions, Route Handlers, Middleware. function accepts callback executed response (or prerender) finished: import { } 'next/server' // Custom logging function import { log } '@/app/utils' export default function Layout({ children }: { children: React.ReactNode }) { after(() => { // Execute layout rendered sent user log() }) return <>{children}</> } Good know: Dynamic API calling cause route become dynamic. used within static page, callback execute build time, whenever page revalidated. Reference Parameters - callback function executed response (or prerender) finished. Duration run platform's default configured max duration route. platform supports it, configure timeout limit using maxDuration route segment config. Good know executed even response complete successfully. Including error thrown whennotFound orredirect called.- use React cache deduplicate functions called insideafter . nested inside otherafter calls, example, create utility functions wrapafter calls add additional functionality. Alternatives use case process secondary tasks without blocking primary response. similar using platform's waitUntil() removing await promise, following differences: waitUntil() : accepts promise enqueues task executed lifecycle request, whereasafter accepts callback executed response finished.- Removing await : starts executing response, uses resources. also reliable serverless environments function stops computation immediately response sent, potentially interrupting task. recommend using designed consider Next.js APIs contexts. Examples request APIs use request APIs cookies headers inside Server Actions Route Handlers. useful logging activity mutation. example: import { } 'next/server' import { cookies, headers } 'next/headers' import { logUserAction } '@/app/utils' export async function POST(request: Request) { // Perform mutation // ... // Log user activity analytics after(async () => { const userAgent = (await headers().get('user-agent')) || 'unknown' const sessionCookie = (await cookies().get('session-id'))?.value || 'anonymous' logUserAction({ sessionCookie, userAgent }) }) return new Response(JSON.stringify({ status: 'success' }), { status: 200, headers: { 'Content-Type': 'application/json' }, }) } However, cannot use request APIs inside Server Components. Next.js needs know part tree access request APIs support Partial Prerendering, runs React's rendering lifecycle. | Version History | Description | |---|---| v15.1.0 | became stable. | v15.0.0-rc | unstable_after introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/unstable_cache", "title": "Functions: unstable_cache | Next.js", "text": "unstable_cache Note: API replaced use cache reaches stability. unstable_cache allows cache results expensive operations, like database queries, reuse across multiple requests. import { getUser } './data'; import { unstable_cache } 'next/cache'; const getCachedUser = unstable_cache( async (id) => getUser(id), ['my-app-user'] ); export default async function Component({ userID }) { const user = await getCachedUser(userID); ... } Good know: - Accessing dynamic data sources headers orcookies inside cache scope supported. need data inside cached function useheaders outside cached function pass required dynamic data argument.- API uses Next.js' built-in Data Cache persist result across requests deployments. Warning: API unstable may change future. provide migration documentation codemods, needed, API stabilizes. Parameters const data = unstable_cache(fetchData, keyParts, options)() fetchData : asynchronous function fetches data want cache. must function returns aPromise .keyParts : extra array keys adds identification cache. default,unstable_cache already uses arguments stringified version function cache key. optional cases; time need use use external variables without passing parameters. However, important add closures used within function pass parameters.options : object controls cache behaves. contain following properties:tags : array tags used control cache invalidation. Next.js use uniquely identify function.revalidate : number seconds cache revalidated. Omit passfalse cache indefinitely matchingrevalidateTag() orrevalidatePath() methods called. Returns unstable_cache returns function invoked, returns Promise resolves cached data. data cache, provided function invoked, result cached returned. Example app/page.tsx import { unstable_cache } 'next/cache' export default async function Page({ params, }: { params: Promise<{ userId: string }> }) { const userId = (await params).userId const getCachedUser = unstable_cache( async () => { return { id: userId } }, [userId], // add user ID cache key { tags: ['users'], revalidate: 60, } ) //... } Version History | Version | Changes | |---|---| v14.0.0 | unstable_cache introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/unstable_noStore", "title": "Functions: unstable_noStore | Next.js", "text": "unstable_noStore legacy API longer recommended. still supported backward compatibility. version 15, recommend using connection instead unstable_noStore . unstable_noStore used declaratively opt static rendering indicate particular component cached. import { unstable_noStore noStore } 'next/cache'; export default async function ServerComponent() { noStore(); const result = await db.query(...); ... } Good know: unstable_noStore equivalent tocache: 'no-store' afetch unstable_noStore preferred overexport const dynamic = 'force-dynamic' granular used per-component basis - Using unstable_noStore insideunstable_cache opt static generation. Instead, defer cache configuration determine whether cache result not. Usage prefer pass additional options fetch , like cache: 'no-store' , next: { revalidate: 0 } cases fetch available, use noStore() replacement use cases. import { unstable_noStore noStore } 'next/cache'; export default async function ServerComponent() { noStore(); const result = await db.query(...); ... } Version History | Version | Changes | |---|---| v15.0.0 | unstable_noStore deprecated connection . | v14.0.0 | unstable_noStore introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow", "title": "Functions: unstable_rethrow | Next.js", "text": "unstable_rethrow unstable_rethrow used avoid catching internal errors thrown Next.js attempting handle errors thrown application code. example, calling notFound function throw internal Next.js error render not-found.js component. However, used inside try/catch block, error caught, preventing not-found.js rendering: import { notFound } 'next/navigation' export default async function Page() { try { const post = await fetch('https://.../posts/1').then((res) => { (res.status === 404) notFound() (!res.ok) throw new Error(res.statusText) return res.json() }) } catch (err) { console.error(err) } } use unstable_rethrow API re-throw internal error continue expected behavior: import { notFound, unstable_rethrow } 'next/navigation' export default async function Page() { try { const post = await fetch('https://.../posts/1').then((res) => { (res.status === 404) notFound() (!res.ok) throw new Error(res.statusText) return res.json() }) } catch (err) { unstable_rethrow(err) console.error(err) } } following Next.js APIs rely throwing error rethrown handled Next.js itself: route segment marked throw error unless static, Dynamic API call also throw error similarly caught developer. Note Partial Prerendering (PPR) affects behavior well. APIs are: cookies headers searchParams fetch(..., { cache: 'no-store' }) fetch(..., { next: { revalidate: 0 } }) Good know: - method called top catch block, passing error object argument. also used within .catch handler promise.- ensure calls APIs throw wrapped try/catch need use unstable_rethrow - resource cleanup (like clearing intervals, timers, etc) would either happen prior call unstable_rethrow within afinally block. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-link-status", "title": "Functions: useLinkStatus | Next.js", "text": "useLinkStatus useLinkStatus hook lets tracks pending state <Link> . use show inline visual feedback user (like spinners text glimmers) navigation new route completes. useLinkStatus useful when: - Prefetching disabled progress meaning navigation blocked. - destination route dynamic include loading.js file would allow instant navigation. 'use client' import { useLinkStatus } 'next/link' export default function LoadingIndicator() { const { pending } = useLinkStatus() return pending ? ( <div role=\"status\" aria-label=\"Loading\" className=\"spinner\" /> ) : null } import Link 'next/link' import LoadingIndicator './loading-indicator' export default function Header() { return ( <header> <Link href=\"/dashboard\" prefetch={false}> Dashboard <LoadingIndicator /> </Link> </header> ) } Good know: useLinkStatus must used within descendant component aLink component- hook useful prefetch={false} set theLink component- linked route prefetched, pending state skipped - clicking multiple links quick succession, last link's pending state shown - hook supported Pages Router always return { pending: false } Parameters const { pending } = useLinkStatus() useLinkStatus take parameters. Returns useLinkStatus returns object single property: | Property | Type | Description | |---|---|---| | pending | boolean | true history updates, false | Example Inline loading indicator helpful add visual feedback navigation happening case user clicks link prefetching complete. 'use client' import { useLinkStatus } 'next/link' export default function LoadingIndicator() { const { pending } = useLinkStatus() return pending ? ( <div role=\"status\" aria-label=\"Loading\" className=\"spinner\" /> ) : null } import Link 'next/link' import LoadingIndicator './components/loading-indicator' const links = [ { href: '/shop/electronics', label: 'Electronics' }, { href: '/shop/clothing', label: 'Clothing' }, { href: '/shop/books', label: 'Books' }, ] function Menubar() { return ( <div> {links.map((link) => ( <Link key={link.label} href={link.href}> {link.label} <LoadingIndicator /> </Link> ))} </div> ) } export default function Layout({ children }: { children: React.ReactNode }) { return ( <div> <Menubar /> {children} </div> ) } Gracefully handling fast navigation navigation new route fast, users may see unecessary flash loading indicator. One way improve user experience show loading indicator navigation takes time complete add initial animation delay (e.g. 100ms) start animation invisible (e.g. opacity: 0 ). .spinner { /* ... */ opacity: 0; animation: fadeIn 500ms 100ms forwards, rotate 1s linear infinite; } @keyframes fadeIn { { opacity: 0; } { opacity: 1; } } @keyframes rotate { { transform: rotate(360deg); } } | Version | Changes | |---|---| v15.3.0 | useLinkStatus introduced. | Next Steps helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-params", "title": "Functions: useParams | Next.js", "text": "useParams useParams Client Component hook lets read route's dynamic params filled current URL. app/example-client-component.tsx 'use client' import { useParams } 'next/navigation' export default function ExampleClientComponent() { const params = useParams<{ tag: string; item: string }>() // Route -> /shop/[tag]/[item] // URL -> /shop/shoes/nike-air-max-97 // `params` -> { tag: 'shoes', item: 'nike-air-max-97' } console.log(params) return '...' } Parameters const params = useParams() useParams take parameters. Returns useParams returns object containing current route's filled dynamic parameters. - property object active dynamic segment. - properties name segment's name, properties value segment filled with. - properties value either string array ofstring 's depending type dynamic segment. - route contains dynamic parameters, useParams returns empty object. - used Pages Router, useParams returnnull initial render updates properties following rules router ready. example: | Route | URL | useParams() | |---|---|---| app/shop/page.js | /shop | {} | app/shop/[slug]/page.js | /shop/1 | { slug: '1' } | app/shop/[tag]/[item]/page.js | /shop/1/2 | { tag: '1', item: '2' } | app/shop/[...slug]/page.js | /shop/1/2 | { slug: ['1', '2'] } | Version History | Version | Changes | |---|---| v13.3.0 | useParams introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-pathname", "title": "Functions: usePathname | Next.js", "text": "usePathname usePathname Client Component hook lets read current URL's pathname. app/example-client-component.tsx 'use client' import { usePathname } 'next/navigation' export default function ExampleClientComponent() { const pathname = usePathname() return <p>Current pathname: {pathname}</p> } usePathname intentionally requires using Client Component. important note Client Components de-optimization. integral part Server Components architecture. example, Client Component usePathname rendered HTML initial page load. navigating new route, component need re-fetched. Instead, component downloaded (in client JavaScript bundle), re-renders based current state. Good know: - Reading current URL Server Component supported. design intentional support layout state preserved across page navigations. - Compatibility mode: usePathname returnnull fallback route rendered apages directory page automatically statically optimized Next.js router ready.- using usePathname rewrites innext.config orMiddleware ,useState anduseEffect must also used order avoid hydration mismatch errors. See rewrites example information.- Next.js automatically update types detects app andpages directory project. Parameters const pathname = usePathname() usePathname take parameters. Returns usePathname returns string current URL's pathname. example: | URL | Returned value | |---|---| / | '/' | /dashboard | '/dashboard' | /dashboard?v=2 | '/dashboard' | /blog/hello-world | '/blog/hello-world' | Examples something response route change app/example-client-component.tsx 'use client' import { usePathname, useSearchParams } 'next/navigation' function ExampleClientComponent() { const pathname = usePathname() const searchParams = useSearchParams() useEffect(() => { // something here... }, [pathname, searchParams]) } | Version | Changes | |---|---| v13.0.0 | usePathname introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-report-web-vitals", "title": "Functions: useReportWebVitals | Next.js", "text": "useReportWebVitals useReportWebVitals hook allows report Core Web Vitals, used combination analytics service. 'use client' import { useReportWebVitals } 'next/web-vitals' export function WebVitals() { useReportWebVitals((metric) => { console.log(metric) }) return null } import { WebVitals } './_components/web-vitals' export default function Layout({ children }) { return ( <html> <body> <WebVitals /> {children} </body> </html> ) } Since useReportWebVitals hook requires the\"use client\" directive, performant approach create separate component root layout imports. confines client boundary exclusively theWebVitals component. useReportWebVitals metric object passed hook's argument consists number properties: id : Unique identifier metric context current page loadname : name performance metric. Possible values include names Web Vitals metrics (TTFB, FCP, LCP, FID, CLS) specific web application.delta : difference current value previous value metric. value typically milliseconds represents change metric's value time.entries : array Performance Entries associated metric. entries provide detailed information performance events related metric.navigationType : Indicates type navigation triggered metric collection. Possible values include\"navigate\" ,\"reload\" ,\"back_forward\" , and\"prerender\" .rating : qualitative rating metric value, providing assessment performance. Possible values are\"good\" ,\"needs-improvement\" , and\"poor\" . rating typically determined comparing metric value predefined thresholds indicate acceptable suboptimal performance.value : actual value duration performance entry, typically milliseconds. value provides quantitative measure performance aspect tracked metric. source value depends specific metric measured come various Performance APIs. Web Vitals Web Vitals set useful metrics aim capture user experience web page. following web vitals included: - Time First Byte (TTFB) - First Contentful Paint (FCP) - Largest Contentful Paint (LCP) - First Input Delay (FID) - Cumulative Layout Shift (CLS) - Interaction Next Paint (INP) handle results metrics using name property. 'use client' import { useReportWebVitals } 'next/web-vitals' export function WebVitals() { useReportWebVitals((metric) => { switch (metric.name) { case 'FCP': { // handle FCP results } case 'LCP': { // handle LCP results } // ... } }) } Usage Vercel Vercel Speed Insights useReportWebVitals , @vercel/speed-insights package instead. useReportWebVitals hook useful local development, using different service collecting Web Vitals. Sending results external systems send results endpoint measure track real user performance site. example: useReportWebVitals((metric) => { const body = JSON.stringify(metric) const url = 'https://example.com/analytics' // Use `navigator.sendBeacon()` available, falling back `fetch()`. (navigator.sendBeacon) { navigator.sendBeacon(url, body) } else { fetch(url, { body, method: 'POST', keepalive: true }) } }) Good know: use Google Analytics, using id value allow construct metric distributions manually (to calculate percentiles, etc.) useReportWebVitals(metric => { // Use `window.gtag` initialized Google Analytics example: // https://github.com/vercel/next.js/blob/canary/examples/with-google-analytics window.gtag('event', metric.name, { value: Math.round(metric.name === 'CLS' ? metric.value * 1000 : metric.value), // values must integers event_label: metric.id, // id unique current page load non_interaction: true, // avoids affecting bounce rate. }); } Read sending results Google Analytics. helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-router", "title": "Functions: useRouter | Next.js", "text": "useRouter useRouter hook allows programmatically change routes inside Client Components. Recommendation: Use <Link> component navigation unless specific requirement usinguseRouter . 'use client' import { useRouter } 'next/navigation' export default function Page() { const router = useRouter() return ( <button type=\"button\" onClick={() => router.push('/dashboard')}> Dashboard </button> ) } useRouter() router.push(href: string, { scroll: boolean }) : Perform client-side navigation provided route. Adds new entry browser\u2019s history stack.router.replace(href: string, { scroll: boolean }) : Perform client-side navigation provided route without adding new entry browser\u2019s history stack.router.refresh() : Refresh current route. Making new request server, re-fetching data requests, re-rendering Server Components. client merge updated React Server Component payload without losing unaffected client-side React (e.g.useState ) browser state (e.g. scroll position).router.prefetch(href: string) : Prefetch provided route faster client-side transitions.router.back() : Navigate back previous route browser\u2019s history stack.router.forward() : Navigate forwards next page browser\u2019s history stack. Good know: - must send untrusted unsanitized URLs router.push orrouter.replace , open site cross-site scripting (XSS) vulnerabilities. example,javascript: URLs sent torouter.push orrouter.replace executed context page.- <Link> component automatically prefetch routes become visible viewport.refresh() could re-produce result fetch requests cached. Dynamic APIs likecookies andheaders could also change response. Migrating next/router - useRouter hook imported fromnext/navigation notnext/router using App Router - pathname string removed replaced byusePathname() - query object removed replaced byuseSearchParams() router.events replaced. See below. View full migration guide. Examples Router events listen page changes composing Client Component hooks like usePathname useSearchParams . 'use client' import { useEffect } 'react' import { usePathname, useSearchParams } 'next/navigation' export function NavigationEvents() { const pathname = usePathname() const searchParams = useSearchParams() useEffect(() => { const url = `${pathname}?${searchParams}` console.log(url) // use current URL // ... }, [pathname, searchParams]) return '...' } imported layout. import { Suspense } 'react' import { NavigationEvents } './components/navigation-events' export default function Layout({ children }) { return ( <html lang=\"en\"> <body> {children} <Suspense fallback={null}> <NavigationEvents /> </Suspense> </body> </html> ) } Good know: <NavigationEvents> wrapped aSuspense boundary becauseuseSearchParams() causes client-side rendering closestSuspense boundary static rendering. Learn more. Disabling scroll top default, Next.js scroll top page navigating new route. disable behavior passing scroll: false router.push() router.replace() . 'use client' import { useRouter } 'next/navigation' export default function Page() { const router = useRouter() return ( <button type=\"button\" onClick={() => router.push('/dashboard', { scroll: false })} > Dashboard </button> ) } Version History | Version | Changes | |---|---| v13.0.0 | useRouter next/navigation introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-search-params", "title": "Functions: useSearchParams | Next.js", "text": "useSearchParams useSearchParams Client Component hook lets read current URL's query string. useSearchParams returns read-only version URLSearchParams interface. 'use client' import { useSearchParams } 'next/navigation' export default function SearchBar() { const searchParams = useSearchParams() const search = searchParams.get('search') // URL -> `/dashboard?search=my-project` // `search` -> 'my-project' return <>Search: {search}</> } Parameters const searchParams = useSearchParams() useSearchParams take parameters. Returns useSearchParams returns read-only version URLSearchParams interface, includes utility methods reading URL's query string: - URLSearchParams.get() : Returns first value associated search parameter. example:URL searchParams.get(\"a\") /dashboard?a=1 '1' /dashboard?a= '' /dashboard?b=3 null /dashboard?a=1&a=2 '1' - usegetAll() get values - URLSearchParams.has() : Returns boolean value indicating given parameter exists. example:URL searchParams.has(\"a\") /dashboard?a=1 true /dashboard?b=3 false - Learn read-only methods URLSearchParams , including thegetAll() ,keys() ,values() ,entries() ,forEach() , andtoString() . Good know: useSearchParams Client Component hook supported Server Components prevent stale values partial rendering.- application includes /pages directory,useSearchParams returnReadonlyURLSearchParams | null . Thenull value compatibility migration since search params cannot known pre-rendering page usegetServerSideProps Behavior Static Rendering route statically rendered, calling useSearchParams cause Client Component tree closest Suspense boundary client-side rendered. allows part route statically rendered dynamic part uses useSearchParams client-side rendered. recommend wrapping Client Component uses useSearchParams <Suspense/> boundary. allow Client Components statically rendered sent part initial HTML. Example. example: 'use client' import { useSearchParams } 'next/navigation' export default function SearchBar() { const searchParams = useSearchParams() const search = searchParams.get('search') // logged server using static rendering console.log(search) return <>Search: {search}</> } import { Suspense } 'react' import SearchBar './search-bar' // component passed fallback Suspense boundary // rendered place search bar initial HTML. // value available React hydration fallback // replaced `<SearchBar>` component. function SearchBarFallback() { return <>placeholder</> } export default function Page() { return ( <> <nav> <Suspense fallback={<SearchBarFallback />}> <SearchBar /> </Suspense> </nav> <h1>Dashboard</h1> </> ) } Dynamic Rendering route dynamically rendered, useSearchParams available server initial server render Client Component. example: 'use client' import { useSearchParams } 'next/navigation' export default function SearchBar() { const searchParams = useSearchParams() const search = searchParams.get('search') // logged server initial render // client subsequent navigations. console.log(search) return <>Search: {search}</> } import SearchBar './search-bar' export const dynamic = 'force-dynamic' export default function Page() { return ( <> <nav> <SearchBar /> </nav> <h1>Dashboard</h1> </> ) } Good know: Setting dynamic route segment config option toforce-dynamic used force dynamic rendering. Server Components Pages access search params Pages (Server Components), use searchParams prop. Layouts Unlike Pages, Layouts (Server Components) receive searchParams prop. shared layout re-rendered navigation could lead stale searchParams navigations. View detailed explanation. Instead, use Page searchParams prop useSearchParams hook Client Component, re-rendered client latest searchParams . Examples Updating searchParams use useRouter Link set new searchParams . navigation performed, current page.js receive updated searchParams prop. 'use client' export default function ExampleClientComponent() { const router = useRouter() const pathname = usePathname() const searchParams = useSearchParams() // Get new searchParams string merging current // searchParams provided key/value pair const createQueryString = useCallback( (name: string, value: string) => { const params = new URLSearchParams(searchParams.toString()) params.set(name, value) return params.toString() }, [searchParams] ) return ( <> <p>Sort By</p> {/* using useRouter */} <button onClick={() => { // <pathname>?sort=asc router.push(pathname + '?' + createQueryString('sort', 'asc')) }} > ASC </button> {/* using <Link> */} <Link href={ // <pathname>?sort=desc pathname + '?' + createQueryString('sort', 'desc') } > DESC </Link> </> ) } Version History | Version | Changes | |---|---| v13.0.0 | useSearchParams introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segment", "title": "Functions: useSelectedLayoutSegment | Next.js", "text": "useSelectedLayoutSegment useSelectedLayoutSegment Client Component hook lets read active route segment one level Layout called from. useful navigation UI, tabs inside parent layout change style depending active child segment. 'use client' import { useSelectedLayoutSegment } 'next/navigation' export default function ExampleClientComponent() { const segment = useSelectedLayoutSegment() return <p>Active segment: {segment}</p> } Good know: - Since useSelectedLayoutSegment Client Component hook, Layouts Server Components default,useSelectedLayoutSegment usually called via Client Component imported Layout.useSelectedLayoutSegment returns segment one level down. return active segments, seeuseSelectedLayoutSegments Parameters const segment = useSelectedLayoutSegment(parallelRoutesKey?: string) useSelectedLayoutSegment optionally accepts parallelRoutesKey , allows read active route segment within slot. Returns useSelectedLayoutSegment returns string active segment null one exist. example, given Layouts URLs below, returned segment would be: | Layout | Visited URL | Returned Segment | |---|---|---| app/layout.js | / | null | app/layout.js | /dashboard | 'dashboard' | app/dashboard/layout.js | /dashboard | null | app/dashboard/layout.js | /dashboard/settings | 'settings' | app/dashboard/layout.js | /dashboard/analytics | 'analytics' | app/dashboard/layout.js | /dashboard/analytics/monthly | 'analytics' | Examples Creating active link component use useSelectedLayoutSegment create active link component changes style depending active segment. example, featured posts list sidebar blog: 'use client' import Link 'next/link' import { useSelectedLayoutSegment } 'next/navigation' // *client* component imported blog layout export default function BlogNavLink({ slug, children, }: { slug: string children: React.ReactNode }) { // Navigating `/blog/hello-world` return 'hello-world' // selected layout segment const segment = useSelectedLayoutSegment() const isActive = slug === segment return ( <Link href={`/blog/${slug}`} // Change style depending whether link active style={{ fontWeight: isActive ? 'bold' : 'normal' }} > {children} </Link> ) } // Import Client Component parent Layout (Server Component) import { BlogNavLink } './blog-nav-link' import getFeaturedPosts './get-featured-posts' export default async function Layout({ children, }: { children: React.ReactNode }) { const featuredPosts = await getFeaturedPosts() return ( <div> {featuredPosts.map((post) => ( <div key={post.id}> <BlogNavLink slug={post.slug}>{post.title}</BlogNavLink> </div> ))} <div>{children}</div> </div> ) } Version History | Version | Changes | |---|---| v13.0.0 | useSelectedLayoutSegment introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segments", "title": "Functions: useSelectedLayoutSegments | Next.js", "text": "useSelectedLayoutSegments useSelectedLayoutSegments Client Component hook lets read active route segments Layout called from. useful creating UI parent Layouts need knowledge active child segments breadcrumbs. app/example-client-component.tsx 'use client' import { useSelectedLayoutSegments } 'next/navigation' export default function ExampleClientComponent() { const segments = useSelectedLayoutSegments() return ( <ul> {segments.map((segment, index) => ( <li key={index}>{segment}</li> ))} </ul> ) } Good know: - Since useSelectedLayoutSegments Client Component hook, Layouts Server Components default,useSelectedLayoutSegments usually called via Client Component imported Layout.- returned segments include Route Groups, might want included UI. use filter() array method remove items start bracket. Parameters const segments = useSelectedLayoutSegments(parallelRoutesKey?: string) useSelectedLayoutSegments optionally accepts parallelRoutesKey , allows read active route segment within slot. Returns useSelectedLayoutSegments returns array strings containing active segments one level layout hook called from. empty array none exist. example, given Layouts URLs below, returned segments would be: | Layout | Visited URL | Returned Segments | |---|---|---| app/layout.js | / | [] | app/layout.js | /dashboard | ['dashboard'] | app/layout.js | /dashboard/settings | ['dashboard', 'settings'] | app/dashboard/layout.js | /dashboard | [] | app/dashboard/layout.js | /dashboard/settings | ['settings'] | Version History | Version | Changes | |---|---| v13.0.0 | useSelectedLayoutSegments introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/functions/userAgent", "title": "Functions: userAgent | Next.js", "text": "userAgent userAgent helper extends Web Request API additional properties methods interact user agent object request. middleware.ts import { NextRequest, NextResponse, userAgent } 'next/server' export function middleware(request: NextRequest) { const url = request.nextUrl const { device } = userAgent(request) const viewport = device.type === 'mobile' ? 'mobile' : 'desktop' url.searchParams.set('viewport', viewport) return NextResponse.rewrite(url) } isBot boolean indicating whether request comes known bot. browser object containing information browser used request. name : string representing browser's name, orundefined identifiable.version : string representing browser's version, orundefined . device object containing information device used request. model : string representing model device, orundefined .type : string representing type device, asconsole ,mobile ,tablet ,smarttv ,wearable ,embedded , orundefined .vendor : string representing vendor device, orundefined . engine object containing information browser's engine. name : string representing engine's name. Possible values include:Amaya ,Blink ,EdgeHTML ,Flow ,Gecko ,Goanna ,iCab ,KHTML ,Links ,Lynx ,NetFront ,NetSurf ,Presto ,Tasman ,Trident ,w3m ,WebKit orundefined .version : string representing engine's version, orundefined . os object containing information operating system. name : string representing name OS, orundefined .version : string representing version OS, orundefined . cpu object containing information CPU architecture. architecture : string representing architecture CPU. Possible values include:68k ,amd64 ,arm ,arm64 ,armhf ,avr ,ia32 ,ia64 ,irix ,irix64 ,mips ,mips64 ,pa-risc ,ppc ,sparc ,sparc64 orundefined helpful?"},
{"source": "https://nextjs.org/docs/app/api-reference/turbopack", "title": "API Reference: Turbopack | Next.js", "text": "Turbopack Turbopack incremental bundler optimized JavaScript TypeScript, written Rust, built Next.js. Turbopack used Next.js pages app directories faster local development. enable Turbopack, use --turbopack flag running Next.js development server. { \"scripts\": { \"dev\": \"next dev --turbopack\", \"build\": \"next build\", \"start\": \"next start\", \"lint\": \"next lint\" } } Reference Supported features Turbopack Next.js requires zero-configuration users extended advanced use cases. learn currently supported features Turbopack, view API Reference. Unsupported features Turbopack currently supports next dev support next build . currently working support builds move closer towards stability. features currently supported: - Turbopack leverages Lightning CSS support low usage CSS Modules features :local and:global standalone pseudo classes. function variant supported, example::global(a) .- @value rule superseded CSS variables. :import and:export ICSS rules. - Invalid CSS comment syntax // - CSS comments written /* comment */ per specification. - Preprocessors Sass support alternative syntax comments. - CSS comments written webpack() configuration innext.config.js - Turbopack replaces Webpack, means webpack configuration supported. - configure Turbopack, see documentation. - subset Webpack loaders supported Turbopack. - Babel ( .babelrc )- Turbopack leverages SWC compiler transpilation optimizations. means Babel included default. - .babelrc file, might longer need Next.js includes common Babel plugins SWC transforms enabled. read compiler documentation. - still need use Babel verifying particular use case covered, leverage Turbopack's support custom webpack loaders include babel-loader . - Creating root layout automatically App Router. - behavior currently supported since changes input files, instead, error shown manually add root layout desired location. @next/font (legacy font support).@next/font deprecated favor ofnext/font .next/font fully supported Turbopack. - Relay transforms - planning implement future. - Blocking .css imports inpages/_document.tsx - Currently webpack Next.js blocks importing .css files inpages/_document.tsx - planning implement warning future. - Currently webpack Next.js blocks importing experimental.typedRoutes - planning implement future. experimental.nextScriptWorkers - planning implement future. experimental.sri.algorithm - planning implement future. experimental.fallbackNodePolyfills - planning implement future. experimental.esmExternals - currently planning support legacy esmExternals configuration Next.js Turbopack. - AMP. - currently planning support AMP Next.js Turbopack. - Yarn PnP - currently planning support Yarn PnP Next.js Turbopack. experimental.urlImports - currently planning support experimental.urlImports Next.js Turbopack. - currently planning support :import and:export ICSS rules- currently planning support :import and:export ICSS rules Next.js Turbopack Lightning CSS CSS parser Turbopack uses support rules. - currently planning support unstable_allowDynamic configuration edge runtime Examples Generating Trace Files Trace files allow Next.js team investigate improve performance metrics memory usage. generate trace file, append NEXT_TURBOPACK_TRACING=1 next dev --turbopack command, generate .next/trace-turbopack file. reporting issues related Turbopack performance memory usage, please include trace file GitHub issue. helpful?"},
{"source": "https://nextjs.org/docs/app/deep-dive", "title": "App Router: Deep Dive | Next.js", "text": "IntroductionApp RouterDeep DiveDeep DiveCachingAn overview caching mechanisms Next.js.PreviousServer Actions MutationsNextCachingWas helpful? supported.Send"},
{"source": "https://nextjs.org/docs/app/deep-dive/caching", "title": "Deep Dive: Caching | Next.js", "text": "Caching Next.js Next.js improves application's performance reduces costs caching rendering work data requests. page provides in-depth look Next.js caching mechanisms, APIs use configure them, interact other. Good know: page helps understand Next.js works hood essential knowledge productive Next.js. Next.js' caching heuristics determined API usage defaults best performance zero minimal configuration. instead want jump examples, start here. Overview Here's high-level overview different caching mechanisms purpose: | Mechanism | | | Purpose | Duration | |---|---|---|---|---| | Request Memoization | Return values functions | Server | Re-use data React Component tree | Per-request lifecycle | | Data Cache | Data | Server | Store data across user requests deployments | Persistent (can revalidated) | | Full Route Cache | HTML RSC payload | Server | Reduce rendering cost improve performance | Persistent (can revalidated) | | Router Cache | RSC Payload | Client | Reduce server requests navigation | User session time-based | default, Next.js cache much possible improve performance reduce cost. means routes statically rendered data requests cached unless opt out. diagram shows default caching behavior: route statically rendered build time static route first visited. Caching behavior changes depending whether route statically dynamically rendered, data cached uncached, whether request part initial visit subsequent navigation. Depending use case, configure caching behavior individual routes data requests. Request Memoization Next.js extends fetch API automatically memoize requests URL options. means call fetch function data multiple places React component tree executing once. example, need use data across route (e.g. Layout, Page, multiple components), fetch data top tree, forward props components. Instead, fetch data components need without worrying performance implications making multiple requests across network data. async function getItem() { // `fetch` function automatically memoized result // cached const res = await fetch('https://.../item/1') return res.json() } // function called twice, executed first time const item = await getItem() // cache MISS // second call could anywhere route const item = await getItem() // cache HIT Request Memoization Works - rendering route, first time particular request called, result memory cache MISS . - Therefore, function executed, data fetched external source, result stored memory. - Subsequent function calls request render pass cache HIT , data returned memory without executing function. - route rendered rendering pass complete, memory \"reset\" request memoization entries cleared. Good know: - Request memoization React feature, Next.js feature. included show interacts caching mechanisms. - Memoization applies GET method infetch requests.- Memoization applies React Component tree, means: - applies fetch requests ingenerateMetadata ,generateStaticParams , Layouts, Pages, Server Components.- apply fetch requests Route Handlers part React component tree.- cases fetch suitable (e.g. database clients, CMS clients, GraphQL clients), use Reactcache function memoize functions. Duration cache lasts lifetime server request React component tree finished rendering. Revalidating Since memoization shared across server requests applies rendering, need revalidate it. Opting Memoization applies GET method fetch requests, methods, POST DELETE , memoized. default behavior React optimization recommend opting it. manage individual requests, use signal property AbortController . However, opt requests memoization, rather, abort in-flight requests. const { signal } = new AbortController() fetch(url, { signal }) Data Cache Next.js built-in Data Cache persists result data fetches across incoming server requests deployments. possible Next.js extends native fetch API allow request server set persistent caching semantics. Good know: browser, cache option offetch indicates request interact browser's HTTP cache, Next.js, thecache option indicates server-side request interact server's Data Cache. use cache next.revalidate options fetch configure caching behavior. Data Cache Works - first time fetch request the'force-cache' option called rendering, Next.js checks Data Cache cached response. - cached response found, returned immediately memoized. - cached response found, request made data source, result stored Data Cache, memoized. - uncached data (e.g. cache option defined using{ cache: 'no-store' } ), result always fetched data source, memoized. - Whether data cached uncached, requests always memoized avoid making duplicate requests data React render pass. Differences Data Cache Request Memoization caching mechanisms help improve performance re-using cached data, Data Cache persistent across incoming requests deployments, whereas memoization lasts lifetime request. Duration Data Cache persistent across incoming requests deployments unless revalidate opt-out. Revalidating Cached data revalidated two ways, with: - Time-based Revalidation: Revalidate data certain amount time passed new request made. useful data changes infrequently freshness critical. - On-demand Revalidation: Revalidate data based event (e.g. form submission). On-demand revalidation use tag-based path-based approach revalidate groups data once. useful want ensure latest data shown soon possible (e.g. content headless CMS updated). Time-based Revalidation revalidate data timed interval, use next.revalidate option fetch set cache lifetime resource (in seconds). // Revalidate every hour fetch('https://...', { next: { revalidate: 3600 } }) Alternatively, use Route Segment Config options configure fetch requests segment cases able use fetch . Time-based Revalidation Works - first time fetch request revalidate called, data fetched external data source stored Data Cache. - requests called within specified timeframe (e.g. 60-seconds) return cached data. - timeframe, next request still return cached (now stale) data. - Next.js trigger revalidation data background. - data fetched successfully, Next.js update Data Cache fresh data. - background revalidation fails, previous data kept unaltered. similar stale-while-revalidate behavior. On-demand Revalidation Data revalidated on-demand path (revalidatePath ) cache tag (revalidateTag ). On-Demand Revalidation Works - first time fetch request called, data fetched external data source stored Data Cache. - on-demand revalidation triggered, appropriate cache entries purged cache. - different time-based revalidation, keeps stale data cache fresh data fetched. - next time request made, cache MISS again, data fetched external data source stored Data Cache. Opting want cache response fetch , following: let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' }) Full Route Cache Related terms: may see terms Automatic Static Optimization, Static Site Generation, Static Rendering used interchangeably refer process rendering caching routes application build time. Next.js automatically renders caches routes build time. optimization allows serve cached route instead rendering server every request, resulting faster page loads. understand Full Route Cache works, helpful look React handles rendering, Next.js caches result: 1. React Rendering Server server, Next.js uses React's APIs orchestrate rendering. rendering work split chunks: individual routes segments Suspense boundaries. chunk rendered two steps: - React renders Server Components special data format, optimized streaming, called React Server Component Payload. - Next.js uses React Server Component Payload Client Component JavaScript instructions render HTML server. means wait everything render caching work sending response. Instead, stream response work completed. React Server Component Payload? React Server Component Payload compact binary representation rendered React Server Components tree. used React client update browser's DOM. React Server Component Payload contains: - rendered result Server Components - Placeholders Client Components rendered references JavaScript files - props passed Server Component Client Component learn more, see Server Components documentation. 2. Next.js Caching Server (Full Route Cache) default behavior Next.js cache rendered result (React Server Component Payload HTML) route server. applies statically rendered routes build time, revalidation. 3. React Hydration Reconciliation Client request time, client: - HTML used immediately show fast non-interactive initial preview Client Server Components. - React Server Components Payload used reconcile Client rendered Server Component trees, update DOM. - JavaScript instructions used hydrate Client Components make application interactive. 4. Next.js Caching Client (Router Cache) React Server Component Payload stored client-side Router Cache - separate in-memory cache, split individual route segment. Router Cache used improve navigation experience storing previously visited routes prefetching future routes. 5. Subsequent Navigations subsequent navigations prefetching, Next.js check React Server Components Payload stored Router Cache. so, skip sending new request server. route segments cache, Next.js fetch React Server Components Payload server, populate Router Cache client. Static Dynamic Rendering Whether route cached build time depends whether statically dynamically rendered. Static routes cached default, whereas dynamic routes rendered request time, cached. diagram shows difference statically dynamically rendered routes, cached uncached data: Learn static dynamic rendering. Duration default, Full Route Cache persistent. means render output cached across user requests. Invalidation two ways invalidate Full Route Cache: - Revalidating Data: Revalidating Data Cache, turn invalidate Router Cache re-rendering components server caching new render output. - Redeploying: Unlike Data Cache, persists across deployments, Full Route Cache cleared new deployments. Opting opt Full Route Cache, words, dynamically render components every incoming request, by: - Using Dynamic API: opt route Full Route Cache dynamically render request time. Data Cache still used. - Using dynamic = 'force-dynamic' orrevalidate = 0 route segment config options: skip Full Route Cache Data Cache. Meaning components rendered data fetched every incoming request server. Router Cache still apply client-side cache. - Opting Data Cache: route fetch request cached, opt route Full Route Cache. data specificfetch request fetched every incoming request. Otherfetch requests opt caching still cached Data Cache. allows hybrid cached uncached data. Client-side Router Cache Next.js in-memory client-side router cache stores RSC payload route segments, split layouts, loading states, pages. user navigates routes, Next.js caches visited route segments prefetches routes user likely navigate to. results instant back/forward navigation, full-page reload navigations, preservation React state browser state. Router Cache: - Layouts cached reused navigation (partial rendering). - Loading states cached reused navigation instant navigation. - Pages cached default, reused browser backward forward navigation. enable caching page segments using experimental staleTimes config option. Good know: cache specifically applies Next.js Server Components, different browser's bfcache, though similar result. Duration cache stored browser's temporary memory. Two factors determine long router cache lasts: - Session: cache persists across navigation. However, cleared page refresh. - Automatic Invalidation Period: cache layouts loading states automatically invalidated specific time. duration depends resource prefetched, resource statically generated: - Default Prefetching ( prefetch={null} unspecified): cached dynamic pages, 5 minutes static pages. - Full Prefetching ( prefetch={true} orrouter.prefetch ): 5 minutes static & dynamic pages. - Default Prefetching ( page refresh clear cached segments, automatic invalidation period affects individual segment time prefetched. Good know: experimental staleTimes config option used adjust automatic invalidation times mentioned above. Invalidation two ways invalidate Router Cache: - Server Action: - Revalidating data on-demand path ( revalidatePath ) cache tag (revalidateTag ) - Using cookies.set orcookies.delete invalidates Router Cache prevent routes use cookies becoming stale (e.g. authentication). - Revalidating data on-demand path ( - Calling router.refresh invalidate Router Cache make new request server current route. Opting Next.js 15, page segments opted default. Good know: also opt prefetching setting prefetch prop the<Link> component tofalse . Cache Interactions configuring different caching mechanisms, important understand interact other: Data Cache Full Route Cache - Revalidating opting Data Cache invalidate Full Route Cache, render output depends data. - Invalidating opting Full Route Cache affect Data Cache. dynamically render route cached uncached data. useful page uses cached data, components rely data needs fetched request time. dynamically render without worrying performance impact re-fetching data. Data Cache Client-side Router cache - immediately invalidate Data Cache Router cache, use revalidatePath orrevalidateTag Server Action. - Revalidating Data Cache Route Handler immediately invalidate Router Cache Route Handler tied specific route. means Router Cache continue serve previous payload hard refresh, automatic invalidation period elapsed. APIs following table provides overview different Next.js APIs affect caching: | API | Router Cache | Full Route Cache | Data Cache | React Cache | |---|---|---|---|---| <Link prefetch> | Cache | ||| router.prefetch | Cache | ||| router.refresh | Revalidate | ||| fetch | Cache | Cache | || fetch options.cache | Cache Opt | ||| fetch options.next.revalidate | Revalidate | Revalidate | || fetch options.next.tags | Cache | Cache | || revalidateTag | Revalidate (Server Action) | Revalidate | Revalidate | | revalidatePath | Revalidate (Server Action) | Revalidate | Revalidate | | const revalidate | Revalidate Opt | Revalidate Opt | || const dynamic | Cache Opt | Cache Opt | || cookies | Revalidate (Server Action) | Opt | || headers , searchParams | Opt | ||| generateStaticParams | Cache | ||| React.cache | Cache | ||| unstable_cache | Cache | <Link> default, <Link> component automatically prefetches routes Full Route Cache adds React Server Component Payload Router Cache. disable prefetching, set prefetch prop false . skip cache permanently, route segment still cached client-side user visits route. Learn <Link> component. router.prefetch prefetch option useRouter hook used manually prefetch route. adds React Server Component Payload Router Cache. See useRouter hook API reference. router.refresh refresh option useRouter hook used manually refresh route. completely clears Router Cache, makes new request server current route. refresh affect Data Full Route Cache. rendered result reconciled client preserving React state browser state. See useRouter hook API reference. fetch Data returned fetch automatically cached Data Cache. default caching behavior fetch (e.g., cache option specified) equal setting cache option no-store : let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' }) See fetch API Reference options. fetch options.cache opt individual fetch caching setting cache option force-cache : // Opt caching fetch(`https://...`, { cache: 'force-cache' }) See fetch API Reference options. fetch options.next.revalidate use next.revalidate option fetch set revalidation period (in seconds) individual fetch request. revalidate Data Cache, turn revalidate Full Route Cache. Fresh data fetched, components re-rendered server. // Revalidate 1 hour fetch(`https://...`, { next: { revalidate: 3600 } }) See fetch API reference options. fetch options.next.tags revalidateTag Next.js cache tagging system fine-grained data caching revalidation. - using fetch orunstable_cache , option tag cache entries one tags. - Then, call revalidateTag purge cache entries associated tag. example, set tag fetching data: // Cache data tag fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } }) Then, call revalidateTag tag purge cache entry: // Revalidate entries specific tag revalidateTag('a') two places use revalidateTag , depending trying achieve: - Route Handlers - revalidate data response third party event (e.g. webhook). invalidate Router Cache immediately Router Handler tied specific route. - Server Actions - revalidate data user action (e.g. form submission). invalidate Router Cache associated route. revalidatePath revalidatePath allows manually revalidate data re-render route segments specific path single operation. Calling revalidatePath method revalidates Data Cache, turn invalidates Full Route Cache. revalidatePath('/') two places use revalidatePath , depending trying achieve: - Route Handlers - revalidate data response third party event (e.g. webhook). - Server Actions - revalidate data user interaction (e.g. form submission, clicking button). See revalidatePath API reference information. revalidatePath vs.router.refresh :Calling router.refresh clear Router cache, re-render route segments server without invalidating Data Cache Full Route Cache.The difference revalidatePath purges Data Cache Full Route Cache, whereasrouter.refresh() change Data Cache Full Route Cache, client-side API. Dynamic APIs Dynamic APIs like cookies headers , searchParams prop Pages depend runtime incoming request information. Using opt route Full Route Cache, words, route dynamically rendered. cookies Using cookies.set cookies.delete Server Action invalidates Router Cache prevent routes use cookies becoming stale (e.g. reflect authentication changes). See cookies API reference. Segment Config Options Route Segment Config options used override route segment defaults able use fetch API (e.g. database client 3rd party libraries). following Route Segment Config options opt Full Route Cache: const dynamic = 'force-dynamic' config option opt fetches Data Cache (i.e. no-store ): const fetchCache = 'default-no-store' See fetchCache see advanced options. See Route Segment Config documentation options. generateStaticParams dynamic segments (e.g. app/blog/[slug]/page.js ), paths provided generateStaticParams cached Full Route Cache build time. request time, Next.js also cache paths known build time first time visited. statically render paths build time, supply full list paths generateStaticParams : export async function generateStaticParams() { const posts = await fetch('https://.../posts').then((res) => res.json()) return posts.map((post) => ({ slug: post.slug, })) } statically render subset paths build time, rest first time visited runtime, return partial list paths: export async function generateStaticParams() { const posts = await fetch('https://.../posts').then((res) => res.json()) // Render first 10 posts build time return posts.slice(0, 10).map((post) => ({ slug: post.slug, })) } statically render paths first time visited, return empty array (no paths rendered build time) utilize export const dynamic = 'force-static' : export async function generateStaticParams() { return [] } Good know: must return array generateStaticParams , even empty. Otherwise, route dynamically rendered. export const dynamic = 'force-static' disable caching request time, add export const dynamicParams = false option route segment. config option used, paths provided generateStaticParams served, routes 404 match (in case catch-all routes). React cache function React cache function allows memoize return value function, allowing call function multiple times executing once. Since fetch requests automatically memoized, need wrap React cache . However, use cache manually memoize data requests use cases fetch API suitable. example, database clients, CMS clients, GraphQL clients. import { cache } 'react' import db '@/lib/db' export const getItem = cache(async (id: string) => { const item = await db.item.findUnique({ id }) return item }) helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started", "title": "App Router: Getting Started | Next.js", "text": "Getting Started Installation Create new Next.js application `create-next-app` CLI, set TypeScript, ESLint, Module Path Aliases. Project Structure overview folder file conventions Next.js, organize project. Layouts Pages Create first pages layouts, link them. Images Fonts Learn optimize images fonts. CSS Learn different ways add CSS application, including CSS Modules, Global CSS, Tailwind CSS, more. Fetching Data Start fetching data streaming content application. Updating Data Learn update data Next.js application. Error Handling Learn display expected errors handle uncaught exceptions. helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/css", "title": "Getting Started: CSS | Next.js", "text": "use CSS application Next.js provides several ways use CSS application, including: page guide use approaches. CSS Modules CSS Modules locally scope CSS generating unique class names. allows use class different files without worrying collisions. start using CSS Modules, create new file extension .module.css import component inside app directory: .blog { padding: 24px; } import styles './styles.module.css' export default function Page({ children }: { children: React.ReactNode }) { return <main className={styles.blog}>{children}</main> } Global CSS use global CSS apply styles across application. use global styles, create new CSS file, example app/global.css : body { padding: 20px 20px 60px; max-width: 680px; margin: 0 auto; } Import file root layout (app/layout.js ) apply styles every route application: // styles apply every route application import './global.css' export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body>{children}</body> </html> ) } Good know: Global styles imported layout, page, component inside app directory. However, since Next.js uses React's built-in support stylesheets integrate Suspense. built-in support currently remove stylesheets navigate routes. Therefore, recommend using global styles truly global CSS, CSS Modules scoped CSS. Tailwind CSS Tailwind CSS utility-first CSS framework integrates seamlessly Next.js. Installing Tailwind start using Tailwind, install necessary Tailwind CSS packages: npm install -D tailwindcss @tailwindcss/postcss postcss Configuring Tailwind Create postcss.config.mjs file root project add @tailwindcss/postcss plugin PostCSS configuration: /** @type {import('tailwindcss').Config} */ export default { plugins: { '@tailwindcss/postcss': {}, }, } Using Tailwind Add Tailwind directives Global Stylesheet: @import 'tailwindcss'; Then, import styles root layout: import type { Metadata } 'next' // styles apply every route application import './globals.css' export const metadata: Metadata = { title: 'Create Next App', description: 'Generated create next app', } export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body>{children}</body> </html> ) } Lastly, start writing Tailwind's utility classes application. export default function Page() { return <h1 className=\"text-3xl font-bold underline\">Hello, Next.js!</h1> } Sass Next.js integrates Sass using .scss .sass extensions syntax. also use component-level Sass via CSS Modules .module.scss .module.sass extension. Installing Sass start using Sass, install sass package: npm install --save-dev sass Customizing Sass options want configure Sass options, use sassOptions option next.config.js . import type { NextConfig } 'next' const nextConfig: NextConfig = { sassOptions: { additionalData: `$var: red;`, }, } export default nextConfig CSS-in-JS Warning: CSS-in-JS libraries require runtime JavaScript currently supported React Server Components. Using CSS-in-JS newer React features like Server Components Streaming requires library authors support latest version React. following libraries supported Client Components app directory (alphabetical): ant-design chakra-ui @fluentui/react-components kuma-ui @mui/material @mui/joy pandacss styled-jsx styled-components stylex tamagui tss-react vanilla-extract following currently working support: want style Server Components, recommend using CSS Modules solutions output CSS files, like Tailwind CSS. Configuring CSS-in-JS configure CSS-in-JS, need to: - Create style registry collect CSS rules render. - Use useServerInsertedHTML hook inject rules content might use them. - Create Client Component wraps app style registry initial server-side rendering. styled-jsx configure styled-jsx application, create new registry: 'use client' import React, { useState } 'react' import { useServerInsertedHTML } 'next/navigation' import { StyleRegistry, createStyleRegistry } 'styled-jsx' export default function StyledJsxRegistry({ children, }: { children: React.ReactNode }) { // create stylesheet lazy initial state // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state const [jsxStyleRegistry] = useState(() => createStyleRegistry()) useServerInsertedHTML(() => { const styles = jsxStyleRegistry.styles() jsxStyleRegistry.flush() return <>{styles}</> }) return <StyleRegistry registry={jsxStyleRegistry}>{children}</StyleRegistry> } Then, wrap root layout registry: import StyledJsxRegistry './registry' export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html> <body> <StyledJsxRegistry>{children}</StyledJsxRegistry> </body> </html> ) } styled-components use styled-components , enable next.config.js : import type { NextConfig } 'next' const nextConfig: NextConfig = { compiler: { styledComponents: true, }, } export default nextConfig Then, use styled-components API create global registry component collect CSS style rules generated render, function return rules. use useServerInsertedHTML hook inject styles collected registry <head> HTML tag root layout. 'use client' import React, { useState } 'react' import { useServerInsertedHTML } 'next/navigation' import { ServerStyleSheet, StyleSheetManager } 'styled-components' export default function StyledComponentsRegistry({ children, }: { children: React.ReactNode }) { // create stylesheet lazy initial state // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state const [styledComponentsStyleSheet] = useState(() => new ServerStyleSheet()) useServerInsertedHTML(() => { const styles = styledComponentsStyleSheet.getStyleElement() styledComponentsStyleSheet.instance.clearTag() return <>{styles}</> }) (typeof window !== 'undefined') return <>{children}</> return ( <StyleSheetManager sheet={styledComponentsStyleSheet.instance}> {children} </StyleSheetManager> ) } Wrap children root layout style registry component: import StyledComponentsRegistry './lib/registry' export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html> <body> <StyledComponentsRegistry>{children}</StyledComponentsRegistry> </body> </html> ) } External stylesheets Stylesheets published external packages imported anywhere app directory, including colocated components: import 'bootstrap/dist/css/bootstrap.css' export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body className=\"container\">{children}</body> </html> ) } External stylesheets must directly imported npm package downloaded colocated codebase. cannot use <link rel=\"stylesheet\" /> . API Reference helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/deploying", "title": "Getting Started: Deploying | Next.js", "text": "deploy Next.js application Next.js deployed Node.js server, Docker container, static export, adapted run different platforms. | Deployment Option | Feature Support | |---|---| | Node.js server | | | Docker container | | | Static export | Limited | | Adapters | Platform-specific | Node.js server Next.js deployed provider supports Node.js. Ensure package.json \"build\" \"start\" scripts: { \"scripts\": { \"dev\": \"next dev\", \"build\": \"next build\", \"start\": \"next start\" } } Then, run npm run build build application npm run start start Node.js server. server supports Next.js features. needed, also eject custom server. Node.js deployments support Next.js features. Learn configure infrastructure. Templates Docker Next.js deployed provider supports Docker containers. includes container orchestrators like Kubernetes cloud provider runs Docker. Docker deployments support Next.js features. Learn configure infrastructure. Templates Static export Next.js enables starting static site Single-Page Application (SPA), later optionally upgrading use features require server. Since Next.js supports static exports, deployed hosted web server serve HTML/CSS/JS static assets. includes tools like AWS S3, Nginx, Apache. Running static export support Next.js features require server. Learn more. Templates Adapters Next.js adapted run different platforms support infrastructure capabilities. Refer provider's documentation information supported Next.js features: Note: working Deployment Adapters API platforms adopt. completion, add documentation write adapters. helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/error-handling", "title": "Getting Started: Error Handling | Next.js", "text": "handle errors Errors divided two categories: expected errors uncaught exceptions. page walk handle errors Next.js application. Handling expected errors Expected errors occur normal operation application, server-side form validation failed requests. errors handled explicitly returned client. Server Actions use useActionState hook manage state Server Functions handle expected errors. Avoid using try /catch blocks expected errors. Instead, model expected errors return values, thrown exceptions. 'use server' export async function createPost(prevState: any, formData: FormData) { const title = formData.get('title') const content = formData.get('content') const res = await fetch('https://api.vercel.app/posts', { method: 'POST', body: { title, content }, }) const json = await res.json() (!res.ok) { return { message: 'Failed create post' } } } Then, pass action useActionState hook use returned state display error message. 'use client' import { useActionState } 'react' import { createPost } '@/app/actions' const initialState = { message: '', } export function Form() { const [state, formAction, pending] = useActionState(createPost, initialState) return ( <form action={formAction}> <label htmlFor=\"title\">Title</label> <input type=\"text\" id=\"title\" name=\"title\" required /> <label htmlFor=\"content\">Content</label> <textarea id=\"content\" name=\"content\" required /> {state?.message && <p aria-live=\"polite\">{state.message}</p>} <button disabled={pending}>Create Post</button> </form> ) } Server Components fetching data inside Server Component, use response conditionally render error message redirect . export default async function Page() { const res = await fetch(`https://...`) const data = await res.json() (!res.ok) { return 'There error.' } return '...' } found call notFound function within route segment use not-found.js file show 404 UI. import { getPostBySlug } '@/lib/posts' export default async function Page({ params }: { params: { slug: string } }) { const post = getPostBySlug((await params).slug) (!post) { notFound() } return <div>{post.title}</div> } export default function NotFound() { return <div>404 - Page Found</div> } Handling uncaught exceptions Uncaught exceptions unexpected errors indicate bugs issues occur normal flow application. handled throwing errors, caught error boundaries. Nested error boundaries Next.js uses error boundaries handle uncaught exceptions. Error boundaries catch errors child components display fallback UI instead component tree crashed. Create error boundary adding error.js file inside route segment exporting React component: 'use client' // Error boundaries must Client Components import { useEffect } 'react' export default function Error({ error, reset, }: { error: Error & { digest?: string } reset: () => void }) { useEffect(() => { // Log error error reporting service console.error(error) }, [error]) return ( <div> <h2>Something went wrong!</h2> <button onClick={ // Attempt recover trying re-render segment () => reset() } > Try </button> </div> ) } Errors bubble nearest parent error boundary. allows granular error handling placing error.tsx files different levels route hierarchy. Global errors less common, handle errors root layout using global-error.js file, located root app directory, even leveraging internationalization. Global error UI must define <html> <body> tags, since replacing root layout template active. 'use client' // Error boundaries must Client Components export default function GlobalError({ error, reset, }: { error: Error & { digest?: string } reset: () => void }) { return ( // global-error must include html body tags <html> <body> <h2>Something went wrong!</h2> <button onClick={() => reset()}>Try again</button> </body> </html> ) } API Reference helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/fetching-data", "title": "Getting Started: Fetching Data | Next.js", "text": "fetch data stream page walk fetch data Server Components Client Components. well stream content depends data. Fetching data Server Components fetch data Server Components using: - fetch API - ORM database fetch API fetch data fetch API, turn component asynchronous function, await fetch call. example: export default async function Page() { const data = await fetch('https://api.vercel.app/blog') const posts = await data.json() return ( <ul> {posts.map((post) => ( <li key={post.id}>{post.title}</li> ))} </ul> ) } ORM database fetch data ORM database turning component asynchronous function, awaiting call: import { db, posts } '@/lib/db' export default async function Page() { const allPosts = await db.select().from(posts) return ( <ul> {allPosts.map((post) => ( <li key={post.id}>{post.title}</li> ))} </ul> ) } Client Components two ways fetch data Client Components, using: - React's use hook - community library like SWR React Query use hook use React's use hook stream data server client. Start fetching data Server component, pass promise Client Component prop: import Posts '@/app/ui/posts import { Suspense } 'react' export default function Page() { // await data fetching function const posts = getPosts() return ( <Suspense fallback={<div>Loading...</div>}> <Posts posts={posts} /> </Suspense> ) } Then, Client Component, use use hook read promise: 'use client' import { use } 'react' export default function Posts({ posts, }: { posts: Promise<{ id: string; title: string }[]> }) { const allPosts = use(posts) return ( <ul> {allPosts.map((post) => ( <li key={post.id}>{post.title}</li> ))} </ul> ) } example above, need wrap <Posts /> component <Suspense> boundary. means fallback shown promise resolved. Learn streaming. Community libraries use community library like SWR React Query fetch data Client Components. libraries semantics caching, streaming, features. example, SWR: 'use client' import useSWR 'swr' const fetcher = (url) => fetch(url).then((r) => r.json()) export default function BlogPage() { const { data, error, isLoading } = useSWR( 'https://api.vercel.app/blog', fetcher ) (isLoading) return <div>Loading...</div> (error) return <div>Error: {error.message}</div> return ( <ul> {data.map((post: { id: string; title: string }) => ( <li key={post.id}>{post.title}</li> ))} </ul> ) } Streaming Warning: content assumes dynamicIO config option enabled application. flag introduced Next.js 15 canary. using async/await Server Components, Next.js opt dynamic rendering. means data fetched rendered server every user request. slow data requests, whole route blocked rendering. improve initial load time user experience, use streaming break page's HTML smaller chunks progressively send chunks server client. two ways implement streaming application: - loading.js file - React's <Suspense> component loading.js create loading.js file folder page stream entire page data fetched. example, stream app/blog/page.js , add file inside app/blog folder. export default function Loading() { // Define Loading UI return <div>Loading...</div> } navigation, user immediately see layout loading state page rendered. new content automatically swapped rendering complete. Behind-the-scenes, loading.js nested inside layout.js , automatically wrap page.js file children <Suspense> boundary. approach works well route segments (layouts pages), granular streaming, use <Suspense> . <Suspense> <Suspense> allows granular parts page stream. example, immediately show page content falls outside <Suspense> boundary, stream list blog posts inside boundary. import { Suspense } 'react' import BlogList '@/components/BlogList' import BlogListSkeleton '@/components/BlogListSkeleton' export default function BlogPage() { return ( <div> {/* content sent client immediately */} <header> <h1>Welcome Blog</h1> <p>Read latest posts below.</p> </header> <main> {/* content wrapped <Suspense> boundary streamed */} <Suspense fallback={<BlogListSkeleton />}> <BlogList /> </Suspense> </main> </div> ) } Creating meaningful loading states instant loading state fallback UI shown immediately user navigation. best user experience, recommend designing loading states meaningful help users understand app responding. example, use skeletons spinners, small meaningful part future screens cover photo, title, etc. development, preview inspect loading state components using React Devtools. API Reference helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/fonts", "title": "Getting Started: Fonts | Next.js", "text": "use fonts next/font module automatically optimizes fonts removes external network requests improved privacy performance. includes built-in self-hosting font file. means optimally load web fonts layout shift. start using next/font , import next/font/local next/font/google , call function appropriate options, set className element want apply font to. example: import { Geist } 'next/font/google' const geist = Geist({ subsets: ['latin'], }) export default function Layout({ children }: { children: React.ReactNode }) { return ( <html lang=\"en\" className={geist.className}> <body>{children}</body> </html> ) } Fonts scoped component used in. apply font entire application, add Root Layout. Google fonts automatically self-host Google Font. Fonts included stored static assets served domain deployment, meaning requests sent Google browser user visits site. start using Google Font, import chosen font next/font/google : import { Geist } 'next/font/google' const geist = Geist({ subsets: ['latin'], }) export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\" className={geist.className}> <body>{children}</body> </html> ) } recommend using variable fonts best performance flexibility. can't use variable font, need specify weight: import { Roboto } 'next/font/google' const roboto = Roboto({ weight: '400', subsets: ['latin'], }) export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\" className={roboto.className}> <body>{children}</body> </html> ) } Local fonts use local font, import font next/font/local specify src local font file. Fonts stored public folder. example: import localFont 'next/font/local' const myFont = localFont({ src: './my-font.woff2', }) export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\" className={myFont.className}> <body>{children}</body> </html> ) } want use multiple files single font family, src array: const roboto = localFont({ src: [ { path: './Roboto-Regular.woff2', weight: '400', style: 'normal', }, { path: './Roboto-Italic.woff2', weight: '400', style: 'italic', }, { path: './Roboto-Bold.woff2', weight: '700', style: 'normal', }, { path: './Roboto-BoldItalic.woff2', weight: '700', style: 'italic', }, ], }) API Reference helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/images", "title": "Getting Started: Images | Next.js", "text": "optimize images Next.js <Image> component extends HTML <img> element provide: - Size optimization: Automatically serving correctly sized images device, using modern image formats like WebP. - Visual stability: Preventing layout shift automatically images loading. - Faster page loads: loading images enter viewport using native browser lazy loading, optional blur-up placeholders. - Asset flexibility: Resizing images on-demand, even images stored remote servers. start using <Image> , import next/image render within component. import Image 'next/image' export default function Page() { return <Image src=\"\" alt=\"\" /> } src property local remote image. \ud83c\udfa5 Watch: Learn use next/image \u2192 YouTube (9 minutes). Local images store static files, like images fonts, folder called public root directory. Files inside public referenced code starting base URL (/ ). import Image 'next/image' export default function Page() { return ( <Image src=\"/profile.png\" alt=\"Picture author\" // width={500} automatically provided // height={500} automatically provided // blurDataURL=\"data:...\" automatically provided // placeholder=\"blur\" // Optional blur-up loading /> ) } using local images, Next.js automatically determine intrinsic width height image based imported file. values used determine image ratio prevent Cumulative Layout Shift image loading. Remote images use remote image, provide URL string src property. import Image 'next/image' export default function Page() { return ( <Image src=\"https://s3.amazonaws.com/my-bucket/profile.png\" alt=\"Picture author\" width={500} height={500} /> ) } Since Next.js access remote files build process, need provide width , height optional blurDataURL props manually. width height used infer correct aspect ratio image avoid layout shift image loading in. safely allow images remote servers, need define list supported URL patterns next.config.js . specific possible prevent malicious usage. example, following configuration allow images specific AWS S3 bucket: import type { NextConfig } 'next' const config: NextConfig = { images: { remotePatterns: [ { protocol: 'https', hostname: 's3.amazonaws.com', port: '', pathname: '/my-bucket/**', search: '', }, ], }, } export default config API Reference helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/installation", "title": "Getting Started: Installation | Next.js", "text": "set new Next.js project System requirements - Node.js 18.18 later. - macOS, Windows (including WSL), Linux supported. Automatic installation recommend starting new Next.js app using create-next-app , sets everything automatically you. create project, run: npx create-next-app@latest installation, see following prompts: project named? my-app Would like use TypeScript? / Yes Would like use ESLint? / Yes Would like use Tailwind CSS? / Yes Would like code inside `src/` directory? / Yes Would like use App Router? (recommended) / Yes Would like use Turbopack `next dev`? / Yes Would like customize import alias (`@/*` default)? / Yes import alias would like configured? @/* prompts, create-next-app create folder project name install required dependencies. Manual installation manually create new Next.js app, install required packages: npm install next@latest react@latest react-dom@latest Open package.json file add following scripts : { \"scripts\": { \"dev\": \"next dev\", \"build\": \"next build\", \"start\": \"next start\", \"lint\": \"next lint\" } } scripts refer different stages developing application: dev : runsnext dev start Next.js development mode.build : runsnext build build application production usage.start : runsnext start start Next.js production server.lint : runsnext lint set Next.js' built-in ESLint configuration. Create app directory Next.js uses file-system routing, means routes application determined structure files. Create app folder, add layout.tsx page.tsx file. rendered user visits root application (/ ). Create root layout inside app/layout.tsx required <html> <body> tags: export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body>{children}</body> </html> ) } Finally, create home page app/page.tsx initial content: export default function Page() { return <h1>Hello, Next.js!</h1> } Good know: - forget create layout.tsx , Next.js automatically create file running development server withnext dev .- optionally use src directory root project separate application's code configuration files. Create public folder (optional) optionally create public folder root project store static assets images, fonts, etc. Files inside public referenced code starting base URL (/ ). Run development server - Run npm run dev start development server. - Visit http://localhost:3000 view application. - Edit app/page.tsx file save see updated result browser. Set TypeScript Minimum TypeScript version: v4.5.2 Next.js comes built-in TypeScript support. add TypeScript project, rename file .ts / .tsx . Run next dev , Next.js automatically install necessary dependencies add tsconfig.json file recommended config options. IDE Plugin Next.js includes custom TypeScript plugin type checker, VSCode code editors use advanced type-checking auto-completion. enable plugin VS Code by: - Opening command palette ( Ctrl/\u2318 +Shift +P ) - Searching \"TypeScript: Select TypeScript Version\" - Selecting \"Use Workspace Version\" Now, editing files, custom plugin enabled. running next build , custom type checker used. See TypeScript configuration page information use TypeScript project. Set ESLint Next.js comes built-in ESLint, automatically installing necessary packages configuring proper settings create new project create-next-app . add ESLint existing project, add next lint script package.json : { \"scripts\": { \"lint\": \"next lint\" } } Then, run npm run lint guided installation configuration process. npm run lint see prompt like this: ? would like configure ESLint? \u276f Strict (recommended) Base Cancel - Strict: Includes Next.js' base ESLint configuration along stricter Core Web Vitals rule-set. recommended configuration developers setting ESLint first time. - Base: Includes Next.js' base ESLint configuration. - Cancel: include ESLint configuration. select option plan setting custom ESLint configuration. either two configuration options selected, Next.js automatically install eslint eslint-config-next dependencies application create .eslintrc.json file root project includes selected configuration. run next lint every time want run ESLint catch errors. ESLint set up, also automatically run every build (next build ). Errors fail build, warnings not. See ESLint Plugin page information configure ESLint project. Set Absolute Imports Module Path Aliases Next.js in-built support \"paths\" \"baseUrl\" options tsconfig.json jsconfig.json files. options allow alias project directories absolute paths, making easier import modules. example: // import { Button } '../../../components/button' // import { Button } '@/components/button' configure absolute imports, add baseUrl configuration option tsconfig.json jsconfig.json file. example: { \"compilerOptions\": { \"baseUrl\": \"src/\" } } addition configuring baseUrl path, use \"paths\" option \"alias\" module paths. example, following configuration maps @/components/* components/* : { \"compilerOptions\": { \"baseUrl\": \"src/\", \"paths\": { \"@/styles/*\": [\"styles/*\"], \"@/components/*\": [\"components/*\"] } } } \"paths\" relative baseUrl location. example: import Button '@/components/button' import '@/styles/styles.css' export default function HomePage() { return ( <div> <h1>Hello World</h1> <Button /> </div> ) } helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/layouts-and-pages", "title": "Getting Started: Layouts and Pages | Next.js", "text": "create layouts pages Next.js uses file-system based routing, meaning use folders files define routes. page guide create layouts pages, link them. Creating page page UI rendered specific route. create page, add page file inside app directory default export React component. example, create index page (/ ): export default function Page() { return <h1>Hello Next.js!</h1> } Creating layout layout UI shared multiple pages. navigation, layouts preserve state, remain interactive, rerender. define layout default exporting React component layout file. component accept children prop page another layout. example, create layout accepts index page child, add layout file inside app directory: export default function DashboardLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body> {/* Layout UI */} {/* Place children want render page nested layout */} <main>{children}</main> </body> </html> ) } layout called root layout defined root app directory. root layout required must contain html body tags. Creating nested route nested route route composed multiple URL segments. example, /blog/[slug] route composed three segments: / (Root Segment)blog (Segment)[slug] (Leaf Segment) Next.js: - Folders used define route segments map URL segments. - Files (like page andlayout ) used create UI shown segment. create nested routes, nest folders inside other. example, add route /blog , create folder called blog app directory. Then, make /blog publicly accessible, add page file: import { getPosts } '@/lib/posts' import { Post } '@/ui/post' export default async function Page() { const posts = await getPosts() return ( <ul> {posts.map((post) => ( <Post key={post.id} post={post} /> ))} </ul> ) } continue nesting folders create nested routes. example, create route specific blog post, create new [slug] folder inside blog add page file: function generateStaticParams() {} export default function Page() { return <h1>Hello, Blog Post Page!</h1> } Good know: Wrapping folder name square brackets (e.g. [slug] ) creates special dynamic route segment used generate multiple pages data. useful blog posts, product pages, etc. Nesting layouts default, layouts folder hierarchy also nested, means wrap child layouts via children prop. nest layouts adding layout inside specific route segments (folders). example, create layout /blog route, add new layout file inside blog folder. export default function BlogLayout({ children, }: { children: React.ReactNode }) { return <section>{children}</section> } combine two layouts above, root layout (app/layout.js ) would wrap blog layout (app/blog/layout.js ), would wrap blog (app/blog/page.js ) blog post page (app/blog/[slug]/page.js ). Linking pages use <Link> component navigate routes. <Link> built-in Next.js component extends HTML <a> tag provide prefetching client-side navigation. example, generate list blog posts, import <Link> next/link pass href prop component: import Link 'next/link' export default async function Post({ post }) { const posts = await getPosts() return ( <ul> {posts.map((post) => ( <li key={post.slug}> <Link href={`/blog/${post.slug}`}>{post.title}</Link> </li> ))} </ul> ) } <Link> primary recommended way navigate routes Next.js application. However, also use useRouter hook advanced navigation. API Reference helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/metadata-and-og-images", "title": "Getting Started: Metadata and OG images | Next.js", "text": "add metadata create OG images Metadata APIs used define application metadata improved SEO web shareability include: - static metadata object - dynamic generateMetadata function - Special file conventions used add static dynamically generated favicons OG images. options above, Next.js automatically generate relevant <head> tags page, inspected browser's developer tools. Default fields two default meta tags always added even route define metadata: - meta charset tag sets character encoding website. - meta viewport tag sets viewport width scale website adjust different devices. <meta charset=\"utf-8\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> metadata fields defined Metadata object (for static metadata) generateMetadata function (for generated metadata). Static metadata define static metadata, export Metadata object static layout.js page.js file. example, add title description blog route: import type { Metadata } 'next' export const metadata: Metadata = { title: 'My Blog', description: '...', } export default function Page() {} view full list available options, generateMetadata documentation. Generated metadata use generateMetadata function fetch metadata depends data. example, fetch title description specific blog post: import type { Metadata, ResolvingMetadata } 'next' type Props = { params: Promise<{ id: string }> searchParams: Promise<{ [key: string]: string | string[] | undefined }> } export async function generateMetadata( { params, searchParams }: Props, parent: ResolvingMetadata ): Promise<Metadata> { const slug = (await params).slug // fetch post information const post = await fetch(`https://api.vercel.app/blog/${slug}`).then((res) => res.json() ) return { title: post.title, description: post.description, } } export default function Page({ params, searchParams }: Props) {} Behind-the-scenes, Next.js stream metadata separately UI inject metadata HTML soon resolved. Memoizing data requests may cases need fetch data metadata page itself. avoid duplicate requests, use React's cache function memoize return value fetch data once. example, fetch blog post information metadata page: import { cache } 'react' import { db } '@/app/lib/db' // getPost used twice, execute export const getPost = cache(async (slug: string) => { const res = await db.query.posts.findFirst({ where: eq(posts.slug, slug) }) return res }) import { getPost } '@/app/lib/data' export async function generateMetadata({ params, }: { params: { slug: string } }) { const post = await getPost(params.slug) return { title: post.title, description: post.description, } } export default async function Page({ params }: { params: { slug: string } }) { const post = await getPost(params.slug) return <div>{post.title}</div> } File-based metadata following special files available metadata: - favicon.ico, apple-icon.jpg, icon.jpg - opengraph-image.jpg twitter-image.jpg - robots.txt - sitemap.xml use static metadata, programmatically generate files code. Favicons Favicons small icons represent site bookmarks search results. add favicon application, create favicon.ico add root app folder. also programmatically generate favicons using code. See favicon docs information. Static Open Graph images Open Graph (OG) images images represent site social media. add static OG image application, create opengraph-image.png file root app folder. also add OG images specific routes creating opengraph-image.png deeper folder structure. example, create OG image specific /blog route, add opengraph-image.jpg file inside blog folder. specific image take precedence OG images folder structure. image formats jpeg ,png , andwebp also supported. See Open Graph Image docs information. Generated Open Graph images ImageResponse constructor allows generate dynamic images using JSX CSS. useful OG images depend data. example, generate unique OG image blog post, add opengraph-image.ts file inside blog folder, import ImageResponse constructor next/og : import { ImageResponse } 'next/og' import { getPost } '@/app/lib/data' // Image metadata export const size = { width: 1200, height: 630, } export const contentType = 'image/png' // Image generation export default async function Image({ params }: { params: { slug: string } }) { const post = await getPost(params.slug) return new ImageResponse( ( // ImageResponse JSX element <div style={{ fontSize: 128, background: 'white', width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', }} > {post.title} </div> ) ) } ImageResponse supports common CSS properties including flexbox absolute positioning, custom fonts, text wrapping, centering, nested images. See full list supported CSS properties. Good know: - Examples available Vercel OG Playground. ImageResponse uses@vercel/og ,satori , andresvg convert HTML CSS PNG.- flexbox subset CSS properties supported. Advanced layouts (e.g. display: grid ) work. API Reference generateMetadata generateViewport ImageResponse Metadata Files favicon, icon, apple-icon opengraph-image twitter-image robots.txt sitemap.xml helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/partial-prerendering", "title": "Getting Started: Partial Prerendering | Next.js", "text": "use Partial Prerendering Partial Prerendering (PPR) rendering strategy allows combine static dynamic content route. improves initial page performance still supporting personalized, dynamic data. user visits route: - server sends shell containing static content, ensuring fast initial load. - shell leaves holes dynamic content load asynchronously. - dynamic holes streamed parallel, reducing overall load time page. \ud83c\udfa5 Watch: PPR works \u2192 YouTube (10 minutes). Partial Prerendering work? understand Partial Prerendering, helps familiar rendering strategies available Next.js. Static Rendering Static Rendering, HTML generated ahead time\u2014either build time revalidation. result cached shared across users requests. Partial Prerendering, Next.js prerenders static shell route. include layout components depend request-time data. Dynamic Rendering Dynamic Rendering, HTML generated request time. allows serve personalized content based request-time data. component becomes dynamic uses following APIs: cookies headers connection draftMode searchParams propunstable_noStore fetch with{ cache: 'no-store' } Partial Prerendering, using APIs throws special React error informs Next.js component cannot statically rendered, causing build error. use Suspense boundary wrap component defer rendering runtime. Suspense React Suspense used defer rendering parts application condition met. Partial Prerendering, Suspense used mark dynamic boundaries component tree. build time, Next.js prerenders static content fallback UI. dynamic content postponed user requests route. Wrapping component Suspense make component dynamic (your API usage does), rather Suspense used boundary encapsulates dynamic content enable streaming import { Suspense } 'react' import StaticComponent './StaticComponent' import DynamicComponent './DynamicComponent' import Fallback './Fallback' export const experimental_ppr = true export default function Page() { return ( <> <StaticComponent /> <Suspense fallback={<Fallback />}> <DynamicComponent /> </Suspense> </> ) } Streaming Streaming splits route chunks progressively streams client become ready. allows user see parts page immediately, entire content finished rendering. Partial Prerendering, dynamic components wrapped Suspense start streaming server parallel. reduce network overhead, full response\u2014including static HTML streamed dynamic parts\u2014is sent single HTTP request. avoids extra roundtrips improves initial load overall performance. Enabling Partial Prerendering enable PPR adding ppr option next.config.ts file: import type { NextConfig } 'next' const nextConfig: NextConfig = { experimental: { ppr: 'incremental', }, } export default nextConfig 'incremental' value allows adopt PPR specific routes: export const experimental_ppr = true export default function Layout({ children }: { children: React.ReactNode }) { // ... } export const experimental_ppr = true export default function Layout({ children }) { // ... } Routes experimental_ppr default false prerendered using PPR. need explicitly opt-in PPR route. Good know: experimental_ppr apply children route segment, including nested layouts pages. add every file, top segment route.- disable PPR children segments, set experimental_ppr tofalse child segment. Examples Dynamic APIs using Dynamic APIs require looking incoming request, Next.js opt dynamic rendering route. continue using PPR, wrap component Suspense. example, <User /> component dynamic uses cookies API: import { cookies } 'next/headers' export async function User() { const session = (await cookies()).get('session')?.value return '...' } <User /> component streamed content inside <Page /> prerendered become part static shell. import { Suspense } 'react' import { User, AvatarSkeleton } './user' export const experimental_ppr = true export default function Page() { return ( <section> <h1>This prerendered</h1> <Suspense fallback={<AvatarSkeleton />}> <User /> </Suspense> </section> ) } Passing dynamic props Components opt dynamic rendering value accessed. example, reading searchParams <Page /> component, forward value another component prop: import { Table, TableSkeleton } './table' import { Suspense } 'react' export default function Page({ searchParams, }: { searchParams: Promise<{ sort: string }> }) { return ( <section> <h1>This prerendered</h1> <Suspense fallback={<TableSkeleton />}> <Table searchParams={searchParams} /> </Suspense> </section> ) } Inside table component, accessing value searchParams make component dynamic rest page prerendered. export async function Table({ searchParams, }: { searchParams: Promise<{ sort: string }> }) { const sort = (await searchParams).sort === 'true' return '...' } Next Steps helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/project-structure", "title": "Getting Started: Project Structure | Next.js", "text": "Project structure organization page provides overview folder file conventions Next.js, well tips organizing project. Folder file conventions Top-level folders Top-level folders used organize application's code static assets. Top-level files Top-level files used configure application, manage dependencies, run middleware, integrate monitoring tools, define environment variables. | Next.js | | next.config.js | Configuration file Next.js | package.json | Project dependencies scripts | instrumentation.ts | OpenTelemetry Instrumentation file | middleware.ts | Next.js request middleware | .env | Environment variables | .env.local | Local environment variables | .env.production | Production environment variables | .env.development | Development environment variables | .eslintrc.json | Configuration file ESLint | .gitignore | Git files folders ignore | next-env.d.ts | TypeScript declaration file Next.js | tsconfig.json | Configuration file TypeScript | jsconfig.json | Configuration file JavaScript | Routing Files layout | .js .jsx .tsx | Layout | page | .js .jsx .tsx | Page | loading | .js .jsx .tsx | Loading UI | not-found | .js .jsx .tsx | found UI | error | .js .jsx .tsx | Error UI | global-error | .js .jsx .tsx | Global error UI | route | .js .ts | API endpoint | template | .js .jsx .tsx | Re-rendered layout | default | .js .jsx .tsx | Parallel route fallback page | Nested routes folder | Route segment | folder/folder | Nested route segment | Dynamic routes [folder] | Dynamic route segment | [...folder] | Catch-all route segment | [[...folder]] | Optional catch-all route segment | Route Groups private folders (folder) | Group routes without affecting routing | _folder | Opt folder child segments routing | Parallel Intercepted Routes @folder | Named slot | (.)folder | Intercept level | (..)folder | Intercept one level | (..)(..)folder | Intercept two levels | (...)folder | Intercept root | Metadata file conventions App icons favicon | .ico | Favicon file | icon | .ico .jpg .jpeg .png .svg | App Icon file | icon | .js .ts .tsx | Generated App Icon | apple-icon | .jpg .jpeg , .png | Apple App Icon file | apple-icon | .js .ts .tsx | Generated Apple App Icon | Open Graph Twitter images opengraph-image | .jpg .jpeg .png .gif | Open Graph image file | opengraph-image | .js .ts .tsx | Generated Open Graph image | twitter-image | .jpg .jpeg .png .gif | Twitter image file | twitter-image | .js .ts .tsx | Generated Twitter image | SEO sitemap | .xml | Sitemap file | sitemap | .js .ts | Generated Sitemap | robots | .txt | Robots file | robots | .js .ts | Generated Robots file | Component hierarchy React components defined special files route segment rendered specific hierarchy: layout.js template.js error.js (React error boundary)loading.js (React suspense boundary)not-found.js (React error boundary)page.js nestedlayout.js nested route, components segment nested inside components parent segment. Organizing project Apart folder file conventions, Next.js unopinionated organize colocate project files. provide several features help organize project. Colocation app directory, nested folders define route structure. folder represents route segment mapped corresponding segment URL path. However, even though route structure defined folders, route publicly accessible page.js route.js file added route segment. And, even route made publicly accessible, content returned page.js route.js sent client. means project files safely colocated inside route segments app directory without accidentally routable. Good know: - colocate project files app to. prefer, keep outside theapp directory. Private folders Private folders created prefixing folder underscore: _folderName indicates folder private implementation detail considered routing system, thereby opting folder subfolders routing. Since files app directory safely colocated default, private folders required colocation. However, useful for: - Separating UI logic routing logic. - Consistently organizing internal files across project Next.js ecosystem. - Sorting grouping files code editors. - Avoiding potential naming conflicts future Next.js file conventions. Good know: - framework convention, might also consider marking files outside private folders \"private\" using underscore pattern. - create URL segments start underscore prefixing folder name %5F (the URL-encoded form underscore):%5FfolderName .- use private folders, would helpful know Next.js special file conventions prevent unexpected naming conflicts. Route groups Route groups created wrapping folder parenthesis: (folderName) indicates folder organizational purposes included route's URL path. Route groups useful for: - Organizing routes groups e.g. site section, intent, team. - Enabling nested layouts route segment level: src directory Next.js supports storing application code (including app ) inside optional src directory. separates application code project configuration files mostly live root project. Common strategies following section lists high-level overview common strategies. simplest takeaway choose strategy works team consistent across project. Good know: examples below, using components andlib folders generalized placeholders, naming special framework significance projects might use folders likeui ,utils ,hooks ,styles , etc. Store project files outside app strategy stores application code shared folders root project keeps app directory purely routing purposes. Store project files top-level folders inside app strategy stores application code shared folders root app directory. Split project files feature route strategy stores globally shared application code root app directory splits specific application code route segments use them. helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/server-and-client-components", "title": "Getting Started: Server and Client Components | Next.js", "text": "use Server Client Components default, layouts pages Server Components, lets fetch data render parts UI server, optionally cache result, stream client. need interactivity browser APIs, use Client Components layer functionality. page explains Server Client Components work Next.js use them, examples compose together application. use Server Client Components? client server environments different capabilities. Server Client components allow run logic environment depending use case. Use Client Components need: - State event handlers. E.g. onClick ,onChange . - Lifecycle logic. E.g. useEffect . - Browser-only APIs. E.g. localStorage ,window ,Navigator.geolocation , etc. - Custom hooks. Use Server Components need: - Fetch data databases APIs close source. - Use API keys, tokens, secrets without exposing client. - Reduce amount JavaScript sent browser. - Improve First Contentful Paint (FCP), stream content progressively client. example, <Page> component Server Component fetches data post, passes props <LikeButton> handles client-side interactivity. import LikeButton '@/app/ui/like-button' import { getPost } '@/lib/data' export default async function Page({ params }: { params: { id: string } }) { const post = await getPost(params.id) return ( <div> <main> <h1>{post.title}</h1> {/* ... */} <LikeButton likes={post.likes} /> </main> </div> ) } 'use client' import { useState } 'react' export default function LikeButton({ likes }: { likes: number }) { // ... } Server Client Components work Next.js? server server, Next.js uses React's APIs orchestrate rendering. rendering work split chunks, individual route segments (layouts pages): - Server Components rendered special data format called React Server Component Payload (RSC Payload). - Client Components RSC Payload used prerender HTML. React Server Component Payload (RSC)? RSC Payload compact binary representation rendered React Server Components tree. used React client update browser's DOM. RSC Payload contains: - rendered result Server Components - Placeholders Client Components rendered references JavaScript files - props passed Server Component Client Component client (first load) Then, client: - HTML used immediately show fast non-interactive preview route user. - RSC Payload used reconcile Client Server Component trees. - JavaScript used hydrate Client Components make application interactive. hydration? Hydration React's process attaching event handlers DOM, make static HTML interactive. Subsequent Navigations subsequent navigations: - RSC Payload prefetched cached instant navigation. - Client Components rendered entirely client, without server-rendered HTML. Examples Using Client Components create Client Component adding \"use client\" directive top file, imports. 'use client' import { useState } 'react' export default function Counter() { const [count, setCount] = useState(0) return ( <div> <p>{count} likes</p> <button onClick={() => setCount(count + 1)}>Click me</button> </div> ) } \"use client\" used declare boundary Server Client module graphs (trees). file marked \"use client\" , imports child components considered part client bundle. means need add directive every component intended client. Reducing JS bundle size reduce size client JavaScript bundles, add 'use client' specific interactive components instead marking large parts UI Client Components. example, <Layout> component contains mostly static elements like logo navigation links, includes interactive search bar. <Search /> interactive needs Client Component, however, rest layout remain Server Component. 'use client' export default function Search() { // ... } // Client Component import Search './search' // Server Component import Logo './logo' // Layout Server Component default export default function Layout({ children }: { children: React.ReactNode }) { return ( <> <nav> <Logo /> <Search /> </nav> <main>{children}</main> </> ) } Passing data Server Client Components pass data Server Components Client Components using props. import LikeButton '@/app/ui/like-button' import { getPost } '@/lib/data' export default async function Page({ params }: { params: { id: string } }) { const post = await getPost(params.id) return <LikeButton likes={post.likes} /> } 'use client' export default function LikeButton({ likes }: { likes: number }) { // ... } Alternatively, stream data Server Component Client Component use Hook. See example. Good know: Props passed Client Components need serializable React. Interleaving Server Client Components pass Server Components prop Client Component. allows visually nest server-rendered UI within Client components. common pattern use children create slot <ClientComponent> . example, <Cart> component fetches data server, inside <Modal> component uses client state toggle visibility. 'use client' export default function Modal({ children }: { children: React.ReactNode }) { return <div>{children}</div> } Then, parent Server Component (e.g.<Page> ), pass <Cart> child <Modal> : import Modal './ui/modal' import Cart './ui/cart' export default function Page() { return ( <Modal> <Cart /> </Modal> ) } pattern, Server Components rendered server ahead time, including props. resulting RSC payload contain references Client Components rendered within component tree. Context providers React context commonly used share global state like current theme. However, React context supported Server Components. use context, create Client Component accepts children : 'use client' import { createContext } 'react' export const ThemeContext = createContext({}) export default function ThemeProvider({ children, }: { children: React.ReactNode }) { return <ThemeContext.Provider value=\"dark\">{children}</ThemeContext.Provider> } Then, import Server Component (e.g. layout ): import ThemeProvider './theme-provider' export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html> <body> <ThemeProvider>{children}</ThemeProvider> </body> </html> ) } Server Component able directly render provider, Client Components throughout app able consume context. Good know: render providers deep possible tree \u2013 notice ThemeProvider wraps{children} instead entire<html> document. makes easier Next.js optimize static parts Server Components. Third-party components using third-party component relies client-only features, wrap Client Component ensure works expected. example, <Carousel /> imported acme-carousel package. component uses useState , yet \"use client\" directive. use <Carousel /> within Client Component, work expected: 'use client' import { useState } 'react' import { Carousel } 'acme-carousel' export default function Gallery() { const [isOpen, setIsOpen] = useState(false) return ( <div> <button onClick={() => setIsOpen(true)}>View pictures</button> {/* Works, since Carousel used within Client Component */} {isOpen && <Carousel />} </div> ) } However, try use directly within Server Component, see error. Next.js know <Carousel /> using client-only features. fix this, wrap third-party components rely client-only features Client Components: 'use client' import { Carousel } 'acme-carousel' export default Carousel Now, use <Carousel /> directly within Server Component: import Carousel './carousel' export default function Page() { return ( <div> <p>View pictures</p> {/* Works, since Carousel Client Component */} <Carousel /> </div> ) } Advice Library Authors you\u2019re building component library, add \"use client\" directive entry points rely client-only features. lets users import components Server Components without needing create wrappers.It's worth noting bundlers might strip \"use client\" directives. find example configure esbuild include the\"use client\" directive React Wrap Balancer Vercel Analytics repositories. Preventing environment poisoning JavaScript modules shared Server Client Components modules. means possible accidentanlly import server-only code client. example, consider following function: export async function getData() { const res = await fetch('https://external-service.com/data', { headers: { authorization: process.env.API_KEY, }, }) return res.json() } function contains API_KEY never exposed client. Next.js, environment variables prefixed NEXT_PUBLIC_ included client bundle. variables prefixed, Next.js replaces empty string. result, even though getData() imported executed client, work expected. prevent accidental usage Client Components, use server-only package. npm install server-only Then, import package file contains server-only code: import 'server-only' export async function getData() { const res = await fetch('https://external-service.com/data', { headers: { authorization: process.env.API_KEY, }, }) return res.json() } Now, try import module Client Component, build-time error. Good know: corresponding client-only package used mark modules contain client-only logic like code accesses thewindow object. Next Steps helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/updating-data", "title": "Getting Started: Updating Data | Next.js", "text": "update data update data Next.js using React's Server Functions. page go create invoke Server Functions. Creating Server Functions Server Function defined using use server directive. place directive top asynchronous function mark function Server Function, top separate file mark exports file. recommend using separate file instances. 'use server' export async function createPost(formData: FormData) {} export async function deletePost(formData: FormData) {} Server Components Server Functions inlined Server Components adding \"use server\" directive top function body: export default function Page() { // Server Action async function createPost() { 'use server' // Update data // ... return <></> } Client Components possible define Server Functions Client Components. However, invoke Client Components importing file \"use server\" directive top it: 'use server' export async function createPost() {} 'use client' import { createPost } '@/app/actions' export function Button() { return <button formAction={createPost}>Create</button> } Invoking Server Functions two main ways invoke Server Function: - Forms Server Client Components - Event Handlers Client Components Forms React extends HTML <form> element allow Server Function invoked HTML action prop. invoked form, function automatically receives FormData object. extract data using native FormData methods: import { createPost } '@/app/actions' export function Form() { return ( <form action={createPost}> <input type=\"text\" name=\"title\" /> <input type=\"text\" name=\"content\" /> <button type=\"submit\">Create</button> </form> ) } 'use server' export async function createPost(formData: FormData) { const title = formData.get('title') const content = formData.get('content') // Update data // Revalidate cache } Good know: passed action prop, Server Functions also known Server Actions. Event Handlers invoke Server Function Client Component using event handlers onClick . 'use client' import { incrementLike } './actions' import { useState } 'react' export default function LikeButton({ initialLikes }: { initialLikes: number }) { const [likes, setLikes] = useState(initialLikes) return ( <> <p>Total Likes: {likes}</p> <button onClick={async () => { const updatedLikes = await incrementLike() setLikes(updatedLikes) }} > Like </button> </> ) } Showing pending state executing Server Function, show loading indicator React's useActionState hook. hook returns pending boolean: 'use client' import { useActionState } 'react' import { createPost } '@/app/actions' import { LoadingSpinner } '@/app/ui/loading-spinner' export function Button() { const [state, action, pending] = useActionState(createPost, false) return ( <button onClick={async () => action()}> {pending ? <LoadingSpinner /> : 'Create Post'} </button> ) } Revalidating cache performing update, revalidate Next.js cache show updated data calling revalidatePath revalidateTag within Server Function: 'use server' import { revalidatePath } 'next/cache' export async function createPost(formData: FormData) { // Update data // ... revalidatePath('/posts') } Redirecting may want redirect user different page performing update. calling redirect within Server Function: 'use server' import { redirect } 'next/navigation' export async function createPost(formData: FormData) { // Update data // ... redirect('/posts') } API Reference helpful?"},
{"source": "https://nextjs.org/docs/app/getting-started/upgrading", "title": "Getting Started: Upgrading | Next.js", "text": "upgrade Next.js app Latest version update latest version Next.js, use upgrade codemod: Terminal npx @next/codemod@canary upgrade latest prefer upgrade manually, install latest Next.js React versions: Terminal npm next@latest react@latest react-dom@latest eslint-config-next@latest Canary version update latest canary, make sure latest version Next.js everything working expected. Then, run following command: Terminal npm next@canary Features available canary following features currently available canary: Caching: Authentication: Version guides See version guides in-depth upgrade instructions. helpful?"},
{"source": "https://nextjs.org/docs/app/guides", "title": "App Router: Guides | Next.js", "text": "Guides Data Fetching - Using fetch API - Using ORM database client - Reading search params server - Reading search params client Revalidating Data Forms - Showing pending state submitting form - Server-side form validation - Handling expected errors - Handling unexpected exceptions - Showing optimistic UI updates - Programmatic form submission Server Actions Metadata - Creating RSS feed - Creating Open Graph image - Creating sitemap - Creating robots.txt file - Creating custom 404 page - Creating custom 500 page Auth - Creating sign-up form - Stateless, cookie-based session management - Stateful, database-backed session management - Managing authorization Testing Deployment Analytics Measure track page performance using Next.js Speed Insights Authentication Learn implement authentication Next.js application. CI Build Caching Learn configure CI cache Next.js builds Content Security Policy Learn set Content Security Policy (CSP) Next.js application. CSS-in-JS Use CSS-in-JS libraries Next.js Custom Server Start Next.js app programmatically using custom server. Debugging Learn debug Next.js application VS Code, Chrome DevTools, Firefox DevTools. Draft Mode Next.js draft mode toggle static dynamic pages. learn works App Router here. Environment Variables Learn add access environment variables Next.js application. Forms Learn create forms Next.js React Server Actions. ISR Learn create update static pages runtime Incremental Static Regeneration. Instrumentation Learn use instrumentation run code server startup Next.js app Internationalization Add support multiple languages internationalized routing localized content. JSON-LD Learn add JSON-LD Next.js application describe content search engines AI. Lazy Loading Lazy load imported libraries React Components improve application's loading performance. Development Environment Learn optimize local development environment Next.js. MDX Learn configure MDX use Next.js apps. Memory Usage Optimize memory used application development production. Migrating Learn migrate popular frameworks Next.js Multi-tenant Learn build multi-tenant apps App Router. Multi-zones Learn build micro-frontends using Next.js Multi-Zones deploy multiple Next.js apps single domain. OpenTelemetry Learn instrument Next.js app OpenTelemetry. Package Bundling Learn optimize application's server client bundles. Production Recommendations ensure best performance user experience taking Next.js application production. PWAs Learn build Progressive Web Application (PWA) Next.js. Sass Style Next.js application using Sass. Scripts Optimize 3rd party scripts built-in Script component. Self-Hosting Learn self-host Next.js application Node.js server, Docker image, static HTML files (static exports). SPAs Next.js fully supports building Single-Page Applications (SPAs). Static Exports Next.js enables starting static site Single-Page Application (SPA), later optionally upgrading use features require server. Tailwind CSS Style Next.js Application using Tailwind CSS. Testing Learn set Next.js four commonly used testing tools \u2014 Cypress, Playwright, Vitest, Jest. Third Party Libraries Optimize performance third-party libraries application `@next/third-parties` package. Upgrading Learn upgrade latest versions Next.js. Videos Recommendations best practices optimizing videos Next.js application. helpful?"},
{"source": "https://nextjs.org/docs/app/guides/analytics", "title": "Guides: Analytics | Next.js", "text": "add analytics Next.js application Next.js built-in support measuring reporting performance metrics. either use useReportWebVitals hook manage reporting yourself, alternatively, Vercel provides managed service automatically collect visualize metrics you. Client Instrumentation advanced analytics monitoring needs, Next.js provides instrumentation-client.js|ts file runs application's frontend code starts executing. ideal setting global analytics, error tracking, performance monitoring tools. use it, create instrumentation-client.js instrumentation-client.ts file application's root directory: // Initialize analytics app starts console.log('Analytics initialized') // Set global error tracking window.addEventListener('error', (event) => { // Send error tracking service reportError(event.error) }) Build 'use client' import { useReportWebVitals } 'next/web-vitals' export function WebVitals() { useReportWebVitals((metric) => { console.log(metric) }) } import { WebVitals } './_components/web-vitals' export default function Layout({ children }) { return ( <html> <body> <WebVitals /> {children} </body> </html> ) } Since useReportWebVitals hook requires the'use client' directive, performant approach create separate component root layout imports. confines client boundary exclusively theWebVitals component. View API Reference information. Web Vitals Web Vitals set useful metrics aim capture user experience web page. following web vitals included: - Time First Byte (TTFB) - First Contentful Paint (FCP) - Largest Contentful Paint (LCP) - First Input Delay (FID) - Cumulative Layout Shift (CLS) - Interaction Next Paint (INP) handle results metrics using name property. 'use client' import { useReportWebVitals } 'next/web-vitals' export function WebVitals() { useReportWebVitals((metric) => { switch (metric.name) { case 'FCP': { // handle FCP results } case 'LCP': { // handle LCP results } // ... } }) } Sending results external systems send results endpoint measure track real user performance site. example: useReportWebVitals((metric) => { const body = JSON.stringify(metric) const url = 'https://example.com/analytics' // Use `navigator.sendBeacon()` available, falling back `fetch()`. (navigator.sendBeacon) { navigator.sendBeacon(url, body) } else { fetch(url, { body, method: 'POST', keepalive: true }) } }) Good know: use Google Analytics, using id value allow construct metric distributions manually (to calculate percentiles, etc.) useReportWebVitals((metric) => { // Use `window.gtag` initialized Google Analytics example: // https://github.com/vercel/next.js/blob/canary/examples/with-google-analytics window.gtag('event', metric.name, { value: Math.round( metric.name === 'CLS' ? metric.value * 1000 : metric.value ), // values must integers event_label: metric.id, // id unique current page load non_interaction: true, // avoids affecting bounce rate. }) }) Read sending results Google Analytics. helpful?"},
{"source": "https://nextjs.org/docs/app/guides/authentication", "title": "Guides: Authentication | Next.js", "text": "implement authentication Next.js Understanding authentication crucial protecting application's data. page guide React Next.js features use implement auth. starting, helps break process three concepts: - Authentication: Verifies user say are. requires user prove identity something have, username password. - Session Management: Tracks user's auth state across requests. - Authorization: Decides routes data user access. diagram shows authentication flow using React Next.js features: examples page walk basic username password auth educational purposes. implement custom auth solution, increased security simplicity, recommend using authentication library. offer built-in solutions authentication, session management, authorization, well additional features social logins, multi-factor authentication, role-based access control. find list Auth Libraries section. Authentication Sign-up login functionality use <form> element React's Server Actions useActionState capture user credentials, validate form fields, call Authentication Provider's API database. Since Server Actions always execute server, provide secure environment handling authentication logic. steps implement signup/login functionality: 1. Capture user credentials capture user credentials, create form invokes Server Action submission. example, signup form accepts user's name, email, password: import { signup } '@/app/actions/auth' export function SignupForm() { return ( <form action={signup}> <div> <label htmlFor=\"name\">Name</label> <input id=\"name\" name=\"name\" placeholder=\"Name\" /> </div> <div> <label htmlFor=\"email\">Email</label> <input id=\"email\" name=\"email\" type=\"email\" placeholder=\"Email\" /> </div> <div> <label htmlFor=\"password\">Password</label> <input id=\"password\" name=\"password\" type=\"password\" /> </div> <button type=\"submit\">Sign Up</button> </form> ) } export async function signup(formData: FormData) {} 2. Validate form fields server Use Server Action validate form fields server. authentication provider provide form validation, use schema validation library like Zod Yup. Using Zod example, define form schema appropriate error messages: import { z } 'zod' export const SignupFormSchema = z.object({ name: z .string() .min(2, { message: 'Name must least 2 characters long.' }) .trim(), email: z.string().email({ message: 'Please enter valid email.' }).trim(), password: z .string() .min(8, { message: 'Be least 8 characters long' }) .regex(/[a-zA-Z]/, { message: 'Contain least one letter.' }) .regex(/[0-9]/, { message: 'Contain least one number.' }) .regex(/[^a-zA-Z0-9]/, { message: 'Contain least one special character.', }) .trim(), }) export type FormState = | { errors?: { name?: string[] email?: string[] password?: string[] } message?: string } | undefined prevent unnecessary calls authentication provider's API database, return early Server Action form fields match defined schema. import { SignupFormSchema, FormState } '@/app/lib/definitions' export async function signup(state: FormState, formData: FormData) { // Validate form fields const validatedFields = SignupFormSchema.safeParse({ name: formData.get('name'), email: formData.get('email'), password: formData.get('password'), }) // form fields invalid, return early (!validatedFields.success) { return { errors: validatedFields.error.flatten().fieldErrors, } } // Call provider db create user... } Back <SignupForm /> , use React's useActionState hook display validation errors form submitting: 'use client' import { signup } '@/app/actions/auth' import { useActionState } 'react' export default function SignupForm() { const [state, action, pending] = useActionState(signup, undefined) return ( <form action={action}> <div> <label htmlFor=\"name\">Name</label> <input id=\"name\" name=\"name\" placeholder=\"Name\" /> </div> {state?.errors?.name && <p>{state.errors.name}</p>} <div> <label htmlFor=\"email\">Email</label> <input id=\"email\" name=\"email\" placeholder=\"Email\" /> </div> {state?.errors?.email && <p>{state.errors.email}</p>} <div> <label htmlFor=\"password\">Password</label> <input id=\"password\" name=\"password\" type=\"password\" /> </div> {state?.errors?.password && ( <div> <p>Password must:</p> <ul> {state.errors.password.map((error) => ( <li key={error}>- {error}</li> ))} </ul> </div> )} <button disabled={pending} type=\"submit\"> Sign </button> </form> ) } Good know: - React 19, useFormStatus includes additional keys returned object, like data, method, action. using React 19, thepending key available.- mutating data, always ensure user also authorized perform action. See Authentication Authorization. 3. Create user check user credentials validating form fields, create new user account check user exists calling authentication provider's API database. Continuing previous example: export async function signup(state: FormState, formData: FormData) { // 1. Validate form fields // ... // 2. Prepare data insertion database const { name, email, password } = validatedFields.data // e.g. Hash user's password storing const hashedPassword = await bcrypt.hash(password, 10) // 3. Insert user database call Auth Library's API const data = await db .insert(users) .values({ name, email, password: hashedPassword, }) .returning({ id: users.id }) const user = data[0] (!user) { return { message: 'An error occurred creating account.', } } // TODO: // 4. Create user session // 5. Redirect user } successfully creating user account verifying user credentials, create session manage user's auth state. Depending session management strategy, session stored cookie database, both. Continue Session Management section learn more. Tips: - example verbose since breaks authentication steps purpose education. highlights implementing secure solution quickly become complex. Consider using Auth Library simplify process. - improve user experience, may want check duplicate emails usernames earlier registration flow. example, user types username input field loses focus. help prevent unnecessary form submissions provide immediate feedback user. debounce requests libraries use-debounce manage frequency checks. Session Management Session management ensures user's authenticated state preserved across requests. involves creating, storing, refreshing, deleting sessions tokens. two types sessions: - Stateless: Session data (or token) stored browser's cookies. cookie sent request, allowing session verified server. method simpler, less secure implemented correctly. - Database: Session data stored database, user's browser receiving encrypted session ID. method secure, complex use server resources. Good know: use either method, both, recommend using session management library iron-session Jose. Stateless Sessions create manage stateless sessions, steps need follow: - Generate secret key, used sign session, store environment variable. - Write logic encrypt/decrypt session data using session management library. - Manage cookies using Next.js cookies API. addition above, consider adding functionality update (or refresh) session user returns application, delete session user logs out. Good know: Check auth library includes session management. 1. Generating secret key ways generate secret key sign session. example, may choose use openssl command terminal: openssl rand -base64 32 command generates 32-character random string use secret key store environment variables file: SESSION_SECRET=your_secret_key reference key session management logic: const secretKey = process.env.SESSION_SECRET 2. Encrypting decrypting sessions Next, use preferred session management library encrypt decrypt sessions. Continuing previous example, use Jose (compatible Edge Runtime) React's server-only package ensure session management logic executed server. import 'server-only' import { SignJWT, jwtVerify } 'jose' import { SessionPayload } '@/app/lib/definitions' const secretKey = process.env.SESSION_SECRET const encodedKey = new TextEncoder().encode(secretKey) export async function encrypt(payload: SessionPayload) { return new SignJWT(payload) .setProtectedHeader({ alg: 'HS256' }) .setIssuedAt() .setExpirationTime('7d') .sign(encodedKey) } export async function decrypt(session: string | undefined = '') { try { const { payload } = await jwtVerify(session, encodedKey, { algorithms: ['HS256'], }) return payload } catch (error) { console.log('Failed verify session') } } Tips: - payload contain minimum, unique user data used subsequent requests, user's ID, role, etc. contain personally identifiable information like phone number, email address, credit card information, etc, sensitive data like passwords. 3. Setting cookies (recommended options) store session cookie, use Next.js cookies API. cookie set server, include recommended options: - HttpOnly: Prevents client-side JavaScript accessing cookie. - Secure: Use https send cookie. - SameSite: Specify whether cookie sent cross-site requests. - Max-Age Expires: Delete cookie certain period. - Path: Define URL path cookie. Please refer MDN information options. import 'server-only' import { cookies } 'next/headers' export async function createSession(userId: string) { const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) const session = await encrypt({ userId, expiresAt }) const cookieStore = await cookies() cookieStore.set('session', session, { httpOnly: true, secure: true, expires: expiresAt, sameSite: 'lax', path: '/', }) } Back Server Action, invoke createSession() function, use redirect() API redirect user appropriate page: import { createSession } '@/app/lib/session' export async function signup(state: FormState, formData: FormData) { // Previous steps: // 1. Validate form fields // 2. Prepare data insertion database // 3. Insert user database call Library API // Current steps: // 4. Create user session await createSession(user.id) // 5. Redirect user redirect('/profile') } Tips: - Cookies set server prevent client-side tampering. - \ud83c\udfa5 Watch: Learn stateless sessions authentication Next.js \u2192 YouTube (11 minutes). Updating (or refreshing) sessions also extend session's expiration time. useful keeping user logged access application again. example: import 'server-only' import { cookies } 'next/headers' import { decrypt } '@/app/lib/session' export async function updateSession() { const session = (await cookies()).get('session')?.value const payload = await decrypt(session) (!session || !payload) { return null } const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) const cookieStore = await cookies() cookieStore.set('session', session, { httpOnly: true, secure: true, expires: expires, sameSite: 'lax', path: '/', }) } Tip: Check auth library supports refresh tokens, used extend user's session. Deleting session delete session, delete cookie: import 'server-only' import { cookies } 'next/headers' export async function deleteSession() { const cookieStore = await cookies() cookieStore.delete('session') } reuse deleteSession() function application, example, logout: import { cookies } 'next/headers' import { deleteSession } '@/app/lib/session' export async function logout() { await deleteSession() redirect('/login') } Database Sessions create manage database sessions, need follow steps: - Create table database store session data (or check Auth Library handles this). - Implement functionality insert, update, delete sessions - Encrypt session ID storing user's browser, ensure database cookie stay sync (this optional, recommended optimistic auth checks Middleware). example: import cookies 'next/headers' import { db } '@/app/lib/db' import { encrypt } '@/app/lib/session' export async function createSession(id: number) { const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 1. Create session database const data = await db .insert(sessions) .values({ userId: id, expiresAt, }) // Return session ID .returning({ id: sessions.id }) const sessionId = data[0].id // 2. Encrypt session ID const session = await encrypt({ sessionId, expiresAt }) // 3. Store session cookies optimistic auth checks const cookieStore = await cookies() cookieStore.set('session', session, { httpOnly: true, secure: true, expires: expiresAt, sameSite: 'lax', path: '/', }) } Tips: - faster access, may consider adding server caching lifetime session. also keep session data primary database, combine data requests reduce number queries. - may opt use database sessions advanced use cases, keeping track last time user logged in, number active devices, give users ability log devices. implementing session management, need add authorization logic control users access within application. Continue Authorization section learn more. Authorization user authenticated session created, implement authorization control user access within application. two main types authorization checks: - Optimistic: Checks user authorized access route perform action using session data stored cookie. checks useful quick operations, showing/hiding UI elements redirecting users based permissions roles. - Secure: Checks user authorized access route perform action using session data stored database. checks secure used operations require access sensitive data actions. cases, recommend: - Creating Data Access Layer centralize authorization logic - Using Data Transfer Objects (DTO) return necessary data - Optionally use Middleware perform optimistic checks. Optimistic checks Middleware (Optional) cases may want use Middleware redirect users based permissions: - perform optimistic checks. Since Middleware runs every route, good way centralize redirect logic pre-filter unauthorized users. - protect static routes share data users (e.g. content behind paywall). However, since Middleware runs every route, including prefetched routes, important read session cookie (optimistic checks), avoid database checks prevent performance issues. example: import { NextRequest, NextResponse } 'next/server' import { decrypt } '@/app/lib/session' import { cookies } 'next/headers' // 1. Specify protected public routes const protectedRoutes = ['/dashboard'] const publicRoutes = ['/login', '/signup', '/'] export default async function middleware(req: NextRequest) { // 2. Check current route protected public const path = req.nextUrl.pathname const isProtectedRoute = protectedRoutes.includes(path) const isPublicRoute = publicRoutes.includes(path) // 3. Decrypt session cookie const cookie = (await cookies()).get('session')?.value const session = await decrypt(cookie) // 4. Redirect /login user authenticated (isProtectedRoute && !session?.userId) { return NextResponse.redirect(new URL('/login', req.nextUrl)) } // 5. Redirect /dashboard user authenticated ( isPublicRoute && session?.userId && !req.nextUrl.pathname.startsWith('/dashboard') ) { return NextResponse.redirect(new URL('/dashboard', req.nextUrl)) } return NextResponse.next() } // Routes Middleware run export const config = { matcher: ['/((?!api|_next/static|_next/image|.*\\\\.png$).*)'], } Middleware useful initial checks, line defense protecting data. majority security checks performed close possible data source, see Data Access Layer information. Tips: - Middleware, also read cookies using req.cookies.get('session').value .- Middleware uses Edge Runtime, check Auth library session management library compatible. - use matcher property Middleware specify routes Middleware run on. Although, auth, recommended Middleware runs routes. Creating Data Access Layer (DAL) recommend creating DAL centralize data requests authorization logic. DAL include function verifies user's session interact application. least, function check session valid, redirect return user information needed make requests. example, create separate file DAL includes verifySession() function. use React's cache API memoize return value function React render pass: import 'server-only' import { cookies } 'next/headers' import { decrypt } '@/app/lib/session' export const verifySession = cache(async () => { const cookie = (await cookies()).get('session')?.value const session = await decrypt(cookie) (!session?.userId) { redirect('/login') } return { isAuth: true, userId: session.userId } }) invoke verifySession() function data requests, Server Actions, Route Handlers: export const getUser = cache(async () => { const session = await verifySession() (!session) return null try { const data = await db.query.users.findMany({ where: eq(users.id, session.userId), // Explicitly return columns need rather whole user object columns: { id: true, name: true, email: true, }, }) const user = data[0] return user } catch (error) { console.log('Failed fetch user') return null } }) Tip: - DAL used protect data fetched request time. However, static routes share data users, data fetched build time request time. Use Middleware protect static routes. - secure checks, check session valid comparing session ID database. Use React's cache function avoid unnecessary duplicate requests database render pass. - may wish consolidate related data requests JavaScript class runs verifySession() methods. Using Data Transfer Objects (DTO) retrieving data, recommended return necessary data used application, entire objects. example, fetching user data, might return user's ID name, rather entire user object could contain passwords, phone numbers, etc. However, control returned data structure, working team want avoid whole objects passed client, use strategies specifying fields safe exposed client. import 'server-only' import { getUser } '@/app/lib/dal' function canSeeUsername(viewer: User) { return true } function canSeePhoneNumber(viewer: User, team: string) { return viewer.isAdmin || team === viewer.team } export async function getProfileDTO(slug: string) { const data = await db.query.users.findMany({ where: eq(users.slug, slug), // Return specific columns }) const user = data[0] const currentUser = await getUser(user.id) // return what's specific query return { username: canSeeUsername(currentUser) ? user.username : null, phonenumber: canSeePhoneNumber(currentUser, user.team) ? user.phonenumber : null, } } centralizing data requests authorization logic DAL using DTOs, ensure data requests secure consistent, making easier maintain, audit, debug application scales. Good know: - couple different ways define DTO, using toJSON() , individual functions like example above, JS classes. Since JavaScript patterns React Next.js feature, recommend research find best pattern application.- Learn security best practices Security Next.js article. Server Components Auth check Server Components useful role-based access. example, conditionally render components based user's role: import { verifySession } '@/app/lib/dal' export default function Dashboard() { const session = await verifySession() const userRole = session?.user?.role // Assuming 'role' part session object (userRole === 'admin') { return <AdminDashboard /> } else (userRole === 'user') { return <UserDashboard /> } else { redirect('/login') } } example, use verifySession() function DAL check 'admin', 'user', unauthorized roles. pattern ensures user interacts components appropriate role. Layouts auth checks Due Partial Rendering, cautious checks Layouts re-render navigation, meaning user session checked every route change. Instead, checks close data source component conditionally rendered. example, consider shared layout fetches user data displays user image nav. Instead auth check layout, fetch user data (getUser() ) layout auth check DAL. guarantees wherever getUser() called within application, auth check performed, prevents developers forgetting check user authorized access data. export default async function Layout({ children, }: { children: React.ReactNode; }) { const user = await getUser(); return ( // ... ) } export const getUser = cache(async () => { const session = await verifySession() (!session) return null // Get user ID session fetch data }) Good know: - common pattern SPAs return null layout top-level component user authorized. pattern recommended since Next.js applications multiple entry points, prevent nested route segments Server Actions accessed. Server Actions Treat Server Actions security considerations public-facing API endpoints, verify user allowed perform mutation. example below, check user's role allowing action proceed: 'use server' import { verifySession } '@/app/lib/dal' export async function serverAction(formData: FormData) { const session = await verifySession() const userRole = session?.user?.role // Return early user authorized perform action (userRole !== 'admin') { return null } // Proceed action authorized users } Route Handlers Treat Route Handlers security considerations public-facing API endpoints, verify user allowed access Route Handler. example: import { verifySession } '@/app/lib/dal' export async function GET() { // User authentication role verification const session = await verifySession() // Check user authenticated (!session) { // User authenticated return new Response(null, { status: 401 }) } // Check user 'admin' role (session.user.role !== 'admin') { // User authenticated right permissions return new Response(null, { status: 403 }) } // Continue authorized users } example demonstrates Route Handler two-tier security check. first checks active session, verifies logged-in user 'admin'. Context Providers Using context providers auth works due interleaving. However, React context supported Server Components, making applicable Client Components. works, child Server Components rendered server first, access context provider\u2019s session data: import { ContextProvider } 'auth-lib' export default function RootLayout({ children }) { return ( <html lang=\"en\"> <body> <ContextProvider>{children}</ContextProvider> </body> </html> ) } 'use client'; import { useSession } \"auth-lib\"; export default function Profile() { const { userId } = useSession(); const { data } = useSWR(`/api/user/${userId}`, fetcher) return ( // ... ); } session data needed Client Components (e.g. client-side data fetching), use React\u2019s taintUniqueValue API prevent sensitive session data exposed client. Resources learned authentication Next.js, Next.js-compatible libraries resources help implement secure authentication session management: Auth Libraries Session Management Libraries Reading continue learning authentication security, check following resources: helpful?"},
{"source": "https://nextjs.org/docs/app/guides/ci-build-caching", "title": "Guides: CI Build Caching | Next.js", "text": "configure Continuous Integration (CI) build caching improve build performance, Next.js saves cache .next/cache shared builds. take advantage cache Continuous Integration (CI) environments, CI workflow need configured correctly persist cache builds. CI configured persist .next/cache builds, may see Cache Detected error. example cache configurations common CI providers: Vercel Next.js caching automatically configured you. There's action required part. using Turborepo Vercel, learn here. CircleCI Edit save_cache step .circleci/config.yml include .next/cache : steps: - save_cache: key: dependency-cache-{{ checksum \"yarn.lock\" }} paths: - ./node_modules - ./.next/cache save_cache key, please follow CircleCI's documentation setting build caching. Travis CI Add merge following .travis.yml : cache: directories: - $HOME/.cache/yarn - node_modules - .next/cache GitLab CI Add merge following .gitlab-ci.yml : cache: key: ${CI_COMMIT_REF_SLUG} paths: - node_modules/ - .next/cache/ Netlify CI Use Netlify Plugins @netlify/plugin-nextjs . AWS CodeBuild Add (or merge in) following buildspec.yml : cache: paths: - 'node_modules/**/*' # Cache `node_modules` faster `yarn` `npm i` - '.next/cache/**/*' # Cache Next.js faster application rebuilds GitHub Actions Using GitHub's actions/cache, add following step workflow file: uses: actions/cache@v4 with: # See caching `yarn`, `bun` package managers https://github.com/actions/cache/blob/main/examples.md leverage caching actions/setup-node https://github.com/actions/setup-node path: | ~/.npm ${{ github.workspace }}/.next/cache # Generate new cache whenever packages source files change. key: ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**/*.js', '**/*.jsx', '**/*.ts', '**/*.tsx') }} # source files changed packages didn't, rebuild prior cache. restore-keys: | ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}- Bitbucket Pipelines Add merge following bitbucket-pipelines.yml top level (same level pipelines ): definitions: caches: nextcache: .next/cache reference caches section pipeline's step : - step: name: your_step_name caches: - node - nextcache Heroku Using Heroku's custom cache, add cacheDirectories array top-level package.json: \"cacheDirectories\": [\".next/cache\"] Azure Pipelines Using Azure Pipelines' Cache task, add following task pipeline yaml file somewhere prior task executes next build : - task: Cache@2 displayName: 'Cache .next/cache' inputs: key: next | $(Agent.OS) | yarn.lock path: '$(System.DefaultWorkingDirectory)/.next/cache' Jenkins (Pipeline) Using Jenkins' Job Cacher plugin, add following build step Jenkinsfile would normally run next build npm install : stage(\"Restore npm packages\") { steps { // Writes lock-file cache based GIT_COMMIT hash writeFile file: \"next-lock.cache\", text: \"$GIT_COMMIT\" cache(caches: [ arbitraryFileCache( path: \"node_modules\", includes: \"**/*\", cacheValidityDecidingFile: \"package-lock.json\" ) ]) { sh \"npm install\" } } } stage(\"Build\") { steps { // Writes lock-file cache based GIT_COMMIT hash writeFile file: \"next-lock.cache\", text: \"$GIT_COMMIT\" cache(caches: [ arbitraryFileCache( path: \".next/cache\", includes: \"**/*\", cacheValidityDecidingFile: \"next-lock.cache\" ) ]) { // aka `next build` sh \"npm run build\" } } } helpful?"},
{"source": "https://nextjs.org/docs/app/guides/content-security-policy", "title": "Guides: Content Security Policy | Next.js", "text": "set Content Security Policy (CSP) Next.js application Content Security Policy (CSP) important guard Next.js application various security threats cross-site scripting (XSS), clickjacking, code injection attacks. using CSP, developers specify origins permissible content sources, scripts, stylesheets, images, fonts, objects, media (audio, video), iframes, more. Examples Nonces nonce unique, random string characters created one-time use. used conjunction CSP selectively allow certain inline scripts styles execute, bypassing strict CSP directives. use nonce? Even though CSPs designed block malicious scripts, legitimate scenarios inline scripts necessary. cases, nonces offer way allow scripts execute correct nonce. Adding nonce Middleware Middleware enables add headers generate nonces page renders. Every time page viewed, fresh nonce generated. means must use dynamic rendering add nonces. example: import { NextRequest, NextResponse } 'next/server' export function middleware(request: NextRequest) { const nonce = Buffer.from(crypto.randomUUID()).toString('base64') const cspHeader = ` default-src 'self'; script-src 'self' 'nonce-${nonce}' 'strict-dynamic'; style-src 'self' 'nonce-${nonce}'; img-src 'self' blob: data:; font-src 'self'; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none'; upgrade-insecure-requests; ` // Replace newline characters spaces const contentSecurityPolicyHeaderValue = cspHeader .replace(/\\s{2,}/g, ' ') .trim() const requestHeaders = new Headers(request.headers) requestHeaders.set('x-nonce', nonce) requestHeaders.set( 'Content-Security-Policy', contentSecurityPolicyHeaderValue ) const response = NextResponse.next({ request: { headers: requestHeaders, }, }) response.headers.set( 'Content-Security-Policy', contentSecurityPolicyHeaderValue ) return response } default, Middleware runs requests. filter Middleware run specific paths using matcher . recommend ignoring matching prefetches (from next/link ) static assets need CSP header. export const config = { matcher: [ /* * Match request paths except ones starting with: * - api (API routes) * - _next/static (static files) * - _next/image (image optimization files) * - favicon.ico (favicon file) */ { source: '/((?!api|_next/static|_next/image|favicon.ico).*)', missing: [ { type: 'header', key: 'next-router-prefetch' }, { type: 'header', key: 'purpose', value: 'prefetch' }, ], }, ], } Reading nonce read nonce Server Component using headers : import { headers } 'next/headers' import Script 'next/script' export default async function Page() { const nonce = (await headers()).get('x-nonce') return ( <Script src=\"https://www.googletagmanager.com/gtag/js\" strategy=\"afterInteractive\" nonce={nonce} /> ) } Without Nonces applications require nonces, set CSP header directly next.config.js file: const cspHeader = ` default-src 'self'; script-src 'self' 'unsafe-eval' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' blob: data:; font-src 'self'; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none'; upgrade-insecure-requests; ` module.exports = { async headers() { return [ { source: '/(.*)', headers: [ { key: 'Content-Security-Policy', value: cspHeader.replace(/\\n/g, ''), }, ], }, ] }, } Version History recommend using v13.4.20+ Next.js properly handle apply nonces. Next Steps helpful?"},
{"source": "https://nextjs.org/docs/app/guides/css-in-js", "title": "Guides: CSS-in-JS | Next.js", "text": "use CSS-in-JS libraries Warning: Using CSS-in-JS newer React features like Server Components Streaming requires library authors support latest version React, including concurrent rendering. following libraries supported Client Components app directory (alphabetical): ant-design chakra-ui @fluentui/react-components kuma-ui @mui/material @mui/joy pandacss styled-jsx styled-components stylex tamagui tss-react vanilla-extract following currently working support: Good know: testing different CSS-in-JS libraries adding examples libraries support React 18 features and/or app directory. Configuring CSS-in-JS app Configuring CSS-in-JS three-step opt-in process involves: - style registry collect CSS rules render. - new useServerInsertedHTML hook inject rules content might use them. - Client Component wraps app style registry initial server-side rendering. styled-jsx Using styled-jsx Client Components requires using v5.1.0 . First, create new registry: 'use client' import React, { useState } 'react' import { useServerInsertedHTML } 'next/navigation' import { StyleRegistry, createStyleRegistry } 'styled-jsx' export default function StyledJsxRegistry({ children, }: { children: React.ReactNode }) { // create stylesheet lazy initial state // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state const [jsxStyleRegistry] = useState(() => createStyleRegistry()) useServerInsertedHTML(() => { const styles = jsxStyleRegistry.styles() jsxStyleRegistry.flush() return <>{styles}</> }) return <StyleRegistry registry={jsxStyleRegistry}>{children}</StyleRegistry> } Then, wrap root layout registry: import StyledJsxRegistry './registry' export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html> <body> <StyledJsxRegistry>{children}</StyledJsxRegistry> </body> </html> ) } Styled Components example configure styled-components@6 newer: First, enable styled-components next.config.js . module.exports = { compiler: { styledComponents: true, }, } Then, use styled-components API create global registry component collect CSS style rules generated render, function return rules. use useServerInsertedHTML hook inject styles collected registry <head> HTML tag root layout. 'use client' import React, { useState } 'react' import { useServerInsertedHTML } 'next/navigation' import { ServerStyleSheet, StyleSheetManager } 'styled-components' export default function StyledComponentsRegistry({ children, }: { children: React.ReactNode }) { // create stylesheet lazy initial state // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state const [styledComponentsStyleSheet] = useState(() => new ServerStyleSheet()) useServerInsertedHTML(() => { const styles = styledComponentsStyleSheet.getStyleElement() styledComponentsStyleSheet.instance.clearTag() return <>{styles}</> }) (typeof window !== 'undefined') return <>{children}</> return ( <StyleSheetManager sheet={styledComponentsStyleSheet.instance}> {children} </StyleSheetManager> ) } Wrap children root layout style registry component: import StyledComponentsRegistry './lib/registry' export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html> <body> <StyledComponentsRegistry>{children}</StyledComponentsRegistry> </body> </html> ) } Good know: - server rendering, styles extracted global registry flushed <head> HTML. ensures style rules placed content might use them. future, may use upcoming React feature determine inject styles.- streaming, styles chunk collected appended existing styles. client-side hydration complete, styled-components take usual inject dynamic styles.- specifically use Client Component top level tree style registry efficient extract CSS rules way. avoids re-generating styles subsequent server renders, prevents sent Server Component payload. - advanced use cases need configure individual properties styled-components compilation, read Next.js styled-components API reference learn more. helpful?"},
{"source": "https://nextjs.org/docs/app/guides/custom-server", "title": "Guides: Custom Server | Next.js", "text": "set custom server Next.js Next.js includes server next start default. existing backend, still use Next.js (this custom server). custom Next.js server allows programmatically start server custom patterns. majority time, need approach. However, available need eject. Good know: - deciding use custom server, keep mind used integrated router Next.js can't meet app requirements. custom server remove important performance optimizations, like Automatic Static Optimization. - using standalone output mode, trace custom server files. mode outputs separate minimal server.js file, instead. cannot used together. Take look following example custom server: import { createServer } 'http' import { parse } 'url' import next 'next' const port = parseInt(process.env.PORT || '3000', 10) const dev = process.env.NODE_ENV !== 'production' const app = next({ dev }) const handle = app.getRequestHandler() app.prepare().then(() => { createServer((req, res) => { const parsedUrl = parse(req.url!, true) handle(req, res, parsedUrl) }).listen(port) console.log( `> Server listening http://localhost:${port} ${ dev ? 'development' : process.env.NODE_ENV }` ) }) server.js run Next.js Compiler bundling process. Make sure syntax source code file requires compatible current Node.js version using. View example. run custom server, need update scripts package.json like so: { \"scripts\": { \"dev\": \"node server.js\", \"build\": \"next build\", \"start\": \"NODE_ENV=production node server.js\" } } Alternatively, set nodemon (example). custom server uses following import connect server Next.js application: import next 'next' const app = next({}) next import function receives object following options: | Option | Type | Description | |---|---|---| conf | Object | object would use next.config.js . Defaults {} | dev | Boolean | (Optional) Whether launch Next.js dev mode. Defaults false | dir | String | (Optional) Location Next.js project. Defaults '.' | quiet | Boolean | (Optional) Hide error messages containing server information. Defaults false | hostname | String | (Optional) hostname server running behind | port | Number | (Optional) port server running behind | httpServer | node:http#Server | (Optional) HTTP Server Next.js running behind | turbo | Boolean | (Optional) Enable Turbopack | returned app used let Next.js handle requests required. helpful?"},
{"source": "https://nextjs.org/docs/app/guides/debugging", "title": "Guides: Debugging | Next.js", "text": "use debugging tools Next.js documentation explains debug Next.js frontend backend code full source maps support using VS Code debugger, Chrome DevTools, Firefox DevTools. debugger attach Node.js also used debug Next.js application. find details Node.js Debugging Guide. Debugging VS Code Create file named .vscode/launch.json root project following content: { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Next.js: debug server-side\", \"type\": \"node-terminal\", \"request\": \"launch\", \"command\": \"npm run dev\" }, { \"name\": \"Next.js: debug client-side\", \"type\": \"chrome\", \"request\": \"launch\", \"url\": \"http://localhost:3000\" }, { \"name\": \"Next.js: debug client-side (Firefox)\", \"type\": \"firefox\", \"request\": \"launch\", \"url\": \"http://localhost:3000\", \"reAttach\": true, \"pathMappings\": [ { \"url\": \"webpack://_N_E\", \"path\": \"${workspaceFolder}\" } ] }, { \"name\": \"Next.js: debug full stack\", \"type\": \"node\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/node_modules/next/dist/bin/next\", \"runtimeArgs\": [\"--inspect\"], \"skipFiles\": [\"<node_internals>/**\"], \"serverReadyAction\": { \"action\": \"debugWithEdge\", \"killOnServerStop\": true, \"pattern\": \"- Local:.+(https?://.+)\", \"uriFormat\": \"%s\", \"webRoot\": \"${workspaceFolder}\" } } ] } Note: use Firefox debugging VS Code, need install Firefox Debugger extension. npm run dev replaced yarn dev using Yarn pnpm dev using pnpm. \"Next.js: debug full stack\" configuration, serverReadyAction.action specifies browser open server ready. debugWithEdge means launch Edge browser. using Chrome, change value debugWithChrome . changing port number application starts on, replace 3000 http://localhost:3000 port using instead. running Next.js directory root (for example, using Turborepo) need add cwd server-side full stack debugging tasks. example, \"cwd\": \"${workspaceFolder}/apps/web\" . go Debug panel (Ctrl+Shift+D Windows/Linux, \u21e7+\u2318+D macOS), select launch configuration, press F5 select Debug: Start Debugging Command Palette start debugging session. Using Debugger Jetbrains WebStorm Click drop menu listing runtime configuration, click Edit Configurations... . Create JavaScript Debug debug configuration http://localhost:3000 URL. Customize liking (e.g. Browser debugging, store project file), click OK . Run debug configuration, selected browser automatically open. point, 2 applications debug mode: NextJS node application, client/browser application. Debugging Browser DevTools Client-side code Start development server usual running next dev , npm run dev , yarn dev . server starts, open http://localhost:3000 (or alternate URL) preferred browser. Chrome: - Open Chrome's Developer Tools ( Ctrl+Shift+J Windows/Linux,\u2325+\u2318+I macOS) - Go Sources tab Firefox: - Open Firefox's Developer Tools ( Ctrl+Shift+I Windows/Linux,\u2325+\u2318+I macOS) - Go Debugger tab either browser, time client-side code reaches debugger statement, code execution pause file appear debug area. also search files set breakpoints manually: - Chrome: Press Ctrl+P Windows/Linux or\u2318+P macOS - Firefox: Press Ctrl+P Windows/Linux or\u2318+P macOS, use file tree left panel Note searching, source files paths starting webpack://_N_E/./ . Server-side code debug server-side Next.js code browser DevTools, need pass --inspect flag underlying Node.js process: NODE_OPTIONS='--inspect' next dev Good know: Use NODE_OPTIONS='--inspect=0.0.0.0' allow remote debugging access outside localhost, running app Docker container. using npm run dev yarn dev update dev script package.json : { \"scripts\": { \"dev\": \"NODE_OPTIONS='--inspect' next dev\" } } Launching Next.js dev server --inspect flag look something like this: Debugger listening ws://127.0.0.1:9229/0cf90313-350d-4466-a748-cd60f4e47c95 help, see: https://nodejs.org/en/docs/inspector ready - started server 0.0.0.0:3000, url: http://localhost:3000 Chrome: - Open new tab visit chrome://inspect - Click Configure... ensure debugging ports listed - Add localhost:9229 andlocalhost:9230 already present - Look Next.js application Remote Target section - Click inspect open separate DevTools window - Go Sources tab Firefox: - Open new tab visit about:debugging - Click Firefox left sidebar - Remote Targets, find Next.js application - Click Inspect open debugger - Go Debugger tab Debugging server-side code works similarly client-side debugging. searching files (Ctrl+P /\u2318+P ), source files paths starting webpack://{application-name}/./ (where {application-name} replaced name application according package.json file). Inspect Server Errors Browser DevTools encounter error, inspecting source code help trace root cause errors. Next.js display Node.js icon underneath Next.js version indicator error overlay. clicking icon, DevTools URL copied clipboard. open new browser tab URL inspect Next.js server process. Debugging Windows Windows users may run issue using NODE_OPTIONS='--inspect' syntax supported Windows platforms. get around this, install cross-env package development dependency (-D npm yarn ) replace dev script following. { \"scripts\": { \"dev\": \"cross-env NODE_OPTIONS='--inspect' next dev\" } } cross-env set NODE_OPTIONS environment variable regardless platform (including Mac, Linux, Windows) allow debug consistently across devices operating systems. Good know: Ensure Windows Defender disabled machine. external service check every file read, reported greatly increase Fast Refresh time next dev . known issue, related Next.js, affect Next.js development. information learn use JavaScript debugger, take look following documentation: helpful?"},
{"source": "https://nextjs.org/docs/app/guides/draft-mode", "title": "Guides: Draft Mode | Next.js", "text": "preview content Draft Mode Next.js Draft Mode allows preview draft content headless CMS Next.js application. useful static pages generated build time allows switch dynamic rendering see draft changes without rebuild entire site. page walks enable use Draft Mode. Step 1: Create Route Handler Create Route Handler. name, example, app/api/draft/route.ts . export async function GET(request: Request) { return new Response('') } Then, import draftMode function call enable() method. import { draftMode } 'next/headers' export async function GET(request: Request) { const draft = await draftMode() draft.enable() return new Response('Draft mode enabled') } set cookie enable draft mode. Subsequent requests containing cookie trigger draft mode change behavior statically generated pages. test manually visiting /api/draft looking browser\u2019s developer tools. Notice Set-Cookie response header cookie named __prerender_bypass . Step 2: Access Route Handler Headless CMS steps assume headless CMS you\u2019re using supports setting custom draft URLs. doesn\u2019t, still use method secure draft URLs, you\u2019ll need construct access draft URL manually. specific steps vary depending headless CMS you\u2019re using. securely access Route Handler headless CMS: - Create secret token string using token generator choice. secret known Next.js app headless CMS. - headless CMS supports setting custom draft URLs, specify draft URL (this assumes Route Handler located app/api/draft/route.ts ). example: https://<your-site>/api/draft?secret=<token>&slug=<path> <your-site> deployment domain.<token> replaced secret token generated.<path> path page want view. want view/posts/one , use&slug=/posts/one .Your headless CMS might allow include variable draft URL <path> set dynamically based CMS\u2019s data like so:&slug=/posts/{entry.fields.slug} - Route Handler, check secret matches slug parameter exists (if not, request fail), calldraftMode.enable() set cookie. Then, redirect browser path specified byslug : import { draftMode } 'next/headers' import { redirect } 'next/navigation' export async function GET(request: Request) { // Parse query string parameters const { searchParams } = new URL(request.url) const secret = searchParams.get('secret') const slug = searchParams.get('slug') // Check secret next parameters // secret known Route Handler CMS (secret !== 'MY_SECRET_TOKEN' || !slug) { return new Response('Invalid token', { status: 401 }) } // Fetch headless CMS check provided `slug` exists // getPostBySlug would implement required fetching logic headless CMS const post = await getPostBySlug(slug) // slug exist prevent draft mode enabled (!post) { return new Response('Invalid slug', { status: 401 }) } // Enable Draft Mode setting cookie const draft = await draftMode() draft.enable() // Redirect path fetched post // redirect searchParams.slug might lead open redirect vulnerabilities redirect(post.slug) } succeeds, browser redirected path want view draft mode cookie. Step 3: Preview Draft Content next step update page check value draftMode().isEnabled . request page cookie set, data fetched request time (instead build time). Furthermore, value isEnabled true . // page fetches data import { draftMode } 'next/headers' async function getData() { const { isEnabled } = await draftMode() const url = isEnabled ? 'https://draft.example.com' : 'https://production.example.com' const res = await fetch(url) return res.json() } export default async function Page() { const { title, desc } = await getData() return ( <main> <h1>{title}</h1> <p>{desc}</p> </main> ) } access draft Route Handler (with secret slug ) headless CMS manually using URL, able see draft content. And, update draft without publishing, able view draft. Next Steps helpful?"},
{"source": "https://nextjs.org/docs/app/guides/environment-variables", "title": "Guides: Environment Variables | Next.js", "text": "use environment variables Next.js Next.js comes built-in support environment variables, allows following: - Use .env load environment variables - Bundle environment variables browser prefixing NEXT_PUBLIC_ Warning: default create-next-app template ensures all.env files added your.gitignore . almost never want commit files repository. Loading Environment Variables Next.js built-in support loading environment variables .env* files process.env . DB_HOST=localhost DB_USER=myuser DB_PASS=mypassword Note: Next.js also supports multiline variables inside .env* files:# .env # write line breaks PRIVATE_KEY=\"-----BEGIN RSA PRIVATE KEY----- ... Kh9NV... ... -----END DSA PRIVATE KEY-----\" # `\\n` inside double quotes PRIVATE_KEY=\"-----BEGIN RSA PRIVATE KEY-----\\nKh9NV...\\n-----END DSA PRIVATE KEY-----\\n\" Note: using /src folder, please note Next.js load .env files parent folder the/src folder. loadsprocess.env.DB_HOST ,process.env.DB_USER , andprocess.env.DB_PASS Node.js environment automatically allowing use Route Handlers. example: export async function GET() { const db = await myDB.connect({ host: process.env.DB_HOST, username: process.env.DB_USER, password: process.env.DB_PASS, }) // ... } Loading Environment Variables @next/env need load environment variables outside Next.js runtime, root config file ORM test runner, use @next/env package. package used internally Next.js load environment variables .env* files. use it, install package use loadEnvConfig function load environment variables: npm install @next/env import { loadEnvConfig } '@next/env' const projectDir = process.cwd() loadEnvConfig(projectDir) Then, import configuration needed. example: import './envConfig.ts' export default defineConfig({ dbCredentials: { connectionString: process.env.DATABASE_URL!, }, }) Referencing Variables Next.js automatically expand variables use $ reference variables e.g. $VARIABLE inside .env* files. allows reference secrets. example: TWITTER_USER=nextjs TWITTER_URL=https://x.com/$TWITTER_USER example, process.env.TWITTER_URL would set https://x.com/nextjs . Good know: need use variable $ actual value, needs escaped e.g.\\$ . Bundling Environment Variables Browser Non-NEXT_PUBLIC_ environment variables available Node.js environment, meaning accessible browser (the client runs different environment). order make value environment variable accessible browser, Next.js \"inline\" value, build time, js bundle delivered client, replacing references process.env.[variable] hard-coded value. tell this, prefix variable NEXT_PUBLIC_ . example: NEXT_PUBLIC_ANALYTICS_ID=abcdefghijk tell Next.js replace references process.env.NEXT_PUBLIC_ANALYTICS_ID Node.js environment value environment run next build , allowing use anywhere code. inlined JavaScript sent browser. Note: built, app longer respond changes environment variables. instance, use Heroku pipeline promote slugs built one environment another environment, build deploy single Docker image multiple environments, NEXT_PUBLIC_ variables frozen value evaluated build time, values need set appropriately project built. need access runtime environment values, setup API provide client (either demand initialization). import setupAnalyticsService '../lib/my-analytics-service' // 'NEXT_PUBLIC_ANALYTICS_ID' used prefixed 'NEXT_PUBLIC_'. // transformed build time `setupAnalyticsService('abcdefghijk')`. setupAnalyticsService(process.env.NEXT_PUBLIC_ANALYTICS_ID) function HomePage() { return <h1>Hello World</h1> } export default HomePage Note dynamic lookups inlined, as: // inlined, uses variable const varName = 'NEXT_PUBLIC_ANALYTICS_ID' setupAnalyticsService(process.env[varName]) // inlined, uses variable const env = process.env setupAnalyticsService(env.NEXT_PUBLIC_ANALYTICS_ID) Runtime Environment Variables Next.js support build time runtime environment variables. default, environment variables available server. expose environment variable browser, must prefixed NEXT_PUBLIC_ . However, public environment variables inlined JavaScript bundle next build . safely read environment variables server dynamic rendering: import { connection } 'next/server' export default async function Component() { await connection() // cookies, headers, Dynamic APIs // also opt dynamic rendering, meaning // env variable evaluated runtime const value = process.env.MY_VALUE // ... } allows use singular Docker image promoted multiple environments different values. Good know: - run code server startup using register function. - recommend using runtimeConfig option, work standalone output mode. Instead, recommend incrementally adopting App Router need feature. Test Environment Variables Apart development production environments, 3rd option available: test . way set defaults development production environments, .env.test file testing environment (though one common previous two). Next.js load environment variables .env.development .env.production testing environment. one useful running tests tools like jest cypress need set specific environment vars testing purposes. Test default values loaded NODE_ENV set test , though usually need manually testing tools address you. small difference test environment, development production need bear mind: .env.local loaded, expect tests produce results everyone. way every test execution use env defaults across different executions ignoring .env.local (which intended override default set). Good know: similar Default Environment Variables, .env.test file included repository, but.env.test.local shouldn't, as.env*.local intended ignored through.gitignore . running unit tests make sure load environment variables way Next.js leveraging loadEnvConfig function @next/env package. // used Jest global setup file similar testing set-up import { loadEnvConfig } '@next/env' export default async () => { const projectDir = process.cwd() loadEnvConfig(projectDir) } Environment Variable Load Order Environment variables looked following places, order, stopping variable found. process.env .env.$(NODE_ENV).local .env.local (Not checked whenNODE_ENV istest .).env.$(NODE_ENV) .env example, NODE_ENV development define variable .env.development.local .env , value .env.development.local used. Good know: allowed values NODE_ENV areproduction ,development andtest . Good know - using /src directory,.env.* files remain root project. - environment variable NODE_ENV unassigned, Next.js automatically assignsdevelopment running thenext dev command, orproduction commands. Version History | Version | Changes | |---|---| v9.4.0 | Support .env NEXT_PUBLIC_ introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/guides/forms", "title": "Guides: Forms | Next.js", "text": "create forms Server Actions React Server Actions Server Functions execute server. called Server Client Components handle form submissions. guide walk create forms Next.js Server Actions. works React extends HTML <form> element allow Server Actions invoked action attribute. used form, function automatically receives FormData object. extract data using native FormData methods: export default function Page() { async function createInvoice(formData: FormData) { 'use server' const rawFormData = { customerId: formData.get('customerId'), amount: formData.get('amount'), status: formData.get('status'), } // mutate data // revalidate cache } return <form action={createInvoice}>...</form> } Good know: working forms multiple fields, use entries() method JavaScript'sObject.fromEntries() . example:const rawFormData = Object.fromEntries(formData) . Passing additional arguments Outside form fields, pass additional arguments Server Function using JavaScript bind method. example, pass userId argument updateUser Server Function: 'use client' import { updateUser } './actions' export function UserProfile({ userId }: { userId: string }) { const updateUserWithId = updateUser.bind(null, userId) return ( <form action={updateUserWithId}> <input type=\"text\" name=\"name\" /> <button type=\"submit\">Update User Name</button> </form> ) } Server Function receive userId additional argument: 'use server' export async function updateUser(userId: string, formData: FormData) {} Good know: - alternative pass arguments hidden input fields form (e.g. <input type=\"hidden\" name=\"userId\" value={userId} /> ). However, value part rendered HTML encoded.bind works Server Client Components supports progressive enhancement. Form validation Forms validate client server. - client-side validation, use HTML attributes like required andtype=\"email\" basic validation. - server-side validation, use library like zod validate form fields. example: 'use server' import { z } 'zod' const schema = z.object({ email: z.string({ invalid_type_error: 'Invalid Email', }), }) export default async function createUser(formData: FormData) { const validatedFields = schema.safeParse({ email: formData.get('email'), }) // Return early form data invalid (!validatedFields.success) { return { errors: validatedFields.error.flatten().fieldErrors, } } // Mutate data } Validation errors display validation errors messages, turn component defines <form> Client Component use React useActionState . using useActionState , Server function signature change receive new prevState initialState parameter first argument. 'use server' import { z } 'zod' export async function createUser(initialState: any, formData: FormData) { const validatedFields = schema.safeParse({ email: formData.get('email'), }) // ... } conditionally render error message based state object. 'use client' import { useActionState } 'react' import { createUser } '@/app/actions' const initialState = { message: '', } export function Signup() { const [state, formAction, pending] = useActionState(createUser, initialState) return ( <form action={formAction}> <label htmlFor=\"email\">Email</label> <input type=\"text\" id=\"email\" name=\"email\" required /> {/* ... */} <p aria-live=\"polite\">{state?.message}</p> <button disabled={pending}>Sign up</button> </form> ) } Pending states useActionState hook exposes pending boolean used show loading indicator disable submit button action executed. 'use client' import { useActionState } 'react' import { createUser } '@/app/actions' export function Signup() { const [state, formAction, pending] = useActionState(createUser, initialState) return ( <form action={formAction}> {/* form elements */} <button disabled={pending}>Sign up</button> </form> ) } Alternatively, use useFormStatus hook show loading indicator action executed. using hook, need create separate component render loading indicator. example, disable button action pending: 'use client' import { useFormStatus } 'react-dom' export function SubmitButton() { const { pending } = useFormStatus() return ( <button disabled={pending} type=\"submit\"> Sign </button> ) } nest SubmitButton component inside form: import { SubmitButton } './button' import { createUser } '@/app/actions' export function Signup() { return ( <form action={createUser}> {/* form elements */} <SubmitButton /> </form> ) } Good know: React 19, useFormStatus includes additional keys returned object, like data, method, action. using React 19, thepending key available. Optimistic updates use React useOptimistic hook optimistically update UI Server Function finishes executing, rather waiting response: 'use client' import { useOptimistic } 'react' import { send } './actions' type Message = { message: string } export function Thread({ messages }: { messages: Message[] }) { const [optimisticMessages, addOptimisticMessage] = useOptimistic< Message[], string >(messages, (state, newMessage) => [...state, { message: newMessage }]) const formAction = async (formData: FormData) => { const message = formData.get('message') string addOptimisticMessage(message) await send(message) } return ( <div> {optimisticMessages.map((m, i) => ( <div key={i}>{m.message}</div> ))} <form action={formAction}> <input type=\"text\" name=\"message\" /> <button type=\"submit\">Send</button> </form> </div> ) } Nested form elements call Server Actions elements nested inside <form> <button> , <input type=\"submit\"> , <input type=\"image\"> . elements accept formAction prop event handlers. useful cases want call multiple Server Actions within form. example, create specific <button> element saving post draft addition publishing it. See React <form> docs information. Programmatic form submission trigger form submission programmatically using requestSubmit() method. example, user submits form using \u2318 + Enter keyboard shortcut, listen onKeyDown event: 'use client' export function Entry() { const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => { ( (e.ctrlKey || e.metaKey) && (e.key === 'Enter' || e.key === 'NumpadEnter') ) { e.preventDefault() e.currentTarget.form?.requestSubmit() } } return ( <div> <textarea name=\"entry\" rows={20} required onKeyDown={handleKeyDown} /> </div> ) } trigger submission nearest <form> ancestor, invoke Server Function. helpful?"},
{"source": "https://nextjs.org/docs/app/guides/incremental-static-regeneration", "title": "Guides: ISR | Next.js", "text": "implement Incremental Static Regeneration (ISR) Examples Incremental Static Regeneration (ISR) enables to: - Update static content without rebuilding entire site - Reduce server load serving prerendered, static pages requests - Ensure proper cache-control headers automatically added pages - Handle large amounts content pages without long next build times Here's minimal example: interface Post { id: string title: string content: string } // Next.js invalidate cache // request comes in, every 60 seconds. export const revalidate = 60 // prerender params `generateStaticParams` build time. // request comes path generated, // Next.js server-render page on-demand. export const dynamicParams = true // false, 404 unknown paths export async function generateStaticParams() { const posts: Post[] = await fetch('https://api.vercel.app/blog').then((res) => res.json() ) return posts.map((post) => ({ id: String(post.id), })) } export default async function Page({ params, }: { params: Promise<{ id: string }> }) { const { id } = await params const post: Post = await fetch(`https://api.vercel.app/blog/${id}`).then( (res) => res.json() ) return ( <main> <h1>{post.title}</h1> <p>{post.content}</p> </main> ) } Here's example works: - next build , known blog posts generated (there 25 example) - requests made pages (e.g. /blog/1 ) cached instantaneous - 60 seconds passed, next request still show cached (stale) page - cache invalidated new version page begins generating background - generated successfully, Next.js display cache updated page - /blog/26 requested, Next.js generate cache page on-demand Reference Route segment config Functions Examples Time-based revalidation fetches displays list blog posts /blog . hour, cache page invalidated next visit page. Then, background, new version page generated latest blog posts. interface Post { id: string title: string content: string } export const revalidate = 3600 // invalidate every hour export default async function Page() { const data = await fetch('https://api.vercel.app/blog') const posts: Post[] = await data.json() return ( <main> <h1>Blog Posts</h1> <ul> {posts.map((post) => ( <li key={post.id}>{post.title}</li> ))} </ul> </main> ) } recommend setting high revalidation time. instance, 1 hour instead 1 second. need precision, consider using on-demand revalidation. need real-time data, consider switching dynamic rendering. On-demand revalidation revalidatePath precise method revalidation, invalidate pages on-demand revalidatePath function. example, Server Action would get called adding new post. Regardless retrieve data Server Component, either using fetch connecting database, clear cache entire route allow Server Component fetch fresh data. 'use server' import { revalidatePath } 'next/cache' export async function createPost() { // Invalidate /posts route cache revalidatePath('/posts') } View demo explore source code. On-demand revalidation revalidateTag use cases, prefer revalidating entire paths. need granular control, use revalidateTag function. example, tag individual fetch calls: export default async function Page() { const data = await fetch('https://api.vercel.app/blog', { next: { tags: ['posts'] }, }) const posts = await data.json() // ... } using ORM connecting database, use unstable_cache : import { unstable_cache } 'next/cache' import { db, posts } '@/lib/db' const getCachedPosts = unstable_cache( async () => { return await db.select().from(posts) }, ['posts'], { revalidate: 3600, tags: ['posts'] } ) export default async function Page() { const posts = getCachedPosts() // ... } use revalidateTag Server Actions Route Handler: 'use server' import { revalidateTag } 'next/cache' export async function createPost() { // Invalidate data tagged 'posts' cache revalidateTag('posts') } Handling uncaught exceptions error thrown attempting revalidate data, last successfully generated data continue served cache. next subsequent request, Next.js retry revalidating data. Learn error handling. Customizing cache location configure Next.js cache location want persist cached pages data durable storage, share cache across multiple containers instances Next.js application. Learn more. Troubleshooting Debugging cached data local development using fetch API, add additional logging understand requests cached uncached. Learn logging option. module.exports = { logging: { fetches: { fullUrl: true, }, }, } Verifying correct production behavior verify pages cached revalidated correctly production, test locally running next build next start run production Next.js server. allow test ISR behavior would work production environment. debugging, add following environment variable .env file: NEXT_PRIVATE_DEBUG_CACHE=1 make Next.js server console log ISR cache hits misses. inspect output see pages generated next build , well pages updated paths accessed on-demand. Caveats - ISR supported using Node.js runtime (default). - ISR supported creating Static Export. - multiple fetch requests statically rendered route, differentrevalidate frequency, lowest time used ISR. However, revalidate frequencies still respected Data Cache. - fetch requests used route arevalidate time of0 , explicitno-store , route dynamically rendered. - Middleware executed on-demand ISR requests, meaning path rewrites logic Middleware applied. Ensure revalidating exact path. example, /post/1 instead rewritten/post-1 . Platform Support | Deployment Option | Supported | |---|---| | Node.js server | Yes | | Docker container | Yes | | Static export | | | Adapters | Platform-specific | Learn configure ISR self-hosting Next.js. Version history | Version | Changes | |---|---| v14.1.0 | Custom cacheHandler stable. | v13.0.0 | App Router introduced. | v12.2.0 | Pages Router: On-Demand ISR stable | v12.0.0 | Pages Router: Bot-aware ISR fallback added. | v9.5.0 | Pages Router: Stable ISR introduced. | helpful?"},
{"source": "https://nextjs.org/docs/app/guides/instrumentation", "title": "Guides: Instrumentation | Next.js", "text": "set instrumentation Instrumentation process using code integrate monitoring logging tools application. allows track performance behavior application, debug issues production. Convention set instrumentation, create instrumentation.ts|js file root directory project (or inside src folder using one). Then, export register function file. function called new Next.js server instance initiated. example, use Next.js OpenTelemetry @vercel/otel: import { registerOTel } '@vercel/otel' export function register() { registerOTel('next-app') } See Next.js OpenTelemetry example complete implementation. Good know: - instrumentation file root project inside theapp orpages directory. using thesrc folder, place file insidesrc alongsidepages andapp .- use pageExtensions config option add suffix, also need update theinstrumentation filename match. Examples Importing files side effects Sometimes, may useful import file code side effects cause. example, might import file defines set global variables, never explicitly use imported file code. would still access global variables package declared. recommend importing files using JavaScript import syntax within register function. following example demonstrates basic usage import register function: export async function register() { await import('package-with-side-effect') } Good know: recommend importing file within register function, rather top file. this, colocate side effects one place code, avoid unintended consequences importing globally top file. Importing runtime-specific code Next.js calls register environments, important conditionally import code support specific runtimes (e.g. Edge Node.js). use NEXT_RUNTIME environment variable get current environment: export async function register() { (process.env.NEXT_RUNTIME === 'nodejs') { await import('./instrumentation-node') } (process.env.NEXT_RUNTIME === 'edge') { await import('./instrumentation-edge') } } Learn Instrumentation helpful?"},
{"source": "https://nextjs.org/docs/app/guides/internationalization", "title": "Guides: Internationalization | Next.js", "text": "Internationalization Next.js enables configure routing rendering content support multiple languages. Making site adaptive different locales includes translated content (localization) internationalized routes. Terminology - Locale: identifier set language formatting preferences. usually includes preferred language user possibly geographic region. en-US : English spoken United Statesnl-NL : Dutch spoken Netherlandsnl : Dutch, specific region Routing Overview It\u2019s recommended use user\u2019s language preferences browser select locale use. Changing preferred language modify incoming Accept-Language header application. example, using following libraries, look incoming Request determine locale select, based Headers , locales plan support, default locale. import { match } '@formatjs/intl-localematcher' import Negotiator 'negotiator' let headers = { 'accept-language': 'en-US,en;q=0.5' } let languages = new Negotiator({ headers }).languages() let locales = ['en-US', 'nl-NL', 'nl'] let defaultLocale = 'en-US' match(languages, locales, defaultLocale) // -> 'en-US' Routing internationalized either sub-path (/fr/products ) domain (my-site.fr/products ). information, redirect user based locale inside Middleware. import { NextResponse } \"next/server\"; let locales = ['en-US', 'nl-NL', 'nl'] // Get preferred locale, similar using library function getLocale(request) { ... } export function middleware(request) { // Check supported locale pathname const { pathname } = request.nextUrl const pathnameHasLocale = locales.some( (locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}` ) (pathnameHasLocale) return // Redirect locale const locale = getLocale(request) request.nextUrl.pathname = `/${locale}${pathname}` // e.g. incoming request /products // new URL /en-US/products return NextResponse.redirect(request.nextUrl) } export const config = { matcher: [ // Skip internal paths (_next) '/((?!_next).*)', // Optional: run root (/) URL // '/' ], } Finally, ensure special files inside app/ nested app/[lang] . enables Next.js router dynamically handle different locales route, forward lang parameter every layout page. example: // access current locale // e.g. /en-US/products -> `lang` \"en-US\" export default async function Page({ params, }: { params: Promise<{ lang: string }> }) { const { lang } = await params return ... } root layout also nested new folder (e.g. app/[lang]/layout.js ). Localization Changing displayed content based user\u2019s preferred locale, localization, something specific Next.js. patterns described would work web application. Let\u2019s assume want support English Dutch content inside application. might maintain two different \u201cdictionaries\u201d, objects give us mapping key localized string. example: { \"products\": { \"cart\": \"Add Cart\" } } { \"products\": { \"cart\": \"Toevoegen aan Winkelwagen\" } } create getDictionary function load translations requested locale: import 'server-only' const dictionaries = { en: () => import('./dictionaries/en.json').then((module) => module.default), nl: () => import('./dictionaries/nl.json').then((module) => module.default), } export const getDictionary = async (locale: 'en' | 'nl') => dictionaries[locale]() Given currently selected language, fetch dictionary inside layout page. import { getDictionary } './dictionaries' export default async function Page({ params, }: { params: Promise<{ lang: 'en' | 'nl' }> }) { const { lang } = await params const dict = await getDictionary(lang) // en return <button>{dict.products.cart}</button> // Add Cart } layouts pages app/ directory default Server Components, need worry size translation files affecting client-side JavaScript bundle size. code run server, resulting HTML sent browser. Static Rendering generate static routes given set locales, use generateStaticParams page layout. global, example, root layout: export async function generateStaticParams() { return [{ lang: 'en-US' }, { lang: 'de' }] } export default async function RootLayout({ children, params, }: Readonly<{ children: React.ReactNode params: Promise<{ lang: 'en-US' | 'de' }> }>) { return ( <html lang={(await params).lang}> <body>{children}</body> </html> ) } Resources helpful?"},
{"source": "https://nextjs.org/docs/app/guides/json-ld", "title": "Guides: JSON-LD | Next.js", "text": "implement JSON-LD Next.js application JSON-LD format structured data used search engines AI help understand structure page beyond pure content. example, use describe person, event, organization, movie, book, recipe, many types entities. current recommendation JSON-LD render structured data <script> tag layout.js page.js components. example: app/products/[id]/page.tsx export default async function Page({ params }) { const { id } = await params const product = await getProduct(id) const jsonLd = { '@context': 'https://schema.org', '@type': 'Product', name: product.name, image: product.image, description: product.description, } return ( <section> {/* Add JSON-LD page */} <script type=\"application/ld+json\" dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }} /> {/* ... */} </section> ) } validate test structured data Rich Results Test Google generic Schema Markup Validator. type JSON-LD TypeScript using community packages like schema-dts : import { Product, WithContext } 'schema-dts' const jsonLd: WithContext<Product> = { '@context': 'https://schema.org', '@type': 'Product', name: 'Next.js Sticker', image: 'https://nextjs.org/imgs/sticker.png', description: 'Dynamic speed static.', } helpful?"},
{"source": "https://nextjs.org/docs/app/guides/lazy-loading", "title": "Guides: Lazy Loading | Next.js", "text": "lazy load Client Components libraries Lazy loading Next.js helps improve initial loading performance application decreasing amount JavaScript needed render route. allows defer loading Client Components imported libraries, include client bundle needed. example, might want defer loading modal user clicks open it. two ways implement lazy loading Next.js: - Using Dynamic Imports next/dynamic - Using React.lazy() Suspense default, Server Components automatically code split, use streaming progressively send pieces UI server client. Lazy loading applies Client Components. next/dynamic next/dynamic composite React.lazy() Suspense. behaves way app pages directories allow incremental migration. Examples Importing Client Components 'use client' import { useState } 'react' import dynamic 'next/dynamic' // Client Components: const ComponentA = dynamic(() => import('../components/A')) const ComponentB = dynamic(() => import('../components/B')) const ComponentC = dynamic(() => import('../components/C'), { ssr: false }) export default function ClientComponentExample() { const [showMore, setShowMore] = useState(false) return ( <div> {/* Load immediately, separate client bundle */} <ComponentA /> {/* Load demand, when/if condition met */} {showMore && <ComponentB />} <button onClick={() => setShowMore(!showMore)}>Toggle</button> {/* Load client side */} <ComponentC /> </div> ) } Note: Server Component dynamically imports Client Component, automatic code splitting currently supported. Skipping SSR using React.lazy() Suspense, Client Components prerendered (SSR) default. Note: ssr: false option work Client Components, move Client Components ensure client code-splitting working properly. want disable pre-rendering Client Component, use ssr option set false : const ComponentC = dynamic(() => import('../components/C'), { ssr: false }) Importing Server Components dynamically import Server Component, Client Components children Server Component lazy-loaded - Server Component itself. also help preload static assets CSS using Server Components. import dynamic 'next/dynamic' // Server Component: const ServerComponent = dynamic(() => import('../components/ServerComponent')) export default function ServerComponentExample() { return ( <div> <ServerComponent /> </div> ) } Note: ssr: false option supported Server Components. see error try use Server Components.ssr: false allowed withnext/dynamic Server Components. Please move Client Component. Loading External Libraries External libraries loaded demand using import() function. example uses external library fuse.js fuzzy search. module loaded client user types search input. 'use client' import { useState } 'react' const names = ['Tim', 'Joe', 'Bel', 'Lee'] export default function Page() { const [results, setResults] = useState() return ( <div> <input type=\"text\" placeholder=\"Search\" onChange={async (e) => { const { value } = e.currentTarget // Dynamically load fuse.js const Fuse = (await import('fuse.js')).default const fuse = new Fuse(names) setResults(fuse.search(value)) }} /> <pre>Results: {JSON.stringify(results, null, 2)}</pre> </div> ) } Adding custom loading component 'use client' import dynamic 'next/dynamic' const WithCustomLoading = dynamic( () => import('../components/WithCustomLoading'), { loading: () => <p>Loading...</p>, } ) export default function Page() { return ( <div> {/* loading component rendered <WithCustomLoading/> loading */} <WithCustomLoading /> </div> ) } Importing Named Exports dynamically import named export, return Promise returned import() function: 'use client' export function Hello() { return <p>Hello!</p> } import dynamic 'next/dynamic' const ClientComponent = dynamic(() => import('../components/hello').then((mod) => mod.Hello) ) helpful?"},
{"source": "https://nextjs.org/docs/app/guides/local-development", "title": "Guides: Development Environment | Next.js", "text": "optimize local development environment Next.js designed provide great developer experience. application grows, might notice slower compilation times local development. guide help identify fix common compile-time performance issues. Local dev vs. production development process next dev different next build next start . next dev compiles routes application open navigate them. enables start dev server without waiting every route application compile, faster uses less memory. Running production build applies optimizations, like minifying files creating content hashes, needed local development. Improving local dev performance 1. Check computer's antivirus Antivirus software slow file access. Try adding project folder antivirus exclusion list. common Windows machines, recommend system antivirus tool installed. 2. Update Next.js enable Turbopack Make sure using latest version Next.js. new version often includes performance improvements. Turbopack new bundler integrated Next.js improve local performance. npm install next@latest npm run dev --turbopack Learn Turbopack. See upgrade guides codemods information. 3. Check imports way import code greatly affect compilation bundling time. Learn optimizing package bundling explore tools like Dependency Cruiser Madge. Icon libraries Libraries like @material-ui/icons react-icons import thousands icons, even use few. Try import icons need: // Instead this: import { Icon1, Icon2 } 'react-icons/md' // this: import Icon1 'react-icons/md/Icon1' import Icon2 'react-icons/md/Icon2' Libraries like react-icons includes many different icon sets. Choose one set stick set. example, application uses react-icons imports these: pi (Phosphor Icons)md (Material Design Icons)tb (tabler-icons)cg (cssgg) Combined tens thousands modules compiler handle, even use single import each. Barrel files \"Barrel files\" files export many items files. slow builds compiler parse find side-effects module scope using import. Try import directly specific files possible. Learn barrel files built-in optimizations Next.js. Optimize package imports Next.js automatically optimize imports certain packages. using packages utilize barrel files, add next.config.js : module.exports = { experimental: { optimizePackageImports: ['package-name'], }, } Turbopack automatically analyzes imports optimizes them. require configuration. 4. Check Tailwind CSS setup using Tailwind CSS, make sure set correctly. common mistake configuring content array way includes node_modules large directories files scanned. Tailwind CSS version 3.4.8 newer warn settings might slow build. - tailwind.config.js , specific files scan:module.exports = { content: [ './src/**/*.{js,ts,jsx,tsx}', // Good // might broad // match `packages/**/node_modules` // '../../packages/**/*.{js,ts,jsx,tsx}', ], } - Avoid scanning unnecessary files: module.exports = { content: [ // Better - scans 'src' folder '../../packages/ui/src/**/*.{js,ts,jsx,tsx}', ], } 5. Check custom webpack settings added custom webpack settings, might slowing compilation. Consider really need local development. optionally include certain tools production builds, explore moving Turbopack using loaders. 6. Optimize memory usage app large, might need memory. Learn optimizing memory usage. 7. Server Components data fetching Changes Server Components cause entire page re-render locally order show new changes, includes fetching new data component. experimental serverComponentsHmrCache option allows cache fetch responses Server Components across Hot Module Replacement (HMR) refreshes local development. results faster responses reduced costs billed API calls. Learn experimental option. Tools finding problems Detailed fetch logging Use logging.fetches option next.config.js file, see detailed information what's happening development: module.exports = { logging: { fetches: { fullUrl: true, }, }, } Learn fetch logging. Turbopack tracing Turbopack tracing tool helps understand performance application local development. provides detailed information time taken module compile related. - Make sure latest version Next.js installed. - Generate Turbopack trace file: NEXT_TURBOPACK_TRACING=1 npm run dev - Navigate around application make edits files reproduce problem. - Stop Next.js development server. - file called trace-turbopack available the.next folder. - interpret file using next internal trace [path-to-file] :next internal trace .next/trace-turbopack versions trace available, command namedturbo-trace-server :next internal turbo-trace-server .next/trace-turbopack - trace server running view trace https://trace.nextjs.org/. - default trace viewer aggregate timings, order see individual time switch \"Aggregated order\" \"Spans order\" top right viewer. Still problems? Share trace file generated Turbopack Tracing section share GitHub Discussions Discord. helpful?"},
{"source": "https://nextjs.org/docs/app/guides/mdx", "title": "Guides: MDX | Next.js", "text": "use markdown MDX Next.js Markdown lightweight markup language used format text. allows write using plain text syntax convert structurally valid HTML. commonly used writing content websites blogs. write... **love** using [Next.js](https://nextjs.org/) Output: <p>I <strong>love</strong> using <a href=\"https://nextjs.org/\">Next.js</a></p> MDX superset markdown lets write JSX directly markdown files. powerful way add dynamic interactivity embed React components within content. Next.js support local MDX content inside application, well remote MDX files fetched dynamically server. Next.js plugin handles transforming markdown React components HTML, including support usage Server Components (the default App Router). Good know: View Portfolio Starter Kit template complete working example. Install dependencies @next/mdx package, related packages, used configure Next.js process markdown MDX. sources data local files, allowing create pages .md .mdx extension, directly /pages /app directory. Install packages render MDX Next.js: npm install @next/mdx @mdx-js/loader @mdx-js/react @types/mdx Configure next.config.mjs Update next.config.mjs file project's root configure use MDX: import createMDX '@next/mdx' /** @type {import('next').NextConfig} */ const nextConfig = { // Configure `pageExtensions` include markdown MDX files pageExtensions: ['js', 'jsx', 'md', 'mdx', 'ts', 'tsx'], // Optionally, add Next.js config } const withMDX = createMDX({ // Add markdown plugins here, desired }) // Merge MDX config Next.js config export default withMDX(nextConfig) allows .mdx files act pages, routes, imports application. Handling .md files default, next/mdx compiles files .mdx extension. handle .md files webpack, update extension option: const withMDX = createMDX({ extension: /\\.(md|mdx)$/, }) Good know: Turbopack currently support extension option therefore support.md files. Add mdx-components.tsx file Create mdx-components.tsx (or .js ) file root project define global MDX Components. example, level pages app , inside src applicable. import type { MDXComponents } 'mdx/types' export function useMDXComponents(components: MDXComponents): MDXComponents { return { ...components, } } Good know: mdx-components.tsx required use@next/mdx App Router work without it.- Learn mdx-components.tsx file convention.- Learn use custom styles components. Rendering MDX render MDX using Next.js's file based routing importing MDX files pages. Using file based routing using file based routing, use MDX pages like page. App Router apps, includes able use metadata. Create new MDX page within /app directory: my-project \u251c\u2500\u2500 app \u2502 \u2514\u2500\u2500 mdx-page \u2502 \u2514\u2500\u2500 page.(mdx/md) |\u2500\u2500 mdx-components.(tsx/js) \u2514\u2500\u2500 package.json use MDX files, even import React components, directly inside MDX page: import { MyComponent } 'my-component' # Welcome MDX page! **bold** _italics_ text. list markdown: - One - Two - Three Checkout React component: <MyComponent /> Navigating /mdx-page route display rendered MDX page. Using imports Create new page within /app directory MDX file wherever like: . \u251c\u2500\u2500 app/ \u2502 \u2514\u2500\u2500 mdx-page/ \u2502 \u2514\u2500\u2500 page.(tsx/js) \u251c\u2500\u2500 markdown/ \u2502 \u2514\u2500\u2500 welcome.(mdx/md) \u251c\u2500\u2500 mdx-components.(tsx/js) \u2514\u2500\u2500 package.json use MDX files, even import React components, directly inside MDX page: Import MDX file inside page display content: import Welcome '@/markdown/welcome.mdx' export default function Page() { return <Welcome /> } Navigating /mdx-page route display rendered MDX page. Using dynamic imports import dynamic MDX components instead using filesystem routing MDX files. example, dynamic route segment loads MDX components separate directory: generateStaticParams used prerender provided routes. marking dynamicParams false , accessing route defined generateStaticParams 404. export default async function Page({ params, }: { params: Promise<{ slug: string }> }) { const { slug } = await params const { default: Post } = await import(`@/content/${slug}.mdx`) return <Post /> } export function generateStaticParams() { return [{ slug: 'welcome' }, { slug: 'about' }] } export const dynamicParams = false Good know: Ensure specify .mdx file extension import. required use module path aliases (e.g.,@/content ), simplify import path. Using custom styles components Markdown, rendered, maps native HTML elements. example, writing following markdown: ## heading list markdown: - One - Two - Three Generates following HTML: <h2>This heading</h2> <p>This list markdown:</p> <ul> <li>One</li> <li>Two</li> <li>Three</li> </ul> style markdown, provide custom components map generated HTML elements. Styles components implemented globally, locally, shared layouts. Global styles components Adding styles components mdx-components.tsx affect MDX files application. import type { MDXComponents } 'mdx/types' import Image, { ImageProps } 'next/image' // file allows provide custom React components // used MDX files. import use // React component want, including inline styles, // components libraries, more. export function useMDXComponents(components: MDXComponents): MDXComponents { return { // Allows customizing built-in components, e.g. add styling. h1: ({ children }) => ( <h1 style={{ color: 'red', fontSize: '48px' }}>{children}</h1> ), img: (props) => ( <Image sizes=\"100vw\" style={{ width: '100%', height: 'auto' }} {...(props ImageProps)} /> ), ...components, } } Local styles components apply local styles components specific pages passing imported MDX components. merge override global styles components. import Welcome '@/markdown/welcome.mdx' function CustomH1({ children }) { return <h1 style={{ color: 'blue', fontSize: '100px' }}>{children}</h1> } const overrideComponents = { h1: CustomH1, } export default function Page() { return <Welcome components={overrideComponents} /> } Shared layouts share layout across MDX pages, use built-in layouts support App Router. export default function MdxLayout({ children }: { children: React.ReactNode }) { // Create shared layout styles return <div style={{ color: 'blue' }}>{children}</div> } Using Tailwind typography plugin using Tailwind style application, using @tailwindcss/typography plugin allow reuse Tailwind configuration styles markdown files. plugin adds set prose classes used add typographic styles content blocks come sources, like markdown. Install Tailwind typography use shared layouts add prose want. export default function MdxLayout({ children }: { children: React.ReactNode }) { // Create shared layout styles return ( <div className=\"prose prose-headings:mt-8 prose-headings:font-semibold prose-headings:text-black prose-h1:text-5xl prose-h2:text-4xl prose-h3:text-3xl prose-h4:text-2xl prose-h5:text-xl prose-h6:text-lg dark:prose-headings:text-white\"> {children} </div> ) } Frontmatter Frontmatter YAML like key/value pairing used store data page. @next/mdx support frontmatter default, though many solutions adding frontmatter MDX content, as: @next/mdx allow use exports like JavaScript component: Metadata referenced outside MDX file: import BlogPost, { metadata } '@/content/blog-post.mdx' export default function Page() { console.log('metadata: ', metadata) //=> { author: 'John Doe' } return <BlogPost /> } common use case want iterate collection MDX extract data. example, creating blog index page blog posts. use packages like Node's fs module globby read directory posts extract metadata. Good know: - Using fs ,globby , etc. used server-side.- View Portfolio Starter Kit template complete working example. remark rehype Plugins optionally provide remark rehype plugins transform MDX content. example, use remark-gfm support GitHub Flavored Markdown. Since remark rehype ecosystem ESM only, need use next.config.mjs next.config.ts configuration file. import remarkGfm 'remark-gfm' import createMDX '@next/mdx' /** @type {import('next').NextConfig} */ const nextConfig = { // Allow .mdx extensions files pageExtensions: ['js', 'jsx', 'md', 'mdx', 'ts', 'tsx'], // Optionally, add Next.js config } const withMDX = createMDX({ // Add markdown plugins here, desired options: { remarkPlugins: [remarkGfm], rehypePlugins: [], }, }) // Combine MDX Next.js config export default withMDX(nextConfig) Using Plugins Turbopack use plugins Turbopack, upgrade latest @next/mdx specify plugin names using string: import createMDX '@next/mdx' /** @type {import('next').NextConfig} */ const nextConfig = { pageExtensions: ['js', 'jsx', 'md', 'mdx', 'ts', 'tsx'], } const withMDX = createMDX({ options: { remarkPlugins: [], rehypePlugins: [['rehype-katex', { strict: true, throwOnError: true }]], }, }) export default withMDX(nextConfig) Good know: remark rehype plugins without serializable options cannot used yet Turbopack, due inability pass JavaScript functions Rust Remote MDX MDX files content lives somewhere else, fetch dynamically server. useful content stored CMS, database, anywhere else. community package use next-mdx-remote-client . Good know: Please proceed caution. MDX compiles JavaScript executed server. fetch MDX content trusted source, otherwise lead remote code execution (RCE). following example uses next-mdx-remote-client : import { MDXRemote } 'next-mdx-remote-client/rsc' export default async function RemoteMdxPage() { // MDX text - database, CMS, fetch, anywhere... const res = await fetch('https://...') const markdown = await res.text() return <MDXRemote source={markdown} /> } Navigating /mdx-page-remote route display rendered MDX. Deep Dive: transform markdown HTML? React natively understand markdown. markdown plaintext needs first transformed HTML. accomplished remark rehype . remark ecosystem tools around markdown. rehype same, HTML. example, following code snippet transforms markdown HTML: import { unified } 'unified' import remarkParse 'remark-parse' import remarkRehype 'remark-rehype' import rehypeSanitize 'rehype-sanitize' import rehypeStringify 'rehype-stringify' main() async function main() { const file = await unified() .use(remarkParse) // Convert markdown AST .use(remarkRehype) // Transform HTML AST .use(rehypeSanitize) // Sanitize HTML input .use(rehypeStringify) // Convert AST serialized HTML .process('Hello, Next.js!') console.log(String(file)) // <p>Hello, Next.js!</p> } remark rehype ecosystem contains plugins syntax highlighting, linking headings, generating table contents, more. using @next/mdx shown above, need use remark rehype directly, handled you. describing deeper understanding @next/mdx package underneath. Using Rust-based MDX compiler (experimental) Next.js supports new MDX compiler written Rust. compiler still experimental recommended production use. use new compiler, need configure next.config.js pass withMDX : module.exports = withMDX({ experimental: { mdxRs: true, }, }) mdxRs also accepts object configure transform mdx files. module.exports = withMDX({ experimental: { mdxRs: { jsxRuntime?: string // Custom jsx runtime jsxImportSource?: string // Custom jsx import source, mdxType?: 'gfm' | 'commonmark' // Configure kind mdx syntax used parse & transform }, }, }) Helpful Links helpful?"},
{"source": "https://nextjs.org/docs/app/guides/memory-usage", "title": "Guides: Memory Usage | Next.js", "text": "optimize memory usage applications grow become feature rich, demand resources developing locally creating production builds. Let's explore strategies techniques optimize memory address common memory issues Next.js. Reduce number dependencies Applications large amount dependencies use memory. Bundle Analyzer help investigate large dependencies application may able removed improve performance memory usage. Try experimental.webpackMemoryOptimizations Starting v15.0.0 , add experimental.webpackMemoryOptimizations: true next.config.js file change behavior Webpack reduces max memory usage may increase compilation times slight amount. Good know: feature currently experimental test projects first, considered low-risk. Run next build --experimental-debug-memory-usage Starting 14.2.0 , run next build --experimental-debug-memory-usage run build mode Next.js print information memory usage continuously throughout build, heap usage garbage collection statistics. Heap snapshots also taken automatically memory usage gets close configured limit. Good know: feature compatible Webpack build worker option auto-enabled unless custom webpack config. Record heap profile look memory issues, record heap profile Node.js load Chrome DevTools identify potential sources memory leaks. terminal, pass --heap-prof flag Node.js starting Next.js build: node --heap-prof node_modules/next/dist/bin/next build end build, .heapprofile file created Node.js. Chrome DevTools, open Memory tab click \"Load Profile\" button visualize file. Analyze snapshot heap use inspector tool analyze memory usage application. running next build next dev command, add NODE_OPTIONS=--inspect beginning command. expose inspector agent default port. wish break user code starts, pass --inspect-brk instead. process running, use tool Chrome DevTools connect debugging port record analyze snapshot heap see memory retained. Starting 14.2.0 , also run next build --experimental-debug-memory-usage flag make easier take heap snapshots. running mode, send SIGUSR2 signal process point, process take heap snapshot. heap snapshot saved project root Next.js application loaded heap analyzer, Chrome DevTools, see memory retained. mode yet compatible Webpack build workers. See record analyze heap snapshots information. Webpack build worker Webpack build worker allows run Webpack compilations inside separate Node.js worker decrease memory usage application builds. option enabled default application custom Webpack configuration starting v14.1.0 . using older version Next.js custom Webpack configuration, enable option setting experimental.webpackBuildWorker: true inside next.config.js . Good know: feature may compatible custom Webpack plugins. Disable Webpack cache Webpack cache saves generated Webpack modules memory and/or disk improve speed builds. help performance, also increase memory usage application store cached data. disable behavior adding custom Webpack configuration application: /** @type {import('next').NextConfig} */ const nextConfig = { webpack: ( config, { buildId, dev, isServer, defaultLoaders, nextRuntime, webpack } ) => { (config.cache && !dev) { config.cache = Object.freeze({ type: 'memory', }) } // Important: return modified config return config }, } export default nextConfig Disable static analysis Typechecking linting may require lot memory, especially large projects. However, projects dedicated CI runner already handles tasks. build produces out-of-memory issues \"Linting checking validity types\" step, disable task builds: /** @type {import('next').NextConfig} */ const nextConfig = { eslint: { // Warning: allows production builds successfully complete even // project ESLint errors. ignoreDuringBuilds: true, }, typescript: { // !! WARN !! // Dangerously allow production builds successfully complete even // project type errors. // !! WARN !! ignoreBuildErrors: true, }, } export default nextConfig Keep mind may produce faulty deploys due type errors linting issues. strongly recommend promoting builds production static analysis completed. deploy Vercel, check guide staging deployments learn promote builds production custom tasks succeeded. Disable source maps Generating source maps consumes extra memory build process. disable source map generation adding productionBrowserSourceMaps: false experimental.serverSourceMaps: false Next.js configuration. Good know: plugins may turn source maps may require custom configuration disable. Edge memory issues Next.js v14.1.3 fixed memory issue using Edge runtime. Please update version (or later) see addresses issue. helpful?"},
{"source": "https://nextjs.org/docs/app/guides/migrating", "title": "Guides: Migrating | Next.js", "text": "Migrating App Router Learn upgrade existing Next.js application Pages Router App Router. Create React App Learn migrate existing React application Create React App Next.js. Vite Learn migrate existing React application Vite Next.js. helpful?"},
{"source": "https://nextjs.org/docs/app/guides/migrating/app-router-migration", "title": "Migrating: App Router | Next.js", "text": "migrate Pages App Router guide help you: - Update Next.js application version 12 version 13 - Upgrade features work pages theapp directories - Incrementally migrate existing application pages toapp Upgrading Node.js Version minimum Node.js version v18.17. See Node.js documentation information. Next.js Version update Next.js version 13, run following command using preferred package manager: npm install next@latest react@latest react-dom@latest ESLint Version using ESLint, need upgrade ESLint version: npm install -D eslint-config-next@latest Good know: may need restart ESLint server VS Code ESLint changes take effect. Open Command Palette ( cmd+shift+p Mac;ctrl+shift+p Windows) search forESLint: Restart ESLint Server . Next Steps updated, see following sections next steps: - Upgrade new features: guide help upgrade new features improved Image Link Components. - Migrate pages toapp directory: step-by-step guide help incrementally migrate thepages theapp directory. Upgrading New Features Next.js 13 introduced new App Router new features conventions. new Router available app directory co-exists pages directory. Upgrading Next.js 13 require using App Router. continue using pages new features work directories, updated Image component, Link component, Script component, Font optimization. <Image/> Component Next.js 12 introduced new improvements Image Component temporary import: next/future/image . improvements included less client-side JavaScript, easier ways extend style images, better accessibility, native browser lazy loading. version 13, new behavior default next/image . two codemods help migrate new Image Component: next-image-to-legacy-image codemod: Safely automatically renamesnext/image imports tonext/legacy/image . Existing components maintain behavior.next-image-experimental codemod: Dangerously adds inline styles removes unused props. change behavior existing components match new defaults. use codemod, need run thenext-image-to-legacy-image codemod first. <Link> Component <Link> Component longer requires manually adding <a> tag child. behavior added experimental option version 12.2 default. Next.js 13, <Link> always renders <a> allows forward props underlying tag. example: import Link 'next/link' // Next.js 12: `<a>` nested otherwise excluded <Link href=\"/about\"> <a>About</a> </Link> // Next.js 13: `<Link>` always renders `<a>` hood <Link href=\"/about\"> </Link> upgrade links Next.js 13, use new-link codemod. <Script> Component behavior next/script updated support pages app , changes need made ensure smooth migration: - Move beforeInteractive scripts previously included in_document.js root layout file (app/layout.tsx ). - experimental worker strategy yet work inapp scripts denoted strategy either removed modified use different strategy (e.g.lazyOnload ). onLoad ,onReady , andonError handlers work Server Components make sure move Client Component remove altogether. Font Optimization Previously, Next.js helped optimize fonts inlining font CSS. Version 13 introduces new next/font module gives ability customize font loading experience still ensuring great performance privacy. next/font supported pages app directories. inlining CSS still works pages , work app . use next/font instead. See Font Optimization page learn use next/font . Migrating pages app \ud83c\udfa5 Watch: Learn incrementally adopt App Router \u2192 YouTube (16 minutes). Moving App Router may first time using React features Next.js builds top Server Components, Suspense, more. combined new Next.js features special files layouts, migration means new concepts, mental models, behavioral changes learn. recommend reducing combined complexity updates breaking migration smaller steps. app directory intentionally designed work simultaneously pages directory allow incremental page-by-page migration. - app directory supports nested routes layouts. Learn more. - Use nested folders define routes special page.js file make route segment publicly accessible. Learn more. - Special file conventions used create UI route segment. common special files page.js andlayout.js .- Use page.js define UI unique route. - Use layout.js define UI shared across multiple routes. .js ,.jsx , or.tsx file extensions used special files. - Use - colocate files inside app directory components, styles, tests, more. Learn more. - Data fetching functions like getServerSideProps andgetStaticProps replaced new API insideapp .getStaticPaths replaced withgenerateStaticParams . pages/_app.js andpages/_document.js replaced singleapp/layout.js root layout. Learn more.pages/_error.js replaced granularerror.js special files. Learn more.pages/404.js replaced thenot-found.js file.pages/api/* API Routes replaced theroute.js (Route Handler) special file. Step 1: Creating app directory Update latest Next.js version (requires 13.4 greater): npm install next@latest Then, create new app directory root project (or src/ directory). Step 2: Creating Root Layout Create new app/layout.tsx file inside app directory. root layout apply routes inside app . export default function RootLayout({ // Layouts must accept children prop. // populated nested layouts pages children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body>{children}</body> </html> ) } - app directory must include root layout. - root layout must define <html> , and<body> tags since Next.js automatically create - root layout replaces pages/_app.tsx andpages/_document.tsx files. .js ,.jsx , or.tsx extensions used layout files. manage <head> HTML elements, use built-in SEO support: import type { Metadata } 'next' export const metadata: Metadata = { title: 'Home', description: 'Welcome Next.js', } Migrating _document.js _app.js existing _app _document file, copy contents (e.g. global styles) root layout (app/layout.tsx ). Styles app/layout.tsx apply pages/* . keep _app /_document migrating prevent pages/* routes breaking. fully migrated, safely delete them. using React Context providers, need moved Client Component. Migrating getLayout() pattern Layouts (Optional) Next.js recommended adding property Page components achieve per-page layouts pages directory. pattern replaced native support nested layouts app directory. See example export default function DashboardLayout({ children }) { return ( <div> <h2>My Dashboard</h2> {children} </div> ) } import DashboardLayout '../components/DashboardLayout' export default function Page() { return <p>My Page</p> } Page.getLayout = function getLayout(page) { return <DashboardLayout>{page}</DashboardLayout> } - Remove Page.getLayout property frompages/dashboard/index.js follow steps migrating pages theapp directory.app/dashboard/page.jsexport default function Page() { return <p>My Page</p> } - Move contents DashboardLayout new Client Component retainpages directory behavior.app/dashboard/DashboardLayout.js'use client' // directive top file, imports. // Client Component export default function DashboardLayout({ children }) { return ( <div> <h2>My Dashboard</h2> {children} </div> ) } - Import DashboardLayout newlayout.js file inside theapp directory.app/dashboard/layout.jsimport DashboardLayout './DashboardLayout' // Server Component export default function Layout({ children }) { return <DashboardLayout>{children}</DashboardLayout> } - incrementally move non-interactive parts DashboardLayout.js (Client Component) intolayout.js (Server Component) reduce amount component JavaScript send client. Step 3: Migrating next/head pages directory, next/head React component used manage <head> HTML elements title meta . app directory, next/head replaced new built-in SEO support. Before: import Head 'next/head' export default function Page() { return ( <> <Head> <title>My page title</title> </Head> </> ) } After: import type { Metadata } 'next' export const metadata: Metadata = { title: 'My Page Title', } export default function Page() { return '...' } Step 4: Migrating Pages - Pages app directory Server Components default. different thepages directory pages Client Components. - Data fetching changed app .getServerSideProps ,getStaticProps andgetInitialProps replaced simpler API. - app directory uses nested folders define routes specialpage.js file make route segment publicly accessible. - pages Directoryapp DirectoryRoute index.js page.js / about.js about/page.js /about blog/[slug].js blog/[slug]/page.js /blog/post-1 recommend breaking migration page two main steps: - Step 1: Move default exported Page Component new Client Component. - Step 2: Import new Client Component new page.js file inside theapp directory. Good know: easiest migration path comparable behavior pages directory. Step 1: Create new Client Component - Create new separate file inside app directory (i.e.app/home-page.tsx similar) exports Client Component. define Client Components, add the'use client' directive top file (before imports).- Similar Pages Router, optimization step prerender Client Components static HTML initial page load. - Move default exported page component pages/index.js toapp/home-page.tsx . 'use client' // Client Component (same components `pages` directory) // receives data props, access state effects, // prerendered server initial page load. export default function HomePage({ recentPosts }) { return ( <div> {recentPosts.map((post) => ( <div key={post.id}>{post.title}</div> ))} </div> ) } Step 2: Create new page - Create new app/page.tsx file inside theapp directory. Server Component default. - Import home-page.tsx Client Component page. - fetching data pages/index.js , move data fetching logic directly Server Component using new data fetching APIs. See data fetching upgrade guide details.app/page.tsx// Import Client Component import HomePage './home-page' async function getPosts() { const res = await fetch('https://...') const posts = await res.json() return posts } export default async function Page() { // Fetch data directly Server Component const recentPosts = await getPosts() // Forward fetched data Client Component return <HomePage recentPosts={recentPosts} /> } - previous page used useRouter , need update new routing hooks. Learn more. - Start development server visit http://localhost:3000 . see existing index route, served app directory. Step 5: Migrating Routing Hooks new router added support new behavior app directory. app , use three new hooks imported next/navigation : useRouter() , usePathname() , useSearchParams() . - new useRouter hook imported fromnext/navigation different behavior theuseRouter hook inpages imported fromnext/router .- useRouter hook imported fromnext/router supported theapp directory continue used thepages directory. - - new useRouter return thepathname string. Use separateusePathname hook instead. - new useRouter return thequery object. Search parameters dynamic route parameters separate. Use theuseSearchParams anduseParams hooks instead. - use useSearchParams andusePathname together listen page changes. See Router Events section details. - new hooks supported Client Components. cannot used Server Components. 'use client' import { useRouter, usePathname, useSearchParams } 'next/navigation' export default function ExampleClientComponent() { const router = useRouter() const pathname = usePathname() const searchParams = useSearchParams() // ... } addition, new useRouter hook following changes: isFallback removed becausefallback replaced.- locale ,locales ,defaultLocales ,domainLocales values removed built-in i18n Next.js features longer necessary theapp directory. Learn i18n. basePath removed. alternative part ofuseRouter . yet implemented.asPath removed concept ofas removed new router.isReady removed longer necessary. static rendering, component uses theuseSearchParams() hook skip prerendering step instead rendered client runtime.route removed.usePathname oruseSelectedLayoutSegments() provide alternative. View useRouter() API reference. Sharing components pages app keep components compatible pages app routers, refer useRouter hook next/compat/router . useRouter hook pages directory, intended used sharing components routers. ready use app router, update new useRouter next/navigation . Step 6: Migrating Data Fetching Methods pages directory uses getServerSideProps getStaticProps fetch data pages. Inside app directory, previous data fetching functions replaced simpler API built top fetch() async React Server Components. export default async function Page() { // request cached manually invalidated. // Similar `getStaticProps`. // `force-cache` default omitted. const staticData = await fetch(`https://...`, { cache: 'force-cache' }) // request refetched every request. // Similar `getServerSideProps`. const dynamicData = await fetch(`https://...`, { cache: 'no-store' }) // request cached lifetime 10 seconds. // Similar `getStaticProps` `revalidate` option. const revalidatedData = await fetch(`https://...`, { next: { revalidate: 10 }, }) return <div>...</div> } Server-side Rendering (getServerSideProps ) pages directory, getServerSideProps used fetch data server forward props default exported React component file. initial HTML page prerendered server, followed \"hydrating\" page browser (making interactive). // `pages` directory export async function getServerSideProps() { const res = await fetch(`https://...`) const projects = await res.json() return { props: { projects } } } export default function Dashboard({ projects }) { return ( <ul> {projects.map((project) => ( <li key={project.id}>{project.name}</li> ))} </ul> ) } App Router, colocate data fetching inside React components using Server Components. allows us send less JavaScript client, maintaining rendered HTML server. setting cache option no-store , indicate fetched data never cached. similar getServerSideProps pages directory. // `app` directory // function named anything async function getProjects() { const res = await fetch(`https://...`, { cache: 'no-store' }) const projects = await res.json() return projects } export default async function Dashboard() { const projects = await getProjects() return ( <ul> {projects.map((project) => ( <li key={project.id}>{project.name}</li> ))} </ul> ) } Accessing Request Object pages directory, retrieve request-based data based Node.js HTTP API. example, retrieve req object getServerSideProps use retrieve request's cookies headers. // `pages` directory export async function getServerSideProps({ req, query }) { const authHeader = req.getHeaders()['authorization']; const theme = req.cookies['theme']; return { props: { ... }} } export default function Page(props) { return ... } app directory exposes new read-only functions retrieve request data: headers : Based Web Headers API, used inside Server Components retrieve request headers.cookies : Based Web Cookies API, used inside Server Components retrieve cookies. // `app` directory import { cookies, headers } 'next/headers' async function getData() { const authHeader = (await headers()).get('authorization') return '...' } export default async function Page() { // use `cookies` `headers` inside Server Components // directly data fetching function const theme = (await cookies()).get('theme') const data = await getData() return '...' } Static Site Generation (getStaticProps ) pages directory, getStaticProps function used pre-render page build time. function used fetch data external API directly database, pass data entire page generated build. // `pages` directory export async function getStaticProps() { const res = await fetch(`https://...`) const projects = await res.json() return { props: { projects } } } export default function Index({ projects }) { return projects.map((project) => <div>{project.name}</div>) } app directory, data fetching fetch() default cache: 'force-cache' , cache request data manually invalidated. similar getStaticProps pages directory. // `app` directory // function named anything async function getProjects() { const res = await fetch(`https://...`) const projects = await res.json() return projects } export default async function Index() { const projects = await getProjects() return projects.map((project) => <div>{project.name}</div>) } Dynamic paths (getStaticPaths ) pages directory, getStaticPaths function used define dynamic paths pre-rendered build time. // `pages` directory import PostLayout '@/components/post-layout' export async function getStaticPaths() { return { paths: [{ params: { id: '1' } }, { params: { id: '2' } }], } } export async function getStaticProps({ params }) { const res = await fetch(`https://.../posts/${params.id}`) const post = await res.json() return { props: { post } } } export default function Post({ post }) { return <PostLayout post={post} /> } app directory, getStaticPaths replaced generateStaticParams . generateStaticParams behaves similarly getStaticPaths , simplified API returning route parameters used inside layouts. return shape generateStaticParams array segments instead array nested param objects string resolved paths. // `app` directory import PostLayout '@/components/post-layout' export async function generateStaticParams() { return [{ id: '1' }, { id: '2' }] } async function getPost(params) { const res = await fetch(`https://.../posts/${(await params).id}`) const post = await res.json() return post } export default async function Post({ params }) { const post = await getPost(params) return <PostLayout post={post} /> } Using name generateStaticParams appropriate getStaticPaths new model app directory. get prefix replaced descriptive generate , sits better alone getStaticProps getServerSideProps longer necessary. Paths suffix replaced Params , appropriate nested routing multiple dynamic segments. Replacing fallback pages directory, fallback property returned getStaticPaths used define behavior page pre-rendered build time. property set true show fallback page page generated, false show 404 page, blocking generate page request time. // `pages` directory export async function getStaticPaths() { return { paths: [], fallback: 'blocking' }; } export async function getStaticProps({ params }) { ... } export default function Post({ post }) { return ... } app directory config.dynamicParams property controls params outside generateStaticParams handled: true : (default) Dynamic segments included ingenerateStaticParams generated demand.false : Dynamic segments included ingenerateStaticParams return 404. replaces fallback: true | false | 'blocking' option getStaticPaths pages directory. fallback: 'blocking' option included dynamicParams difference 'blocking' true negligible streaming. // `app` directory export const dynamicParams = true; export async function generateStaticParams() { return [...] } async function getPost(params) { ... } export default async function Post({ params }) { const post = await getPost(params); return ... } dynamicParams set true (the default), route segment requested generated, server-rendered cached. Incremental Static Regeneration (getStaticProps revalidate ) pages directory, getStaticProps function allows add revalidate field automatically regenerate page certain amount time. // `pages` directory export async function getStaticProps() { const res = await fetch(`https://.../posts`) const posts = await res.json() return { props: { posts }, revalidate: 60, } } export default function Index({ posts }) { return ( <Layout> <PostList posts={posts} /> </Layout> ) } app directory, data fetching fetch() use revalidate , cache request specified amount seconds. // `app` directory async function getPosts() { const res = await fetch(`https://.../posts`, { next: { revalidate: 60 } }) const data = await res.json() return data.posts } export default async function PostList() { const posts = await getPosts() return posts.map((post) => <div>{post.name}</div>) } API Routes API Routes continue work pages/api directory without changes. However, replaced Route Handlers app directory. Route Handlers allow create custom request handlers given route using Web Request Response APIs. export async function GET(request: Request) {} Good know: previously used API routes call external API client, use Server Components instead securely fetch data. Learn data fetching. Single-Page Applications also migrating Next.js Single-Page Application (SPA) time, see documentation learn more. Step 7: Styling pages directory, global stylesheets restricted pages/_app.js . app directory, restriction lifted. Global styles added layout, page, component. Tailwind CSS using Tailwind CSS, need add app directory tailwind.config.js file: module.exports = { content: [ './app/**/*.{js,ts,jsx,tsx,mdx}', // <-- Add line './pages/**/*.{js,ts,jsx,tsx,mdx}', './components/**/*.{js,ts,jsx,tsx,mdx}', ], } also need import global styles app/layout.js file: import '../styles/globals.css' export default function RootLayout({ children }) { return ( <html lang=\"en\"> <body>{children}</body> </html> ) } Learn styling Tailwind CSS Using App Router together Pages Router navigating routes served different Next.js routers, hard navigation. Automatic link prefetching next/link prefetch across routers. Instead, optimize navigations App Router Pages Router retain prefetched fast page transitions. Learn more. Codemods Next.js provides Codemod transformations help upgrade codebase feature deprecated. See Codemods information. helpful?"},
{"source": "https://nextjs.org/docs/app/guides/migrating/from-create-react-app", "title": "Migrating: Create React App | Next.js", "text": "migrate Create React App Next.js guide help migrate existing Create React App (CRA) site Next.js. Switch? several reasons might want switch Create React App Next.js: Slow initial page loading time Create React App uses purely client-side React. Client-side applications, also known single-page applications (SPAs), often experience slow initial page loading time. happens due couple reasons: - browser needs wait React code entire application bundle download run code able send requests load data. - application code grows every new feature dependency add. automatic code splitting previous issue slow loading times somewhat mitigated code splitting. However, try code splitting manually, inadvertently introduce network waterfalls. Next.js provides automatic code splitting tree-shaking built router build pipeline. Network waterfalls common cause poor performance occurs applications make sequential client-server requests fetch data. One pattern data fetching SPA render placeholder, fetch data component mounted. Unfortunately, child component begin fetching data parent finished loading data, resulting \u201cwaterfall\u201d requests. client-side data fetching supported Next.js, Next.js also lets move data fetching server. often eliminates client-server waterfalls altogether. Fast intentional loading states built-in support streaming React Suspense, define parts UI load first order, without creating network waterfalls. enables build pages faster load eliminate layout shifts. Choose data fetching strategy Depending needs, Next.js allows choose data fetching strategy page component-level basis. example, could fetch data CMS render blog posts build time (SSG) quick load speeds, fetch data request time (SSR) necessary. Middleware Next.js Middleware allows run code server request completed. instance, avoid flash unauthenticated content redirecting user login page middleware authenticated-only pages. also use features like A/B testing, experimentation, internationalization. Built-in Optimizations Images, fonts, third-party scripts often large impact application\u2019s performance. Next.js includes specialized components APIs automatically optimize you. Migration Steps goal get working Next.js application quickly possible adopt Next.js features incrementally. begin with, we\u2019ll treat application purely client-side application (SPA) without immediately replacing existing router. reduces complexity merge conflicts. Note: using advanced CRA configurations custom homepage field yourpackage.json , custom service worker, specific Babel/webpack tweaks, please see Additional Considerations section end guide tips replicating adapting features Next.js. Step 1: Install Next.js Dependency Install Next.js existing project: npm install next@latest Step 2: Create Next.js Configuration File Create next.config.ts root project (same level package.json ). file holds Next.js configuration options. import type { NextConfig } 'next' const nextConfig: NextConfig = { output: 'export', // Outputs Single-Page Application (SPA) distDir: 'build', // Changes build output directory `build` } export default nextConfig Note: Using output: 'export' means you\u2019re static export. access server-side features like SSR APIs. remove line leverage Next.js server features. Step 3: Create Root Layout Next.js App Router application must include root layout file, React Server Component wrap pages. closest equivalent root layout file CRA application public/index.html , includes <html> , <head> , <body> tags. - Create new app directory inside yoursrc folder (or project root preferapp root). - Inside app directory, create alayout.tsx (orlayout.js ) file: export default function RootLayout({ children, }: { children: React.ReactNode }) { return '...' } copy content old index.html <RootLayout> component. Replace body div#root (and body noscript ) <div id=\"root\">{children}</div> . export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <head> <meta charSet=\"UTF-8\" /> <link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> <title>React App</title> <meta name=\"description\" content=\"Web site created...\" /> </head> <body> <div id=\"root\">{children}</div> </body> </html> ) } Good know: Next.js ignores CRA\u2019s public/manifest.json , additional iconography, testing configuration default. need these, Next.js support Metadata API Testing setup. Step 4: Metadata Next.js automatically includes <meta charset=\"UTF-8\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> tags, remove <head> : export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <head> <link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" /> <title>React App</title> <meta name=\"description\" content=\"Web site created...\" /> </head> <body> <div id=\"root\">{children}</div> </body> </html> ) } metadata files favicon.ico , icon.png , robots.txt automatically added application <head> tag long placed top level app directory. moving supported files app directory safely delete <link> tags: export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <head> <title>React App</title> <meta name=\"description\" content=\"Web site created...\" /> </head> <body> <div id=\"root\">{children}</div> </body> </html> ) } Finally, Next.js manage last <head> tags Metadata API. Move final metadata info exported metadata object: import type { Metadata } 'next' export const metadata: Metadata = { title: 'React App', description: 'Web site created Next.js.', } export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body> <div id=\"root\">{children}</div> </body> </html> ) } changes, shifted declaring everything index.html using Next.js' convention-based approach built framework (Metadata API). approach enables easily improve SEO web shareability pages. Step 5: Styles Like CRA, Next.js supports CSS Modules box. also supports global CSS imports. global CSS file, import app/layout.tsx : import '../index.css' export const metadata = { title: 'React App', description: 'Web site created Next.js.', } export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body> <div id=\"root\">{children}</div> </body> </html> ) } you\u2019re using Tailwind CSS, see installation docs. Step 6: Create Entrypoint Page Create React App uses src/index.tsx (or index.js ) entry point. Next.js (App Router), folder inside app directory corresponds route, folder page.tsx . Since want keep app SPA intercept routes, we\u2019ll use optional catch-all route. - Create [[...slug]] directory insideapp . app \u2523 [[...slug]] \u2503 \u2517 page.tsx \u2523 layout.tsx - Add following page.tsx : export function generateStaticParams() { return [{ slug: [''] }] } export default function Page() { return '...' // update } tells Next.js generate single route empty slug (/ ), effectively mapping routes page. page Server Component, prerendered static HTML. Step 7: Add Client-Only Entrypoint Next, we\u2019ll embed CRA\u2019s root App component inside Client Component logic remains client-side. first time using Next.js, worth knowing clients components (by default) still prerendered server. think additional capability running client-side JavaScript. Create client.tsx (or client.js ) app/[[...slug]]/ : 'use client' import dynamic 'next/dynamic' const App = dynamic(() => import('../../App'), { ssr: false }) export function ClientOnly() { return <App /> } - 'use client' directive makes file Client Component. - dynamic import withssr: false disables server-side rendering the<App /> component, making truly client-only (SPA). update page.tsx (or page.js ) use new component: import { ClientOnly } './client' export function generateStaticParams() { return [{ slug: [''] }] } export default function Page() { return <ClientOnly /> } Step 8: Update Static Image Imports CRA, importing image file returns public URL string: import image './img.png' export default function App() { return <img src={image} /> } Next.js, static image imports return object. object used directly Next.js <Image> component, use object's src property existing <img> tag. <Image> component added benefits automatic image optimization. <Image> component automatically sets width height attributes resulting <img> based image's dimensions. prevents layout shifts image loads. However, cause issues app contains images one dimensions styled without styled auto . styled auto , dimension default <img> dimension attribute's value, cause image appear distorted. Keeping <img> tag reduce amount changes application prevent issues. optionally later migrate <Image> component take advantage optimizing images configuring loader, moving default Next.js server automatic image optimization. Convert absolute import paths images imported /public relative imports: // import logo '/logo.png' // import logo '../public/logo.png' Pass image src property instead whole image object <img> tag: // <img src={logo} /> // <img src={logo.src} /> Alternatively, reference public URL image asset based filename. example, public/logo.png serve image /logo.png application, would src value. Warning: using TypeScript, might encounter type errors accessing src property. fix them, need addnext-env.d.ts theinclude array yourtsconfig.json file. Next.js automatically generate file run application step 9. Step 9: Migrate Environment Variables Next.js supports environment variables similarly CRA requires NEXT_PUBLIC_ prefix variable want expose browser. main difference prefix used expose environment variables client-side. Change environment variables REACT_APP_ prefix NEXT_PUBLIC_ . Step 10: Update Scripts package.json Update package.json scripts use Next.js commands. Also, add .next next-env.d.ts .gitignore : { \"scripts\": { \"dev\": \"next dev --turbopack\", \"build\": \"next build\", \"start\": \"npx serve@latest ./build\" } } # ... .next next-env.d.ts run: npm run dev Open http://localhost:3000. see application running Next.js (in SPA mode). Step 11: Clean remove artifacts specific Create React App: public/index.html src/index.tsx src/react-app-env.d.ts - reportWebVitals setup - react-scripts dependency (uninstall frompackage.json ) Additional Considerations Using Custom homepage CRA used homepage field CRA package.json serve app specific subpath, replicate Next.js using basePath configuration next.config.ts : import { NextConfig } 'next' const nextConfig: NextConfig = { basePath: '/my-subpath', // ... } export default nextConfig Handling Custom Service Worker used CRA\u2019s service worker (e.g., serviceWorker.js create-react-app ), learn create Progressive Web Applications (PWAs) Next.js. Proxying API Requests CRA app used proxy field package.json forward requests backend server, replicate Next.js rewrites next.config.ts : import { NextConfig } 'next' const nextConfig: NextConfig = { async rewrites() { return [ { source: '/api/:path*', destination: 'https://your-backend.com/:path*', }, ] }, } Custom Webpack / Babel Config custom webpack Babel configuration CRA, extend Next.js\u2019s config next.config.ts : import { NextConfig } 'next' const nextConfig: NextConfig = { webpack: (config, { isServer }) => { // Modify webpack config return config }, } export default nextConfig Note: require disabling Turbopack removing --turbopack yourdev script. TypeScript Setup Next.js automatically sets TypeScript tsconfig.json . Make sure next-env.d.ts listed tsconfig.json include array: { \"include\": [\"next-env.d.ts\", \"app/**/*\", \"src/**/*\"] } Bundler Compatibility Create React App Next.js default webpack bundling. Next.js also offers Turbopack faster local development with: next dev --turbopack still provide custom webpack configuration need migrate advanced webpack settings CRA. Next Steps everything worked, functioning Next.js application running single-page application. aren\u2019t yet leveraging Next.js features like server-side rendering file-based routing, incrementally: - Migrate React Router Next.js App Router for: - Automatic code splitting - Streaming server rendering - React Server Components - Optimize images <Image> component - Optimize fonts next/font - Optimize third-party scripts <Script> component - Enable ESLint Next.js recommended rules running npx next lint configuring match project\u2019s needs Note: Using static export ( output: 'export' ) currently support theuseParams hook server features. use Next.js features, removeoutput: 'export' yournext.config.ts . helpful?"},
{"source": "https://nextjs.org/docs/app/guides/migrating/from-vite", "title": "Migrating: Vite | Next.js", "text": "migrate Vite Next.js guide help migrate existing Vite application Next.js. Switch? several reasons might want switch Vite Next.js: Slow initial page loading time built application default Vite plugin React, application purely client-side application. Client-side applications, also known single-page applications (SPAs), often experience slow initial page loading time. happens due couple reasons: - browser needs wait React code entire application bundle download run code able send requests load data. - application code grows every new feature extra dependency add. automatic code splitting previous issue slow loading times somewhat managed code splitting. However, try code splitting manually, often make performance worse. easy inadvertently introduce network waterfalls code-splitting manually. Next.js provides automatic code splitting built router. Network waterfalls common cause poor performance occurs applications make sequential client-server requests fetch data. One common pattern data fetching SPA initially render placeholder, fetch data component mounted. Unfortunately, means child component fetches data can't start fetching parent component finished loading data. fetching data client supported Next.js, also gives option shift data fetching server, eliminate client-server waterfalls. Fast intentional loading states built-in support streaming React Suspense, intentional parts UI want load first order without introducing network waterfalls. enables build pages faster load eliminate layout shifts. Choose data fetching strategy Depending needs, Next.js allows choose data fetching strategy page component basis. decide fetch build time, request time server, client. example, fetch data CMS render blog posts build time, efficiently cached CDN. Middleware Next.js Middleware allows run code server request completed. especially useful avoid flash unauthenticated content user visits authenticated-only page redirecting user login page. middleware also useful experimentation internationalization. Built-in Optimizations Images, fonts, third-party scripts often significant impact application's performance. Next.js comes built-in components automatically optimize you. Migration Steps goal migration get working Next.js application quickly possible, adopt Next.js features incrementally. begin with, keep purely client-side application (SPA) without migrating existing router. helps minimize chances encountering issues migration process reduces merge conflicts. Step 1: Install Next.js Dependency first thing need install next dependency: npm install next@latest Step 2: Create Next.js Configuration File Create next.config.mjs root project. file hold Next.js configuration options. /** @type {import('next').NextConfig} */ const nextConfig = { output: 'export', // Outputs Single-Page Application (SPA). distDir: './dist', // Changes build output directory `./dist/`. } export default nextConfig Good know: use either .js or.mjs Next.js configuration file. Step 3: Update TypeScript Configuration using TypeScript, need update tsconfig.json file following changes make compatible Next.js. using TypeScript, skip step. - Remove project reference tsconfig.node.json - Add ./dist/types/**/*.ts and./next-env.d.ts theinclude array - Add ./node_modules theexclude array - Add { \"name\": \"next\" } theplugins array incompilerOptions :\"plugins\": [{ \"name\": \"next\" }] - Set esModuleInterop totrue :\"esModuleInterop\": true - Set jsx topreserve :\"jsx\": \"preserve\" - Set allowJs totrue :\"allowJs\": true - Set forceConsistentCasingInFileNames totrue :\"forceConsistentCasingInFileNames\": true - Set incremental totrue :\"incremental\": true Here's example working tsconfig.json changes: { \"compilerOptions\": { \"target\": \"ES2020\", \"useDefineForClassFields\": true, \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"], \"module\": \"ESNext\", \"esModuleInterop\": true, \"skipLibCheck\": true, \"moduleResolution\": \"bundler\", \"allowImportingTsExtensions\": true, \"resolveJsonModule\": true, \"isolatedModules\": true, \"noEmit\": true, \"jsx\": \"preserve\", \"strict\": true, \"noUnusedLocals\": true, \"noUnusedParameters\": true, \"noFallthroughCasesInSwitch\": true, \"allowJs\": true, \"forceConsistentCasingInFileNames\": true, \"incremental\": true, \"plugins\": [{ \"name\": \"next\" }] }, \"include\": [\"./src\", \"./dist/types/**/*.ts\", \"./next-env.d.ts\"], \"exclude\": [\"./node_modules\"] } find information configuring TypeScript Next.js docs. Step 4: Create Root Layout Next.js App Router application must include root layout file, React Server Component wrap pages application. file defined top level app directory. closest equivalent root layout file Vite application index.html file, contains <html> , <head> , <body> tags. step, convert index.html file root layout file: - Create new app directory yoursrc folder. - Create new layout.tsx file inside thatapp directory: export default function RootLayout({ children, }: { children: React.ReactNode }) { return '...' } Good know: .js ,.jsx , or.tsx extensions used Layout files. - Copy content index.html file previously created<RootLayout> component replacing thebody.div#root andbody.script tags with<div id=\"root\">{children}</div> : export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <head> <meta charset=\"UTF-8\" /> <link rel=\"icon\" type=\"image/svg+xml\" href=\"/icon.svg\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /> <title>My App</title> <meta name=\"description\" content=\"My App a...\" /> </head> <body> <div id=\"root\">{children}</div> </body> </html> ) } - Next.js already includes default meta charset meta viewport tags, safely remove <head> : export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <head> <link rel=\"icon\" type=\"image/svg+xml\" href=\"/icon.svg\" /> <title>My App</title> <meta name=\"description\" content=\"My App a...\" /> </head> <body> <div id=\"root\">{children}</div> </body> </html> ) } - metadata files favicon.ico ,icon.png ,robots.txt automatically added application<head> tag long placed top level theapp directory. moving supported files theapp directory safely delete their<link> tags: export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <head> <title>My App</title> <meta name=\"description\" content=\"My App a...\" /> </head> <body> <div id=\"root\">{children}</div> </body> </html> ) } - Finally, Next.js manage last <head> tags Metadata API. Move final metadata info exportedmetadata object: import type { Metadata } 'next' export const metadata: Metadata = { title: 'My App', description: 'My App a...', } export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body> <div id=\"root\">{children}</div> </body> </html> ) } changes, shifted declaring everything index.html using Next.js' convention-based approach built framework (Metadata API). approach enables easily improve SEO web shareability pages. Step 5: Create Entrypoint Page Next.js declare entrypoint application creating page.tsx file. closest equivalent file Vite main.tsx file. step, you\u2019ll set entrypoint application. - Create [[...slug]] directory yourapp directory. Since guide aiming first set Next.js SPA (Single Page Application), need page entrypoint catch possible routes application. that, create new [[...slug]] directory app directory. directory called optional catch-all route segment. Next.js uses file-system based router folders used define routes. special directory make sure routes application directed containing page.tsx file. - Create new page.tsx file inside theapp/[[...slug]] directory following content: import '../../index.css' export function generateStaticParams() { return [{ slug: [''] }] } export default function Page() { return '...' // update } Good know: .js ,.jsx , or.tsx extensions used Page files. file Server Component. run next build , file prerendered static asset. require dynamic code. file imports global CSS tells generateStaticParams going generate one route, index route / . Now, let's move rest Vite application run client-only. 'use client' import React 'react' import dynamic 'next/dynamic' const App = dynamic(() => import('../../App'), { ssr: false }) export function ClientOnly() { return <App /> } file Client Component, defined 'use client' directive. Client Components still prerendered HTML server sent client. Since want client-only application start, configure Next.js disable prerendering App component down. const App = dynamic(() => import('../../App'), { ssr: false }) Now, update entrypoint page use new component: import '../../index.css' import { ClientOnly } './client' export function generateStaticParams() { return [{ slug: [''] }] } export default function Page() { return <ClientOnly /> } Step 6: Update Static Image Imports Next.js handles static image imports slightly different Vite. Vite, importing image file return public URL string: import image './img.png' // `image` '/assets/img.2d8efhg.png' production export default function App() { return <img src={image} /> } Next.js, static image imports return object. object used directly Next.js <Image> component, use object's src property existing <img> tag. <Image> component added benefits automatic image optimization. <Image> component automatically sets width height attributes resulting <img> based image's dimensions. prevents layout shifts image loads. However, cause issues app contains images one dimensions styled without styled auto . styled auto , dimension default <img> dimension attribute's value, cause image appear distorted. Keeping <img> tag reduce amount changes application prevent issues. optionally later migrate <Image> component take advantage optimizing images configuring loader, moving default Next.js server automatic image optimization. - Convert absolute import paths images imported /public relative imports: // import logo '/logo.png' // import logo '../public/logo.png' - Pass image src property instead whole image object your<img> tag: // <img src={logo} /> // <img src={logo.src} /> Alternatively, reference public URL image asset based filename. example, public/logo.png serve image /logo.png application, would src value. Warning: using TypeScript, might encounter type errors accessing src property. safely ignore now. fixed end guide. Step 7: Migrate Environment Variables Next.js support .env environment variables similar Vite. main difference prefix used expose environment variables client-side. - Change environment variables VITE_ prefix toNEXT_PUBLIC_ . Vite exposes built-in environment variables special import.meta.env object aren\u2019t supported Next.js. need update usage follows: import.meta.env.MODE \u21d2process.env.NODE_ENV import.meta.env.PROD \u21d2process.env.NODE_ENV === 'production' import.meta.env.DEV \u21d2process.env.NODE_ENV !== 'production' import.meta.env.SSR \u21d2typeof window !== 'undefined' Next.js also provide built-in BASE_URL environment variable. However, still configure one, need it: - Add following .env file: # ... NEXT_PUBLIC_BASE_PATH=\"/some-base-path\" - Set basePath toprocess.env.NEXT_PUBLIC_BASE_PATH yournext.config.mjs file: /** @type {import('next').NextConfig} */ const nextConfig = { output: 'export', // Outputs Single-Page Application (SPA). distDir: './dist', // Changes build output directory `./dist/`. basePath: process.env.NEXT_PUBLIC_BASE_PATH, // Sets base path `/some-base-path`. } export default nextConfig - Update import.meta.env.BASE_URL usages toprocess.env.NEXT_PUBLIC_BASE_PATH Step 8: Update Scripts package.json able run application test successfully migrated Next.js. that, need update scripts package.json Next.js related commands, add .next next-env.d.ts .gitignore : { \"scripts\": { \"dev\": \"next dev\", \"build\": \"next build\", \"start\": \"next start\" } } # ... .next next-env.d.ts dist run npm run dev , open http://localhost:3000 . see application running Next.js. Example: Check pull request working example Vite application migrated Next.js. Step 9: Clean clean codebase Vite related artifacts: - Delete main.tsx - Delete index.html - Delete vite-env.d.ts - Delete tsconfig.node.json - Delete vite.config.ts - Uninstall Vite dependencies Next Steps everything went according plan, functioning Next.js application running single-page application. However, yet taking advantage Next.js' benefits, start making incremental changes reap benefits. Here's might want next: - Migrate React Router Next.js App Router get: - Automatic code splitting - Streaming Server-Rendering - React Server Components - Optimize images <Image> component - Optimize fonts next/font - Optimize third-party scripts <Script> component - Update ESLint configuration support Next.js rules helpful?"},
{"source": "https://nextjs.org/docs/app/guides/multi-tenant", "title": "Guides: Multi-tenant | Next.js", "text": "build multi-tenant apps Next.js looking build single Next.js application serves multiple tenants, built example showing recommended architecture. helpful? looking build single Next.js application serves multiple tenants, built example showing recommended architecture. helpful?"},
{"source": "https://nextjs.org/docs/app/guides/multi-zones", "title": "Guides: Multi-zones | Next.js", "text": "build micro-frontends using multi-zones Next.js Examples Multi-Zones approach micro-frontends separate large application domain smaller Next.js applications serve set paths. useful collections pages unrelated pages application. moving pages separate zone (i.e., separate application), reduce size application improves build times removes code necessary one zones. Since applications decoupled, Multi-Zones also allows applications domain use choice framework. example, let's say following set pages would like split up: /blog/* blog posts/dashboard/* pages user logged-in dashboard/* rest website covered zones Multi-Zones support, create three applications served domain look user, develop deploy applications independently. Navigating pages zone perform soft navigations, navigation require reloading page. example, diagram, navigating / /products soft navigation. Navigating page one zone page another zone, / /dashboard , perform hard navigation, unloading resources current page loading resources new page. Pages frequently visited together live zone avoid hard navigations. define zone zone normal Next.js application also configure assetPrefix avoid conflicts pages static files zones. /** @type {import('next').NextConfig} */ const nextConfig = { assetPrefix: '/blog-static', } Next.js assets, JavaScript CSS, prefixed assetPrefix make sure conflict assets zones. assets served /assetPrefix/_next/... zones. default application handling paths routed another specific zone need assetPrefix . versions older Next.js 15, may also need additional rewrite handle static assets. longer necessary Next.js 15. /** @type {import('next').NextConfig} */ const nextConfig = { assetPrefix: '/blog-static', async rewrites() { return { beforeFiles: [ { source: '/blog-static/_next/:path+', destination: '/_next/:path+', }, ], } }, } route requests right zone Multi Zones set-up, need route paths correct zone since served different applications. use HTTP proxy this, one Next.js applications also used route requests entire domain. route correct zone using Next.js application, use rewrites . path served different zone, would add rewrite rule send path domain zone, also need rewrite requests static assets. example: async rewrites() { return [ { source: '/blog', destination: `${process.env.BLOG_DOMAIN}/blog`, }, { source: '/blog/:path+', destination: `${process.env.BLOG_DOMAIN}/blog/:path+`, }, { source: '/blog-static/:path+', destination: `${process.env.BLOG_DOMAIN}/blog-static/:path+`, } ]; } destination URL served zone, including scheme domain. point zone's production domain, also used route requests localhost local development. Good know: URL paths unique zone. example, two zones trying serve /blog would create routing conflict. Routing requests using middleware Routing requests rewrites recommended minimize latency overhead requests, middleware also used need dynamic decision routing. example, using feature flag decide path routed migration, use middleware. export async function middleware(request) { const { pathname, search } = req.nextUrl; (pathname === '/your-path' && myFeatureFlag.isEnabled()) { return NextResponse.rewrite(`${rewriteDomain}${pathname}${search}); } } Linking zones Links paths different zone use tag instead Next.js <Link> component. Next.js try prefetch soft navigate relative path <Link> component, work across zones. Sharing code Next.js applications make different zones live repository. However, often convenient put zones monorepo easily share code. zones live different repositories, code also shared using public private NPM packages. Since pages different zones may released different times, feature flags useful enabling disabling features unison across different zones. Server Actions using Server Actions Multi-Zones, must explicitly allow user-facing origin since user facing domain may serve multiple applications. next.config.js file, add following lines: const nextConfig = { experimental: { serverActions: { allowedOrigins: ['your-production-domain.com'], }, }, } See serverActions.allowedOrigins information. helpful?"},
{"source": "https://nextjs.org/docs/app/guides/open-telemetry", "title": "Guides: OpenTelemetry | Next.js", "text": "set instrumentation OpenTelemetry Observability crucial understanding optimizing behavior performance Next.js app. applications become complex, becomes increasingly difficult identify diagnose issues may arise. leveraging observability tools, logging metrics, developers gain insights application's behavior identify areas optimization. observability, developers proactively address issues become major problems provide better user experience. Therefore, highly recommended use observability Next.js applications improve performance, optimize resources, enhance user experience. recommend using OpenTelemetry instrumenting apps. platform-agnostic way instrument apps allows change observability provider without changing code. Read Official OpenTelemetry docs information OpenTelemetry works. documentation uses terms like Span, Trace Exporter throughout doc, found OpenTelemetry Observability Primer. Next.js supports OpenTelemetry instrumentation box, means already instrumented Next.js itself. Getting Started OpenTelemetry extensible setting properly quite verbose. That's prepared package @vercel/otel helps get started quickly. Using @vercel/otel get started, install following packages: npm install @vercel/otel @opentelemetry/sdk-logs @opentelemetry/api-logs @opentelemetry/instrumentation Next, create custom instrumentation.ts (or .js ) file root directory project (or inside src folder using one): import { registerOTel } '@vercel/otel' export function register() { registerOTel({ serviceName: 'next-app' }) } See @vercel/otel documentation additional configuration options. Good know: - instrumentation file root project inside theapp orpages directory. using thesrc folder, place file insidesrc alongsidepages andapp .- use pageExtensions config option add suffix, also need update theinstrumentation filename match.- created basic with-opentelemetry example use. Manual OpenTelemetry configuration @vercel/otel package provides many configuration options serve common use cases. suit needs, configure OpenTelemetry manually. Firstly need install OpenTelemetry packages: npm install @opentelemetry/sdk-node @opentelemetry/resources @opentelemetry/semantic-conventions @opentelemetry/sdk-trace-node @opentelemetry/exporter-trace-otlp-http initialize NodeSDK instrumentation.ts . Unlike @vercel/otel , NodeSDK compatible edge runtime, need make sure importing process.env.NEXT_RUNTIME === 'nodejs' . recommend creating new file instrumentation.node.ts conditionally import using node: export async function register() { (process.env.NEXT_RUNTIME === 'nodejs') { await import('./instrumentation.node.ts') } } import { OTLPTraceExporter } '@opentelemetry/exporter-trace-otlp-http' import { Resource } '@opentelemetry/resources' import { NodeSDK } '@opentelemetry/sdk-node' import { SimpleSpanProcessor } '@opentelemetry/sdk-trace-node' import { ATTR_SERVICE_NAME } '@opentelemetry/semantic-conventions' const sdk = new NodeSDK({ resource: new Resource({ [ATTR_SERVICE_NAME]: 'next-app', }), spanProcessor: new SimpleSpanProcessor(new OTLPTraceExporter()), }) sdk.start() equivalent using @vercel/otel , possible modify extend features exposed @vercel/otel . edge runtime support necessary, use @vercel/otel . Testing instrumentation need OpenTelemetry collector compatible backend test OpenTelemetry traces locally. recommend using OpenTelemetry dev environment. everything works well able see root server span labeled GET /requested/pathname . spans particular trace nested it. Next.js traces spans emitted default. see spans, must set NEXT_OTEL_VERBOSE=1 . Deployment Using OpenTelemetry Collector deploying OpenTelemetry Collector, use @vercel/otel . work Vercel self-hosted. Deploying Vercel made sure OpenTelemetry works box Vercel. Follow Vercel documentation connect project observability provider. Self-hosting Deploying platforms also straightforward. need spin OpenTelemetry Collector receive process telemetry data Next.js app. this, follow OpenTelemetry Collector Getting Started guide, walk setting collector configuring receive data Next.js app. collector running, deploy Next.js app chosen platform following respective deployment guides. Custom Exporters OpenTelemetry Collector necessary. use custom OpenTelemetry exporter @vercel/otel manual OpenTelemetry configuration. Custom Spans add custom span OpenTelemetry APIs. npm install @opentelemetry/api following example demonstrates function fetches GitHub stars adds custom fetchGithubStars span track fetch request's result: import { trace } '@opentelemetry/api' export async function fetchGithubStars() { return await trace .getTracer('nextjs-example') .startActiveSpan('fetchGithubStars', async (span) => { try { return await getValue() } finally { span.end() } }) } register function execute code runs new environment. start creating new spans, correctly added exported trace. Default Spans Next.js Next.js automatically instruments several spans provide useful insights application's performance. Attributes spans follow OpenTelemetry semantic conventions. also add custom attributes next namespace: next.span_name - duplicates span namenext.span_type - span type unique identifiernext.route - route pattern request (e.g.,/[param]/user ).next.rsc (true/false) - Whether request RSC request, prefetch.next.page - internal value used app router. - think route special file (like page.ts ,layout.ts ,loading.ts others) - used unique identifier paired next.route because/layout used identify both/(groupA)/layout.ts and/(groupB)/layout.ts [http.method] [next.route] next.span_type :BaseServer.handleRequest span represents root span incoming request Next.js application. tracks HTTP method, route, target, status code request. Attributes: - Common HTTP attributes http.method http.status_code - Server HTTP attributes http.route http.target next.span_name next.span_type next.route render route (app) [next.route] next.span_type :AppRender.getBodyResult . span represents process rendering route app router. Attributes: next.span_name next.span_type next.route fetch [http.method] [http.url] next.span_type :AppRender.fetch span represents fetch request executed code. Attributes: - Common HTTP attributes http.method - Client HTTP attributes http.url net.peer.name net.peer.port (only specified) next.span_name next.span_type span turned setting NEXT_OTEL_FETCH_DISABLED=1 environment. useful want use custom fetch instrumentation library. executing api route (app) [next.route] next.span_type :AppRouteRouteHandlers.runHandler . span represents execution API Route Handler app router. Attributes: next.span_name next.span_type next.route getServerSideProps [next.route] next.span_type :Render.getServerSideProps . span represents execution getServerSideProps specific route. Attributes: next.span_name next.span_type next.route getStaticProps [next.route] next.span_type :Render.getStaticProps . span represents execution getStaticProps specific route. Attributes: next.span_name next.span_type next.route render route (pages) [next.route] next.span_type :Render.renderDocument . span represents process rendering document specific route. Attributes: next.span_name next.span_type next.route generateMetadata [next.page] next.span_type :ResolveMetadata.generateMetadata . span represents process generating metadata specific page (a single route multiple spans). Attributes: next.span_name next.span_type next.page resolve page components next.span_type :NextNodeServer.findPageComponents . span represents process resolving page components specific page. Attributes: next.span_name next.span_type next.route resolve segment modules next.span_type :NextNodeServer.getLayoutOrPageModule . span represents loading code modules layout page. Attributes: next.span_name next.span_type next.segment start response next.span_type :NextNodeServer.startResponse . zero-length span represents time first byte sent response. helpful?"},
{"source": "https://nextjs.org/docs/app/guides/package-bundling", "title": "Guides: Package Bundling | Next.js", "text": "optimize package bundling Bundling external packages significantly improve performance application. default, packages imported inside Server Components Route Handlers automatically bundled Next.js. page guide analyze optimize package bundling. Analyzing JavaScript bundles @next/bundle-analyzer plugin Next.js helps manage size application bundles. generates visual report size package dependencies. use information remove large dependencies, split, lazy-load code. Installation Install plugin running following command: npm @next/bundle-analyzer # yarn add @next/bundle-analyzer # pnpm add @next/bundle-analyzer Then, add bundle analyzer's settings next.config.js . /** @type {import('next').NextConfig} */ const nextConfig = {} const withBundleAnalyzer = require('@next/bundle-analyzer')({ enabled: process.env.ANALYZE === 'true', }) module.exports = withBundleAnalyzer(nextConfig) Generating report Run following command analyze bundles: ANALYZE=true npm run build # ANALYZE=true yarn build # ANALYZE=true pnpm build report open three new tabs browser, inspect. Periodically evaluating application's bundles help maintain application performance time. Optimizing package imports packages, icon libraries, export hundreds modules, cause performance issues development production. optimize packages imported adding optimizePackageImports option next.config.js . option load modules actually use, still giving convenience writing import statements many named exports. /** @type {import('next').NextConfig} */ const nextConfig = { experimental: { optimizePackageImports: ['icon-library'], }, } module.exports = nextConfig Next.js also optimizes libraries automatically, thus need included optimizePackageImports list. See full list. Opting specific packages bundling Since packages imported inside Server Components Route Handlers automatically bundled Next.js, opt specific packages bundling using serverExternalPackages option next.config.js . /** @type {import('next').NextConfig} */ const nextConfig = { serverExternalPackages: ['package-name'], } module.exports = nextConfig Next.js includes list popular packages currently working compatibility automatically opt-ed out. See full list. Next Steps helpful?"},
{"source": "https://nextjs.org/docs/app/guides/production-checklist", "title": "Guides: Production | Next.js", "text": "optimize Next.js application production taking Next.js application production, optimizations patterns consider implementing best user experience, performance, security. page provides best practices use reference building application going production, well automatic Next.js optimizations aware of. Automatic optimizations Next.js optimizations enabled default require configuration: - Server Components: Next.js uses Server Components default. Server Components run server, require JavaScript render client. such, impact size client-side JavaScript bundles. use Client Components needed interactivity. - Code-splitting: Server Components enable automatic code-splitting route segments. may also consider lazy loading Client Components third-party libraries, appropriate. - Prefetching: link new route enters user's viewport, Next.js prefetches route background. makes navigation new routes almost instant. opt prefetching, appropriate. - Static Rendering: Next.js statically renders Server Client Components server build time caches rendered result improve application's performance. opt Dynamic Rendering specific routes, appropriate. - Caching: Next.js caches data requests, rendered result Server Client Components, static assets, more, reduce number network requests server, database, backend services. may opt caching, appropriate. defaults aim improve application's performance, reduce cost amount data transferred network request. development building application, recommend using following features ensure best performance user experience: Routing rendering - Layouts: Use layouts share UI across pages enable partial rendering navigation. <Link> component: Use the<Link> component client-side navigation prefetching.- Error Handling: Gracefully handle catch-all errors 404 errors production creating custom error pages. - Client Server Components: Follow recommended composition patterns Server Client Components, check placement \"use client\" boundaries avoid unnecessarily increasing client-side JavaScript bundle. - Dynamic APIs: aware Dynamic APIs like cookies thesearchParams prop opt entire route Dynamic Rendering (or whole application used Root Layout). Ensure Dynamic API usage intentional wrap in<Suspense> boundaries appropriate. Good know: Partial Prerendering (experimental) allow parts route dynamic without opting whole route dynamic rendering. Data fetching caching - Server Components: Leverage benefits fetching data server using Server Components. - Route Handlers: Use Route Handlers access backend resources Client Components. call Route Handlers Server Components avoid additional server request. - Streaming: Use Loading UI React Suspense progressively send UI server client, prevent whole route blocking data fetched. - Parallel Data Fetching: Reduce network waterfalls fetching data parallel, appropriate. Also, consider preloading data appropriate. - Data Caching: Verify whether data requests cached not, opt caching, appropriate. Ensure requests use fetch cached. - Static Images: Use public directory automatically cache application's static assets, e.g. images. UI accessibility - Forms Validation: Use Server Actions handle form submissions, server-side validation, handle errors. - Font Module: Optimize fonts using Font Module, automatically hosts font files static assets, removes external network requests, reduces layout shift. <Image> Component: Optimize images using Image Component, automatically optimizes images, prevents layout shift, serves modern formats like WebP.<Script> Component: Optimize third-party scripts using Script Component, automatically defers scripts prevents blocking main thread.- ESLint: Use built-in eslint-plugin-jsx-a11y plugin catch accessibility issues early. Security - Tainting: Prevent sensitive data exposed client tainting data objects and/or specific values. - Server Actions: Ensure users authorized call Server Actions. Review recommended security practices. - Environment Variables: Ensure .env.* files added to.gitignore public variables prefixed withNEXT_PUBLIC_ . - Content Security Policy: Consider adding Content Security Policy protect application various security threats cross-site scripting, clickjacking, code injection attacks. Metadata SEO - Metadata API: Use Metadata API improve application's Search Engine Optimization (SEO) adding page titles, descriptions, more. - Open Graph (OG) images: Create OG images prepare application social sharing. - Sitemaps Robots: Help Search Engines crawl index pages generating sitemaps robots files. Type safety - TypeScript TS Plugin: Use TypeScript TypeScript plugin better type-safety, help catch errors early. going production going production, run next build build application locally catch build errors, run next start measure performance application production-like environment. Core Web Vitals - Lighthouse: Run lighthouse incognito gain better understanding users experience site, identify areas improvement. simulated test paired looking field data (such Core Web Vitals). useReportWebVitals hook: Use hook send Core Web Vitals data analytics tools. Analyzing bundles Use @next/bundle-analyzer plugin analyze size JavaScript bundles identify large modules dependencies might impacting application's performance. Additionally, following tools help understand impact adding new dependencies application: helpful?"},
{"source": "https://nextjs.org/docs/app/guides/progressive-web-apps", "title": "Guides: PWAs | Next.js", "text": "build Progressive Web Application (PWA) Next.js Progressive Web Applications (PWAs) offer reach accessibility web applications combined features user experience native mobile apps. Next.js, create PWAs provide seamless, app-like experience across platforms without need multiple codebases app store approvals. PWAs allow to: - Deploy updates instantly without waiting app store approval - Create cross-platform applications single codebase - Provide native-like features home screen installation push notifications Creating PWA Next.js 1. Creating Web App Manifest Next.js provides built-in support creating web app manifest using App Router. create either static dynamic manifest file: example, create app/manifest.ts app/manifest.json file: import type { MetadataRoute } 'next' export default function manifest(): MetadataRoute.Manifest { return { name: 'Next.js PWA', short_name: 'NextPWA', description: 'A Progressive Web App built Next.js', start_url: '/', display: 'standalone', background_color: '#ffffff', theme_color: '#000000', icons: [ { src: '/icon-192x192.png', sizes: '192x192', type: 'image/png', }, { src: '/icon-512x512.png', sizes: '512x512', type: 'image/png', }, ], } } file contain information name, icons, displayed icon user's device. allow users install PWA home screen, providing native app-like experience. use tools like favicon generators create different icon sets place generated files public/ folder. 2. Implementing Web Push Notifications Web Push Notifications supported modern browsers, including: - iOS 16.4+ applications installed home screen - Safari 16 macOS 13 later - Chromium based browsers - Firefox makes PWAs viable alternative native apps. Notably, trigger install prompts without needing offline support. Web Push Notifications allow re-engage users even actively using app. Here's implement Next.js application: First, let's create main page component app/page.tsx . break smaller parts better understanding. First, we\u2019ll add imports utilities we\u2019ll need. It\u2019s okay referenced Server Actions yet exist: 'use client' import { useState, useEffect } 'react' import { subscribeUser, unsubscribeUser, sendNotification } './actions' function urlBase64ToUint8Array(base64String: string) { const padding = '='.repeat((4 - (base64String.length % 4)) % 4) const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/') const rawData = window.atob(base64) const outputArray = new Uint8Array(rawData.length) (let = 0; < rawData.length; ++i) { outputArray[i] = rawData.charCodeAt(i) } return outputArray } Let\u2019s add component manage subscribing, unsubscribing, sending push notifications. function PushNotificationManager() { const [isSupported, setIsSupported] = useState(false) const [subscription, setSubscription] = useState<PushSubscription | null>( null ) const [message, setMessage] = useState('') useEffect(() => { ('serviceWorker' navigator && 'PushManager' window) { setIsSupported(true) registerServiceWorker() } }, []) async function registerServiceWorker() { const registration = await navigator.serviceWorker.register('/sw.js', { scope: '/', updateViaCache: 'none', }) const sub = await registration.pushManager.getSubscription() setSubscription(sub) } async function subscribeToPush() { const registration = await navigator.serviceWorker.ready const sub = await registration.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: urlBase64ToUint8Array( process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY! ), }) setSubscription(sub) const serializedSub = JSON.parse(JSON.stringify(sub)) await subscribeUser(serializedSub) } async function unsubscribeFromPush() { await subscription?.unsubscribe() setSubscription(null) await unsubscribeUser() } async function sendTestNotification() { (subscription) { await sendNotification(message) setMessage('') } } (!isSupported) { return <p>Push notifications supported browser.</p> } return ( <div> <h3>Push Notifications</h3> {subscription ? ( <> <p>You subscribed push notifications.</p> <button onClick={unsubscribeFromPush}>Unsubscribe</button> <input type=\"text\" placeholder=\"Enter notification message\" value={message} onChange={(e) => setMessage(e.target.value)} /> <button onClick={sendTestNotification}>Send Test</button> </> ) : ( <> <p>You subscribed push notifications.</p> <button onClick={subscribeToPush}>Subscribe</button> </> )} </div> ) } Finally, let\u2019s create component show message iOS devices instruct install home screen, show app already installed. function InstallPrompt() { const [isIOS, setIsIOS] = useState(false) const [isStandalone, setIsStandalone] = useState(false) useEffect(() => { setIsIOS( /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window any).MSStream ) setIsStandalone(window.matchMedia('(display-mode: standalone)').matches) }, []) (isStandalone) { return null // show install button already installed } return ( <div> <h3>Install App</h3> <button>Add Home Screen</button> {isIOS && ( <p> install app iOS device, tap share button <span role=\"img\" aria-label=\"share icon\"> {' '} \u238b{' '} </span> \"Add Home Screen\" <span role=\"img\" aria-label=\"plus icon\"> {' '} \u2795{' '} </span>. </p> )} </div> ) } export default function Page() { return ( <div> <PushNotificationManager /> <InstallPrompt /> </div> ) } Now, let\u2019s create Server Actions file calls. 3. Implementing Server Actions Create new file contain actions app/actions.ts . file handle creating subscriptions, deleting subscriptions, sending notifications. 'use server' import webpush 'web-push' webpush.setVapidDetails( '<mailto:your-email@example.com>', process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!, process.env.VAPID_PRIVATE_KEY! ) let subscription: PushSubscription | null = null export async function subscribeUser(sub: PushSubscription) { subscription = sub // production environment, would want store subscription database // example: await db.subscriptions.create({ data: sub }) return { success: true } } export async function unsubscribeUser() { subscription = null // production environment, would want remove subscription database // example: await db.subscriptions.delete({ where: { ... } }) return { success: true } } export async function sendNotification(message: string) { (!subscription) { throw new Error('No subscription available') } try { await webpush.sendNotification( subscription, JSON.stringify({ title: 'Test Notification', body: message, icon: '/icon.png', }) ) return { success: true } } catch (error) { console.error('Error sending push notification:', error) return { success: false, error: 'Failed send notification' } } } Sending notification handled service worker, created step 5. production environment, would want store subscription database persistence across server restarts manage multiple users' subscriptions. 4. Generating VAPID Keys use Web Push API, need generate VAPID keys. simplest way use web-push CLI directly: First, install web-push globally: npm install -g web-push Generate VAPID keys running: web-push generate-vapid-keys Copy output paste keys .env file: NEXT_PUBLIC_VAPID_PUBLIC_KEY=your_public_key_here VAPID_PRIVATE_KEY=your_private_key_here 5. Creating Service Worker Create public/sw.js file service worker: self.addEventListener('push', function (event) { (event.data) { const data = event.data.json() const options = { body: data.body, icon: data.icon || '/icon.png', badge: '/badge.png', vibrate: [100, 50, 100], data: { dateOfArrival: Date.now(), primaryKey: '2', }, } event.waitUntil(self.registration.showNotification(data.title, options)) } }) self.addEventListener('notificationclick', function (event) { console.log('Notification click received.') event.notification.close() event.waitUntil(clients.openWindow('<https://your-website.com>')) }) service worker supports custom images notifications. handles incoming push events notification clicks. - set custom icons notifications using icon andbadge properties. - vibrate pattern adjusted create custom vibration alerts supported devices. - Additional data attached notification using data property. Remember test service worker thoroughly ensure behaves expected across different devices browsers. Also, make sure update 'https://your-website.com' link notificationclick event listener appropriate URL application. 6. Adding Home Screen InstallPrompt component defined step 2 shows message iOS devices instruct install home screen. ensure application installed mobile home screen, must have: - valid web app manifest (created step 1) - website served HTTPS Modern browsers automatically show installation prompt users criteria met. provide custom installation button beforeinstallprompt , however, recommend cross browser platform (does work Safari iOS). 7. Testing Locally ensure view notifications locally, ensure that: - running locally HTTPS - Use next dev --experimental-https testing - Use - browser (Chrome, Safari, Firefox) notifications enabled - prompted locally, accept permissions use notifications - Ensure notifications disabled globally entire browser - still seeing notifications, try using another browser debug 8. Securing application Security crucial aspect web application, especially PWAs. Next.js allows configure security headers using next.config.js file. example: module.exports = { async headers() { return [ { source: '/(.*)', headers: [ { key: 'X-Content-Type-Options', value: 'nosniff', }, { key: 'X-Frame-Options', value: 'DENY', }, { key: 'Referrer-Policy', value: 'strict-origin-when-cross-origin', }, ], }, { source: '/sw.js', headers: [ { key: 'Content-Type', value: 'application/javascript; charset=utf-8', }, { key: 'Cache-Control', value: 'no-cache, no-store, must-revalidate', }, { key: 'Content-Security-Policy', value: \"default-src 'self'; script-src 'self'\", }, ], }, ] }, } Let\u2019s go options: - Global Headers (applied routes): X-Content-Type-Options: nosniff : Prevents MIME type sniffing, reducing risk malicious file uploads.X-Frame-Options: DENY : Protects clickjacking attacks preventing site embedded iframes.Referrer-Policy: strict-origin-when-cross-origin : Controls much referrer information included requests, balancing security functionality. - Service Worker Specific Headers: Content-Type: application/javascript; charset=utf-8 : Ensures service worker interpreted correctly JavaScript.Cache-Control: no-cache, no-store, must-revalidate : Prevents caching service worker, ensuring users always get latest version.Content-Security-Policy: default-src 'self'; script-src 'self' : Implements strict Content Security Policy service worker, allowing scripts origin. Learn defining Content Security Policies Next.js. Next Steps - Exploring PWA Capabilities: PWAs leverage various web APIs provide advanced functionality. Consider exploring features like background sync, periodic background sync, File System Access API enhance application. inspiration up-to-date information PWA capabilities, refer resources like PWA Today. - Static Exports: application requires running server, instead using static export files, update Next.js configuration enable change. Learn Next.js Static Export documentation. However, need move Server Actions calling external API, well moving defined headers proxy. - Offline Support: provide offline functionality, one option Serwist Next.js. find example integrate Serwist Next.js documentation. Note: plugin currently requires webpack configuration. - Security Considerations: Ensure service worker properly secured. includes using HTTPS, validating source push messages, implementing proper error handling. - User Experience: Consider implementing progressive enhancement techniques ensure app works well even certain PWA features supported user's browser. helpful?"},
{"source": "https://nextjs.org/docs/app/guides/sass", "title": "Guides: Sass | Next.js", "text": "use Sass Next.js built-in support integrating Sass package installed using .scss .sass extensions. use component-level Sass via CSS Modules .module.scss .module.sass extension. First, install sass : npm install --save-dev sass Good know: Sass supports two different syntaxes, extension. .scss extension requires use SCSS syntax, the.sass extension requires use Indented Syntax (\"Sass\").If sure choose, start .scss extension superset CSS, require learn Indented Syntax (\"Sass\"). Customizing Sass Options want configure Sass options, use sassOptions next.config . import type { NextConfig } 'next' const nextConfig: NextConfig = { sassOptions: { additionalData: `$var: red;`, }, } export default nextConfig Implementation use implementation property specify Sass implementation use. default, Next.js uses sass package. import type { NextConfig } 'next' const nextConfig: NextConfig = { sassOptions: { implementation: 'sass-embedded', }, } export default nextConfig Sass Variables Next.js supports Sass variables exported CSS Module files. example, using exported primaryColor Sass variable: $primary-color: #64ff00; :export { primaryColor: $primary-color; } // maps root `/` URL import variables './variables.module.scss' export default function Page() { return <h1 style={{ color: variables.primaryColor }}>Hello, Next.js!</h1> } helpful?"},
{"source": "https://nextjs.org/docs/app/guides/scripts", "title": "Guides: Scripts | Next.js", "text": "load optimize scripts Layout Scripts load third-party script multiple routes, import next/script include script directly layout component: import Script 'next/script' export default function DashboardLayout({ children, }: { children: React.ReactNode }) { return ( <> <section>{children}</section> <Script src=\"https://example.com/script.js\" /> </> ) } third-party script fetched folder route (e.g. dashboard/page.js ) nested route (e.g. dashboard/settings/page.js ) accessed user. Next.js ensure script load once, even user navigates multiple routes layout. Application Scripts load third-party script routes, import next/script include script directly root layout: import Script 'next/script' export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body>{children}</body> <Script src=\"https://example.com/script.js\" /> </html> ) } script load execute route application accessed. Next.js ensure script load once, even user navigates multiple pages. Recommendation: recommend including third-party scripts specific pages layouts order minimize unnecessary impact performance. Strategy Although default behavior next/script allows load third-party scripts page layout, fine-tune loading behavior using strategy property: beforeInteractive : Load script Next.js code page hydration occurs.afterInteractive : (default) Load script early hydration page occurs.lazyOnload : Load script later browser idle time.worker : (experimental) Load script web worker. Refer next/script API reference documentation learn strategy use cases. Offloading Scripts Web Worker (experimental) Warning: worker strategy yet stable yet work App Router. Use caution. Scripts use worker strategy offloaded executed web worker Partytown. improve performance site dedicating main thread rest application code. strategy still experimental used nextScriptWorkers flag enabled next.config.js : module.exports = { experimental: { nextScriptWorkers: true, }, } Then, run next (normally npm run dev yarn dev ) Next.js guide installation required packages finish setup: npm run dev see instructions like these: Please install Partytown running npm install @builder.io/partytown setup complete, defining strategy=\"worker\" automatically instantiate Partytown application offload script web worker. import Script 'next/script' export default function Home() { return ( <> <Script src=\"https://example.com/script.js\" strategy=\"worker\" /> </> ) } number trade-offs need considered loading third-party script web worker. Please see Partytown's tradeoffs documentation information. Inline Scripts Inline scripts, scripts loaded external file, also supported Script component. written placing JavaScript within curly braces: <Script id=\"show-banner\"> {`document.getElementById('banner').classList.remove('hidden')`} </Script> using dangerouslySetInnerHTML property: <Script id=\"show-banner\" dangerouslySetInnerHTML={{ __html: `document.getElementById('banner').classList.remove('hidden')`, }} /> Warning: id property must assigned inline scripts order Next.js track optimize script. Executing Additional Code Event handlers used Script component execute additional code certain event occurs: onLoad : Execute code script finished loading.onReady : Execute code script finished loading every time component mounted.onError : Execute code script fails load. handlers work next/script imported used inside Client Component \"use client\" defined first line code: 'use client' import Script 'next/script' export default function Page() { return ( <> <Script src=\"https://example.com/script.js\" onLoad={() => { console.log('Script loaded') }} /> </> ) } Refer next/script API reference learn event handler view examples. Additional Attributes many DOM attributes assigned <script> element used Script component, like nonce custom data attributes. Including additional attributes automatically forward final, optimized <script> element included HTML. import Script 'next/script' export default function Page() { return ( <> <Script src=\"https://example.com/script.js\" id=\"example-script\" nonce=\"XUENAJFW\" data-test=\"script\" /> </> ) } API Reference helpful?"},
{"source": "https://nextjs.org/docs/app/guides/self-hosting", "title": "Guides: Self-Hosting | Next.js", "text": "self-host Next.js application deploying Next.js app, may want configure different features handled based infrastructure. \ud83c\udfa5 Watch: Learn self-hosting Next.js \u2192 YouTube (45 minutes). Image Optimization Image Optimization next/image works self-hosted zero configuration deploying using next start . would prefer separate service optimize images, configure image loader. Image Optimization used static export defining custom image loader next.config.js . Note images optimized runtime, build. Good know: - glibc-based Linux systems, Image Optimization may require additional configuration prevent excessive memory usage. - Learn caching behavior optimized images configure TTL. - also disable Image Optimization still retain benefits using next/image prefer. example, optimizing images separately. Middleware Middleware works self-hosted zero configuration deploying using next start . Since requires access incoming request, supported using static export. Middleware uses Edge runtime, subset available Node.js APIs help ensure low latency, since may run front every route asset application. want this, use full Node.js runtime run Middleware. looking add logic (or use external package) requires Node.js APIs, might able move logic layout Server Component. example, checking headers redirecting. also use headers, cookies, query parameters redirect rewrite next.config.js . work, also use custom server. Environment Variables Next.js support build time runtime environment variables. default, environment variables available server. expose environment variable browser, must prefixed NEXT_PUBLIC_ . However, public environment variables inlined JavaScript bundle next build . safely read environment variables server dynamic rendering. import { connection } 'next/server' export default async function Component() { await connection() // cookies, headers, Dynamic APIs // also opt dynamic rendering, meaning // env variable evaluated runtime const value = process.env.MY_VALUE // ... } allows use singular Docker image promoted multiple environments different values. Good know: - run code server startup using register function.- recommend using runtimeConfig option, work standalone output mode. Instead, recommend incrementally adopting App Router. Caching ISR Next.js cache responses, generated static pages, build outputs, static assets like images, fonts, scripts. Caching revalidating pages (with Incremental Static Regeneration) use shared cache. default, cache stored filesystem (on disk) Next.js server. works automatically self-hosting using Pages App Router. configure Next.js cache location want persist cached pages data durable storage, share cache across multiple containers instances Next.js application. Automatic Caching - Next.js sets Cache-Control header ofpublic, max-age=31536000, immutable truly immutable assets. cannot overridden. immutable files contain SHA-hash file name, safely cached indefinitely. example, Static Image Imports. configure TTL images. - Incremental Static Regeneration (ISR) sets Cache-Control header ofs-maxage: <revalidate getStaticProps>, stale-while-revalidate . revalidation time defined yourgetStaticProps function seconds. setrevalidate: false , default one-year cache duration. - Dynamically rendered pages set Cache-Control header ofprivate, no-cache, no-store, max-age=0, must-revalidate prevent user-specific data cached. applies App Router Pages Router. also includes Draft Mode. Static Assets want host static assets different domain CDN, use assetPrefix configuration next.config.js . Next.js use asset prefix retrieving JavaScript CSS files. Separating assets different domain come downside extra time spent DNS TLS resolution. Configuring Caching default, generated cache assets stored memory (defaults 50mb) disk. hosting Next.js using container orchestration platform like Kubernetes, pod copy cache. prevent stale data shown since cache shared pods default, configure Next.js cache provide cache handler disable in-memory caching. configure ISR/Data Cache location self-hosting, configure custom handler next.config.js file: module.exports = { cacheHandler: require.resolve('./cache-handler.js'), cacheMaxMemorySize: 0, // disable default in-memory caching } Then, create cache-handler.js root project, example: const cache = new Map() module.exports = class CacheHandler { constructor(options) { this.options = options } async get(key) { // could stored anywhere, like durable storage return cache.get(key) } async set(key, data, ctx) { // could stored anywhere, like durable storage cache.set(key, { value: data, lastModified: Date.now(), tags: ctx.tags, }) } async revalidateTag(tags) { // tags either string array strings tags = [tags].flat() // Iterate entries cache (let [key, value] cache) { // value's tags include specified tag, delete entry (value.tags.some((tag) => tags.includes(tag))) { cache.delete(key) } } } // want temporary memory cache single request reset // next request leverage method resetRequestCache() {} } Using custom cache handler allow ensure consistency across pods hosting Next.js application. instance, save cached values anywhere, like Redis AWS S3. Good know: revalidatePath convenience layer top cache tags. CallingrevalidatePath call therevalidateTag function special default tag provided page. Build Cache Next.js generates ID next build identify version application served. build used boot multiple containers. rebuilding stage environment, need generate consistent build ID use containers. Use generateBuildId command next.config.js : module.exports = { generateBuildId: async () => { // could anything, using latest git hash return process.env.GIT_HASH }, } Version Skew Next.js automatically mitigate instances version skew automatically reload application retrieve new assets detected. example, mismatch deploymentId , transitions pages perform hard navigation versus using prefetched value. application reloaded, may loss application state designed persist page navigations. example, using URL state local storage would persist state page refresh. However, component state like useState would lost navigations. Streaming Suspense Next.js App Router supports streaming responses self-hosting. using Nginx similar proxy, need configure disable buffering enable streaming. example, disable buffering Nginx setting X-Accel-Buffering : module.exports = { async headers() { return [ { source: '/:path*{/}?', headers: [ { key: 'X-Accel-Buffering', value: 'no', }, ], }, ] }, } Partial Prerendering Partial Prerendering (experimental) works default Next.js CDN-only feature. includes deployment Node.js server (through next start ) used Docker container. Usage CDNs using CDN front Next.js application, page include Cache-Control: private response header dynamic APIs accessed. ensures resulting HTML page marked non-cachable. page fully prerendered static, include Cache-Control: public allow page cached CDN. need mix static dynamic components, make entire route static cache output HTML CDN. Automatic Static Optimization default behavior running next build dynamic APIs used. Partial Prerendering moves stable, provide support Deployment Adapters API. fully supported self-hosting next start . stopping server, ensure graceful shutdown sending SIGINT SIGTERM signals waiting. allows Next.js server wait pending callback functions promises used inside finished. helpful?"},
{"source": "https://nextjs.org/docs/app/guides/single-page-applications", "title": "Guides: SPAs | Next.js", "text": "build single-page applications Next.js Next.js fully supports building Single-Page Applications (SPAs). includes fast route transitions prefetching, client-side data fetching, using browser APIs, integrating third-party client libraries, creating static routes, more. existing SPA, migrate Next.js without large changes code. Next.js allows progressively add server features needed. Single-Page Application? definition SPA varies. We\u2019ll define \u201cstrict SPA\u201d as: - Client-side rendering (CSR): app served one HTML file (e.g. index.html ). Every route, page transition, data fetch handled JavaScript browser. - full-page reloads: Rather requesting new document route, client-side JavaScript manipulates current page\u2019s DOM fetches data needed. Strict SPAs often require large amounts JavaScript load page interactive. Further, client data waterfalls challenging manage. Building SPAs Next.js address issues. use Next.js SPAs? Next.js automatically code split JavaScript bundles, generate multiple HTML entry points different routes. avoids loading unnecessary JavaScript code client-side, reducing bundle size enabling faster page loads. next/link component automatically prefetches routes, giving fast page transitions strict SPA, advantage persisting application routing state URL linking sharing. Next.js start static site even strict SPA everything rendered client-side. project grows, Next.js allows progressively add server features (e.g. React Server Components, Server Actions, more) needed. Examples Let's explore common patterns used build SPAs Next.js solves them. Using React\u2019s use within Context Provider recommend fetching data parent component (or layout), returning Promise, unwrapping value Client Component React\u2019s use hook. Next.js start data fetching early server. example, that\u2019s root layout \u2014 entry point application. server immediately begin streaming response client. \u201choisting\u201d data fetching root layout, Next.js starts specified requests server early components application. eliminates client waterfalls prevents multiple roundtrips client server. also significantly improve performance, server closer (and ideally colocated) database located. example, update root layout call Promise, await it. import { UserProvider } './user-provider' import { getUser } './user' // server-side function export default function RootLayout({ children, }: { children: React.ReactNode }) { let userPromise = getUser() // await return ( <html lang=\"en\"> <body> <UserProvider userPromise={userPromise}>{children}</UserProvider> </body> </html> ) } defer pass single Promise prop Client Component, generally see pattern paired React context provider. enables easier access Client Components custom React Hook. forward Promise React context provider: 'use client'; import { createContext, useContext, ReactNode } 'react'; type User = any; type UserContextType = { userPromise: Promise<User | null>; }; const UserContext = createContext<UserContextType | null>(null); export function useUser(): UserContextType { let context = useContext(UserContext); (context === null) { throw new Error('useUser must used within UserProvider'); } return context; } export function UserProvider({ children, userPromise }: { children: ReactNode; userPromise: Promise<User | null>; }) { return ( <UserContext.Provider value={{ userPromise }}> {children} </UserContext.Provider> ); } Finally, call useUser() custom hook Client Component unwrap Promise: 'use client' import { use } 'react' import { useUser } './user-provider' export function Profile() { const { userPromise } = useUser() const user = use(userPromise) return '...' } component consumes Promise (e.g. Profile above) suspended. enables partial hydration. see streamed prerendered HTML JavaScript finished loading. SPAs SWR SWR popular React library data fetching. SWR 2.3.0 (and React 19+), gradually adopt server features alongside existing SWR-based client data fetching code. abstraction use() pattern. means move data fetching client server-side, use both: - Client-only: useSWR(key, fetcher) - Server-only: useSWR(key) + RSC-provided data - Mixed: useSWR(key, fetcher) + RSC-provided data example, wrap application <SWRConfig> fallback : import { SWRConfig } 'swr' import { getUser } './user' // server-side function export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <SWRConfig value={{ fallback: { // await getUser() // components read data suspend '/api/user': getUser(), }, }} > {children} </SWRConfig> ) } Server Component, getUser() securely read cookies, headers, talk database. separate API route needed. Client components <SWRConfig> call useSWR() key retrieve user data. component code useSWR require changes existing client-fetching solution. 'use client' import useSWR 'swr' export function Profile() { const fetcher = (url) => fetch(url).then((res) => res.json()) // SWR pattern already know const { data, error } = useSWR('/api/user', fetcher) return '...' } fallback data prerendered included initial HTML response, immediately read child components using useSWR . SWR\u2019s polling, revalidation, caching still run client-side only, preserves interactivity rely SPA. Since initial fallback data automatically handled Next.js, delete conditional logic previously needed check data undefined . data loading, closest <Suspense> boundary suspended. | SWR | RSC | RSC + SWR | | |---|---|---|---| | SSR data | ||| | Streaming SSR | ||| | Deduplicate requests | ||| | Client-side features | SPAs React Query use React Query Next.js client server. enables build strict SPAs, well take advantage server features Next.js paired React Query. Learn React Query documentation. Rendering components browser Client components prerendered next build . want disable prerendering Client Component load browser environment, use next/dynamic : import dynamic 'next/dynamic' const ClientOnlyComponent = dynamic(() => import('./component'), { ssr: false, }) useful third-party libraries rely browser APIs like window document . also add useEffect checks existence APIs, exist, return null loading state would prerendered. Shallow routing client migrating strict SPA like Create React App Vite, might existing code shallow routes update URL state. useful manual transitions views application without using default Next.js file-system routing. Next.js allows use native window.history.pushState window.history.replaceState methods update browser's history stack without reloading page. pushState replaceState calls integrate Next.js Router, allowing sync usePathname useSearchParams . 'use client' import { useSearchParams } 'next/navigation' export default function SortProducts() { const searchParams = useSearchParams() function updateSorting(sortOrder: string) { const urlSearchParams = new URLSearchParams(searchParams.toString()) urlSearchParams.set('sort', sortOrder) window.history.pushState(null, '', `?${urlSearchParams.toString()}`) } return ( <> <button onClick={() => updateSorting('asc')}>Sort Ascending</button> <button onClick={() => updateSorting('desc')}>Sort Descending</button> </> ) } Learn routing navigation work Next.js. Using Server Actions Client Components progressively adopt Server Actions still using Client Components. allows remove boilerplate code call API route, instead use React features like useActionState handle loading error states. example, create first Server Action: 'use server' export async function create() {} import use Server Action client, similar calling JavaScript function. need create API endpoint manually: 'use client' import { create } './actions' export function Button() { return <button onClick={() => create()}>Create</button> } Learn mutating data Server Actions. Static export (optional) Next.js also supports generating fully static site. advantages strict SPAs: - Automatic code-splitting: Instead shipping single index.html , Next.js generate HTML file per route, visitors get content faster without waiting client JavaScript bundle. - Improved user experience: Instead minimal skeleton routes, get fully rendered pages route. users navigate client side, transitions remain instant SPA-like. enable static export, update configuration: import type { NextConfig } 'next' const nextConfig: NextConfig = { output: 'export', } export default nextConfig running next build , Next.js create folder HTML/CSS/JS assets application. Note: Next.js server features supported static exports. Learn more. Migrating existing projects Next.js incrementally migrate Next.js following guides: already using SPA Pages Router, learn incrementally adopt App Router. helpful?"},
{"source": "https://nextjs.org/docs/app/guides/static-exports", "title": "Guides: Static Exports | Next.js", "text": "create static export Next.js application Next.js enables starting static site Single-Page Application (SPA), later optionally upgrading use features require server. running next build , Next.js generates HTML file per route. breaking strict SPA individual HTML files, Next.js avoid loading unnecessary JavaScript code client-side, reducing bundle size enabling faster page loads. Since Next.js supports static export, deployed hosted web server serve HTML/CSS/JS static assets. Configuration enable static export, change output mode inside next.config.js : /** * @type {import('next').NextConfig} */ const nextConfig = { output: 'export', // Optional: Change links `/me` -> `/me/` emit `/me.html` -> `/me/index.html` // trailingSlash: true, // Optional: Prevent automatic `/me` -> `/me/`, instead preserve `href` // skipTrailingSlashRedirect: true, // Optional: Change output directory `out` -> `dist` // distDir: 'dist', } module.exports = nextConfig running next build , Next.js create folder HTML/CSS/JS assets application. Supported Features core Next.js designed support static exports. Server Components run next build generate static export, Server Components consumed inside app directory run build, similar traditional static-site generation. resulting component rendered static HTML initial page load static payload client navigation routes. changes required Server Components using static export, unless consume dynamic server functions. export default async function Page() { // fetch run server `next build` const res = await fetch('https://api.example.com/...') const data = await res.json() return <main>...</main> } Client Components want perform data fetching client, use Client Component SWR memoize requests. 'use client' import useSWR 'swr' const fetcher = (url: string) => fetch(url).then((r) => r.json()) export default function Page() { const { data, error } = useSWR( `https://jsonplaceholder.typicode.com/posts/1`, fetcher ) (error) return 'Failed load' (!data) return 'Loading...' return data.title } Since route transitions happen client-side, behaves like traditional SPA. example, following index route allows navigate different posts client: import Link 'next/link' export default function Page() { return ( <> <h1>Index Page</h1> <hr /> <ul> <li> <Link href=\"/post/1\">Post 1</Link> </li> <li> <Link href=\"/post/2\">Post 2</Link> </li> </ul> </> ) } Image Optimization Image Optimization next/image used static export defining custom image loader next.config.js . example, optimize images service like Cloudinary: /** @type {import('next').NextConfig} */ const nextConfig = { output: 'export', images: { loader: 'custom', loaderFile: './my-loader.ts', }, } module.exports = nextConfig custom loader define fetch images remote source. example, following loader construct URL Cloudinary: export default function cloudinaryLoader({ src, width, quality, }: { src: string width: number quality?: number }) { const params = ['f_auto', 'c_limit', `w_${width}`, `q_${quality || 'auto'}`] return `https://res.cloudinary.com/demo/image/upload/${params.join( ',' )}${src}` } use next/image application, defining relative paths image Cloudinary: import Image 'next/image' export default function Page() { return <Image alt=\"turtles\" src=\"/turtles.jpg\" width={300} height={300} /> } Route Handlers Route Handlers render static response running next build . GET HTTP verb supported. used generate static HTML, JSON, TXT, files cached uncached data. example: export async function GET() { return Response.json({ name: 'Lee' }) } file app/data.json/route.ts render static file next build , producing data.json containing { name: 'Lee' } . need read dynamic values incoming request, cannot use static export. Browser APIs Client Components pre-rendered HTML next build . Web APIs like window , localStorage , navigator available server, need safely access APIs running browser. example: 'use client'; import { useEffect } 'react'; export default function ClientComponent() { useEffect(() => { // access `window` console.log(window.innerHeight); }, []) return ...; } Unsupported Features Features require Node.js server, dynamic logic cannot computed build process, supported: - Dynamic Routes dynamicParams: true - Dynamic Routes without generateStaticParams() - Route Handlers rely Request - Cookies - Rewrites - Redirects - Headers - Middleware - Incremental Static Regeneration - Image Optimization default loader - Draft Mode - Server Actions - Intercepting Routes Attempting use features next dev result error, similar setting dynamic option error root layout. export const dynamic = 'error' Deploying static export, Next.js deployed hosted web server serve HTML/CSS/JS static assets. running next build , Next.js generates static export folder. example, let's say following routes: / /blog/[id] running next build , Next.js generate following files: /out/index.html /out/404.html /out/blog/post-1.html /out/blog/post-2.html using static host like Nginx, configure rewrites incoming requests correct files: server { listen 80; server_name acme.com; root /var/www/out; location / { try_files $uri $uri.html $uri/ =404; } # necessary `trailingSlash: false`. # omit `trailingSlash: true`. location /blog/ { rewrite ^/blog/(.*)$ /blog/$1.html break; } error_page 404 /404.html; location = /404.html { internal; } } Version History | Version | Changes | |---|---| v14.0.0 | next export removed favor \"output\": \"export\" | v13.4.0 | App Router (Stable) adds enhanced static export support, including using React Server Components Route Handlers. | v13.3.0 | next export deprecated replaced \"output\": \"export\" | helpful?"},
{"source": "https://nextjs.org/docs/app/guides/tailwind-css", "title": "Guides: Tailwind CSS | Next.js", "text": "install Tailwind CSS Next.js application Tailwind CSS utility-first CSS framework fully compatible Next.js. guide walk install Tailwind CSS Next.js application. Installing Tailwind Install necessary Tailwind CSS packages: npm install -D tailwindcss @tailwindcss/postcss postcss Good know: using create-next-app CLI create project, Next.js prompt like install Tailwind automatically configure project. Configuring Tailwind Create postcss.config.mjs file root project add @tailwindcss/postcss plugin PostCSS configuration: /** @type {import('tailwindcss').Config} */ export default { plugins: { '@tailwindcss/postcss': {}, }, } Tailwind v4, zero configuration required default. need configure Tailwind, follow official documentation configuring global CSS file. also upgrade CLI guide existing Tailwind v3 project. Importing Styles Add Tailwind CSS directives Tailwind use inject generated styles Global Stylesheet application, example: @import 'tailwindcss'; Inside root layout (app/layout.tsx ), import globals.css stylesheet apply styles every route application. import type { Metadata } 'next' // styles apply every route application import './globals.css' export const metadata: Metadata = { title: 'Create Next App', description: 'Generated create next app', } export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body>{children}</body> </html> ) } Using Classes installing Tailwind CSS adding global styles, use Tailwind's utility classes application. export default function Page() { return <h1 className=\"text-3xl font-bold underline\">Hello, Next.js!</h1> } Usage Turbopack Next.js 13.1, Tailwind CSS PostCSS supported Turbopack. helpful?"},
{"source": "https://nextjs.org/docs/app/guides/testing", "title": "Guides: Testing | Next.js", "text": "Testing React Next.js, different types tests write, purpose use cases. page provides overview types commonly used tools use test application. Types tests - Unit Testing involves testing individual units (or blocks code) isolation. React, unit single function, hook, component. - Component Testing focused version unit testing primary subject tests React components. may involve testing components rendered, interaction props, behavior response user events. - Integration Testing involves testing multiple units work together. combination components, hooks, functions. - End-to-End (E2E) Testing involves testing user flows environment simulates real user scenarios, like browser. means testing specific tasks (e.g. signup flow) production-like environment. - Snapshot Testing involves capturing rendered output component saving snapshot file. tests run, current rendered output component compared saved snapshot. Changes snapshot used indicate unexpected changes behavior. Async Server Components Since async Server Components new React ecosystem, tools fully support them. meantime, recommend using End-to-End Testing Unit Testing async components. Guides See guides learn set Next.js commonly used testing tools: Cypress Learn set Cypress Next.js End-to-End (E2E) Component Testing. Jest Learn set Jest Next.js Unit Testing Snapshot Testing. Playwright Learn set Playwright Next.js End-to-End (E2E) Testing. Vitest Learn set Vitest Next.js Unit Testing. helpful?"},
{"source": "https://nextjs.org/docs/app/guides/testing/cypress", "title": "Testing: Cypress | Next.js", "text": "set Cypress Next.js Cypress test runner used End-to-End (E2E) Component Testing. page show set Cypress Next.js write first tests. Warning: - Cypress versions 13.6.3 support TypeScript version 5 moduleResolution:\"bundler\" . However, issue resolved Cypress version 13.6.3 later. cypress v13.6.3 Quickstart use create-next-app with-cypress example quickly get started. npx create-next-app@latest --example with-cypress with-cypress-app Manual setup manually set Cypress, install cypress dev dependency: npm install -D cypress # yarn add -D cypress # pnpm install -D cypress Add Cypress open command package.json scripts field: { \"scripts\": { \"dev\": \"next dev\", \"build\": \"next build\", \"start\": \"next start\", \"lint\": \"next lint\", \"cypress:open\": \"cypress open\" } } Run Cypress first time open Cypress testing suite: npm run cypress:open choose configure E2E Testing and/or Component Testing. Selecting options automatically create cypress.config.js file cypress folder project. Creating first Cypress E2E test Ensure cypress.config file following configuration: import { defineConfig } 'cypress' export default defineConfig({ e2e: { setupNodeEvents(on, config) {}, }, }) Then, create two new Next.js files: import Link 'next/link' export default function Page() { return ( <div> <h1>Home</h1> <Link href=\"/about\">About</Link> </div> ) } import Link 'next/link' export default function Page() { return ( <div> <h1>About</h1> <Link href=\"/\">Home</Link> </div> ) } Add test check navigation working correctly: describe('Navigation', () => { it('should navigate page', () => { // Start index page cy.visit('http://localhost:3000/') // Find link href attribute containing \"about\" click cy.get('a[href*=\"about\"]').click() // new url include \"/about\" cy.url().should('include', '/about') // new page contain h1 \"About\" cy.get('h1').contains('About') }) }) Running E2E Tests Cypress simulate user navigating application, requires Next.js server running. recommend running tests production code closely resemble application behave. Run npm run build && npm run start build Next.js application, run npm run cypress:open another terminal window start Cypress run E2E Testing suite. Good know: - use cy.visit(\"/\") instead ofcy.visit(\"http://localhost:3000/\") addingbaseUrl: 'http://localhost:3000' thecypress.config.js configuration file.- Alternatively, install start-server-and-test package run Next.js production server conjunction Cypress. installation, add\"test\": \"start-server-and-test start http://localhost:3000 cypress\" yourpackage.json scripts field. Remember rebuild application new changes. Creating first Cypress component test Component tests build mount specific component without bundle whole application start server. Select Component Testing Cypress app, select Next.js front-end framework. cypress/component folder created project, cypress.config.js file updated enable Component Testing. Ensure cypress.config file following configuration: import { defineConfig } 'cypress' export default defineConfig({ component: { devServer: { framework: 'next', bundler: 'webpack', }, }, }) Assuming components previous section, add test validate component rendering expected output: import Page '../../app/page' describe('<Page />', () => { it('should render display expected content', () => { // Mount React component Home page cy.mount(<Page />) // new page contain h1 \"Home\" cy.get('h1').contains('Home') // Validate link expected URL present // Following link better suited E2E test cy.get('a[href=\"/about\"]').should('be.visible') }) }) Good know: - Cypress currently support Component Testing async Server Components. recommend using E2E testing.- Since component tests require Next.js server, features like <Image /> rely server available may function out-of-the-box. Running Component Tests Run npm run cypress:open terminal start Cypress run Component Testing suite. Continuous Integration (CI) addition interactive testing, also run Cypress headlessly using cypress run command, better suited CI environments: { \"scripts\": { //... \"e2e\": \"start-server-and-test dev http://localhost:3000 \\\"cypress open --e2e\\\"\", \"e2e:headless\": \"start-server-and-test dev http://localhost:3000 \\\"cypress run --e2e\\\"\", \"component\": \"cypress open --component\", \"component:headless\": \"cypress run --component\" } } learn Cypress Continuous Integration resources: helpful?"},
{"source": "https://nextjs.org/docs/app/guides/testing/jest", "title": "Testing: Jest | Next.js", "text": "set Jest Next.js Jest React Testing Library frequently used together Unit Testing Snapshot Testing. guide show set Jest Next.js write first tests. Good know: Since async Server Components new React ecosystem, Jest currently support them. still run unit tests synchronous Server Client Components, recommend using E2E tests forasync components. Quickstart use create-next-app Next.js with-jest example quickly get started: npx create-next-app@latest --example with-jest with-jest-app Manual setup Since release Next.js 12, Next.js built-in configuration Jest. set Jest, install jest following packages dev dependencies: npm install -D jest jest-environment-jsdom @testing-library/react @testing-library/dom @testing-library/jest-dom ts-node @types/jest # yarn add -D jest jest-environment-jsdom @testing-library/react @testing-library/dom @testing-library/jest-dom ts-node @types/jest # pnpm install -D jest jest-environment-jsdom @testing-library/react @testing-library/dom @testing-library/jest-dom ts-node @types/jest Generate basic Jest configuration file running following command: npm init jest@latest # yarn create jest@latest # pnpm create jest@latest take series prompts setup Jest project, including automatically creating jest.config.ts|js file. Update config file use next/jest . transformer necessary configuration options Jest work Next.js: import type { Config } 'jest' import nextJest 'next/jest.js' const createJestConfig = nextJest({ // Provide path Next.js app load next.config.js .env files test environment dir: './', }) // Add custom config passed Jest const config: Config = { coverageProvider: 'v8', testEnvironment: 'jsdom', // Add setup options test run // setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'], } // createJestConfig exported way ensure next/jest load Next.js config async export default createJestConfig(config) hood, next/jest automatically configuring Jest you, including: - Setting transform using Next.js Compiler. - Auto mocking stylesheets ( .css ,.module.css , scss variants), image imports andnext/font . - Loading .env (and variants) intoprocess.env . - Ignoring node_modules test resolving transforms. - Ignoring .next test resolving. - Loading next.config.js flags enable SWC transforms. Good know: test environment variables directly, load manually separate setup script jest.config.ts file. information, please see Test Environment Variables. Optional: Handling Absolute Imports Module Path Aliases project using Module Path Aliases, need configure Jest resolve imports matching paths option jsconfig.json file moduleNameMapper option jest.config.js file. example: { \"compilerOptions\": { \"module\": \"esnext\", \"moduleResolution\": \"bundler\", \"baseUrl\": \"./\", \"paths\": { \"@/components/*\": [\"components/*\"] } } } moduleNameMapper: { // ... '^@/components/(.*)$': '<rootDir>/components/$1', } Optional: Extend Jest custom matchers @testing-library/jest-dom includes set convenient custom matchers .toBeInTheDocument() making easier write tests. import custom matchers every test adding following option Jest configuration file: setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'] Then, inside jest.setup , add following import: import '@testing-library/jest-dom' Good know: extend-expect removed inv6.0 , using@testing-library/jest-dom version 6, need import@testing-library/jest-dom/extend-expect instead. need add setup options test, add jest.setup file above. Add test script package.json Finally, add Jest test script package.json file: { \"scripts\": { \"dev\": \"next dev\", \"build\": \"next build\", \"start\": \"next start\", \"test\": \"jest\", \"test:watch\": \"jest --watch\" } } jest --watch re-run tests file changed. Jest CLI options, please refer Jest Docs. Creating first test project ready run tests. Create folder called __tests__ project's root directory. example, add test check <Page /> component successfully renders heading: import Link 'next/link' export default function Page() { return ( <div> <h1>Home</h1> <Link href=\"/about\">About</Link> </div> ) } import '@testing-library/jest-dom' import { render, screen } '@testing-library/react' import Page '../app/page' describe('Page', () => { it('renders heading', () => { render(<Page />) const heading = screen.getByRole('heading', { level: 1 }) expect(heading).toBeInTheDocument() }) }) Optionally, add snapshot test keep track unexpected changes component: import { render } '@testing-library/react' import Page '../app/page' it('renders homepage unchanged', () => { const { container } = render(<Page />) expect(container).toMatchSnapshot() }) Running tests Then, run following command run tests: npm run test # yarn test # pnpm test Additional Resources reading, may find resources helpful: - Next.js Jest example - Jest Docs - React Testing Library Docs - Testing Playground - use good testing practices match elements. helpful?"},
{"source": "https://nextjs.org/docs/app/guides/testing/playwright", "title": "Testing: Playwright | Next.js", "text": "set Playwright Next.js Playwright testing framework lets automate Chromium, Firefox, WebKit single API. use write End-to-End (E2E) testing. guide show set Playwright Next.js write first tests. Quickstart fastest way get started use create-next-app with-playwright example. create Next.js project complete Playwright configured. npx create-next-app@latest --example with-playwright with-playwright-app Manual setup install Playwright, run following command: npm init playwright # yarn create playwright # pnpm create playwright take series prompts setup configure Playwright project, including adding playwright.config.ts file. Please refer Playwright installation guide step-by-step guide. Creating first Playwright E2E test Create two new Next.js pages: import Link 'next/link' export default function Page() { return ( <div> <h1>Home</h1> <Link href=\"/about\">About</Link> </div> ) } import Link 'next/link' export default function Page() { return ( <div> <h1>About</h1> <Link href=\"/\">Home</Link> </div> ) } Then, add test verify navigation working correctly: import { test, expect } '@playwright/test' test('should navigate page', async ({ page }) => { // Start index page (the baseURL set via webServer playwright.config.ts) await page.goto('http://localhost:3000/') // Find element text 'About' click await page.click('text=About') // new URL \"/about\" (baseURL used there) await expect(page).toHaveURL('http://localhost:3000/about') // new page contain h1 \"About\" await expect(page.locator('h1')).toContainText('About') }) Good know: use page.goto(\"/\") instead ofpage.goto(\"http://localhost:3000/\") , add\"baseURL\": \"http://localhost:3000\" theplaywright.config.ts configuration file. Running Playwright tests Playwright simulate user navigating application using three browsers: Chromium, Firefox Webkit, requires Next.js server running. recommend running tests production code closely resemble application behave. Run npm run build npm run start , run npx playwright test another terminal window run Playwright tests. Good know: Alternatively, use webServer feature let Playwright start development server wait fully available. Running Playwright Continuous Integration (CI) Playwright default run tests headless mode. install Playwright dependencies, run npx playwright install-deps . learn Playwright Continuous Integration resources: helpful?"},
{"source": "https://nextjs.org/docs/app/guides/testing/vitest", "title": "Testing: Vitest | Next.js", "text": "set Vitest Next.js Vite React Testing Library frequently used together Unit Testing. guide show setup Vitest Next.js write first tests. Good know: Since async Server Components new React ecosystem, Vitest currently support them. still run unit tests synchronous Server Client Components, recommend using E2E tests forasync components. Quickstart use create-next-app Next.js with-vitest example quickly get started: npx create-next-app@latest --example with-vitest with-vitest-app Manual Setup manually set Vitest, install vitest following packages dev dependencies: # Using TypeScript npm install -D vitest @vitejs/plugin-react jsdom @testing-library/react @testing-library/dom vite-tsconfig-paths # Using JavaScript npm install -D vitest @vitejs/plugin-react jsdom @testing-library/react @testing-library/dom Create vitest.config.mts|js file root project, add following options: import { defineConfig } 'vitest/config' import react '@vitejs/plugin-react' import tsconfigPaths 'vite-tsconfig-paths' export default defineConfig({ plugins: [tsconfigPaths(), react()], test: { environment: 'jsdom', }, }) information configuring Vitest, please refer Vitest Configuration docs. Then, add test script package.json : { \"scripts\": { \"dev\": \"next dev\", \"build\": \"next build\", \"start\": \"next start\", \"test\": \"vitest\" } } run npm run test , Vitest watch changes project default. Creating first Vitest Unit Test Check everything working creating test check <Page /> component successfully renders heading: import Link 'next/link' export default function Page() { return ( <div> <h1>Home</h1> <Link href=\"/about\">About</Link> </div> ) } import { expect, test } 'vitest' import { render, screen } '@testing-library/react' import Page '../app/page' test('Page', () => { render(<Page />) expect(screen.getByRole('heading', { level: 1, name: 'Home' })).toBeDefined() }) Good know: example uses common __tests__ convention, test files also colocated inside theapp router. Running tests Then, run following command run tests: npm run test # yarn test # pnpm test # bun test Additional Resources may find resources helpful: helpful?"},
{"source": "https://nextjs.org/docs/app/guides/third-party-libraries", "title": "Guides: Third Party Libraries | Next.js", "text": "optimize third-party libraries @next/third-parties library provides collection components utilities improve performance developer experience loading popular third-party libraries Next.js application. third-party integrations provided @next/third-parties optimized performance ease use. Getting Started get started, install @next/third-parties library: npm install @next/third-parties@latest next@latest @next/third-parties currently experimental library active development. recommend installing latest canary flags work adding third-party integrations. Google Third-Parties supported third-party libraries Google imported @next/third-parties/google . Google Tag Manager GoogleTagManager component used instantiate Google Tag Manager container page. default, fetches original inline script hydration occurs page. load Google Tag Manager routes, include component directly root layout pass GTM container ID: import { GoogleTagManager } '@next/third-parties/google' export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <GoogleTagManager gtmId=\"GTM-XYZ\" /> <body>{children}</body> </html> ) } load Google Tag Manager single route, include component page file: import { GoogleTagManager } '@next/third-parties/google' export default function Page() { return <GoogleTagManager gtmId=\"GTM-XYZ\" /> } Sending Events sendGTMEvent function used track user interactions page sending events using dataLayer object. function work, <GoogleTagManager /> component must included either parent layout, page, component, directly file. 'use client' import { sendGTMEvent } '@next/third-parties/google' export function EventButton() { return ( <div> <button onClick={() => sendGTMEvent({ event: 'buttonClicked', value: 'xyz' })} > Send Event </button> </div> ) } Refer Tag Manager developer documentation learn different variables events passed function. Server-side Tagging using server-side tag manager serving gtm.js scripts tagging server use gtmScriptUrl option specify URL script. Options Options pass Google Tag Manager. full list options, read Google Tag Manager docs. | Name | Type | Description | |---|---|---| gtmId | Required | GTM container ID. Usually starts GTM- . | gtmScriptUrl | Optional | GTM script URL. Defaults https://www.googletagmanager.com/gtm.js . | dataLayer | Optional | Data layer object instantiate container with. | dataLayerName | Optional | Name data layer. Defaults dataLayer . | auth | Optional | Value authentication parameter (gtm_auth ) environment snippets. | preview | Optional | Value preview parameter (gtm_preview ) environment snippets. | Google Analytics GoogleAnalytics component used include Google Analytics 4 page via Google tag (gtag.js ). default, fetches original scripts hydration occurs page. Recommendation: Google Tag Manager already included application, configure Google Analytics directly using it, rather including Google Analytics separate component. Refer documentation learn differences Tag Manager gtag.js . load Google Analytics routes, include component directly root layout pass measurement ID: import { GoogleAnalytics } '@next/third-parties/google' export default function RootLayout({ children, }: { children: React.ReactNode }) { return ( <html lang=\"en\"> <body>{children}</body> <GoogleAnalytics gaId=\"G-XYZ\" /> </html> ) } load Google Analytics single route, include component page file: import { GoogleAnalytics } '@next/third-parties/google' export default function Page() { return <GoogleAnalytics gaId=\"G-XYZ\" /> } Sending Events sendGAEvent function used measure user interactions page sending events using dataLayer object. function work, <GoogleAnalytics /> component must included either parent layout, page, component, directly file. 'use client' import { sendGAEvent } '@next/third-parties/google' export function EventButton() { return ( <div> <button onClick={() => sendGAEvent('event', 'buttonClicked', { value: 'xyz' })} > Send Event </button> </div> ) } Refer Google Analytics developer documentation learn event parameters. Tracking Pageviews Google Analytics automatically tracks pageviews browser history state changes. means client-side navigations Next.js routes send pageview data without configuration. ensure client-side navigations measured correctly, verify \u201cEnhanced Measurement\u201d property enabled Admin panel \u201cPage changes based browser history events\u201d checkbox selected. Note: decide manually send pageview events, make sure disable default pageview measurement avoid duplicate data. Refer Google Analytics developer documentation learn more. Options Options pass <GoogleAnalytics> component. | Name | Type | Description | |---|---|---| gaId | Required | measurement ID. Usually starts G- . | dataLayerName | Optional | Name data layer. Defaults dataLayer . | nonce | Optional | nonce. | Google Maps Embed GoogleMapsEmbed component used add Google Maps Embed page. default, uses loading attribute lazy-load embed fold. import { GoogleMapsEmbed } '@next/third-parties/google' export default function Page() { return ( <GoogleMapsEmbed apiKey=\"XYZ\" height={200} width=\"100%\" mode=\"place\" q=\"Brooklyn+Bridge,New+York,NY\" /> ) } Options Options pass Google Maps Embed. full list options, read Google Map Embed docs. | Name | Type | Description | |---|---|---| apiKey | Required | api key. | mode | Required | Map mode | height | Optional | Height embed. Defaults auto . | width | Optional | Width embed. Defaults auto . | style | Optional | Pass styles iframe. | allowfullscreen | Optional | Property allow certain map parts go full screen. | loading | Optional | Defaults lazy. Consider changing know embed fold. | q | Optional | Defines map marker location. may required depending map mode. | center | Optional | Defines center map view. | zoom | Optional | Sets initial zoom level map. | maptype | Optional | Defines type map tiles load. | language | Optional | Defines language use UI elements display labels map tiles. | region | Optional | Defines appropriate borders labels display, based geo-political sensitivities. | YouTube Embed YouTubeEmbed component used load display YouTube embed. component loads faster using lite-youtube-embed hood. import { YouTubeEmbed } '@next/third-parties/google' export default function Page() { return <YouTubeEmbed videoid=\"ogfYd705cRs\" height={400} params=\"controls=0\" /> } Options | Name | Type | Description | |---|---|---| videoid | Required | YouTube video id. | width | Optional | Width video container. Defaults auto | height | Optional | Height video container. Defaults auto | playlabel | Optional | visually hidden label play button accessibility. | params | Optional | video player params defined here. Params passed query param string. Eg: params=\"controls=0&start=10&end=30\" | style | Optional | Used apply styles video container. | helpful?"},
{"source": "https://nextjs.org/docs/app/guides/upgrading", "title": "Guides: Upgrading | Next.js", "text": "Upgrade Guides Learn upgrade latest versions Next.js following versions-specific guides: Codemods Use codemods upgrade Next.js codebase new features released. Version 14 Upgrade Next.js Application Version 13 14. Version 15 Upgrade Next.js Application Version 14 15. helpful?"},
{"source": "https://nextjs.org/docs/app/guides/upgrading/codemods", "title": "Upgrading: Codemods | Next.js", "text": "Codemods Codemods transformations run codebase programmatically. allows large number changes programmatically applied without manually go every file. Next.js provides Codemod transformations help upgrade Next.js codebase API updated deprecated. Usage terminal, navigate (cd ) project's folder, run: npx @next/codemod <transform> <path> Replacing <transform> <path> appropriate values. transform - name transformpath - files directory transform--dry dry-run, code edited--print Prints changed output comparison Codemods 15.0 Transform App Router Route Segment Config runtime value experimental-edge edge app-dir-runtime-config-experimental-edge Note: codemod App Router specific. npx @next/codemod@latest app-dir-runtime-config-experimental-edge . codemod transforms Route Segment Config runtime value experimental-edge edge . example: export const runtime = 'experimental-edge' Transforms into: export const runtime = 'edge' Migrate async Dynamic APIs APIs opted dynamic rendering previously supported synchronous access asynchronous. read breaking change upgrade guide. next-async-request-api npx @next/codemod@latest next-async-request-api . codemod transform dynamic APIs (cookies() , headers() draftMode() next/headers ) asynchronous properly awaited wrapped React.use() applicable. automatic migration possible, codemod either add typecast (if TypeScript file) comment inform user needs manually reviewed & updated. example: import { cookies, headers } 'next/headers' const token = cookies().get('token') function useToken() { const token = cookies().get('token') return token } export default function Page() { const name = cookies().get('name') } function getHeader() { return headers().get('x-foo') } Transforms into: import { use } 'react' import { cookies, headers, type UnsafeUnwrappedCookies, type UnsafeUnwrappedHeaders, } 'next/headers' const token = (cookies() unknown UnsafeUnwrappedCookies).get('token') function useToken() { const token = use(cookies()).get('token') return token } export default async function Page() { const name = (await cookies()).get('name') } function getHeader() { return (headers() unknown UnsafeUnwrappedHeaders).get('x-foo') } detect property access params searchParams props page / route entries (page.js , layout.js , route.js , default.js ) generateMetadata / generateViewport APIs, attempt transform callsite sync async function, await property access. can't made async (such Client Component), use React.use unwrap promise . example: // page.tsx export default function Page({ params, searchParams, }: { params: { slug: string } searchParams: { [key: string]: string | string[] | undefined } }) { const { value } = searchParams (value === 'foo') { // ... } } export function generateMetadata({ params }: { params: { slug: string } }) { const { slug } = params return { title: `My Page - ${slug}`, } } Transforms into: // page.tsx export default async function Page(props: { params: Promise<{ slug: string }> searchParams: Promise<{ [key: string]: string | string[] | undefined }> }) { const searchParams = await props.searchParams const { value } = searchParams (value === 'foo') { // ... } } export async function generateMetadata(props: { params: Promise<{ slug: string }> }) { const params = await props.params const { slug } = params return { title: `My Page - ${slug}`, } } Good know: codemod identifies spot might require manual intervention, able determine exact fix, add comment typecast code inform user needs manually updated. comments prefixed @next/codemod, typecasts prefixed UnsafeUnwrapped . build error comments explicitly removed. Read more. Replace geo ip properties NextRequest @vercel/functions next-request-geo-ip npx @next/codemod@latest next-request-geo-ip . codemod installs @vercel/functions transforms geo ip properties NextRequest corresponding @vercel/functions features. example: import type { NextRequest } 'next/server' export function GET(req: NextRequest) { const { geo, ip } = req } Transforms into: import type { NextRequest } 'next/server' import { geolocation, ipAddress } '@vercel/functions' export function GET(req: NextRequest) { const geo = geolocation(req) const ip = ipAddress(req) } 14.0 Migrate ImageResponse imports next-og-import npx @next/codemod@latest next-og-import . codemod moves transforms imports next/server next/og usage Dynamic OG Image Generation. example: import { ImageResponse } 'next/server' Transforms into: import { ImageResponse } 'next/og' Use viewport export metadata-to-viewport-export npx @next/codemod@latest metadata-to-viewport-export . codemod migrates certain viewport metadata viewport export. example: export const metadata = { title: 'My App', themeColor: 'dark', viewport: { width: 1, }, } Transforms into: export const metadata = { title: 'My App', } export const viewport = { width: 1, themeColor: 'dark', } 13.2 Use Built-in Font built-in-next-font npx @next/codemod@latest built-in-next-font . codemod uninstalls @next/font package transforms @next/font imports built-in next/font . example: import { Inter } '@next/font/google' Transforms into: import { Inter } 'next/font/google' 13.0 Rename Next Image Imports next-image-to-legacy-image npx @next/codemod@latest next-image-to-legacy-image . Safely renames next/image imports existing Next.js 10, 11, 12 applications next/legacy/image Next.js 13. Also renames next/future/image next/image . example: import Image1 'next/image' import Image2 'next/future/image' export default function Home() { return ( <div> <Image1 src=\"/test.jpg\" width=\"200\" height=\"300\" /> <Image2 src=\"/test.png\" width=\"500\" height=\"400\" /> </div> ) } Transforms into: // 'next/image' becomes 'next/legacy/image' import Image1 'next/legacy/image' // 'next/future/image' becomes 'next/image' import Image2 'next/image' export default function Home() { return ( <div> <Image1 src=\"/test.jpg\" width=\"200\" height=\"300\" /> <Image2 src=\"/test.png\" width=\"500\" height=\"400\" /> </div> ) } Migrate New Image Component next-image-experimental npx @next/codemod@latest next-image-experimental . Dangerously migrates next/legacy/image new next/image adding inline styles removing unused props. - Removes layout prop addsstyle . - Removes objectFit prop addsstyle . - Removes objectPosition prop addsstyle . - Removes lazyBoundary prop. - Removes lazyRoot prop. Remove <a> Tags Link Components new-link npx @next/codemod@latest new-link . Remove <a> tags inside Link Components, add legacyBehavior prop Links cannot auto-fixed. example: <Link href=\"/about\"> <a>About</a> </Link> // transforms <Link href=\"/about\"> </Link> <Link href=\"/about\"> <a onClick={() => console.log('clicked')}>About</a> </Link> // transforms <Link href=\"/about\" onClick={() => console.log('clicked')}> </Link> cases auto-fixing can't applied, legacyBehavior prop added. allows app keep functioning using old behavior particular link. const Component = () => <a>About</a> <Link href=\"/about\"> <Component /> </Link> // becomes <Link href=\"/about\" legacyBehavior> <Component /> </Link> 11 Migrate CRA cra-to-next npx @next/codemod cra-to-next Migrates Create React App project Next.js; creating Pages Router necessary config match behavior. Client-side rendering leveraged initially prevent breaking compatibility due window usage SSR enabled seamlessly allow gradual adoption Next.js specific features. Please share feedback related transform discussion. 10 Add React imports add-missing-react-import npx @next/codemod add-missing-react-import Transforms files import React include import order new React JSX transform work. example: export default class Home extends React.Component { render() { return <div>Hello World</div> } } Transforms into: import React 'react' export default class Home extends React.Component { render() { return <div>Hello World</div> } } 9 Transform Anonymous Components Named Components name-default-component npx @next/codemod name-default-component Versions 9 above. Transforms anonymous components named components make sure work Fast Refresh. example: export default function () { return <div>Hello World</div> } Transforms into: export default function MyComponent() { return <div>Hello World</div> } component camel-cased name based name file, also works arrow functions. 8 Transform AMP HOC page config withamp-to-config npx @next/codemod withamp-to-config Transforms withAmp HOC Next.js 9 page configuration. example: // import { withAmp } 'next/amp' function Home() { return <h1>My AMP Page</h1> } export default withAmp(Home) // export default function Home() { return <h1>My AMP Page</h1> } export const config = { amp: true, } 6 Use withRouter url-to-withrouter npx @next/codemod url-to-withrouter Transforms deprecated automatically injected url property top level pages using withRouter router property injects. Read here: https://nextjs.org/docs/messages/url-deprecated example: import React 'react' export default class extends React.Component { render() { const { pathname } = this.props.url return <div>Current pathname: {pathname}</div> } } import React 'react' import { withRouter } 'next/router' export default withRouter( class extends React.Component { render() { const { pathname } = this.props.router return <div>Current pathname: {pathname}</div> } } ) one case. cases transformed (and tested) found __testfixtures__ directory. helpful?"},
{"source": "https://nextjs.org/docs/app/guides/upgrading/version-15", "title": "Upgrading: Version 15 | Next.js", "text": "upgrade version 15 Upgrading 14 15 update Next.js version 15, use upgrade codemod: npx @next/codemod@canary upgrade latest prefer manually, ensure installing latest Next & React versions: npm next@latest react@latest react-dom@latest eslint-config-next@latest Good know: - see peer dependencies warning, may need update react andreact-dom suggested versions, use the--force or--legacy-peer-deps flag ignore warning. necessary Next.js 15 React 19 stable. React 19 - minimum versions react andreact-dom 19. useFormState replaced byuseActionState . TheuseFormState hook still available React 19, deprecated removed future release.useActionState recommended includes additional properties like reading thepending state directly. Learn more.useFormStatus includes additional keys likedata ,method , andaction . using React 19, thepending key available. Learn more.- Read React 19 upgrade guide. Good know: using TypeScript, ensure also upgrade @types/react and@types/react-dom latest versions. Async Request APIs (Breaking change) Previously synchronous Dynamic APIs rely runtime information asynchronous: cookies headers draftMode params inlayout.js ,page.js ,route.js ,default.js ,opengraph-image ,twitter-image ,icon , andapple-icon .searchParams inpage.js ease burden migration, codemod available automate process APIs temporarily accessed synchronously. cookies Recommended Async Usage import { cookies } 'next/headers' // const cookieStore = cookies() const token = cookieStore.get('token') // const cookieStore = await cookies() const token = cookieStore.get('token') Temporary Synchronous Usage import { cookies, type UnsafeUnwrappedCookies } 'next/headers' // const cookieStore = cookies() const token = cookieStore.get('token') // const cookieStore = cookies() unknown UnsafeUnwrappedCookies // log warning dev const token = cookieStore.get('token') headers Recommended Async Usage import { headers } 'next/headers' // const headersList = headers() const userAgent = headersList.get('user-agent') // const headersList = await headers() const userAgent = headersList.get('user-agent') Temporary Synchronous Usage import { headers, type UnsafeUnwrappedHeaders } 'next/headers' // const headersList = headers() const userAgent = headersList.get('user-agent') // const headersList = headers() unknown UnsafeUnwrappedHeaders // log warning dev const userAgent = headersList.get('user-agent') draftMode Recommended Async Usage import { draftMode } 'next/headers' // const { isEnabled } = draftMode() // const { isEnabled } = await draftMode() Temporary Synchronous Usage import { draftMode, type UnsafeUnwrappedDraftMode } 'next/headers' // const { isEnabled } = draftMode() // // log warning dev const { isEnabled } = draftMode() unknown UnsafeUnwrappedDraftMode params & searchParams Asynchronous Layout // type Params = { slug: string } export function generateMetadata({ params }: { params: Params }) { const { slug } = params } export default async function Layout({ children, params, }: { children: React.ReactNode params: Params }) { const { slug } = params } // type Params = Promise<{ slug: string }> export async function generateMetadata({ params }: { params: Params }) { const { slug } = await params } export default async function Layout({ children, params, }: { children: React.ReactNode params: Params }) { const { slug } = await params } Synchronous Layout // type Params = { slug: string } export default function Layout({ children, params, }: { children: React.ReactNode params: Params }) { const { slug } = params } // import { use } 'react' type Params = Promise<{ slug: string }> export default function Layout(props: { children: React.ReactNode params: Params }) { const params = use(props.params) const slug = params.slug } Asynchronous Page // type Params = { slug: string } type SearchParams = { [key: string]: string | string[] | undefined } export function generateMetadata({ params, searchParams, }: { params: Params searchParams: SearchParams }) { const { slug } = params const { query } = searchParams } export default async function Page({ params, searchParams, }: { params: Params searchParams: SearchParams }) { const { slug } = params const { query } = searchParams } // type Params = Promise<{ slug: string }> type SearchParams = Promise<{ [key: string]: string | string[] | undefined }> export async function generateMetadata(props: { params: Params searchParams: SearchParams }) { const params = await props.params const searchParams = await props.searchParams const slug = params.slug const query = searchParams.query } export default async function Page(props: { params: Params searchParams: SearchParams }) { const params = await props.params const searchParams = await props.searchParams const slug = params.slug const query = searchParams.query } Synchronous Page 'use client' // type Params = { slug: string } type SearchParams = { [key: string]: string | string[] | undefined } export default function Page({ params, searchParams, }: { params: Params searchParams: SearchParams }) { const { slug } = params const { query } = searchParams } // import { use } 'react' type Params = Promise<{ slug: string }> type SearchParams = Promise<{ [key: string]: string | string[] | undefined }> export default function Page(props: { params: Params searchParams: SearchParams }) { const params = use(props.params) const searchParams = use(props.searchParams) const slug = params.slug const query = searchParams.query } // export default function Page({ params, searchParams }) { const { slug } = params const { query } = searchParams } // import { use } \"react\" export default function Page(props) { const params = use(props.params) const searchParams = use(props.searchParams) const slug = params.slug const query = searchParams.query } Route Handlers // type Params = { slug: string } export async function GET(request: Request, segmentData: { params: Params }) { const params = segmentData.params const slug = params.slug } // type Params = Promise<{ slug: string }> export async function GET(request: Request, segmentData: { params: Params }) { const params = await segmentData.params const slug = params.slug } // export async function GET(request, segmentData) { const params = segmentData.params const slug = params.slug } // export async function GET(request, segmentData) { const params = await segmentData.params const slug = params.slug } runtime configuration (Breaking change) runtime segment configuration previously supported value experimental-edge addition edge . configurations refer thing, simplify options, error experimental-edge used. fix this, update runtime configuration edge . codemod available automatically this. fetch requests fetch requests longer cached default. opt specific fetch requests caching, pass cache: 'force-cache' option. export default async function RootLayout() { const = await fetch('https://...') // Cached const b = await fetch('https://...', { cache: 'force-cache' }) // Cached // ... } opt fetch requests layout page caching, use export const fetchCache = 'default-cache' segment config option. individual fetch requests specify cache option, used instead. // Since root layout, fetch requests app // set cache option cached. export const fetchCache = 'default-cache' export default async function RootLayout() { const = await fetch('https://...') // Cached const b = await fetch('https://...', { cache: 'no-store' }) // cached // ... } Route Handlers GET functions Route Handlers longer cached default. opt GET methods caching, use route config option export const dynamic = 'force-static' Route Handler file. export const dynamic = 'force-static' export async function GET() {} Client-side Router Cache navigating pages via <Link> useRouter , page segments longer reused client-side router cache. However, still reused browser backward forward navigation shared layouts. opt page segments caching, use staleTimes config option: /** @type {import('next').NextConfig} */ const nextConfig = { experimental: { staleTimes: { dynamic: 30, static: 180, }, }, } module.exports = nextConfig Layouts loading states still cached reused navigation. next/font @next/font package removed favor built-in next/font . codemod available safely automatically rename imports. // import { Inter } '@next/font/google' // import { Inter } 'next/font/google' bundlePagesRouterDependencies experimental.bundlePagesExternals stable renamed bundlePagesRouterDependencies . /** @type {import('next').NextConfig} */ const nextConfig = { // experimental: { bundlePagesExternals: true, }, // bundlePagesRouterDependencies: true, } module.exports = nextConfig serverExternalPackages experimental.serverComponentsExternalPackages stable renamed serverExternalPackages . /** @type {import('next').NextConfig} */ const nextConfig = { // experimental: { serverComponentsExternalPackages: ['package-name'], }, // serverExternalPackages: ['package-name'], } module.exports = nextConfig Speed Insights Auto instrumentation Speed Insights removed Next.js 15. continue using Speed Insights, follow Vercel Speed Insights Quickstart guide. NextRequest Geolocation geo ip properties NextRequest removed values provided hosting provider. codemod available automate migration. using Vercel, alternatively use geolocation ipAddress functions @vercel/functions instead: import { geolocation } '@vercel/functions' import type { NextRequest } 'next/server' export function middleware(request: NextRequest) { const { city } = geolocation(request) // ... } import { ipAddress } '@vercel/functions' import type { NextRequest } 'next/server' export function middleware(request: NextRequest) { const ip = ipAddress(request) // ... } helpful?"},
{"source": "https://nextjs.org/docs/app/guides/videos", "title": "Guides: Videos | Next.js", "text": "use optimize videos page outlines use videos Next.js applications, showing store display video files without affecting performance. Using <video> <iframe> Videos embedded page using HTML <video> tag direct video files <iframe> external platform-hosted videos. <video> HTML <video> tag embed self-hosted directly served video content, allowing full control playback appearance. export function Video() { return ( <video width=\"320\" height=\"240\" controls preload=\"none\"> <source src=\"/path/to/video.mp4\" type=\"video/mp4\" /> <track src=\"/path/to/captions.vtt\" kind=\"subtitles\" srcLang=\"en\" label=\"English\" /> browser support video tag. </video> ) } Common <video> tag attributes | Attribute | Description | Example Value | |---|---|---| src | Specifies source video file. | <video src=\"/path/to/video.mp4\" /> | width | Sets width video player. | <video width=\"320\" /> | height | Sets height video player. | <video height=\"240\" /> | controls | present, displays default set playback controls. | <video controls /> | autoPlay | Automatically starts playing video page loads. Note: Autoplay policies vary across browsers. | <video autoPlay /> | loop | Loops video playback. | <video loop /> | muted | Mutes audio default. Often used autoPlay . | <video muted /> | preload | Specifies video preloaded. Values: none , metadata , auto . | <video preload=\"none\" /> | playsInline | Enables inline playback iOS devices, often necessary autoplay work iOS Safari. | <video playsInline /> | Good know: using autoPlay attribute, important also include themuted attribute ensure video plays automatically browsers theplaysInline attribute compatibility iOS devices. comprehensive list video attributes, refer MDN documentation. Video best practices - Fallback Content: using <video> tag, include fallback content inside tag browsers support video playback. - Subtitles Captions: Include subtitles captions users deaf hard hearing. Utilize <track> tag your<video> elements specify caption file sources. - Accessible Controls: Standard HTML5 video controls recommended keyboard navigation screen reader compatibility. advanced needs, consider third-party players like react-player video.js, offer accessible controls consistent browser experience. <iframe> HTML <iframe> tag allows embed videos external platforms like YouTube Vimeo. export default function Page() { return ( <iframe src=\"https://www.youtube.com/embed/19g66ezsKAg\" allowFullScreen /> ) } Common <iframe> tag attributes | Attribute | Description | Example Value | |---|---|---| src | URL page embed. | <iframe src=\"https://example.com\" /> | width | Sets width iframe. | <iframe width=\"500\" /> | height | Sets height iframe. | <iframe height=\"300\" /> | allowFullScreen | Allows iframe content displayed full-screen mode. | <iframe allowFullScreen /> | sandbox | Enables extra set restrictions content within iframe. | <iframe sandbox /> | loading | Optimize loading behavior (e.g., lazy loading). | <iframe loading=\"lazy\" /> | title | Provides title iframe support accessibility. | <iframe title=\"Description\" /> | comprehensive list iframe attributes, refer MDN documentation. Choosing video embedding method two ways embed videos Next.js application: - Self-hosted direct video files: Embed self-hosted videos using <video> tag scenarios requiring detailed control player's functionality appearance. integration method within Next.js allows customization control video content. - Using video hosting services (YouTube, Vimeo, etc.): video hosting services like YouTube Vimeo, embed iframe-based players using <iframe> tag. method limits control player, offers ease use features provided platforms. Choose embedding method aligns application's requirements user experience aim deliver. Embedding externally hosted videos embed videos external platforms, use Next.js fetch video information React Suspense handle fallback state loading. 1. Create Server Component video embedding first step create Server Component generates appropriate iframe embedding video. component fetch source URL video render iframe. export default async function VideoComponent() { const src = await getVideoSrc() return <iframe src={src} allowFullScreen /> } 2. Stream video component using React Suspense creating Server Component embed video, next step stream component using React Suspense. import { Suspense } 'react' import VideoComponent '../ui/VideoComponent.jsx' export default function Page() { return ( <section> <Suspense fallback={<p>Loading video...</p>}> <VideoComponent /> </Suspense> {/* content page */} </section> ) } Good know: embedding videos external platforms, consider following best practices: - Ensure video embeds responsive. Use CSS make iframe video player adapt different screen sizes. - Implement strategies loading videos based network conditions, especially users limited data plans. approach results better user experience prevents page blocking, meaning user interact page video component streams in. engaging informative loading experience, consider using loading skeleton fallback UI. instead showing simple loading message, show skeleton resembles video player like this: import { Suspense } 'react' import VideoComponent '../ui/VideoComponent.jsx' import VideoSkeleton '../ui/VideoSkeleton.jsx' export default function Page() { return ( <section> <Suspense fallback={<VideoSkeleton />}> <VideoComponent /> </Suspense> {/* content page */} </section> ) } Self-hosted videos Self-hosting videos may preferable several reasons: - Complete control independence: Self-hosting gives direct management video content, playback appearance, ensuring full ownership control, free external platform constraints. - Customization specific needs: Ideal unique requirements, like dynamic background videos, allows tailored customization align design functional needs. - Performance scalability considerations: Choose storage solutions high-performing scalable, support increasing traffic content size effectively. - Cost integration: Balance costs storage bandwidth need easy integration Next.js framework broader tech ecosystem. Using Vercel Blob video hosting Vercel Blob offers efficient way host videos, providing scalable cloud storage solution works well Next.js. Here's host video using Vercel Blob: 1. Uploading video Vercel Blob Vercel dashboard, navigate \"Storage\" tab select Vercel Blob store. Blob table's upper-right corner, find click \"Upload\" button. Then, choose video file wish upload. upload completes, video file appear Blob table. Alternatively, upload video using server action. detailed instructions, refer Vercel documentation server-side uploads. Vercel also supports client-side uploads. method may preferable certain use cases. 2. Displaying video Next.js video uploaded stored, display Next.js application. Here's example using <video> tag React Suspense: import { Suspense } 'react' import { list } '@vercel/blob' export default function Page() { return ( <Suspense fallback={<p>Loading video...</p>}> <VideoComponent fileName=\"my-video.mp4\" /> </Suspense> ) } async function VideoComponent({ fileName }) { const { blobs } = await list({ prefix: fileName, limit: 1, }) const { url } = blobs[0] return ( <video controls preload=\"none\" aria-label=\"Video player\"> <source src={url} type=\"video/mp4\" /> browser support video tag. </video> ) } approach, page uses video's @vercel/blob URL display video using VideoComponent . React Suspense used show fallback video URL fetched video ready displayed. Adding subtitles video subtitles video, easily add using <track> element inside <video> tag. fetch subtitle file Vercel Blob similar way video file. Here's update <VideoComponent> include subtitles. async function VideoComponent({ fileName }) { const { blobs } = await list({ prefix: fileName, limit: 2, }) const { url } = blobs[0] const { url: captionsUrl } = blobs[1] return ( <video controls preload=\"none\" aria-label=\"Video player\"> <source src={url} type=\"video/mp4\" /> <track src={captionsUrl} kind=\"subtitles\" srcLang=\"en\" label=\"English\" /> browser support video tag. </video> ) } following approach, effectively self-host integrate videos Next.js applications. Resources continue learning video optimization best practices, please refer following resources: - Understanding video formats codecs: Choose right format codec, like MP4 compatibility WebM web optimization, video needs. details, see Mozilla's guide video codecs. - Video compression: Use tools like FFmpeg effectively compress videos, balancing quality file size. Learn compression techniques FFmpeg's official website. - Resolution bitrate adjustment: Adjust resolution bitrate based viewing platform, lower settings mobile devices. - Content Delivery Networks (CDNs): Utilize CDN enhance video delivery speed manage high traffic. using storage solutions, Vercel Blob, CDN functionality automatically handled you. Learn CDNs benefits. Explore video streaming platforms integrating video Next.js projects: Open source next-video component - Provides <Video> component Next.js, compatible various hosting services including Vercel Blob, S3, Backblaze, Mux. - Detailed documentation using next-video.dev different hosting services. Cloudinary Integration - Official documentation integration guide using Cloudinary Next.js. - Includes <CldVideoPlayer> component drop-in video support. - Find examples integrating Cloudinary Next.js including Adaptive Bitrate Streaming. - Cloudinary libraries including Node.js SDK also available. Mux Video API - Mux provides starter template creating video course Mux Next.js. - Learn Mux's recommendations embedding high-performance video Next.js application. - Explore example project demonstrating Mux Next.js. Fastly - Learn integrating Fastly's solutions video demand streaming media Next.js. ImageKit.io Integration - Check official quick start guide integrating ImageKit Next.js. - integration provides <IKVideo> component, offering seamless video support. - also explore ImageKit libraries, Node.js SDK, also available. helpful?"}]