[{"source": "https://react.dev/blog/2024/12/05/react-19", "title": "React v19 \u2013 React", "text": "React v19\nDecember 05, 2024 by The React Team\nReact v19 is now available on npm!\nIn our React 19 Upgrade Guide, we shared step-by-step instructions for upgrading your app to React 19. In this post, we\u2019ll give an overview of the new features in React 19, and how you can adopt them.\nFor a list of breaking changes, see the Upgrade Guide.\nWhat\u2019s new in React 19\nActions\nA common use case in React apps is to perform a data mutation and then update state in response. For example, when a user submits a form to change their name, you will make an API request, and then handle the response. In the past, you would need to handle pending states, errors, optimistic updates, and sequential requests manually.\nFor example, you could handle the pending and error state in useState\n:\n// Before Actions\nfunction UpdateName({}) {\nconst [name, setName] = useState(\"\");\nconst [error, setError] = useState(null);\nconst [isPending, setIsPending] = useState(false);\nconst handleSubmit = async () => {\nsetIsPending(true);\nconst error = await updateName(name);\nsetIsPending(false);\nif (error) {\nsetError(error);\nreturn;\n}\nredirect(\"/path\");\n};\nreturn (\n<div>\n<input value={name} onChange={(event) => setName(event.target.value)} />\n<button onClick={handleSubmit} disabled={isPending}>\nUpdate\n</button>\n{error && <p>{error}</p>}\n</div>\n);\n}\nIn React 19, we\u2019re adding support for using async functions in transitions to handle pending states, errors, forms, and optimistic updates automatically.\nFor example, you can use useTransition\nto handle the pending state for you:\n// Using pending state from Actions\nfunction UpdateName({}) {\nconst [name, setName] = useState(\"\");\nconst [error, setError] = useState(null);\nconst [isPending, startTransition] = useTransition();\nconst handleSubmit = () => {\nstartTransition(async () => {\nconst error = await updateName(name);\nif (error) {\nsetError(error);\nreturn;\n}\nredirect(\"/path\");\n})\n};\nreturn (\n<div>\n<input value={name} onChange={(event) => setName(event.target.value)} />\n<button onClick={handleSubmit} disabled={isPending}>\nUpdate\n</button>\n{error && <p>{error}</p>}\n</div>\n);\n}\nThe async transition will immediately set the isPending\nstate to true, make the async request(s), and switch isPending\nto false after any transitions. This allows you to keep the current UI responsive and interactive while the data is changing.\nBuilding on top of Actions, React 19 introduces useOptimistic\nto manage optimistic updates, and a new hook React.useActionState\nto handle common cases for Actions. In react-dom\nwe\u2019re adding <form>\nActions to manage forms automatically and useFormStatus\nto support the common cases for Actions in forms.\nIn React 19, the above example can be simplified to:\n// Using <form> Actions and useActionState\nfunction ChangeName({ name, setName }) {\nconst [error, submitAction, isPending] = useActionState(\nasync (previousState, formData) => {\nconst error = await updateName(formData.get(\"name\"));\nif (error) {\nreturn error;\n}\nredirect(\"/path\");\nreturn null;\n},\nnull,\n);\nreturn (\n<form action={submitAction}>\n<input type=\"text\" name=\"name\" />\n<button type=\"submit\" disabled={isPending}>Update</button>\n{error && <p>{error}</p>}\n</form>\n);\n}\nIn the next section, we\u2019ll break down each of the new Action features in React 19.\nNew hook: useActionState\nTo make the common cases easier for Actions, we\u2019ve added a new hook called useActionState\n:\nconst [error, submitAction, isPending] = useActionState(\nasync (previousState, newName) => {\nconst error = await updateName(newName);\nif (error) {\n// You can return any result of the action.\n// Here, we return only the error.\nreturn error;\n}\n// handle success\nreturn null;\n},\nnull,\n);\nuseActionState\naccepts a function (the \u201cAction\u201d), and returns a wrapped Action to call. This works because Actions compose. When the wrapped Action is called, useActionState\nwill return the last result of the Action as data\n, and the pending state of the Action as pending\n.\nFor more information, see the docs for useActionState\n.\nReact DOM: <form>\nActions\nActions are also integrated with React 19\u2019s new <form>\nfeatures for react-dom\n. We\u2019ve added support for passing functions as the action\nand formAction\nprops of <form>\n, <input>\n, and <button>\nelements to automatically submit forms with Actions:\n<form action={actionFunction}>\nWhen a <form>\nAction succeeds, React will automatically reset the form for uncontrolled components. If you need to reset the <form>\nmanually, you can call the new requestFormReset\nReact DOM API.\nFor more information, see the react-dom\ndocs for <form>\n, <input>\n, and <button>\n.\nReact DOM: New hook: useFormStatus\nIn design systems, it\u2019s common to write design components that need access to information about the <form>\nthey\u2019re in, without drilling props down to the component. This can be done via Context, but to make the common case easier, we\u2019ve added a new hook useFormStatus\n:\nimport {useFormStatus} from 'react-dom';\nfunction DesignButton() {\nconst {pending} = useFormStatus();\nreturn <button type=\"submit\" disabled={pending} />\n}\nuseFormStatus\nreads the status of the parent <form>\nas if the form was a Context provider.\nFor more information, see the react-dom\ndocs for useFormStatus\n.\nNew hook: useOptimistic\nAnother common UI pattern when performing a data mutation is to show the final state optimistically while the async request is underway. In React 19, we\u2019re adding a new hook called useOptimistic\nto make this easier:\nfunction ChangeName({currentName, onUpdateName}) {\nconst [optimisticName, setOptimisticName] = useOptimistic(currentName);\nconst submitAction = async formData => {\nconst newName = formData.get(\"name\");\nsetOptimisticName(newName);\nconst updatedName = await updateName(newName);\nonUpdateName(updatedName);\n};\nreturn (\n<form action={submitAction}>\n<p>Your name is: {optimisticName}</p>\n<p>\n<label>Change Name:</label>\n<input\ntype=\"text\"\nname=\"name\"\ndisabled={currentName !== optimisticName}\n/>\n</p>\n</form>\n);\n}\nThe useOptimistic\nhook will immediately render the optimisticName\nwhile the updateName\nrequest is in progress. When the update finishes or errors, React will automatically switch back to the currentName\nvalue.\nFor more information, see the docs for useOptimistic\n.\nNew API: use\nIn React 19 we\u2019re introducing a new API to read resources in render: use\n.\nFor example, you can read a promise with use\n, and React will Suspend until the promise resolves:\nimport {use} from 'react';\nfunction Comments({commentsPromise}) {\n// `use` will suspend until the promise resolves.\nconst comments = use(commentsPromise);\nreturn comments.map(comment => <p key={comment.id}>{comment}</p>);\n}\nfunction Page({commentsPromise}) {\n// When `use` suspends in Comments,\n// this Suspense boundary will be shown.\nreturn (\n<Suspense fallback={<div>Loading...</div>}>\n<Comments commentsPromise={commentsPromise} />\n</Suspense>\n)\n}\nYou can also read context with use\n, allowing you to read Context conditionally such as after early returns:\nimport {use} from 'react';\nimport ThemeContext from './ThemeContext'\nfunction Heading({children}) {\nif (children == null) {\nreturn null;\n}\n// This would not work with useContext\n// because of the early return.\nconst theme = use(ThemeContext);\nreturn (\n<h1 style={{color: theme.color}}>\n{children}\n</h1>\n);\n}\nThe use\nAPI can only be called in render, similar to hooks. Unlike hooks, use\ncan be called conditionally. In the future we plan to support more ways to consume resources in render with use\n.\nFor more information, see the docs for use\n.\nNew React DOM Static APIs\nWe\u2019ve added two new APIs to react-dom/static\nfor static site generation:\nThese new APIs improve on renderToString\nby waiting for data to load for static HTML generation. They are designed to work with streaming environments like Node.js Streams and Web Streams. For example, in a Web Stream environment, you can prerender a React tree to static HTML with prerender\n:\nimport { prerender } from 'react-dom/static';\nasync function handler(request) {\nconst {prelude} = await prerender(<App />, {\nbootstrapScripts: ['/main.js']\n});\nreturn new Response(prelude, {\nheaders: { 'content-type': 'text/html' },\n});\n}\nPrerender APIs will wait for all data to load before returning the static HTML stream. Streams can be converted to strings, or sent with a streaming response. They do not support streaming content as it loads, which is supported by the existing React DOM server rendering APIs.\nFor more information, see React DOM Static APIs.\nReact Server Components\nServer Components\nServer Components are a new option that allows rendering components ahead of time, before bundling, in an environment separate from your client application or SSR server. This separate environment is the \u201cserver\u201d in React Server Components. Server Components can run once at build time on your CI server, or they can be run for each request using a web server.\nReact 19 includes all of the React Server Components features included from the Canary channel. This means libraries that ship with Server Components can now target React 19 as a peer dependency with a react-server\nexport condition for use in frameworks that support the Full-stack React Architecture.\nFor more, see the docs for React Server Components.\nServer Actions\nServer Actions allow Client Components to call async functions executed on the server.\nWhen a Server Action is defined with the \"use server\"\ndirective, your framework will automatically create a reference to the server function, and pass that reference to the Client Component. When that function is called on the client, React will send a request to the server to execute the function, and return the result.\nServer Actions can be created in Server Components and passed as props to Client Components, or they can be imported and used in Client Components.\nFor more, see the docs for React Server Actions.\nImprovements in React 19\nref\nas a prop\nStarting in React 19, you can now access ref\nas a prop for function components:\nfunction MyInput({placeholder, ref}) {\nreturn <input placeholder={placeholder} ref={ref} />\n}\n//...\n<MyInput ref={ref} />\nNew function components will no longer need forwardRef\n, and we will be publishing a codemod to automatically update your components to use the new ref\nprop. In future versions we will deprecate and remove forwardRef\n.\nDiffs for hydration errors\nWe also improved error reporting for hydration errors in react-dom\n. For example, instead of logging multiple errors in DEV without any information about the mismatch:\nWe now log a single message with a diff of the mismatch:\nif (typeof window !== 'undefined')\n.\n- Variable input such as Date.now()\nor Math.random()\nwhich changes each time it\u2019s called.\n- Date formatting in a user\u2019s locale which doesn\u2019t match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\nhttps://react.dev/link/hydration-mismatch\n<App>\n<span>\n+ Client\n- Server\nat throwOnHydrationMismatch\n\u2026<Context>\nas a provider\nIn React 19, you can render <Context>\nas a provider instead of <Context.Provider>\n:\nconst ThemeContext = createContext('');\nfunction App({children}) {\nreturn (\n<ThemeContext value=\"dark\">\n{children}\n</ThemeContext>\n);\n}\nNew Context providers can use <Context>\nand we will be publishing a codemod to convert existing providers. In future versions we will deprecate <Context.Provider>\n.\nCleanup functions for refs\nWe now support returning a cleanup function from ref\ncallbacks:\n<input\nref={(ref) => {\n// ref created\n// NEW: return a cleanup function to reset\n// the ref when element is removed from DOM.\nreturn () => {\n// ref cleanup\n};\n}}\n/>\nWhen the component unmounts, React will call the cleanup function returned from the ref\ncallback. This works for DOM refs, refs to class components, and useImperativeHandle\n.\nDue to the introduction of ref cleanup functions, returning anything else from a ref\ncallback will now be rejected by TypeScript. The fix is usually to stop using implicit returns, for example:\n- <div ref={current => (instance = current)} />\n+ <div ref={current => {instance = current}} />\nThe original code returned the instance of the HTMLDivElement\nand TypeScript wouldn\u2019t know if this was supposed to be a cleanup function or if you didn\u2019t want to return a cleanup function.\nYou can codemod this pattern with no-implicit-ref-callback-return\n.\nuseDeferredValue\ninitial value\nWe\u2019ve added an initialValue\noption to useDeferredValue\n:\nfunction Search({deferredValue}) {\n// On initial render the value is ''.\n// Then a re-render is scheduled with the deferredValue.\nconst value = useDeferredValue(deferredValue, '');\nreturn (\n<Results query={value} />\n);\n}\nWhen initialValue is provided, useDeferredValue\nwill return it as value\nfor the initial render of the component, and schedules a re-render in the background with the deferredValue returned.\nFor more, see useDeferredValue\n.\nSupport for Document Metadata\nIn HTML, document metadata tags like <title>\n, <link>\n, and <meta>\nare reserved for placement in the <head>\nsection of the document. In React, the component that decides what metadata is appropriate for the app may be very far from the place where you render the <head>\nor React does not render the <head>\nat all. In the past, these elements would need to be inserted manually in an effect, or by libraries like react-helmet\n, and required careful handling when server rendering a React application.\nIn React 19, we\u2019re adding support for rendering document metadata tags in components natively:\nfunction BlogPost({post}) {\nreturn (\n<article>\n<h1>{post.title}</h1>\n<title>{post.title}</title>\n<meta name=\"author\" content=\"Josh\" />\n<link rel=\"author\" href=\"https://twitter.com/joshcstory/\" />\n<meta name=\"keywords\" content={post.keywords} />\n<p>\nEee equals em-see-squared...\n</p>\n</article>\n);\n}\nWhen React renders this component, it will see the <title>\n<link>\nand <meta>\ntags, and automatically hoist them to the <head>\nsection of document. By supporting these metadata tags natively, we\u2019re able to ensure they work with client-only apps, streaming SSR, and Server Components.\nFor more info, see the docs for <title>\n, <link>\n, and <meta>\n.\nSupport for stylesheets\nStylesheets, both externally linked (<link rel=\"stylesheet\" href=\"...\">\n) and inline (<style>...</style>\n), require careful positioning in the DOM due to style precedence rules. Building a stylesheet capability that allows for composability within components is hard, so users often end up either loading all of their styles far from the components that may depend on them, or they use a style library which encapsulates this complexity.\nIn React 19, we\u2019re addressing this complexity and providing even deeper integration into Concurrent Rendering on the Client and Streaming Rendering on the Server with built in support for stylesheets. If you tell React the precedence\nof your stylesheet it will manage the insertion order of the stylesheet in the DOM and ensure that the stylesheet (if external) is loaded before revealing content that depends on those style rules.\nfunction ComponentOne() {\nreturn (\n<Suspense fallback=\"loading...\">\n<link rel=\"stylesheet\" href=\"foo\" precedence=\"default\" />\n<link rel=\"stylesheet\" href=\"bar\" precedence=\"high\" />\n<article class=\"foo-class bar-class\">\n{...}\n</article>\n</Suspense>\n)\n}\nfunction ComponentTwo() {\nreturn (\n<div>\n<p>{...}</p>\n<link rel=\"stylesheet\" href=\"baz\" precedence=\"default\" /> <-- will be inserted between foo & bar\n</div>\n)\n}\nDuring Server Side Rendering React will include the stylesheet in the <head>\n, which ensures that the browser will not paint until it has loaded. If the stylesheet is discovered late after we\u2019ve already started streaming, React will ensure that the stylesheet is inserted into the <head>\non the client before revealing the content of a Suspense boundary that depends on that stylesheet.\nDuring Client Side Rendering React will wait for newly rendered stylesheets to load before committing the render. If you render this component from multiple places within your application React will only include the stylesheet once in the document:\nfunction App() {\nreturn <>\n<ComponentOne />\n...\n<ComponentOne /> // won't lead to a duplicate stylesheet link in the DOM\n</>\n}\nFor users accustomed to loading stylesheets manually this is an opportunity to locate those stylesheets alongside the components that depend on them allowing for better local reasoning and an easier time ensuring you only load the stylesheets that you actually depend on.\nStyle libraries and style integrations with bundlers can also adopt this new capability so even if you don\u2019t directly render your own stylesheets, you can still benefit as your tools are upgraded to use this feature.\nFor more details, read the docs for <link>\nand <style>\n.\nSupport for async scripts\nIn HTML normal scripts (<script src=\"...\">\n) and deferred scripts (<script defer=\"\" src=\"...\">\n) load in document order which makes rendering these kinds of scripts deep within your component tree challenging. Async scripts (<script async=\"\" src=\"...\">\n) however will load in arbitrary order.\nIn React 19 we\u2019ve included better support for async scripts by allowing you to render them anywhere in your component tree, inside the components that actually depend on the script, without having to manage relocating and deduplicating script instances.\nfunction MyComponent() {\nreturn (\n<div>\n<script async={true} src=\"...\" />\nHello World\n</div>\n)\n}\nfunction App() {\n<html>\n<body>\n<MyComponent>\n...\n<MyComponent> // won't lead to duplicate script in the DOM\n</body>\n</html>\n}\nIn all rendering environments, async scripts will be deduplicated so that React will only load and execute the script once even if it is rendered by multiple different components.\nIn Server Side Rendering, async scripts will be included in the <head>\nand prioritized behind more critical resources that block paint such as stylesheets, fonts, and image preloads.\nFor more details, read the docs for <script>\n.\nSupport for preloading resources\nDuring initial document load and on client side updates, telling the Browser about resources that it will likely need to load as early as possible can have a dramatic effect on page performance.\nReact 19 includes a number of new APIs for loading and preloading Browser resources to make it as easy as possible to build great experiences that aren\u2019t held back by inefficient resource loading.\nimport { prefetchDNS, preconnect, preload, preinit } from 'react-dom'\nfunction MyComponent() {\npreinit('https://.../path/to/some/script.js', {as: 'script' }) // loads and executes this script eagerly\npreload('https://.../path/to/font.woff', { as: 'font' }) // preloads this font\npreload('https://.../path/to/stylesheet.css', { as: 'style' }) // preloads this stylesheet\nprefetchDNS('https://...') // when you may not actually request anything from this host\npreconnect('https://...') // when you will request something but aren't sure what\n}\n<!-- the above would result in the following DOM/HTML -->\n<html>\n<head>\n<!-- links/scripts are prioritized by their utility to early loading, not call order -->\n<link rel=\"prefetch-dns\" href=\"https://...\">\n<link rel=\"preconnect\" href=\"https://...\">\n<link rel=\"preload\" as=\"font\" href=\"https://.../path/to/font.woff\">\n<link rel=\"preload\" as=\"style\" href=\"https://.../path/to/stylesheet.css\">\n<script async=\"\" src=\"https://.../path/to/some/script.js\"></script>\n</head>\n<body>\n...\n</body>\n</html>\nThese APIs can be used to optimize initial page loads by moving discovery of additional resources like fonts out of stylesheet loading. They can also make client updates faster by prefetching a list of resources used by an anticipated navigation and then eagerly preloading those resources on click or even on hover.\nFor more details see Resource Preloading APIs.\nCompatibility with third-party scripts and extensions\nWe\u2019ve improved hydration to account for third-party scripts and browser extensions.\nWhen hydrating, if an element that renders on the client doesn\u2019t match the element found in the HTML from the server, React will force a client re-render to fix up the content. Previously, if an element was inserted by third-party scripts or browser extensions, it would trigger a mismatch error and client render.\nIn React 19, unexpected tags in the <head>\nand <body>\nwill be skipped over, avoiding the mismatch errors. If React needs to re-render the entire document due to an unrelated hydration mismatch, it will leave in place stylesheets inserted by third-party scripts and browser extensions.\nBetter error reporting\nWe improved error handling in React 19 to remove duplication and provide options for handling caught and uncaught errors. For example, when there\u2019s an error in render caught by an Error Boundary, previously React would throw the error twice (once for the original error, then again after failing to automatically recover), and then call console.error\nwith info about where the error occurred.\nThis resulted in three errors for every caught error:\nIn React 19, we log a single error with all the error information included:\nAdditionally, we\u2019ve added two new root options to complement onRecoverableError\n:\nonCaughtError\n: called when React catches an error in an Error Boundary.onUncaughtError\n: called when an error is thrown and not caught by an Error Boundary.onRecoverableError\n: called when an error is thrown and automatically recovered.\nFor more info and examples, see the docs for createRoot\nand hydrateRoot\n.\nSupport for Custom Elements\nReact 19 adds full support for custom elements and passes all tests on Custom Elements Everywhere.\nIn past versions, using Custom Elements in React has been difficult because React treated unrecognized props as attributes rather than properties. In React 19, we\u2019ve added support for properties that works on the client and during SSR with the following strategy:\n- Server Side Rendering: props passed to a custom element will render as attributes if their type is a primitive value like\nstring\n,number\n, or the value istrue\n. Props with non-primitive types likeobject\n,symbol\n,function\n, or valuefalse\nwill be omitted. - Client Side Rendering: props that match a property on the Custom Element instance will be assigned as properties, otherwise they will be assigned as attributes.\nThanks to Joey Arhar for driving the design and implementation of Custom Element support in React.\nHow to upgrade\nSee the React 19 Upgrade Guide for step-by-step instructions and a full list of breaking and notable changes.\nNote: this post was originally published 04/25/2024 and has been updated to 12/05/2024 with the stable release."},
{"source": "https://react.dev/blog/2024/04/25/react-19-upgrade-guide", "title": "React 19 Upgrade Guide \u2013 React", "text": "React 19 Upgrade Guide\nApril 25, 2024 by Ricky Hanlon\nThe improvements added to React 19 require some breaking changes, but we\u2019ve worked to make the upgrade as smooth as possible, and we don\u2019t expect the changes to impact most apps.\nIn this post, we will guide you through the steps for upgrading to React 19:\nIf you\u2019d like to help us test React 19, follow the steps in this upgrade guide and report any issues you encounter. For a list of new features added to React 19, see the React 19 release post.\nInstalling\nTo install the latest version of React and React DOM:\nnpm install --save-exact react@^19.0.0 react-dom@^19.0.0\nOr, if you\u2019re using Yarn:\nyarn add --exact react@^19.0.0 react-dom@^19.0.0\nIf you\u2019re using TypeScript, you also need to update the types.\nnpm install --save-exact @types/react@^19.0.0 @types/react-dom@^19.0.0\nOr, if you\u2019re using Yarn:\nyarn add --exact @types/react@^19.0.0 @types/react-dom@^19.0.0\nWe\u2019re also including a codemod for the most common replacements. See TypeScript changes below.\nCodemods\nTo help with the upgrade, we\u2019ve worked with the team at codemod.com to publish codemods that will automatically update your code to many of the new APIs and patterns in React 19.\nAll codemods are available in the react-codemod\nrepo and the Codemod team have joined in helping maintain the codemods. To run these codemods, we recommend using the codemod\ncommand instead of the react-codemod\nbecause it runs faster, handles more complex code migrations, and provides better support for TypeScript.\nChanges that include a codemod include the command below.\nFor a list of all available codemods, see the react-codemod\nrepo.\nBreaking changes\nErrors in render are not re-thrown\nIn previous versions of React, errors thrown during render were caught and rethrown. In DEV, we would also log to console.error\n, resulting in duplicate error logs.\nIn React 19, we\u2019ve improved how errors are handled to reduce duplication by not re-throwing:\n- Uncaught Errors: Errors that are not caught by an Error Boundary are reported to\nwindow.reportError\n. - Caught Errors: Errors that are caught by an Error Boundary are reported to\nconsole.error\n.\nThis change should not impact most apps, but if your production error reporting relies on errors being re-thrown, you may need to update your error handling. To support this, we\u2019ve added new methods to createRoot\nand hydrateRoot\nfor custom error handling:\nconst root = createRoot(container, {\nonUncaughtError: (error, errorInfo) => {\n// ... log error report\n},\nonCaughtError: (error, errorInfo) => {\n// ... log error report\n}\n});\nFor more info, see the docs for createRoot\nand hydrateRoot\n.\nRemoved deprecated React APIs\nRemoved: propTypes\nand defaultProps\nfor functions\nPropTypes\nwere deprecated in April 2017 (v15.5.0).\nIn React 19, we\u2019re removing the propType\nchecks from the React package, and using them will be silently ignored. If you\u2019re using propTypes\n, we recommend migrating to TypeScript or another type-checking solution.\nWe\u2019re also removing defaultProps\nfrom function components in place of ES6 default parameters. Class components will continue to support defaultProps\nsince there is no ES6 alternative.\n// Before\nimport PropTypes from 'prop-types';\nfunction Heading({text}) {\nreturn <h1>{text}</h1>;\n}\nHeading.propTypes = {\ntext: PropTypes.string,\n};\nHeading.defaultProps = {\ntext: 'Hello, world!',\n};\n// After\ninterface Props {\ntext?: string;\n}\nfunction Heading({text = 'Hello, world!'}: Props) {\nreturn <h1>{text}</h1>;\n}\nRemoved: Legacy Context using contextTypes\nand getChildContext\nLegacy Context was deprecated in October 2018 (v16.6.0).\nLegacy Context was only available in class components using the APIs contextTypes\nand getChildContext\n, and was replaced with contextType\ndue to subtle bugs that were easy to miss. In React 19, we\u2019re removing Legacy Context to make React slightly smaller and faster.\nIf you\u2019re still using Legacy Context in class components, you\u2019ll need to migrate to the new contextType\nAPI:\n// Before\nimport PropTypes from 'prop-types';\nclass Parent extends React.Component {\nstatic childContextTypes = {\nfoo: PropTypes.string.isRequired,\n};\ngetChildContext() {\nreturn { foo: 'bar' };\n}\nrender() {\nreturn <Child />;\n}\n}\nclass Child extends React.Component {\nstatic contextTypes = {\nfoo: PropTypes.string.isRequired,\n};\nrender() {\nreturn <div>{this.context.foo}</div>;\n}\n}\n// After\nconst FooContext = React.createContext();\nclass Parent extends React.Component {\nrender() {\nreturn (\n<FooContext value='bar'>\n<Child />\n</FooContext>\n);\n}\n}\nclass Child extends React.Component {\nstatic contextType = FooContext;\nrender() {\nreturn <div>{this.context}</div>;\n}\n}\nRemoved: string refs\nString refs were deprecated in March, 2018 (v16.3.0).\nClass components supported string refs before being replaced by ref callbacks due to multiple downsides. In React 19, we\u2019re removing string refs to make React simpler and easier to understand.\nIf you\u2019re still using string refs in class components, you\u2019ll need to migrate to ref callbacks:\n// Before\nclass MyComponent extends React.Component {\ncomponentDidMount() {\nthis.refs.input.focus();\n}\nrender() {\nreturn <input ref='input' />;\n}\n}\n// After\nclass MyComponent extends React.Component {\ncomponentDidMount() {\nthis.input.focus();\n}\nrender() {\nreturn <input ref={input => this.input = input} />;\n}\n}\nRemoved: Module pattern factories\nModule pattern factories were deprecated in August 2019 (v16.9.0).\nThis pattern was rarely used and supporting it causes React to be slightly larger and slower than necessary. In React 19, we\u2019re removing support for module pattern factories, and you\u2019ll need to migrate to regular functions:\n// Before\nfunction FactoryComponent() {\nreturn { render() { return <div />; } }\n}\n// After\nfunction FactoryComponent() {\nreturn <div />;\n}\nRemoved: React.createFactory\ncreateFactory\nwas deprecated in February 2020 (v16.13.0).\nUsing createFactory\nwas common before broad support for JSX, but it\u2019s rarely used today and can be replaced with JSX. In React 19, we\u2019re removing createFactory\nand you\u2019ll need to migrate to JSX:\n// Before\nimport { createFactory } from 'react';\nconst button = createFactory('button');\n// After\nconst button = <button />;\nRemoved: react-test-renderer/shallow\nIn React 18, we updated react-test-renderer/shallow\nto re-export react-shallow-renderer. In React 19, we\u2019re removing react-test-render/shallow\nto prefer installing the package directly:\nnpm install react-shallow-renderer --save-dev\n- import ShallowRenderer from 'react-test-renderer/shallow';\n+ import ShallowRenderer from 'react-shallow-renderer';\nRemoved deprecated React DOM APIs\nRemoved: react-dom/test-utils\nWe\u2019ve moved act\nfrom react-dom/test-utils\nto the react\npackage:\nReactDOMTestUtils.act\nis deprecated in favor of React.act\n. Import act\nfrom react\ninstead of react-dom/test-utils\n. See https://react.dev/warnings/react-dom-test-utils for more info.To fix this warning, you can import act\nfrom react\n:\n- import {act} from 'react-dom/test-utils'\n+ import {act} from 'react';\nAll other test-utils\nfunctions have been removed. These utilities were uncommon, and made it too easy to depend on low level implementation details of your components and React. In React 19, these functions will error when called and their exports will be removed in a future version.\nSee the warning page for alternatives.\nRemoved: ReactDOM.render\nReactDOM.render\nwas deprecated in March 2022 (v18.0.0). In React 19, we\u2019re removing ReactDOM.render\nand you\u2019ll need to migrate to using ReactDOM.createRoot\n:\n// Before\nimport {render} from 'react-dom';\nrender(<App />, document.getElementById('root'));\n// After\nimport {createRoot} from 'react-dom/client';\nconst root = createRoot(document.getElementById('root'));\nroot.render(<App />);\nRemoved: ReactDOM.hydrate\nReactDOM.hydrate\nwas deprecated in March 2022 (v18.0.0). In React 19, we\u2019re removing ReactDOM.hydrate\nyou\u2019ll need to migrate to using ReactDOM.hydrateRoot\n,\n// Before\nimport {hydrate} from 'react-dom';\nhydrate(<App />, document.getElementById('root'));\n// After\nimport {hydrateRoot} from 'react-dom/client';\nhydrateRoot(document.getElementById('root'), <App />);\nRemoved: unmountComponentAtNode\nReactDOM.unmountComponentAtNode\nwas deprecated in March 2022 (v18.0.0). In React 19, you\u2019ll need to migrate to using root.unmount()\n.\n// Before\nunmountComponentAtNode(document.getElementById('root'));\n// After\nroot.unmount();\nFor more see root.unmount()\nfor createRoot\nand hydrateRoot\n.\nRemoved: ReactDOM.findDOMNode\nReactDOM.findDOMNode\nwas deprecated in October 2018 (v16.6.0).\nWe\u2019re removing findDOMNode\nbecause it was a legacy escape hatch that was slow to execute, fragile to refactoring, only returned the first child, and broke abstraction levels (see more here). You can replace ReactDOM.findDOMNode\nwith DOM refs:\n// Before\nimport {findDOMNode} from 'react-dom';\nfunction AutoselectingInput() {\nuseEffect(() => {\nconst input = findDOMNode(this);\ninput.select()\n}, []);\nreturn <input defaultValue=\"Hello\" />;\n}\n// After\nfunction AutoselectingInput() {\nconst ref = useRef(null);\nuseEffect(() => {\nref.current.select();\n}, []);\nreturn <input ref={ref} defaultValue=\"Hello\" />\n}\nNew deprecations\nDeprecated: element.ref\nReact 19 supports ref\nas a prop, so we\u2019re deprecating the element.ref\nin place of element.props.ref\n.\nAccessing element.ref\nwill warn:\nDeprecated: react-test-renderer\nWe are deprecating react-test-renderer\nbecause it implements its own renderer environment that doesn\u2019t match the environment users use, promotes testing implementation details, and relies on introspection of React\u2019s internals.\nThe test renderer was created before there were more viable testing strategies available like React Testing Library, and we now recommend using a modern testing library instead.\nIn React 19, react-test-renderer\nlogs a deprecation warning, and has switched to concurrent rendering. We recommend migrating your tests to @testing-library/react or @testing-library/react-native for a modern and well supported testing experience.\nNotable changes\nStrictMode changes\nReact 19 includes several fixes and improvements to Strict Mode.\nWhen double rendering in Strict Mode in development, useMemo\nand useCallback\nwill reuse the memoized results from the first render during the second render. Components that are already Strict Mode compatible should not notice a difference in behavior.\nAs with all Strict Mode behaviors, these features are designed to proactively surface bugs in your components during development so you can fix them before they are shipped to production. For example, during development, Strict Mode will double-invoke ref callback functions on initial mount, to simulate what happens when a mounted component is replaced by a Suspense fallback.\nImprovements to Suspense\nIn React 19, when a component suspends, React will immediately commit the fallback of the nearest Suspense boundary without waiting for the entire sibling tree to render. After the fallback commits, React schedules another render for the suspended siblings to \u201cpre-warm\u201d lazy requests in the rest of the tree:\nThis change means Suspense fallbacks display faster, while still warming lazy requests in the suspended tree.\nUMD builds removed\nUMD was widely used in the past as a convenient way to load React without a build step. Now, there are modern alternatives for loading modules as scripts in HTML documents. Starting with React 19, React will no longer produce UMD builds to reduce the complexity of its testing and release process.\nTo load React 19 with a script tag, we recommend using an ESM-based CDN such as esm.sh.\n<script type=\"module\">\nimport React from \"https://esm.sh/react@19/?dev\"\nimport ReactDOMClient from \"https://esm.sh/react-dom@19/client?dev\"\n...\n</script>\nLibraries depending on React internals may block upgrades\nThis release includes changes to React internals that may impact libraries that ignore our pleas to not use internals like SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n. These changes are necessary to land improvements in React 19, and will not break libraries that follow our guidelines.\nBased on our Versioning Policy, these updates are not listed as breaking changes, and we are not including docs for how to upgrade them. The recommendation is to remove any code that depends on internals.\nTo reflect the impact of using internals, we have renamed the SECRET_INTERNALS\nsuffix to:\n_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE\nIn the future we will more aggressively block accessing internals from React to discourage usage and ensure users are not blocked from upgrading.\nTypeScript changes\nRemoved deprecated TypeScript types\nWe\u2019ve cleaned up the TypeScript types based on the removed APIs in React 19. Some of the removed have types been moved to more relevant packages, and others are no longer needed to describe React\u2019s behavior.\nCheck out types-react-codemod\nfor a list of supported replacements. If you feel a codemod is missing, it can be tracked in the list of missing React 19 codemods.\nref\ncleanups required\nThis change is included in the react-19\ncodemod preset as no-implicit-ref-callback-return\n.\nDue to the introduction of ref cleanup functions, returning anything else from a ref callback will now be rejected by TypeScript. The fix is usually to stop using implicit returns:\n- <div ref={current => (instance = current)} />\n+ <div ref={current => {instance = current}} />\nThe original code returned the instance of the HTMLDivElement\nand TypeScript wouldn\u2019t know if this was supposed to be a cleanup function or not.\nuseRef\nrequires an argument\nThis change is included in the react-19\ncodemod preset as refobject-defaults\n.\nA long-time complaint of how TypeScript and React work has been useRef\n. We\u2019ve changed the types so that useRef\nnow requires an argument. This significantly simplifies its type signature. It\u2019ll now behave more like createContext\n.\n// @ts-expect-error: Expected 1 argument but saw none\nuseRef();\n// Passes\nuseRef(undefined);\n// @ts-expect-error: Expected 1 argument but saw none\ncreateContext();\n// Passes\ncreateContext(undefined);\nThis now also means that all refs are mutable. You\u2019ll no longer hit the issue where you can\u2019t mutate a ref because you initialised it with null\n:\nconst ref = useRef<number>(null);\n// Cannot assign to 'current' because it is a read-only property\nref.current = 1;\nMutableRef\nis now deprecated in favor of a single RefObject\ntype which useRef\nwill always return:\ninterface RefObject<T> {\ncurrent: T\n}\ndeclare function useRef<T>: RefObject<T>\nuseRef\nstill has a convenience overload for useRef<T>(null)\nthat automatically returns RefObject<T | null>\n. To ease migration due to the required argument for useRef\n, a convenience overload for useRef(undefined)\nwas added that automatically returns RefObject<T | undefined>\n.\nCheck out [RFC] Make all refs mutable for prior discussions about this change.\nChanges to the ReactElement\nTypeScript type\nThis change is included in the react-element-default-any-props\ncodemod.\nThe props\nof React elements now default to unknown\ninstead of any\nif the element is typed as ReactElement\n. This does not affect you if you pass a type argument to ReactElement\n:\ntype Example2 = ReactElement<{ id: string }>[\"props\"];\n// ^? { id: string }\nBut if you relied on the default, you now have to handle unknown\n:\ntype Example = ReactElement[\"props\"];\n// ^? Before, was 'any', now 'unknown'\nYou should only need it if you have a lot of legacy code relying on unsound access of element props. Element introspection only exists as an escape hatch, and you should make it explicit that your props access is unsound via an explicit any\n.\nThe JSX namespace in TypeScript\nThis change is included in the react-19\ncodemod preset as scoped-jsx\nA long-time request is to remove the global JSX\nnamespace from our types in favor of React.JSX\n. This helps prevent pollution of global types which prevents conflicts between different UI libraries that leverage JSX.\nYou\u2019ll now need to wrap module augmentation of the JSX namespace in `declare module \u201d\u2026\u201d:\n// global.d.ts\n+ declare module \"react\" {\nnamespace JSX {\ninterface IntrinsicElements {\n\"my-element\": {\nmyElementProps: string;\n};\n}\n}\n+ }\nThe exact module specifier depends on the JSX runtime you specified in the compilerOptions\nof your tsconfig.json\n:\n- For\n\"jsx\": \"react-jsx\"\nit would bereact/jsx-runtime\n. - For\n\"jsx\": \"react-jsxdev\"\nit would bereact/jsx-dev-runtime\n. - For\n\"jsx\": \"react\"\nand\"jsx\": \"preserve\"\nit would bereact\n.\nBetter useReducer\ntypings\nuseReducer\nnow has improved type inference thanks to @mfp22.\nHowever, this required a breaking change where useReducer\ndoesn\u2019t accept the full reducer type as a type parameter but instead either needs none (and rely on contextual typing) or needs both the state and action type.\nThe new best practice is not to pass type arguments to useReducer\n.\n- useReducer<React.Reducer<State, Action>>(reducer)\n+ useReducer(reducer)\nThis may not work in edge cases where you can explicitly type the state and action, by passing in the Action\nin a tuple:\n- useReducer<React.Reducer<State, Action>>(reducer)\n+ useReducer<State, [Action]>(reducer)\nIf you define the reducer inline, we encourage to annotate the function parameters instead:\n- useReducer<React.Reducer<State, Action>>((state, action) => state)\n+ useReducer((state: State, action: Action) => state)\nThis is also what you\u2019d also have to do if you move the reducer outside of the useReducer\ncall:\nconst reducer = (state: State, action: Action) => state;\nChangelog\nOther breaking changes\n- react-dom: Error for javascript URLs in\nsrc\nandhref\n#26507 - react-dom: Remove\nerrorInfo.digest\nfromonRecoverableError\n#28222 - react-dom: Remove\nunstable_flushControlled\n#26397 - react-dom: Remove\nunstable_createEventHandle\n#28271 - react-dom: Remove\nunstable_renderSubtreeIntoContainer\n#28271 - react-dom: Remove\nunstable_runWithPriority\n#28271 - react-is: Remove deprecated methods from\nreact-is\n28224\nOther notable changes\n- react: Batch sync, default and continuous lanes #25700\n- react: Don\u2019t prerender siblings of suspended component #26380\n- react: Detect infinite update loops caused by render phase updates #26625\n- react-dom: Transitions in popstate are now synchronous #26025\n- react-dom: Remove layout effect warning during SSR #26395\n- react-dom: Warn and don\u2019t set empty string for src/href (except anchor tags) #28124\nFor a full list of changes, please see the Changelog.\nThanks to Andrew Clark, Eli White, Jack Pope, Jan Kassens, Josh Story, Matt Carroll, Noah Lemen, Sophie Alpert, and Sebastian Silbermann for reviewing and editing this post."},
{"source": "https://react.dev/blog/2024/05/22/react-conf-2024-recap", "title": "React Conf 2024 Recap \u2013 React", "text": "React Conf 2024 Recap\nMay 22, 2024 by Ricky Hanlon.\nLast week we hosted React Conf 2024, a two-day conference in Henderson, Nevada where 700+ attendees gathered in-person to discuss the latest in UI engineering. This was our first in-person conference since 2019, and we were thrilled to be able to bring the community together again.\nAt React Conf 2024, we announced the React 19 RC, the React Native New Architecture Beta, and an experimental release of the React Compiler. The community also took the stage to announce React Router v7, Universal Server Components in Expo Router, React Server Components in RedwoodJS, and much more.\nThe entire day 1 and day 2 streams are available online. In this post, we\u2019ll summarize the talks and announcements from the event.\nDay 1\nWatch the full day 1 stream here.\nTo kick off day 1, Meta CTO Andrew \u201cBoz\u201d Bosworth shared a welcome message followed by an introduction by Seth Webster, who manages the React Org at Meta, and our MC Ashley Narcisse.\nIn the day 1 keynote, Joe Savona shared our goals and vision for React to make it easy for anyone to build great user experiences. Lauren Tan followed with a State of React, where she shared that React was downloaded over 1 billion times in 2023, and that 37% of new developers learn to program with React. Finally, she highlighted the work of the React community to make React, React.\nFor more, check out these talks from the community later in the conference:\n- Vanilla React by Ryan Florence\n- React Rhythm & Blues by Lee Robinson\n- RedwoodJS, now with React Server Components by Amy Dutton\n- Introducing Universal React Server Components in Expo Router by Evan Bacon\nNext in the keynote, Josh Story and Andrew Clark shared new features coming in React 19, and announced the React 19 RC which is ready for testing in production. Check out all the features in the React 19 release post, and see these talks for deep dives on the new features:\n- What\u2019s new in React 19 by Lydia Hallie\n- React Unpacked: A Roadmap to React 19 by Sam Selikoff\n- React 19 Deep Dive: Coordinating HTML by Josh Story\n- Enhancing Forms with React Server Components by Aurora Walberg Scharff\n- React for Two Computers by Dan Abramov\n- And Now You Understand React Server Components by Kent C. Dodds\nFinally, we ended the keynote with Joe Savona, Sathya Gunasekaran, and Mofei Zhang announcing that the React Compiler is now Open Source, and sharing an experimental version of the React Compiler to try out.\nFor more information on using the Compiler and how it works, check out the docs and these talks:\nWatch the full day 1 keynote here:\nDay 2\nWatch the full day 2 stream here.\nTo kick off day 2, Seth Webster shared a welcome message, followed by a Thank You from Eli White and an introduction by our Chief Vibes Officer Ashley Narcisse.\nIn the day 2 keynote, Nicola Corti shared the State of React Native, including 78 million downloads in 2023. He also highlighted apps using React Native including 2000+ screens used inside of Meta; the product details page in Facebook Marketplace, which is visited more than 2 billion times per day; and part of the Microsoft Windows Start Menu and some features in almost every Microsoft Office product across mobile and desktop.\nNicola also highlighted all the work the community does to support React Native including libraries, frameworks, and multiple platforms. For more, check out these talks from the community:\n- Extending React Native beyond Mobile and Desktop Apps by Chris Traganos and Anisha Malde\n- Spatial computing with React by Micha\u0142 Pierzcha\u0142a\nRiccardo Cipolleschi continued the day 2 keynote by announcing that the React Native New Architecture is now in Beta and ready for apps to adopt in production. He shared new features and improvements in the new architecture, and shared the roadmap for the future of React Native. For more check out:\nNext in the keynote, Nicola announced that we are now recommending starting with a framework like Expo for all new apps created with React Native. With the change, he also announced a new React Native homepage and new Getting Started docs. You can view the new Getting Started guide in the React Native docs.\nFinally, to end the keynote, Kadi Kraman shared the latest features and improvements in Expo, and how to get started developing with React Native using Expo.\nWatch the full day 2 keynote here:\nQ&A\nThe React and React Native teams also ended each day with a Q&A session:\n- React Q&A hosted by Michael Chan\n- React Native Q&A hosted by Jamon Holmgren\nAnd more\u2026\nWe also heard talks on accessibility, error reporting, css, and more:\n- Demystifying accessibility in React apps by Kateryna Porshnieva\n- Pigment CSS, CSS in the server component age by Olivier Tassinari\n- Real-time React Server Components by Sunil Pai\n- Let\u2019s break React Rules by Charlotte Isambert\n- Solve 100% of your errors by Ryan Albrecht\nThank you\nThank you to all the staff, speakers, and participants who made React Conf 2024 possible. There are too many to list, but we want to thank a few in particular.\nThank you to Barbara Markiewicz, the team at Callstack, and our React Team Developer Advocate Matt Carroll for helping to plan the entire event; and to Sunny Leggett and everyone from Zero Slope for helping to organize the event.\nThank you Ashley Narcisse for being our MC and Chief Vibes Officer; and to Michael Chan and Jamon Holmgren for hosting the Q&A sessions.\nThank you Seth Webster and Eli White for welcoming us each day and providing direction on structure and content; and to Tom Occhino for joining us with a special message during the after-party.\nThank you Ricky Hanlon for providing detailed feedback on talks, working on slide designs, and generally filling in the gaps to sweat the details.\nThank you Callstack for building the conference website; and to Kadi Kraman and the Expo team for building the conference mobile app.\nThank you to all the sponsors who made the event possible: Remix, Amazon, MUI, Sentry, Abbott, Expo, RedwoodJS, and Vercel.\nThank you to the AV Team for the visuals, stage, and sound; and to the Westin Hotel for hosting us.\nThank you to all the speakers who shared their knowledge and experiences with the community.\nFinally, thank you to everyone who attended in person and online to show what makes React, React. React is more than a library, it is a community, and it was inspiring to see everyone come together to share and learn together.\nSee you next time!"},
{"source": "https://react.dev/blog/2024/10/21/react-compiler-beta-release", "title": "React Compiler Beta Release \u2013 React", "text": "React Compiler Beta Release\nOctober 21, 2024 by Lauren Tan.\nThe React team is excited to share new updates:\n- We\u2019re publishing React Compiler Beta today, so that early adopters and library maintainers can try it and provide feedback.\n- We\u2019re officially supporting React Compiler for apps on React 17+, through an optional\nreact-compiler-runtime\npackage. - We\u2019re opening up public membership of the React Compiler Working Group to prepare the community for gradual adoption of the compiler.\nAt React Conf 2024, we announced the experimental release of React Compiler, a build-time tool that optimizes your React app through automatic memoization. You can find an introduction to React Compiler here.\nSince the first release, we\u2019ve fixed numerous bugs reported by the React community, received several high quality bug fixes and contributions1 to the compiler, made the compiler more resilient to the broad diversity of JavaScript patterns, and have continued to roll out the compiler more widely at Meta.\nIn this post, we want to share what\u2019s next for React Compiler.\nTry React Compiler Beta today\nAt React India 2024, we shared an update on React Compiler. Today, we are excited to announce a new Beta release of React Compiler and ESLint plugin. New betas are published to npm using the @beta\ntag.\nTo install React Compiler Beta:\nOr, if you\u2019re using Yarn:\nYou can watch Sathya Gunasekaran\u2019s talk at React India here:\nWe recommend everyone use the React Compiler linter today\nReact Compiler\u2019s ESLint plugin helps developers proactively identify and correct Rules of React violations. We strongly recommend everyone use the linter today. The linter does not require that you have the compiler installed, so you can use it independently, even if you are not ready to try out the compiler.\nTo install the linter only:\nOr, if you\u2019re using Yarn:\nAfter installation you can enable the linter by adding it to your ESLint config. Using the linter helps identify Rules of React breakages, making it easier to adopt the compiler when it\u2019s fully released.\nBackwards Compatibility\nReact Compiler produces code that depends on runtime APIs added in React 19, but we\u2019ve since added support for the compiler to also work with React 17 and 18. If you are not on React 19 yet, in the Beta release you can now try out React Compiler by specifying a minimum target\nin your compiler config, and adding react-compiler-runtime\nas a dependency. You can find docs on this here.\nUsing React Compiler in libraries\nOur initial release was focused on identifying major issues with using the compiler in applications. We\u2019ve gotten great feedback and have substantially improved the compiler since then. We\u2019re now ready for broad feedback from the community, and for library authors to try out the compiler to improve performance and the developer experience of maintaining your library.\nReact Compiler can also be used to compile libraries. Because React Compiler needs to run on the original source code prior to any code transformations, it is not possible for an application\u2019s build pipeline to compile the libraries they use. Hence, our recommendation is for library maintainers to independently compile and test their libraries with the compiler, and ship compiled code to npm.\nBecause your code is pre-compiled, users of your library will not need to have the compiler enabled in order to benefit from the automatic memoization applied to your library. If your library targets apps not yet on React 19, specify a minimum target\nand add react-compiler-runtime\nas a direct dependency. The runtime package will use the correct implementation of APIs depending on the application\u2019s version, and polyfill the missing APIs if necessary.\nYou can find more docs on this here.\nOpening up React Compiler Working Group to everyone\nWe previously announced the invite-only React Compiler Working Group at React Conf to provide feedback, ask questions, and collaborate on the compiler\u2019s experimental release.\nFrom today, together with the Beta release of React Compiler, we are opening up Working Group membership to everyone. The goal of the React Compiler Working Group is to prepare the ecosystem for a smooth, gradual adoption of React Compiler by existing applications and libraries. Please continue to file bug reports in the React repo, but please leave feedback, ask questions, or share ideas in the Working Group discussion forum.\nThe core team will also use the discussions repo to share our research findings. As the Stable Release gets closer, any important information will also be posted on this forum.\nReact Compiler at Meta\nAt React Conf, we shared that our rollout of the compiler on Quest Store and Instagram were successful. Since then, we\u2019ve deployed React Compiler across several more major web apps at Meta, including Facebook and Threads. That means if you\u2019ve used any of these apps recently, you may have had your experience powered by the compiler. We were able to onboard these apps onto the compiler with few code changes required, in a monorepo with more than 100,000 React components.\nWe\u2019ve seen notable performance improvements across all of these apps. As we\u2019ve rolled out, we\u2019re continuing to see results on the order of the wins we shared previously at ReactConf. These apps have already been heavily hand tuned and optimized by Meta engineers and React experts over the years, so even improvements on the order of a few percent are a huge win for us.\nWe also expected developer productivity wins from React Compiler. To measure this, we collaborated with our data science partners at Meta2 to conduct a thorough statistical analysis of the impact of manual memoization on productivity. Before rolling out the compiler at Meta, we discovered that only about 8% of React pull requests used manual memoization and that these pull requests took 31-46% longer to author3. This confirmed our intuition that manual memoization introduces cognitive overhead, and we anticipate that React Compiler will lead to more efficient code authoring and review. Notably, React Compiler also ensures that all code is memoized by default, not just the (in our case) 8% where developers explicitly apply memoization.\nRoadmap to Stable\nThis is not a final roadmap, and is subject to change.\nWe intend to ship a Release Candidate of the compiler in the near future following the Beta release, when the majority of apps and libraries that follow the Rules of React have been proven to work well with the compiler. After a period of final feedback from the community, we plan on a Stable Release for the compiler. The Stable Release will mark the beginning of a new foundation for React, and all apps and libraries will be strongly recommended to use the compiler and ESLint plugin.\n- \u2705 Experimental: Released at React Conf 2024, primarily for feedback from early adopters.\n- \u2705 Public Beta: Available today, for feedback from the wider community.\n- \ud83d\udea7 Release Candidate (RC): React Compiler works for the majority of rule-following apps and libraries without issue.\n- \ud83d\udea7 General Availability: After final feedback period from the community.\nThese releases also include the compiler\u2019s ESLint plugin, which surfaces diagnostics statically analyzed by the compiler. We plan to combine the existing eslint-plugin-react-hooks plugin with the compiler\u2019s ESLint plugin, so only one plugin needs to be installed.\nPost-Stable, we plan to add more compiler optimizations and improvements. This includes both continual improvements to automatic memoization, and new optimizations altogether, with minimal to no change of product code. Upgrading to each new release of the compiler is aimed to be straightforward, and each upgrade will continue to improve performance and add better handling of diverse JavaScript and React patterns.\nThroughout this process, we also plan to prototype an IDE extension for React. It is still very early in research, so we expect to be able to share more of our findings with you in a future React Labs blog post.\nThanks to Sathya Gunasekaran, Joe Savona, Ricky Hanlon, Alex Taylor, Jason Bonta, and Eli White for reviewing and editing this post.\nFootnotes\n-\nThanks @nikeee, @henryqdineen, @TrickyPi, and several others for their contributions to the compiler. \u21a9\n-\nThanks Vaishali Garg for leading this study on React Compiler at Meta, and for reviewing this post. \u21a9\n-\nAfter controlling on author tenure, diff length/complexity, and other potential confounding factors. \u21a9"},
{"source": "https://react.dev/blog/2024/12/05/react-19", "title": "React v19 \u2013 React", "text": "React v19\nDecember 05, 2024 by The React Team\nReact v19 is now available on npm!\nIn our React 19 Upgrade Guide, we shared step-by-step instructions for upgrading your app to React 19. In this post, we\u2019ll give an overview of the new features in React 19, and how you can adopt them.\nFor a list of breaking changes, see the Upgrade Guide.\nWhat\u2019s new in React 19\nActions\nA common use case in React apps is to perform a data mutation and then update state in response. For example, when a user submits a form to change their name, you will make an API request, and then handle the response. In the past, you would need to handle pending states, errors, optimistic updates, and sequential requests manually.\nFor example, you could handle the pending and error state in useState\n:\n// Before Actions\nfunction UpdateName({}) {\nconst [name, setName] = useState(\"\");\nconst [error, setError] = useState(null);\nconst [isPending, setIsPending] = useState(false);\nconst handleSubmit = async () => {\nsetIsPending(true);\nconst error = await updateName(name);\nsetIsPending(false);\nif (error) {\nsetError(error);\nreturn;\n}\nredirect(\"/path\");\n};\nreturn (\n<div>\n<input value={name} onChange={(event) => setName(event.target.value)} />\n<button onClick={handleSubmit} disabled={isPending}>\nUpdate\n</button>\n{error && <p>{error}</p>}\n</div>\n);\n}\nIn React 19, we\u2019re adding support for using async functions in transitions to handle pending states, errors, forms, and optimistic updates automatically.\nFor example, you can use useTransition\nto handle the pending state for you:\n// Using pending state from Actions\nfunction UpdateName({}) {\nconst [name, setName] = useState(\"\");\nconst [error, setError] = useState(null);\nconst [isPending, startTransition] = useTransition();\nconst handleSubmit = () => {\nstartTransition(async () => {\nconst error = await updateName(name);\nif (error) {\nsetError(error);\nreturn;\n}\nredirect(\"/path\");\n})\n};\nreturn (\n<div>\n<input value={name} onChange={(event) => setName(event.target.value)} />\n<button onClick={handleSubmit} disabled={isPending}>\nUpdate\n</button>\n{error && <p>{error}</p>}\n</div>\n);\n}\nThe async transition will immediately set the isPending\nstate to true, make the async request(s), and switch isPending\nto false after any transitions. This allows you to keep the current UI responsive and interactive while the data is changing.\nBuilding on top of Actions, React 19 introduces useOptimistic\nto manage optimistic updates, and a new hook React.useActionState\nto handle common cases for Actions. In react-dom\nwe\u2019re adding <form>\nActions to manage forms automatically and useFormStatus\nto support the common cases for Actions in forms.\nIn React 19, the above example can be simplified to:\n// Using <form> Actions and useActionState\nfunction ChangeName({ name, setName }) {\nconst [error, submitAction, isPending] = useActionState(\nasync (previousState, formData) => {\nconst error = await updateName(formData.get(\"name\"));\nif (error) {\nreturn error;\n}\nredirect(\"/path\");\nreturn null;\n},\nnull,\n);\nreturn (\n<form action={submitAction}>\n<input type=\"text\" name=\"name\" />\n<button type=\"submit\" disabled={isPending}>Update</button>\n{error && <p>{error}</p>}\n</form>\n);\n}\nIn the next section, we\u2019ll break down each of the new Action features in React 19.\nNew hook: useActionState\nTo make the common cases easier for Actions, we\u2019ve added a new hook called useActionState\n:\nconst [error, submitAction, isPending] = useActionState(\nasync (previousState, newName) => {\nconst error = await updateName(newName);\nif (error) {\n// You can return any result of the action.\n// Here, we return only the error.\nreturn error;\n}\n// handle success\nreturn null;\n},\nnull,\n);\nuseActionState\naccepts a function (the \u201cAction\u201d), and returns a wrapped Action to call. This works because Actions compose. When the wrapped Action is called, useActionState\nwill return the last result of the Action as data\n, and the pending state of the Action as pending\n.\nFor more information, see the docs for useActionState\n.\nReact DOM: <form>\nActions\nActions are also integrated with React 19\u2019s new <form>\nfeatures for react-dom\n. We\u2019ve added support for passing functions as the action\nand formAction\nprops of <form>\n, <input>\n, and <button>\nelements to automatically submit forms with Actions:\n<form action={actionFunction}>\nWhen a <form>\nAction succeeds, React will automatically reset the form for uncontrolled components. If you need to reset the <form>\nmanually, you can call the new requestFormReset\nReact DOM API.\nFor more information, see the react-dom\ndocs for <form>\n, <input>\n, and <button>\n.\nReact DOM: New hook: useFormStatus\nIn design systems, it\u2019s common to write design components that need access to information about the <form>\nthey\u2019re in, without drilling props down to the component. This can be done via Context, but to make the common case easier, we\u2019ve added a new hook useFormStatus\n:\nimport {useFormStatus} from 'react-dom';\nfunction DesignButton() {\nconst {pending} = useFormStatus();\nreturn <button type=\"submit\" disabled={pending} />\n}\nuseFormStatus\nreads the status of the parent <form>\nas if the form was a Context provider.\nFor more information, see the react-dom\ndocs for useFormStatus\n.\nNew hook: useOptimistic\nAnother common UI pattern when performing a data mutation is to show the final state optimistically while the async request is underway. In React 19, we\u2019re adding a new hook called useOptimistic\nto make this easier:\nfunction ChangeName({currentName, onUpdateName}) {\nconst [optimisticName, setOptimisticName] = useOptimistic(currentName);\nconst submitAction = async formData => {\nconst newName = formData.get(\"name\");\nsetOptimisticName(newName);\nconst updatedName = await updateName(newName);\nonUpdateName(updatedName);\n};\nreturn (\n<form action={submitAction}>\n<p>Your name is: {optimisticName}</p>\n<p>\n<label>Change Name:</label>\n<input\ntype=\"text\"\nname=\"name\"\ndisabled={currentName !== optimisticName}\n/>\n</p>\n</form>\n);\n}\nThe useOptimistic\nhook will immediately render the optimisticName\nwhile the updateName\nrequest is in progress. When the update finishes or errors, React will automatically switch back to the currentName\nvalue.\nFor more information, see the docs for useOptimistic\n.\nNew API: use\nIn React 19 we\u2019re introducing a new API to read resources in render: use\n.\nFor example, you can read a promise with use\n, and React will Suspend until the promise resolves:\nimport {use} from 'react';\nfunction Comments({commentsPromise}) {\n// `use` will suspend until the promise resolves.\nconst comments = use(commentsPromise);\nreturn comments.map(comment => <p key={comment.id}>{comment}</p>);\n}\nfunction Page({commentsPromise}) {\n// When `use` suspends in Comments,\n// this Suspense boundary will be shown.\nreturn (\n<Suspense fallback={<div>Loading...</div>}>\n<Comments commentsPromise={commentsPromise} />\n</Suspense>\n)\n}\nYou can also read context with use\n, allowing you to read Context conditionally such as after early returns:\nimport {use} from 'react';\nimport ThemeContext from './ThemeContext'\nfunction Heading({children}) {\nif (children == null) {\nreturn null;\n}\n// This would not work with useContext\n// because of the early return.\nconst theme = use(ThemeContext);\nreturn (\n<h1 style={{color: theme.color}}>\n{children}\n</h1>\n);\n}\nThe use\nAPI can only be called in render, similar to hooks. Unlike hooks, use\ncan be called conditionally. In the future we plan to support more ways to consume resources in render with use\n.\nFor more information, see the docs for use\n.\nNew React DOM Static APIs\nWe\u2019ve added two new APIs to react-dom/static\nfor static site generation:\nThese new APIs improve on renderToString\nby waiting for data to load for static HTML generation. They are designed to work with streaming environments like Node.js Streams and Web Streams. For example, in a Web Stream environment, you can prerender a React tree to static HTML with prerender\n:\nimport { prerender } from 'react-dom/static';\nasync function handler(request) {\nconst {prelude} = await prerender(<App />, {\nbootstrapScripts: ['/main.js']\n});\nreturn new Response(prelude, {\nheaders: { 'content-type': 'text/html' },\n});\n}\nPrerender APIs will wait for all data to load before returning the static HTML stream. Streams can be converted to strings, or sent with a streaming response. They do not support streaming content as it loads, which is supported by the existing React DOM server rendering APIs.\nFor more information, see React DOM Static APIs.\nReact Server Components\nServer Components\nServer Components are a new option that allows rendering components ahead of time, before bundling, in an environment separate from your client application or SSR server. This separate environment is the \u201cserver\u201d in React Server Components. Server Components can run once at build time on your CI server, or they can be run for each request using a web server.\nReact 19 includes all of the React Server Components features included from the Canary channel. This means libraries that ship with Server Components can now target React 19 as a peer dependency with a react-server\nexport condition for use in frameworks that support the Full-stack React Architecture.\nFor more, see the docs for React Server Components.\nServer Actions\nServer Actions allow Client Components to call async functions executed on the server.\nWhen a Server Action is defined with the \"use server\"\ndirective, your framework will automatically create a reference to the server function, and pass that reference to the Client Component. When that function is called on the client, React will send a request to the server to execute the function, and return the result.\nServer Actions can be created in Server Components and passed as props to Client Components, or they can be imported and used in Client Components.\nFor more, see the docs for React Server Actions.\nImprovements in React 19\nref\nas a prop\nStarting in React 19, you can now access ref\nas a prop for function components:\nfunction MyInput({placeholder, ref}) {\nreturn <input placeholder={placeholder} ref={ref} />\n}\n//...\n<MyInput ref={ref} />\nNew function components will no longer need forwardRef\n, and we will be publishing a codemod to automatically update your components to use the new ref\nprop. In future versions we will deprecate and remove forwardRef\n.\nDiffs for hydration errors\nWe also improved error reporting for hydration errors in react-dom\n. For example, instead of logging multiple errors in DEV without any information about the mismatch:\nWe now log a single message with a diff of the mismatch:\nif (typeof window !== 'undefined')\n.\n- Variable input such as Date.now()\nor Math.random()\nwhich changes each time it\u2019s called.\n- Date formatting in a user\u2019s locale which doesn\u2019t match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\nhttps://react.dev/link/hydration-mismatch\n<App>\n<span>\n+ Client\n- Server\nat throwOnHydrationMismatch\n\u2026<Context>\nas a provider\nIn React 19, you can render <Context>\nas a provider instead of <Context.Provider>\n:\nconst ThemeContext = createContext('');\nfunction App({children}) {\nreturn (\n<ThemeContext value=\"dark\">\n{children}\n</ThemeContext>\n);\n}\nNew Context providers can use <Context>\nand we will be publishing a codemod to convert existing providers. In future versions we will deprecate <Context.Provider>\n.\nCleanup functions for refs\nWe now support returning a cleanup function from ref\ncallbacks:\n<input\nref={(ref) => {\n// ref created\n// NEW: return a cleanup function to reset\n// the ref when element is removed from DOM.\nreturn () => {\n// ref cleanup\n};\n}}\n/>\nWhen the component unmounts, React will call the cleanup function returned from the ref\ncallback. This works for DOM refs, refs to class components, and useImperativeHandle\n.\nDue to the introduction of ref cleanup functions, returning anything else from a ref\ncallback will now be rejected by TypeScript. The fix is usually to stop using implicit returns, for example:\n- <div ref={current => (instance = current)} />\n+ <div ref={current => {instance = current}} />\nThe original code returned the instance of the HTMLDivElement\nand TypeScript wouldn\u2019t know if this was supposed to be a cleanup function or if you didn\u2019t want to return a cleanup function.\nYou can codemod this pattern with no-implicit-ref-callback-return\n.\nuseDeferredValue\ninitial value\nWe\u2019ve added an initialValue\noption to useDeferredValue\n:\nfunction Search({deferredValue}) {\n// On initial render the value is ''.\n// Then a re-render is scheduled with the deferredValue.\nconst value = useDeferredValue(deferredValue, '');\nreturn (\n<Results query={value} />\n);\n}\nWhen initialValue is provided, useDeferredValue\nwill return it as value\nfor the initial render of the component, and schedules a re-render in the background with the deferredValue returned.\nFor more, see useDeferredValue\n.\nSupport for Document Metadata\nIn HTML, document metadata tags like <title>\n, <link>\n, and <meta>\nare reserved for placement in the <head>\nsection of the document. In React, the component that decides what metadata is appropriate for the app may be very far from the place where you render the <head>\nor React does not render the <head>\nat all. In the past, these elements would need to be inserted manually in an effect, or by libraries like react-helmet\n, and required careful handling when server rendering a React application.\nIn React 19, we\u2019re adding support for rendering document metadata tags in components natively:\nfunction BlogPost({post}) {\nreturn (\n<article>\n<h1>{post.title}</h1>\n<title>{post.title}</title>\n<meta name=\"author\" content=\"Josh\" />\n<link rel=\"author\" href=\"https://twitter.com/joshcstory/\" />\n<meta name=\"keywords\" content={post.keywords} />\n<p>\nEee equals em-see-squared...\n</p>\n</article>\n);\n}\nWhen React renders this component, it will see the <title>\n<link>\nand <meta>\ntags, and automatically hoist them to the <head>\nsection of document. By supporting these metadata tags natively, we\u2019re able to ensure they work with client-only apps, streaming SSR, and Server Components.\nFor more info, see the docs for <title>\n, <link>\n, and <meta>\n.\nSupport for stylesheets\nStylesheets, both externally linked (<link rel=\"stylesheet\" href=\"...\">\n) and inline (<style>...</style>\n), require careful positioning in the DOM due to style precedence rules. Building a stylesheet capability that allows for composability within components is hard, so users often end up either loading all of their styles far from the components that may depend on them, or they use a style library which encapsulates this complexity.\nIn React 19, we\u2019re addressing this complexity and providing even deeper integration into Concurrent Rendering on the Client and Streaming Rendering on the Server with built in support for stylesheets. If you tell React the precedence\nof your stylesheet it will manage the insertion order of the stylesheet in the DOM and ensure that the stylesheet (if external) is loaded before revealing content that depends on those style rules.\nfunction ComponentOne() {\nreturn (\n<Suspense fallback=\"loading...\">\n<link rel=\"stylesheet\" href=\"foo\" precedence=\"default\" />\n<link rel=\"stylesheet\" href=\"bar\" precedence=\"high\" />\n<article class=\"foo-class bar-class\">\n{...}\n</article>\n</Suspense>\n)\n}\nfunction ComponentTwo() {\nreturn (\n<div>\n<p>{...}</p>\n<link rel=\"stylesheet\" href=\"baz\" precedence=\"default\" /> <-- will be inserted between foo & bar\n</div>\n)\n}\nDuring Server Side Rendering React will include the stylesheet in the <head>\n, which ensures that the browser will not paint until it has loaded. If the stylesheet is discovered late after we\u2019ve already started streaming, React will ensure that the stylesheet is inserted into the <head>\non the client before revealing the content of a Suspense boundary that depends on that stylesheet.\nDuring Client Side Rendering React will wait for newly rendered stylesheets to load before committing the render. If you render this component from multiple places within your application React will only include the stylesheet once in the document:\nfunction App() {\nreturn <>\n<ComponentOne />\n...\n<ComponentOne /> // won't lead to a duplicate stylesheet link in the DOM\n</>\n}\nFor users accustomed to loading stylesheets manually this is an opportunity to locate those stylesheets alongside the components that depend on them allowing for better local reasoning and an easier time ensuring you only load the stylesheets that you actually depend on.\nStyle libraries and style integrations with bundlers can also adopt this new capability so even if you don\u2019t directly render your own stylesheets, you can still benefit as your tools are upgraded to use this feature.\nFor more details, read the docs for <link>\nand <style>\n.\nSupport for async scripts\nIn HTML normal scripts (<script src=\"...\">\n) and deferred scripts (<script defer=\"\" src=\"...\">\n) load in document order which makes rendering these kinds of scripts deep within your component tree challenging. Async scripts (<script async=\"\" src=\"...\">\n) however will load in arbitrary order.\nIn React 19 we\u2019ve included better support for async scripts by allowing you to render them anywhere in your component tree, inside the components that actually depend on the script, without having to manage relocating and deduplicating script instances.\nfunction MyComponent() {\nreturn (\n<div>\n<script async={true} src=\"...\" />\nHello World\n</div>\n)\n}\nfunction App() {\n<html>\n<body>\n<MyComponent>\n...\n<MyComponent> // won't lead to duplicate script in the DOM\n</body>\n</html>\n}\nIn all rendering environments, async scripts will be deduplicated so that React will only load and execute the script once even if it is rendered by multiple different components.\nIn Server Side Rendering, async scripts will be included in the <head>\nand prioritized behind more critical resources that block paint such as stylesheets, fonts, and image preloads.\nFor more details, read the docs for <script>\n.\nSupport for preloading resources\nDuring initial document load and on client side updates, telling the Browser about resources that it will likely need to load as early as possible can have a dramatic effect on page performance.\nReact 19 includes a number of new APIs for loading and preloading Browser resources to make it as easy as possible to build great experiences that aren\u2019t held back by inefficient resource loading.\nimport { prefetchDNS, preconnect, preload, preinit } from 'react-dom'\nfunction MyComponent() {\npreinit('https://.../path/to/some/script.js', {as: 'script' }) // loads and executes this script eagerly\npreload('https://.../path/to/font.woff', { as: 'font' }) // preloads this font\npreload('https://.../path/to/stylesheet.css', { as: 'style' }) // preloads this stylesheet\nprefetchDNS('https://...') // when you may not actually request anything from this host\npreconnect('https://...') // when you will request something but aren't sure what\n}\n<!-- the above would result in the following DOM/HTML -->\n<html>\n<head>\n<!-- links/scripts are prioritized by their utility to early loading, not call order -->\n<link rel=\"prefetch-dns\" href=\"https://...\">\n<link rel=\"preconnect\" href=\"https://...\">\n<link rel=\"preload\" as=\"font\" href=\"https://.../path/to/font.woff\">\n<link rel=\"preload\" as=\"style\" href=\"https://.../path/to/stylesheet.css\">\n<script async=\"\" src=\"https://.../path/to/some/script.js\"></script>\n</head>\n<body>\n...\n</body>\n</html>\nThese APIs can be used to optimize initial page loads by moving discovery of additional resources like fonts out of stylesheet loading. They can also make client updates faster by prefetching a list of resources used by an anticipated navigation and then eagerly preloading those resources on click or even on hover.\nFor more details see Resource Preloading APIs.\nCompatibility with third-party scripts and extensions\nWe\u2019ve improved hydration to account for third-party scripts and browser extensions.\nWhen hydrating, if an element that renders on the client doesn\u2019t match the element found in the HTML from the server, React will force a client re-render to fix up the content. Previously, if an element was inserted by third-party scripts or browser extensions, it would trigger a mismatch error and client render.\nIn React 19, unexpected tags in the <head>\nand <body>\nwill be skipped over, avoiding the mismatch errors. If React needs to re-render the entire document due to an unrelated hydration mismatch, it will leave in place stylesheets inserted by third-party scripts and browser extensions.\nBetter error reporting\nWe improved error handling in React 19 to remove duplication and provide options for handling caught and uncaught errors. For example, when there\u2019s an error in render caught by an Error Boundary, previously React would throw the error twice (once for the original error, then again after failing to automatically recover), and then call console.error\nwith info about where the error occurred.\nThis resulted in three errors for every caught error:\nIn React 19, we log a single error with all the error information included:\nAdditionally, we\u2019ve added two new root options to complement onRecoverableError\n:\nonCaughtError\n: called when React catches an error in an Error Boundary.onUncaughtError\n: called when an error is thrown and not caught by an Error Boundary.onRecoverableError\n: called when an error is thrown and automatically recovered.\nFor more info and examples, see the docs for createRoot\nand hydrateRoot\n.\nSupport for Custom Elements\nReact 19 adds full support for custom elements and passes all tests on Custom Elements Everywhere.\nIn past versions, using Custom Elements in React has been difficult because React treated unrecognized props as attributes rather than properties. In React 19, we\u2019ve added support for properties that works on the client and during SSR with the following strategy:\n- Server Side Rendering: props passed to a custom element will render as attributes if their type is a primitive value like\nstring\n,number\n, or the value istrue\n. Props with non-primitive types likeobject\n,symbol\n,function\n, or valuefalse\nwill be omitted. - Client Side Rendering: props that match a property on the Custom Element instance will be assigned as properties, otherwise they will be assigned as attributes.\nThanks to Joey Arhar for driving the design and implementation of Custom Element support in React.\nHow to upgrade\nSee the React 19 Upgrade Guide for step-by-step instructions and a full list of breaking and notable changes.\nNote: this post was originally published 04/25/2024 and has been updated to 12/05/2024 with the stable release."}]