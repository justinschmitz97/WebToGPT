[{"source": "https://react.dev/blog/2024/12/05/react-19", "title": "React v19 \u2013 React", "text": "React v19 December 05, 2024 by The React Team React v19 is now available on npm! In our React 19 Upgrade Guide, we shared step-by-step instructions for upgrading your app to React 19. In this post, we\u2019ll give an overview of the new features in React 19, and how you can adopt them. For a list of breaking changes, see the Upgrade Guide. What\u2019s new in React 19 Actions A common use case in React apps is to perform a data mutation and then update state in response. For example, when a user submits a form to change their name, you will make an API request, and then handle the response. In the past, you would need to handle pending states, errors, optimistic updates, and sequential requests manually. For example, you could handle the pending and error state in useState : // Before Actions function UpdateName({}) { const [name, setName] = useState(\"\"); const [error, setError] = useState(null); const [isPending, setIsPending] = useState(false); const handleSubmit = async () => { setIsPending(true); const error = await updateName(name); setIsPending(false); if (error) { setError(error); return; } redirect(\"/path\"); }; return ( <div> <input value={name} onChange={(event) => setName(event.target.value)} /> <button onClick={handleSubmit} disabled={isPending}> Update </button> {error && <p>{error}</p>} </div> ); } In React 19, we\u2019re adding support for using async functions in transitions to handle pending states, errors, forms, and optimistic updates automatically. For example, you can use useTransition to handle the pending state for you: // Using pending state from Actions function UpdateName({}) { const [name, setName] = useState(\"\"); const [error, setError] = useState(null); const [isPending, startTransition] = useTransition(); const handleSubmit = () => { startTransition(async () => { const error = await updateName(name); if (error) { setError(error); return; } redirect(\"/path\"); }) }; return ( <div> <input value={name} onChange={(event) => setName(event.target.value)} /> <button onClick={handleSubmit} disabled={isPending}> Update </button> {error && <p>{error}</p>} </div> ); } The async transition will immediately set the isPending state to true, make the async request(s), and switch isPending to false after any transitions. This allows you to keep the current UI responsive and interactive while the data is changing. Building on top of Actions, React 19 introduces useOptimistic to manage optimistic updates, and a new hook React.useActionState to handle common cases for Actions. In react-dom we\u2019re adding <form> Actions to manage forms automatically and useFormStatus to support the common cases for Actions in forms. In React 19, the above example can be simplified to: // Using <form> Actions and useActionState function ChangeName({ name, setName }) { const [error, submitAction, isPending] = useActionState( async (previousState, formData) => { const error = await updateName(formData.get(\"name\")); if (error) { return error; } redirect(\"/path\"); return null; }, null, ); return ( <form action={submitAction}> <input type=\"text\" name=\"name\" /> <button type=\"submit\" disabled={isPending}>Update</button> {error && <p>{error}</p>} </form> ); } In the next section, we\u2019ll break down each of the new Action features in React 19. New hook: useActionState To make the common cases easier for Actions, we\u2019ve added a new hook called useActionState : const [error, submitAction, isPending] = useActionState( async (previousState, newName) => { const error = await updateName(newName); if (error) { // You can return any result of the action. // Here, we return only the error. return error; } // handle success return null; }, null, ); useActionState accepts a function (the \u201cAction\u201d), and returns a wrapped Action to call. This works because Actions compose. When the wrapped Action is called, useActionState will return the last result of the Action as data , and the pending state of the Action as pending . For more information, see the docs for useActionState . React DOM: <form> Actions Actions are also integrated with React 19\u2019s new <form> features for react-dom . We\u2019ve added support for passing functions as the action and formAction props of <form> , <input> , and <button> elements to automatically submit forms with Actions: <form action={actionFunction}> When a <form> Action succeeds, React will automatically reset the form for uncontrolled components. If you need to reset the <form> manually, you can call the new requestFormReset React DOM API. For more information, see the react-dom docs for <form> , <input> , and <button> . React DOM: New hook: useFormStatus In design systems, it\u2019s common to write design components that need access to information about the <form> they\u2019re in, without drilling props down to the component. This can be done via Context, but to make the common case easier, we\u2019ve added a new hook useFormStatus : import {useFormStatus} from 'react-dom'; function DesignButton() { const {pending} = useFormStatus(); return <button type=\"submit\" disabled={pending} /> } useFormStatus reads the status of the parent <form> as if the form was a Context provider. For more information, see the react-dom docs for useFormStatus . New hook: useOptimistic Another common UI pattern when performing a data mutation is to show the final state optimistically while the async request is underway. In React 19, we\u2019re adding a new hook called useOptimistic to make this easier: function ChangeName({currentName, onUpdateName}) { const [optimisticName, setOptimisticName] = useOptimistic(currentName); const submitAction = async formData => { const newName = formData.get(\"name\"); setOptimisticName(newName); const updatedName = await updateName(newName); onUpdateName(updatedName); }; return ( <form action={submitAction}> <p>Your name is: {optimisticName}</p> <p> <label>Change Name:</label> <input type=\"text\" name=\"name\" disabled={currentName !== optimisticName} /> </p> </form> ); } The useOptimistic hook will immediately render the optimisticName while the updateName request is in progress. When the update finishes or errors, React will automatically switch back to the currentName value. For more information, see the docs for useOptimistic . New API: use In React 19 we\u2019re introducing a new API to read resources in render: use . For example, you can read a promise with use , and React will Suspend until the promise resolves: import {use} from 'react'; function Comments({commentsPromise}) { // `use` will suspend until the promise resolves. const comments = use(commentsPromise); return comments.map(comment => <p key={comment.id}>{comment}</p>); } function Page({commentsPromise}) { // When `use` suspends in Comments, // this Suspense boundary will be shown. return ( <Suspense fallback={<div>Loading...</div>}> <Comments commentsPromise={commentsPromise} /> </Suspense> ) } You can also read context with use , allowing you to read Context conditionally such as after early returns: import {use} from 'react'; import ThemeContext from './ThemeContext' function Heading({children}) { if (children == null) { return null; } // This would not work with useContext // because of the early return. const theme = use(ThemeContext); return ( <h1 style={{color: theme.color}}> {children} </h1> ); } The use API can only be called in render, similar to hooks. Unlike hooks, use can be called conditionally. In the future we plan to support more ways to consume resources in render with use . For more information, see the docs for use . New React DOM Static APIs We\u2019ve added two new APIs to react-dom/static for static site generation: These new APIs improve on renderToString by waiting for data to load for static HTML generation. They are designed to work with streaming environments like Node.js Streams and Web Streams. For example, in a Web Stream environment, you can prerender a React tree to static HTML with prerender : import { prerender } from 'react-dom/static'; async function handler(request) { const {prelude} = await prerender(<App />, { bootstrapScripts: ['/main.js'] }); return new Response(prelude, { headers: { 'content-type': 'text/html' }, }); } Prerender APIs will wait for all data to load before returning the static HTML stream. Streams can be converted to strings, or sent with a streaming response. They do not support streaming content as it loads, which is supported by the existing React DOM server rendering APIs. For more information, see React DOM Static APIs. React Server Components Server Components Server Components are a new option that allows rendering components ahead of time, before bundling, in an environment separate from your client application or SSR server. This separate environment is the \u201cserver\u201d in React Server Components. Server Components can run once at build time on your CI server, or they can be run for each request using a web server. React 19 includes all of the React Server Components features included from the Canary channel. This means libraries that ship with Server Components can now target React 19 as a peer dependency with a react-server export condition for use in frameworks that support the Full-stack React Architecture. For more, see the docs for React Server Components. Server Actions Server Actions allow Client Components to call async functions executed on the server. When a Server Action is defined with the \"use server\" directive, your framework will automatically create a reference to the server function, and pass that reference to the Client Component. When that function is called on the client, React will send a request to the server to execute the function, and return the result. Server Actions can be created in Server Components and passed as props to Client Components, or they can be imported and used in Client Components. For more, see the docs for React Server Actions. Improvements in React 19 ref as a prop Starting in React 19, you can now access ref as a prop for function components: function MyInput({placeholder, ref}) { return <input placeholder={placeholder} ref={ref} /> } //... <MyInput ref={ref} /> New function components will no longer need forwardRef , and we will be publishing a codemod to automatically update your components to use the new ref prop. In future versions we will deprecate and remove forwardRef . Diffs for hydration errors We also improved error reporting for hydration errors in react-dom . For example, instead of logging multiple errors in DEV without any information about the mismatch: We now log a single message with a diff of the mismatch: if (typeof window !== 'undefined') . - Variable input such as Date.now() or Math.random() which changes each time it\u2019s called. - Date formatting in a user\u2019s locale which doesn\u2019t match the server. - External changing data without sending a snapshot of it along with the HTML. - Invalid HTML tag nesting. It can also happen if the client has a browser extension installed which messes with the HTML before React loaded. https://react.dev/link/hydration-mismatch <App> <span> + Client - Server at throwOnHydrationMismatch \u2026<Context> as a provider In React 19, you can render <Context> as a provider instead of <Context.Provider> : const ThemeContext = createContext(''); function App({children}) { return ( <ThemeContext value=\"dark\"> {children} </ThemeContext> ); } New Context providers can use <Context> and we will be publishing a codemod to convert existing providers. In future versions we will deprecate <Context.Provider> . Cleanup functions for refs We now support returning a cleanup function from ref callbacks: <input ref={(ref) => { // ref created // NEW: return a cleanup function to reset // the ref when element is removed from DOM. return () => { // ref cleanup }; }} /> When the component unmounts, React will call the cleanup function returned from the ref callback. This works for DOM refs, refs to class components, and useImperativeHandle . Due to the introduction of ref cleanup functions, returning anything else from a ref callback will now be rejected by TypeScript. The fix is usually to stop using implicit returns, for example: - <div ref={current => (instance = current)} /> + <div ref={current => {instance = current}} /> The original code returned the instance of the HTMLDivElement and TypeScript wouldn\u2019t know if this was supposed to be a cleanup function or if you didn\u2019t want to return a cleanup function. You can codemod this pattern with no-implicit-ref-callback-return . useDeferredValue initial value We\u2019ve added an initialValue option to useDeferredValue : function Search({deferredValue}) { // On initial render the value is ''. // Then a re-render is scheduled with the deferredValue. const value = useDeferredValue(deferredValue, ''); return ( <Results query={value} /> ); } When initialValue is provided, useDeferredValue will return it as value for the initial render of the component, and schedules a re-render in the background with the deferredValue returned. For more, see useDeferredValue . Support for Document Metadata In HTML, document metadata tags like <title> , <link> , and <meta> are reserved for placement in the <head> section of the document. In React, the component that decides what metadata is appropriate for the app may be very far from the place where you render the <head> or React does not render the <head> at all. In the past, these elements would need to be inserted manually in an effect, or by libraries like react-helmet , and required careful handling when server rendering a React application. In React 19, we\u2019re adding support for rendering document metadata tags in components natively: function BlogPost({post}) { return ( <article> <h1>{post.title}</h1> <title>{post.title}</title> <meta name=\"author\" content=\"Josh\" /> <link rel=\"author\" href=\"https://twitter.com/joshcstory/\" /> <meta name=\"keywords\" content={post.keywords} /> <p> Eee equals em-see-squared... </p> </article> ); } When React renders this component, it will see the <title> <link> and <meta> tags, and automatically hoist them to the <head> section of document. By supporting these metadata tags natively, we\u2019re able to ensure they work with client-only apps, streaming SSR, and Server Components. For more info, see the docs for <title> , <link> , and <meta> . Support for stylesheets Stylesheets, both externally linked (<link rel=\"stylesheet\" href=\"...\"> ) and inline (<style>...</style> ), require careful positioning in the DOM due to style precedence rules. Building a stylesheet capability that allows for composability within components is hard, so users often end up either loading all of their styles far from the components that may depend on them, or they use a style library which encapsulates this complexity. In React 19, we\u2019re addressing this complexity and providing even deeper integration into Concurrent Rendering on the Client and Streaming Rendering on the Server with built in support for stylesheets. If you tell React the precedence of your stylesheet it will manage the insertion order of the stylesheet in the DOM and ensure that the stylesheet (if external) is loaded before revealing content that depends on those style rules. function ComponentOne() { return ( <Suspense fallback=\"loading...\"> <link rel=\"stylesheet\" href=\"foo\" precedence=\"default\" /> <link rel=\"stylesheet\" href=\"bar\" precedence=\"high\" /> <article class=\"foo-class bar-class\"> {...} </article> </Suspense> ) } function ComponentTwo() { return ( <div> <p>{...}</p> <link rel=\"stylesheet\" href=\"baz\" precedence=\"default\" /> <-- will be inserted between foo & bar </div> ) } During Server Side Rendering React will include the stylesheet in the <head> , which ensures that the browser will not paint until it has loaded. If the stylesheet is discovered late after we\u2019ve already started streaming, React will ensure that the stylesheet is inserted into the <head> on the client before revealing the content of a Suspense boundary that depends on that stylesheet. During Client Side Rendering React will wait for newly rendered stylesheets to load before committing the render. If you render this component from multiple places within your application React will only include the stylesheet once in the document: function App() { return <> <ComponentOne /> ... <ComponentOne /> // won't lead to a duplicate stylesheet link in the DOM </> } For users accustomed to loading stylesheets manually this is an opportunity to locate those stylesheets alongside the components that depend on them allowing for better local reasoning and an easier time ensuring you only load the stylesheets that you actually depend on. Style libraries and style integrations with bundlers can also adopt this new capability so even if you don\u2019t directly render your own stylesheets, you can still benefit as your tools are upgraded to use this feature. For more details, read the docs for <link> and <style> . Support for async scripts In HTML normal scripts (<script src=\"...\"> ) and deferred scripts (<script defer=\"\" src=\"...\"> ) load in document order which makes rendering these kinds of scripts deep within your component tree challenging. Async scripts (<script async=\"\" src=\"...\"> ) however will load in arbitrary order. In React 19 we\u2019ve included better support for async scripts by allowing you to render them anywhere in your component tree, inside the components that actually depend on the script, without having to manage relocating and deduplicating script instances. function MyComponent() { return ( <div> <script async={true} src=\"...\" /> Hello World </div> ) } function App() { <html> <body> <MyComponent> ... <MyComponent> // won't lead to duplicate script in the DOM </body> </html> } In all rendering environments, async scripts will be deduplicated so that React will only load and execute the script once even if it is rendered by multiple different components. In Server Side Rendering, async scripts will be included in the <head> and prioritized behind more critical resources that block paint such as stylesheets, fonts, and image preloads. For more details, read the docs for <script> . Support for preloading resources During initial document load and on client side updates, telling the Browser about resources that it will likely need to load as early as possible can have a dramatic effect on page performance. React 19 includes a number of new APIs for loading and preloading Browser resources to make it as easy as possible to build great experiences that aren\u2019t held back by inefficient resource loading. import { prefetchDNS, preconnect, preload, preinit } from 'react-dom' function MyComponent() { preinit('https://.../path/to/some/script.js', {as: 'script' }) // loads and executes this script eagerly preload('https://.../path/to/font.woff', { as: 'font' }) // preloads this font preload('https://.../path/to/stylesheet.css', { as: 'style' }) // preloads this stylesheet prefetchDNS('https://...') // when you may not actually request anything from this host preconnect('https://...') // when you will request something but aren't sure what } <!-- the above would result in the following DOM/HTML --> <html> <head> <!-- links/scripts are prioritized by their utility to early loading, not call order --> <link rel=\"prefetch-dns\" href=\"https://...\"> <link rel=\"preconnect\" href=\"https://...\"> <link rel=\"preload\" as=\"font\" href=\"https://.../path/to/font.woff\"> <link rel=\"preload\" as=\"style\" href=\"https://.../path/to/stylesheet.css\"> <script async=\"\" src=\"https://.../path/to/some/script.js\"></script> </head> <body> ... </body> </html> These APIs can be used to optimize initial page loads by moving discovery of additional resources like fonts out of stylesheet loading. They can also make client updates faster by prefetching a list of resources used by an anticipated navigation and then eagerly preloading those resources on click or even on hover. For more details see Resource Preloading APIs. Compatibility with third-party scripts and extensions We\u2019ve improved hydration to account for third-party scripts and browser extensions. When hydrating, if an element that renders on the client doesn\u2019t match the element found in the HTML from the server, React will force a client re-render to fix up the content. Previously, if an element was inserted by third-party scripts or browser extensions, it would trigger a mismatch error and client render. In React 19, unexpected tags in the <head> and <body> will be skipped over, avoiding the mismatch errors. If React needs to re-render the entire document due to an unrelated hydration mismatch, it will leave in place stylesheets inserted by third-party scripts and browser extensions. Better error reporting We improved error handling in React 19 to remove duplication and provide options for handling caught and uncaught errors. For example, when there\u2019s an error in render caught by an Error Boundary, previously React would throw the error twice (once for the original error, then again after failing to automatically recover), and then call console.error with info about where the error occurred. This resulted in three errors for every caught error: In React 19, we log a single error with all the error information included: Additionally, we\u2019ve added two new root options to complement onRecoverableError : onCaughtError : called when React catches an error in an Error Boundary.onUncaughtError : called when an error is thrown and not caught by an Error Boundary.onRecoverableError : called when an error is thrown and automatically recovered. For more info and examples, see the docs for createRoot and hydrateRoot . Support for Custom Elements React 19 adds full support for custom elements and passes all tests on Custom Elements Everywhere. In past versions, using Custom Elements in React has been difficult because React treated unrecognized props as attributes rather than properties. In React 19, we\u2019ve added support for properties that works on the client and during SSR with the following strategy: - Server Side Rendering: props passed to a custom element will render as attributes if their type is a primitive value like string ,number , or the value istrue . Props with non-primitive types likeobject ,symbol ,function , or valuefalse will be omitted. - Client Side Rendering: props that match a property on the Custom Element instance will be assigned as properties, otherwise they will be assigned as attributes. Thanks to Joey Arhar for driving the design and implementation of Custom Element support in React. How to upgrade See the React 19 Upgrade Guide for step-by-step instructions and a full list of breaking and notable changes. Note: this post was originally published 04/25/2024 and has been updated to 12/05/2024 with the stable release."},
{"source": "https://react.dev/blog/2024/04/25/react-19-upgrade-guide", "title": "React 19 Upgrade Guide \u2013 React", "text": "React 19 Upgrade Guide April 25, 2024 by Ricky Hanlon The improvements added to React 19 require some breaking changes, but we\u2019ve worked to make the upgrade as smooth as possible, and we don\u2019t expect the changes to impact most apps. In this post, we will guide you through the steps for upgrading to React 19: If you\u2019d like to help us test React 19, follow the steps in this upgrade guide and report any issues you encounter. For a list of new features added to React 19, see the React 19 release post. Installing To install the latest version of React and React DOM: npm install --save-exact react@^19.0.0 react-dom@^19.0.0 Or, if you\u2019re using Yarn: yarn add --exact react@^19.0.0 react-dom@^19.0.0 If you\u2019re using TypeScript, you also need to update the types. npm install --save-exact @types/react@^19.0.0 @types/react-dom@^19.0.0 Or, if you\u2019re using Yarn: yarn add --exact @types/react@^19.0.0 @types/react-dom@^19.0.0 We\u2019re also including a codemod for the most common replacements. See TypeScript changes below. Codemods To help with the upgrade, we\u2019ve worked with the team at codemod.com to publish codemods that will automatically update your code to many of the new APIs and patterns in React 19. All codemods are available in the react-codemod repo and the Codemod team have joined in helping maintain the codemods. To run these codemods, we recommend using the codemod command instead of the react-codemod because it runs faster, handles more complex code migrations, and provides better support for TypeScript. Changes that include a codemod include the command below. For a list of all available codemods, see the react-codemod repo. Breaking changes Errors in render are not re-thrown In previous versions of React, errors thrown during render were caught and rethrown. In DEV, we would also log to console.error , resulting in duplicate error logs. In React 19, we\u2019ve improved how errors are handled to reduce duplication by not re-throwing: - Uncaught Errors: Errors that are not caught by an Error Boundary are reported to window.reportError . - Caught Errors: Errors that are caught by an Error Boundary are reported to console.error . This change should not impact most apps, but if your production error reporting relies on errors being re-thrown, you may need to update your error handling. To support this, we\u2019ve added new methods to createRoot and hydrateRoot for custom error handling: const root = createRoot(container, { onUncaughtError: (error, errorInfo) => { // ... log error report }, onCaughtError: (error, errorInfo) => { // ... log error report } }); For more info, see the docs for createRoot and hydrateRoot . Removed deprecated React APIs Removed: propTypes and defaultProps for functions PropTypes were deprecated in April 2017 (v15.5.0). In React 19, we\u2019re removing the propType checks from the React package, and using them will be silently ignored. If you\u2019re using propTypes , we recommend migrating to TypeScript or another type-checking solution. We\u2019re also removing defaultProps from function components in place of ES6 default parameters. Class components will continue to support defaultProps since there is no ES6 alternative. // Before import PropTypes from 'prop-types'; function Heading({text}) { return <h1>{text}</h1>; } Heading.propTypes = { text: PropTypes.string, }; Heading.defaultProps = { text: 'Hello, world!', }; // After interface Props { text?: string; } function Heading({text = 'Hello, world!'}: Props) { return <h1>{text}</h1>; } Removed: Legacy Context using contextTypes and getChildContext Legacy Context was deprecated in October 2018 (v16.6.0). Legacy Context was only available in class components using the APIs contextTypes and getChildContext , and was replaced with contextType due to subtle bugs that were easy to miss. In React 19, we\u2019re removing Legacy Context to make React slightly smaller and faster. If you\u2019re still using Legacy Context in class components, you\u2019ll need to migrate to the new contextType API: // Before import PropTypes from 'prop-types'; class Parent extends React.Component { static childContextTypes = { foo: PropTypes.string.isRequired, }; getChildContext() { return { foo: 'bar' }; } render() { return <Child />; } } class Child extends React.Component { static contextTypes = { foo: PropTypes.string.isRequired, }; render() { return <div>{this.context.foo}</div>; } } // After const FooContext = React.createContext(); class Parent extends React.Component { render() { return ( <FooContext value='bar'> <Child /> </FooContext> ); } } class Child extends React.Component { static contextType = FooContext; render() { return <div>{this.context}</div>; } } Removed: string refs String refs were deprecated in March, 2018 (v16.3.0). Class components supported string refs before being replaced by ref callbacks due to multiple downsides. In React 19, we\u2019re removing string refs to make React simpler and easier to understand. If you\u2019re still using string refs in class components, you\u2019ll need to migrate to ref callbacks: // Before class MyComponent extends React.Component { componentDidMount() { this.refs.input.focus(); } render() { return <input ref='input' />; } } // After class MyComponent extends React.Component { componentDidMount() { this.input.focus(); } render() { return <input ref={input => this.input = input} />; } } Removed: Module pattern factories Module pattern factories were deprecated in August 2019 (v16.9.0). This pattern was rarely used and supporting it causes React to be slightly larger and slower than necessary. In React 19, we\u2019re removing support for module pattern factories, and you\u2019ll need to migrate to regular functions: // Before function FactoryComponent() { return { render() { return <div />; } } } // After function FactoryComponent() { return <div />; } Removed: React.createFactory createFactory was deprecated in February 2020 (v16.13.0). Using createFactory was common before broad support for JSX, but it\u2019s rarely used today and can be replaced with JSX. In React 19, we\u2019re removing createFactory and you\u2019ll need to migrate to JSX: // Before import { createFactory } from 'react'; const button = createFactory('button'); // After const button = <button />; Removed: react-test-renderer/shallow In React 18, we updated react-test-renderer/shallow to re-export react-shallow-renderer. In React 19, we\u2019re removing react-test-render/shallow to prefer installing the package directly: npm install react-shallow-renderer --save-dev - import ShallowRenderer from 'react-test-renderer/shallow'; + import ShallowRenderer from 'react-shallow-renderer'; Removed deprecated React DOM APIs Removed: react-dom/test-utils We\u2019ve moved act from react-dom/test-utils to the react package: ReactDOMTestUtils.act is deprecated in favor of React.act . Import act from react instead of react-dom/test-utils . See https://react.dev/warnings/react-dom-test-utils for more info.To fix this warning, you can import act from react : - import {act} from 'react-dom/test-utils' + import {act} from 'react'; All other test-utils functions have been removed. These utilities were uncommon, and made it too easy to depend on low level implementation details of your components and React. In React 19, these functions will error when called and their exports will be removed in a future version. See the warning page for alternatives. Removed: ReactDOM.render ReactDOM.render was deprecated in March 2022 (v18.0.0). In React 19, we\u2019re removing ReactDOM.render and you\u2019ll need to migrate to using ReactDOM.createRoot : // Before import {render} from 'react-dom'; render(<App />, document.getElementById('root')); // After import {createRoot} from 'react-dom/client'; const root = createRoot(document.getElementById('root')); root.render(<App />); Removed: ReactDOM.hydrate ReactDOM.hydrate was deprecated in March 2022 (v18.0.0). In React 19, we\u2019re removing ReactDOM.hydrate you\u2019ll need to migrate to using ReactDOM.hydrateRoot , // Before import {hydrate} from 'react-dom'; hydrate(<App />, document.getElementById('root')); // After import {hydrateRoot} from 'react-dom/client'; hydrateRoot(document.getElementById('root'), <App />); Removed: unmountComponentAtNode ReactDOM.unmountComponentAtNode was deprecated in March 2022 (v18.0.0). In React 19, you\u2019ll need to migrate to using root.unmount() . // Before unmountComponentAtNode(document.getElementById('root')); // After root.unmount(); For more see root.unmount() for createRoot and hydrateRoot . Removed: ReactDOM.findDOMNode ReactDOM.findDOMNode was deprecated in October 2018 (v16.6.0). We\u2019re removing findDOMNode because it was a legacy escape hatch that was slow to execute, fragile to refactoring, only returned the first child, and broke abstraction levels (see more here). You can replace ReactDOM.findDOMNode with DOM refs: // Before import {findDOMNode} from 'react-dom'; function AutoselectingInput() { useEffect(() => { const input = findDOMNode(this); input.select() }, []); return <input defaultValue=\"Hello\" />; } // After function AutoselectingInput() { const ref = useRef(null); useEffect(() => { ref.current.select(); }, []); return <input ref={ref} defaultValue=\"Hello\" /> } New deprecations Deprecated: element.ref React 19 supports ref as a prop, so we\u2019re deprecating the element.ref in place of element.props.ref . Accessing element.ref will warn: Deprecated: react-test-renderer We are deprecating react-test-renderer because it implements its own renderer environment that doesn\u2019t match the environment users use, promotes testing implementation details, and relies on introspection of React\u2019s internals. The test renderer was created before there were more viable testing strategies available like React Testing Library, and we now recommend using a modern testing library instead. In React 19, react-test-renderer logs a deprecation warning, and has switched to concurrent rendering. We recommend migrating your tests to @testing-library/react or @testing-library/react-native for a modern and well supported testing experience. Notable changes StrictMode changes React 19 includes several fixes and improvements to Strict Mode. When double rendering in Strict Mode in development, useMemo and useCallback will reuse the memoized results from the first render during the second render. Components that are already Strict Mode compatible should not notice a difference in behavior. As with all Strict Mode behaviors, these features are designed to proactively surface bugs in your components during development so you can fix them before they are shipped to production. For example, during development, Strict Mode will double-invoke ref callback functions on initial mount, to simulate what happens when a mounted component is replaced by a Suspense fallback. Improvements to Suspense In React 19, when a component suspends, React will immediately commit the fallback of the nearest Suspense boundary without waiting for the entire sibling tree to render. After the fallback commits, React schedules another render for the suspended siblings to \u201cpre-warm\u201d lazy requests in the rest of the tree: This change means Suspense fallbacks display faster, while still warming lazy requests in the suspended tree. UMD builds removed UMD was widely used in the past as a convenient way to load React without a build step. Now, there are modern alternatives for loading modules as scripts in HTML documents. Starting with React 19, React will no longer produce UMD builds to reduce the complexity of its testing and release process. To load React 19 with a script tag, we recommend using an ESM-based CDN such as esm.sh. <script type=\"module\"> import React from \"https://esm.sh/react@19/?dev\" import ReactDOMClient from \"https://esm.sh/react-dom@19/client?dev\" ... </script> Libraries depending on React internals may block upgrades This release includes changes to React internals that may impact libraries that ignore our pleas to not use internals like SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED . These changes are necessary to land improvements in React 19, and will not break libraries that follow our guidelines. Based on our Versioning Policy, these updates are not listed as breaking changes, and we are not including docs for how to upgrade them. The recommendation is to remove any code that depends on internals. To reflect the impact of using internals, we have renamed the SECRET_INTERNALS suffix to: _DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE In the future we will more aggressively block accessing internals from React to discourage usage and ensure users are not blocked from upgrading. TypeScript changes Removed deprecated TypeScript types We\u2019ve cleaned up the TypeScript types based on the removed APIs in React 19. Some of the removed have types been moved to more relevant packages, and others are no longer needed to describe React\u2019s behavior. Check out types-react-codemod for a list of supported replacements. If you feel a codemod is missing, it can be tracked in the list of missing React 19 codemods. ref cleanups required This change is included in the react-19 codemod preset as no-implicit-ref-callback-return . Due to the introduction of ref cleanup functions, returning anything else from a ref callback will now be rejected by TypeScript. The fix is usually to stop using implicit returns: - <div ref={current => (instance = current)} /> + <div ref={current => {instance = current}} /> The original code returned the instance of the HTMLDivElement and TypeScript wouldn\u2019t know if this was supposed to be a cleanup function or not. useRef requires an argument This change is included in the react-19 codemod preset as refobject-defaults . A long-time complaint of how TypeScript and React work has been useRef . We\u2019ve changed the types so that useRef now requires an argument. This significantly simplifies its type signature. It\u2019ll now behave more like createContext . // @ts-expect-error: Expected 1 argument but saw none useRef(); // Passes useRef(undefined); // @ts-expect-error: Expected 1 argument but saw none createContext(); // Passes createContext(undefined); This now also means that all refs are mutable. You\u2019ll no longer hit the issue where you can\u2019t mutate a ref because you initialised it with null : const ref = useRef<number>(null); // Cannot assign to 'current' because it is a read-only property ref.current = 1; MutableRef is now deprecated in favor of a single RefObject type which useRef will always return: interface RefObject<T> { current: T } declare function useRef<T>: RefObject<T> useRef still has a convenience overload for useRef<T>(null) that automatically returns RefObject<T | null> . To ease migration due to the required argument for useRef , a convenience overload for useRef(undefined) was added that automatically returns RefObject<T | undefined> . Check out [RFC] Make all refs mutable for prior discussions about this change. Changes to the ReactElement TypeScript type This change is included in the react-element-default-any-props codemod. The props of React elements now default to unknown instead of any if the element is typed as ReactElement . This does not affect you if you pass a type argument to ReactElement : type Example2 = ReactElement<{ id: string }>[\"props\"]; // ^? { id: string } But if you relied on the default, you now have to handle unknown : type Example = ReactElement[\"props\"]; // ^? Before, was 'any', now 'unknown' You should only need it if you have a lot of legacy code relying on unsound access of element props. Element introspection only exists as an escape hatch, and you should make it explicit that your props access is unsound via an explicit any . The JSX namespace in TypeScript This change is included in the react-19 codemod preset as scoped-jsx A long-time request is to remove the global JSX namespace from our types in favor of React.JSX . This helps prevent pollution of global types which prevents conflicts between different UI libraries that leverage JSX. You\u2019ll now need to wrap module augmentation of the JSX namespace in `declare module \u201d\u2026\u201d: // global.d.ts + declare module \"react\" { namespace JSX { interface IntrinsicElements { \"my-element\": { myElementProps: string; }; } } + } The exact module specifier depends on the JSX runtime you specified in the compilerOptions of your tsconfig.json : - For \"jsx\": \"react-jsx\" it would bereact/jsx-runtime . - For \"jsx\": \"react-jsxdev\" it would bereact/jsx-dev-runtime . - For \"jsx\": \"react\" and\"jsx\": \"preserve\" it would bereact . Better useReducer typings useReducer now has improved type inference thanks to @mfp22. However, this required a breaking change where useReducer doesn\u2019t accept the full reducer type as a type parameter but instead either needs none (and rely on contextual typing) or needs both the state and action type. The new best practice is not to pass type arguments to useReducer . - useReducer<React.Reducer<State, Action>>(reducer) + useReducer(reducer) This may not work in edge cases where you can explicitly type the state and action, by passing in the Action in a tuple: - useReducer<React.Reducer<State, Action>>(reducer) + useReducer<State, [Action]>(reducer) If you define the reducer inline, we encourage to annotate the function parameters instead: - useReducer<React.Reducer<State, Action>>((state, action) => state) + useReducer((state: State, action: Action) => state) This is also what you\u2019d also have to do if you move the reducer outside of the useReducer call: const reducer = (state: State, action: Action) => state; Changelog Other breaking changes - react-dom: Error for javascript URLs in src andhref #26507 - react-dom: Remove errorInfo.digest fromonRecoverableError #28222 - react-dom: Remove unstable_flushControlled #26397 - react-dom: Remove unstable_createEventHandle #28271 - react-dom: Remove unstable_renderSubtreeIntoContainer #28271 - react-dom: Remove unstable_runWithPriority #28271 - react-is: Remove deprecated methods from react-is 28224 Other notable changes - react: Batch sync, default and continuous lanes #25700 - react: Don\u2019t prerender siblings of suspended component #26380 - react: Detect infinite update loops caused by render phase updates #26625 - react-dom: Transitions in popstate are now synchronous #26025 - react-dom: Remove layout effect warning during SSR #26395 - react-dom: Warn and don\u2019t set empty string for src/href (except anchor tags) #28124 For a full list of changes, please see the Changelog. Thanks to Andrew Clark, Eli White, Jack Pope, Jan Kassens, Josh Story, Matt Carroll, Noah Lemen, Sophie Alpert, and Sebastian Silbermann for reviewing and editing this post."},
{"source": "https://react.dev/blog/2024/12/05/react-19", "title": "React v19 \u2013 React", "text": "React v19 December 05, 2024 by The React Team React v19 is now available on npm! In our React 19 Upgrade Guide, we shared step-by-step instructions for upgrading your app to React 19. In this post, we\u2019ll give an overview of the new features in React 19, and how you can adopt them. For a list of breaking changes, see the Upgrade Guide. What\u2019s new in React 19 Actions A common use case in React apps is to perform a data mutation and then update state in response. For example, when a user submits a form to change their name, you will make an API request, and then handle the response. In the past, you would need to handle pending states, errors, optimistic updates, and sequential requests manually. For example, you could handle the pending and error state in useState : // Before Actions function UpdateName({}) { const [name, setName] = useState(\"\"); const [error, setError] = useState(null); const [isPending, setIsPending] = useState(false); const handleSubmit = async () => { setIsPending(true); const error = await updateName(name); setIsPending(false); if (error) { setError(error); return; } redirect(\"/path\"); }; return ( <div> <input value={name} onChange={(event) => setName(event.target.value)} /> <button onClick={handleSubmit} disabled={isPending}> Update </button> {error && <p>{error}</p>} </div> ); } In React 19, we\u2019re adding support for using async functions in transitions to handle pending states, errors, forms, and optimistic updates automatically. For example, you can use useTransition to handle the pending state for you: // Using pending state from Actions function UpdateName({}) { const [name, setName] = useState(\"\"); const [error, setError] = useState(null); const [isPending, startTransition] = useTransition(); const handleSubmit = () => { startTransition(async () => { const error = await updateName(name); if (error) { setError(error); return; } redirect(\"/path\"); }) }; return ( <div> <input value={name} onChange={(event) => setName(event.target.value)} /> <button onClick={handleSubmit} disabled={isPending}> Update </button> {error && <p>{error}</p>} </div> ); } The async transition will immediately set the isPending state to true, make the async request(s), and switch isPending to false after any transitions. This allows you to keep the current UI responsive and interactive while the data is changing. Building on top of Actions, React 19 introduces useOptimistic to manage optimistic updates, and a new hook React.useActionState to handle common cases for Actions. In react-dom we\u2019re adding <form> Actions to manage forms automatically and useFormStatus to support the common cases for Actions in forms. In React 19, the above example can be simplified to: // Using <form> Actions and useActionState function ChangeName({ name, setName }) { const [error, submitAction, isPending] = useActionState( async (previousState, formData) => { const error = await updateName(formData.get(\"name\")); if (error) { return error; } redirect(\"/path\"); return null; }, null, ); return ( <form action={submitAction}> <input type=\"text\" name=\"name\" /> <button type=\"submit\" disabled={isPending}>Update</button> {error && <p>{error}</p>} </form> ); } In the next section, we\u2019ll break down each of the new Action features in React 19. New hook: useActionState To make the common cases easier for Actions, we\u2019ve added a new hook called useActionState : const [error, submitAction, isPending] = useActionState( async (previousState, newName) => { const error = await updateName(newName); if (error) { // You can return any result of the action. // Here, we return only the error. return error; } // handle success return null; }, null, ); useActionState accepts a function (the \u201cAction\u201d), and returns a wrapped Action to call. This works because Actions compose. When the wrapped Action is called, useActionState will return the last result of the Action as data , and the pending state of the Action as pending . For more information, see the docs for useActionState . React DOM: <form> Actions Actions are also integrated with React 19\u2019s new <form> features for react-dom . We\u2019ve added support for passing functions as the action and formAction props of <form> , <input> , and <button> elements to automatically submit forms with Actions: <form action={actionFunction}> When a <form> Action succeeds, React will automatically reset the form for uncontrolled components. If you need to reset the <form> manually, you can call the new requestFormReset React DOM API. For more information, see the react-dom docs for <form> , <input> , and <button> . React DOM: New hook: useFormStatus In design systems, it\u2019s common to write design components that need access to information about the <form> they\u2019re in, without drilling props down to the component. This can be done via Context, but to make the common case easier, we\u2019ve added a new hook useFormStatus : import {useFormStatus} from 'react-dom'; function DesignButton() { const {pending} = useFormStatus(); return <button type=\"submit\" disabled={pending} /> } useFormStatus reads the status of the parent <form> as if the form was a Context provider. For more information, see the react-dom docs for useFormStatus . New hook: useOptimistic Another common UI pattern when performing a data mutation is to show the final state optimistically while the async request is underway. In React 19, we\u2019re adding a new hook called useOptimistic to make this easier: function ChangeName({currentName, onUpdateName}) { const [optimisticName, setOptimisticName] = useOptimistic(currentName); const submitAction = async formData => { const newName = formData.get(\"name\"); setOptimisticName(newName); const updatedName = await updateName(newName); onUpdateName(updatedName); }; return ( <form action={submitAction}> <p>Your name is: {optimisticName}</p> <p> <label>Change Name:</label> <input type=\"text\" name=\"name\" disabled={currentName !== optimisticName} /> </p> </form> ); } The useOptimistic hook will immediately render the optimisticName while the updateName request is in progress. When the update finishes or errors, React will automatically switch back to the currentName value. For more information, see the docs for useOptimistic . New API: use In React 19 we\u2019re introducing a new API to read resources in render: use . For example, you can read a promise with use , and React will Suspend until the promise resolves: import {use} from 'react'; function Comments({commentsPromise}) { // `use` will suspend until the promise resolves. const comments = use(commentsPromise); return comments.map(comment => <p key={comment.id}>{comment}</p>); } function Page({commentsPromise}) { // When `use` suspends in Comments, // this Suspense boundary will be shown. return ( <Suspense fallback={<div>Loading...</div>}> <Comments commentsPromise={commentsPromise} /> </Suspense> ) } You can also read context with use , allowing you to read Context conditionally such as after early returns: import {use} from 'react'; import ThemeContext from './ThemeContext' function Heading({children}) { if (children == null) { return null; } // This would not work with useContext // because of the early return. const theme = use(ThemeContext); return ( <h1 style={{color: theme.color}}> {children} </h1> ); } The use API can only be called in render, similar to hooks. Unlike hooks, use can be called conditionally. In the future we plan to support more ways to consume resources in render with use . For more information, see the docs for use . New React DOM Static APIs We\u2019ve added two new APIs to react-dom/static for static site generation: These new APIs improve on renderToString by waiting for data to load for static HTML generation. They are designed to work with streaming environments like Node.js Streams and Web Streams. For example, in a Web Stream environment, you can prerender a React tree to static HTML with prerender : import { prerender } from 'react-dom/static'; async function handler(request) { const {prelude} = await prerender(<App />, { bootstrapScripts: ['/main.js'] }); return new Response(prelude, { headers: { 'content-type': 'text/html' }, }); } Prerender APIs will wait for all data to load before returning the static HTML stream. Streams can be converted to strings, or sent with a streaming response. They do not support streaming content as it loads, which is supported by the existing React DOM server rendering APIs. For more information, see React DOM Static APIs. React Server Components Server Components Server Components are a new option that allows rendering components ahead of time, before bundling, in an environment separate from your client application or SSR server. This separate environment is the \u201cserver\u201d in React Server Components. Server Components can run once at build time on your CI server, or they can be run for each request using a web server. React 19 includes all of the React Server Components features included from the Canary channel. This means libraries that ship with Server Components can now target React 19 as a peer dependency with a react-server export condition for use in frameworks that support the Full-stack React Architecture. For more, see the docs for React Server Components. Server Actions Server Actions allow Client Components to call async functions executed on the server. When a Server Action is defined with the \"use server\" directive, your framework will automatically create a reference to the server function, and pass that reference to the Client Component. When that function is called on the client, React will send a request to the server to execute the function, and return the result. Server Actions can be created in Server Components and passed as props to Client Components, or they can be imported and used in Client Components. For more, see the docs for React Server Actions. Improvements in React 19 ref as a prop Starting in React 19, you can now access ref as a prop for function components: function MyInput({placeholder, ref}) { return <input placeholder={placeholder} ref={ref} /> } //... <MyInput ref={ref} /> New function components will no longer need forwardRef , and we will be publishing a codemod to automatically update your components to use the new ref prop. In future versions we will deprecate and remove forwardRef . Diffs for hydration errors We also improved error reporting for hydration errors in react-dom . For example, instead of logging multiple errors in DEV without any information about the mismatch: We now log a single message with a diff of the mismatch: if (typeof window !== 'undefined') . - Variable input such as Date.now() or Math.random() which changes each time it\u2019s called. - Date formatting in a user\u2019s locale which doesn\u2019t match the server. - External changing data without sending a snapshot of it along with the HTML. - Invalid HTML tag nesting. It can also happen if the client has a browser extension installed which messes with the HTML before React loaded. https://react.dev/link/hydration-mismatch <App> <span> + Client - Server at throwOnHydrationMismatch \u2026<Context> as a provider In React 19, you can render <Context> as a provider instead of <Context.Provider> : const ThemeContext = createContext(''); function App({children}) { return ( <ThemeContext value=\"dark\"> {children} </ThemeContext> ); } New Context providers can use <Context> and we will be publishing a codemod to convert existing providers. In future versions we will deprecate <Context.Provider> . Cleanup functions for refs We now support returning a cleanup function from ref callbacks: <input ref={(ref) => { // ref created // NEW: return a cleanup function to reset // the ref when element is removed from DOM. return () => { // ref cleanup }; }} /> When the component unmounts, React will call the cleanup function returned from the ref callback. This works for DOM refs, refs to class components, and useImperativeHandle . Due to the introduction of ref cleanup functions, returning anything else from a ref callback will now be rejected by TypeScript. The fix is usually to stop using implicit returns, for example: - <div ref={current => (instance = current)} /> + <div ref={current => {instance = current}} /> The original code returned the instance of the HTMLDivElement and TypeScript wouldn\u2019t know if this was supposed to be a cleanup function or if you didn\u2019t want to return a cleanup function. You can codemod this pattern with no-implicit-ref-callback-return . useDeferredValue initial value We\u2019ve added an initialValue option to useDeferredValue : function Search({deferredValue}) { // On initial render the value is ''. // Then a re-render is scheduled with the deferredValue. const value = useDeferredValue(deferredValue, ''); return ( <Results query={value} /> ); } When initialValue is provided, useDeferredValue will return it as value for the initial render of the component, and schedules a re-render in the background with the deferredValue returned. For more, see useDeferredValue . Support for Document Metadata In HTML, document metadata tags like <title> , <link> , and <meta> are reserved for placement in the <head> section of the document. In React, the component that decides what metadata is appropriate for the app may be very far from the place where you render the <head> or React does not render the <head> at all. In the past, these elements would need to be inserted manually in an effect, or by libraries like react-helmet , and required careful handling when server rendering a React application. In React 19, we\u2019re adding support for rendering document metadata tags in components natively: function BlogPost({post}) { return ( <article> <h1>{post.title}</h1> <title>{post.title}</title> <meta name=\"author\" content=\"Josh\" /> <link rel=\"author\" href=\"https://twitter.com/joshcstory/\" /> <meta name=\"keywords\" content={post.keywords} /> <p> Eee equals em-see-squared... </p> </article> ); } When React renders this component, it will see the <title> <link> and <meta> tags, and automatically hoist them to the <head> section of document. By supporting these metadata tags natively, we\u2019re able to ensure they work with client-only apps, streaming SSR, and Server Components. For more info, see the docs for <title> , <link> , and <meta> . Support for stylesheets Stylesheets, both externally linked (<link rel=\"stylesheet\" href=\"...\"> ) and inline (<style>...</style> ), require careful positioning in the DOM due to style precedence rules. Building a stylesheet capability that allows for composability within components is hard, so users often end up either loading all of their styles far from the components that may depend on them, or they use a style library which encapsulates this complexity. In React 19, we\u2019re addressing this complexity and providing even deeper integration into Concurrent Rendering on the Client and Streaming Rendering on the Server with built in support for stylesheets. If you tell React the precedence of your stylesheet it will manage the insertion order of the stylesheet in the DOM and ensure that the stylesheet (if external) is loaded before revealing content that depends on those style rules. function ComponentOne() { return ( <Suspense fallback=\"loading...\"> <link rel=\"stylesheet\" href=\"foo\" precedence=\"default\" /> <link rel=\"stylesheet\" href=\"bar\" precedence=\"high\" /> <article class=\"foo-class bar-class\"> {...} </article> </Suspense> ) } function ComponentTwo() { return ( <div> <p>{...}</p> <link rel=\"stylesheet\" href=\"baz\" precedence=\"default\" /> <-- will be inserted between foo & bar </div> ) } During Server Side Rendering React will include the stylesheet in the <head> , which ensures that the browser will not paint until it has loaded. If the stylesheet is discovered late after we\u2019ve already started streaming, React will ensure that the stylesheet is inserted into the <head> on the client before revealing the content of a Suspense boundary that depends on that stylesheet. During Client Side Rendering React will wait for newly rendered stylesheets to load before committing the render. If you render this component from multiple places within your application React will only include the stylesheet once in the document: function App() { return <> <ComponentOne /> ... <ComponentOne /> // won't lead to a duplicate stylesheet link in the DOM </> } For users accustomed to loading stylesheets manually this is an opportunity to locate those stylesheets alongside the components that depend on them allowing for better local reasoning and an easier time ensuring you only load the stylesheets that you actually depend on. Style libraries and style integrations with bundlers can also adopt this new capability so even if you don\u2019t directly render your own stylesheets, you can still benefit as your tools are upgraded to use this feature. For more details, read the docs for <link> and <style> . Support for async scripts In HTML normal scripts (<script src=\"...\"> ) and deferred scripts (<script defer=\"\" src=\"...\"> ) load in document order which makes rendering these kinds of scripts deep within your component tree challenging. Async scripts (<script async=\"\" src=\"...\"> ) however will load in arbitrary order. In React 19 we\u2019ve included better support for async scripts by allowing you to render them anywhere in your component tree, inside the components that actually depend on the script, without having to manage relocating and deduplicating script instances. function MyComponent() { return ( <div> <script async={true} src=\"...\" /> Hello World </div> ) } function App() { <html> <body> <MyComponent> ... <MyComponent> // won't lead to duplicate script in the DOM </body> </html> } In all rendering environments, async scripts will be deduplicated so that React will only load and execute the script once even if it is rendered by multiple different components. In Server Side Rendering, async scripts will be included in the <head> and prioritized behind more critical resources that block paint such as stylesheets, fonts, and image preloads. For more details, read the docs for <script> . Support for preloading resources During initial document load and on client side updates, telling the Browser about resources that it will likely need to load as early as possible can have a dramatic effect on page performance. React 19 includes a number of new APIs for loading and preloading Browser resources to make it as easy as possible to build great experiences that aren\u2019t held back by inefficient resource loading. import { prefetchDNS, preconnect, preload, preinit } from 'react-dom' function MyComponent() { preinit('https://.../path/to/some/script.js', {as: 'script' }) // loads and executes this script eagerly preload('https://.../path/to/font.woff', { as: 'font' }) // preloads this font preload('https://.../path/to/stylesheet.css', { as: 'style' }) // preloads this stylesheet prefetchDNS('https://...') // when you may not actually request anything from this host preconnect('https://...') // when you will request something but aren't sure what } <!-- the above would result in the following DOM/HTML --> <html> <head> <!-- links/scripts are prioritized by their utility to early loading, not call order --> <link rel=\"prefetch-dns\" href=\"https://...\"> <link rel=\"preconnect\" href=\"https://...\"> <link rel=\"preload\" as=\"font\" href=\"https://.../path/to/font.woff\"> <link rel=\"preload\" as=\"style\" href=\"https://.../path/to/stylesheet.css\"> <script async=\"\" src=\"https://.../path/to/some/script.js\"></script> </head> <body> ... </body> </html> These APIs can be used to optimize initial page loads by moving discovery of additional resources like fonts out of stylesheet loading. They can also make client updates faster by prefetching a list of resources used by an anticipated navigation and then eagerly preloading those resources on click or even on hover. For more details see Resource Preloading APIs. Compatibility with third-party scripts and extensions We\u2019ve improved hydration to account for third-party scripts and browser extensions. When hydrating, if an element that renders on the client doesn\u2019t match the element found in the HTML from the server, React will force a client re-render to fix up the content. Previously, if an element was inserted by third-party scripts or browser extensions, it would trigger a mismatch error and client render. In React 19, unexpected tags in the <head> and <body> will be skipped over, avoiding the mismatch errors. If React needs to re-render the entire document due to an unrelated hydration mismatch, it will leave in place stylesheets inserted by third-party scripts and browser extensions. Better error reporting We improved error handling in React 19 to remove duplication and provide options for handling caught and uncaught errors. For example, when there\u2019s an error in render caught by an Error Boundary, previously React would throw the error twice (once for the original error, then again after failing to automatically recover), and then call console.error with info about where the error occurred. This resulted in three errors for every caught error: In React 19, we log a single error with all the error information included: Additionally, we\u2019ve added two new root options to complement onRecoverableError : onCaughtError : called when React catches an error in an Error Boundary.onUncaughtError : called when an error is thrown and not caught by an Error Boundary.onRecoverableError : called when an error is thrown and automatically recovered. For more info and examples, see the docs for createRoot and hydrateRoot . Support for Custom Elements React 19 adds full support for custom elements and passes all tests on Custom Elements Everywhere. In past versions, using Custom Elements in React has been difficult because React treated unrecognized props as attributes rather than properties. In React 19, we\u2019ve added support for properties that works on the client and during SSR with the following strategy: - Server Side Rendering: props passed to a custom element will render as attributes if their type is a primitive value like string ,number , or the value istrue . Props with non-primitive types likeobject ,symbol ,function , or valuefalse will be omitted. - Client Side Rendering: props that match a property on the Custom Element instance will be assigned as properties, otherwise they will be assigned as attributes. Thanks to Joey Arhar for driving the design and implementation of Custom Element support in React. How to upgrade See the React 19 Upgrade Guide for step-by-step instructions and a full list of breaking and notable changes. Note: this post was originally published 04/25/2024 and has been updated to 12/05/2024 with the stable release."}]