[{"source": "https://tailwindcss.com/blog/tailwindcss-v4", "title": "Tailwind CSS v4.0", "text": "Holy shit it's actually done \u2014 we just tagged Tailwind CSS v4.0. Tailwind CSS v4.0 is an all-new version of the framework optimized for performance and flexibility, with a reimagined configuration and customization experience, and taking full advantage of the latest advancements the web platform has to offer. - New high-performance engine \u2014 where full builds are up to 5x faster, and incremental builds are over 100x faster \u2014 and measured in microseconds. - Designed for the modern web \u2014 built on cutting-edge CSS features like cascade layers, registered custom properties with @property , andcolor-mix() . - Simplified installation \u2014 fewer dependencies, zero configuration, and just a single line of code in your CSS file. - First-party Vite plugin \u2014 tight integration for maximum performance and minimum configuration. - Automatic content detection \u2014 all of your template files are discovered automatically, with no configuration required. - Built-in import support \u2014 no additional tooling necessary to bundle multiple CSS files. - CSS-first configuration \u2014 a reimagined developer experience where you customize and extend the framework directly in CSS instead of a JavaScript configuration file. - CSS theme variables \u2014 all of your design tokens exposed as native CSS variables so you can access them anywhere. - Dynamic utility values and variants \u2014 stop guessing what values exist in your spacing scale, or extending your configuration for things like basic data attributes. - Modernized P3 color palette \u2014 a redesigned, more vivid color palette that takes full advantage of modern display technology. - Container queries \u2014 first-class APIs for styling elements based on their container size, no plugins required. - New 3D transform utilities \u2014 transform elements in 3D space directly in your HTML. - Expanded gradient APIs \u2014 radial and conic gradients, interpolation modes, and more. - @starting-style support \u2014 a new variant you can use to create enter and exit transitions, without the need for JavaScript. - not-* variant \u2014 style an element only when it doesn't match another variant, custom selector, or media or feature query. - Even more new utilities and variants \u2014 including support for color-scheme ,field-sizing , complex shadows,inert , and more. Start using Tailwind CSS v4.0 today by installing it in a new project, or playing with it directly in the browser on Tailwind Play. For existing projects, we've published a comprehensive upgrade guide and built an automated upgrade tool to get you on the latest version as quickly and painlessly as possible. New high-performance engine Tailwind CSS v4.0 is a ground-up rewrite of the framework, taking everything we've learned about the architecture over the years and optimizing it to be as fast as possible. When benchmarking it on our own projects, we've found full rebuilds to be over 3.5x faster, and incremental builds to be over 8x faster. Here are the median build times we saw when we benchmarked Tailwind CSS v4.0 against Catalyst: | v3.4 | v4.0 | Improvement | | |---|---|---|---| | Full build | 378ms | 100ms | 3.78x | | Incremental rebuild with new CSS | 44ms | 5ms | 8.8x | | Incremental rebuild with no new CSS | 35ms | 192\u00b5s | 182x | The most impressive improvement is on incremental builds that don't actually need to compile any new CSS \u2014 these builds are over 100x faster and complete in microseconds. And the longer you work on a project, the more of these builds you run into because you're just using classes you've already used before, like flex , col-span-2 , or font-bold . Designed for the modern web The platform has evolved a lot since we released Tailwind CSS v3.0, and v4.0 takes full advantage of many of these improvements. @layer theme, base, components, utilities;@layer utilities { .mx-6 { margin-inline: calc(var(--spacing) * 6); } .bg-blue-500\\/50 { background-color: color-mix(in oklab, var(--color-blue-500) 50%, transparent); }}@property --tw-gradient-from { syntax: \"<color>\"; inherits: false; initial-value: #0000;} We're leveraging modern CSS features like: - Native cascade layers \u2014 giving us more control than ever over how different style rules interact with each other. - Registered custom properties \u2014 making it possible to do things like animate gradients, and significantly improving performance on large pages. - color-mix() \u2014 which lets us adjust the opacity of any color value, including CSS variables and currentColor . - Logical properties \u2014 simplifying RTL support and reducing the size of your generated CSS. Many of these features have even simplified Tailwind internally, reducing the surface area for bugs and making the framework easier for us to maintain. Simplified installation We've streamlined the setup process a ton in v4.0, reducing the number of steps and removing a lot of boilerplate. npm i tailwindcss @tailwindcss/postcss; export default { plugins: [\"@tailwindcss/postcss\"],}; @import \"tailwindcss\"; With the improvements we've made to this process for v4.0, Tailwind feels more light-weight than ever: - Just one-line of CSS \u2014 no more @tailwind directives, just add@import \"tailwindcss\" and start building. - Zero configuration \u2014 you can start using the framework without configuring anything, not even the paths to your template files. - No external plugins required \u2014 we bundle @import rules for you out of the box, and use Lightning CSS under the hood for vendor prefixing and modern syntax transforms. Sure you only go through this once per project, but it adds up when you're starting and abandoning a different side-project every weekend. First-party Vite plugin If you're a Vite user, you can now integrate Tailwind using @tailwindcss/vite instead of PostCSS: import { defineConfig } from \"vite\";import tailwindcss from \"@tailwindcss/vite\";export default defineConfig({ plugins: [ tailwindcss(), ],}); Tailwind CSS v4.0 is incredibly fast when used as a PostCSS plugin, but you'll get even better performance using the Vite plugin. Automatic content detection You know how you always had to configure that annoying content array in Tailwind CSS v3? In v4.0, we came up with a bunch of heuristics for detecting all of that stuff automatically so you don\u2019t have to configure it at all. For example, we automatically ignore anything in your .gitignore file to avoid scanning dependencies or generated files that aren\u2019t under version control: /node_modules/coverage/.next//build We also automatically ignore all binary extensions like images, videos, .zip files, and more. And if you ever need to explicitly add a source that's excluded by default, you can always add it with the @source directive, right in your CSS file: @import \"tailwindcss\";@source \"../node_modules/@my-company/ui-lib\"; The @source directive uses the same heuristics under the hood, so it will exclude binary file types for example as well, without you having to specify all of the extensions to scan explicitly. Learn more about in our new documentation on detecting classes in source files. Built-in import support Before v4.0, if you wanted to inline other CSS files using @import you'd have to configure another plugin like postcss-import to handle it for you. Now we handle this out of the box, so you don't need any other tools: export default { plugins: [ \"postcss-import\", \"@tailwindcss/postcss\", ],}; Our import system is purpose-built for Tailwind CSS, so we've also been able to make it even faster by tightly integrating it with our engine. CSS-first configuration One of the biggest changes in Tailwind CSS v4.0 is the shift from configuring your project in JavaScript to configuring it in CSS. Instead of a tailwind.config.js file, you can configure all of your customizations directly in the CSS file where you import Tailwind, giving you one less file to worry about in your project: @import \"tailwindcss\";@theme { --font-display: \"Satoshi\", \"sans-serif\"; --breakpoint-3xl: 1920px; --color-avocado-100: oklch(0.99 0 0); --color-avocado-200: oklch(0.98 0.04 113.22); --color-avocado-300: oklch(0.94 0.11 115.03); --color-avocado-400: oklch(0.92 0.19 114.08); --color-avocado-500: oklch(0.84 0.18 117.33); --color-avocado-600: oklch(0.53 0.12 118.34); --ease-fluid: cubic-bezier(0.3, 0, 0, 1); --ease-snappy: cubic-bezier(0.2, 0, 0, 1); /* ... */} The new CSS-first configuration lets you do just about everything you could do in your tailwind.config.js file, including configuring your design tokens, defining custom utilities and variants, and more. To learn more about how it all works, read the new theme variables documentation. CSS theme variables Tailwind CSS v4.0 takes all of your design tokens and makes them available as CSS variables by default, so you can reference any value you need at run-time using just CSS. Using the example @theme from earlier, all of these values will be added to your CSS to as regular custom properties: :root { --font-display: \"Satoshi\", \"sans-serif\"; --breakpoint-3xl: 1920px; --color-avocado-100: oklch(0.99 0 0); --color-avocado-200: oklch(0.98 0.04 113.22); --color-avocado-300: oklch(0.94 0.11 115.03); --color-avocado-400: oklch(0.92 0.19 114.08); --color-avocado-500: oklch(0.84 0.18 117.33); --color-avocado-600: oklch(0.53 0.12 118.34); --ease-fluid: cubic-bezier(0.3, 0, 0, 1); --ease-snappy: cubic-bezier(0.2, 0, 0, 1); /* ... */} This makes it easy to reuse these values as inline styles or pass them to libraries like Motion to animate them. Dynamic utility values and variants We've simplified the way many utilities and variants work in v4.0 by effectively allowing them to accept certain types of arbitrary values, without the need for any configuration or dropping down to the arbitrary value syntax. For example, in Tailwind CSS v4.0 you can create grids of any size out of the box: <div class=\"grid grid-cols-15\"> <!-- ... --></div> You can also target custom boolean data attributes without needing to define them: <div data-current class=\"opacity-75 data-current:opacity-100\"> <!-- ... --></div> Even spacing utilities like px-* , mt-* , w-* , h-* , and more are now dynamically derived from a single spacing scale variable and accept any value out of the box: @layer theme { :root { --spacing: 0.25rem; }}@layer utilities { .mt-8 { margin-top: calc(var(--spacing) * 8); } .w-17 { width: calc(var(--spacing) * 17); } .pr-29 { padding-right: calc(var(--spacing) * 29); }} The upgrade tool we released alongside v4.0 will even simplify most of these utilities for you automatically if it notices you using an arbitrary value that's no longer needed. Modernized P3 color palette We've upgraded the entire default color palette from rgb to oklch , taking advantage of the wider gamut to make the colors more vivid in places where we were previously limited by the sRGB color space. We've tried to keep the balance between all the colors the same as it was in v3, so even though we've refreshed things across the board, it shouldn't feel like a breaking change when upgrading your existing projects. Container queries We've brought container query support into core for v4.0, so you don't need the @tailwindcss/container-queries plugin anymore: <div class=\"@container\"> <div class=\"grid grid-cols-1 @sm:grid-cols-3 @lg:grid-cols-4\"> <!-- ... --> </div></div> We've also added support for max-width container queries using the new @max-* variant: <div class=\"@container\"> <div class=\"grid grid-cols-3 @max-md:grid-cols-1\"> <!-- ... --> </div></div> Like our regular breakpoint variants, you can also stack @min-* and @max-* variants to define container query ranges: <div class=\"@container\"> <div class=\"flex @min-md:@max-xl:hidden\"> <!-- ... --> </div></div> Learn more in our all-new container queries documentation. New 3D transform utilities We've finally added APIs for doing 3D transforms, like rotate-x-* , rotate-y-* , scale-z-* , translate-z-* , and tons more. Check out the updated transform-style , rotate , perspective , and perspective-origin documentation to get started. Expanded gradient APIs We've added a ton of new gradient features in v4.0, so you can pull off even fancier effects without having to write any custom CSS. Linear gradient angles Linear gradients now support angles as values, so you can use utilities like bg-linear-45 to create a gradient on a 45 degree angle: You may notice we've renamed bg-gradient-* to bg-linear-* too \u2014 you'll see why shortly! Gradient interpolation modifiers We've added the ability to control the color interpolation mode for gradients using a modifier, so a class like bg-linear-to-r/srgb interpolates using sRGB, and bg-linear-to-r/oklch interpolates using OKLCH: Using polar color spaces like OKLCH or HSL can lead to much more vivid gradients when the from-* and to-* colors are far apart on the color wheel. We're using OKLAB by default in v4.0 but you can always interpolate using a different color space by adding one of these modifiers. Conic and radial gradients We've added new bg-conic-* and bg-radial-* utilities for creating conic and radial gradients: These new utilities work alongside the existing from-* , via-* , and to-* utilities to let you create conic and radial gradients the same way you create linear gradients, and include modifiers for setting the color interpolation method and arbitrary value support for controlling details like the gradient position. @starting-style support The new starting variant adds support for the new CSS @starting-style feature, making it possible to transition element properties when an element is first displayed: With @starting-style , you can finally animate elements as they appear on the page without the need for any JavaScript at all. Browser support probably isn't quite there yet for most teams, but we're getting close! not-* variant We've added a new not-* variant which finally adds support for the CSS :not() pseudo-class: <div class=\"not-hover:opacity-75\"> <!-- ... --></div> .not-hover\\:opacity-75:not(*:hover) { opacity: 75%;}@media not (hover: hover) { .not-hover\\:opacity-75 { opacity: 75%; }} It does double duty and also lets you negate media queries and @supports queries: <div class=\"not-supports-hanging-punctuation:px-4\"> <!-- ... --></div> .not-supports-hanging-punctuation\\:px-4 { @supports not (hanging-punctuation: var(--tw)) { padding-inline: calc(var(--spacing) * 4); }} Check out the new not-* documentation to learn more. Even more new utilities and variants We've added a ton of other new utilities and variants to v4.0 too, including: - New inset-shadow-* andinset-ring-* utilities \u2014 making it possible to stack up to four layers of box shadows on a single element. - New field-sizing utilities \u2014 for auto-resizing textareas without writing a single line of JavaScript. - New color-scheme utilities \u2014 so you can finally get rid of those ugly light scrollbars in dark mode. - New font-stretch utilities \u2014 for carefully tweaking variable fonts that support different widths. - New inert variant \u2014 for styling non-interactive elements marked with theinert attribute. - New nth-* variants \u2014 for doing really clever things you'll eventually regret. - New in-* variant \u2014 which is a lot likegroup-* , but without the need for thegroup class. - Support for :popover-open \u2014 using the existingopen variant to also target open popovers. - New descendant variant \u2014 for styling all descendant elements, for better or for worse. Check out the relevant documentation for all of these features to learn more. And that's it \u2014 that's Tailwind CSS v4.0. It's been years of work to get to this point, but we're all extremely proud of this release and we can't wait to see what you build with it. Check it out, play with it, maybe even break it, and definitely let us know what you think. Just no bug reports until tomorrow please \u2014 let us at least enjoy one celebratory team dinner and maybe relax in the hot tub at this hotel for a bit believing that somehow we really did ship flawless software."},
{"source": "https://tailwindcss.com/blog/tailwindcss-v4-1", "title": "Tailwind CSS v4.1: Text shadows, masks, and tons more", "text": "I wasn't sure it would ever happen but we did it \u2014 we released a version of Tailwind CSS that includes text-shadow utilities. Tailwind CSS v4.1 is here and it's packed with new utilities, variants, and developer experience improvements that will help you (or your LLM, you coward) build even better interactive experiences. Here's all the best stuff we got into this release: - New text-shadow-* utilities \u2014 only about twenty years after they were first supported by a browser. - Mask elements with the mask-* utilities \u2014 use images and gradients to mask elements with new ergonomic APIs. - Improved compatibility with older browsers \u2014 we've made things degrade way more gracefully for older browsers, while still taking advantage of modern features in browsers that support them. - Fine-grained text wrapping with overflow-wrap \u2014 defend the integrity of your layouts from even the longest German words your users will throw at you. - Colored drop-shadow support \u2014 can't really remember why we didn't have these before but we do now. - Target input devices with pointer-* andany-pointer-* \u2014 tweak your design for touch devices explicitly instead of relying on viewport size. - Align items to the last baseline \u2014 align flex or grid items to the baseline of the last line of text using the new items-baseline-last andself-baseline-last utilities. - Keep content visible with safe alignment \u2014 center content in flex and grid layouts without it disappearing when there's not enough space. - Ignore specific paths with @source not \u2014 explicitly ignore irrelevant large directories and speed up your builds even more. - Safelist specific utilities with @source inline(\u2026) \u2014 force Tailwind to include classes that aren't in your source files. - A bunch of other new variants \u2014 including noscript ,user-valid ,inverted-colors , and more. That's all the cool stuff, but there's a few other little things hiding in the release notes that you might want to check out too. Upgrade your projects by installing the latest version of tailwindcss from npm: npm install tailwindcss@latest @tailwindcss/cli@latest npm install tailwindcss@latest @tailwindcss/vite@latest npm install tailwindcss@latest @tailwindcss/postcss@latest New text-shadow-* utilities We've been threatening to add text shadows for at least the last six years and today they are finally here. We've added five text shadows to the default theme, from text-shadow-2xs to text-shadow-lg . They are particularly useful for making headings stand out against a busy background: You can change the color of the shadow using the text-shadow-<color> utilities. For instance, you can create a sort of embossed effect by using a small white shadow on dark text: If you just want to adjust the opacity of a text shadow without changing the color, you can slap an opacity modifier directly on text shadow size utilities like text-shadow-lg . For example, text-shadow-lg/50 is the same as setting text-shadow-lg and text-shadow-black/50 at the same time: Check out the text-shadow docs for more details. Mask elements with the mask-* utilities One of the coolest features of modern CSS is the ability to use images and gradients as masks - basically using the opacity of an image to hide certain parts of an element: Because you can use any background-image as a mask, the logical thing to do was to copy the bg-* utilities so they share the same API. The problem with that approach is you often want to combine multiple masks together and the bg-* utilities are not composable. So instead, we created a new set of utilities to work with mask-image that are composable and purpose-built for the masking use case. For example, you can use utilities like mask-b-from-<value> and mask-t-to-<value> to add a linear gradient mask to a single side of an element: It's more natural to think about which side you want to mask, rather than trying to work out the exact gradient you need to use. The gradient mask utilities are also composable, so you can combine radial, conic and linear gradients together to create more complex masks: Masking is a super powerful technique and there's a lot more to the API than we can cover here. For a full breakdown of the new utilities, check out the documentation. Improved compatibility with older browsers We went all-in on modern platform features with Tailwind CSS v4.0 to make the best framework we could, and give this version the longest shelf-life possible. Unfortunately some of those features degrade really poorly in older browsers, to the point where even basic things like colors and shadows might not render at all for someone visiting from an old iPhone or iPad that's stuck on Safari 15. For Tailwind CSS v4.1, we put a bunch of effort into coming up with and testing our own framework-specific fallbacks to make your sites render as best as possible in older browsers, even if some super modern things still don't behave quite the same. Here's a list of the things we've managed to improve in this release: - Colors defined in oklab now render in older versions of Safari - Features that depend on custom properties defined with @property (like shadows, transforms, gradients and more) now work in older versions of Safari and Firefox - Colors using the opacity modifier now render with inlined fallbacks in older browsers - Gradients using explicit interpolation methods fall back to the browser default when not supported Tailwind CSS v4 is still designed for modern browsers like Safari 16.4 and up and still depends on a lot of modern features for everything to work perfectly, but at least now your sites will render and be usable in older browsers, even if in certain specific situations the odd shadow color be different. To learn everything you need to know about browser compatibility in Tailwind CSS v4, you can read the full browser compatibility documentation. Fine-grained text wrapping with overflow-wrap The new overflow-wrap utilities let you control how text wraps within an element. The wrap-break-word utility is especially useful for long words or URLs that might otherwise break your layout: The one case where this doesn't quite behave like you'd expect is inside a flex container and that's where you probably want to use the new wrap-anywhere utility instead. It's similar to wrap-break-word , but it allows mid-word line breaks when calculating the intrinsic size of the element, replacing the need to set min-width: 0 on the child element: There's not much more to it than that, but here's the overflow-wrap documentation if you want to read it again in slightly different words. Colored drop-shadow support While we were building out text-shadow support we thought we might as well add another feature we never got around to implementing: colored drop shadows. Now you can use utilities like drop-shadow-indigo-500 and drop-shadow-cyan-500/50 to change the color of a drop shadow: There isn't much more to it but here's the drop-shadow documentation anyway. Target input devices with pointer-* and any-pointer-* The new pointer-fine and pointer-coarse variants let you style something differently depending on whether the user is using a device with a mouse or using a touchscreen. Use pointer-fine to target precise pointing devices like mouses and trackpads, and pointer-coarse to target devices lower precision like touchscreens: Try emulating a touch device in your developer tools to see the changes If you're on your phone, you'll see the pointer-coarse styles applied, which make the touch targets larger and easier to hit. If you're on a desktop, you'll see the pointer-fine styles applied, which make the touch targets smaller and more precise. The any-pointer-* variants work the same way but instead of just checking the user's primary pointing device, they check if any pointing device matches. So any-pointer-coarse will match on a laptop with a touchscreen for a example, even if the user also has a mouse connected. Align items to the last baseline When working with flex or grid layouts, sometimes you need to align something to the baseline of the last line of text rather than the end of the container. The new items-baseline-last utility does just that: We've also added self-baseline-last for when you need to align just a single item, and not all items in the flex or grid container. Keep content visible with safe alignment Ever had center aligned content overflow in both directions when the container got too small? Now you don't have to use a container query to switch the alignment at different sizes. The new safe alignment utilities will change the alignment to start when the container starts to overflow, so it only overflows in one direction. Resize the container to see the alignment behavior These utilities work with both flexbox and grid layouts, and are available for all alignment properties. Ignore specific paths with @source not Sometimes you need to specifically exclude some parts of your code base from being scanned by Tailwind. Now you can use @source not to ignore specific paths when scanning for class names: @import \"tailwindcss\";@source not \"./src/components/legacy\"; This is useful when you have a large number of files in your project, but only want to scan a specific subset of them. Safelist specific utilities with @source inline(\u2026) If you need to make sure Tailwind generates certain class names that don\u2019t exist in your content files, you can force them to be generated by using @source inline() : @import \"tailwindcss\";@source inline(\"underline\"); .underline { text-decoration: underline;} This is the equivalent of the safelist configuration option in previous versions of Tailwind, but now you can use it in your CSS files instead of your config file. The source input is brace-expanded, so you can generate multiple classes at once. For example, to generate all the red shades with hover variants, you can add a range to the source input: @import \"tailwindcss\";@source inline(\"{hover:,}bg-red-{50,{100..900..100},950}\"); .bg-red-50 { background-color: var(--color-red-50);}.bg-red-100 { background-color: var(--color-red-100);}.bg-red-200 { background-color: var(--color-red-200);}/* ... */.bg-red-800 { background-color: var(--color-red-800);}.bg-red-900 { background-color: var(--color-red-900);}.bg-red-950 { background-color: var(--color-red-950);}@media (hover: hover) { .hover\\:bg-red-50:hover { background-color: var(--color-red-50); } /* ... */ .hover\\:bg-red-950:hover { background-color: var(--color-red-950); }} This will generate shades of red from 100 to 900 in increments of 100, as well as the 50 and 950 shades. It also adds the hover: variant for each of those classes. You can also use @source inline() with the not modifier to exclude specific classes from being generated: @import \"tailwindcss\";@source not inline(\"container\"); This will specifically prevent the container class from being generated, even if the word container is detected in your source files. For more details, check out the detecting classes in source files documentation. A bunch of other new variants Prettier accordions with details-content While you could always add styles to the children of a <details> element, it's been impossible to style the content container itself. The new details-content variant targets the content container which is useful for positioning the content container relative to the <summary> element: Target inverted-colors mode Use the inverted-colors variant to conditionally add styles when the user has enabled an inverted color scheme in their OS: <div class=\"shadow-xl inverted-colors:shadow-none ...\"> <!-- ... --></div> This is useful for things like preventing black shadows being turned white when inverted colors are enabled. New noscript variant Yes, some people disable JavaScript and now you can tell them your app doesn't work without it. The noscript variant lets you conditionally apply styles when JS is disabled: <div class=\"hidden noscript:block\">Please enable JavaScript to use this app.</div> You could already do this with the <noscript> tag but now you can do it with CSS too, which Tailwind lets you write in your HTML, so\u2026 yeah. Better form validation with user-valid and user-invalid Ever tried the :invalid pseudo-class only for the page to be full of red invalid states as soon as it loads, before the user has even touched your form? The new user-valid and user-invalid variants try to solve this problem, by only applying validation-related styling after the user has actually interacted with the controls: <input required class=\"border user-valid:border-green-500\" /><input required class=\"border user-invalid:border-red-500\" /> So that's it, that's Tailwind CSS v4.1! Update to the latest version using npm and start playing with it today: npm install tailwindcss@latest @tailwindcss/cli@latest npm install tailwindcss@latest @tailwindcss/vite@latest npm install tailwindcss@latest @tailwindcss/postcss@latest Looking forward to seeing what you build with the new features!"},
{"source": "https://tailwindcss.com/blog/tailwindcss-v4-alpha", "title": "Open-sourcing our progress on Tailwind CSS v4.0 - Tailwind CSS", "text": "Open-sourcing our progress on Tailwind CSS v4.0 - Date - Adam Wathan Last summer at Tailwind Connect I shared a preview of Oxide \u2014 a new high-performance engine for Tailwind CSS that we\u2019ve been working on, designed to simplify the developer experience and take advantage of how the web platform has evolved in recent years. The new engine was originally going to ship as a v3.x release, but even though we\u2019re committed to backwards compatibility, this feels so clearly like a new generation of the framework that it deserves to be v4.0. It\u2019s still early and we\u2019ve got a lot of work to do, but today we\u2019re open-sourcing our progress and tagging the first public v4.0.0-alpha so you can start experimenting with it and help us get to a stable release later this year. I\u2019ll try keep it brief to save some of the excitement for the stable release, but if you like to play with very early and experimental stuff, there should be plenty of information here to get you going. A new engine, built for speed The new engine is a ground-up rewrite, using everything we know about the framework now to better model the problem space, making things faster with a lot less code. - Up to 10x faster \u2014 we can do a full build of the Tailwind CSS website in 105ms instead of 960ms, or our Catalyst UI kit in 55ms instead of 341ms. - Smaller footprint \u2014 the new engine is over 35% smaller installed, even with the heavier native packages we ship like the parts we\u2019ve rewritten in Rust and Lightning CSS. - Rust where it counts \u2014 we\u2019ve migrated some of the most expensive and parallelizable parts of the framework to Rust, while keeping the core of the framework in TypeScript for extensibility. - One dependency \u2014 the only thing the new engine depends on is Lightning CSS. - Custom parser \u2014 we wrote our own CSS parser and designed our own data structures tailored to our needs, making parsing over 2x as fast for us as it was with PostCSS. Unified toolchain Tailwind CSS v4 isn\u2019t just a plugin anymore \u2014 it\u2019s an all-in-one tool for processing your CSS. We\u2019ve integrated Lightning CSS directly into the framework so you don\u2019t have to configure anything about your CSS pipeline. - Built-in @import handling \u2014 no need to setup and configure a tool likepostcss-import . - Built-in vendor prefixing \u2014 you don\u2019t have to add autoprefixer to your projects anymore. - Built-in nesting support \u2014 no plugins needed to flatten nested CSS, it works out of the box. - Syntax transforms \u2014 modern CSS features like oklch() colors and media query ranges are transpiled to syntax with better browser support. We\u2019re still shipping a PostCSS plugin, but we\u2019re also exploring first-party bundler plugins, and we\u2019re shipping an official Vite plugin with this first alpha release that you can try out today. Designed for the modern web We\u2019re looking into the future with Tailwind CSS v4 and trying to build a framework that\u2019s going to feel cutting edge for years to come. - Native cascade layers \u2014 we\u2019re using real @layer rules now, which solves a ton of specificity problems we\u2019ve wrestled with in the past. - Explicitly defined custom properties \u2014 we use @property to define our internal custom properties with proper types and constraints, making it possible to do things like transition background gradients. - Using color-mix for opacity modifiers \u2014 making it easier than ever to use our opacity modifier syntax when using CSS variables for colors, or even adjusting the opacity ofcurrentColor . - Container queries in core \u2014 we\u2019ve added support for container queries directly to core, with new @min-* and@max-* variants to support container query ranges. We\u2019re also working on refreshing our color palette with wide gamut colors, and introducing support for other modern CSS features like @starting-style , anchor positioning, and more. Composable variants The new architecture makes it possible to compose together variants that act on other selectors, like group-* , peer-* , has-* , and a new not-* variant we\u2019re introducing for v4. In earlier releases, variants like group-has-* were explicitly defined in the framework, but now group-* can compose with the existing has-* variant, which can compose with other variants like focus : <div class=\"group\"> <div class=\"group-has-[&:focus]:opacity-100\"> <div class=\"group-has-focus:opacity-100\"> <!-- ... --> </div> </div> There\u2019s no limits to this composability, and you can even write stuff like group-not-has-peer-not-data-active:underline if for some horrible reason that\u2019s what you need to do. Zero-configuration content detection You\u2019ll notice that at least in these early alpha releases, it\u2019s not even possible to configure your content paths. For most projects, you\u2019re never going to need to do this ever again \u2014 Tailwind just finds your template files for you. We do this using one of two ways depending on how you\u2019ve integrated Tailwind into your project: - Using the PostCSS plugin or the CLI, Tailwind will crawl your entire project looking for template files, using a bunch of heuristics we\u2019ve built in to keep things fast, like not crawling directories that are in your .gitignore file, and ignoring binary file formats. - Using the Vite plugin, we rely on the module graph. This is amazing because we know exactly what files you\u2019re actually using, so it\u2019s maximally performant, and with no false positives or negatives. We\u2019re hoping to expand this approach outside of the Vite ecosystem with other bundler plugins in the future. We\u2019ll introduce a way to configure content paths explicitly in the future for sure, but we\u2019re curious to see how well this automatic approach works for everyone \u2014 it\u2019s working awesome in our own projects. CSS-first configuration A major goal of Tailwind CSS v4.0 is making the framework feel CSS-native, and less like a JavaScript library. Once you\u2019ve installed it, you add it to your project with a regular CSS @import statement: @import \"tailwindcss\"; And instead of setting up all of your customizations in a JavaScript configuration file, you just use CSS variables: @import \"tailwindcss\"; @theme { --font-family-display: \"Satoshi\", \"sans-serif\"; --breakpoint-3xl: 1920px; --color-neon-pink: oklch(71.7% 0.25 360); --color-neon-lime: oklch(91.5% 0.258 129); --color-neon-cyan: oklch(91.3% 0.139 195.8); } The special @theme directive tells Tailwind to make new utilities and variants available based on those variables, letting you use classes like 3xl:text-neon-lime in your markup: <div class=\"max-w-lg 3xl:max-w-xl\"> <h1 class=\"font-display text-4xl\"> Data to <span class=\"text-neon-cyan\">enrich</span> your online business </h1> </div> Adding new CSS variables behaves like extend did in earlier versions of the framework, but you can override a whole set of variables by clearing the namespace with syntax like --color-*: initial before defining all of your custom values: @import \"tailwindcss\"; @theme { --color-*: initial; --color-gray-50: #f8fafc; --color-gray-100: #f1f5f9; --color-gray-200: #e2e8f0; /* ... */ --color-green-800: #3f6212; --color-green-900: #365314; --color-green-950: #1a2e05; } We\u2019re still fine-tuning some of the naming conventions, but you can explore the default theme on GitHub to see what\u2019s available to customize. If you don\u2019t want to explicitly clear the default theme and would rather start from scratch, you can import \"tailwindcss/preflight\" and \"tailwindcss/utilities\" directly to skip importing the default theme: @import \"tailwindcss\"; @import \"tailwindcss/preflight\" layer(base); @import \"tailwindcss/utilities\" layer(utilities); @theme { --color-*: initial; --color-gray-50: #f8fafc; --color-gray-100: #f1f5f9; --color-gray-200: #e2e8f0; /* ... */ --color-green-800: #3f6212; --color-green-900: #365314; --color-green-950: #1a2e05; } We also make all of your theme values available as native CSS variables in your custom CSS: :root { --color-gray-50: #f8fafc; --color-gray-100: #f1f5f9; --color-gray-200: #e2e8f0; /* ... */ --color-green-800: #3f6212; --color-green-900: #365314; --color-green-950: #1a2e05; } This makes it easy to reference any of your theme values in arbitrary values without needing the theme() function: <div class=\"p-[calc(var(--spacing-6)-1px)]\"> <!-- ... --> </div> It also makes it possible to use your theme values when working with UI libraries like Framer Motion, without having to use the resolveConfig() function: import { motion } from \"framer-motion\" export const MyComponent = () => ( <motion.div initial={{ y: 'var(--spacing-8)' }} animate={{ y: 0 }} exit={{ y: 'var(--spacing-8)' }} > {children} </motion.div> ) What\u2019s changed We don\u2019t take breaking changes lightly, but there are a few things we\u2019re doing differently in v4 so far that are worth sharing: - Removed deprecated utilities \u2014 we\u2019ve removed utilities we stopped documenting a long time ago like text-opacity-* ,flex-grow-* , anddecoration-slice in favor of their modern replacements liketext-{color}/* ,grow-* , andbox-decoration-slice . - PostCSS plugin and CLI are separate packages \u2014 the main tailwindcss package doesn\u2019t include these anymore since not everyone needs them, instead they should be installed separately using@tailwindcss/postcss and@tailwindcss/cli . - No default border color \u2014 the border utility used to default togray-200 , but now it defaults tocurrentColor like the browser does. We made this change to make it harder to accidentally introduce a wrong gray into your project if you\u2019re usingzinc orslate or something else as your main gray. - Rings are 1px by default \u2014 the ring utility used to be a 3px blue ring by default, now it\u2019s a 1px ring usingcurrentColor . We find ourselves using thering-* utilities as an alternative to borders in our projects, and usingoutline-* for focus rings, so we think making things consistent here is a helpful change. There are a handful of other really low-level implementation detail changes that might surface in some way in your projects, but nothing deliberate like these changes. If you bump into anything surprising, let us know. Roadmap to v4.0 This new engine is a ground-up rewrite, and up until now we\u2019ve been focused entirely on this reimagined developer experience using the new configuration approach. We put an enormous amount of value in backwards compatibility, and that\u2019s where the bulk of the work lies before we can tag a stable v4.0 release later this year. - Support for JavaScript configuration files \u2014 reintroducing compatibility with the classic tailwind.config.js file to make migrating to v4 easy. - Explicit content path configuration \u2014 making it possible to tell Tailwind exactly where your templates are when automatic content detection isn\u2019t good enough for your setup. - Support for other dark modes \u2014 right now we only support dark mode using media queries, and still need to reimplement the selector and variant strategies. - Plugins and custom utilities \u2014 we don\u2019t have support for plugins, or for writing custom utilities that automatically work with variants yet. Obviously we will make this work before a stable release. - Prefix support \u2014 there\u2019s no way to configure a prefix for your classes yet, but we\u2019ll bring it back for sure. - Safelists and blocklists \u2014 can\u2019t force Tailwind to generate certain classes or prevent it from generating other classes yet. - Support for important configuration \u2014 there\u2019s no way to make utilities all generate with!important right now, but we plan to implement it. - Support for the theme() function \u2014 this isn\u2019t needed for new projects because you can usevar() now, but we\u2019ll implement it for backwards compatibility. - Standalone CLI \u2014 we haven\u2019t worked on a standalone CLI for the new engine yet, but will absolutely have it before the v4.0 release. Aside from that, I\u2019m sure we\u2019ll find a lot of bugs to fix, some exciting new CSS features to sneak in, and refine some of these new APIs that need some more polish before a proper release. I don\u2019t want to make promises on a specific release timeline, but I\u2019d personally love to mark v4.0 as stable before the summer holiday season kicks in. Try out the alpha We\u2019ve tagged a couple alpha releases already, and you can start playing with it in your projects today. If you\u2019re using the Tailwind CSS IntelliSense extension for VS Code, make sure you switch to the prerelease version from the extension page, and if you\u2019re using our Prettier plugin, make sure you install the latest version. If you find an issue, please let us know on GitHub. We really want this thing to be bullet-proof before we tag a stable release and reporting any problems you find will help us a lot. Using Vite Install the Tailwind CSS v4 alpha and our new Vite plugin: $ npm install tailwindcss@next @tailwindcss/vite@next Then add our plugin to your vite.config.ts file: import tailwindcss from '@tailwindcss/vite' import { defineConfig } from 'vite' export default defineConfig({ plugins: [tailwindcss()], }) Finally, import Tailwind in your main CSS file: @import \"tailwindcss\"; Using PostCSS Install the Tailwind CSS v4 alpha and the separate PostCSS plugin package: $ npm install tailwindcss@next @tailwindcss/postcss@next Then add our plugin to your postcss.config.js file: module.exports = { plugins: { '@tailwindcss/postcss': {} } } Finally, import Tailwind in your main CSS file: @import \"tailwindcss\"; Using the CLI Install the Tailwind CSS v4 alpha and the separate CLI package: $ npm install tailwindcss@next @tailwindcss/cli@next Next, import Tailwind in your main CSS file: @import \"tailwindcss\"; Finally, compile your CSS using the CLI tool: $ npx @tailwindcss/cli@next -i app.css -o dist/app.css"},
{"source": "https://tailwindcss.com/blog/tailwindcss-v4-beta", "title": "Tailwind CSS v4.0 Beta 1 - Tailwind CSS", "text": "Tailwind CSS v4.0 Beta 1 - Date - Adam Wathan About eight months ago we open-sourced our progress on Tailwind CSS v4.0. Hundreds of hours of fixing bugs, soul-crushing backward compatibility work, and troubleshooting Windows CI failures later, I\u2019m excited to finally tag the first public beta release. As I talked about when we published the first alpha, Tailwind CSS v4.0 is an all-new engine built for performance, and designed for the modern web. - Built for performance \u2014 full builds in the new engine are up to 5x faster, and incremental builds are over 100x faster \u2014 and measured in microseconds. - Unified toolchain \u2014 built-in import handling, vendor prefixing, and syntax transforms, with no additional tooling required. - CSS-first configuration \u2014 a reimagined developer experience where you customize and extend the framework directly in CSS instead of a JavaScript configuration file. - Designed for the modern web \u2014 built on native cascade layers, wide-gamut colors, and including first-class support for modern CSS features like container queries, @starting-style , popovers, and more. There\u2019s so much more to say, but everything you need to get started is in the new beta documentation we published today: Get started with Tailwind CSS v4.0 Beta 1 \u2192 Start building and help us bullet-proof this thing for the stable release early in the new year."}]