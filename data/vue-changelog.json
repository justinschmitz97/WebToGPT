[{"source": "https://blog.vuejs.org/posts/vue-3-2", "title": "Vue 3.2 Released!", "text": "- Published on\nVue 3.2 Released!\n- Authors\n- Name\n- Evan You\n- @youyuxi\nWe are excited to announce the release of Vue.js 3.2 \"Quintessential Quintuplets\"! This release includes many significant new features and performance improvements, and contains no breaking changes.\nNew SFC Features\nTwo new features for Single File Components (SFCs, aka .vue\nfiles) have graduated from experimental status and are now considered stable:\n<script setup>\nis a compile-time syntactic sugar that greatly improves the ergonomics when using Composition API inside SFCs.<style> v-bind\nenables component state-driven dynamic CSS values in SFC<style>\ntags.\nHere is an example component using these two new features together:\n<script setup>\nimport { ref } from 'vue'\nconst color = ref('red')\n</script>\n<template>\n<button @click=\"color = color === 'red' ? 'green' : 'red'\">\nColor is: {{ color }}\n</button>\n</template>\n<style scoped>\nbutton {\ncolor: v-bind(color);\n}\n</style>\nTry it out in the SFC Playground, or read their respective documentations:\nBuilding on top of <script setup>\n, we also have a new RFC for improving the ergonomics of ref usage with compiler-enabled sugar - please share your feedback here.\nWeb Components\nVue 3.2 introduces a new defineCustomElement\nmethod for easily creating native custom elements using Vue component APIs:\nimport { defineCustomElement } from 'vue'\nconst MyVueElement = defineCustomElement({\n// normal Vue component options here\n})\n// Register the custom element.\n// After registration, all `<my-vue-element>` tags\n// on the page will be upgraded.\ncustomElements.define('my-vue-element', MyVueElement)\nThis API allows developers to create Vue-powered UI component libraries that can be used with any framework, or no framework at all. We have also added a new section in our docs on consuming and creating Web Components in Vue.\nPerformance Improvements\n3.2 includes some significant performance improvements to Vue's reactivity system, thanks to the great work by @basvanmeurs. Specifically:\n- More efficient ref implementation (~260% faster read / ~50% faster write)\n- ~40% faster dependency tracking\n- ~17% less memory usage\nThe template compiler also received a number of improvements:\n- ~200% faster creation of plain element VNodes\n- More aggressive constant hoisting [1] [2]\nFinally, there is a new v-memo\ndirective that provides the ability to memoize part of the template tree. A v-memo\nhit allows Vue to skip not only the Virtual DOM diffing, but the creation of new VNodes altogether. Although rarely needed, it provides an escape hatch to squeeze out maximum performance in certain scenarios, for example large v-for\nlists.\nThe usage of v-memo\n, which is a one-line addition, places Vue among the fastest mainstream frameworks in js-framework-benchmark:\nServer-side Rendering\nThe @vue/server-renderer\npackage in 3.2 now ships an ES module build which is also decoupled from Node.js built-ins. This makes it possible to bundle and leverage @vue/server-renderer\nfor use inside non-Node.js runtimes such as CloudFlare Workers or Service Workers.\nWe also improved the streaming render APIs, with new methods for rendering to the Web Streams API. Check out the documentation of @vue/server-renderer\nfor more details.\nEffect Scope API\n3.2 introduces a new Effect Scope API for directly controlling the disposal timing of reactive effects (computed and watchers). It makes it easier to leverage Vue's reactivity API out of a component context, and also unlocks some advanced use cases inside components.\nThis is low-level API largely intended for library authors, so it's recommended to read the feature's RFC for the motivation and use cases of this feature.\nFor a detailed list of all changes in 3.2, please refer to the full changelog."},
{"source": "https://blog.vuejs.org/posts/vue-3-3", "title": "Announcing Vue 3.3", "text": "- Published on\nAnnouncing Vue 3.3\n- Authors\n- Name\n- Evan You\n- @youyuxi\nToday we're excited to announce the release of Vue 3.3 \"Rurouni Kenshin\"!\nThis release is focused on developer experience improvements - in particular, SFC <script setup>\nusage with TypeScript. Together with the 1.6 release of Vue Language Tools (previously known as Volar), we have resolved many long-standing pain points when using Vue with TypeScript.\nThis post provides an overview of the highlighted features in 3.3. For the full list of changes, please consult the full changelog on GitHub.\nDependency Updates\nWhen upgrading to 3.3, it is recommended to also update the following dependencies:\n- volar / vue-tsc@^1.6.4\n- vite@^4.3.5\n- @vitejs/plugin-vue@^4.2.0\n- vue-loader@^17.1.0 (if using webpack or vue-cli)\n<script setup>\n+ TypeScript DX Improvements\nImported and Complex Types Support in Macros\nPreviously, types used in the type parameter position of defineProps\nand defineEmits\nwere limited to local types, and only supported type literals and interfaces. This is because Vue needs to be able to analyze the properties on the props interface in order to generate corresponding runtime options.\nThis limitation is now resolved in 3.3. The compiler can now resolve imported types, and supports a limited set of complex types:\n<script setup lang=\"ts\">\nimport type { Props } from './foo'\n// imported + intersection type\ndefineProps<Props & { extraProp?: string }>()\n</script>\nDo note that complex types support is AST-based and therefore not 100% comprehensive. Some complex types that require actual type analysis, e.g. conditional types, are not supported. You can use conditional types for the type of a single prop, but not the entire props object.\n- Details: PR#8083\nGeneric Components\nComponents using <script setup>\ncan now accept generic type parameters via the generic\nattribute:\n<script setup lang=\"ts\" generic=\"T\">\ndefineProps<{\nitems: T[]\nselected: T\n}>()\n</script>\nThe value of generic\nworks exactly the same as the parameter list between <...>\nin TypeScript. For example, you can use multiple parameters, extends\nconstraints, default types, and reference imported types:\n<script setup lang=\"ts\" generic=\"T extends string | number, U extends Item\">\nimport type { Item } from './types'\ndefineProps<{\nid: T\nlist: U[]\n}>()\n</script>\nThis feature previously required explicit opt-in, but is now enabled by default in the latest version of volar / vue-tsc.\n- Discussion: RFC#436\n- Related: generic\ndefineComponent()\n- PR#7963\nMore Ergonomic defineEmits\nPreviously, the type parameter for defineEmits\nonly supports the call signature syntax:\n// BEFORE\nconst emit = defineEmits<{\n(e: 'foo', id: number): void\n(e: 'bar', name: string, ...rest: any[]): void\n}>()\nThe type matches the return type for emit\n, but is a bit verbose and awkward to write. 3.3 introduces a more ergonomic way of declaring emits with types:\n// AFTER\nconst emit = defineEmits<{\nfoo: [id: number]\nbar: [name: string, ...rest: any[]]\n}>()\nIn the type literal, the key is the event name and the value is an array type specifying the additional arguments. Although not required, you can use the labeled tuple elements for explicitness, like in the example above.\nThe call signature syntax is still supported.\nTyped Slots with defineSlots\nThe new defineSlots\nmacro can be used to declare expected slots and their respective expected slot props:\n<script setup lang=\"ts\">\ndefineSlots<{\ndefault?: (props: { msg: string }) => any\nitem?: (props: { id: number }) => any\n}>()\n</script>\ndefineSlots()\nonly accepts a type parameter and no runtime arguments. The type parameter should be a type literal where the property key is the slot name, and the value is a slot function. The first argument of the function is the props the slot expects to receive, and its type will be used for slot props in the template. The returning value of defineSlots\nis the same slots object returned from useSlots\n.\nSome current limitations:\n- Required slots checking is not yet implemented in volar / vue-tsc.\n- Slot function return type is currently ignored and can be\nany\n, but we may leverage it for slot content checking in the future.\nThere is also a corresponding slots\noption for defineComponent\nusage. Both APIs have no runtime implications and serve purely as type hints for IDEs and vue-tsc\n.\n- Details: PR#7982\nExperimental Features\nReactive Props Destructure\nPreviously part of the now-dropped Reactivity Transform, reactive props destructure has been split into a separate feature.\nThe feature allows destructured props to retain reactivity, and provides a more ergonomic way to declare props default values:\n<script setup>\nimport { watchEffect } from 'vue'\nconst { msg = 'hello' } = defineProps(['msg'])\nwatchEffect(() => {\n// accessing `msg` in watchers and computed getters\n// tracks it as a dependency, just like accessing `props.msg`\nconsole.log(`msg is: ${msg}`)\n})\n</script>\n<template>{{ msg }}</template>\nThis feature is experimental and requires explicit opt-in.\n- Details: RFC#502\ndefineModel\nPreviously, for a component to support two-way binding with v-model\n, it needs to (1) declare a prop and (2) emit a corresponding update:propName\nevent when it intends to update the prop:\n<!-- BEFORE -->\n<script setup>\nconst props = defineProps(['modelValue'])\nconst emit = defineEmits(['update:modelValue'])\nconsole.log(props.modelValue)\nfunction onInput(e) {\nemit('update:modelValue', e.target.value)\n}\n</script>\n<template>\n<input :value=\"modelValue\" @input=\"onInput\" />\n</template>\n3.3 simplifies the usage with the new defineModel\nmacro. The macro automatically registers a prop, and returns a ref that can be directly mutated:\n<!-- AFTER -->\n<script setup>\nconst modelValue = defineModel()\nconsole.log(modelValue.value)\n</script>\n<template>\n<input v-model=\"modelValue\" />\n</template>\nThis feature is experimental and requires explicit opt-in.\n- Details: RFC#503\nOther Notable Features\ndefineOptions\nThe new defineOptions\nmacro allows declaring component options directly in <script setup>\n, without requiring a separate <script>\nblock:\n<script setup>\ndefineOptions({ inheritAttrs: false })\n</script>\nBetter Getter Support with toRef\nand toValue\ntoRef\nhas been enhanced to support normalizing values / getters / existing refs into refs:\n// equivalent to ref(1)\ntoRef(1)\n// creates a readonly ref that calls the getter on .value access\ntoRef(() => props.foo)\n// returns existing refs as-is\ntoRef(existingRef)\nCalling toRef\nwith a getter is similar to computed\n, but can be more efficient when the getter is just performing property access with no expensive computations.\nThe new toValue\nutility method provides the opposite, normalizing values / getters / refs into values:\ntoValue(1) // --> 1\ntoValue(ref(1)) // --> 1\ntoValue(() => 1) // --> 1\ntoValue\ncan be used in composables in place of unref\nso that your composable can accept getters as reactive data sources:\n// before: allocating unnecessary intermediate refs\nuseFeature(computed(() => props.foo))\nuseFeature(toRef(props, 'foo'))\n// after: more efficient and succinct\nuseFeature(() => props.foo)\nThe relationship between toRef\nand toValue\nis similar to that between ref\nand unref\n, with the main difference being the special handling of getter functions.\n- Details: PR#7997\nJSX Import Source Support\nCurrently, Vue's types automatically registers global JSX typing. This may cause conflict with used together with other libraries that needs JSX type inference, in particular React.\nStarting in 3.3, Vue supports specifying JSX namespace via TypeScript's jsxImportSource option. This allows the users to choose global or per-file opt-in based on their use case.\nFor backwards compatibility, 3.3 still registers JSX namespace globally. We plan to remove the default global registration in 3.4. If you are using TSX with Vue, you should add explicit jsxImportSource\nto your tsconfig.json\nafter upgrading to 3.3 to avoid breakage in 3.4.\nMaintenance Infrastructure Improvements\nThis release builds upon many maintenance infrastructure improvements that allow us to move faster with more confidence:\n- 10x faster builds by separating type checking from the rollup build and moving from\nrollup-plugin-typescript2\ntorollup-plugin-esbuild\n. - Faster tests by moving from Jest to Vitest.\n- Faster types generation by moving from\n@microsoft/api-extractor\ntorollup-plugin-dts\n. - Comprehensive regression tests via ecosystem-ci - catches regressions in major ecosystem dependents before releases!\nAs planned, we aim to start making smaller and more frequent feature releases in 2023. Stay tuned!"},
{"source": "https://blog.vuejs.org/posts/vue-3-4", "title": "Announcing Vue 3.4", "text": "- Published on\nAnnouncing Vue 3.4\n- Authors\n- Name\n- Evan You\n- @youyuxi\nToday we're excited to announce the release of Vue 3.4 \"\ud83c\udfc0 Slam Dunk\"!\nThis release includes some substantial internal improvements - most notably a rewritten template parser that is 2x faster, and a refactored reactivity system that makes effect triggering more accurate and efficient. It also packs a number of quality-of-life API improvements, including the stabilization of defineModel\nand a new same-name shorthand when binding props.\nThis post provides an overview of the highlighted features in 3.4. For the full list of changes, please consult the full changelog on GitHub.\nPotential Actions Needed\nTo fully leverage new features in 3.4, it is recommended to also update the following dependencies when upgrading to 3.4:\n- Volar / vue-tsc@^1.8.27 (required)\n- @vitejs/plugin-vue@^5.0.0 (if using Vite)\n- nuxt@^3.9.0 (if using Nuxt)\n- vue-loader@^17.4.0 (if using webpack or vue-cli)\nIf using TSX with Vue, check actions needed in Removed: Global JSX Namespace.\nMake sure you are no longer using any deprecated features (if you are, you should have warnings in the console telling you so). They may have been removed in 3.4.\nFeature Highlights\n2X Faster Parser and Improved SFC Build Performance\n- Context: PR#9674\nIn 3.4, we completely rewrote the template parser. Previously, Vue used a recursive descent parser that relied on many regular expressions and look-ahead searches. The new parser uses a state-machine tokenizer based on the tokenizer in htmlparser2, which iterates through the entire template string only once. The result is a parser that is consistently twice as fast for templates of all sizes. Thanks to our extensive test cases and ecosystem-ci, it is also 100% backwards compatible for Vue end users.\nWhile integrating the new parser with other parts of the system, we also discovered a few opportunities to further improve the overall SFC compilation performance. The benchmarks show a ~44% improvement when compiling the script and template parts of a Vue SFC while generating source maps, so 3.4 should result in faster builds for most projects using Vue SFCs. However, do note that Vue SFC compilation is only one part of the entire build process in real world projects. The final gain in end-to-end build time will likely be much smaller compared to the isolated benchmarks.\nOutside of Vue core, the new parser will also benefit the performance of Volar / vue-tsc, and community plugins that need to parse Vue SFCs or templates, e.g. Vue Macros.\nMore Efficient Reactivity System\nContext: PR#5912\n3.4 also ships a substantial refactor of the reactivity system, with the goal of improving re-compute efficiency of computed properties.\nTo illustrate what is being improved, let's consider the following scenario:\nconst count = ref(0)\nconst isEven = computed(() => count.value % 2 === 0)\nwatchEffect(() => console.log(isEven.value)) // logs true\ncount.value = 2 // logs true again\nBefore 3.4, the callback of watchEffect\nwill fire every time count.value\nis changed, even if the computed result remains the same. With the post-3.4 optimizations, the callback now only fires if the computed result has actually changed.\nIn addition, in 3.4:\n- Multiple computed dep changes only trigger sync effects once.\n- Array\nshift\n,unshift\n,splice\nmethods only trigger sync effects once.\nIn addition to the gains shown in the benchmarks, this should reduce unnecessary component re-renders in many scenarios while retaining full backwards compatibility.\ndefineModel\nis Now Stable\nContext: RFC#503\ndefineModel\nis a new <script setup>\nmacro that aims to simplify the implementation of components that support v-model\n. It was previously shipped in 3.3 as an experimental feature, and has graduated to stable status in 3.4. It now also provides better support for usage with v-model\nmodifiers.\nRelevant Documentation:\nv-bind\nSame-name Shorthand\nContext: PR#9451\nYou can now shorten this:\n<img :id=\"id\" :src=\"src\" :alt=\"alt\">\nTo this:\n<img :id :src :alt>\nThis feature has been frequently requested in the past. Originally, we had concerns about its usage being confused with boolean attributes. However, after revisiting the feature, we now think it makes sense for v-bind\nto behave a bit more like JavaScript than native attributes, considering its dynamic nature.\nImproved Hydration Mismatch Errors\nContext: PR#5953\n3.4 ships a number of improvements to hydration mismatch error messages:\n- Improved clarity of the wording (rendered by server vs. expected on client).\n- The message now includes the DOM node in question so you can quickly locate it on the page or in the elements panel.\n- Hydration mismatch checks now also apply to class, style, and other dynamically bound attributes.\nIn addition, 3.4 also adds a new compile-time flag, __VUE_PROD_HYDRATION_MISMATCH_DETAILS__\n, which can be used to force hydration mismatch errors to include full details even in production.\nError Code and Compile-time Flag Reference\nTo reduce bundle size, Vue drops long error message strings in production builds. However, this means errors caught by error handlers in production will receive short error codes that are difficult to decipher without diving into Vue's source code.\nTo improve this, we have added a Production Error Reference Page to the documentation. The error codes are automatically generated from the latest version of Vue stable release.\nWe have also added a Compile-Time Flags Reference with instructions on how to configure these flags for different build tools.\nRemoved Deprecated Features\nGlobal JSX Namespace\nStarting in 3.4, Vue no longer registers the global JSX\nnamespace by default. This is necessary to avoid global namespace collision with React so that TSX of both libs can co-exist in the same project. This should not affect SFC-only users with latest version of Volar.\nIf you are using TSX, there are two options:\nExplicitly set jsxImportSource to\n'vue'\nintsconfig.json\nbefore upgrading to 3.4. You can also opt-in per file by adding a/* @jsxImportSource vue */\ncomment at the top of the file.If you have code that depends on the presence of the global\nJSX\nnamespace, e.g. usage of types likeJSX.Element\netc., you can retain the exact pre-3.4 global behavior by explicitly referencingvue/jsx\n, which registers the globalJSX\nnamespace.\nNote that this is a type-only breaking change in a minor release, which adheres to our release policy.\nOther Removed Features\n- Reactivity Transform was marked deprecated in 3.3 and is now removed in 3.4. This change does not require a major due to the feature being experimental. Users who wish to continue using the feature can do so via the Vue Macros plugin.\napp.config.unwrapInjectedRef\nhas been removed. It was deprecated and enabled by default in 3.3. In 3.4 it is no longer possible to disable this behavior.@vnodeXXX\nevent listeners in templates are now a compiler error instead of a deprecation warning. Use@vue:XXX\nlisteners instead.v-is\ndirective has been removed. It was deprecated in 3.3. Use theis\nattribute withvue:\nprefix instead."},
{"source": "https://blog.vuejs.org/posts/vue-3-5", "title": "Announcing Vue 3.5", "text": "- Published on\nAnnouncing Vue 3.5\n- Authors\n- Name\n- Evan You\n- @youyuxi\nToday we are excited to announce the release of Vue 3.5 \"Tengen Toppa Gurren Lagann\"!\nThis minor release contains no breaking changes and includes both internal improvements and useful new features. We will cover some highlights in this blog post - for a full list of changes and new features, please consult the full changelog on GitHub.\nReactivity System Optimizations\nIn 3.5, Vue's reactivity system has undergone another major refactor that achieves better performance and significantly improved memory usage (-56%) with no behavior changes. The refactor also resolves stale computed values and memory issues caused by hanging computeds during SSR.\nIn addition, 3.5 also optimizes reactivity tracking for large, deeply reactive arrays, making such operations up to 10x faster in some cases.\nReactive Props Destructure\nReactive Props Destructure has been stabilized in 3.5. With the feature now enabled by default, variables destructured from a defineProps\ncall in <script setup>\nare now reactive. Notably, this feature significantly simplifies declaring props with default values by leveraging JavaScript's native default value syntax:\nBefore\nconst props = withDefaults(\ndefineProps<{\ncount?: number\nmsg?: string\n}>(),\n{\ncount: 0,\nmsg: 'hello'\n}\n)\nAfter\nconst { count = 0, msg = 'hello' } = defineProps<{\ncount?: number\nmessage?: string\n}>()\nAccess to a destructured variable, e.g. count\n, is automatically compiled into props.count\nby the compiler, so they are tracked on access. Similar to props.count\n, watching the destructured prop variable or passing it into a composable while retaining reactivity requires wrapping it in a getter:\nwatch(count /* ... */)\n// ^ results in compile-time error\nwatch(() => count /* ... */)\n// ^ wrap in a getter, works as expected\n// composables should normalize the input with `toValue()`\nuseDynamicCount(() => count)\nFor those who prefer to better distinguish destructured props from normal variables, @vue/language-tools\n2.1 has shipped an opt-in setting to enable inlay hints for them:\nDetails:\n- See docs for usage and caveats.\n- See RFC#502 for the history and design rationale behind this feature.\nSSR Improvements\n3.5 brings a few long-requested improvements to server-side rendering (SSR).\nLazy Hydration\nAsync components can now control when they should be hydrated by specifying a strategy via the hydrate\noption of the defineAsyncComponent()\nAPI. For example, to only hydrate a component when it becomes visible:\nimport { defineAsyncComponent, hydrateOnVisible } from 'vue'\nconst AsyncComp = defineAsyncComponent({\nloader: () => import('./Comp.vue'),\nhydrate: hydrateOnVisible()\n})\nThe core API is intentionally lower level and the Nuxt team is already building higher-level syntax sugar on top of this feature.\nDetails: PR#11458\nuseId()\nuseId()\nis an API that can be used to generate unique-per-application IDs that are guaranteed to be stable across the server and client renders. They can be used to generate IDs for form elements and accessibility attributes, and can be used in SSR applications without leading to hydration mismatches:\n<script setup>\nimport { useId } from 'vue'\nconst id = useId()\n</script>\n<template>\n<form>\n<label :for=\"id\">Name:</label>\n<input :id=\"id\" type=\"text\" />\n</form>\n</template>\nDetails: PR#11404\ndata-allow-mismatch\nIn cases where a client value will be inevitably different from its server counterpart (e.g. dates), we can now suppress the resulting hydration mismatch warnings with data-allow-mismatch\nattributes:\n<span data-allow-mismatch>{{ data.toLocaleString() }}</span>\nYou can also limit what types of mismatches are allowed by providing a value to the attribute, where the possible values are text\n, children\n, class\n, style\n, and attribute\n.\nCustom Elements Improvements\n3.5 fixes many long-standing issues related to the defineCustomElement()\nAPI, and adds a number of new capabilities for authoring custom elements with Vue:\n- Support app configurations for custom elements via the\nconfigureApp\noption. - Add\nuseHost()\n,useShadowRoot()\n, andthis.$host\nAPIs for accessing the host element and shadow root of a custom element. - Support mounting custom elements without Shadow DOM by passing\nshadowRoot: false\n. - Support providing a\nnonce\noption, which will be attached to<style>\ntags injected by custom elements.\nThese new custom-element-only options can be passed to defineCustomElement\nvia a second argument:\nimport MyElement from './MyElement.ce.vue'\ndefineCustomElements(MyElement, {\nshadowRoot: false,\nnonce: 'xxx',\nconfigureApp(app) {\napp.config.errorHandler = ...\n}\n})\nOther Notable Features\nuseTemplateRef()\n3.5 introduces a new way of obtaining Template Refs via the useTemplateRef()\nAPI:\n<script setup>\nimport { useTemplateRef } from 'vue'\nconst inputRef = useTemplateRef('input')\n</script>\n<template>\n<input ref=\"input\">\n</template>\nPrior to 3.5, we recommended using plain refs with variable names matching static ref\nattributes. The old approach required the ref\nattributes to be analyzable by the compiler and thus was limited to static ref\nattributes. In comparison, useTemplateRef()\nmatches the refs via runtime string IDs, therefore supporting dynamic ref bindings to changing IDs.\n@vue/language-tools\n2.1 has also implemented special support for the new syntax, so you will get auto-completion and warnings when using useTemplateRef()\nbased on presence of ref\nattributes in your template:\nDeferred Teleport\nA known constraint of the built-in <Teleport>\ncomponent is that its target element must exist at the time the teleport component is mounted. This prevented users from teleporting content to other elements rendered by Vue after the teleport.\nIn 3.5, we have introduced a defer\nprop for <Teleport>\nwhich mounts it after the current render cycle, so this will now work:\n<Teleport defer target=\"#container\">...</Teleport>\n<div id=\"container\"></div>\nThis behavior requires the defer\nprop because the default behavior needs to be backwards compatible.\nDetails: PR#11387\nonWatcherCleanup()\n3.5 introduces a globally imported API, onWatcherCleanup()\n, for registering cleanup callbacks in watchers:\nimport { watch, onWatcherCleanup } from 'vue'\nwatch(id, (newId) => {\nconst controller = new AbortController()\nfetch(`/api/${newId}`, { signal: controller.signal }).then(() => {\n// callback logic\n})\nonWatcherCleanup(() => {\n// abort stale request\ncontroller.abort()\n})\n})\n- Related: new docs section on Side Effect Cleanup\nFor a comprehensive list of changes and features in 3.5, check out of the the full changelog on GitHub. Happy hacking!"},
{"source": "https://blog.vuejs.org/posts/vue-3-as-the-new-default", "title": "Vue 3 as the New Default", "text": "- Published on\nVue 3 as the New Default\n- Authors\n- Name\n- Evan You\n- @youyuxi\nTL;DR: Vue 3 is now the new default version as of Monday, February 7, 2022!\nMake sure to read the Potential Required Actions section to see if you need to make certain changes before the switch to avoid breakage.\nFrom a Library to a Framework\nWhen Vue first started, it was just a runtime library. Over the years, it has evolved into a framework that encompasses many sub projects:\n- The core library, i.e. the\nvue\nnpm package - The documentation, with enough content to be considered a book\n- The build toolchain, i.e. Vue CLI, vue-loader and other supporting packages\n- Vue Router for building SPA\n- Vuex for state management\n- Browser devtools extension for debugging and profiling\n- Vetur, the VSCode extension for Single-File Component IDE support\n- ESLint plugin for static style / error checking\n- Vue Test Utils for component testing\n- Custom JSX transforms that leverages Vue's runtime features\n- VuePress for Vue-based static site generation\nThis is only possible because Vue is a community-driven project. Many of these projects were started by community members who later became Vue team members. The rest were originally started by me, but are now almost entirely maintained by the team (with the exception of the core library).\nSoft Launch of Vue 3\nWith the core releasing a new major version, all the other parts of the framework needed to move forward together. We also needed to provide a migration path for Vue 2 users. This was a massive undertaking for a community-drive team like Vue. When Vue 3 core was ready, most other parts of the framework were either in beta or still awaiting update. We decided to go ahead and release the core so that the early adopters, library authors and higher-level frameworks can start building with it while we worked on the rest of the framework.\nAt the same time, we kept Vue 2 as the default for documentation and npm installs. This is because we knew that for many users, Vue 2 still provided a more coherent and comprehensive experience until other parts of Vue 3 are refined.\nThe New Vue\nThis soft launch process took longer than we hoped, but we are finally here: we are excited to announce that Vue 3 will become the new default version on Monday, February 7, 2022.\nOutside of Vue core, we have improved almost every aspect of the framework:\n- Blazing fast, Vite-powered build toolchain\n- More ergonomic Composition API syntax via\n<script setup>\n- Improved TypeScript IDE support for Single File Components via Volar\n- Command line type checking for SFCs via vue-tsc\n- Simpler state management via Pinia\n- New devtools extension with simultaneous Vue 2 / Vue 3 support and a plugin system that allows community libraries to hook into the devtools panels\nWe also completely reworked the main documentation. The new vuejs.org (currently in staging) will provide updated framework overview and recommendations, flexible learning paths for users from different backgrounds, the ability to toggle between Options API and Composition API throughout the guide and examples, and many new deep dive sections. It's also very fast - which we will discuss in more details in a separate blog post soon.\nVersion Switch Details\nHere are the details on what we mean by \"the new default\". In addition, please read the Potential Required Actions section to see if you need to make certain changes before the switch to avoid breakage.\nnpm dist tags\nnpm install vue\nnow installs Vue 3 by default.The\nlatest\ndist tag of all other official npm packages now point to Vue 3 compatible versions, includingvue-router\n,vuex\n,vue-loader\n, and@vue/test-utils\n.\nOfficial docs and sites\nAll documentation and official sites now default to Vue 3 versions. These include:\n- vuejs.org\n- router.vuejs.org\n- vuex.vuejs.org\n- vue-test-utils.vuejs.org (moved to test-utils.vuejs.org)\n- template-explorer.vuejs.org\nThe current Vue 2 versions of these sites have been moved to new addresses (the version prefixes indicate the libraries' respective versions, not Vue core's):\n- vuejs.org -> v2.vuejs.org (old v2 URLs will auto redirect to the new address)\n- router.vuejs.org -> v3.router.vuejs.org\n- vuex.vuejs.org -> v3.vuex.vuejs.org\n- vue-test-utils.vuejs.org -> v1.test-utils.vuejs.org\n- template-explorer.vuejs.org -> v2.template-explorer.vuejs.org\nGitHub repos\nAll GitHub repos under the vuejs\norganization have switched to Vue 3 versions in the default branch. In addition, we have renamed the following repos to remove next\nin their names:\nvuejs/vue-next\n->vuejs/core\nvuejs/vue-router-next\n->vuejs/router\nvuejs/docs-next\n->vuejs/docs\nvuejs/vue-test-utils-next\n->vuejs/test-utils\nvuejs/jsx-next\n->vuejs/babel-plugin-jsx\nTranslation repos for the main documentation are moved to the vuejs-translations\norganization.\nGitHub handles repo directs automatically, so previous links to source code and issues should still work.\nDevtools extension\nDevtools v6, which was previously published under the beta channel on Chrome Web Store, is now published under the stable channel.\nThe previous version of the devtools extension is still be available and has been moved to the legacy channel.\nPotential Required Actions\nUnversioned CDN Usage\nIf you are using Vue 2 via a CDN link without specifying a version, make sure to specify a version range via @2\n:\n- <script src=\"https://unpkg.com/vue\"></script>\n+ <script src=\"https://unpkg.com/vue@2\"></script>\n- <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js\"></script>\n+ <script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.min.js\"></script>\nNote: even if using Vue 3, you should also always specify a version range in production to avoid accidentally loading future major versions.\nNPM latest\nTag\nIf you are installing Vue or other official libraries from npm using the latest\ntag or *\n, please update to explicitly use Vue 2 compatible versions:\n{\n\"dependencies\": {\n- \"vue\": \"latest\",\n+ \"vue\": \"^2.6.14\",\n- \"vue-router\": \"latest\",\n+ \"vue-router\": \"^3.5.3\",\n- \"vuex\": \"latest\"\n+ \"vuex\": \"^3.6.2\"\n},\n\"devDependencies\": {\n- \"vue-loader\": \"latest\",\n+ \"vue-loader\": \"^15.9.8\",\n- \"@vue/test-utils\": \"latest\"\n+ \"@vue/test-utils\": \"^1.3.0\"\n}\n}"},
{"source": "https://blog.vuejs.org/posts/vue-3-as-the-new-default.html", "title": "Vue 3 as the New Default", "text": "- Published on\nVue 3 as the New Default\n- Authors\n- Name\n- Evan You\n- @youyuxi\nTL;DR: Vue 3 is now the new default version as of Monday, February 7, 2022!\nMake sure to read the Potential Required Actions section to see if you need to make certain changes before the switch to avoid breakage.\nFrom a Library to a Framework\nWhen Vue first started, it was just a runtime library. Over the years, it has evolved into a framework that encompasses many sub projects:\n- The core library, i.e. the\nvue\nnpm package - The documentation, with enough content to be considered a book\n- The build toolchain, i.e. Vue CLI, vue-loader and other supporting packages\n- Vue Router for building SPA\n- Vuex for state management\n- Browser devtools extension for debugging and profiling\n- Vetur, the VSCode extension for Single-File Component IDE support\n- ESLint plugin for static style / error checking\n- Vue Test Utils for component testing\n- Custom JSX transforms that leverages Vue's runtime features\n- VuePress for Vue-based static site generation\nThis is only possible because Vue is a community-driven project. Many of these projects were started by community members who later became Vue team members. The rest were originally started by me, but are now almost entirely maintained by the team (with the exception of the core library).\nSoft Launch of Vue 3\nWith the core releasing a new major version, all the other parts of the framework needed to move forward together. We also needed to provide a migration path for Vue 2 users. This was a massive undertaking for a community-drive team like Vue. When Vue 3 core was ready, most other parts of the framework were either in beta or still awaiting update. We decided to go ahead and release the core so that the early adopters, library authors and higher-level frameworks can start building with it while we worked on the rest of the framework.\nAt the same time, we kept Vue 2 as the default for documentation and npm installs. This is because we knew that for many users, Vue 2 still provided a more coherent and comprehensive experience until other parts of Vue 3 are refined.\nThe New Vue\nThis soft launch process took longer than we hoped, but we are finally here: we are excited to announce that Vue 3 will become the new default version on Monday, February 7, 2022.\nOutside of Vue core, we have improved almost every aspect of the framework:\n- Blazing fast, Vite-powered build toolchain\n- More ergonomic Composition API syntax via\n<script setup>\n- Improved TypeScript IDE support for Single File Components via Volar\n- Command line type checking for SFCs via vue-tsc\n- Simpler state management via Pinia\n- New devtools extension with simultaneous Vue 2 / Vue 3 support and a plugin system that allows community libraries to hook into the devtools panels\nWe also completely reworked the main documentation. The new vuejs.org (currently in staging) will provide updated framework overview and recommendations, flexible learning paths for users from different backgrounds, the ability to toggle between Options API and Composition API throughout the guide and examples, and many new deep dive sections. It's also very fast - which we will discuss in more details in a separate blog post soon.\nVersion Switch Details\nHere are the details on what we mean by \"the new default\". In addition, please read the Potential Required Actions section to see if you need to make certain changes before the switch to avoid breakage.\nnpm dist tags\nnpm install vue\nnow installs Vue 3 by default.The\nlatest\ndist tag of all other official npm packages now point to Vue 3 compatible versions, includingvue-router\n,vuex\n,vue-loader\n, and@vue/test-utils\n.\nOfficial docs and sites\nAll documentation and official sites now default to Vue 3 versions. These include:\n- vuejs.org\n- router.vuejs.org\n- vuex.vuejs.org\n- vue-test-utils.vuejs.org (moved to test-utils.vuejs.org)\n- template-explorer.vuejs.org\nThe current Vue 2 versions of these sites have been moved to new addresses (the version prefixes indicate the libraries' respective versions, not Vue core's):\n- vuejs.org -> v2.vuejs.org (old v2 URLs will auto redirect to the new address)\n- router.vuejs.org -> v3.router.vuejs.org\n- vuex.vuejs.org -> v3.vuex.vuejs.org\n- vue-test-utils.vuejs.org -> v1.test-utils.vuejs.org\n- template-explorer.vuejs.org -> v2.template-explorer.vuejs.org\nGitHub repos\nAll GitHub repos under the vuejs\norganization have switched to Vue 3 versions in the default branch. In addition, we have renamed the following repos to remove next\nin their names:\nvuejs/vue-next\n->vuejs/core\nvuejs/vue-router-next\n->vuejs/router\nvuejs/docs-next\n->vuejs/docs\nvuejs/vue-test-utils-next\n->vuejs/test-utils\nvuejs/jsx-next\n->vuejs/babel-plugin-jsx\nTranslation repos for the main documentation are moved to the vuejs-translations\norganization.\nGitHub handles repo directs automatically, so previous links to source code and issues should still work.\nDevtools extension\nDevtools v6, which was previously published under the beta channel on Chrome Web Store, is now published under the stable channel.\nThe previous version of the devtools extension is still be available and has been moved to the legacy channel.\nPotential Required Actions\nUnversioned CDN Usage\nIf you are using Vue 2 via a CDN link without specifying a version, make sure to specify a version range via @2\n:\n- <script src=\"https://unpkg.com/vue\"></script>\n+ <script src=\"https://unpkg.com/vue@2\"></script>\n- <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js\"></script>\n+ <script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.min.js\"></script>\nNote: even if using Vue 3, you should also always specify a version range in production to avoid accidentally loading future major versions.\nNPM latest\nTag\nIf you are installing Vue or other official libraries from npm using the latest\ntag or *\n, please update to explicitly use Vue 2 compatible versions:\n{\n\"dependencies\": {\n- \"vue\": \"latest\",\n+ \"vue\": \"^2.6.14\",\n- \"vue-router\": \"latest\",\n+ \"vue-router\": \"^3.5.3\",\n- \"vuex\": \"latest\"\n+ \"vuex\": \"^3.6.2\"\n},\n\"devDependencies\": {\n- \"vue-loader\": \"latest\",\n+ \"vue-loader\": \"^15.9.8\",\n- \"@vue/test-utils\": \"latest\"\n+ \"@vue/test-utils\": \"^1.3.0\"\n}\n}"},
{"source": "https://blog.vuejs.org/posts/vue-3-one-piece", "title": "Announcing Vue 3.0 \"One Piece\"", "text": "- Published on\nAnnouncing Vue 3.0 \"One Piece\"\n- Authors\n- Name\n- Evan You\n- @youyuxi\nToday we are proud to announce the official release of Vue.js 3.0 \"One Piece\". This new major version of the framework provides improved performance, smaller bundle sizes, better TypeScript integration, new APIs for tackling large scale use cases, and a solid foundation for long-term future iterations of the framework.\nThe 3.0 release represents over 2 years of development efforts, featuring 30+ RFCs, 2,600+ commits, 628 pull requests from 99 contributors, plus tremendous amount of development and documentation work outside of the core repo. We would like to express our deepest gratitude towards our team members for taking on this challenge, our contributors for the pull requests, our sponsors and backers for the financial support, and the wider community for participating in our design discussions and providing feedback for the pre-release versions. Vue is an independent project created for the community and sustained by the community, and Vue 3.0 wouldn't have been possible without your consistent support.\nTaking the \"Progressive Framework\" Concept Further\nVue had a simple mission from its humble beginning: to be an approachable framework that anyone can quickly learn. As our user base grew, the framework also grew in scope to adapt to the increasing demands. Over time, it evolved into what we call a \"Progressive Framework\": a framework that can be learned and adopted incrementally, while providing continued support as the user tackles more and more demanding scenarios.\nToday, with over 1.3 million users worldwide*, we are seeing Vue being used in a wildly diverse range of scenarios, from sprinkling interactivity on traditional server-rendered pages, to full-blown single page applications with hundreds of components. Vue 3 takes this flexibility even further.\nLayered internal modules\nVue 3.0 core can still be used via a simple <script>\ntag, but its internals has been re-written from the ground up into a collection of decoupled modules. The new architecture provides better maintainability, and allows end users to shave off up to half of the runtime size via tree-shaking.\nThese modules also exposes lower-level APIs that unlocks many advanced use cases:\n- The compiler supports custom AST transforms for build-time customizations (e.g. build-time i18n)\n- The core runtime provides first-class API for creating custom renderers targeting different render targets (e.g. native mobile, WebGL or terminals). The default DOM renderer is built using the same API.\n- The\n@vue/reactivity\nmodule exports functions that provide direct access to Vue's reactivity system, and can be used as a standalone package. It can be used to pair with other templating solutions (e.g. lit-html) or even in non-UI scenarios.\nNew APIs for tackling scale\nThe 2.x Object-based API is largely intact in Vue 3. However, 3.0 also introduces the Composition API - a new set of APIs aimed at addressing the pain points of Vue usage in large scale applications. The Composition API builds on top of the reactivity API and enables logic composition and reuse similar to React hooks, more flexible code organization patterns, and more reliable type inference than the 2.x Object-based API.\nComposition API can also be used with Vue 2.x via the @vue/composition-api plugin, and there are already Composition API utility libraries that work for both Vue 2 and 3 (e.g. vueuse, vue-composable).\nPerformance Improvements\nVue 3 has demonstrated significant performance improvements over Vue 2 in terms of bundle size (up to 41% lighter with tree-shaking), initial render (up to 55% faster), updates (up to 133% faster), and memory usage (up to 54% less).\nIn Vue 3, we have taken the approach of \"compiler-informed Virtual DOM\": the template compiler performs aggressive optimizations and generates render function code that hoists static content, leaves runtime hints for binding types, and most importantly, flattens the dynamic nodes inside a template to reduce the cost of runtime traversal. The user therefore gets the best of both worlds: compiler-optimized performance from templates, or direct control via manual render functions when the use case demands.\nImproved TypeScript integration\nVue 3's codebase is written in TypeScript, with automatically generated, tested, and bundled type definitions so they are always up-to-date. Composition API works great with type inference. Vetur, our official VSCode extension, now supports template expression and props type checking leveraging Vue 3's improved internal typing. Oh, and Vue 3's typing fully supports TSX if that's your preference.\nExperimental Features\nWe have proposed two new features for Singe-File Components (SFC, aka .vue\nfiles):\n<script setup>\n: syntactic sugar for using Composition API inside SFCs<style vars>\n: state-driven CSS variables inside SFCs\nThese features are already implemented and available in Vue 3.0, but are provided only for the purpose of gathering feedback. They will remain experimental until the RFCs are merged.\nWe have also implemented a currently undocumented <Suspense>\ncomponent, which allows waiting on nested async dependencies (async components or component with async setup()\n) on initial render or branch switch. We are testing and iterating on this feature with the Nuxt.js team (Nuxt 3 is on the way) and will likely solidify it in 3.1.\nPhased Release Process\nThe release of Vue 3.0 marks the general readiness of the framework. While some of the frameworks sub projects may still need further work to reach stable status (specifically router and Vuex integration in the devtools), we believe it's suitable to start new, green-field projects with Vue 3 today. We also encourage library authors to start upgrading your projects to support Vue 3.\nCheck out the Vue 3 Libraries Guide for details on all framework sub projects.\nMigration and IE11 Support\nWe have pushed back the migration build (v3 build with v2 compatible behavior + migration warnings) and the IE11 build due to time constraints, and are aiming to focus on them in Q4 2020. Therefore, users planning to migrate an existing v2 app or require IE11 support should be aware of these limitations at this time.\nNext Steps\nFor the near term after release, we will focus on:\n- Migration build\n- IE11 support\n- Router and Vuex integration in new devtools\n- Further improvements to template type inference in Vetur\nFor the time being, the documentation websites, GitHub branches, and npm dist tags for Vue 3 and v3-targeting projects will remain under next\n-denoted status. This means npm install vue\nwill still install Vue 2.x and npm install vue@next\nwill install Vue 3. We are planning to switch all doc links, branches and dist tags to default to 3.0 in early 2021.\nAt the same time, we have started planning for 2.7, which will be the last planned minor release of the 2.x release line. 2.7 will be backporting compatible improvements from v3, and emit warnings on usage of APIs that are removed/changed in v3 to help with potential migration. We are planning to work on 2.7 in Q1 2021, which will directly become LTS upon release with an 18 months maintenance lifespan.\nTrying It Out\nTo learn more about Vue 3.0, check out our new documentation website. If you are an existing Vue 2.x user, go directly to the Migration Guide.\n- *based on Vue Devtools Chrome extension weekly active users as reported by Google."}]