[{"source": "https://developer.chrome.com/docs/extensions/reference", "title": "Extensions / Reference | Chrome for Developers", "text": "Reference\nReference documentation for Chrome extensions.\nLooking for Manifest V2 documentation? See here.\nLooking for Manifest V2 documentation? See here.\nAPI reference\nLearn about extension APIs and capabilities.\nManifest reference\nSee supported manifest keys.\nPermissions reference\nLearn about permissions needed for extension features."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/accessibilityFeatures", "title": "chrome.accessibilityFeatures | API | Chrome for Developers", "text": "Description\nUse the chrome.accessibilityFeatures\nAPI to manage Chrome's accessibility features. This API relies on the ChromeSetting prototype of the type API for getting and setting individual accessibility features. In order to get feature states the extension must request accessibilityFeatures.read\npermission. For modifying feature state, the extension needs accessibilityFeatures.modify\npermission. Note that accessibilityFeatures.modify\ndoes not imply accessibilityFeatures.read\npermission.\nPermissions\naccessibilityFeatures.modify\naccessibilityFeatures.read\nProperties\nanimationPolicy\nget()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<\"allowed\"\n| \"once\"\n| \"none\"\n>\nautoclick\nChromeOS only.\nAuto mouse click after mouse stops moving. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\ncaretHighlight\nChromeOS only.\nCaret highlighting. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\ncursorColor\nChromeOS only.\nCursor color. The value indicates whether the feature is enabled or not, doesn't indicate the color of it. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\ncursorHighlight\nChromeOS only.\nCursor highlighting. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\ndictation\nChromeOS only.\nDictation. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\ndockedMagnifier\nChromeOS only.\nDocked magnifier. The value indicates whether docked magnifier feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\nfocusHighlight\nChromeOS only.\nFocus highlighting. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\nhighContrast\nChromeOS only.\nHigh contrast rendering mode. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\nlargeCursor\nChromeOS only.\nEnlarged cursor. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\nscreenMagnifier\nChromeOS only.\nFull screen magnification. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\nselectToSpeak\nChromeOS only.\nSelect-to-speak. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\nspokenFeedback\nChromeOS only.\nSpoken feedback (text-to-speech). The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\nstickyKeys\nChromeOS only.\nSticky modifier keys (like shift or alt). The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\nswitchAccess\nChromeOS only.\nSwitch Access. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\nvirtualKeyboard\nChromeOS only.\nVirtual on-screen keyboard. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/action", "title": "chrome.action | API | Chrome for Developers", "text": "Description\nUse the chrome.action\nAPI to control the extension's icon in the Google Chrome toolbar.\nAvailability\nManifest\nTo use the chrome.action\nAPI, specify a \"manifest_version\"\nof 3\nand include\nthe \"action\"\nkey in your manifest file.\n{\n\"name\": \"Action Extension\",\n...\n\"action\": {\n\"default_icon\": { // optional\n\"16\": \"images/icon16.png\", // optional\n\"24\": \"images/icon24.png\", // optional\n\"32\": \"images/icon32.png\" // optional\n},\n\"default_title\": \"Click Me\", // optional, shown in tooltip\n\"default_popup\": \"popup.html\" // optional\n},\n...\n}\nThe \"action\"\nkey (along with its children) is optional. When it isn't included, your extension is still shown in the toolbar to provide access to the extension's menu. For this reason, we recommend that you always include at least the \"action\"\nand \"default_icon\"\nkeys.\nConcepts and usage\nParts of the UI\nIcon\nThe icon is the main image on the toolbar for your extension, and is set by the \"default_icon\"\nkey in\nyour manifest's \"action\"\nkey. Icons must be 16 device-independent pixels (DIPs) wide and tall.\nThe \"default_icon\"\nkey is a dictionary of sizes to image paths. Chrome uses these icons\nto choose which image scale to use. If an exact match is not found, Chrome selects the closest\navailable and scales it to fit the image, which might affect image quality.\nBecause devices with less-common scale factors like 1.5x or 1.2x are becoming more\ncommon, we encourage you to provide multiple sizes for your icons. This also\nfutureproofs your extension against potential icon display size changes. However,\nif only providing a single size, the \"default_icon\"\nkey can also be set to a\nstring with the path to a single icon instead of a dictionary.\nYou can also call action.setIcon()\nto set your extension's icon programmatically\nby specifying a different image path or providing a dynamically-generated icon using the HTML canvas\nelement, or, if setting from an extension service worker, the offscreen\ncanvas API.\nconst canvas = new OffscreenCanvas(16, 16);\nconst context = canvas.getContext('2d');\ncontext.clearRect(0, 0, 16, 16);\ncontext.fillStyle = '#00FF00'; // Green\ncontext.fillRect(0, 0, 16, 16);\nconst imageData = context.getImageData(0, 0, 16, 16);\nchrome.action.setIcon({imageData: imageData}, () => { /* ... */ });\nFor packed extensions (installed from a .crx file), images can be in most formats that the Blink rendering engine can display, including PNG, JPEG, BMP, ICO, and others. SVG isn't supported. Unpacked extensions must use PNG images.\nTooltip (title)\nThe tooltip, or title, appears when the user holds their mouse pointer over the extension's icon in the toolbar. It's also included in the accessible text spoken by screen readers when the button gets focus.\nThe default tooltip is set using the \"default_title\"\nfield of the \"action\"\nkey in manifest.json\n.\nYou can also set it programmatically by calling action.setTitle()\n.\nBadge\nActions can optionally display a \"badge\" \u2014 a bit of text layered over the icon. This lets you update the action to display a small amount of information about the state of the extension, such as a counter. The badge has a text component and a background color. Because space is limited, we recommend that badge text use four or fewer characters.\nTo create a badge, set it programmatically by calling action.setBadgeBackgroundColor()\nand\naction.setBadgeText()\n. There isn't a default badge setting in the manifest. Badge color values\ncan be either an array of four integers between 0 and 255 that make up the RGBA color of the\nbadge or a string with a CSS color value.\nchrome.action.setBadgeBackgroundColor(\n{color: [0, 255, 0, 0]}, // Green\n() => { /* ... */ },\n);\nchrome.action.setBadgeBackgroundColor(\n{color: '#00FF00'}, // Also green\n() => { /* ... */ },\n);\nchrome.action.setBadgeBackgroundColor(\n{color: 'green'}, // Also, also green\n() => { /* ... */ },\n);\nPopup\nAn action's popup is shown when the user clicks on the extension's action button in the toolbar. The popup can contain any HTML contents you like, and will be automatically sized to fit its contents. The popup's size must be between 25x25 and 800x600 pixels.\nThe popup is initially set by the \"default_popup\"\nproperty in the \"action\"\nkey in the\nmanifest.json\nfile. If present, this property should point to a relative path within the extension\ndirectory. It can also be updated dynamically to point to a different relative path using the\naction.setPopup()\nmethod.\nUse cases\nPer-tab state\nExtension actions can have different states for each tab. To set a value for an individual\ntab, use the tabId\nproperty in the action\nAPI's setting methods. For example, to\nset the badge text for a specific tab, do something like the following:\nfunction getTabId() { /* ... */}\nfunction getTabBadge() { /* ... */}\nchrome.action.setBadgeText(\n{\ntext: getTabBadge(tabId),\ntabId: getTabId(),\n},\n() => { ... }\n);\nIf the tabId\nproperty is left out, the setting is treated as a global setting. Tab-specific\nsettings take priority over global settings.\nEnabled state\nBy default, toolbar actions are enabled (clickable) on every tab. You can change this default\nby setting the default_state\nproperty in the action\nkey of the manifest. If\ndefault_state\nis set to \"disabled\"\n, the action is disabled by default and must be enabled\nprogrammatically to be clickable. If default_state\nis set to \"enabled\"\n(the default),\nthe action is enabled and clickable by default.\nYou can control the state programmatically using the action.enable()\nand action.disable()\nmethods. This only affects whether the popup (if any) or action.onClicked\nevent is sent\nto your extension; it doesn't affect the action's presence in the toolbar.\nExamples\nThe following examples show some common ways that actions are used in extensions. To try this API, install the Action API example from the chrome-extension-samples repository.\nShow a popup\nIt's common for an extension to display a popup when the user clicks the extension's action. To\nimplement this in your own extension, declare the popup in your manifest.json\nand specify the\ncontent that Chrome should display in the popup.\n// manifest.json\n{\n\"name\": \"Action popup demo\",\n\"version\": \"1.0\",\n\"manifest_version\": 3,\n\"action\": {\n\"default_title\": \"Click to view a popup\",\n\"default_popup\": \"popup.html\"\n}\n}\n<!-- popup.html -->\n<!DOCTYPE html>\n<html>\n<head>\n<style>\nhtml {\nmin-height: 5em;\nmin-width: 10em;\nbackground: salmon;\n}\n</style>\n</head>\n<body>\n<p>Hello, world!</p>\n</body>\n</html>\nInject a content script on click\nA common pattern for extensions is to expose their primary feature using the extension's action. The following example demonstrates this pattern. When the user clicks the action, the extension injects a content script into the current page. The content script then displays an alert to verify that everything worked as expected.\n// manifest.json\n{\n\"name\": \"Action script injection demo\",\n\"version\": \"1.0\",\n\"manifest_version\": 3,\n\"action\": {\n\"default_title\": \"Click to show an alert\"\n},\n\"permissions\": [\"activeTab\", \"scripting\"],\n\"background\": {\n\"service_worker\": \"background.js\"\n}\n}\n// background.js\nchrome.action.onClicked.addListener((tab) => {\nchrome.scripting.executeScript({\ntarget: {tabId: tab.id},\nfiles: ['content.js']\n});\n});\n// content.js\nalert('Hello, world!');\nEmulate actions with declarativeContent\nThis example shows how an extension's background logic can (a) disable an action by default and (b) use declarativeContent to enable the action on specific sites.\n// service-worker.js\n// Wrap in an onInstalled callback to avoid unnecessary work\n// every time the service worker is run\nchrome.runtime.onInstalled.addListener(() => {\n// Page actions are disabled by default and enabled on select tabs\nchrome.action.disable();\n// Clear all rules to ensure only our expected rules are set\nchrome.declarativeContent.onPageChanged.removeRules(undefined, () => {\n// Declare a rule to enable the action on example.com pages\nlet exampleRule = {\nconditions: [\nnew chrome.declarativeContent.PageStateMatcher({\npageUrl: {hostSuffix: '.example.com'},\n})\n],\nactions: [new chrome.declarativeContent.ShowAction()],\n};\n// Finally, apply our new array of rules\nlet rules = [exampleRule];\nchrome.declarativeContent.onPageChanged.addRules(rules);\n});\n});\nTypes\nOpenPopupOptions\nProperties\n-\nwindowId\nnumber optional\nThe ID of the window to open the action popup in. Defaults to the currently-active window if unspecified.\nTabDetails\nProperties\n-\ntabId\nnumber optional\nThe ID of the tab to query state for. If no tab is specified, the non-tab-specific state is returned.\nUserSettings\nThe collection of user-specified settings relating to an extension's action.\nProperties\n-\nisOnToolbar\nboolean\nWhether the extension's action icon is visible on browser windows' top-level toolbar (i.e., whether the extension has been 'pinned' by the user).\nUserSettingsChange\nProperties\n-\nisOnToolbar\nboolean optional\nWhether the extension's action icon is visible on browser windows' top-level toolbar (i.e., whether the extension has been 'pinned' by the user).\nMethods\ndisable()\nchrome.action.disable(\ntabId?: number,\ncallback?: function,\n)\nDisables the action for a tab.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab for which you want to modify the action.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nenable()\nchrome.action.enable(\ntabId?: number,\ncallback?: function,\n)\nEnables the action for a tab. By default, actions are enabled.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab for which you want to modify the action.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetBadgeBackgroundColor()\nchrome.action.getBadgeBackgroundColor(\ndetails: TabDetails,\ncallback?: function,\n)\nGets the background color of the action.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: ColorArray) => void\n-\nresult\n-\nReturns\n-\nPromise<browserAction.ColorArray>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetBadgeText()\nchrome.action.getBadgeText(\ndetails: TabDetails,\ncallback?: function,\n)\nGets the badge text of the action. If no tab is specified, the non-tab-specific badge text is returned. If displayActionCountAsBadgeText is enabled, a placeholder text will be returned unless the declarativeNetRequestFeedback permission is present or tab-specific badge text was provided.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: string) => void\n-\nresult\nstring\n-\nReturns\n-\nPromise<string>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetBadgeTextColor()\nchrome.action.getBadgeTextColor(\ndetails: TabDetails,\ncallback?: function,\n)\nGets the text color of the action.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: ColorArray) => void\n-\nresult\n-\nReturns\n-\nPromise<browserAction.ColorArray>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetPopup()\nchrome.action.getPopup(\ndetails: TabDetails,\ncallback?: function,\n)\nGets the html document set as the popup for this action.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: string) => void\n-\nresult\nstring\n-\nReturns\n-\nPromise<string>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetTitle()\nchrome.action.getTitle(\ndetails: TabDetails,\ncallback?: function,\n)\nGets the title of the action.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: string) => void\n-\nresult\nstring\n-\nReturns\n-\nPromise<string>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetUserSettings()\nchrome.action.getUserSettings(\ncallback?: function,\n)\nReturns the user-specified settings relating to an extension's action.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(userSettings: UserSettings) => void\n-\nuserSettings\n-\nReturns\n-\nPromise<UserSettings>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nisEnabled()\nchrome.action.isEnabled(\ntabId?: number,\ncallback?: function,\n)\nIndicates whether the extension action is enabled for a tab (or globally if no tabId\nis provided). Actions enabled using only declarativeContent\nalways return false.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab for which you want check enabled status.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(isEnabled: boolean) => void\n-\nisEnabled\nboolean\nTrue if the extension action is enabled.\n-\nReturns\n-\nPromise<boolean>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nopenPopup()\nchrome.action.openPopup(\noptions?: OpenPopupOptions,\ncallback?: function,\n)\nOpens the extension's popup. Between Chrome 118 and Chrome 126, this is only available to policy installed extensions.\nParameters\n-\noptions\nOpenPopupOptions optional\nSpecifies options for opening the popup.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetBadgeBackgroundColor()\nchrome.action.setBadgeBackgroundColor(\ndetails: object,\ncallback?: function,\n)\nSets the background color for the badge.\nParameters\n-\ndetails\nobject\n-\ncolor\nstring | ColorArray\nAn array of four integers in the range [0,255] that make up the RGBA color of the badge. For example, opaque red is\n[255, 0, 0, 255]\n. Can also be a string with a CSS value, with opaque red being#FF0000\nor#F00\n. -\ntabId\nnumber optional\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetBadgeText()\nchrome.action.setBadgeText(\ndetails: object,\ncallback?: function,\n)\nSets the badge text for the action. The badge is displayed on top of the icon.\nParameters\n-\ndetails\nobject\n-\ntabId\nnumber optional\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n-\ntext\nstring optional\nAny number of characters can be passed, but only about four can fit in the space. If an empty string (\n''\n) is passed, the badge text is cleared. IftabId\nis specified andtext\nis null, the text for the specified tab is cleared and defaults to the global badge text.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetBadgeTextColor()\nchrome.action.setBadgeTextColor(\ndetails: object,\ncallback?: function,\n)\nSets the text color for the badge.\nParameters\n-\ndetails\nobject\n-\ncolor\nstring | ColorArray\nAn array of four integers in the range [0,255] that make up the RGBA color of the badge. For example, opaque red is\n[255, 0, 0, 255]\n. Can also be a string with a CSS value, with opaque red being#FF0000\nor#F00\n. Not setting this value will cause a color to be automatically chosen that will contrast with the badge's background color so the text will be visible. Colors with alpha values equivalent to 0 will not be set and will return an error. -\ntabId\nnumber optional\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetIcon()\nchrome.action.setIcon(\ndetails: object,\ncallback?: function,\n)\nSets the icon for the action. The icon can be specified either as the path to an image file or as the pixel data from a canvas element, or as dictionary of either one of those. Either the path or the imageData property must be specified.\nParameters\n-\ndetails\nobject\n-\nimageData\nImageData | object optional\nEither an ImageData object or a dictionary {size -> ImageData} representing icon to be set. If the icon is specified as a dictionary, the actual image to be used is chosen depending on screen's pixel density. If the number of image pixels that fit into one screen space unit equals\nscale\n, then image with sizescale\n* n will be selected, where n is the size of the icon in the UI. At least one image must be specified. Note that 'details.imageData = foo' is equivalent to 'details.imageData = {'16': foo}' -\npath\nstring | object optional\nEither a relative image path or a dictionary {size -> relative image path} pointing to icon to be set. If the icon is specified as a dictionary, the actual image to be used is chosen depending on screen's pixel density. If the number of image pixels that fit into one screen space unit equals\nscale\n, then image with sizescale\n* n will be selected, where n is the size of the icon in the UI. At least one image must be specified. Note that 'details.path = foo' is equivalent to 'details.path = {'16': foo}' -\ntabId\nnumber optional\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetPopup()\nchrome.action.setPopup(\ndetails: object,\ncallback?: function,\n)\nSets the HTML document to be opened as a popup when the user clicks on the action's icon.\nParameters\n-\ndetails\nobject\n-\npopup\nstring\nThe relative path to the HTML file to show in a popup. If set to the empty string (\n''\n), no popup is shown. -\ntabId\nnumber optional\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetTitle()\nchrome.action.setTitle(\ndetails: object,\ncallback?: function,\n)\nSets the title of the action. This shows up in the tooltip.\nParameters\n-\ndetails\nobject\n-\ntabId\nnumber optional\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n-\ntitle\nstring\nThe string the action should display when moused over.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonClicked\nchrome.action.onClicked.addListener(\ncallback: function,\n)\nFired when an action icon is clicked. This event will not fire if the action has a popup.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(tab: tabs.Tab) => void\n-\ntab\n-\nonUserSettingsChanged\nchrome.action.onUserSettingsChanged.addListener(\ncallback: function,\n)\nFired when user-specified settings relating to an extension's action change.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(change: UserSettingsChange) => void\n-\nchange\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api", "title": "API reference | Chrome for Developers", "text": "Most extensions need access to one or more Chrome Extensions APIs to function. This API reference describes the APIs available for use in extensions and presents example use cases.\nCommon Extensions API features\nAn Extensions API consists of a namespace containing methods and properties for doing extensions work, and usually, but not\nalways, manifest fields for the manifest.json\nfile. For example, the chrome.action\nnamespace requires an \"action\"\nobject\nin the manifest. Many APIs also require permissions in the manifest.\nMethods in extension APIs are asynchronous unless stated otherwise. Asynchronous methods return immediately, without waiting for the operation that calls them to finish. Use promises to get the results of these asynchronous methods.\nChrome Extension APIs\n- accessibilityFeatures\n-\nUse the\nchrome.accessibilityFeatures\nAPI to manage Chrome's accessibility features. This API relies on the ChromeSetting prototype of the type API for getting and setting individual accessibility features. In order to get feature states the extension must requestaccessibilityFeatures.read\npermission. For modifying feature state, the extension needsaccessibilityFeatures.modify\npermission. Note thataccessibilityFeatures.modify\ndoes not implyaccessibilityFeatures.read\npermission. - action\n-\nChrome 88+ MV3+\nUse the\nchrome.action\nAPI to control the extension's icon in the Google Chrome toolbar. - alarms\n-\nUse the\nchrome.alarms\nAPI to schedule code to run periodically or at a specified time in the future. - audio\n-\nChrome 59+ ChromeOS only\nThe\nchrome.audio\nAPI is provided to allow users to get information about and control the audio devices attached to the system. This API is currently only available in kiosk mode for ChromeOS. - bookmarks\n-\nUse the\nchrome.bookmarks\nAPI to create, organize, and otherwise manipulate bookmarks. Also see Override Pages, which you can use to create a custom Bookmark Manager page. - browsingData\n-\nUse the\nchrome.browsingData\nAPI to remove browsing data from a user's local profile. - certificateProvider\n-\nChrome 46+ ChromeOS only\nUse this API to expose certificates to the platform which can use these certificates for TLS authentications.\n- commands\n-\nUse the commands API to add keyboard shortcuts that trigger actions in your extension, for example, an action to open the browser action or send a command to the extension.\n- contentSettings\n-\nUse the\nchrome.contentSettings\nAPI to change settings that control whether websites can use features such as cookies, JavaScript, and plugins. More generally speaking, content settings allow you to customize Chrome's behavior on a per-site basis instead of globally. - contextMenus\n-\nUse the\nchrome.contextMenus\nAPI to add items to Google Chrome's context menu. You can choose what types of objects your context menu additions apply to, such as images, hyperlinks, and pages. - cookies\n-\nUse the\nchrome.cookies\nAPI to query and modify cookies, and to be notified when they change. - debugger\n-\nThe\nchrome.debugger\nAPI serves as an alternate transport for Chrome's remote debugging protocol. Usechrome.debugger\nto attach to one or more tabs to instrument network interaction, debug JavaScript, mutate the DOM and CSS, and more. Use theDebuggee\npropertytabId\nto target tabs withsendCommand\nand route events bytabId\nfromonEvent\ncallbacks. - declarativeContent\n-\nUse the\nchrome.declarativeContent\nAPI to take actions depending on the content of a page, without requiring permission to read the page's content. - declarativeNetRequest\n-\nChrome 84+\nThe\nchrome.declarativeNetRequest\nAPI is used to block or modify network requests by specifying declarative rules. This lets extensions modify network requests without intercepting them and viewing their content, thus providing more privacy. - desktopCapture\n-\nThe Desktop Capture API captures the content of the screen, individual windows, or individual tabs.\n- devtools.inspectedWindow\n-\nUse the\nchrome.devtools.inspectedWindow\nAPI to interact with the inspected window: obtain the tab ID for the inspected page, evaluate the code in the context of the inspected window, reload the page, or obtain the list of resources within the page. - devtools.network\n-\nUse the\nchrome.devtools.network\nAPI to retrieve the information about network requests displayed by the Developer Tools in the Network panel. - devtools.panels\n-\nUse the\nchrome.devtools.panels\nAPI to integrate your extension into Developer Tools window UI: create your own panels, access existing panels, and add sidebars. - devtools.performance\n-\nChrome 129+\nUse the\nchrome.devtools.performance\nAPI to listen to recording status updates in the Performance panel in DevTools. - devtools.recorder\n-\nChrome 105+\nUse the\nchrome.devtools.recorder\nAPI to customize the Recorder panel in DevTools. - dns\n-\nDev channel\nUse the\nchrome.dns\nAPI for dns resolution. - documentScan\n-\nChrome 44+ ChromeOS only\nUse the\nchrome.documentScan\nAPI to discover and retrieve images from attached document scanners. - dom\n-\nChrome 88+\nUse the\nchrome.dom\nAPI to access special DOM APIs for Extensions - downloads\n-\nUse the\nchrome.downloads\nAPI to programmatically initiate, monitor, manipulate, and search for downloads. - enterprise.deviceAttributes\n-\nUse the\nchrome.enterprise.deviceAttributes\nAPI to read device attributes. Note: This API is only available to extensions force-installed by enterprise policy. - enterprise.hardwarePlatform\n-\nChrome 71+ Requires policy\nUse the\nchrome.enterprise.hardwarePlatform\nAPI to get the manufacturer and model of the hardware platform where the browser runs. Note: This API is only available to extensions installed by enterprise policy. - enterprise.networkingAttributes\n-\nUse the\nchrome.enterprise.networkingAttributes\nAPI to read information about your current network. Note: This API is only available to extensions force-installed by enterprise policy. - enterprise.platformKeys\n-\nChromeOS only Requires policy\nUse the\nchrome.enterprise.platformKeys\nAPI to generate keys and install certificates for these keys. The certificates will be managed by the platform and can be used for TLS authentication, network access or by other extension through chrome.platformKeys. - events\n-\nThe\nchrome.events\nnamespace contains common types used by APIs dispatching events to notify you when something interesting happens. - extension\n-\nThe\nchrome.extension\nAPI has utilities that can be used by any extension page. It includes support for exchanging messages between an extension and its content scripts or between extensions, as described in detail in Message Passing. - extensionTypes\n-\nThe\nchrome.extensionTypes\nAPI contains type declarations for Chrome extensions. - fileBrowserHandler\n-\nChromeOS only Foreground only\nUse the\nchrome.fileBrowserHandler\nAPI to extend the Chrome OS file browser. For example, you can use this API to enable users to upload files to your website. - fileSystemProvider\n-\nChromeOS only\nUse the\nchrome.fileSystemProvider\nAPI to create file systems, that can be accessible from the file manager on Chrome OS. - fontSettings\n-\nUse the\nchrome.fontSettings\nAPI to manage Chrome's font settings. - gcm\n-\nUse\nchrome.gcm\nto enable apps and extensions to send and receive messages through Firebase Cloud Messaging (FCM). - history\n-\nUse the\nchrome.history\nAPI to interact with the browser's record of visited pages. You can add, remove, and query for URLs in the browser's history. To override the history page with your own version, see Override Pages. - i18n\n-\nUse the\nchrome.i18n\ninfrastructure to implement internationalization across your whole app or extension. - identity\n-\nUse the\nchrome.identity\nAPI to get OAuth2 access tokens. - idle\n-\nUse the\nchrome.idle\nAPI to detect when the machine's idle state changes. - input.ime\n-\nChromeOS only\nUse the\nchrome.input.ime\nAPI to implement a custom IME for Chrome OS. This allows your extension to handle keystrokes, set the composition, and manage the candidate window. - instanceID\n-\nChrome 44+\nUse\nchrome.instanceID\nto access the Instance ID service. - loginState\n-\nChrome 78+ ChromeOS only\nUse the\nchrome.loginState\nAPI to read and monitor the login state. - management\n-\nThe\nchrome.management\nAPI provides ways to manage installed apps and extensions. - notifications\n-\nUse the\nchrome.notifications\nAPI to create rich notifications using templates and show these notifications to users in the system tray. - offscreen\n-\nChrome 109+ MV3+\nUse the\noffscreen\nAPI to create and manage offscreen documents. - omnibox\n-\nThe omnibox API allows you to register a keyword with Google Chrome's address bar, which is also known as the omnibox.\n- pageCapture\n-\nUse the\nchrome.pageCapture\nAPI to save a tab as MHTML. - permissions\n-\nUse the\nchrome.permissions\nAPI to request declared optional permissions at run time rather than install time, so users understand why the permissions are needed and grant only those that are necessary. - platformKeys\n-\nChrome 45+ ChromeOS only\nUse the\nchrome.platformKeys\nAPI to access client certificates managed by the platform. If the user or policy grants the permission, an extension can use such a certficate in its custom authentication protocol. E.g. this allows usage of platform managed certificates in third party VPNs (see chrome.vpnProvider). - power\n-\nUse the\nchrome.power\nAPI to override the system's power management features. - printerProvider\n-\nChrome 44+\nThe\nchrome.printerProvider\nAPI exposes events used by print manager to query printers controlled by extensions, to query their capabilities and to submit print jobs to these printers. - printing\n-\nChrome 81+ ChromeOS only\nUse the\nchrome.printing\nAPI to send print jobs to printers installed on Chromebook. - printingMetrics\n-\nUse the\nchrome.printingMetrics\nAPI to fetch data about printing usage. - privacy\n-\nUse the\nchrome.privacy\nAPI to control usage of the features in Chrome that can affect a user's privacy. This API relies on the ChromeSetting prototype of the type API for getting and setting Chrome's configuration. - processes\n-\nDev channel\nUse the\nchrome.processes\nAPI to interact with the browser's processes. - proxy\n-\nUse the\nchrome.proxy\nAPI to manage Chrome's proxy settings. This API relies on the ChromeSetting prototype of the type API for getting and setting the proxy configuration. - readingList\n-\nChrome 120+ MV3+\nUse the\nchrome.readingList\nAPI to read from and modify the items in the Reading List. - runtime\n-\nUse the\nchrome.runtime\nAPI to retrieve the service worker, return details about the manifest, and listen for and respond to events in the extension lifecycle. You can also use this API to convert the relative path of URLs to fully-qualified URLs. - scripting\n-\nChrome 88+ MV3+\nUse the\nchrome.scripting\nAPI to execute script in different contexts. - search\n-\nChrome 87+\nUse the\nchrome.search\nAPI to search via the default provider. - sessions\n-\nUse the\nchrome.sessions\nAPI to query and restore tabs and windows from a browsing session. - sidePanel\n-\nChrome 114+ MV3+\nUse the\nchrome.sidePanel\nAPI to host content in the browser's side panel alongside the main content of a webpage. - storage\n-\nUse the\nchrome.storage\nAPI to store, retrieve, and track changes to user data. - system.cpu\n-\nUse the\nsystem.cpu\nAPI to query CPU metadata. - system.display\n-\nUse the\nsystem.display\nAPI to query display metadata. - system.memory\n-\nThe\nchrome.system.memory\nAPI. - system.storage\n-\nUse the\nchrome.system.storage\nAPI to query storage device information and be notified when a removable storage device is attached and detached. - systemLog\n-\nUse the\nchrome.systemLog\nAPI to record Chrome system logs from extensions. - tabCapture\n-\nUse the\nchrome.tabCapture\nAPI to interact with tab media streams. - tabGroups\n-\nChrome 89+ MV3+\nUse the\nchrome.tabGroups\nAPI to interact with the browser's tab grouping system. You can use this API to modify and rearrange tab groups in the browser. To group and ungroup tabs, or to query what tabs are in groups, use thechrome.tabs\nAPI. - tabs\n-\nUse the\nchrome.tabs\nAPI to interact with the browser's tab system. You can use this API to create, modify, and rearrange tabs in the browser. - topSites\n-\nUse the\nchrome.topSites\nAPI to access the top sites (i.e. most visited sites) that are displayed on the new tab page. These do not include shortcuts customized by the user. - tts\n-\nUse the\nchrome.tts\nAPI to play synthesized text-to-speech (TTS). See also the relatedttsEngine\nAPI, which allows an extension to implement a speech engine. - ttsEngine\n-\nUse the\nchrome.ttsEngine\nAPI to implement a text-to-speech(TTS) engine using an extension. If your extension registers using this API, it will receive events containing an utterance to be spoken and other parameters when any extension or Chrome App uses thetts\nAPI to generate speech. Your extension can then use any available web technology to synthesize and output the speech, and send events back to the calling function to report the status. - types\n-\nThe\nchrome.types\nAPI contains type declarations for Chrome. - userScripts\n-\nChrome 120+ MV3+\nUse the\nuserScripts\nAPI to execute user scripts in the User Scripts context. - vpnProvider\n-\nChrome 43+ ChromeOS only\nUse the\nchrome.vpnProvider\nAPI to implement a VPN client. - wallpaper\n-\nChrome 43+ ChromeOS only\nUse the\nchrome.wallpaper\nAPI to change the ChromeOS wallpaper. - webAuthenticationProxy\n-\nChrome 115+ MV3+\nThe\nchrome.webAuthenticationProxy\nAPI lets remote desktop software running on a remote host intercept Web Authentication API (WebAuthn) requests in order to handle them on a local client. - webNavigation\n-\nUse the\nchrome.webNavigation\nAPI to receive notifications about the status of navigation requests in-flight. - webRequest\n-\nUse the\nchrome.webRequest\nAPI to observe and analyze traffic and to intercept, block, or modify requests in-flight. - windows\n-\nUse the\nchrome.windows\nAPI to interact with browser windows. You can use this API to create, modify, and rearrange windows in the browser."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/accessibilityFeatures", "title": "chrome.accessibilityFeatures | API | Chrome for Developers", "text": "Description\nUse the chrome.accessibilityFeatures\nAPI to manage Chrome's accessibility features. This API relies on the ChromeSetting prototype of the type API for getting and setting individual accessibility features. In order to get feature states the extension must request accessibilityFeatures.read\npermission. For modifying feature state, the extension needs accessibilityFeatures.modify\npermission. Note that accessibilityFeatures.modify\ndoes not imply accessibilityFeatures.read\npermission.\nPermissions\naccessibilityFeatures.modify\naccessibilityFeatures.read\nProperties\nanimationPolicy\nget()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<\"allowed\"\n| \"once\"\n| \"none\"\n>\nautoclick\nChromeOS only.\nAuto mouse click after mouse stops moving. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\ncaretHighlight\nChromeOS only.\nCaret highlighting. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\ncursorColor\nChromeOS only.\nCursor color. The value indicates whether the feature is enabled or not, doesn't indicate the color of it. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\ncursorHighlight\nChromeOS only.\nCursor highlighting. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\ndictation\nChromeOS only.\nDictation. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\ndockedMagnifier\nChromeOS only.\nDocked magnifier. The value indicates whether docked magnifier feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\nfocusHighlight\nChromeOS only.\nFocus highlighting. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\nhighContrast\nChromeOS only.\nHigh contrast rendering mode. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\nlargeCursor\nChromeOS only.\nEnlarged cursor. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\nscreenMagnifier\nChromeOS only.\nFull screen magnification. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\nselectToSpeak\nChromeOS only.\nSelect-to-speak. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\nspokenFeedback\nChromeOS only.\nSpoken feedback (text-to-speech). The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\nstickyKeys\nChromeOS only.\nSticky modifier keys (like shift or alt). The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\nswitchAccess\nChromeOS only.\nSwitch Access. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>\nvirtualKeyboard\nChromeOS only.\nVirtual on-screen keyboard. The value indicates whether the feature is enabled or not. get()\nrequires accessibilityFeatures.read\npermission. set()\nand clear()\nrequire accessibilityFeatures.modify\npermission.\nType\ntypes.ChromeSetting<boolean>"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/action", "title": "chrome.action | API | Chrome for Developers", "text": "Description\nUse the chrome.action\nAPI to control the extension's icon in the Google Chrome toolbar.\nAvailability\nManifest\nTo use the chrome.action\nAPI, specify a \"manifest_version\"\nof 3\nand include\nthe \"action\"\nkey in your manifest file.\n{\n\"name\": \"Action Extension\",\n...\n\"action\": {\n\"default_icon\": { // optional\n\"16\": \"images/icon16.png\", // optional\n\"24\": \"images/icon24.png\", // optional\n\"32\": \"images/icon32.png\" // optional\n},\n\"default_title\": \"Click Me\", // optional, shown in tooltip\n\"default_popup\": \"popup.html\" // optional\n},\n...\n}\nThe \"action\"\nkey (along with its children) is optional. When it isn't included, your extension is still shown in the toolbar to provide access to the extension's menu. For this reason, we recommend that you always include at least the \"action\"\nand \"default_icon\"\nkeys.\nConcepts and usage\nParts of the UI\nIcon\nThe icon is the main image on the toolbar for your extension, and is set by the \"default_icon\"\nkey in\nyour manifest's \"action\"\nkey. Icons must be 16 device-independent pixels (DIPs) wide and tall.\nThe \"default_icon\"\nkey is a dictionary of sizes to image paths. Chrome uses these icons\nto choose which image scale to use. If an exact match is not found, Chrome selects the closest\navailable and scales it to fit the image, which might affect image quality.\nBecause devices with less-common scale factors like 1.5x or 1.2x are becoming more\ncommon, we encourage you to provide multiple sizes for your icons. This also\nfutureproofs your extension against potential icon display size changes. However,\nif only providing a single size, the \"default_icon\"\nkey can also be set to a\nstring with the path to a single icon instead of a dictionary.\nYou can also call action.setIcon()\nto set your extension's icon programmatically\nby specifying a different image path or providing a dynamically-generated icon using the HTML canvas\nelement, or, if setting from an extension service worker, the offscreen\ncanvas API.\nconst canvas = new OffscreenCanvas(16, 16);\nconst context = canvas.getContext('2d');\ncontext.clearRect(0, 0, 16, 16);\ncontext.fillStyle = '#00FF00'; // Green\ncontext.fillRect(0, 0, 16, 16);\nconst imageData = context.getImageData(0, 0, 16, 16);\nchrome.action.setIcon({imageData: imageData}, () => { /* ... */ });\nFor packed extensions (installed from a .crx file), images can be in most formats that the Blink rendering engine can display, including PNG, JPEG, BMP, ICO, and others. SVG isn't supported. Unpacked extensions must use PNG images.\nTooltip (title)\nThe tooltip, or title, appears when the user holds their mouse pointer over the extension's icon in the toolbar. It's also included in the accessible text spoken by screen readers when the button gets focus.\nThe default tooltip is set using the \"default_title\"\nfield of the \"action\"\nkey in manifest.json\n.\nYou can also set it programmatically by calling action.setTitle()\n.\nBadge\nActions can optionally display a \"badge\" \u2014 a bit of text layered over the icon. This lets you update the action to display a small amount of information about the state of the extension, such as a counter. The badge has a text component and a background color. Because space is limited, we recommend that badge text use four or fewer characters.\nTo create a badge, set it programmatically by calling action.setBadgeBackgroundColor()\nand\naction.setBadgeText()\n. There isn't a default badge setting in the manifest. Badge color values\ncan be either an array of four integers between 0 and 255 that make up the RGBA color of the\nbadge or a string with a CSS color value.\nchrome.action.setBadgeBackgroundColor(\n{color: [0, 255, 0, 0]}, // Green\n() => { /* ... */ },\n);\nchrome.action.setBadgeBackgroundColor(\n{color: '#00FF00'}, // Also green\n() => { /* ... */ },\n);\nchrome.action.setBadgeBackgroundColor(\n{color: 'green'}, // Also, also green\n() => { /* ... */ },\n);\nPopup\nAn action's popup is shown when the user clicks on the extension's action button in the toolbar. The popup can contain any HTML contents you like, and will be automatically sized to fit its contents. The popup's size must be between 25x25 and 800x600 pixels.\nThe popup is initially set by the \"default_popup\"\nproperty in the \"action\"\nkey in the\nmanifest.json\nfile. If present, this property should point to a relative path within the extension\ndirectory. It can also be updated dynamically to point to a different relative path using the\naction.setPopup()\nmethod.\nUse cases\nPer-tab state\nExtension actions can have different states for each tab. To set a value for an individual\ntab, use the tabId\nproperty in the action\nAPI's setting methods. For example, to\nset the badge text for a specific tab, do something like the following:\nfunction getTabId() { /* ... */}\nfunction getTabBadge() { /* ... */}\nchrome.action.setBadgeText(\n{\ntext: getTabBadge(tabId),\ntabId: getTabId(),\n},\n() => { ... }\n);\nIf the tabId\nproperty is left out, the setting is treated as a global setting. Tab-specific\nsettings take priority over global settings.\nEnabled state\nBy default, toolbar actions are enabled (clickable) on every tab. You can change this default\nby setting the default_state\nproperty in the action\nkey of the manifest. If\ndefault_state\nis set to \"disabled\"\n, the action is disabled by default and must be enabled\nprogrammatically to be clickable. If default_state\nis set to \"enabled\"\n(the default),\nthe action is enabled and clickable by default.\nYou can control the state programmatically using the action.enable()\nand action.disable()\nmethods. This only affects whether the popup (if any) or action.onClicked\nevent is sent\nto your extension; it doesn't affect the action's presence in the toolbar.\nExamples\nThe following examples show some common ways that actions are used in extensions. To try this API, install the Action API example from the chrome-extension-samples repository.\nShow a popup\nIt's common for an extension to display a popup when the user clicks the extension's action. To\nimplement this in your own extension, declare the popup in your manifest.json\nand specify the\ncontent that Chrome should display in the popup.\n// manifest.json\n{\n\"name\": \"Action popup demo\",\n\"version\": \"1.0\",\n\"manifest_version\": 3,\n\"action\": {\n\"default_title\": \"Click to view a popup\",\n\"default_popup\": \"popup.html\"\n}\n}\n<!-- popup.html -->\n<!DOCTYPE html>\n<html>\n<head>\n<style>\nhtml {\nmin-height: 5em;\nmin-width: 10em;\nbackground: salmon;\n}\n</style>\n</head>\n<body>\n<p>Hello, world!</p>\n</body>\n</html>\nInject a content script on click\nA common pattern for extensions is to expose their primary feature using the extension's action. The following example demonstrates this pattern. When the user clicks the action, the extension injects a content script into the current page. The content script then displays an alert to verify that everything worked as expected.\n// manifest.json\n{\n\"name\": \"Action script injection demo\",\n\"version\": \"1.0\",\n\"manifest_version\": 3,\n\"action\": {\n\"default_title\": \"Click to show an alert\"\n},\n\"permissions\": [\"activeTab\", \"scripting\"],\n\"background\": {\n\"service_worker\": \"background.js\"\n}\n}\n// background.js\nchrome.action.onClicked.addListener((tab) => {\nchrome.scripting.executeScript({\ntarget: {tabId: tab.id},\nfiles: ['content.js']\n});\n});\n// content.js\nalert('Hello, world!');\nEmulate actions with declarativeContent\nThis example shows how an extension's background logic can (a) disable an action by default and (b) use declarativeContent to enable the action on specific sites.\n// service-worker.js\n// Wrap in an onInstalled callback to avoid unnecessary work\n// every time the service worker is run\nchrome.runtime.onInstalled.addListener(() => {\n// Page actions are disabled by default and enabled on select tabs\nchrome.action.disable();\n// Clear all rules to ensure only our expected rules are set\nchrome.declarativeContent.onPageChanged.removeRules(undefined, () => {\n// Declare a rule to enable the action on example.com pages\nlet exampleRule = {\nconditions: [\nnew chrome.declarativeContent.PageStateMatcher({\npageUrl: {hostSuffix: '.example.com'},\n})\n],\nactions: [new chrome.declarativeContent.ShowAction()],\n};\n// Finally, apply our new array of rules\nlet rules = [exampleRule];\nchrome.declarativeContent.onPageChanged.addRules(rules);\n});\n});\nTypes\nOpenPopupOptions\nProperties\n-\nwindowId\nnumber optional\nThe ID of the window to open the action popup in. Defaults to the currently-active window if unspecified.\nTabDetails\nProperties\n-\ntabId\nnumber optional\nThe ID of the tab to query state for. If no tab is specified, the non-tab-specific state is returned.\nUserSettings\nThe collection of user-specified settings relating to an extension's action.\nProperties\n-\nisOnToolbar\nboolean\nWhether the extension's action icon is visible on browser windows' top-level toolbar (i.e., whether the extension has been 'pinned' by the user).\nUserSettingsChange\nProperties\n-\nisOnToolbar\nboolean optional\nWhether the extension's action icon is visible on browser windows' top-level toolbar (i.e., whether the extension has been 'pinned' by the user).\nMethods\ndisable()\nchrome.action.disable(\ntabId?: number,\ncallback?: function,\n)\nDisables the action for a tab.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab for which you want to modify the action.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nenable()\nchrome.action.enable(\ntabId?: number,\ncallback?: function,\n)\nEnables the action for a tab. By default, actions are enabled.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab for which you want to modify the action.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetBadgeBackgroundColor()\nchrome.action.getBadgeBackgroundColor(\ndetails: TabDetails,\ncallback?: function,\n)\nGets the background color of the action.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: ColorArray) => void\n-\nresult\n-\nReturns\n-\nPromise<browserAction.ColorArray>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetBadgeText()\nchrome.action.getBadgeText(\ndetails: TabDetails,\ncallback?: function,\n)\nGets the badge text of the action. If no tab is specified, the non-tab-specific badge text is returned. If displayActionCountAsBadgeText is enabled, a placeholder text will be returned unless the declarativeNetRequestFeedback permission is present or tab-specific badge text was provided.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: string) => void\n-\nresult\nstring\n-\nReturns\n-\nPromise<string>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetBadgeTextColor()\nchrome.action.getBadgeTextColor(\ndetails: TabDetails,\ncallback?: function,\n)\nGets the text color of the action.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: ColorArray) => void\n-\nresult\n-\nReturns\n-\nPromise<browserAction.ColorArray>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetPopup()\nchrome.action.getPopup(\ndetails: TabDetails,\ncallback?: function,\n)\nGets the html document set as the popup for this action.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: string) => void\n-\nresult\nstring\n-\nReturns\n-\nPromise<string>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetTitle()\nchrome.action.getTitle(\ndetails: TabDetails,\ncallback?: function,\n)\nGets the title of the action.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: string) => void\n-\nresult\nstring\n-\nReturns\n-\nPromise<string>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetUserSettings()\nchrome.action.getUserSettings(\ncallback?: function,\n)\nReturns the user-specified settings relating to an extension's action.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(userSettings: UserSettings) => void\n-\nuserSettings\n-\nReturns\n-\nPromise<UserSettings>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nisEnabled()\nchrome.action.isEnabled(\ntabId?: number,\ncallback?: function,\n)\nIndicates whether the extension action is enabled for a tab (or globally if no tabId\nis provided). Actions enabled using only declarativeContent\nalways return false.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab for which you want check enabled status.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(isEnabled: boolean) => void\n-\nisEnabled\nboolean\nTrue if the extension action is enabled.\n-\nReturns\n-\nPromise<boolean>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nopenPopup()\nchrome.action.openPopup(\noptions?: OpenPopupOptions,\ncallback?: function,\n)\nOpens the extension's popup. Between Chrome 118 and Chrome 126, this is only available to policy installed extensions.\nParameters\n-\noptions\nOpenPopupOptions optional\nSpecifies options for opening the popup.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetBadgeBackgroundColor()\nchrome.action.setBadgeBackgroundColor(\ndetails: object,\ncallback?: function,\n)\nSets the background color for the badge.\nParameters\n-\ndetails\nobject\n-\ncolor\nstring | ColorArray\nAn array of four integers in the range [0,255] that make up the RGBA color of the badge. For example, opaque red is\n[255, 0, 0, 255]\n. Can also be a string with a CSS value, with opaque red being#FF0000\nor#F00\n. -\ntabId\nnumber optional\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetBadgeText()\nchrome.action.setBadgeText(\ndetails: object,\ncallback?: function,\n)\nSets the badge text for the action. The badge is displayed on top of the icon.\nParameters\n-\ndetails\nobject\n-\ntabId\nnumber optional\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n-\ntext\nstring optional\nAny number of characters can be passed, but only about four can fit in the space. If an empty string (\n''\n) is passed, the badge text is cleared. IftabId\nis specified andtext\nis null, the text for the specified tab is cleared and defaults to the global badge text.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetBadgeTextColor()\nchrome.action.setBadgeTextColor(\ndetails: object,\ncallback?: function,\n)\nSets the text color for the badge.\nParameters\n-\ndetails\nobject\n-\ncolor\nstring | ColorArray\nAn array of four integers in the range [0,255] that make up the RGBA color of the badge. For example, opaque red is\n[255, 0, 0, 255]\n. Can also be a string with a CSS value, with opaque red being#FF0000\nor#F00\n. Not setting this value will cause a color to be automatically chosen that will contrast with the badge's background color so the text will be visible. Colors with alpha values equivalent to 0 will not be set and will return an error. -\ntabId\nnumber optional\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetIcon()\nchrome.action.setIcon(\ndetails: object,\ncallback?: function,\n)\nSets the icon for the action. The icon can be specified either as the path to an image file or as the pixel data from a canvas element, or as dictionary of either one of those. Either the path or the imageData property must be specified.\nParameters\n-\ndetails\nobject\n-\nimageData\nImageData | object optional\nEither an ImageData object or a dictionary {size -> ImageData} representing icon to be set. If the icon is specified as a dictionary, the actual image to be used is chosen depending on screen's pixel density. If the number of image pixels that fit into one screen space unit equals\nscale\n, then image with sizescale\n* n will be selected, where n is the size of the icon in the UI. At least one image must be specified. Note that 'details.imageData = foo' is equivalent to 'details.imageData = {'16': foo}' -\npath\nstring | object optional\nEither a relative image path or a dictionary {size -> relative image path} pointing to icon to be set. If the icon is specified as a dictionary, the actual image to be used is chosen depending on screen's pixel density. If the number of image pixels that fit into one screen space unit equals\nscale\n, then image with sizescale\n* n will be selected, where n is the size of the icon in the UI. At least one image must be specified. Note that 'details.path = foo' is equivalent to 'details.path = {'16': foo}' -\ntabId\nnumber optional\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetPopup()\nchrome.action.setPopup(\ndetails: object,\ncallback?: function,\n)\nSets the HTML document to be opened as a popup when the user clicks on the action's icon.\nParameters\n-\ndetails\nobject\n-\npopup\nstring\nThe relative path to the HTML file to show in a popup. If set to the empty string (\n''\n), no popup is shown. -\ntabId\nnumber optional\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetTitle()\nchrome.action.setTitle(\ndetails: object,\ncallback?: function,\n)\nSets the title of the action. This shows up in the tooltip.\nParameters\n-\ndetails\nobject\n-\ntabId\nnumber optional\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n-\ntitle\nstring\nThe string the action should display when moused over.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonClicked\nchrome.action.onClicked.addListener(\ncallback: function,\n)\nFired when an action icon is clicked. This event will not fire if the action has a popup.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(tab: tabs.Tab) => void\n-\ntab\n-\nonUserSettingsChanged\nchrome.action.onUserSettingsChanged.addListener(\ncallback: function,\n)\nFired when user-specified settings relating to an extension's action change.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(change: UserSettingsChange) => void\n-\nchange\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/alarms", "title": "chrome.alarms | API | Chrome for Developers", "text": "Description\nUse the chrome.alarms\nAPI to schedule code to run periodically or at a specified time in the future.\nPermissions\nalarms\nTo use the chrome.alarms\nAPI, declare the \"alarms\"\npermission in the manifest:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"alarms\"\n],\n...\n}\nConcepts and usage\nTo ensure reliable behavior, it is helpful to understand how the API behaves.\nDevice sleep\nAlarms continue to run while a device is sleeping. However, an alarm will not wake up a device. When the device wakes up, any missed alarms will fire. Repeating alarms will fire at most once and then be rescheduled using the specified period starting from when the device wakes, not taking into account any time that has already elapsed since the alarm was originally set to run.\nPersistence\nAlarms generally persist until an extension is updated. However, this is not guaranteed, and alarms may be cleared when the browser is restarted. Consequently, consider setting a value in storage when an alarm is created, and then ensure it exists each time your service worker starts up. For example:\nconst STORAGE_KEY = \"user-preference-alarm-enabled\";\nasync function checkAlarmState() {\nconst { alarmEnabled } = await chrome.storage.get(STORAGE_KEY);\nif (alarmEnabled) {\nconst alarm = await chrome.alarms.get(\"my-alarm\");\nif (!alarm) {\nawait chrome.alarms.create({ periodInMinutes: 1 });\n}\n}\n}\ncheckAlarmState();\nExamples\nThe following examples show how to use and respond to an alarm. To try this API, install the Alarm API example from the chrome-extension-samples repository.\nSet an alarm\nThe following example sets an alarm in the service worker when the extension is installed:\nservice-worker.js:\nchrome.runtime.onInstalled.addListener(async ({ reason }) => {\nif (reason !== 'install') {\nreturn;\n}\n// Create an alarm so we have something to look at in the demo\nawait chrome.alarms.create('demo-default-alarm', {\ndelayInMinutes: 1,\nperiodInMinutes: 1\n});\n});\nRespond to an alarm\nThe following example sets the action toolbar icon based on the name of the alarm that went off.\nservice-worker.js:\nchrome.alarms.onAlarm.addListener((alarm) => {\nchrome.action.setIcon({\npath: getIconPath(alarm.name),\n});\n});\nTypes\nAlarm\nProperties\n-\nname\nstring\nName of this alarm.\n-\nperiodInMinutes\nnumber optional\nIf not null, the alarm is a repeating alarm and will fire again in\nperiodInMinutes\nminutes. -\nscheduledTime\nnumber\nTime at which this alarm was scheduled to fire, in milliseconds past the epoch (e.g.\nDate.now() + n\n). For performance reasons, the alarm may have been delayed an arbitrary amount beyond this.\nAlarmCreateInfo\nProperties\n-\ndelayInMinutes\nnumber optional\nLength of time in minutes after which the\nonAlarm\nevent should fire. -\nperiodInMinutes\nnumber optional\nIf set, the onAlarm event should fire every\nperiodInMinutes\nminutes after the initial event specified bywhen\nordelayInMinutes\n. If not set, the alarm will only fire once. -\nwhen\nnumber optional\nTime at which the alarm should fire, in milliseconds past the epoch (e.g.\nDate.now() + n\n).\nMethods\nclear()\nchrome.alarms.clear(\nname?: string,\ncallback?: function,\n)\nClears the alarm with the given name.\nParameters\n-\nname\nstring optional\nThe name of the alarm to clear. Defaults to the empty string.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(wasCleared: boolean) => void\n-\nwasCleared\nboolean\n-\nReturns\n-\nPromise<boolean>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nclearAll()\nchrome.alarms.clearAll(\ncallback?: function,\n)\nClears all alarms.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(wasCleared: boolean) => void\n-\nwasCleared\nboolean\n-\nReturns\n-\nPromise<boolean>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ncreate()\nchrome.alarms.create(\nname?: string,\nalarmInfo: AlarmCreateInfo,\ncallback?: function,\n)\nCreates an alarm. Near the time(s) specified by alarmInfo\n, the onAlarm\nevent is fired. If there is another alarm with the same name (or no name if none is specified), it will be cancelled and replaced by this alarm.\nIn order to reduce the load on the user's machine, Chrome limits alarms to at most once every 30 seconds but may delay them an arbitrary amount more. That is, setting delayInMinutes\nor periodInMinutes\nto less than 0.5\nwill not be honored and will cause a warning. when\ncan be set to less than 30 seconds after \"now\" without warning but won't actually cause the alarm to fire for at least 30 seconds.\nTo help you debug your app or extension, when you've loaded it unpacked, there's no limit to how often the alarm can fire.\nParameters\n-\nname\nstring optional\nOptional name to identify this alarm. Defaults to the empty string.\n-\nalarmInfo\nDescribes when the alarm should fire. The initial time must be specified by either\nwhen\nordelayInMinutes\n(but not both). IfperiodInMinutes\nis set, the alarm will repeat everyperiodInMinutes\nminutes after the initial event. If neitherwhen\nordelayInMinutes\nis set for a repeating alarm,periodInMinutes\nis used as the default fordelayInMinutes\n. -\ncallback\nfunction optional\nChrome 111+The\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 111+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nget()\nchrome.alarms.get(\nname?: string,\ncallback?: function,\n)\nRetrieves details about the specified alarm.\nParameters\nReturns\n-\nPromise<Alarm | undefined>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetAll()\nchrome.alarms.getAll(\ncallback?: function,\n)\nGets an array of all the alarms.\nParameters\nReturns\n-\nPromise<Alarm[]>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/audio", "title": "chrome.audio | API | Chrome for Developers", "text": "Description\nThe chrome.audio\nAPI is provided to allow users to get information about and control the audio devices attached to the system. This API is currently only available in kiosk mode for ChromeOS.\nPermissions\naudio\nAvailability\nTypes\nAudioDeviceInfo\nProperties\n-\ndeviceName\nstring\nDevice name.\n-\ndeviceType\nType of the device.\n-\ndisplayName\nstring\nThe user-friendly name (e.g. \"USB Microphone\").\n-\nid\nstring\nThe unique identifier of the audio device.\n-\nisActive\nboolean\nTrue if this is the current active device.\n-\nlevel\nnumber\nThe sound level of the device, volume for output, gain for input.\n-\nstableDeviceId\nstring optional\nThe stable/persisted device id string when available.\n-\nstreamType\nStream type associated with this device.\nDeviceFilter\nProperties\n-\nisActive\nboolean optional\nIf set, only audio devices whose active state matches this value will satisfy the filter.\n-\nstreamTypes\nStreamType[] optional\nIf set, only audio devices whose stream type is included in this list will satisfy the filter.\nDeviceIdLists\nProperties\n-\ninput\nstring[] optional\nList of input devices specified by their ID.\nTo indicate input devices should be unaffected, leave this property unset.\n-\noutput\nstring[] optional\nList of output devices specified by their ID.\nTo indicate output devices should be unaffected, leave this property unset.\nDeviceProperties\nProperties\n-\nlevel\nnumber optional\nThe audio device's desired sound level. Defaults to the device's current sound level.\nIf used with audio input device, represents audio device gain.\nIf used with audio output device, represents audio device volume.\nDeviceType\nAvailable audio device types.\nEnum\n\"HEADPHONE\" \"MIC\" \"USB\" \"BLUETOOTH\" \"HDMI\" \"INTERNAL_SPEAKER\" \"INTERNAL_MIC\" \"FRONT_MIC\" \"REAR_MIC\" \"KEYBOARD_MIC\" \"HOTWORD\" \"LINEOUT\" \"POST_MIX_LOOPBACK\" \"POST_DSP_LOOPBACK\" \"ALSA_LOOPBACK\" \"OTHER\"\nLevelChangedEvent\nProperties\n-\ndeviceId\nstring\nID of device whose sound level has changed.\n-\nlevel\nnumber\nThe device's new sound level.\nMuteChangedEvent\nProperties\n-\nisMuted\nboolean\nWhether or not the stream is now muted.\n-\nstreamType\nThe type of the stream for which the mute value changed. The updated mute value applies to all devices with this stream type.\nStreamType\nType of stream an audio device provides.\nEnum\n\"INPUT\" \"OUTPUT\"\nMethods\ngetDevices()\nchrome.audio.getDevices(\nfilter?: DeviceFilter,\ncallback?: function,\n)\nGets a list of audio devices filtered based on filter\n.\nParameters\n-\nfilter\nDeviceFilter optional\nDevice properties by which to filter the list of returned audio devices. If the filter is not set or set to\n{}\n, returned device list will contain all available audio devices. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(devices: AudioDeviceInfo[]) => void\n-\ndevices\n-\nReturns\n-\nPromise<AudioDeviceInfo[]>\nChrome 116+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetMute()\nchrome.audio.getMute(\nstreamType: StreamType,\ncallback?: function,\n)\nGets the system-wide mute state for the specified stream type.\nParameters\n-\nstreamType\nStream type for which mute state should be fetched.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(value: boolean) => void\n-\nvalue\nboolean\n-\nReturns\n-\nPromise<boolean>\nChrome 116+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetActiveDevices()\nchrome.audio.setActiveDevices(\nids: DeviceIdLists,\ncallback?: function,\n)\nSets lists of active input and/or output devices.\nParameters\n-\nids\nSpecifies IDs of devices that should be active. If either the input or output list is not set, devices in that category are unaffected.\nIt is an error to pass in a non-existent device ID.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 116+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetMute()\nchrome.audio.setMute(\nstreamType: StreamType,\nisMuted: boolean,\ncallback?: function,\n)\nSets mute state for a stream type. The mute state will apply to all audio devices with the specified audio stream type.\nParameters\n-\nstreamType\nStream type for which mute state should be set.\n-\nisMuted\nboolean\nNew mute value.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 116+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetProperties()\nchrome.audio.setProperties(\nid: string,\nproperties: DeviceProperties,\ncallback?: function,\n)\nSets the properties for the input or output device.\nParameters\n-\nid\nstring\n-\nproperties\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 116+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonDeviceListChanged\nchrome.audio.onDeviceListChanged.addListener(\ncallback: function,\n)\nFired when audio devices change, either new devices being added, or existing devices being removed.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(devices: AudioDeviceInfo[]) => void\n-\ndevices\n-\nonLevelChanged\nchrome.audio.onLevelChanged.addListener(\ncallback: function,\n)\nFired when sound level changes for an active audio device.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(event: LevelChangedEvent) => void\n-\nevent\n-\nonMuteChanged\nchrome.audio.onMuteChanged.addListener(\ncallback: function,\n)\nFired when the mute state of the audio input or output changes. Note that mute state is system-wide and the new value applies to every audio device with specified stream type.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(event: MuteChangedEvent) => void\n-\nevent\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/bookmarks", "title": "chrome.bookmarks | API | Chrome for Developers", "text": "Description\nUse the chrome.bookmarks\nAPI to create, organize, and otherwise manipulate bookmarks. Also see Override Pages, which you can use to create a custom Bookmark Manager page.\nPermissions\nbookmarks\nYou must declare the \"bookmarks\" permission in the extension manifest to use the bookmarks API. For example:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"bookmarks\"\n],\n...\n}\nConcepts and usage\nObjects and properties\nBookmarks are organized in a tree, where each node in the tree is either a bookmark or a folder (sometimes called a group). Each node in the tree is represented by a bookmarks.BookmarkTreeNode object.\nBookmarkTreeNode\nproperties are used throughout the chrome.bookmarks\nAPI. For example, when you\ncall bookmarks.create, you pass in the new node's parent (parentId\n), and, optionally, the\nnode's index\n, title\n, and url\nproperties. See bookmarks.BookmarkTreeNode for information\nabout the properties a node can have.\nExamples\nThe following code creates a folder with the title \"Extension bookmarks\". The first argument to\ncreate()\nspecifies properties for the new folder. The second argument defines a function to be\nexecuted after the folder is created.\nchrome.bookmarks.create(\n{'parentId': bookmarkBar.id, 'title': 'Extension bookmarks'},\nfunction(newFolder) {\nconsole.log(\"added folder: \" + newFolder.title);\n},\n);\nThe next snippet creates a bookmark pointing to the developer documentation for extensions. Since nothing bad will happen if creating the bookmark fails, this code doesn't bother to define a callback function.\nchrome.bookmarks.create({\n'parentId': extensionsFolderId,\n'title': 'Extensions doc',\n'url': 'https://developer.chrome.com/docs/extensions',\n});\nTo try this API, install the Bookmarks API example from the chrome-extension-samples repository.\nTypes\nBookmarkTreeNode\nA node (either a bookmark or a folder) in the bookmark tree. Child nodes are ordered within their parent folder.\nProperties\n-\nchildren\nBookmarkTreeNode[] optional\nAn ordered list of children of this node.\n-\ndateAdded\nnumber optional\nWhen this node was created, in milliseconds since the epoch (\nnew Date(dateAdded)\n). -\ndateGroupModified\nnumber optional\nWhen the contents of this folder last changed, in milliseconds since the epoch.\n-\ndateLastUsed\nnumber optional\nChrome 114+When this node was last opened, in milliseconds since the epoch. Not set for folders.\n-\nid\nstring\nThe unique identifier for the node. IDs are unique within the current profile, and they remain valid even after the browser is restarted.\n-\nindex\nnumber optional\nThe 0-based position of this node within its parent folder.\n-\nparentId\nstring optional\nThe\nid\nof the parent folder. Omitted for the root node. -\ntitle\nstring\nThe text displayed for the node.\n-\nunmodifiable\n\"managed\"\noptionalIndicates the reason why this node is unmodifiable. The\nmanaged\nvalue indicates that this node was configured by the system administrator or by the custodian of a supervised user. Omitted if the node can be modified by the user and the extension (default). -\nurl\nstring optional\nThe URL navigated to when a user clicks the bookmark. Omitted for folders.\nBookmarkTreeNodeUnmodifiable\nIndicates the reason why this node is unmodifiable. The managed\nvalue indicates that this node was configured by the system administrator. Omitted if the node can be modified by the user and the extension (default).\nValue\n\"managed\"\nCreateDetails\nObject passed to the create() function.\nProperties\n-\nindex\nnumber optional\n-\nparentId\nstring optional\nDefaults to the Other Bookmarks folder.\n-\ntitle\nstring optional\n-\nurl\nstring optional\nProperties\nMAX_SUSTAINED_WRITE_OPERATIONS_PER_MINUTE\nBookmark write operations are no longer limited by Chrome.\nValue\n1000000\nMAX_WRITE_OPERATIONS_PER_HOUR\nBookmark write operations are no longer limited by Chrome.\nValue\n1000000\nMethods\ncreate()\nchrome.bookmarks.create(\nbookmark: CreateDetails,\ncallback?: function,\n)\nCreates a bookmark or folder under the specified parentId. If url is NULL or missing, it will be a folder.\nParameters\n-\nbookmark\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: BookmarkTreeNode) => void\n-\nresult\n-\nReturns\n-\nPromise<BookmarkTreeNode>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nget()\nchrome.bookmarks.get(\nidOrIdList: string | [string, ...string[]],\ncallback?: function,\n)\nRetrieves the specified BookmarkTreeNode(s).\nParameters\n-\nidOrIdList\nstring | [string, ...string[]]\nA single string-valued id, or an array of string-valued ids\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(results: BookmarkTreeNode[]) => void\n-\nresults\n-\nReturns\n-\nPromise<BookmarkTreeNode[]>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetChildren()\nchrome.bookmarks.getChildren(\nid: string,\ncallback?: function,\n)\nRetrieves the children of the specified BookmarkTreeNode id.\nParameters\n-\nid\nstring\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(results: BookmarkTreeNode[]) => void\n-\nresults\n-\nReturns\n-\nPromise<BookmarkTreeNode[]>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetRecent()\nchrome.bookmarks.getRecent(\nnumberOfItems: number,\ncallback?: function,\n)\nRetrieves the recently added bookmarks.\nParameters\n-\nnumberOfItems\nnumber\nThe maximum number of items to return.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(results: BookmarkTreeNode[]) => void\n-\nresults\n-\nReturns\n-\nPromise<BookmarkTreeNode[]>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetSubTree()\nchrome.bookmarks.getSubTree(\nid: string,\ncallback?: function,\n)\nRetrieves part of the Bookmarks hierarchy, starting at the specified node.\nParameters\n-\nid\nstring\nThe ID of the root of the subtree to retrieve.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(results: BookmarkTreeNode[]) => void\n-\nresults\n-\nReturns\n-\nPromise<BookmarkTreeNode[]>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetTree()\nchrome.bookmarks.getTree(\ncallback?: function,\n)\nRetrieves the entire Bookmarks hierarchy.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(results: BookmarkTreeNode[]) => void\n-\nresults\n-\nReturns\n-\nPromise<BookmarkTreeNode[]>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nmove()\nchrome.bookmarks.move(\nid: string,\ndestination: object,\ncallback?: function,\n)\nMoves the specified BookmarkTreeNode to the provided location.\nParameters\n-\nid\nstring\n-\ndestination\nobject\n-\nindex\nnumber optional\n-\nparentId\nstring optional\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: BookmarkTreeNode) => void\n-\nresult\n-\nReturns\n-\nPromise<BookmarkTreeNode>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremove()\nchrome.bookmarks.remove(\nid: string,\ncallback?: function,\n)\nRemoves a bookmark or an empty bookmark folder.\nParameters\n-\nid\nstring\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveTree()\nchrome.bookmarks.removeTree(\nid: string,\ncallback?: function,\n)\nRecursively removes a bookmark folder.\nParameters\n-\nid\nstring\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsearch()\nchrome.bookmarks.search(\nquery: string | object,\ncallback?: function,\n)\nSearches for BookmarkTreeNodes matching the given query. Queries specified with an object produce BookmarkTreeNodes matching all specified properties.\nParameters\n-\nquery\nstring | object\nEither a string of words and quoted phrases that are matched against bookmark URLs and titles, or an object. If an object, the properties\nquery\n,url\n, andtitle\nmay be specified and bookmarks matching all specified properties will be produced.-\nquery\nstring optional\nA string of words and quoted phrases that are matched against bookmark URLs and titles.\n-\ntitle\nstring optional\nThe title of the bookmark; matches verbatim.\n-\nurl\nstring optional\nThe URL of the bookmark; matches verbatim. Note that folders have no URL.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(results: BookmarkTreeNode[]) => void\n-\nresults\n-\nReturns\n-\nPromise<BookmarkTreeNode[]>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdate()\nchrome.bookmarks.update(\nid: string,\nchanges: object,\ncallback?: function,\n)\nUpdates the properties of a bookmark or folder. Specify only the properties that you want to change; unspecified properties will be left unchanged. Note: Currently, only 'title' and 'url' are supported.\nParameters\n-\nid\nstring\n-\nchanges\nobject\n-\ntitle\nstring optional\n-\nurl\nstring optional\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: BookmarkTreeNode) => void\n-\nresult\n-\nReturns\n-\nPromise<BookmarkTreeNode>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonChanged\nchrome.bookmarks.onChanged.addListener(\ncallback: function,\n)\nFired when a bookmark or folder changes. Note: Currently, only title and url changes trigger this.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(id: string, changeInfo: object) => void\n-\nid\nstring\n-\nchangeInfo\nobject\n-\ntitle\nstring\n-\nurl\nstring optional\n-\n-\nonChildrenReordered\nchrome.bookmarks.onChildrenReordered.addListener(\ncallback: function,\n)\nFired when the children of a folder have changed their order due to the order being sorted in the UI. This is not called as a result of a move().\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(id: string, reorderInfo: object) => void\n-\nid\nstring\n-\nreorderInfo\nobject\n-\nchildIds\nstring[]\n-\n-\nonCreated\nchrome.bookmarks.onCreated.addListener(\ncallback: function,\n)\nFired when a bookmark or folder is created.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(id: string, bookmark: BookmarkTreeNode) => void\n-\nid\nstring\n-\nbookmark\n-\nonImportBegan\nchrome.bookmarks.onImportBegan.addListener(\ncallback: function,\n)\nFired when a bookmark import session is begun. Expensive observers should ignore onCreated updates until onImportEnded is fired. Observers should still handle other notifications immediately.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonImportEnded\nchrome.bookmarks.onImportEnded.addListener(\ncallback: function,\n)\nFired when a bookmark import session is ended.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonMoved\nchrome.bookmarks.onMoved.addListener(\ncallback: function,\n)\nFired when a bookmark or folder is moved to a different parent folder.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(id: string, moveInfo: object) => void\n-\nid\nstring\n-\nmoveInfo\nobject\n-\nindex\nnumber\n-\noldIndex\nnumber\n-\noldParentId\nstring\n-\nparentId\nstring\n-\n-\nonRemoved\nchrome.bookmarks.onRemoved.addListener(\ncallback: function,\n)\nFired when a bookmark or folder is removed. When a folder is removed recursively, a single notification is fired for the folder, and none for its contents.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(id: string, removeInfo: object) => void\n-\nid\nstring\n-\nremoveInfo\nobject\n-\nindex\nnumber\n-\nnodeChrome 48+\n-\nparentId\nstring\n-\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/browsingData", "title": "chrome.browsingData | API | Chrome for Developers", "text": "Description\nUse the chrome.browsingData\nAPI to remove browsing data from a user's local profile.\nPermissions\nbrowsingData\nYou must declare the \"browsingData\"\npermission in the extension manifest to use this API.\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"browsingData\",\n],\n...\n}\nConcepts and usage\nThe simplest use-case for this API is a a time-based mechanism for clearing a user's browsing data.\nYour code should provide a timestamp which indicates the historical date after which the user's\nbrowsing data should be removed. This timestamp is formatted as the number of milliseconds since the\nUnix epoch (which can be retrieved from a JavaScript Date\nobject using the getTime()\nmethod).\nFor example, to clear all of a user's browsing data from the last week, you might write code as follows:\nvar callback = function () {\n// Do something clever here once data has been removed.\n};\nvar millisecondsPerWeek = 1000 * 60 * 60 * 24 * 7;\nvar oneWeekAgo = (new Date()).getTime() - millisecondsPerWeek;\nchrome.browsingData.remove({\n\"since\": oneWeekAgo\n}, {\n\"appcache\": true,\n\"cache\": true,\n\"cacheStorage\": true,\n\"cookies\": true,\n\"downloads\": true,\n\"fileSystems\": true,\n\"formData\": true,\n\"history\": true,\n\"indexedDB\": true,\n\"localStorage\": true,\n\"passwords\": true,\n\"serviceWorkers\": true,\n\"webSQL\": true\n}, callback);\nThe chrome.browsingData.remove()\nmethod lets you remove various types of browsing data with a\nsingle call, and will be much faster than calling multiple more specific methods. If, however, you\nonly want to clear one specific type of browsing data (cookies, for example), the more granular\nmethods offer a readable alternative to a call filled with JSON.\nvar callback = function () {\n// Do something clever here once data has been removed.\n};\nvar millisecondsPerWeek = 1000 * 60 * 60 * 24 * 7;\nvar oneWeekAgo = (new Date()).getTime() - millisecondsPerWeek;\nchrome.browsingData.removeCookies({\n\"since\": oneWeekAgo\n}, callback);\nIf the user is syncing their data, chrome.browsingData.remove()\nmay automatically rebuild the cookie\nfor the Sync account after clearing it. This is to ensure that Sync can continue working, so that\nthe data can be eventually deleted on the server. However the more specific\nchrome.browsingData.removeCookies()\ncan be used to clear the cookie for the Sync account, and Sync\nwill be paused in this case.\nSpecific origins\nTo remove data for a specific origin or to exclude a set of origins from deletion, you can use the\nRemovalOptions.origins\nand RemovalOptions.excludeOrigins\nparameters. They can only be applied to\ncookies, cache, and storage (CacheStorage, FileSystems, IndexedDB, LocalStorage, ServiceWorkers, and\nWebSQL).\nchrome.browsingData.remove({\n\"origins\": [\"https://www.example.com\"]\n}, {\n\"cacheStorage\": true,\n\"cookies\": true,\n\"fileSystems\": true,\n\"indexedDB\": true,\n\"localStorage\": true,\n\"serviceWorkers\": true,\n\"webSQL\": true\n}, callback);\nOrigin types\nAdding an originTypes\nproperty to the APIs options object lets you specify which types of\norigins ought to be effected. Origins are divided into three categories:\nunprotectedWeb\ncovers the general case of websites that users visit without taking any special action. If you don't specify anoriginTypes\n, the API defaults to removing data from unprotected web origins.protectedWeb\ncovers those web origins that have been installed as hosted applications. Installing Angry Birds, for example, protects the originhttps://chrome.angrybirds.com\n, and removes it from theunprotectedWeb\ncategory. Be careful when triggering deletion of data for these origins: make sure your users know what they're getting, as this will irrevocably remove their game data. No one wants to knock tiny pig houses over more often than necessary.extension\ncovers origins under thechrome-extensions:\nscheme. Removing extension data is, again, something you should be very careful about.\nWe could adjust the previous example to remove only data from protected websites as follows:\nvar callback = function () {\n// Do something clever here once data has been removed.\n};\nvar millisecondsPerWeek = 1000 * 60 * 60 * 24 * 7;\nvar oneWeekAgo = (new Date()).getTime() - millisecondsPerWeek;\nchrome.browsingData.remove({\n\"since\": oneWeekAgo,\n\"originTypes\": {\n\"protectedWeb\": true\n}\n}, {\n\"appcache\": true,\n\"cache\": true,\n\"cacheStorage\": true,\n\"cookies\": true,\n\"downloads\": true,\n\"fileSystems\": true,\n\"formData\": true,\n\"history\": true,\n\"indexedDB\": true,\n\"localStorage\": true,\n\"passwords\": true,\n\"serviceWorkers\": true,\n\"webSQL\": true\n}, callback);\nExamples\nTo try this API, install the browsingData API example from the chrome-extension-samples repository.\nTypes\nDataTypeSet\nA set of data types. Missing data types are interpreted as false\n.\nProperties\n-\nappcache\nboolean optional\nWebsites' appcaches.\n-\ncache\nboolean optional\nThe browser's cache.\n-\ncacheStorage\nboolean optional\nChrome 72+Cache storage\n-\ncookies\nboolean optional\nThe browser's cookies.\n-\ndownloads\nboolean optional\nThe browser's download list.\n-\nfileSystems\nboolean optional\nWebsites' file systems.\n-\nformData\nboolean optional\nThe browser's stored form data.\n-\nhistory\nboolean optional\nThe browser's history.\n-\nindexedDB\nboolean optional\nWebsites' IndexedDB data.\n-\nlocalStorage\nboolean optional\nWebsites' local storage data.\n-\npasswords\nboolean optional\nStored passwords.\n-\npluginData\nboolean optional\nDeprecated since Chrome 88Support for Flash has been removed. This data type will be ignored.\nPlugins' data.\n-\nserverBoundCertificates\nboolean optional\nDeprecated since Chrome 76Support for server-bound certificates has been removed. This data type will be ignored.\nServer-bound certificates.\n-\nserviceWorkers\nboolean optional\nService Workers.\n-\nwebSQL\nboolean optional\nWebsites' WebSQL data.\nRemovalOptions\nOptions that determine exactly what data will be removed.\nProperties\n-\nexcludeOrigins\nstring[] optional\nChrome 74+When present, data for origins in this list is excluded from deletion. Can't be used together with\norigins\n. Only supported for cookies, storage and cache. Cookies are excluded for the whole registrable domain. -\noriginTypes\nobject optional\nAn object whose properties specify which origin types ought to be cleared. If this object isn't specified, it defaults to clearing only \"unprotected\" origins. Please ensure that you really want to remove application data before adding 'protectedWeb' or 'extensions'.\n-\nextension\nboolean optional\nExtensions and packaged applications a user has installed (be _really_ careful!).\n-\nprotectedWeb\nboolean optional\nWebsites that have been installed as hosted applications (be careful!).\n-\nunprotectedWeb\nboolean optional\nNormal websites.\n-\n-\norigins\n[string, ...string[]] optional\nChrome 74+When present, only data for origins in this list is deleted. Only supported for cookies, storage and cache. Cookies are cleared for the whole registrable domain.\n-\nsince\nnumber optional\nRemove data accumulated on or after this date, represented in milliseconds since the epoch (accessible via the\ngetTime\nmethod of the JavaScriptDate\nobject). If absent, defaults to 0 (which would remove all browsing data).\nMethods\nremove()\nchrome.browsingData.remove(\noptions: RemovalOptions,\ndataToRemove: DataTypeSet,\ncallback?: function,\n)\nClears various types of browsing data stored in a user's profile.\nParameters\n-\noptions\n-\ndataToRemove\nThe set of data types to remove.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveAppcache()\nchrome.browsingData.removeAppcache(\noptions: RemovalOptions,\ncallback?: function,\n)\nClears websites' appcache data.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveCache()\nchrome.browsingData.removeCache(\noptions: RemovalOptions,\ncallback?: function,\n)\nClears the browser's cache.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveCacheStorage()\nchrome.browsingData.removeCacheStorage(\noptions: RemovalOptions,\ncallback?: function,\n)\nClears websites' cache storage data.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveCookies()\nchrome.browsingData.removeCookies(\noptions: RemovalOptions,\ncallback?: function,\n)\nClears the browser's cookies and server-bound certificates modified within a particular timeframe.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveDownloads()\nchrome.browsingData.removeDownloads(\noptions: RemovalOptions,\ncallback?: function,\n)\nClears the browser's list of downloaded files (not the downloaded files themselves).\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveFileSystems()\nchrome.browsingData.removeFileSystems(\noptions: RemovalOptions,\ncallback?: function,\n)\nClears websites' file system data.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveFormData()\nchrome.browsingData.removeFormData(\noptions: RemovalOptions,\ncallback?: function,\n)\nClears the browser's stored form data (autofill).\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveHistory()\nchrome.browsingData.removeHistory(\noptions: RemovalOptions,\ncallback?: function,\n)\nClears the browser's history.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveIndexedDB()\nchrome.browsingData.removeIndexedDB(\noptions: RemovalOptions,\ncallback?: function,\n)\nClears websites' IndexedDB data.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveLocalStorage()\nchrome.browsingData.removeLocalStorage(\noptions: RemovalOptions,\ncallback?: function,\n)\nClears websites' local storage data.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremovePasswords()\nchrome.browsingData.removePasswords(\noptions: RemovalOptions,\ncallback?: function,\n)\nClears the browser's stored passwords.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremovePluginData()\nchrome.browsingData.removePluginData(\noptions: RemovalOptions,\ncallback?: function,\n)\nSupport for Flash has been removed. This function has no effect.\nClears plugins' data.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveServiceWorkers()\nchrome.browsingData.removeServiceWorkers(\noptions: RemovalOptions,\ncallback?: function,\n)\nClears websites' service workers.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveWebSQL()\nchrome.browsingData.removeWebSQL(\noptions: RemovalOptions,\ncallback?: function,\n)\nClears websites' WebSQL data.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsettings()\nchrome.browsingData.settings(\ncallback?: function,\n)\nReports which types of data are currently selected in the 'Clear browsing data' settings UI. Note: some of the data types included in this API are not available in the settings UI, and some UI settings control more than one data type listed here.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: object) => void\n-\nresult\nobject\n-\ndataRemovalPermitted\nAll of the types will be present in the result, with values of\ntrue\nif they are permitted to be removed (e.g., by enterprise policy) andfalse\nif not. -\ndataToRemove\nAll of the types will be present in the result, with values of\ntrue\nif they are both selected to be removed and permitted to be removed, otherwisefalse\n. -\noptions\n-\n-\nReturns\n-\nPromise<object>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/certificateProvider", "title": "chrome.certificateProvider | API | Chrome for Developers", "text": "Description\nUse this API to expose certificates to the platform which can use these certificates for TLS authentications.\nPermissions\ncertificateProvider\nAvailability\nConcepts and usage\nTypical usage of this API to expose client certificates to ChromeOS follows these steps:\n- The Extension registers for the events\nonCertificatesUpdateRequested\nandonSignatureRequested\n. - The Extension calls\nsetCertificates()\nto provide the initial list of certificates after the initialization. - The Extension monitors the changes in the list of available certificates and calls\nsetCertificates()\nto notify the browser about every such change. - During a TLS handshake, the browser receives a client certificate request. With an\nonCertificatesUpdateRequested\nevent, the browser asks the Extension to report all certificates that it currently provides. - The Extension reports back with the currently available certificates, using the\nsetCertificates()\nmethod. - The browser matches all available certificates with the client certificate request from the remote host. The matches are presented to the user in a selection dialog.\n- The user can select a certificate and thereby approve the authentication or abort the authentication.\n- If the user aborts the authentication or no certificate matched the request, the TLS client authentication is aborted.\n- Otherwise, if the user approves the authentication with a certificate provided by this Extension, the browser requests the Extension to sign the data to continue the TLS handshake. The request is sent as a\nonSignatureRequested\nevent. - This event contains input data, declares which algorithm has to be used to generate the signature, and refers to one of the certificates that were reported by this Extension. The Extension must create a signature for the given data using the private key associated with the referenced certificate. Creating the signature might require prepending a DigestInfo and padding the result before the actual signing.\n- The Extension sends back the signature to the browser using the\nreportSignature()\nmethod. If the signature couldn't be calculated, the method has to be called without signature. - If the signature was provided, the browser completes the TLS handshake.\nThe actual sequence of steps can be different. For example, the user will not be asked to select a certificate if the enterprise policy to automatically select a certificate is used (see AutoSelectCertificateForUrls\nand Chrome policies for users).\nIn the Extension, this can look similar to the following snippet:\nfunction collectAvailableCertificates() {\n// Return all certificates that this Extension can currently provide.\n// For example:\nreturn [{\ncertificateChain: [new Uint8Array(...)],\nsupportedAlgorithms: ['RSASSA_PKCS1_v1_5_SHA256']\n}];\n}\n// The Extension calls this function every time the currently available list of\n// certificates changes, and also once after the Extension's initialization.\nfunction onAvailableCertificatesChanged() {\nchrome.certificateProvider.setCertificates({\nclientCertificates: collectAvailableCertificates()\n});\n}\nfunction handleCertificatesUpdateRequest(request) {\n// Report the currently available certificates as a response to the request\n// event. This is important for supporting the case when the Extension is\n// unable to detect the changes proactively.\nchrome.certificateProvider.setCertificates({\ncertificatesRequestId: request.certificatesRequestId,\nclientCertificates: collectAvailableCertificates()\n});\n}\n// Returns a private key handle for the given DER-encoded certificate.\n// |certificate| is an ArrayBuffer.\nfunction getPrivateKeyHandle(certificate) {...}\n// Digests and signs |input| with the given private key. |input| is an\n// ArrayBuffer. |algorithm| is an Algorithm.\n// Returns the signature as ArrayBuffer.\nfunction signUnhashedData(privateKey, input, algorithm) {...}\nfunction handleSignatureRequest(request) {\n// Look up the handle to the private key of |request.certificate|.\nconst key = getPrivateKeyHandle(request.certificate);\nif (!key) {\n// Handle if the key isn't available.\nconsole.error('Key for requested certificate no available.');\n// Abort the request by reporting the error to the API.\nchrome.certificateProvider.reportSignature({\nsignRequestId: request.signRequestId,\nerror: 'GENERAL_ERROR'\n});\nreturn;\n}\nconst signature = signUnhashedData(key, request.input, request.algorithm);\nchrome.certificateProvider.reportSignature({\nsignRequestId: request.signRequestId,\nsignature: signature\n});\n}\nchrome.certificateProvider.onCertificatesUpdateRequested.addListener(\nhandleCertificatesUpdateRequest);\nchrome.certificateProvider.onSignatureRequested.addListener(\nhandleSignatureRequest);\nTypes\nAlgorithm\nTypes of supported cryptographic signature algorithms.\nEnum\n\"RSASSA_PKCS1_v1_5_MD5_SHA1\" \"RSASSA_PKCS1_v1_5_SHA1\" \"RSASSA_PKCS1_v1_5_SHA256\" \"RSASSA_PKCS1_v1_5_SHA384\" \"RSASSA_PKCS1_v1_5_SHA512\" \"RSASSA_PSS_SHA256\" \"RSASSA_PSS_SHA384\" \"RSASSA_PSS_SHA512\"\nSpecifies the RSASSA PKCS#1 v1.5 signature algorithm with the MD5-SHA-1 hashing. The extension must not prepend a DigestInfo prefix but only add PKCS#1 padding. This algorithm is deprecated and will never be requested by Chrome as of version 109.\nSpecifies the RSASSA PKCS#1 v1.5 signature algorithm with the SHA-1 hash function.\nSpecifies the RSASSA PKCS#1 v1.5 signature algorithm with the SHA-256 hashing function.\nSpecifies the RSASSA PKCS#1 v1.5 signature algorithm with the SHA-384 hashing function.\nSpecifies the RSASSA PKCS#1 v1.5 signature algorithm with the SHA-512 hashing function.\nSpecifies the RSASSA PSS signature algorithm with the SHA-256 hashing function, MGF1 mask generation function and the salt of the same size as the hash.\nSpecifies the RSASSA PSS signature algorithm with the SHA-384 hashing function, MGF1 mask generation function and the salt of the same size as the hash.\nSpecifies the RSASSA PSS signature algorithm with the SHA-512 hashing function, MGF1 mask generation function and the salt of the same size as the hash.\nCertificateInfo\nProperties\n-\ncertificate\nArrayBuffer\nMust be the DER encoding of a X.509 certificate. Currently, only certificates of RSA keys are supported.\n-\nsupportedHashes\nHash[]\nMust be set to all hashes supported for this certificate. This extension will only be asked for signatures of digests calculated with one of these hash algorithms. This should be in order of decreasing hash preference.\nCertificatesUpdateRequest\nProperties\n-\ncertificatesRequestId\nnumber\nRequest identifier to be passed to\nsetCertificates\n.\nClientCertificateInfo\nProperties\n-\ncertificateChain\nArrayBuffer[]\nThe array must contain the DER encoding of the X.509 client certificate as its first element.\nThis must include exactly one certificate.\n-\nsupportedAlgorithms\nAll algorithms supported for this certificate. The extension will only be asked for signatures using one of these algorithms.\nError\nTypes of errors that the extension can report.\nValue\n\"GENERAL_ERROR\"\nHash\nDeprecated. Replaced by Algorithm\n.\nEnum\n\"MD5_SHA1\" \"SHA1\" \"SHA256\" \"SHA384\" \"SHA512\"\nSpecifies the MD5 and SHA1 hashing algorithms.\nSpecifies the SHA1 hashing algorithm.\nSpecifies the SHA256 hashing algorithm.\nSpecifies the SHA384 hashing algorithm.\nSpecifies the SHA512 hashing algorithm.\nPinRequestErrorType\nThe types of errors that can be presented to the user through the requestPin function.\nEnum\n\"INVALID_PIN\" \"INVALID_PUK\" \"MAX_ATTEMPTS_EXCEEDED\" \"UNKNOWN_ERROR\"\nSpecifies the PIN is invalid.\nSpecifies the PUK is invalid.\nSpecifies the maximum attempt number has been exceeded.\nSpecifies that the error cannot be represented by the above types.\nPinRequestType\nThe type of code being requested by the extension with requestPin function.\nEnum\n\"PIN\" \"PUK\"\nSpecifies the requested code is a PIN.\nSpecifies the requested code is a PUK.\nPinResponseDetails\nProperties\n-\nuserInput\nstring optional\nThe code provided by the user. Empty if user closed the dialog or some other error occurred.\nReportSignatureDetails\nProperties\n-\nerror\n\"GENERAL_ERROR\"\noptionalError that occurred while generating the signature, if any.\n-\nsignRequestId\nnumber\nRequest identifier that was received via the\nonSignatureRequested\nevent. -\nsignature\nArrayBuffer optional\nThe signature, if successfully generated.\nRequestPinDetails\nProperties\n-\nattemptsLeft\nnumber optional\nThe number of attempts left. This is provided so that any UI can present this information to the user. Chrome is not expected to enforce this, instead stopPinRequest should be called by the extension with errorType = MAX_ATTEMPTS_EXCEEDED when the number of pin requests is exceeded.\n-\nerrorType\nPinRequestErrorType optional\nThe error template displayed to the user. This should be set if the previous request failed, to notify the user of the failure reason.\n-\nrequestType\nPinRequestType optional\nThe type of code requested. Default is PIN.\n-\nsignRequestId\nnumber\nThe ID given by Chrome in SignRequest.\nSetCertificatesDetails\nProperties\n-\ncertificatesRequestId\nnumber optional\nWhen called in response to\nonCertificatesUpdateRequested\n, should contain the receivedcertificatesRequestId\nvalue. Otherwise, should be unset. -\nclientCertificates\nList of currently available client certificates.\n-\nerror\n\"GENERAL_ERROR\"\noptionalError that occurred while extracting the certificates, if any. This error will be surfaced to the user when appropriate.\nSignatureRequest\nProperties\n-\nalgorithm\nSignature algorithm to be used.\n-\ncertificate\nArrayBuffer\nThe DER encoding of a X.509 certificate. The extension must sign\ninput\nusing the associated private key. -\ninput\nArrayBuffer\nData to be signed. Note that the data is not hashed.\n-\nsignRequestId\nnumber\nRequest identifier to be passed to\nreportSignature\n.\nSignRequest\nProperties\n-\ncertificate\nArrayBuffer\nThe DER encoding of a X.509 certificate. The extension must sign\ndigest\nusing the associated private key. -\ndigest\nArrayBuffer\nThe digest that must be signed.\n-\nhash\nRefers to the hash algorithm that was used to create\ndigest\n. -\nsignRequestId\nnumber\nChrome 57+The unique ID to be used by the extension should it need to call a method that requires it, e.g. requestPin.\nStopPinRequestDetails\nProperties\n-\nerrorType\nPinRequestErrorType optional\nThe error template. If present it is displayed to user. Intended to contain the reason for stopping the flow if it was caused by an error, e.g. MAX_ATTEMPTS_EXCEEDED.\n-\nsignRequestId\nnumber\nThe ID given by Chrome in SignRequest.\nMethods\nreportSignature()\nchrome.certificateProvider.reportSignature(\ndetails: ReportSignatureDetails,\ncallback?: function,\n)\nShould be called as a response to onSignatureRequested\n.\nThe extension must eventually call this function for every onSignatureRequested\nevent; the API implementation will stop waiting for this call after some time and respond with a timeout error when this function is called.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nrequestPin()\nchrome.certificateProvider.requestPin(\ndetails: RequestPinDetails,\ncallback?: function,\n)\nRequests the PIN from the user. Only one ongoing request at a time is allowed. The requests issued while another flow is ongoing are rejected. It's the extension's responsibility to try again later if another flow is in progress.\nParameters\n-\ndetails\nContains the details about the requested dialog.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(details?: PinResponseDetails) => void\n-\ndetails\nPinResponseDetails optional\n-\nReturns\n-\nPromise<PinResponseDetails | undefined>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetCertificates()\nchrome.certificateProvider.setCertificates(\ndetails: SetCertificatesDetails,\ncallback?: function,\n)\nSets a list of certificates to use in the browser.\nThe extension should call this function after initialization and on every change in the set of currently available certificates. The extension should also call this function in response to onCertificatesUpdateRequested\nevery time this event is received.\nParameters\n-\ndetails\nThe certificates to set. Invalid certificates will be ignored.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nstopPinRequest()\nchrome.certificateProvider.stopPinRequest(\ndetails: StopPinRequestDetails,\ncallback?: function,\n)\nStops the pin request started by the requestPin\nfunction.\nParameters\n-\ndetails\nContains the details about the reason for stopping the request flow.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonCertificatesUpdateRequested\nchrome.certificateProvider.onCertificatesUpdateRequested.addListener(\ncallback: function,\n)\nThis event fires if the certificates set via setCertificates\nare insufficient or the browser requests updated information. The extension must call setCertificates\nwith the updated list of certificates and the received certificatesRequestId\n.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(request: CertificatesUpdateRequest) => void\n-\nrequest\n-\nonSignatureRequested\nchrome.certificateProvider.onSignatureRequested.addListener(\ncallback: function,\n)\nThis event fires every time the browser needs to sign a message using a certificate provided by this extension via setCertificates\n.\nThe extension must sign the input data from request\nusing the appropriate algorithm and private key and return it by calling reportSignature\nwith the received signRequestId\n.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(request: SignatureRequest) => void\n-\nrequest\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/commands", "title": "chrome.commands | API | Chrome for Developers", "text": "Description\nUse the commands API to add keyboard shortcuts that trigger actions in your extension, for example, an action to open the browser action or send a command to the extension.\nManifest\nConcepts and usage\nThe Commands API allows extension developers to define specific commands, and bind them to a default\nkey combination. Each command an extension accepts must be declared as properties of the\n\"commands\"\nobject in the extension's manifest.\nThe property key is used as the command's name. Command objects can take two properties.\nsuggested_key\nAn optional property that declares default keyboard shortcuts for the command. If omitted, the command will be unbound. This property can either take a string or an object value.\nA string value specifies the default keyboard shortcut that should be used across all platforms.\nAn object value allows the extension developer to customize the keyboard shortcut for each platform. When providing platform-specific shortcuts, valid object properties are\ndefault\n,chromeos\n,linux\n,mac\n, andwindows\n.\nSee Key combination requirements for additional details.\ndescription\nA string used to provide the user with a short description of the command's purpose. This string appears in extension keyboard shortcut management UI. Descriptions are required for standard commands, but are ignored for Action commands.\nAn extension can have many commands, but may specify at most four suggested keyboard shortcuts. The\nuser can manually add more shortcuts from the chrome://extensions/shortcuts\ndialog.\nSupported Keys\nThe following keys are usable command shortcuts. Key definitions are case sensitive. Attempting to load an extension with an incorrectly cased key will result in a manifest parse error at installation time.\n- Alpha keys\nA\n\u2026Z\n- Numeric keys\n0\n\u20269\n- Standard key strings\nGeneral\u2013\nComma\n,Period\n,Home\n,End\n,PageUp\n,PageDown\n,Space\n,Insert\n,Delete\nArrow keys\u2013\nUp\n,Down\n,Left\n,Right\nMedia Keys\u2013\nMediaNextTrack\n,MediaPlayPause\n,MediaPrevTrack\n,MediaStop\n- Modifier key strings\nCtrl\n,Alt\n,Shift\n,MacCtrl\n(macOS only),Command\n(macOS only),Search\n(ChromeOS only)\nKey combination requirements\nExtension command shortcuts must include either\nCtrl\norAlt\n.Modifiers cannot be used in combination with Media Keys.\nOn many macOS keyboards,\nAlt\nrefers to the Option key.On macOS,\nCommand\norMacCtrl\ncan also be used in place ofCtrl\norAlt\n(see next bullet point).\nOn macOS\nCtrl\nis automatically converted intoCommand\n.Command\ncan also be used in the\"mac\"\nshortcut to explicitly refer to the Command key.To use the Control key on macOS, replace\nCtrl\nwithMacCtrl\nwhen defining the\"mac\"\nshortcut.Using\nMacCtrl\nin the combination for another platform will cause a validation error and prevent the extension from being installed.\nShift\nis an optional modifier on all platforms.Search\nis an optional modifier exclusive to ChromeOS.Certain operating system and Chrome shortcuts (e.g. window management) always take priority over Extension command shortcuts and cannot be overridden.\nHandle command events\nmanifest.json:\n{\n\"name\": \"My extension\",\n...\n\"commands\": {\n\"run-foo\": {\n\"suggested_key\": {\n\"default\": \"Ctrl+Shift+Y\",\n\"mac\": \"Command+Shift+Y\"\n},\n\"description\": \"Run \\\"foo\\\" on the current page.\"\n},\n\"_execute_action\": {\n\"suggested_key\": {\n\"windows\": \"Ctrl+Shift+Y\",\n\"mac\": \"Command+Shift+Y\",\n\"chromeos\": \"Ctrl+Shift+U\",\n\"linux\": \"Ctrl+Shift+J\"\n}\n}\n},\n...\n}\nIn your service worker, you can bind a handler to each of the commands defined in the manifest\nusing onCommand.addListener\n. For example:\nservice-worker.js:\nchrome.commands.onCommand.addListener((command) => {\nconsole.log(`Command: ${command}`);\n});\nAction commands\nThe _execute_action\n(Manifest V3), _execute_browser_action\n(Manifest V2), and\n_execute_page_action\n(Manifest V2) commands are reserved for the action of trigger your action,\nbrowser action, or page action respectively. These commands don't dispatch\ncommand.onCommand events like standard commands.\nIf you need to take action based on your popup opening, consider listening for a DOMContentLoaded event inside your popup's JavaScript.\nScope\nBy default, commands are scoped to the Chrome browser. This means that when the browser does not have focus, command shortcuts are inactive. Beginning in Chrome 35, extension developers can optionally mark a command as \"global\". Global commands also work while Chrome does not have focus.\nKeyboard shortcut suggestions for global commands are limited to Ctrl+Shift+[0..9]\n. This is a\nprotective measure to minimize the risk of overriding shortcuts in other applications since if, for\nexample, Alt+P\nwere to be allowed as global, the keyboard shortcut for opening a print dialog\nmight not work in other applications.\nEnd users are free to remap global commands to their preferred key combination using the UI exposed\nat chrome://extensions/shortcuts\n.\nExample:\nmanifest.json:\n{\n\"name\": \"My extension\",\n...\n\"commands\": {\n\"toggle-feature-foo\": {\n\"suggested_key\": {\n\"default\": \"Ctrl+Shift+5\"\n},\n\"description\": \"Toggle feature foo\",\n\"global\": true\n}\n},\n...\n}\nExamples\nThe following examples flex the core functionality of the Commands API.\nBasic command\nCommands allow extensions to map logic to keyboard shortcuts that can be invoked by the user. At its most basic, a command only requires a command declaration in the extension's manifest and a listener registration as shown in the following example.\nmanifest.json:\n{\n\"name\": \"Command demo - basic\",\n\"version\": \"1.0\",\n\"manifest_version\": 3,\n\"background\": {\n\"service_worker\": \"service-worker.js\"\n},\n\"commands\": {\n\"inject-script\": {\n\"suggested_key\": \"Ctrl+Shift+Y\",\n\"description\": \"Inject a script on the page\"\n}\n}\n}\nservice-worker.js:\nchrome.commands.onCommand.addListener((command) => {\nconsole.log(`Command \"${command}\" triggered`);\n});\nAction command\nAs described in the Concepts and usage section, you can also map a command to an extension's action. The following example injects a content script that shows an alert on the current page when the user either clicks the extension's action or triggers the keyboard shortcut.\nmanifest.json:\n{\n\"name\": \"Commands demo - action invocation\",\n\"version\": \"1.0\",\n\"manifest_version\": 3,\n\"background\": {\n\"service_worker\": \"service-worker.js\"\n},\n\"permissions\": [\"activeTab\", \"scripting\"],\n\"action\": {},\n\"commands\": {\n\"_execute_action\": {\n\"suggested_key\": {\n\"default\": \"Ctrl+U\",\n\"mac\": \"Command+U\"\n}\n}\n}\n}\nservice-worker.js:\nchrome.action.onClicked.addListener((tab) => {\nchrome.scripting.executeScript({\ntarget: {tabId: tab.id},\nfunc: contentScriptFunc,\nargs: ['action'],\n});\n});\nfunction contentScriptFunc(name) {\nalert(`\"${name}\" executed`);\n}\n// This callback WILL NOT be called for \"_execute_action\"\nchrome.commands.onCommand.addListener((command) => {\nconsole.log(`Command \"${command}\" called`);\n});\nVerify commands registered\nIf an extension attempts to register a shortcut that is already used by another extension, the second extension's shortcut won't register as expected. You can provide a more robust end user experience by anticipating this possibility and checking for collisions at install time.\nservice-worker.js:\nchrome.runtime.onInstalled.addListener((details) => {\nif (details.reason === chrome.runtime.OnInstalledReason.INSTALL) {\ncheckCommandShortcuts();\n}\n});\n// Only use this function during the initial install phase. After\n// installation the user may have intentionally unassigned commands.\nfunction checkCommandShortcuts() {\nchrome.commands.getAll((commands) => {\nlet missingShortcuts = [];\nfor (let {name, shortcut} of commands) {\nif (shortcut === '') {\nmissingShortcuts.push(name);\n}\n}\nif (missingShortcuts.length > 0) {\n// Update the extension UI to inform the user that one or more\n// commands are currently unassigned.\n}\n});\n}\nTypes\nCommand\nProperties\n-\ndescription\nstring optional\nThe Extension Command description\n-\nname\nstring optional\nThe name of the Extension Command\n-\nshortcut\nstring optional\nThe shortcut active for this command, or blank if not active.\nMethods\ngetAll()\nchrome.commands.getAll(\ncallback?: function,\n)\nReturns all the registered extension commands for this extension and their shortcut (if active). Before Chrome 110, this command did not return _execute_action\n.\nParameters\nReturns\n-\nPromise<Command[]>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/contentSettings", "title": "chrome.contentSettings | API | Chrome for Developers", "text": "Description\nUse the chrome.contentSettings\nAPI to change settings that control whether websites can use features such as cookies, JavaScript, and plugins. More generally speaking, content settings allow you to customize Chrome's behavior on a per-site basis instead of globally.\nPermissions\ncontentSettings\nYou must declare the \"contentSettings\"\npermission in your extension's manifest to use the API. For\nexample:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"contentSettings\"\n],\n...\n}\nConcepts and usage\nContent setting patterns\nYou can use patterns to specify the websites that each content setting affects. For example,\nhttps://*.youtube.com/*\nspecifies youtube.com and all of its subdomains. The syntax for content\nsetting patterns is the same as for match patterns, with a few differences:\n- For\nhttp\n,https\n, andftp\nURLs, the path must be a wildcard (/*\n). Forfile\nURLs, the path must be completely specified and must not contain wildcards. - In contrast to match patterns, content setting patterns can specify a port number. If a port number is specified, the pattern only matches websites with that port. If no port number is specified, the pattern matches all ports.\nPattern precedence\nWhen more than one content setting rule applies for a given site, the rule with the more specific pattern takes precedence.\nFor example, the following patterns are ordered by precedence:\nhttps://www.example.com/*\nhttps://*.example.com/*\n(matching example.com and all subdomains)<all_urls>\n(matching every URL)\nThree kinds of wildcards affect how specific a pattern is:\n- Wildcards in the port (for example\nhttps://www.example.com:*/*\n) - Wildcards in the scheme (for example\n*://www.example.com:123/*\n) - Wildcards in the hostname (for example\nhttps://*.example.com:123/*\n)\nIf a pattern is more specific than another pattern in one part but less specific in another part, the different parts are checked in the following order: hostname, scheme, port. For example, the following patterns are ordered by precedence:\nhttps://www.example.com:*/*\nSpecifies the hostname and scheme.*:/www.example.com:123/*\nNot as high, because although it specifies the hostname, it doesn't specify the scheme.https://*.example.com:123/*\nLower because although it specifies the port and scheme, it has a wildcard in the hostname.\nPrimary and secondary patterns\nThe URL taken into account when deciding which content setting to apply depends on the content type.\nFor example, for contentSettings.notifications\nsettings are based on the URL shown in the\nomnibox. This URL is called the \"primary\" URL.\nSome content types can take additional URLs into account. For example, whether a site is allowed to\nset a contentSettings.cookies\nis decided based on the URL of the HTTP request (which is the\nprimary URL in this case) as well as the URL shown in the omnibox (which is called the \"secondary\"\nURL).\nIf multiple rules have primary and secondary patterns, the rule with the more specific primary pattern takes precedence. If there multiple rules have the same primary pattern, the rule with the more specific secondary pattern takes precedence. For example, the following list of primary/secondary pattern pairs is ordered by precedence:\n| Precedence | Primary pattern | Secondary pattern |\n|---|---|---|\n| 1 | https://www.moose.com/* , | https://www.wombat.com/* |\n| 2 | https://www.moose.com/* , | <all_urls> |\n| 3 | <all_urls> , | https://www.wombat.com/* |\n| 4 | <all_urls> , | <all_urls> |\nSecondary patterns are not supported for the images content setting.\nResource identifiers\nResource identifiers allow you to specify content settings for specific subtypes of a content type.\nCurrently, the only content type that supports resource identifiers is contentSettings.plugins\n,\nwhere a resource identifier identifies a specific plugin. When applying content settings, first the\nsettings for the specific plugin are checked. If there are no settings found for the specific\nplugin, the general content settings for plugins are checked.\nFor example, if a content setting rule has the resource identifier adobe-flash-player\nand the\npattern <all_urls>\n, it takes precedence over a rule without a resource identifier and the pattern\nhttps://www.example.com/*\n, even if that pattern is more specific.\nYou can get a list of resource identifiers for a content type by calling the\ncontentSettings.ContentSetting.getResourceIdentifiers()\nmethod. The returned list can change with\nthe set of installed plugins on the user's machine, but Chrome tries to keep the identifiers stable\nacross plugin updates.\nExamples\nTo try this API, install the contentSettings API example from the chrome-extension-samples repository.\nTypes\nAutoVerifyContentSetting\nEnum\n\"allow\" \"block\"\nCameraContentSetting\nEnum\n\"allow\" \"block\" \"ask\"\nClipboardContentSetting\nEnum\n\"allow\" \"block\" \"ask\"\nContentSetting\nProperties\n-\nclear\nvoid\nPromiseClear all content setting rules set by this extension.\nThe\nclear\nfunction looks like:(details: object, callback?: function) => {...}\n-\ndetails\nobject\n-\nscope\nScope optional\nWhere to clear the setting (default: regular).\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\n-\nreturns\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\nget\nvoid\nPromiseGets the current content setting for a given pair of URLs.\nThe\nget\nfunction looks like:(details: object, callback?: function) => {...}\n-\ndetails\nobject\n-\nincognito\nboolean optional\nWhether to check the content settings for an incognito session. (default false)\n-\nprimaryUrl\nstring\nThe primary URL for which the content setting should be retrieved. Note that the meaning of a primary URL depends on the content type.\n-\nresourceIdentifier\nResourceIdentifier optional\nA more specific identifier of the type of content for which the settings should be retrieved.\n-\nsecondaryUrl\nstring optional\nThe secondary URL for which the content setting should be retrieved. Defaults to the primary URL. Note that the meaning of a secondary URL depends on the content type, and not all content types use secondary URLs.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nsetting\nT\nThe content setting. See the description of the individual ContentSetting objects for the possible values.\n-\n-\n-\nreturns\nPromise<object>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\ngetResourceIdentifiers\nvoid\nPromiseThe\ngetResourceIdentifiers\nfunction looks like:(callback?: function) => {...}\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(resourceIdentifiers?: ResourceIdentifier[]) => void\n-\nresourceIdentifiers\nResourceIdentifier[] optional\nA list of resource identifiers for this content type, or\nundefined\nif this content type does not use resource identifiers.\n-\n-\nreturns\nPromise<ResourceIdentifier[]>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\nset\nvoid\nPromiseApplies a new content setting rule.\nThe\nset\nfunction looks like:(details: object, callback?: function) => {...}\n-\ndetails\nobject\n-\nprimaryPattern\nstring\nThe pattern for the primary URL. For details on the format of a pattern, see Content Setting Patterns.\n-\nresourceIdentifier\nResourceIdentifier optional\nThe resource identifier for the content type.\n-\nscope\nScope optional\nWhere to set the setting (default: regular).\n-\nsecondaryPattern\nstring optional\nThe pattern for the secondary URL. Defaults to matching all URLs. For details on the format of a pattern, see Content Setting Patterns.\n-\nsetting\nany\nThe setting applied by this rule. See the description of the individual ContentSetting objects for the possible values.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\n-\nreturns\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\nCookiesContentSetting\nEnum\n\"allow\" \"block\" \"session_only\"\nFullscreenContentSetting\nValue\n\"allow\"\nImagesContentSetting\nEnum\n\"allow\" \"block\"\nJavascriptContentSetting\nEnum\n\"allow\" \"block\"\nLocationContentSetting\nEnum\n\"allow\" \"block\" \"ask\"\nMicrophoneContentSetting\nEnum\n\"allow\" \"block\" \"ask\"\nMouselockContentSetting\nValue\n\"allow\"\nMultipleAutomaticDownloadsContentSetting\nEnum\n\"allow\" \"block\" \"ask\"\nNotificationsContentSetting\nEnum\n\"allow\" \"block\" \"ask\"\nPluginsContentSetting\nValue\n\"block\"\nPopupsContentSetting\nEnum\n\"allow\" \"block\"\nPpapiBrokerContentSetting\nValue\n\"block\"\nResourceIdentifier\nThe only content type using resource identifiers is contentSettings.plugins\n. For more information, see Resource Identifiers.\nProperties\n-\ndescription\nstring optional\nA human readable description of the resource.\n-\nid\nstring\nThe resource identifier for the given content type.\nScope\nThe scope of the ContentSetting. One of\nregular\n: setting for regular profile (which is inherited by the incognito profile if not overridden elsewhere),\nincognito\\_session\\_only\n: setting for incognito profile that can only be set during an incognito session and is deleted when the incognito session ends (overrides regular settings).\nEnum\n\"regular\" \"incognito_session_only\"\nProperties\nautomaticDownloads\nWhether to allow sites to download multiple files automatically. One of\nallow\n: Allow sites to download multiple files automatically,\nblock\n: Don't allow sites to download multiple files automatically,\nask\n: Ask when a site wants to download files automatically after the first file.\nDefault is ask\n.\nThe primary URL is the URL of the top-level frame. The secondary URL is not used.\nautoVerify\nWhether to allow sites to use the Private State Tokens API. One of\nallow\n: Allow sites to use the Private State Tokens API,\nblock\n: Block sites from using the Private State Tokens API.\nDefault is allow\n.\nThe primary URL is the URL of the top-level frame. The secondary URL is not used. NOTE: When calling set()\n, the primary pattern must be .\ncamera\nWhether to allow sites to access the camera. One of\nallow\n: Allow sites to access the camera,\nblock\n: Don't allow sites to access the camera,\nask\n: Ask when a site wants to access the camera.\nDefault is ask\n.\nThe primary URL is the URL of the document which requested camera access. The secondary URL is not used.\nNOTE: The 'allow' setting is not valid if both patterns are ''.\nclipboard\nWhether to allow sites to access the clipboard via advanced capabilities of the Async Clipboard API. \"Advanced\" capabilities include anything besides writing built-in formats after a user gesture, i.e. the ability to read, the ability to write custom formats, and the ability to write without a user gesture. One of\nallow\n: Allow sites to use advanced clipboard capabilities,\nblock\n: Don't allow sites to use advanced clipboard capabilties,\nask\n: Ask when a site wants to use advanced clipboard capabilities.\nDefault is ask\n.\nThe primary URL is the URL of the document which requested clipboard access. The secondary URL is not used.\ncookies\nWhether to allow cookies and other local data to be set by websites. One of\nallow\n: Accept cookies,\nblock\n: Block cookies,\nsession\\_only\n: Accept cookies only for the current session.\nDefault is allow\n.\nThe primary URL is the URL representing the cookie origin. The secondary URL is the URL of the top-level frame.\nfullscreen\nDeprecated. No longer has any effect. Fullscreen permission is now automatically granted for all sites. Value is always allow\n.\nimages\nWhether to show images. One of\nallow\n: Show images,\nblock\n: Don't show images.\nDefault is allow\n.\nThe primary URL is the URL of the top-level frame. The secondary URL is the URL of the image.\njavascript\nWhether to run JavaScript. One of\nallow\n: Run JavaScript,\nblock\n: Don't run JavaScript.\nDefault is allow\n.\nThe primary URL is the URL of the top-level frame. The secondary URL is not used.\nlocation\nWhether to allow Geolocation. One of\nallow\n: Allow sites to track your physical location,\nblock\n: Don't allow sites to track your physical location,\nask\n: Ask before allowing sites to track your physical location.\nDefault is ask\n.\nThe primary URL is the URL of the document which requested location data. The secondary URL is the URL of the top-level frame (which may or may not differ from the requesting URL).\nmicrophone\nWhether to allow sites to access the microphone. One of\nallow\n: Allow sites to access the microphone,\nblock\n: Don't allow sites to access the microphone,\nask\n: Ask when a site wants to access the microphone.\nDefault is ask\n.\nThe primary URL is the URL of the document which requested microphone access. The secondary URL is not used.\nNOTE: The 'allow' setting is not valid if both patterns are ''.\nmouselock\nDeprecated. No longer has any effect. Mouse lock permission is now automatically granted for all sites. Value is always allow\n.\nnotifications\nWhether to allow sites to show desktop notifications. One of\nallow\n: Allow sites to show desktop notifications,\nblock\n: Don't allow sites to show desktop notifications,\nask\n: Ask when a site wants to show desktop notifications.\nDefault is ask\n.\nThe primary URL is the URL of the document which wants to show the notification. The secondary URL is not used.\nplugins\nDeprecated. With Flash support removed in Chrome 88, this permission no longer has any effect. Value is always block\n. Calls to set()\nand clear()\nwill be ignored.\npopups\nWhether to allow sites to show pop-ups. One of\nallow\n: Allow sites to show pop-ups,\nblock\n: Don't allow sites to show pop-ups.\nDefault is block\n.\nThe primary URL is the URL of the top-level frame. The secondary URL is not used.\nunsandboxedPlugins\nDeprecated. Previously, controlled whether to allow sites to run plugins unsandboxed, however, with the Flash broker process removed in Chrome 88, this permission no longer has any effect. Value is always block\n. Calls to set()\nand clear()\nwill be ignored."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/contextMenus", "title": "chrome.contextMenus | API | Chrome for Developers", "text": "Description\nUse the chrome.contextMenus\nAPI to add items to Google Chrome's context menu. You can choose what types of objects your context menu additions apply to, such as images, hyperlinks, and pages.\nPermissions\ncontextMenus\nYou must declare the \"contextMenus\"\npermission in your extension's manifest to use the API. Also,\nyou should specify a 16 by 16-pixel icon for display next to your menu item. For example:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"contextMenus\"\n],\n\"icons\": {\n\"16\": \"icon-bitty.png\",\n\"48\": \"icon-small.png\",\n\"128\": \"icon-large.png\"\n},\n...\n}\nConcepts and usage\nContext menu items can appear in any document (or frame within a document), even those with file://\nor chrome:// URLs. To control which documents your items can appear in, specify the\ndocumentUrlPatterns\nfield when you call the create()\nor update()\nmethods.\nYou can create as many context menu items as you need, but if more than one from your extension is visible at once, Google Chrome automatically collapses them into a single parent menu.\nExamples\nTo try this API, install the contextMenus API example from the chrome-extension-samples repository.\nTypes\nContextType\nThe different contexts a menu can appear in. Specifying 'all' is equivalent to the combination of all other contexts except for 'launcher'. The 'launcher' context is only supported by apps and is used to add menu items to the context menu that appears when clicking the app icon in the launcher/taskbar/dock/etc. Different platforms might put limitations on what is actually supported in a launcher context menu.\nEnum\n\"all\" \"page\" \"frame\" \"selection\" \"link\" \"editable\" \"image\" \"video\" \"audio\" \"launcher\" \"browser_action\" \"page_action\" \"action\"\nCreateProperties\nProperties of the new context menu item.\nProperties\n-\nchecked\nboolean optional\nThe initial state of a checkbox or radio button:\ntrue\nfor selected,false\nfor unselected. Only one radio button can be selected at a time in a given group. -\ncontexts\n[ContextType, ...ContextType[]] optional\nList of contexts this menu item will appear in. Defaults to\n['page']\n. -\ndocumentUrlPatterns\nstring[] optional\nRestricts the item to apply only to documents or frames whose URL matches one of the given patterns. For details on pattern formats, see Match Patterns.\n-\nenabled\nboolean optional\nWhether this context menu item is enabled or disabled. Defaults to\ntrue\n. -\nid\nstring optional\nThe unique ID to assign to this item. Mandatory for event pages. Cannot be the same as another ID for this extension.\n-\nparentId\nstring | number optional\nThe ID of a parent menu item; this makes the item a child of a previously added item.\n-\ntargetUrlPatterns\nstring[] optional\nSimilar to\ndocumentUrlPatterns\n, filters based on thesrc\nattribute ofimg\n,audio\n, andvideo\ntags and thehref\nattribute ofa\ntags. -\ntitle\nstring optional\nThe text to display in the item; this is required unless\ntype\nisseparator\n. When the context isselection\n, use%s\nwithin the string to show the selected text. For example, if this parameter's value is \"Translate '%s' to Pig Latin\" and the user selects the word \"cool\", the context menu item for the selection is \"Translate 'cool' to Pig Latin\". -\ntype\nItemType optional\nThe type of menu item. Defaults to\nnormal\n. -\nvisible\nboolean optional\nWhether the item is visible in the menu.\n-\nonclick\nvoid optional\nA function that is called back when the menu item is clicked. This is not available inside of a service worker; instead, you should register a listener for\ncontextMenus.onClicked\n.The\nonclick\nfunction looks like:(info: OnClickData, tab: Tab) => {...}\n-\ninfo\nInformation about the item clicked and the context where the click happened.\n-\ntab\nThe details of the tab where the click took place. This parameter is not present for platform apps.\n-\nItemType\nThe type of menu item.\nEnum\n\"normal\" \"checkbox\" \"radio\" \"separator\"\nOnClickData\nInformation sent when a context menu item is clicked.\nProperties\n-\nchecked\nboolean optional\nA flag indicating the state of a checkbox or radio item after it is clicked.\n-\neditable\nboolean\nA flag indicating whether the element is editable (text input, textarea, etc.).\n-\nframeId\nnumber optional\nChrome 51+The ID of the frame of the element where the context menu was clicked, if it was in a frame.\n-\nframeUrl\nstring optional\nThe URL of the frame of the element where the context menu was clicked, if it was in a frame.\n-\nlinkUrl\nstring optional\nIf the element is a link, the URL it points to.\n-\nmediaType\nstring optional\nOne of 'image', 'video', or 'audio' if the context menu was activated on one of these types of elements.\n-\nstring | number\nThe ID of the menu item that was clicked.\n-\npageUrl\nstring optional\nThe URL of the page where the menu item was clicked. This property is not set if the click occured in a context where there is no current page, such as in a launcher context menu.\n-\nparentMenuItemId\nstring | number optional\nThe parent ID, if any, for the item clicked.\n-\nselectionText\nstring optional\nThe text for the context selection, if any.\n-\nsrcUrl\nstring optional\nWill be present for elements with a 'src' URL.\n-\nwasChecked\nboolean optional\nA flag indicating the state of a checkbox or radio item before it was clicked.\nProperties\nACTION_MENU_TOP_LEVEL_LIMIT\nThe maximum number of top level extension items that can be added to an extension action context menu. Any items beyond this limit will be ignored.\nValue\n6\nMethods\ncreate()\nchrome.contextMenus.create(\ncreateProperties: CreateProperties,\ncallback?: function,\n)\nCreates a new context menu item. If an error occurs during creation, it may not be detected until the creation callback fires; details will be in runtime.lastError\n.\nParameters\n-\ncreateProperties\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nnumber | string\nThe ID of the newly created item.\nremove()\nchrome.contextMenus.remove(\nmenuItemId: string | number,\ncallback?: function,\n)\nRemoves a context menu item.\nParameters\n-\nstring | number\nThe ID of the context menu item to remove.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 123+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveAll()\nchrome.contextMenus.removeAll(\ncallback?: function,\n)\nRemoves all context menu items added by this extension.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 123+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdate()\nchrome.contextMenus.update(\nid: string | number,\nupdateProperties: object,\ncallback?: function,\n)\nUpdates a previously created context menu item.\nParameters\n-\nid\nstring | number\nThe ID of the item to update.\n-\nupdateProperties\nobject\nThe properties to update. Accepts the same values as the\ncontextMenus.create\nfunction.-\nchecked\nboolean optional\n-\ncontexts\n[ContextType, ...ContextType[]] optional\n-\ndocumentUrlPatterns\nstring[] optional\n-\nenabled\nboolean optional\n-\nparentId\nstring | number optional\nThe ID of the item to be made this item's parent. Note: You cannot set an item to become a child of its own descendant.\n-\ntargetUrlPatterns\nstring[] optional\n-\ntitle\nstring optional\n-\ntype\nItemType optional\n-\nvisible\nboolean optional\nChrome 62+Whether the item is visible in the menu.\n-\nonclick\nvoid optional\nThe\nonclick\nfunction looks like:(info: OnClickData, tab: Tab) => {...}\n-\ninfoChrome 44+\n-\ntabChrome 44+\nThe details of the tab where the click took place. This parameter is not present for platform apps.\n-\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 123+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonClicked\nchrome.contextMenus.onClicked.addListener(\ncallback: function,\n)\nFired when a context menu item is clicked.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(info: OnClickData, tab?: tabs.Tab) => void\n-\ninfo\n-\ntab\ntabs.Tab optional\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/cookies", "title": "chrome.cookies | API | Chrome for Developers", "text": "Description\nUse the chrome.cookies\nAPI to query and modify cookies, and to be notified when they change.\nPermissions\ncookies\nTo use the cookies API, declare the \"cookies\"\npermission in your\nmanifest along with host permissions for any hosts whose cookies you want\nto access. For example:\n{\n\"name\": \"My extension\",\n...\n\"host_permissions\": [\n\"*://*.google.com/\"\n],\n\"permissions\": [\n\"cookies\"\n],\n...\n}\nPartitioning\nPartitioned cookies allow a site to mark that certain cookies should be keyed against the origin of the top-level frame. This means that, for example, if site A is embedded using an iframe in site B and site C, the embedded versions of a partitioned cookie from A can have different values on B and C.\nBy default, all API methods operate on unpartitioned cookies. The\npartitionKey\nproperty can be used to override this behavior.\nFor details on the general impact of partitioning for extensions, see Storage and Cookies.\nExamples\nYou can find a simple example of using the cookies API in the examples/api/cookies directory. For other examples and for help in viewing the source code, see Samples.\nTypes\nCookie\nRepresents information about an HTTP cookie.\nProperties\n-\ndomain\nstring\nThe domain of the cookie (e.g. \"www.google.com\", \"example.com\").\n-\nexpirationDate\nnumber optional\nThe expiration date of the cookie as the number of seconds since the UNIX epoch. Not provided for session cookies.\n-\nhostOnly\nboolean\nTrue if the cookie is a host-only cookie (i.e. a request's host must exactly match the domain of the cookie).\n-\nhttpOnly\nboolean\nTrue if the cookie is marked as HttpOnly (i.e. the cookie is inaccessible to client-side scripts).\n-\nname\nstring\nThe name of the cookie.\n-\npartitionKey\nCookiePartitionKey optional\nChrome 119+The partition key for reading or modifying cookies with the Partitioned attribute.\n-\npath\nstring\nThe path of the cookie.\n-\nsameSiteChrome 51+\nThe cookie's same-site status (i.e. whether the cookie is sent with cross-site requests).\n-\nsecure\nboolean\nTrue if the cookie is marked as Secure (i.e. its scope is limited to secure channels, typically HTTPS).\n-\nsession\nboolean\nTrue if the cookie is a session cookie, as opposed to a persistent cookie with an expiration date.\n-\nstoreId\nstring\nThe ID of the cookie store containing this cookie, as provided in getAllCookieStores().\n-\nvalue\nstring\nThe value of the cookie.\nCookieDetails\nDetails to identify the cookie.\nProperties\n-\nname\nstring\nThe name of the cookie to access.\n-\npartitionKey\nCookiePartitionKey optional\nChrome 119+The partition key for reading or modifying cookies with the Partitioned attribute.\n-\nstoreId\nstring optional\nThe ID of the cookie store in which to look for the cookie. By default, the current execution context's cookie store will be used.\n-\nurl\nstring\nThe URL with which the cookie to access is associated. This argument may be a full URL, in which case any data following the URL path (e.g. the query string) is simply ignored. If host permissions for this URL are not specified in the manifest file, the API call will fail.\nCookiePartitionKey\nRepresents a partitioned cookie's partition key.\nProperties\n-\nhasCrossSiteAncestor\nboolean optional\nChrome 130+Indicates if the cookie was set in a cross-cross site context. This prevents a top-level site embedded in a cross-site context from accessing cookies set by the top-level site in a same-site context.\n-\ntopLevelSite\nstring optional\nThe top-level site the partitioned cookie is available in.\nCookieStore\nRepresents a cookie store in the browser. An incognito mode window, for instance, uses a separate cookie store from a non-incognito window.\nProperties\n-\nid\nstring\nThe unique identifier for the cookie store.\n-\ntabIds\nnumber[]\nIdentifiers of all the browser tabs that share this cookie store.\nFrameDetails\nDetails to identify the frame.\nProperties\n-\ndocumentId\nstring optional\nThe unique identifier for the document. If the frameId and/or tabId are provided they will be validated to match the document found by provided document ID.\n-\nframeId\nnumber optional\nThe unique identifier for the frame within the tab.\n-\ntabId\nnumber optional\nThe unique identifier for the tab containing the frame.\nOnChangedCause\nThe underlying reason behind the cookie's change. If a cookie was inserted, or removed via an explicit call to \"chrome.cookies.remove\", \"cause\" will be \"explicit\". If a cookie was automatically removed due to expiry, \"cause\" will be \"expired\". If a cookie was removed due to being overwritten with an already-expired expiration date, \"cause\" will be set to \"expired_overwrite\". If a cookie was automatically removed due to garbage collection, \"cause\" will be \"evicted\". If a cookie was automatically removed due to a \"set\" call that overwrote it, \"cause\" will be \"overwrite\". Plan your response accordingly.\nEnum\n\"evicted\" \"expired\" \"explicit\" \"expired_overwrite\" \"overwrite\"\nSameSiteStatus\nA cookie's 'SameSite' state (https://tools.ietf.org/html/draft-west-first-party-cookies). 'no_restriction' corresponds to a cookie set with 'SameSite=None', 'lax' to 'SameSite=Lax', and 'strict' to 'SameSite=Strict'. 'unspecified' corresponds to a cookie set without the SameSite attribute.\nEnum\n\"no_restriction\" \"lax\" \"strict\" \"unspecified\"\nMethods\nget()\nchrome.cookies.get(\ndetails: CookieDetails,\ncallback?: function,\n)\nRetrieves information about a single cookie. If more than one cookie of the same name exists for the given URL, the one with the longest path will be returned. For cookies with the same path length, the cookie with the earliest creation time will be returned.\nParameters\nReturns\n-\nPromise<Cookie | undefined>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetAll()\nchrome.cookies.getAll(\ndetails: object,\ncallback?: function,\n)\nRetrieves all cookies from a single cookie store that match the given information. The cookies returned will be sorted, with those with the longest path first. If multiple cookies have the same path length, those with the earliest creation time will be first. This method only retrieves cookies for domains that the extension has host permissions to.\nParameters\n-\ndetails\nobject\nInformation to filter the cookies being retrieved.\n-\ndomain\nstring optional\nRestricts the retrieved cookies to those whose domains match or are subdomains of this one.\n-\nname\nstring optional\nFilters the cookies by name.\n-\npartitionKey\nCookiePartitionKey optional\nChrome 119+The partition key for reading or modifying cookies with the Partitioned attribute.\n-\npath\nstring optional\nRestricts the retrieved cookies to those whose path exactly matches this string.\n-\nsecure\nboolean optional\nFilters the cookies by their Secure property.\n-\nsession\nboolean optional\nFilters out session vs. persistent cookies.\n-\nstoreId\nstring optional\nThe cookie store to retrieve cookies from. If omitted, the current execution context's cookie store will be used.\n-\nurl\nstring optional\nRestricts the retrieved cookies to those that would match the given URL.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(cookies: Cookie[]) => void\n-\ncookies\nCookie[]\nAll the existing, unexpired cookies that match the given cookie info.\n-\nReturns\n-\nPromise<Cookie[]>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetAllCookieStores()\nchrome.cookies.getAllCookieStores(\ncallback?: function,\n)\nLists all existing cookie stores.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(cookieStores: CookieStore[]) => void\n-\ncookieStores\nAll the existing cookie stores.\n-\nReturns\n-\nPromise<CookieStore[]>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetPartitionKey()\nchrome.cookies.getPartitionKey(\ndetails: FrameDetails,\ncallback?: function,\n)\nThe partition key for the frame indicated.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\nContains details about the partition key that's been retrieved.\n-\npartitionKey\nThe partition key for reading or modifying cookies with the Partitioned attribute.\n-\n-\nReturns\n-\nPromise<object>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremove()\nchrome.cookies.remove(\ndetails: CookieDetails,\ncallback?: function,\n)\nDeletes a cookie by name.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(details?: object) => void\n-\ndetails\nobject optional\nContains details about the cookie that's been removed. If removal failed for any reason, this will be \"null\", and\nruntime.lastError\nwill be set.-\nname\nstring\nThe name of the cookie that's been removed.\n-\npartitionKey\nCookiePartitionKey optional\nChrome 119+The partition key for reading or modifying cookies with the Partitioned attribute.\n-\nstoreId\nstring\nThe ID of the cookie store from which the cookie was removed.\n-\nurl\nstring\nThe URL associated with the cookie that's been removed.\n-\n-\nReturns\n-\nPromise<object | undefined>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nset()\nchrome.cookies.set(\ndetails: object,\ncallback?: function,\n)\nSets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.\nParameters\n-\ndetails\nobject\nDetails about the cookie being set.\n-\ndomain\nstring optional\nThe domain of the cookie. If omitted, the cookie becomes a host-only cookie.\n-\nexpirationDate\nnumber optional\nThe expiration date of the cookie as the number of seconds since the UNIX epoch. If omitted, the cookie becomes a session cookie.\n-\nhttpOnly\nboolean optional\nWhether the cookie should be marked as HttpOnly. Defaults to false.\n-\nname\nstring optional\nThe name of the cookie. Empty by default if omitted.\n-\npartitionKey\nCookiePartitionKey optional\nChrome 119+The partition key for reading or modifying cookies with the Partitioned attribute.\n-\npath\nstring optional\nThe path of the cookie. Defaults to the path portion of the url parameter.\n-\nsameSite\nSameSiteStatus optional\nChrome 51+The cookie's same-site status. Defaults to \"unspecified\", i.e., if omitted, the cookie is set without specifying a SameSite attribute.\n-\nsecure\nboolean optional\nWhether the cookie should be marked as Secure. Defaults to false.\n-\nstoreId\nstring optional\nThe ID of the cookie store in which to set the cookie. By default, the cookie is set in the current execution context's cookie store.\n-\nurl\nstring\nThe request-URI to associate with the setting of the cookie. This value can affect the default domain and path values of the created cookie. If host permissions for this URL are not specified in the manifest file, the API call will fail.\n-\nvalue\nstring optional\nThe value of the cookie. Empty by default if omitted.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(cookie?: Cookie) => void\n-\ncookie\nCookie optional\nContains details about the cookie that's been set. If setting failed for any reason, this will be \"null\", and\nruntime.lastError\nwill be set.\n-\nReturns\n-\nPromise<Cookie | undefined>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonChanged\nchrome.cookies.onChanged.addListener(\ncallback: function,\n)\nFired when a cookie is set or removed. As a special case, note that updating a cookie's properties is implemented as a two step process: the cookie to be updated is first removed entirely, generating a notification with \"cause\" of \"overwrite\" . Afterwards, a new cookie is written with the updated values, generating a second notification with \"cause\" \"explicit\".\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(changeInfo: object) => void\n-\nchangeInfo\nobject\n-\ncause\nThe underlying reason behind the cookie's change.\n-\ncookie\nInformation about the cookie that was set or removed.\n-\nremoved\nboolean\nTrue if a cookie was removed.\n-\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/debugger", "title": "chrome.debugger | API | Chrome for Developers", "text": "Description\nThe chrome.debugger\nAPI serves as an alternate transport for Chrome's remote debugging protocol. Use chrome.debugger\nto attach to one or more tabs to instrument network interaction, debug JavaScript, mutate the DOM and CSS, and more. Use the Debuggee\nproperty tabId\nto target tabs with sendCommand\nand route events by tabId\nfrom onEvent\ncallbacks.\nPermissions\ndebugger\nYou must declare the \"debugger\"\npermission in your extension's manifest to use this API.\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"debugger\",\n],\n...\n}\nConcepts and usage\nOnce attached, the chrome.debugger\nAPI lets you send Chrome DevTools Protocol\n(CDP) commands to a given target. Explaining the CDP in depth is out of scope\nfor this documentation\u2014to learn more about CDP check out the\nofficial CDP documentation.\nTargets\nTargets represent something which is being debugged\u2014this could include a tab,\nan iframe or a worker. Each target is identified by a UUID and has an associated\ntype (such as iframe\n, shared_worker\n, and more).\nWithin a target, there may be multiple execution contexts\u2014for example same process iframes don't get a unique target but are instead represented as different contexts that can be accessed from a single target.\nRestricted domains\nFor security reasons, the chrome.debugger\nAPI does not provide access to all Chrome DevTools\nProtocol Domains. The available domains are: Accessibility,\nAudits, CacheStorage, Console,\nCSS, Database, Debugger, DOM,\nDOMDebugger, DOMSnapshot,\nEmulation, Fetch, IO, Input,\nInspector, Log, Network, Overlay,\nPage, Performance, Profiler,\nRuntime, Storage, Target, Tracing,\nWebAudio, and WebAuthn.\nWork with frames\nThere is not a one to one mapping of frames to targets. Within a single tab, multiple same process frames may share the same target but use a different execution context. On the other hand, a new target may be created for an out-of-process iframe.\nTo attach to all frames, you need to handle each type of frame separately:\nListen for the\nRuntime.executionContextCreated\nevent to identify new execution contexts associated with same process frames.Follow the steps to attach to related targets to identify out-of-process frames.\nAttach to related targets\nAfter connecting to a target, you may want to connect to further related targets including out-of-process child frames or associated workers.\nStarting in Chrome 125, the chrome.debugger\nAPI supports flat sessions. This\nlets you add additional targets as children to your main debugger session and\nmessage them without needing another call to chrome.debugger.attach\n. Instead,\nyou can add a sessionId\nproperty when calling chrome.debugger.sendCommand\nto\nidentify the child target you would like to send a command to.\nTo automatically attach to out of process child frames, first add a listener for\nthe Target.attachedToTarget\nevent:\nchrome.debugger.onEvent.addListener((source, method, params) => {\nif (method === \"Target.attachedToTarget\") {\n// `source` identifies the parent session, but we need to construct a new\n// identifier for the child session\nconst session = { ...source, sessionId: params.sessionId };\n// Call any needed CDP commands for the child session\nawait chrome.debugger.sendCommand(session, \"Runtime.enable\");\n}\n});\nThen, enable auto attach by sending the Target.setAutoAttach\ncommand with\nthe flatten\noption set to true\n:\nawait chrome.debugger.sendCommand({ tabId }, \"Target.setAutoAttach\", {\nautoAttach: true,\nwaitForDebuggerOnStart: false,\nflatten: true,\nfilter: [{ type: \"iframe\", exclude: false }]\n});\nExamples\nTo try this API, install the debugger API example from the chrome-extension-samples repository.\nTypes\nDebuggee\nDebuggee identifier. Either tabId, extensionId or targetId must be specified\nProperties\n-\nextensionId\nstring optional\nThe id of the extension which you intend to debug. Attaching to an extension background page is only possible when the\n--silent-debugger-extension-api\ncommand-line switch is used. -\ntabId\nnumber optional\nThe id of the tab which you intend to debug.\n-\ntargetId\nstring optional\nThe opaque id of the debug target.\nDebuggerSession\nDebugger session identifier. One of tabId, extensionId or targetId must be specified. Additionally, an optional sessionId can be provided. If sessionId is specified for arguments sent from onEvent\n, it means the event is coming from a child protocol session within the root debuggee session. If sessionId is specified when passed to sendCommand\n, it targets a child protocol session within the root debuggee session.\nProperties\n-\nextensionId\nstring optional\nThe id of the extension which you intend to debug. Attaching to an extension background page is only possible when the\n--silent-debugger-extension-api\ncommand-line switch is used. -\nsessionId\nstring optional\nThe opaque id of the Chrome DevTools Protocol session. Identifies a child session within the root session identified by tabId, extensionId or targetId.\n-\ntabId\nnumber optional\nThe id of the tab which you intend to debug.\n-\ntargetId\nstring optional\nThe opaque id of the debug target.\nDetachReason\nConnection termination reason.\nEnum\n\"target_closed\" \"canceled_by_user\"\nTargetInfo\nDebug target information\nProperties\n-\nattached\nboolean\nTrue if debugger is already attached.\n-\nextensionId\nstring optional\nThe extension id, defined if type = 'background_page'.\n-\nfaviconUrl\nstring optional\nTarget favicon URL.\n-\nid\nstring\nTarget id.\n-\ntabId\nnumber optional\nThe tab id, defined if type == 'page'.\n-\ntitle\nstring\nTarget page title.\n-\ntype\nTarget type.\n-\nurl\nstring\nTarget URL.\nTargetInfoType\nTarget type.\nEnum\n\"page\" \"background_page\" \"worker\" \"other\"\nMethods\nattach()\nchrome.debugger.attach(\ntarget: Debuggee,\nrequiredVersion: string,\ncallback?: function,\n)\nAttaches debugger to the given target.\nParameters\n-\ntarget\nDebugging target to which you want to attach.\n-\nrequiredVersion\nstring\nRequired debugging protocol version (\"0.1\"). One can only attach to the debuggee with matching major version and greater or equal minor version. List of the protocol versions can be obtained here.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ndetach()\nchrome.debugger.detach(\ntarget: Debuggee,\ncallback?: function,\n)\nDetaches debugger from the given target.\nParameters\n-\ntarget\nDebugging target from which you want to detach.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetTargets()\nchrome.debugger.getTargets(\ncallback?: function,\n)\nReturns the list of available debug targets.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: TargetInfo[]) => void\n-\nresult\nArray of TargetInfo objects corresponding to the available debug targets.\n-\nReturns\n-\nPromise<TargetInfo[]>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsendCommand()\nchrome.debugger.sendCommand(\ntarget: DebuggerSession,\nmethod: string,\ncommandParams?: object,\ncallback?: function,\n)\nSends given command to the debugging target.\nParameters\n-\ntarget\nDebugging target to which you want to send the command.\n-\nmethod\nstring\nMethod name. Should be one of the methods defined by the remote debugging protocol.\n-\ncommandParams\nobject optional\nJSON object with request parameters. This object must conform to the remote debugging params scheme for given method.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result?: object) => void\n-\nresult\nobject optional\nJSON object with the response. Structure of the response varies depending on the method name and is defined by the 'returns' attribute of the command description in the remote debugging protocol.\n-\nReturns\n-\nPromise<object | undefined>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonDetach\nchrome.debugger.onDetach.addListener(\ncallback: function,\n)\nFired when browser terminates debugging session for the tab. This happens when either the tab is being closed or Chrome DevTools is being invoked for the attached tab.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(source: Debuggee, reason: DetachReason) => void\n-\nsource\n-\nreason\n-\nonEvent\nchrome.debugger.onEvent.addListener(\ncallback: function,\n)\nFired whenever debugging target issues instrumentation event.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(source: DebuggerSession, method: string, params?: object) => void\n-\nsource\n-\nmethod\nstring\n-\nparams\nobject optional\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/declarativeContent", "title": "chrome.declarativeContent | API | Chrome for Developers", "text": "Description\nUse the chrome.declarativeContent\nAPI to take actions depending on the content of a page, without requiring permission to read the page's content.\nPermissions\ndeclarativeContent\nConcepts and usage\nThe Declarative Content API lets you enable your extension's action depending on the URL of a web page, or if a CSS selector matches an element on the page, without needing to add host permissions or inject a content script.\nUse the activeTab permission to interact with a page after the user clicks on the extension's action.\nRules\nRules consists of conditions and actions. If any of the conditions is fulfilled, all actions are\nexecuted. The actions are setIcon()\nand showAction()\n.\nThe PageStateMatcher\nmatches web pages if and only if all listed\ncriteria are met. It can match a page url, a css compound selector\nor the bookmarked state of a page. The following rule enables\nthe extension's action on Google pages when a password field is present:\nlet rule1 = {\nconditions: [\nnew chrome.declarativeContent.PageStateMatcher({\npageUrl: { hostSuffix: '.google.com', schemes: ['https'] },\ncss: [\"input[type='password']\"]\n})\n],\nactions: [ new chrome.declarativeContent.ShowAction() ]\n};\nTo also enable the extension's action for Google sites with a video, you can add a second condition, as each condition is sufficient to trigger all specified actions:\nlet rule2 = {\nconditions: [\nnew chrome.declarativeContent.PageStateMatcher({\npageUrl: { hostSuffix: '.google.com', schemes: ['https'] },\ncss: [\"input[type='password']\"]\n}),\nnew chrome.declarativeContent.PageStateMatcher({\ncss: [\"video\"]\n})\n],\nactions: [ new chrome.declarativeContent.ShowAction() ]\n};\nThe onPageChanged\nevent tests whether any rule has at least one fulfilled\ncondition and executes the actions. Rules persist across browsing sessions; therefore, during\nextension installation time you should first use removeRules\nto clear\npreviously installed rules and then use addRules\nto register new ones.\nchrome.runtime.onInstalled.addListener(function(details) {\nchrome.declarativeContent.onPageChanged.removeRules(undefined, function() {\nchrome.declarativeContent.onPageChanged.addRules([rule2]);\n});\n});\nWith the activeTab permission, your extension won't display any permission warnings and when the user clicks the extension action, it will only run on relevant pages.\nPage URL matching\nThe PageStateMatcher.pageurl\nmatches when the URL criteria are fulfilled. The\nmost common criteria are a concatenation of either host, path, or URL, followed by Contains, Equals, Prefix, or\nSuffix. The following table contains a few examples:\n| Criteria | Matches |\n|---|---|\n{ hostSuffix: 'google.com' } |\nAll Google URLs |\n{ pathPrefix: '/docs/extensions' } |\nExtension docs URLs |\n{ urlContains: 'developer.chrome.com' } |\nAll chrome developers docs URLs |\nAll criteria are case sensitive. For a complete list of criteria, see UrlFilter.\nCSS Matching\nPageStateMatcher.css\nconditions must be compound selectors,\nmeaning that you can't include combinators like whitespace or \">\n\" in your\nselectors. This helps Chrome match the selectors more efficiently.\n| Compound Selectors (OK) | Complex Selectors (Not OK) |\n|---|---|\na |\ndiv p |\niframe.special[src^='http'] |\np>span.highlight |\nns|* |\np + ol |\n#abcd:checked |\np::first-line |\nCSS conditions only match displayed elements: if an element that matches your selector is\ndisplay:none\nor one of its parent elements is display:none\n, it doesn't cause the condition to\nmatch. Elements styled with visibility:hidden\n, positioned off-screen, or hidden by other elements\ncan still make your condition match.\nBookmarked state matching\nThe PageStateMatcher.isBookmarked\ncondition allows matching of the\nbookmarked state of the current URL in the user's profile. To make use of this condition the\n\"bookmarks\" permission must be declared in the extension manifest.\nTypes\nImageDataType\nSee https://developer.mozilla.org/en-US/docs/Web/API/ImageData.\nType\nImageData\nPageStateMatcher\nMatches the state of a web page based on various criteria.\nProperties\n-\nconstructor\nvoid\nThe\nconstructor\nfunction looks like:(arg: PageStateMatcher) => {...}\n-\narg\n-\nreturns\n-\n-\ncss\nstring[] optional\nMatches if all of the CSS selectors in the array match displayed elements in a frame with the same origin as the page's main frame. All selectors in this array must be compound selectors to speed up matching. Note: Listing hundreds of CSS selectors or listing CSS selectors that match hundreds of times per page can slow down web sites.\n-\nisBookmarked\nboolean optional\nChrome 45+Matches if the bookmarked state of the page is equal to the specified value. Requres the bookmarks permission.\n-\npageUrl\nUrlFilter optional\nMatches if the conditions of the\nUrlFilter\nare fulfilled for the top-level URL of the page.\nRequestContentScript\nDeclarative event action that injects a content script.\nWARNING: This action is still experimental and is not supported on stable builds of Chrome.\nProperties\n-\nconstructor\nvoid\nThe\nconstructor\nfunction looks like:(arg: RequestContentScript) => {...}\n-\nreturns\n-\n-\nallFrames\nboolean optional\nWhether the content script runs in all frames of the matching page, or in only the top frame. Default is\nfalse\n. -\ncss\nstring[] optional\nNames of CSS files to be injected as a part of the content script.\n-\njs\nstring[] optional\nNames of JavaScript files to be injected as a part of the content script.\n-\nmatchAboutBlank\nboolean optional\nWhether to insert the content script on\nabout:blank\nandabout:srcdoc\n. Default isfalse\n.\nSetIcon\nDeclarative event action that sets the n-dip square icon for the extension's page action or browser action while the corresponding conditions are met. This action can be used without host permissions, but the extension must have a page or browser action.\nExactly one of imageData\nor path\nmust be specified. Both are dictionaries mapping a number of pixels to an image representation. The image representation in imageData\nis an ImageData object; for example, from a canvas\nelement, while the image representation in path\nis the path to an image file relative to the extension's manifest. If scale\nscreen pixels fit into a device-independent pixel, the scale * n\nicon is used. If that scale is missing, another image is resized to the required size.\nProperties\n-\nconstructor\nvoid\nThe\nconstructor\nfunction looks like:(arg: SetIcon) => {...}\n-\narg\n-\nreturns\n-\n-\nimageData\nImageData | object optional\nEither an\nImageData\nobject or a dictionary {size -> ImageData} representing an icon to be set. If the icon is specified as a dictionary, the image used is chosen depending on the screen's pixel density. If the number of image pixels that fit into one screen space unit equalsscale\n, then an image with sizescale * n\nis selected, where n is the size of the icon in the UI. At least one image must be specified. Note thatdetails.imageData = foo\nis equivalent todetails.imageData = {'16': foo}\n.\nShowAction\nA declarative event action that sets the extension's toolbar action to an enabled state while the corresponding conditions are met. This action can be used without host permissions. If the extension has the activeTab permission, clicking the page action grants access to the active tab.\nOn pages where the conditions are not met the extension's toolbar action will be grey-scale, and clicking it will open the context menu, instead of triggering the action.\nProperties\n-\nconstructor\nvoid\nThe\nconstructor\nfunction looks like:(arg: ShowAction) => {...}\n-\narg\n-\nreturns\n-\nShowPageAction\nPlease use declarativeContent.ShowAction\n.\nA declarative event action that sets the extension's page action to an enabled state while the corresponding conditions are met. This action can be used without host permissions, but the extension must have a page action. If the extension has the activeTab permission, clicking the page action grants access to the active tab.\nOn pages where the conditions are not met the extension's toolbar action will be grey-scale, and clicking it will open the context menu, instead of triggering the action.\nProperties\n-\nconstructor\nvoid\nThe\nconstructor\nfunction looks like:(arg: ShowPageAction) => {...}\n-\narg\n-\nreturns\n-\nEvents\nonPageChanged\nProvides the Declarative Event API consisting of addRules\n, removeRules\n, and getRules\n."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/declarativeNetRequest", "title": "chrome.declarativeNetRequest | API | Chrome for Developers", "text": "Description\nThe chrome.declarativeNetRequest\nAPI is used to block or modify network requests by specifying declarative rules. This lets extensions modify network requests without intercepting them and viewing their content, thus providing more privacy.\nPermissions\ndeclarativeNetRequest\ndeclarativeNetRequestWithHostAccess\nThe \"declarativeNetRequest\n\" and \"declarativeNetRequestWithHostAccess\n\" permissions\nprovide the same capabilities. The differences between them is when permissions are\nrequested or granted.\n\"declarativeNetRequest\"\n- Triggers a permission warning at install time but provides implicit access to\nallow\n,allowAllRequests\nandblock\nrules. Use this when possible to avoid needing to request full access to hosts. \"declarativeNetRequestFeedback\"\n- Enables debugging features for unpacked extensions, specifically\ngetMatchedRules()\nandonRuleMatchedDebug\n. \"declarativeNetRequestWithHostAccess\"\n- A permission warning is not shown at install time, but you must request host permissions before you can perform any action on a host. This is appropriate when you want to use declarative net request rules in an extension which already has host permissions without generating additional warnings.\nAvailability\nManifest\nIn addition to the permissions described previously, certain types of rulesets, static rulesets specifically, require declaring the \"declarative_net_request\"\nmanifest key, which should be a dictionary with a single key called \"rule_resources\"\n. This key is an array containing dictionaries of type Ruleset\n, as shown in the following. (Note that the name 'Ruleset' does not appear in the manifest's JSON since it is merely an array.) Static rulesets are explained later in this document.\n{\n\"name\": \"My extension\",\n...\n\"declarative_net_request\" : {\n\"rule_resources\" : [{\n\"id\": \"ruleset_1\",\n\"enabled\": true,\n\"path\": \"rules_1.json\"\n}, {\n\"id\": \"ruleset_2\",\n\"enabled\": false,\n\"path\": \"rules_2.json\"\n}]\n},\n\"permissions\": [\n\"declarativeNetRequest\",\n\"declarativeNetRequestFeedback\",\n],\n\"host_permissions\": [\n\"http://www.blogger.com/*\",\n\"http://*.google.com/*\"\n],\n...\n}\nRules and rulesets\nTo use this API, specify one or more rulesets. A ruleset contains an array of rules. A single rule does one of the following:\n- Block a network request.\n- Upgrade the schema (http to https).\n- Prevent a request from getting blocked by negating any matching blocked rules.\n- Redirect a network request.\n- Modify request or response headers.\nThere are three types of rulesets, managed in slightly different ways.\n- Dynamic\n- Persist across browser sessions and extension upgrades and are managed using JavaScript while an extension is in use.\n- Session\n- Cleared when the browser shuts down and when a new version of the extension is installed. Session rules are managed using JavaScript while an extension is in use.\n- Static\n- Packaged, installed, and updated when an extension is installed or upgraded. Static rules are stored in JSON-formatted rule files and listed in the manifest file.\nDynamic and session-scoped rulesets\nDynamic and session rulesets are managed using JavaScript while an extension is in use.\n- Dynamic rules persist across browser sessions and extension upgrades.\n- Session rules are cleared when the browser shuts down and when a new version of the extension is installed.\nThere is only one each of these ruleset types. An extension can add or remove rules to them dynamically by calling updateDynamicRules()\nand updateSessionRules()\n, provided the rule limits aren't exceeded. For information on rule limits, see Rule limits. You can see an example of this under code examples.\nStatic rulesets\nUnlike dynamic and session rules, static rules are packaged, installed, and updated when an extension is installed or upgraded. They're stored in rule files in JSON format, which are indicated to the extension using the \"declarative_net_request\"\nand \"rule_resources\"\nkeys as described above, as well as one or more Ruleset\ndictionaries. A Ruleset\ndictionary contains a path to the rule file, an ID for the ruleset contained in the file, and whether the ruleset is enabled or disabled. The last two are important when you enable or disable a ruleset programmatically.\n{\n...\n\"declarative_net_request\" : {\n\"rule_resources\" : [{\n\"id\": \"ruleset_1\",\n\"enabled\": true,\n\"path\": \"rules_1.json\"\n},\n...\n]\n}\n...\n}\nTo test rule files, load your extension unpacked. Errors and warnings about invalid static rules are only displayed for unpacked extensions. Invalid static rules in packed extensions are ignored.\nExpedited review\nChanges to static rulesets may be eligible for expedited review. See expedited review for eligible changes.\nEnable and disable static rules and rulesets\nBoth individual static rules and complete static rulesets may be enabled or disabled at runtime.\nThe set of enabled static rules and rulesets is persisted across browser sessions. Neither are persisted across extension updates, meaning that only rules you chose to leave in your rule files are available after an update.\nFor performance reasons there are also limits to the number of rules and rulesets that may be enabled at one time. Call getAvailableStaticRuleCount()\nto check the number of additional rules that may be enabled. For information on rule limits, see Rule limits.\nTo enable or disable static rules, call updateStaticRules()\n. This method takes an UpdateStaticRulesOptions\nobject, which contains arrays of IDs of rules to enable or disable. The IDs are defined using the \"id\"\nkey of the Ruleset\ndictionary. There is a maximum limit of 5000 disabled static rules.\nTo enable or disable static rulesets, call updateEnabledRulesets()\n. This method takes an UpdateRulesetOptions\nobject, which contains arrays of IDs of rulesets to enable or disable. The IDs are defined using the \"id\"\nkey of the Ruleset\ndictionary.\nBuild rules\nRegardless of type, a rule starts with four fields as shown in the following. While the \"id\"\nand \"priority\"\nkeys take a number, the \"action\"\nand \"condition\"\nkeys may provide several blocking and redirecting conditions. The following rule blocks all script requests originating from \"foo.com\"\nto any URL with \"abc\"\nas a substring.\n{\n\"id\" : 1,\n\"priority\": 1,\n\"action\" : { \"type\" : \"block\" },\n\"condition\" : {\n\"urlFilter\" : \"abc\",\n\"initiatorDomains\" : [\"foo.com\"],\n\"resourceTypes\" : [\"script\"]\n}\n}\nURL matching\nDeclarative Net Request provides the ability to match URLs with either a pattern matching syntax or regular expressions.\nURL filter syntax\nA rule's \"condition\"\nkey allows a \"urlFilter\"\nkey for acting on URLs under a specified domain. You create patterns using pattern matching tokens. Here are a few examples.\nurlFilter |\nMatches | Does not match |\n|---|---|---|\n\"abc\" |\nhttps://abcd.com https://example.com/abcd |\nhttps://ab.com |\n\"abc*d\" |\nhttps://abcd.com https://example.com/abcxyzd |\nhttps://abc.com |\n\"||a.example.com\" |\nhttps://a.example.com/ https://b.a.example.com/xyz https://a.example.company |\nhttps://example.com/ |\n\"|https*\" |\nhttps://example.com | http://example.com/ http://https.com |\n\"example*^123|\" |\nhttps://example.com/123 http://abc.com/example?123 |\nhttps://example.com/1234 https://abc.com/example0123 |\nRegular expressions\nConditions can also use regular expressions. See the\n\"regexFilter\"\nkey. To learn about the\nlimits that apply to these conditions, see\nRules that use regular expressions.\nWrite good URL conditions\nTake care when writing rules to always match an entire domain. Otherwise, your rule may match in situations that are unexpected. For example, when using the pattern matching syntax:\ngoogle.com\nincorrectly matcheshttps://example.com/?param=google.com\n||google.com\nincorrectly matcheshttps://google.company\nhttps://www.google.com\nincorrectly matcheshttps://example.com/?param=https://www.google.com\nConsider using:\n||google.com/\n, which matches all paths and all subdomains.|https://www.google.com/\nwhich matches all paths and no subdomains.\nSimilarly, use the ^\nand /\ncharacters to anchor a regular expression. For\nexample, ^https:\\/\\/www\\.google\\.com\\/\nmatches any path on\nhttps://www.google.com.\nRule evaluation\nDNR rules are applied by the browser across various stages of the network request lifecycle.\nBefore the request\nBefore a request is made, an extension can block or redirect (including upgrading the scheme from HTTP to HTTPS) it with a matching rule.\nFor each extension, the browser determines a list of matching rules. Rules with a modifyHeaders\naction are not included here as they will be handled later. Additionally, rules with a responseHeaders\ncondition will be considered later (when response headers are available) and are not included.\nThen, for each extension, Chrome picks at most one candidate per request. Chrome finds a matching rule, by ordering all matching rules by priority. Rules with the same priority are ordered by action (allow\nor allowAllRequests\n> block\n> upgradeScheme\n> redirect\n).\nIf the candidate is an allow\nor allowAllRequests\nrule, or the frame the request is being made in previously matched an allowAllRequests\nrule of higher or equal priority from this extension, the request is \"allowed\" and the extension won't have any effect on the request.\nIf more than one extension wants to block or redirect this request, a single action to take is chosen. Chrome does this by sorting the rules in the order block\n> redirect\nor upgradeScheme\n> allow\nor allowAllRequests\n. If two rules are of the same type, Chrome chooses the rule from the most recently installed extension.\nBefore request headers are sent\nBefore Chrome sends request headers to the server, the headers are updated based on matching modifyHeaders\nrules.\nWithin a single extension, Chrome builds the list of modifications to perform by finding all matching modifyHeaders\nrules. Similar to before, only rules which have a higher priority than any matching allow\nor allowAllRequests\nrules are included.\nThese rules are applied by Chrome in an order such that rules from a more recently installed extension are always evaluated before rules from an older extension. Additionally, rules of a higher priority from one extension are always applied before rules of a lower priority from the same extension. Notably, even across extensions:\n- If a rule appends to a header, then lower priority rules can only append to that header. Set and remove operations are not allowed.\n- If a rule sets a header, then only lower priority rules from the same extension can append to that header. No other modifications are allowed.\n- If a rule removes a header, then lower priority rules cannot further modify the header.\nOnce a response is received\nOnce the response headers have been received, Chrome evaluates rules with a responseHeaders\ncondition.\nAfter sorting these rules by action\nand priority\nand excluding any rules made redundant by a matching allow\nor allowAllRequests\nrule (this happens identically to the steps in \"Before the request\"), Chrome may block or redirect the request on behalf of an extension.\nNote that if a request made it to this stage, the request has already been sent to the server and the server has received data like the request body. A block or redirect rule with a response headers condition will still run\u2013but cannot actually block or redirect the request.\nIn the case of a block rule, this is handled by the page which made the request receiving a blocked response and Chrome terminating the request early. In the case of a redirect rule, Chrome makes a new request to the redirected URL. Make sure to consider if these behaviors meet the privacy expectations for your extension.\nIf the request is not blocked or redirected, Chrome applies any modifyHeaders\nrules. Applying modifications to response headers works in the same way as described in \"Before request headers are sent\". Applying modifications to request headers does nothing, since the request has already been made.\nSafe rules\nSafe rules are defined as rules with an action of block\n, allow\n,\nallowAllRequests\nor upgradeScheme\n. These rules are subject to an increased\ndynamic rules quota.\nRule limits\nThere is a performance overhead to loading and evaluating rules in the browser, so some limits apply when using the API. Limits depend on the type of rule you're using.\nStatic rules\nStatic rules are those specified in rule files declared in the manifest file. An extension can specify up to 100 static rulesets as part of the \"rule_resources\"\nmanifest key, but only 50 of these rulesets can be enabled at a time. The latter is called the MAX_NUMBER_OF_ENABLED_STATIC_RULESETS\n. Collectively, those rulesets are guaranteed at least 30,000 rules. This is called the GUARANTEED_MINIMUM_STATIC_RULES\n.\nThe number of rules available after that depends on how many rules are enabled by all the extensions installed on a user's browser. You can find this number at runtime by calling getAvailableStaticRuleCount()\n. You can see an example of this under code examples.\nSession rules\nAn extension can have up to 5000 session rules. This is exposed as the\nMAX_NUMBER_OF_SESSION_RULES\n.\nBefore Chrome 120, there was a limit of 5000 combined dynamic and session rules.\nDynamic rules\nAn extension can have at least 5000 dynamic rules. This is exposed as the\nMAX_NUMBER_OF_UNSAFE_DYNAMIC_RULES\n.\nStarting in Chrome 121, there is a larger limit of 30,000 rules available for safe dynamic rules,\nexposed as the MAX_NUMBER_OF_DYNAMIC_RULES\n. Any\nunsafe rules added within the limit of 5000 will also count towards this limit.\nBefore Chrome 120, there was a 5000 combined dynamic and session rules limit.\nRules that use regular expressions\nAll types of rules can use regular expressions; however, the total number of regular expression rules of each type cannot exceed 1000. This is called the MAX_NUMBER_OF_REGEX_RULES.\nAdditionally, each rule must be less than 2KB once compiled. This roughly correlates with the complexity of the rule. If you try to load a rule that exceeds this limit, you will see a warning like the following and the rule will be ignored.\nrules_1.json: Rule with id 1 specified a more complex regex than allowed\nas part of the \"regexFilter\" key.\nInteractions with service workers\nA declarativeNetRequest only applies to requests that reach the network stack. This includes responses from the HTTP cache, but may not include responses that go through a service worker's onfetch\nhandler. declarativeNetRequest won't affect responses generated by the service worker or retrieved from CacheStorage\n, but it will affect calls to fetch()\nmade in a service worker.\nWeb accessible resources\nA declarativeNetRequest rule cannot redirect from a public resource request to a resource that is not web accessible. Doing so triggers an error. This is true even if the specified web accessible resource is owned by the redirecting extension. To declare resources for declarativeNetRequest, use the manifest's \"web_accessible_resources\"\narray.\nHeader modification\nThe append operation is only supported for the following headers: accept\n, accept-encoding\n, accept-language\n, access-control-request-headers\n, cache-control\n, connection\n, content-language\n, cookie\n, forwarded\n, if-match\n, if-none-match\n, keep-alive\n, range\n, te\n, trailer\n, transfer-encoding\n, upgrade\n, user-agent\n, via\n, want-digest\n, x-forwarded-for\n.\nExamples\nCode examples\nUpdate dynamic rules\nThe following example shows how to call updateDynamicRules()\n. The procedure for updateSessionRules()\nis the same.\n// Get arrays containing new and old rules\nconst newRules = await getNewRules();\nconst oldRules = await chrome.declarativeNetRequest.getDynamicRules();\nconst oldRuleIds = oldRules.map(rule => rule.id);\n// Use the arrays to update the dynamic rules\nawait chrome.declarativeNetRequest.updateDynamicRules({\nremoveRuleIds: oldRuleIds,\naddRules: newRules\n});\nUpdate static rulesets\nThe following example shows how to enable and disable rulesets while considering the number of available and the maximum number of enabled static rulesets. You would do this when the number of static rules you need exceeds the number allowed. For this to work, some of your rulesets should be installed with some of your rulesets disabled (setting \"Enabled\"\nto false\nwithin the manifest file).\nasync function updateStaticRules(enableRulesetIds, disableCandidateIds) {\n// Create the options structure for the call to updateEnabledRulesets()\nlet options = { enableRulesetIds: enableRulesetIds }\n// Get the number of enabled static rules\nconst enabledStaticCount = await chrome.declarativeNetRequest.getEnabledRulesets();\n// Compare rule counts to determine if anything needs to be disabled so that\n// new rules can be enabled\nconst proposedCount = enableRulesetIds.length;\nif (enabledStaticCount + proposedCount > chrome.declarativeNetRequest.MAX_NUMBER_OF_ENABLED_STATIC_RULESETS) {\noptions.disableRulesetIds = disableCandidateIds\n}\n// Update the enabled static rules\nawait chrome.declarativeNetRequest.updateEnabledRulesets(options);\n}\nRule examples\nThe following examples illustrate how Chrome prioritizes rules in an extension. When reviewing them, you may want to open the prioritization rules in a separate window.\nThe \"priority\" key\nThese examples require host permission to *://*.example.com/*\n.\nTo work out the priority of a particular URL, look at the (developer-defined) \"priority\"\nkey, the \"action\"\nkey and the \"urlFilter\"\nkey. These examples refer to the example rule file shown below them.\n- Navigation to https://google.com\n- Two rules cover this URL: the rules with IDs 1 and 4. The rule with ID 1 applies because\n\"block\"\nactions have a higher priority than\"redirect\"\nactions. The remaining rules don't apply because they are for longer URLs. - Navigation to https://google.com/1234\n- Because of the longer URL, the rule with ID 2 now matches in addition to the rules with IDs 1 and 4. The rule with ID 2 applies because\n\"allow\"\nhas a higher priority than\"block\"\nand\"redirect\"\n. - Navigation to https://google.com/12345\n- All four rules match this URL. The rule with ID 3 applies because its developer-defined priority is the highest of the group.\n[\n{\n\"id\": 1,\n\"priority\": 1,\n\"action\": { \"type\": \"block\" },\n\"condition\": {\"urlFilter\": \"||google.com/\", \"resourceTypes\": [\"main_frame\"] }\n},\n{\n\"id\": 2,\n\"priority\": 1,\n\"action\": { \"type\": \"allow\" },\n\"condition\": { \"urlFilter\": \"||google.com/123\", \"resourceTypes\": [\"main_frame\"] }\n},\n{\n\"id\": 3,\n\"priority\": 2,\n\"action\": { \"type\": \"block\" },\n\"condition\": { \"urlFilter\": \"||google.com/12345\", \"resourceTypes\": [\"main_frame\"] }\n},\n{\n\"id\": 4,\n\"priority\": 1,\n\"action\": { \"type\": \"redirect\", \"redirect\": { \"url\": \"https://example.com\" } },\n\"condition\": { \"urlFilter\": \"||google.com/\", \"resourceTypes\": [\"main_frame\"] }\n},\n]\nRedirects\nThe example below requires host permission to *://*.example.com/*\n.\nThe following example shows how to redirect a request from example.com to a page within the extension itself. The extension path /a.jpg\nresolves to chrome-extension://EXTENSION_ID/a.jpg\n, where EXTENSION_ID\nis the ID of your extension. For this to work the manifest should declare /a.jpg\nas a web accessible resource.\n{\n\"id\": 1,\n\"priority\": 1,\n\"action\": { \"type\": \"redirect\", \"redirect\": { \"extensionPath\": \"/a.jpg\" } },\n\"condition\": {\n\"urlFilter\": \"||https://www.example.com/\",\n\"resourceTypes\": [\"main_frame\"]\n}\n}\nThe following uses the \"transform\"\nkey to redirect to a subdomain of example.com. It uses a domain name anchor (\"||\") to intercept requests with any scheme from example.com. The \"scheme\"\nkey in \"transform\"\nspecifies that redirects to the subdomain will always use \"https\".\n{\n\"id\": 1,\n\"priority\": 1,\n\"action\": {\n\"type\": \"redirect\",\n\"redirect\": {\n\"transform\": { \"scheme\": \"https\", \"host\": \"new.example.com\" }\n}\n},\n\"condition\": {\n\"urlFilter\": \"||example.com/\",\n\"resourceTypes\": [\"main_frame\"]\n}\n}\nThe following example uses regular expressions to redirect from https://www.abc.xyz.com/path\nto https://abc.xyz.com/path\n. In the \"regexFilter\"\nkey, notice how periods are escaped and that the capturing group selects either \"abc\" or \"def\". The \"regexSubstitution\"\nkey specifies the first returned match of the regular expression using \"\\1\". In this case, \"abc\" is captured from the redirected URL and placed in the substitution.\n{\n\"id\": 1,\n\"priority\": 1,\n\"action\": {\n\"type\": \"redirect\",\n\"redirect\": {\n\"regexSubstitution\": \"https://\\\\1.xyz.com/\"\n}\n},\n\"condition\": {\n\"regexFilter\": \"^https://www\\\\.(abc|def)\\\\.xyz\\\\.com/\",\n\"resourceTypes\": [\n\"main_frame\"\n]\n}\n}\nHeaders\nThe following example removes all cookies from both a main frame and any sub frames.\n{\n\"id\": 1,\n\"priority\": 1,\n\"action\": {\n\"type\": \"modifyHeaders\",\n\"requestHeaders\": [{ \"header\": \"cookie\", \"operation\": \"remove\" }]\n},\n\"condition\": { \"resourceTypes\": [\"main_frame\", \"sub_frame\"] }\n}\nTypes\nDomainType\nThis describes whether the request is first or third party to the frame in which it originated. A request is said to be first party if it has the same domain (eTLD+1) as the frame in which the request originated.\nEnum\n\"firstParty\" \"thirdParty\"\nThe network request is first party to the frame in which it originated.\nThe network request is third party to the frame in which it originated.\nExtensionActionOptions\nProperties\n-\ndisplayActionCountAsBadgeText\nboolean optional\nWhether to automatically display the action count for a page as the extension's badge text. This preference is persisted across sessions.\n-\ntabUpdate\nTabActionCountUpdate optional\nChrome 89+Details of how the tab's action count should be adjusted.\nGetDisabledRuleIdsOptions\nProperties\n-\nrulesetId\nstring\nThe id corresponding to a static\nRuleset\n.\nGetRulesFilter\nProperties\n-\nruleIds\nnumber[] optional\nIf specified, only rules with matching IDs are included.\nHeaderInfo\nProperties\n-\nexcludedValues\nstring[] optional\nIf specified, this condition is not matched if the header exists but its value contains at least one element in this list. This uses the same match pattern syntax as\nvalues\n. -\nheader\nstring\nThe name of the header. This condition matches on the name only if both\nvalues\nandexcludedValues\nare not specified. -\nvalues\nstring[] optional\nIf specified, this condition matches if the header's value matches at least one pattern in this list. This supports case-insensitive header value matching plus the following constructs:\n'*' : Matches any number of characters.\n'?' : Matches zero or one character(s).\n'*' and '?' can be escaped with a backslash, e.g. '\\*' and '\\?'\nHeaderOperation\nThis describes the possible operations for a \"modifyHeaders\" rule.\nEnum\n\"append\" \"set\" \"remove\"\nAdds a new entry for the specified header. This operation is not supported for request headers.\nSets a new value for the specified header, removing any existing headers with the same name.\nRemoves all entries for the specified header.\nIsRegexSupportedResult\nProperties\n-\nisSupported\nboolean\n-\nreason\nUnsupportedRegexReason optional\nSpecifies the reason why the regular expression is not supported. Only provided if\nisSupported\nis false.\nMatchedRule\nProperties\n-\nruleId\nnumber\nA matching rule's ID.\n-\nrulesetId\nstring\nID of the\nRuleset\nthis rule belongs to. For a rule originating from the set of dynamic rules, this will be equal toDYNAMIC_RULESET_ID\n.\nMatchedRuleInfo\nProperties\n-\nrule\n-\ntabId\nnumber\nThe tabId of the tab from which the request originated if the tab is still active. Else -1.\n-\ntimeStamp\nnumber\nThe time the rule was matched. Timestamps will correspond to the Javascript convention for times, i.e. number of milliseconds since the epoch.\nMatchedRuleInfoDebug\nProperties\n-\nrequest\nDetails about the request for which the rule was matched.\n-\nrule\nMatchedRulesFilter\nProperties\n-\nminTimeStamp\nnumber optional\nIf specified, only matches rules after the given timestamp.\n-\ntabId\nnumber optional\nIf specified, only matches rules for the given tab. Matches rules not associated with any active tab if set to -1.\nModifyHeaderInfo\nProperties\n-\nheader\nstring\nThe name of the header to be modified.\n-\noperation\nThe operation to be performed on a header.\n-\nvalue\nstring optional\nThe new value for the header. Must be specified for\nappend\nandset\noperations.\nQueryKeyValue\nProperties\n-\nkey\nstring\n-\nreplaceOnly\nboolean optional\nChrome 94+If true, the query key is replaced only if it's already present. Otherwise, the key is also added if it's missing. Defaults to false.\n-\nvalue\nstring\nQueryTransform\nProperties\n-\naddOrReplaceParams\nQueryKeyValue[] optional\nThe list of query key-value pairs to be added or replaced.\n-\nremoveParams\nstring[] optional\nThe list of query keys to be removed.\nRedirect\nProperties\n-\nextensionPath\nstring optional\nPath relative to the extension directory. Should start with '/'.\n-\nregexSubstitution\nstring optional\nSubstitution pattern for rules which specify a\nregexFilter\n. The first match ofregexFilter\nwithin the url will be replaced with this pattern. WithinregexSubstitution\n, backslash-escaped digits (\\1 to \\9) can be used to insert the corresponding capture groups. \\0 refers to the entire matching text. -\ntransform\nURLTransform optional\nUrl transformations to perform.\n-\nurl\nstring optional\nThe redirect url. Redirects to JavaScript urls are not allowed.\nRegexOptions\nProperties\n-\nisCaseSensitive\nboolean optional\nWhether the\nregex\nspecified is case sensitive. Default is true. -\nregex\nstring\nThe regular expresson to check.\n-\nrequireCapturing\nboolean optional\nWhether the\nregex\nspecified requires capturing. Capturing is only required for redirect rules which specify aregexSubstition\naction. The default is false.\nRequestDetails\nProperties\n-\ndocumentId\nstring optional\nChrome 106+The unique identifier for the frame's document, if this request is for a frame.\n-\ndocumentLifecycle\nDocumentLifecycle optional\nChrome 106+The lifecycle of the frame's document, if this request is for a frame.\n-\nframeId\nnumber\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (\ntype\nismain_frame\norsub_frame\n),frameId\nindicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. -\nframeType\nFrameType optional\nChrome 106+The type of the frame, if this request is for a frame.\n-\ninitiator\nstring optional\nThe origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n-\nmethod\nstring\nStandard HTTP method.\n-\nparentDocumentId\nstring optional\nChrome 106+The unique identifier for the frame's parent document, if this request is for a frame and has a parent.\n-\nparentFrameId\nnumber\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session.\n-\ntabId\nnumber\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n-\ntype\nThe resource type of the request.\n-\nurl\nstring\nThe URL of the request.\nRequestMethod\nThis describes the HTTP request method of a network request.\nEnum\n\"connect\" \"delete\" \"get\" \"head\" \"options\" \"patch\" \"post\" \"put\" \"other\"\nResourceType\nThis describes the resource type of the network request.\nEnum\n\"main_frame\" \"sub_frame\" \"stylesheet\" \"script\" \"image\" \"font\" \"object\" \"xmlhttprequest\" \"ping\" \"csp_report\" \"media\" \"websocket\" \"webtransport\" \"webbundle\" \"other\"\nRule\nProperties\n-\naction\nThe action to take if this rule is matched.\n-\ncondition\nThe condition under which this rule is triggered.\n-\nid\nnumber\nAn id which uniquely identifies a rule. Mandatory and should be >= 1.\n-\npriority\nnumber optional\nRule priority. Defaults to 1. When specified, should be >= 1.\nRuleAction\nProperties\n-\nredirect\nRedirect optional\nDescribes how the redirect should be performed. Only valid for redirect rules.\n-\nrequestHeaders\nModifyHeaderInfo[] optional\nChrome 86+The request headers to modify for the request. Only valid if RuleActionType is \"modifyHeaders\".\n-\nresponseHeaders\nModifyHeaderInfo[] optional\nChrome 86+The response headers to modify for the request. Only valid if RuleActionType is \"modifyHeaders\".\n-\ntype\nThe type of action to perform.\nRuleActionType\nDescribes the kind of action to take if a given RuleCondition matches.\nEnum\n\"block\" \"redirect\" \"allow\" \"upgradeScheme\" \"modifyHeaders\" \"allowAllRequests\"\nBlock the network request.\nRedirect the network request.\nAllow the network request. The request won't be intercepted if there is an allow rule which matches it.\nUpgrade the network request url's scheme to https if the request is http or ftp.\nModify request/response headers from the network request.\nAllow all requests within a frame hierarchy, including the frame request itself.\nRuleCondition\nProperties\n-\ndomainType\nDomainType optional\nSpecifies whether the network request is first-party or third-party to the domain from which it originated. If omitted, all requests are accepted.\n-\ndomains\nstring[] optional\nDeprecated since Chrome 101Use\ninitiatorDomains\ninsteadThe rule will only match network requests originating from the list of\ndomains\n. -\nexcludedDomains\nstring[] optional\nDeprecated since Chrome 101Use\nexcludedInitiatorDomains\ninsteadThe rule will not match network requests originating from the list of\nexcludedDomains\n. -\nexcludedInitiatorDomains\nstring[] optional\nChrome 101+The rule will not match network requests originating from the list of\nexcludedInitiatorDomains\n. If the list is empty or omitted, no domains are excluded. This takes precedence overinitiatorDomains\n.Notes:\n- Sub-domains like \"a.example.com\" are also allowed.\n- The entries must consist of only ascii characters.\n- Use punycode encoding for internationalized domains.\n- This matches against the request initiator and not the request url.\n- Sub-domains of the listed domains are also excluded.\n-\nexcludedRequestDomains\nstring[] optional\nChrome 101+The rule will not match network requests when the domains matches one from the list of\nexcludedRequestDomains\n. If the list is empty or omitted, no domains are excluded. This takes precedence overrequestDomains\n.Notes:\n- Sub-domains like \"a.example.com\" are also allowed.\n- The entries must consist of only ascii characters.\n- Use punycode encoding for internationalized domains.\n- Sub-domains of the listed domains are also excluded.\n-\nexcludedRequestMethods\nRequestMethod[] optional\nChrome 91+List of request methods which the rule won't match. Only one of\nrequestMethods\nandexcludedRequestMethods\nshould be specified. If neither of them is specified, all request methods are matched. -\nexcludedResourceTypes\nResourceType[] optional\nList of resource types which the rule won't match. Only one of\nresourceTypes\nandexcludedResourceTypes\nshould be specified. If neither of them is specified, all resource types except \"main_frame\" are blocked. -\nexcludedResponseHeaders\nHeaderInfo[] optional\nChrome 128+Rule does not match if the request matches any response header condition in this list (if specified). If both\nexcludedResponseHeaders\nandresponseHeaders\nare specified, then theexcludedResponseHeaders\nproperty takes precedence. -\nexcludedTabIds\nnumber[] optional\nChrome 92+List of\ntabs.Tab.id\nwhich the rule should not match. An ID oftabs.TAB_ID_NONE\nexcludes requests which don't originate from a tab. Only supported for session-scoped rules. -\ninitiatorDomains\nstring[] optional\nChrome 101+The rule will only match network requests originating from the list of\ninitiatorDomains\n. If the list is omitted, the rule is applied to requests from all domains. An empty list is not allowed.Notes:\n- Sub-domains like \"a.example.com\" are also allowed.\n- The entries must consist of only ascii characters.\n- Use punycode encoding for internationalized domains.\n- This matches against the request initiator and not the request url.\n- Sub-domains of the listed domains are also matched.\n-\nisUrlFilterCaseSensitive\nboolean optional\nWhether the\nurlFilter\norregexFilter\n(whichever is specified) is case sensitive. Default is false. -\nregexFilter\nstring optional\nRegular expression to match against the network request url. This follows the RE2 syntax.\nNote: Only one of\nurlFilter\norregexFilter\ncan be specified.Note: The\nregexFilter\nmust be composed of only ASCII characters. This is matched against a url where the host is encoded in the punycode format (in case of internationalized domains) and any other non-ascii characters are url encoded in utf-8. -\nrequestDomains\nstring[] optional\nChrome 101+The rule will only match network requests when the domain matches one from the list of\nrequestDomains\n. If the list is omitted, the rule is applied to requests from all domains. An empty list is not allowed.Notes:\n- Sub-domains like \"a.example.com\" are also allowed.\n- The entries must consist of only ascii characters.\n- Use punycode encoding for internationalized domains.\n- Sub-domains of the listed domains are also matched.\n-\nrequestMethods\nRequestMethod[] optional\nChrome 91+List of HTTP request methods which the rule can match. An empty list is not allowed.\nNote: Specifying a\nrequestMethods\nrule condition will also exclude non-HTTP(s) requests, whereas specifyingexcludedRequestMethods\nwill not. -\nresourceTypes\nResourceType[] optional\nList of resource types which the rule can match. An empty list is not allowed.\nNote: this must be specified for\nallowAllRequests\nrules and may only include thesub_frame\nandmain_frame\nresource types. -\nresponseHeaders\nHeaderInfo[] optional\nChrome 128+Rule matches if the request matches any response header condition in this list (if specified).\n-\ntabIds\nnumber[] optional\nChrome 92+List of\ntabs.Tab.id\nwhich the rule should match. An ID oftabs.TAB_ID_NONE\nmatches requests which don't originate from a tab. An empty list is not allowed. Only supported for session-scoped rules. -\nurlFilter\nstring optional\nThe pattern which is matched against the network request url. Supported constructs:\n'*' : Wildcard: Matches any number of characters.\n'|' : Left/right anchor: If used at either end of the pattern, specifies the beginning/end of the url respectively.\n'||' : Domain name anchor: If used at the beginning of the pattern, specifies the start of a (sub-)domain of the URL.\n'^' : Separator character: This matches anything except a letter, a digit, or one of the following:\n_\n,-\n,.\n, or%\n. This also match the end of the URL.Therefore\nurlFilter\nis composed of the following parts: (optional Left/Domain name anchor) + pattern + (optional Right anchor).If omitted, all urls are matched. An empty string is not allowed.\nA pattern beginning with\n||*\nis not allowed. Use*\ninstead.Note: Only one of\nurlFilter\norregexFilter\ncan be specified.Note: The\nurlFilter\nmust be composed of only ASCII characters. This is matched against a url where the host is encoded in the punycode format (in case of internationalized domains) and any other non-ascii characters are url encoded in utf-8. For example, when the request url is http://abc.\u0440\u0444?q=\u0444, theurlFilter\nwill be matched against the url http://abc.xn--p1ai/?q=%D1%84.\nRuleset\nProperties\n-\nenabled\nboolean\nWhether the ruleset is enabled by default.\n-\nid\nstring\nA non-empty string uniquely identifying the ruleset. IDs beginning with '_' are reserved for internal use.\n-\npath\nstring\nThe path of the JSON ruleset relative to the extension directory.\nRulesMatchedDetails\nProperties\n-\nrulesMatchedInfo\nRules matching the given filter.\nTabActionCountUpdate\nProperties\n-\nincrement\nnumber\nThe amount to increment the tab's action count by. Negative values will decrement the count.\n-\ntabId\nnumber\nThe tab for which to update the action count.\nTestMatchOutcomeResult\nProperties\n-\nmatchedRules\nThe rules (if any) that match the hypothetical request.\nTestMatchRequestDetails\nProperties\n-\ninitiator\nstring optional\nThe initiator URL (if any) for the hypothetical request.\n-\nmethod\nRequestMethod optional\nStandard HTTP method of the hypothetical request. Defaults to \"get\" for HTTP requests and is ignored for non-HTTP requests.\n-\nresponseHeaders\nobject optional\nChrome 129+The headers provided by a hypothetical response if the request does not get blocked or redirected before it is sent. Represented as an object which maps a header name to a list of string values. If not specified, the hypothetical response would return empty response headers, which can match rules which match on the non-existence of headers. E.g.\n{\"content-type\": [\"text/html; charset=utf-8\", \"multipart/form-data\"]}\n-\ntabId\nnumber optional\nThe ID of the tab in which the hypothetical request takes place. Does not need to correspond to a real tab ID. Default is -1, meaning that the request isn't related to a tab.\n-\ntype\nThe resource type of the hypothetical request.\n-\nurl\nstring\nThe URL of the hypothetical request.\nUnsupportedRegexReason\nDescribes the reason why a given regular expression isn't supported.\nEnum\n\"syntaxError\" \"memoryLimitExceeded\"\nThe regular expression is syntactically incorrect, or uses features not available in the RE2 syntax.\nThe regular expression exceeds the memory limit.\nUpdateRuleOptions\nProperties\n-\naddRules\nRule[] optional\nRules to add.\n-\nremoveRuleIds\nnumber[] optional\nIDs of the rules to remove. Any invalid IDs will be ignored.\nUpdateRulesetOptions\nProperties\nUpdateStaticRulesOptions\nProperties\nURLTransform\nProperties\n-\nfragment\nstring optional\nThe new fragment for the request. Should be either empty, in which case the existing fragment is cleared; or should begin with '#'.\n-\nhost\nstring optional\nThe new host for the request.\n-\npassword\nstring optional\nThe new password for the request.\n-\npath\nstring optional\nThe new path for the request. If empty, the existing path is cleared.\n-\nport\nstring optional\nThe new port for the request. If empty, the existing port is cleared.\n-\nquery\nstring optional\nThe new query for the request. Should be either empty, in which case the existing query is cleared; or should begin with '?'.\n-\nqueryTransform\nQueryTransform optional\nAdd, remove or replace query key-value pairs.\n-\nscheme\nstring optional\nThe new scheme for the request. Allowed values are \"http\", \"https\", \"ftp\" and \"chrome-extension\".\n-\nusername\nstring optional\nThe new username for the request.\nProperties\nDYNAMIC_RULESET_ID\nRuleset ID for the dynamic rules added by the extension.\nValue\n\"_dynamic\"\nGETMATCHEDRULES_QUOTA_INTERVAL\nTime interval within which MAX_GETMATCHEDRULES_CALLS_PER_INTERVAL getMatchedRules\ncalls can be made, specified in minutes. Additional calls will fail immediately and set runtime.lastError\n. Note: getMatchedRules\ncalls associated with a user gesture are exempt from the quota.\nValue\n10\nGUARANTEED_MINIMUM_STATIC_RULES\nThe minimum number of static rules guaranteed to an extension across its enabled static rulesets. Any rules above this limit will count towards the global static rule limit.\nValue\n30000\nMAX_GETMATCHEDRULES_CALLS_PER_INTERVAL\nThe number of times getMatchedRules\ncan be called within a period of GETMATCHEDRULES_QUOTA_INTERVAL\n.\nValue\n20\nMAX_NUMBER_OF_DYNAMIC_RULES\nThe maximum number of dynamic rules that an extension can add.\nValue\n30000\nMAX_NUMBER_OF_ENABLED_STATIC_RULESETS\nThe maximum number of static Rulesets\nan extension can enable at any one time.\nValue\n50\nMAX_NUMBER_OF_REGEX_RULES\nThe maximum number of regular expression rules that an extension can add. This limit is evaluated separately for the set of dynamic rules and those specified in the rule resources file.\nValue\n1000\nMAX_NUMBER_OF_SESSION_RULES\nThe maximum number of session scoped rules that an extension can add.\nValue\n5000\nMAX_NUMBER_OF_STATIC_RULESETS\nThe maximum number of static Rulesets\nan extension can specify as part of the \"rule_resources\"\nmanifest key.\nValue\n100\nMAX_NUMBER_OF_UNSAFE_DYNAMIC_RULES\nThe maximum number of \"unsafe\" dynamic rules that an extension can add.\nValue\n5000\nMAX_NUMBER_OF_UNSAFE_SESSION_RULES\nThe maximum number of \"unsafe\" session scoped rules that an extension can add.\nValue\n5000\nSESSION_RULESET_ID\nRuleset ID for the session-scoped rules added by the extension.\nValue\n\"_session\"\nMethods\ngetAvailableStaticRuleCount()\nchrome.declarativeNetRequest.getAvailableStaticRuleCount(\ncallback?: function,\n)\nReturns the number of static rules an extension can enable before the global static rule limit is reached.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(count: number) => void\n-\ncount\nnumber\n-\nReturns\n-\nPromise<number>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetDisabledRuleIds()\nchrome.declarativeNetRequest.getDisabledRuleIds(\noptions: GetDisabledRuleIdsOptions,\ncallback?: function,\n)\nReturns the list of static rules in the given Ruleset\nthat are currently disabled.\nParameters\n-\noptions\nSpecifies the ruleset to query.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(disabledRuleIds: number[]) => void\n-\ndisabledRuleIds\nnumber[]\n-\nReturns\n-\nPromise<number[]>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetDynamicRules()\nchrome.declarativeNetRequest.getDynamicRules(\nfilter?: GetRulesFilter,\ncallback?: function,\n)\nReturns the current set of dynamic rules for the extension. Callers can optionally filter the list of fetched rules by specifying a filter\n.\nParameters\n-\nfilter\nGetRulesFilter optional\nChrome 111+An object to filter the list of fetched rules.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(rules: Rule[]) => void\n-\nrules\nRule[]\n-\nReturns\n-\nPromise<Rule[]>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetEnabledRulesets()\nchrome.declarativeNetRequest.getEnabledRulesets(\ncallback?: function,\n)\nReturns the ids for the current set of enabled static rulesets.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(rulesetIds: string[]) => void\n-\nrulesetIds\nstring[]\n-\nReturns\n-\nPromise<string[]>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetMatchedRules()\nchrome.declarativeNetRequest.getMatchedRules(\nfilter?: MatchedRulesFilter,\ncallback?: function,\n)\nReturns all rules matched for the extension. Callers can optionally filter the list of matched rules by specifying a filter\n. This method is only available to extensions with the \"declarativeNetRequestFeedback\"\npermission or having the \"activeTab\"\npermission granted for the tabId\nspecified in filter\n. Note: Rules not associated with an active document that were matched more than five minutes ago will not be returned.\nParameters\n-\nfilter\nMatchedRulesFilter optional\nAn object to filter the list of matched rules.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(details: RulesMatchedDetails) => void\n-\ndetails\n-\nReturns\n-\nPromise<RulesMatchedDetails>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetSessionRules()\nchrome.declarativeNetRequest.getSessionRules(\nfilter?: GetRulesFilter,\ncallback?: function,\n)\nReturns the current set of session scoped rules for the extension. Callers can optionally filter the list of fetched rules by specifying a filter\n.\nParameters\n-\nfilter\nGetRulesFilter optional\nChrome 111+An object to filter the list of fetched rules.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(rules: Rule[]) => void\n-\nrules\nRule[]\n-\nReturns\n-\nPromise<Rule[]>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nisRegexSupported()\nchrome.declarativeNetRequest.isRegexSupported(\nregexOptions: RegexOptions,\ncallback?: function,\n)\nChecks if the given regular expression will be supported as a regexFilter\nrule condition.\nParameters\n-\nregexOptions\nThe regular expression to check.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: IsRegexSupportedResult) => void\n-\nresult\n-\nReturns\n-\nPromise<IsRegexSupportedResult>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetExtensionActionOptions()\nchrome.declarativeNetRequest.setExtensionActionOptions(\noptions: ExtensionActionOptions,\ncallback?: function,\n)\nConfigures if the action count for tabs should be displayed as the extension action's badge text and provides a way for that action count to be incremented.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nChrome 89+The\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ntestMatchOutcome()\nchrome.declarativeNetRequest.testMatchOutcome(\nrequest: TestMatchRequestDetails,\ncallback?: function,\n)\nChecks if any of the extension's declarativeNetRequest rules would match a hypothetical request. Note: Only available for unpacked extensions as this is only intended to be used during extension development.\nParameters\n-\nrequest\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: TestMatchOutcomeResult) => void\n-\nresult\n-\nReturns\n-\nPromise<TestMatchOutcomeResult>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdateDynamicRules()\nchrome.declarativeNetRequest.updateDynamicRules(\noptions: UpdateRuleOptions,\ncallback?: function,\n)\nModifies the current set of dynamic rules for the extension. The rules with IDs listed in options.removeRuleIds\nare first removed, and then the rules given in options.addRules\nare added. Notes:\n- This update happens as a single atomic operation: either all specified rules are added and removed, or an error is returned.\n- These rules are persisted across browser sessions and across extension updates.\n- Static rules specified as part of the extension package can not be removed using this function.\nMAX_NUMBER_OF_DYNAMIC_RULES\nis the maximum number of dynamic rules an extension can add. The number of unsafe rules must not exceedMAX_NUMBER_OF_UNSAFE_DYNAMIC_RULES\n.\nParameters\n-\noptionsChrome 87+\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdateEnabledRulesets()\nchrome.declarativeNetRequest.updateEnabledRulesets(\noptions: UpdateRulesetOptions,\ncallback?: function,\n)\nUpdates the set of enabled static rulesets for the extension. The rulesets with IDs listed in options.disableRulesetIds\nare first removed, and then the rulesets listed in options.enableRulesetIds\nare added.\nNote that the set of enabled static rulesets is persisted across sessions but not across extension updates, i.e. the rule_resources\nmanifest key will determine the set of enabled static rulesets on each extension update.\nParameters\n-\noptionsChrome 87+\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdateSessionRules()\nchrome.declarativeNetRequest.updateSessionRules(\noptions: UpdateRuleOptions,\ncallback?: function,\n)\nModifies the current set of session scoped rules for the extension. The rules with IDs listed in options.removeRuleIds\nare first removed, and then the rules given in options.addRules\nare added. Notes:\n- This update happens as a single atomic operation: either all specified rules are added and removed, or an error is returned.\n- These rules are not persisted across sessions and are backed in memory.\nMAX_NUMBER_OF_SESSION_RULES\nis the maximum number of session rules an extension can add.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdateStaticRules()\nchrome.declarativeNetRequest.updateStaticRules(\noptions: UpdateStaticRulesOptions,\ncallback?: function,\n)\nDisables and enables individual static rules in a Ruleset\n. Changes to rules belonging to a disabled Ruleset\nwill take effect the next time that it becomes enabled.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonRuleMatchedDebug\nchrome.declarativeNetRequest.onRuleMatchedDebug.addListener(\ncallback: function,\n)\nFired when a rule is matched with a request. Only available for unpacked extensions with the \"declarativeNetRequestFeedback\"\npermission as this is intended to be used for debugging purposes only.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(info: MatchedRuleInfoDebug) => void\n-\ninfo\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/desktopCapture", "title": "chrome.desktopCapture | API | Chrome for Developers", "text": "Description\nThe Desktop Capture API captures the content of the screen, individual windows, or individual tabs.\nPermissions\ndesktopCapture\nTypes\nDesktopCaptureSourceType\nEnum used to define set of desktop media sources used in chooseDesktopMedia().\nEnum\n\"screen\" \"window\" \"tab\" \"audio\"\nEnum\n\"include\" \"exclude\"\nEnum\n\"include\" \"exclude\"\nMethods\ncancelChooseDesktopMedia()\nchrome.desktopCapture.cancelChooseDesktopMedia(\ndesktopMediaRequestId: number,\n)\nHides desktop media picker dialog shown by chooseDesktopMedia().\nParameters\n-\ndesktopMediaRequestId\nnumber\nId returned by chooseDesktopMedia()\nchooseDesktopMedia()\nchrome.desktopCapture.chooseDesktopMedia(\nsources: DesktopCaptureSourceType[],\ntargetTab?: Tab,\ncallback: function,\n)\nShows desktop media picker UI with the specified set of sources.\nParameters\n-\nsources\nSet of sources that should be shown to the user. The sources order in the set decides the tab order in the picker.\n-\ntargetTab\nTab optional\nOptional tab for which the stream is created. If not specified then the resulting stream can be used only by the calling extension. The stream can only be used by frames in the given tab whose security origin matches\ntab.url\n. The tab's origin must be a secure origin, e.g. HTTPS. -\ncallback\nfunction\nThe\ncallback\nparameter looks like:(streamId: string, options: object) => void\n-\nstreamId\nstring\nAn opaque string that can be passed to\ngetUserMedia()\nAPI to generate media stream that corresponds to the source selected by the user. If user didn't select any source (i.e. canceled the prompt) then the callback is called with an emptystreamId\n. The createdstreamId\ncan be used only once and expires after a few seconds when it is not used. -\noptions\nobject\nChrome 57+Contains properties that describe the stream.\n-\ncanRequestAudioTrack\nboolean\nTrue if \"audio\" is included in parameter sources, and the end user does not uncheck the \"Share audio\" checkbox. Otherwise false, and in this case, one should not ask for audio stream through getUserMedia call.\n-\n-\nReturns\n-\nnumber\nAn id that can be passed to cancelChooseDesktopMedia() in case the prompt need to be canceled."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/devtools/devtools_inspectedWindow", "title": "404 | Page Not Found | Chrome for Developers", "text": "Get inspired\nBlog\nDocs\nBuild with Chrome\nLearn how Chrome works, participate in origin trials, and build with Chrome everywhere.\nWeb Platform\nCapabilities\nChromeDriver\nExtensions\nChrome Web Store\nChromium\nAurora\nWeb on Android\nOrigin trials\nRelease notes\nProductivity\nCreate the best experience for your users with the web's best tools.\nDevTools\nLighthouse\nChrome UX Report\nAccessibility\nGet things done quicker and neater, with our ready-made libraries.\nWorkbox\nPuppeteer\nExperience\nDesign a beautiful and performant web with Chrome.\nAI\nPerformance\nCSS and UI\nIdentity\nPayments\nPrivacy and security\nResources\nMore from the Chrome team.\nAll documentation\nBaseline\nweb.dev\nPageSpeed Insights audit\nNew in Chrome\nMore\n/\nSign in\nGet inspired\nBlog\nDocs\nMore\nNew in Chrome\nBuild with Chrome\nWeb Platform\nCapabilities\nChromeDriver\nExtensions\nChrome Web Store\nChromium\nAurora\nWeb on Android\nOrigin trials\nRelease notes\nProductivity\nDevTools\nLighthouse\nChrome UX Report\nAccessibility\nWorkbox\nPuppeteer\nExperience\nAI\nPerformance\nCSS and UI\nIdentity\nPayments\nPrivacy and security\nResources\nAll documentation\nBaseline\nweb.dev\nPageSpeed Insights audit\n404\nSorry, we couldn't find that page.\n/\nContribute\nFile a bug\nSee open issues\nRelated content\nChromium updates\nCase studies\nArchive\nPodcasts & shows\nFollow\n@ChromiumDev on X\nYouTube\nChrome for Developers on LinkedIn\nRSS"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/devtools/inspectedWindow", "title": "chrome.devtools.inspectedWindow | API | Chrome for Developers", "text": "Description\nUse the chrome.devtools.inspectedWindow\nAPI to interact with the inspected window: obtain the tab ID for the inspected page, evaluate the code in the context of the inspected window, reload the page, or obtain the list of resources within the page.\nSee DevTools APIs summary for general introduction to using Developer Tools APIs.\nThe tabId\nproperty provides the tab identifier that you can use with the chrome.tabs.*\nAPI calls. However, please note that chrome.tabs.*\nAPI is not exposed to the Developer Tools\nextension pages due to security considerations\u2014you will need to pass the tab ID to the background\npage and invoke the chrome.tabs.*\nAPI functions from there.\nThe reload\nmethod may be used to reload the inspected page. Additionally, the caller can specify\nan override for the user agent string, a script that will be injected early upon page load, or an\noption to force reload of cached resources.\nUse the getResources\ncall and the onResourceContent\nevent to obtain the list of resources\n(documents, stylesheets, scripts, images etc) within the inspected page. The getContent\nand\nsetContent\nmethods of the Resource\nclass along with the onResourceContentCommitted\nevent may\nbe used to support modification of the resource content, for example, by an external editor.\nManifest\nExecute code in the inspected window\nThe eval\nmethod provides the ability for extensions to execute JavaScript code in the context of\nthe inspected page. This method is powerful when used in the right context and dangerous when used\ninappropriately. Use the tabs.executeScript\nmethod unless you need the specific functionality\nthat the eval\nmethod provides.\nHere are the main differences between the eval\nand tabs.executeScript\nmethods:\n- The\neval\nmethod does not use an isolated world for the code being evaluated, so the JavaScript state of the inspected window is accessible to the code. Use this method when access to the JavaScript state of the inspected page is required. - The execution context of the code being evaluated includes the Developer Tools console API.\nFor example, the code can use\ninspect\nand$0\n. - The evaluated code may return a value that is passed to the extension callback. The returned value has to be a valid JSON object (it may contain only primitive JavaScript types and acyclic references to other JSON objects). Please observe extra care while processing the data received from the inspected page\u2014the execution context is essentially controlled by the inspected page; a malicious page may affect the data being returned to the extension.\nNote that a page can include multiple different JavaScript execution contexts. Each frame has its own context, plus an additional context for each extension that has content scripts running in that frame.\nBy default, the eval\nmethod executes in the context of the main frame of the inspected page.\nThe eval\nmethod takes an optional second argument that you can use to specify the context in which\nthe code is evaluated. This options object can contain one or more of the following keys:\nframeURL\n- Use to specify a frame other than the inspected page's main frame.\ncontextSecurityOrigin\n- Use to select a context within the specified frame according to its web origin.\nuseContentScriptContext\n- If true, execute the script in the same context as the extensions's content scripts. (Equivalent to specifying the extensions's own web orgin as the context security origin.) This can be used to exchange data with the content script.\nExamples\nThe following code checks for the version of jQuery used by the inspected page:\nchrome.devtools.inspectedWindow.eval(\n\"jQuery.fn.jquery\",\nfunction(result, isException) {\nif (isException) {\nconsole.log(\"the page is not using jQuery\");\n} else {\nconsole.log(\"The page is using jQuery v\" + result);\n}\n}\n);\nTo try this API, install the devtools API examples from the chrome-extension-samples repository.\nTypes\nResource\nA resource within the inspected page, such as a document, a script, or an image.\nProperties\n-\nurl\nstring\nThe URL of the resource.\n-\ngetContent\nvoid\nGets the content of the resource.\nThe\ngetContent\nfunction looks like:(callback: function) => {...}\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(content: string, encoding: string) => void\n-\ncontent\nstring\nContent of the resource (potentially encoded).\n-\nencoding\nstring\nEmpty if the content is not encoded, encoding name otherwise. Currently, only base64 is supported.\n-\n-\n-\nsetContent\nvoid\nSets the content of the resource.\nThe\nsetContent\nfunction looks like:(content: string, commit: boolean, callback?: function) => {...}\n-\ncontent\nstring\nNew content of the resource. Only resources with the text type are currently supported.\n-\ncommit\nboolean\nTrue if the user has finished editing the resource, and the new content of the resource should be persisted; false if this is a minor change sent in progress of the user editing the resource.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(error?: object) => void\n-\nerror\nobject optional\nSet to undefined if the resource content was set successfully; describes error otherwise.\n-\n-\nProperties\ntabId\nThe ID of the tab being inspected. This ID may be used with chrome.tabs.* API.\nType\nnumber\nMethods\neval()\nchrome.devtools.inspectedWindow.eval(\nexpression: string,\noptions?: object,\ncallback?: function,\n)\nEvaluates a JavaScript expression in the context of the main frame of the inspected page. The expression must evaluate to a JSON-compliant object, otherwise an exception is thrown. The eval function can report either a DevTools-side error or a JavaScript exception that occurs during evaluation. In either case, the result\nparameter of the callback is undefined\n. In the case of a DevTools-side error, the isException\nparameter is non-null and has isError\nset to true and code\nset to an error code. In the case of a JavaScript error, isException\nis set to true and value\nis set to the string value of thrown object.\nParameters\n-\nexpression\nstring\nAn expression to evaluate.\n-\noptions\nobject optional\nThe options parameter can contain one or more options.\n-\nframeURL\nstring optional\nIf specified, the expression is evaluated on the iframe whose URL matches the one specified. By default, the expression is evaluated in the top frame of the inspected page.\n-\nscriptExecutionContext\nstring optional\nChrome 107+Evaluate the expression in the context of a content script of an extension that matches the specified origin. If given, scriptExecutionContext overrides the 'true' setting on useContentScriptContext.\n-\nuseContentScriptContext\nboolean optional\nEvaluate the expression in the context of the content script of the calling extension, provided that the content script is already injected into the inspected page. If not, the expression is not evaluated and the callback is invoked with the exception parameter set to an object that has the\nisError\nfield set to true and thecode\nfield set toE_NOTFOUND\n.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: object, exceptionInfo: object) => void\n-\nresult\nobject\nThe result of evaluation.\n-\nexceptionInfo\nobject\nAn object providing details if an exception occurred while evaluating the expression.\n-\ncode\nstring\nSet if the error occurred on the DevTools side before the expression is evaluated.\n-\ndescription\nstring\nSet if the error occurred on the DevTools side before the expression is evaluated.\n-\ndetails\nany[]\nSet if the error occurred on the DevTools side before the expression is evaluated, contains the array of the values that may be substituted into the description string to provide more information about the cause of the error.\n-\nisError\nboolean\nSet if the error occurred on the DevTools side before the expression is evaluated.\n-\nisException\nboolean\nSet if the evaluated code produces an unhandled exception.\n-\nvalue\nstring\nSet if the evaluated code produces an unhandled exception.\n-\n-\ngetResources()\nchrome.devtools.inspectedWindow.getResources(\ncallback: function,\n)\nRetrieves the list of resources from the inspected page.\nParameters\nreload()\nchrome.devtools.inspectedWindow.reload(\nreloadOptions?: object,\n)\nReloads the inspected page.\nParameters\n-\nreloadOptions\nobject optional\n-\nignoreCache\nboolean optional\nWhen true, the loader will bypass the cache for all inspected page resources loaded before the\nload\nevent is fired. The effect is similar to pressing Ctrl+Shift+R in the inspected window or within the Developer Tools window. -\ninjectedScript\nstring optional\nIf specified, the script will be injected into every frame of the inspected page immediately upon load, before any of the frame's scripts. The script will not be injected after subsequent reloads\u2014for example, if the user presses Ctrl+R.\n-\nuserAgent\nstring optional\nIf specified, the string will override the value of the\nUser-Agent\nHTTP header that's sent while loading the resources of the inspected page. The string will also override the value of thenavigator.userAgent\nproperty that's returned to any scripts that are running within the inspected page.\n-\nEvents\nonResourceAdded\nchrome.devtools.inspectedWindow.onResourceAdded.addListener(\ncallback: function,\n)\nFired when a new resource is added to the inspected page.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(resource: Resource) => void\n-\nresource\n-\nonResourceContentCommitted\nchrome.devtools.inspectedWindow.onResourceContentCommitted.addListener(\ncallback: function,\n)\nFired when a new revision of the resource is committed (e.g. user saves an edited version of the resource in the Developer Tools)."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/devtools/network", "title": "chrome.devtools.network | API | Chrome for Developers", "text": "Description\nUse the chrome.devtools.network\nAPI to retrieve the information about network requests displayed by the Developer Tools in the Network panel.\nNetwork requests information is represented in the HTTP Archive format (HAR). The description of HAR is outside of scope of this document, refer to HAR v1.2 Specification.\nIn terms of HAR, the chrome.devtools.network.getHAR()\nmethod returns entire HAR log, while\nchrome.devtools.network.onRequestFinished\nevent provides HAR entry as an argument to the event\ncallback.\nNote that request content is not provided as part of HAR for efficiency reasons. You may call\nrequest's getContent()\nmethod to retrieve content.\nIf the Developer Tools window is opened after the page is loaded, some requests may be missing in\nthe array of entries returned by getHAR()\n. Reload the page to get all requests. In general, the\nlist of requests returned by getHAR()\nshould match that displayed in the Network panel.\nSee DevTools APIs summary for general introduction to using Developer Tools APIs.\nManifest\nExamples\nThe following code logs URLs of all images larger than 40KB as they are loaded:\nchrome.devtools.network.onRequestFinished.addListener(\nfunction(request) {\nif (request.response.bodySize > 40*1024) {\nchrome.devtools.inspectedWindow.eval(\n'console.log(\"Large image: \" + unescape(\"' +\nescape(request.request.url) + '\"))');\n}\n}\n);\nTo try this API, install the devtools API examples from the chrome-extension-samples repository.\nTypes\nRequest\nRepresents a network request for a document resource (script, image and so on). See HAR Specification for reference.\nProperties\n-\ngetContent\nvoid\nReturns content of the response body.\nThe\ngetContent\nfunction looks like:(callback: function) => {...}\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(content: string, encoding: string) => void\n-\ncontent\nstring\nContent of the response body (potentially encoded).\n-\nencoding\nstring\nEmpty if content is not encoded, encoding name otherwise. Currently, only base64 is supported.\n-\n-\nMethods\ngetHAR()\nchrome.devtools.network.getHAR(\ncallback: function,\n)\nReturns HAR log that contains all known network requests.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(harLog: object) => void\n-\nharLog\nobject\nA HAR log. See HAR specification for details.\n-\nEvents\nonNavigated\nchrome.devtools.network.onNavigated.addListener(\ncallback: function,\n)\nFired when the inspected window navigates to a new page.\nParameters\n-\nfunction\nThe\ncallback\nparameter looks like:(url: string) => void\n-\nstring\n-\nonRequestFinished\nchrome.devtools.network.onRequestFinished.addListener(\ncallback: function,\n)\nFired when a network request is finished and all request data are available."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/devtools/panels", "title": "chrome.devtools.panels | API | Chrome for Developers", "text": "Description\nUse the chrome.devtools.panels\nAPI to integrate your extension into Developer Tools window UI: create your own panels, access existing panels, and add sidebars.\nEach extension panel and sidebar is displayed as a separate HTML page. All extension pages displayed\nin the Developer Tools window have access to all parts of the chrome.devtools\nAPI, as well as all\nother extension APIs.\nYou can use the devtools.panels.setOpenResourceHandler\nmethod to install a callback function\nthat handles user requests to open a resource (typically, a click a resource link in the\nDeveloper Tools window). At most one of the installed handlers gets called; users can specify (using\nthe Developer Tools Settings dialog) either the default behavior or an extension to handle resource\nopen requests. If an extension calls setOpenResourceHandler()\nmultiple times, only the last\nhandler is retained.\nSee DevTools APIs summary for general introduction to using Developer Tools APIs.\nManifest\nExample\nThe following code adds a panel contained in Panel.html\n, represented by FontPicker.png\non the\nDeveloper Tools toolbar and labeled as Font Picker:\nchrome.devtools.panels.create(\"Font Picker\",\n\"FontPicker.png\",\n\"Panel.html\",\nfunction(panel) { ... });\nThe following code adds a sidebar pane contained in Sidebar.html\nand titled Font Properties to\nthe Elements panel, then sets its height to 8ex\n:\nchrome.devtools.panels.elements.createSidebarPane(\"Font Properties\",\nfunction(sidebar) {\nsidebar.setPage(\"Sidebar.html\");\nsidebar.setHeight(\"8ex\");\n}\n);\nThe screenshot illustrates the effect this example would have on Developer Tools window:\nTo try this API, install the devtools panels API example from the chrome-extension-samples repository.\nTypes\nButton\nA button created by the extension.\nProperties\n-\nonClicked\nEvent<functionvoidvoid>\nFired when the button is clicked.\nThe\nonClicked.addListener\nfunction looks like:(callback: function) => {...}\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\n-\n-\nupdate\nvoid\nUpdates the attributes of the button. If some of the arguments are omitted or\nnull\n, the corresponding attributes are not updated.The\nupdate\nfunction looks like:(iconPath?: string, tooltipText?: string, disabled?: boolean) => {...}\n-\niconPath\nstring optional\nPath to the new icon of the button.\n-\ntooltipText\nstring optional\nText shown as a tooltip when user hovers the mouse over the button.\n-\ndisabled\nboolean optional\nWhether the button is disabled.\n-\nElementsPanel\nRepresents the Elements panel.\nProperties\n-\nonSelectionChanged\nEvent<functionvoidvoid>\nFired when an object is selected in the panel.\nThe\nonSelectionChanged.addListener\nfunction looks like:(callback: function) => {...}\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\n-\n-\ncreateSidebarPane\nvoid\nCreates a pane within panel's sidebar.\nThe\ncreateSidebarPane\nfunction looks like:(title: string, callback?: function) => {...}\n-\ntitle\nstring\nText that is displayed in sidebar caption.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: ExtensionSidebarPane) => void\n-\nresult\nAn ExtensionSidebarPane object for created sidebar pane.\n-\n-\nExtensionPanel\nRepresents a panel created by extension.\nProperties\n-\nonHidden\nEvent<functionvoidvoid>\nFired when the user switches away from the panel.\nThe\nonHidden.addListener\nfunction looks like:(callback: function) => {...}\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\n-\n-\nonSearch\nEvent<functionvoidvoid>\nFired upon a search action (start of a new search, search result navigation, or search being canceled).\nThe\nonSearch.addListener\nfunction looks like:(callback: function) => {...}\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(action: string, queryString?: string) => void\n-\naction\nstring\n-\nqueryString\nstring optional\n-\n-\n-\nonShown\nEvent<functionvoidvoid>\nFired when the user switches to the panel.\nThe\nonShown.addListener\nfunction looks like:(callback: function) => {...}\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(window: Window) => void\n-\nwindow\nWindow\n-\n-\n-\ncreateStatusBarButton\nvoid\nAppends a button to the status bar of the panel.\nThe\ncreateStatusBarButton\nfunction looks like:(iconPath: string, tooltipText: string, disabled: boolean) => {...}\n-\niconPath\nstring\nPath to the icon of the button. The file should contain a 64x24-pixel image composed of two 32x24 icons. The left icon is used when the button is inactive; the right icon is displayed when the button is pressed.\n-\ntooltipText\nstring\nText shown as a tooltip when user hovers the mouse over the button.\n-\ndisabled\nboolean\nWhether the button is disabled.\n-\nreturns\n-\nExtensionSidebarPane\nA sidebar created by the extension.\nProperties\n-\nonHidden\nEvent<functionvoidvoid>\nFired when the sidebar pane becomes hidden as a result of the user switching away from the panel that hosts the sidebar pane.\nThe\nonHidden.addListener\nfunction looks like:(callback: function) => {...}\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\n-\n-\nonShown\nEvent<functionvoidvoid>\nFired when the sidebar pane becomes visible as a result of user switching to the panel that hosts it.\nThe\nonShown.addListener\nfunction looks like:(callback: function) => {...}\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(window: Window) => void\n-\nwindow\nWindow\n-\n-\n-\nsetExpression\nvoid\nSets an expression that is evaluated within the inspected page. The result is displayed in the sidebar pane.\nThe\nsetExpression\nfunction looks like:(expression: string, rootTitle?: string, callback?: function) => {...}\n-\nexpression\nstring\nAn expression to be evaluated in context of the inspected page. JavaScript objects and DOM nodes are displayed in an expandable tree similar to the console/watch.\n-\nrootTitle\nstring optional\nAn optional title for the root of the expression tree.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\n-\n-\nsetHeight\nvoid\nSets the height of the sidebar.\nThe\nsetHeight\nfunction looks like:(height: string) => {...}\n-\nheight\nstring\nA CSS-like size specification, such as\n'100px'\nor'12ex'\n.\n-\n-\nsetObject\nvoid\nSets a JSON-compliant object to be displayed in the sidebar pane.\nThe\nsetObject\nfunction looks like:(jsonObject: string, rootTitle?: string, callback?: function) => {...}\n-\njsonObject\nstring\nAn object to be displayed in context of the inspected page. Evaluated in the context of the caller (API client).\n-\nrootTitle\nstring optional\nAn optional title for the root of the expression tree.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\n-\n-\nsetPage\nvoid\nSets an HTML page to be displayed in the sidebar pane.\nThe\nsetPage\nfunction looks like:(path: string) => {...}\n-\npath\nstring\nRelative path of an extension page to display within the sidebar.\n-\nSourcesPanel\nRepresents the Sources panel.\nProperties\n-\nonSelectionChanged\nEvent<functionvoidvoid>\nFired when an object is selected in the panel.\nThe\nonSelectionChanged.addListener\nfunction looks like:(callback: function) => {...}\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\n-\n-\ncreateSidebarPane\nvoid\nCreates a pane within panel's sidebar.\nThe\ncreateSidebarPane\nfunction looks like:(title: string, callback?: function) => {...}\n-\ntitle\nstring\nText that is displayed in sidebar caption.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: ExtensionSidebarPane) => void\n-\nresult\nAn ExtensionSidebarPane object for created sidebar pane.\n-\n-\nProperties\nelements\nElements panel.\nType\nsources\nSources panel.\nType\nthemeName\nThe name of the color theme set in user's DevTools settings. Possible values: default\n(the default) and dark\n.\nType\nstring\nMethods\ncreate()\nchrome.devtools.panels.create(\ntitle: string,\niconPath: string,\npagePath: string,\ncallback?: function,\n)\nCreates an extension panel.\nParameters\n-\ntitle\nstring\nTitle that is displayed next to the extension icon in the Developer Tools toolbar.\n-\niconPath\nstring\nPath of the panel's icon relative to the extension directory.\n-\npagePath\nstring\nPath of the panel's HTML page relative to the extension directory.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(panel: ExtensionPanel) => void\n-\npanel\nAn ExtensionPanel object representing the created panel.\n-\nopenResource()\nchrome.devtools.panels.openResource(\nurl: string,\nlineNumber: number,\ncolumnNumber?: number,\ncallback?: function,\n)\nRequests DevTools to open a URL in a Developer Tools panel.\nParameters\n-\nurl\nstring\nThe URL of the resource to open.\n-\nlineNumber\nnumber\nSpecifies the line number to scroll to when the resource is loaded.\n-\ncolumnNumber\nnumber optional\nChrome 114+Specifies the column number to scroll to when the resource is loaded.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nsetOpenResourceHandler()\nchrome.devtools.panels.setOpenResourceHandler(\ncallback?: function,\n)\nSpecifies the function to be called when the user clicks a resource link in the Developer Tools window. To unset the handler, either call the method with no parameters or pass null as the parameter.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(resource: Resource) => void\n-\nresource\nA\ndevtools.inspectedWindow.Resource\nobject for the resource that was clicked.\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/devtools/performance", "title": "chrome.devtools.performance | API | Chrome for Developers", "text": "Description\nUse the chrome.devtools.performance\nAPI to listen to recording status updates in the Performance panel in DevTools.\nSee DevTools APIs summary for general introduction to using Developer Tools APIs.\nAvailability\nConcepts and usage\nThe chrome.devtools.performance API allows developers to interact with the recording features of the Performance panel panel in Chrome DevTools. You can use this API to get notifications when recording starts or stops.\nTwo events are available:\n- onProfilingStarted: This event is fired when the Performance panel begins recording performance data.\n- onProfilingStopped: This event is fired when the Performance panel stops recording performance data. stance that associates the current stack trace with the cre Both events don't have any associated parameters.\nBy listening to these events, developers can create extensions that react to the recording status in the Performance panel, providing additional automation during performance profiling.\nExamples\nThis is how you can use the API to listen to recording status updates\nchrome.devtools.performance.onProfilingStarted.addListener(() => {\n// Profiling started listener implementation\n});\nchrome.devtools.performance.onProfilingStopped.addListener(() => {\n// Profiling stopped listener implementation\n})\nEvents\nonProfilingStarted\nchrome.devtools.performance.onProfilingStarted.addListener(\ncallback: function,\n)\nFired when the Performance panel starts recording.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonProfilingStopped\nchrome.devtools.performance.onProfilingStopped.addListener(\ncallback: function,\n)\nFired when the Performance panel stops recording.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/devtools/recorder", "title": "chrome.devtools.recorder | API | Chrome for Developers", "text": "Description\nUse the chrome.devtools.recorder\nAPI to customize the Recorder panel in DevTools.\ndevtools.recorder\nAPI is a preview feature that allows you to extend the Recorder panel in Chrome DevTools.\nSee DevTools APIs summary for general introduction to using Developer Tools APIs.\nAvailability\nConcepts and usage\nCustomizing the export feature\nTo register an extension plugin, use the registerRecorderExtensionPlugin\nfunction. This function requires a plugin instance, a name\nand a mediaType\nas parameters. The plugin instance must implement two methods: stringify\nand stringifyStep\n.\nThe name\nprovided by the extension shows up in the Export menu in the Recorder panel.\nDepending on the export context, when the user clicks the export option provided by the extension, the Recorder panel invokes one of the two functions:\nstringify\nthat receives an entire user flow recordingstringifyStep\nthat receives a single recorded step\nThe mediaType\nparameter allows the extension to specify the kind of output it generates with the\nstringify\nand stringifyStep\nfunctions. For example, application/javascript\nif the result is a JavaScript\nprogram.\nCustomizing the replay button\nTo customize the replay button in the Recorder, use the registerRecorderExtensionPlugin\nfunction. The plugin must implement the replay\nmethod for the customization to take effect.\nIf the method is detected, a replay button will appear in the Recorder.\nUpon clicking the button, the current recording object will be passed as the first argument to the replay\nmethod.\nAt this point, the extension can display a RecorderView\nfor handling the replay or use other extension APIs to process the replay request. To create a new RecorderView\n, invoke chrome.devtools.recorder.createView\n.\nExamples\nExport plugin\nThe following code implements an extension plugin that stringifes a recording using JSON.stringify\n:\nclass MyPlugin {\nstringify(recording) {\nreturn Promise.resolve(JSON.stringify(recording));\n}\nstringifyStep(step) {\nreturn Promise.resolve(JSON.stringify(step));\n}\n}\nchrome.devtools.recorder.registerRecorderExtensionPlugin(\nnew MyPlugin(),\n/*name=*/'MyPlugin',\n/*mediaType=*/'application/json'\n);\nReplay plugin\nThe following code implements an extension plugin that creates a dummy Recorder view and displays it upon a replay request:\nconst view = await chrome.devtools.recorder.createView(\n/* name= */ 'ExtensionName',\n/* pagePath= */ 'Replay.html'\n);\nlet latestRecording;\nview.onShown.addListener(() => {\n// Recorder has shown the view. Send additional data to the view if needed.\nchrome.runtime.sendMessage(JSON.stringify(latestRecording));\n});\nview.onHidden.addListener(() => {\n// Recorder has hidden the view.\n});\nexport class RecorderPlugin {\nreplay(recording) {\n// Share the data with the view.\nlatestRecording = recording;\n// Request to show the view.\nview.show();\n}\n}\nchrome.devtools.recorder.registerRecorderExtensionPlugin(\nnew RecorderPlugin(),\n/* name=*/ 'CoffeeTest'\n);\nFind a complete extension example on GitHub.\nTypes\nRecorderExtensionPlugin\nA plugin interface that the Recorder panel invokes to customize the Recorder panel.\nProperties\n-\nreplay\nvoid\nChrome 112+Allows the extension to implement custom replay functionality.\nThe\nreplay\nfunction looks like:(recording: object) => {...}\n-\nrecording\nobject\nA recording of the user interaction with the page. This should match Puppeteer's recording schema.\n-\n-\nstringify\nvoid\nConverts a recording from the Recorder panel format into a string.\nThe\nstringify\nfunction looks like:(recording: object) => {...}\n-\nrecording\nobject\nA recording of the user interaction with the page. This should match Puppeteer's recording schema.\n-\n-\nstringifyStep\nvoid\nConverts a step of the recording from the Recorder panel format into a string.\nThe\nstringifyStep\nfunction looks like:(step: object) => {...}\n-\nstep\nobject\nA step of the recording of a user interaction with the page. This should match Puppeteer's step schema.\n-\nRecorderView\nRepresents a view created by extension to be embedded inside the Recorder panel.\nProperties\n-\nonHidden\nEvent<functionvoidvoid>\nFired when the view is hidden.\nThe\nonHidden.addListener\nfunction looks like:(callback: function) => {...}\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\n-\n-\nonShown\nEvent<functionvoidvoid>\nFired when the view is shown.\nThe\nonShown.addListener\nfunction looks like:(callback: function) => {...}\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\n-\n-\nshow\nvoid\nIndicates that the extension wants to show this view in the Recorder panel.\nThe\nshow\nfunction looks like:() => {...}\nMethods\ncreateView()\nchrome.devtools.recorder.createView(\ntitle: string,\npagePath: string,\n)\nCreates a view that can handle the replay. This view will be embedded inside the Recorder panel.\nParameters\n-\ntitle\nstring\nTitle that is displayed next to the extension icon in the Developer Tools toolbar.\n-\npagePath\nstring\nPath of the panel's HTML page relative to the extension directory.\nReturns\nregisterRecorderExtensionPlugin()\nchrome.devtools.recorder.registerRecorderExtensionPlugin(\nplugin: RecorderExtensionPlugin,\nname: string,\nmediaType: string,\n)\nRegisters a Recorder extension plugin.\nParameters\n-\nplugin\nAn instance implementing the RecorderExtensionPlugin interface.\n-\nname\nstring\nThe name of the plugin.\n-\nmediaType\nstring\nThe media type of the string content that the plugin produces."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/dns", "title": "chrome.dns | API | Chrome for Developers", "text": "Description\nUse the chrome.dns\nAPI for dns resolution.\nPermissions\ndns\nAvailability\nTo use this API, you must declare the \"dns\"\npermission in the manifest.\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"dns\"\n],\n...\n}\nUsage\nThe following code calls resolve()\nto retrieve the IP address of example.com\n.\nservice-worker.js:\nconst resolveDNS = async () => {\nlet record = await chrome.dns.resolve('example.com');\nconsole.log(record.address); // \"192.0.2.172\"\n};\nresolveDNS();\nTypes\nResolveCallbackResolveInfo\nProperties\n-\naddress\nstring optional\nA string representing the IP address literal. Supplied only if resultCode indicates success.\n-\nresultCode\nnumber\nThe result code. Zero indicates success.\nMethods\nresolve()\nchrome.dns.resolve(\nhostname: string,\ncallback?: function,\n)\nResolves the given hostname or IP address literal.\nParameters\n-\nhostname\nstring\nThe hostname to resolve.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(resolveInfo: ResolveCallbackResolveInfo) => void\n-\nresolveInfo\n-\nReturns\n-\nPromise<ResolveCallbackResolveInfo>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/documentScan", "title": "chrome.documentScan | API | Chrome for Developers", "text": "Description\nUse the chrome.documentScan\nAPI to discover and retrieve images from attached document scanners.\nThe Document Scan API is designed to allow apps and extensions to view the content of paper documents on an attached document scanner.\nPermissions\ndocumentScan\nAvailability\nConcepts and usage\nThis API supports two means of scanning documents. If your use case can work\nwith any scanner and doesn't require control of the configuration, use the\nscan()\nmethod. More complicated use cases require a combination of methods,\nwhich are only supported in Chrome 124 and later.\nSimple scanning\nFor simple use cases, meaning those that can work with any scanner and don't\nrequire control of configuration, call scan()\n. This method takes a\nScanOptions\nobject and returns a Promise that resolves with a ScanResults\nobject. The capabilities of this option are limited to the number of scans and\nthe MIME types that will be accepted by the caller. Scans are returned as URLs\nfor display in an <img>\ntag for a user interface.\nComplex scanning\nComplex scans are accomplished in three phases as described in this section. This outline does not describe every method argument or every property returned in a response. It is only intended to give you a general guide to writing scanner code.\nDiscovery\nCall\ngetScannerList()\n. Available scanners are returned in a Promise that resolves with aGetScannerListResponse\n.- The response object contains an array of\nScannerInfo\nobjects. - The array may contain multiple entries for a single scanner if that scanner supports multiple protocols or connection methods.\n- The response object contains an array of\nSelect a scanner from the returned array and save the value of its\nscannerId\nproperty.Use the properties of individual\nScannerInfo\nobjects to distinguish among multiple objects for the same scanner. Objects from the same scanner will have the same value for thedeviceUuid\nproperty.ScannerInfo\nalso contains animageFormats\nproperty containing an array of supported image types.\nScanner configuration\nCall\nopenScanner()\n, passing in the saved scanner ID. It returns a Promise that resolves with anOpenScannerResponse\n. The response object contains:A\nscannerHandle\nproperty, which you'll need to save.An options property containing scanner-specific properties, which you'll need to set. See Retrieve scanner options for more information.\n(Optional) If you need the user to provide values for scanner options, construct a user interface. You will need the scanner options provided by the previous step, and you'll need to retrieve option groups provided by the scanner. See Construct a user interface for more information.\nConstruct an array of\nOptionSetting\nobjects using programmatic or user-provided values. See Set scanner options for more information.Pass the array of\nOptionSetting\nobjects tosetOptions()\nto set options for the scanner. It returns a Promise that resolves with aSetOptionsResponse\n. This object contains an updated version of the scanner options retrieved in step 1 of scanner configuration.Since changing one option can alter constraints on another option, you may need to repeat these steps several times.\nScanning\nConstruct a\nStartScanOptions\nobject and pass it tostartScan()\n. It returns a Promise that resolves with aStartScanResponse\n. Itsjob\nproperty is a handle that you will use to either read scan data or cancel the scan.Pass the job handle to\nreadScanData()\n. It returns a Promise that resolves with aReadScanDataResponse\nobject. If data was read successfully, itsresult\nproperty equalsSUCCESS\nand itsdata\nproperty contains anArrayBuffer\nwith part of the scan. Note thatestimatedCompletion\ncontains an estimated percentage of the total data that has been delivered so far.Repeat the previous step until the\nresult\nproperty equalsEOF\nor an error.\nWhen the end of the scan is reached, call\ncloseScanner()\nwith the scanner handle saved in step\n3. It returns a Promise that resolves with a\nCloseScannerResponse\n. Calling\ncancelScan()\nat any time after the job is created will\nend scanning.\nResponse objects\nAll methods return a Promise that resolves with a response object of some kind.\nMost of these contain a result\nproperty whose value is a member of\nOperationResult\n. Some properties of response objects\nwon't contain values unless the value of result\nhas a specific value. These\nrelationships are described in the reference for each response object.\nFor example, OpenScannerResponse.scannerHandle\nwill only have a value when\nOpenScannerResponse.result\nequals SUCCESS\n.\nScanner options\nScanner options vary considerably by device. Consequently, it's not possible to\nreflect scanner options directly within the documentScan API. To get around\nthis, the OpenScannerResponse\n(retrieved using\nopenScanner()\n) and the\nSetOptionsResponse\n(the response object for\nsetOptions()\n) contain an options\nproperty which is an\nobject containing scanner-specific options. Each option is a key-value mapping\nwhere the key is a device-specific option and the value is an instance of\nScannerOption\n.\nThe structure generally looks like this:\n{\n\"key1\": { scannerOptionInstance }\n\"key2\": { scannerOptionInstance }\n}\nFor example, imagine a scanner that returns options named \"source\" and\n\"resolution\". The structure of the returned options\nobject will look something\nlike the following example. For simplicity, only partial ScannerOption\nresponses are shown.\n{\n\"source\": {\n\"name\": \"source\",\n\"type\": OptionType.STRING,\n...\n},\n\"resolution\": {\n\"name\": \"resolution\",\n\"type\": OptionType.INT,\n...\n},\n...\n}\nConstruct a user interface\nThough not required to use this API, you may want a user to choose the value for\na particular option. This requires a user interface. Use the\nOpenScannerResponse\n(opened by\nopenScanner()\n) to retrieve the options for the attached\nscanner as described in the previous section.\nSome scanners group options in device-specific ways. They don't affect option\nbehaviors, but since these groups may be mentioned in a scanner's product\ndocumentation, such groups should be shown to the user. You can retrieve these\ngroups by calling getOptionGroups()\n. This returns a\nPromise that resolves with a\nGetOptionGroupsResponse\nobject. Its groups\nproperty contains a scanner-specific array of groups. Use the information in\nthese groups to organize the options in the\nOpenScannerResponse\nfor display.\n{\nscannerHandle: \"123456\",\nresult: SUCCESS,\ngroups: [\n{\ntitle: \"Standard\",\nmembers: [ \"resolution\", \"mode\", \"source\" ]\n}\n]\n}\nAs stated under Scanner configuration, changing one option can alter constraints\non another option. This is why\nsetOptionsResponse\n(the response object for\nsetOptions()\n) contains another options\nproperty. Use\nthis to update the user interface. Then repeat as needed until all options are\nset.\nSet scanner options\nSet scanner options by passing an array of\nOptionSetting\nobjects to\nsetOptions()\n. For an example, see the following Scan one letter-size page section.\nExamples\nRetrieve a page as a blob\nThis example shows one way to retrieve a page from the scanner as a blob and\ndemonstrates use of startScan()\nand readScanData()\nusing the value of\nOperationResult\n.\nasync function pageAsBlob(handle) {\nlet response = await chrome.documentScan.startScan(\nhandle, {format: \"image/jpeg\"});\nif (response.result != chrome.documentScan.OperationResult.SUCCESS) {\nreturn null;\n}\nconst job = response.job;\nlet imgParts = [];\nresponse = await chrome.documentScan.readScanData(job);\nwhile (response.result == chrome.documentScan.OperationResult.SUCCESS) {\nif (response.data && response.data.byteLength > 0) {\nimgParts.push(response.data);\n} else {\n// Delay so hardware can make progress.\nawait new Promise(r => setTimeout(r, 100));\n}\nresponse = await chrome.documentScan.readScanData(job);\n}\nif (response.result != chrome.documentScan.OperationResult.EOF) {\nreturn null;\n}\nif (response.data && response.data.byteLength > 0) {\nimgParts.push(response.data);\n}\nreturn new Blob(imgParts, { type: \"image/jpeg\" });\n}\nScan one letter-size page\nThis example shows how to select a scanner, set its options, and open it. It\nthen retrieves the contents of a single page and closes the scanner. This process\ndemonstrates using getScannerList()\n, openScanner()\n, setOptions()\n, and\ncloseScanner()\n. Note that the contents of the page are retrieved by calling\nthe pageAsBlob()\nfunction from the previous example.\nasync function scan() {\nlet response = await chrome.documentScan.getScannerList({ secure: true });\nlet scanner = await chrome.documentScan.openScanner(\nresponse.scanners[0].scannerId);\nconst handle = scanner.scannerHandle;\nlet options = [];\nfor (source of scanner.options[\"source\"].constraint.list) {\nif (source.includes(\"ADF\")) {\noptions.push({\nname: \"source\",\ntype: chrome.documentScan.OptionType.STRING,\nvalue: { value: source }\n});\nbreak;\n}\n}\noptions.push({\nname: \"tl-x\",\ntype: chrome.documentScan.OptionType.FIXED,\nvalue: 0.0\n});\noptions.push({\nname: \"br-x\",\ntype: chrome.documentScan.OptionType.FIXED,\nvalue: 215.9 // 8.5\" in mm\n});\noptions.push({\nname: \"tl-y\",\ntype: chrome.documentScan.OptionType.FIXED,\nvalue: 0.0\n});\noptions.push({\nname: \"br-y\",\ntype: chrome.documentScan.OptionType.FIXED,\nvalue: 279.4 // 11\" in mm\n});\nresponse = await chrome.documentScan.setOptions(handle, options);\nlet imgBlob = await pageAsBlob(handle);\nif (imgBlob != null) {\n// Insert imgBlob into DOM, save to disk, etc\n}\nawait chrome.documentScan.closeScanner(handle);\n}\nShow the configuration\nAs stated elsewhere, showing a scanner's configuration options to a user requires\ncalling getOptionGroups()\nin addition to the scanner options returned from a\ncall to openScanner()\n. This is so that options can be shown to users in\nmanufacturer-defined groups. This example shows how to do that.\nasync function showConfig() {\nlet response = await chrome.documentScan.getScannerList({ secure: true });\nlet scanner = await chrome.documentScan.openScanner(\nresponse.scanners[0].scannerId);\nlet groups = await chrome.documentScan.getOptionGroups(scanner.scannerHandle);\nfor (const group of groups.groups) {\nconsole.log(\"=== \" + group.title + \" ===\");\nfor (const member of group.members) {\nconst option = scanner.options[member];\nif (option.isActive) {\nconsole.log(\" \" + option.name + \" = \" + option.value);\n} else {\nconsole.log(\" \" + option.name + \" is inactive\");\n}\n}\n}\n}\nTypes\nCancelScanResponse\nProperties\n-\njob\nstring\nProvides the same job handle that was passed to\ncancelScan()\n. -\nresult\nThe backend's cancel scan result. If the result is\nOperationResult.SUCCESS\norOperationResult.CANCELLED\n, the scan has been cancelled and the scanner is ready to start a new scan. If the result isOperationResult.DEVICE_BUSY\n, the scanner is still processing the requested cancellation; the caller should wait a short time and try the request again. Other result values indicate a permanent error that should not be retried.\nCloseScannerResponse\nProperties\n-\nresult\nThe result of closing the scanner. Even if this value is not\nSUCCESS\n, the handle will be invalid and should not be used for any further operations. -\nscannerHandle\nstring\nThe same scanner handle as was passed to\ncloseScanner\n.\nConfigurability\nHow an option can be changed.\nEnum\n\"NOT_CONFIGURABLE\" \"SOFTWARE_CONFIGURABLE\" \"HARDWARE_CONFIGURABLE\"\nThe option is read-only.\nThe option can be set in software.\nThe option can be set by the user toggling or pushing a button on the scanner.\nConnectionType\nIndicates how the scanner is connected to the computer.\nEnum\n\"UNSPECIFIED\" \"USB\" \"NETWORK\"\nEnum\n\"INT_RANGE\" \"FIXED_RANGE\" \"INT_LIST\" \"FIXED_LIST\" \"STRING_LIST\"\nThe constraint on a range of OptionType.INT\nvalues. The min\n, max\n, and quant\nproperties of OptionConstraint\nwill be long\n, and its list\npropety will be unset.\nThe constraint on a range of OptionType.FIXED\nvalues. The min\n, max\n, and quant\nproperties of OptionConstraint\nwill be double\n, and its list\nproperty will be unset.\nThe constraint on a specific list of OptionType.INT\nvalues. The OptionConstraint.list\nproperty will contain long\nvalues, and the other properties will be unset.\nThe constraint on a specific list of OptionType.FIXED\nvalues. The OptionConstraint.list\nproperty will contain double\nvalues, and the other properties will be unset.\nThe constraint on a specific list of OptionType.STRING\nvalues. The OptionConstraint.list\nproperty will contain DOMString\nvalues, and the other properties will be unset.\nDeviceFilter\nProperties\n-\nlocal\nboolean optional\nOnly return scanners that are directly attached to the computer.\n-\nsecure\nboolean optional\nOnly return scanners that use a secure transport, such as USB or TLS.\nGetOptionGroupsResponse\nProperties\n-\ngroups\nOptionGroup[] optional\nIf\nresult\nisSUCCESS\n, provides a list of option groups in the order supplied by the scanner driver. -\nresult\nThe result of getting the option groups. If the value of this is\nSUCCESS\n, thegroups\nproperty will be populated. -\nscannerHandle\nstring\nThe same scanner handle as was passed to\ngetOptionGroups\n.\nGetScannerListResponse\nProperties\n-\nresult\nThe enumeration result. Note that partial results could be returned even if this indicates an error.\n-\nscanners\nA possibly-empty list of scanners that match the provided\nDeviceFilter\n.\nOpenScannerResponse\nProperties\n-\noptions\nobject optional\nIf\nresult\nisSUCCESS\n, provides a key-value mapping where the key is a device-specific option and the value is an instance ofScannerOption\n. -\nresult\nThe result of opening the scanner. If the value of this is\nSUCCESS\n, thescannerHandle\nandoptions\nproperties will be populated. -\nscannerHandle\nstring optional\nIf\nresult\nisSUCCESS\n, a handle to the scanner that can be used for further operations. -\nscannerId\nstring\nThe scanner ID passed to\nopenScanner()\n.\nOperationResult\nAn enum that indicates the result of each operation.\nEnum\n\"UNKNOWN\" \"SUCCESS\" \"UNSUPPORTED\" \"CANCELLED\" \"DEVICE_BUSY\" \"INVALID\" \"WRONG_TYPE\" \"EOF\" \"ADF_JAMMED\" \"ADF_EMPTY\" \"COVER_OPEN\" \"IO_ERROR\" \"ACCESS_DENIED\" \"NO_MEMORY\" \"UNREACHABLE\" \"MISSING\" \"INTERNAL_ERROR\"\nAn unknown or generic failure occurred.\nThe operation succeeded.\nThe operation is not supported.\nThe operation was cancelled.\nThe device is busy.\nEither the data or an argument passed to the method is not valid.\nThe supplied value is the wrong data type for the underlying option.\nNo more data is available.\nThe document feeder is jammed.\nThe document feeder is empty.\nThe flatbed cover is open.\nAn error occurred while communicating with the device.\nThe device requires authentication.\nNot enough memory is available on the Chromebook to complete the operation.\nThe device is not reachable.\nThe device is disconnected.\nAn error has occurred somewhere other than the calling application.\nOptionConstraint\nProperties\n-\nlist\nstring[] | number[] optional\n-\nmax\nnumber optional\n-\nmin\nnumber optional\n-\nquant\nnumber optional\n-\ntype\nOptionGroup\nProperties\n-\nmembers\nstring[]\nAn array of option names in driver-provided order.\n-\ntitle\nstring\nProvides a printable title, for example \"Geometry options\".\nOptionSetting\nProperties\n-\nname\nstring\nIndicates the name of the option to set.\n-\ntype\nIndicates the data type of the option. The requested data type must match the real data type of the underlying option.\n-\nvalue\nstring | number | boolean | number[] optional\nIndicates the value to set. Leave unset to request automatic setting for options that have\nautoSettable\nenabled. The data type supplied forvalue\nmust matchtype\n.\nOptionType\nThe data type of an option.\nEnum\n\"UNKNOWN\" \"BOOL\" \"INT\" \"FIXED\" \"STRING\" \"BUTTON\" \"GROUP\"\nThe option's data type is unknown. The value\nproperty will be unset.\nThe value\nproperty will be one of true\nfalse.\nA signed 32-bit integer. The value\nproperty will be long or long[], depending on whether the option takes more than one value.\nA double in the range -32768-32767.9999 with a resolution of 1/65535. The value\nproperty will be double or double[] depending on whether the option takes more than one value. Double values that can't be exactly represented will be rounded to the available range and precision.\nA sequence of any bytes except NUL ('\\0'). The value\nproperty will be a DOMString.\nAn option of this type has no value. Instead, setting an option of this type causes an option-specific side effect in the scanner driver. For example, a button-typed option could be used by a scanner driver to provide a means to select default values or to tell an automatic document feeder to advance to the next sheet of paper.\nGrouping option. No value. This is included for compatibility, but will not normally be returned in ScannerOption\nvalues. Use getOptionGroups()\nto retrieve the list of groups with their member options.\nEnum\n\"UNITLESS\" \"PIXEL\" \"BIT\" \"MM\" \"DPI\" \"PERCENT\" \"MICROSECOND\"\nThe value is a unitless number. For example, it can be a threshold.\nThe value is a number of pixels, for example, scan dimensions.\nThe value is the number of bits, for example, color depth.\nThe value is measured in millimeters, for example, scan dimensions.\nThe value is measured in dots per inch, for example, resolution.\nThe value is a percent, for example, brightness.\nThe value is measured in microseconds, for example, exposure time.\nReadScanDataResponse\nProperties\n-\ndata\nArrayBuffer optional\nIf\nresult\nisSUCCESS\n, contains the next chunk of scanned image data. Ifresult\nisEOF\n, contains the last chunk of scanned image data. -\nestimatedCompletion\nnumber optional\nIf\nresult\nisSUCCESS\n, an estimate of how much of the total scan data has been delivered so far, in the range 0 to 100. -\njob\nstring\nProvides the job handle passed to\nreadScanData()\n. -\nresult\nThe result of reading data. If its value is\nSUCCESS\n, thendata\ncontains the next (possibly zero-length) chunk of image data that is ready for reading. If its value isEOF\n, thedata\ncontains the last chunk of image data.\nScannerInfo\nProperties\n-\nconnectionType\nIndicates how the scanner is connected to the computer.\n-\ndeviceUuid\nstring\nFor matching against other\nScannerInfo\nentries that point to the same physical device. -\nimageFormats\nstring[]\nAn array of MIME types that can be requested for returned scans.\n-\nmanufacturer\nstring\nThe scanner manufacturer.\n-\nmodel\nstring\nThe scanner model if it is available, or a generic description.\n-\nname\nstring\nA human-readable name for the scanner to display in the UI.\n-\nprotocolType\nstring\nA human-readable description of the protocol or driver used to access the scanner, such as Mopria, WSD, or epsonds. This is primarily useful for allowing a user to choose between protocols if a device supports multiple protocols.\n-\nscannerId\nstring\nThe ID of a specific scanner.\n-\nsecure\nboolean\nIf true, the scanner connection's transport cannot be intercepted by a passive listener, such as TLS or USB.\nScannerOption\nProperties\n-\nconfigurability\nIndicates whether and how the option can be changed.\n-\nconstraint\nOptionConstraint optional\nDefines\nOptionConstraint\non the current scanner option. -\ndescription\nstring\nA longer description of the option.\n-\nisActive\nboolean\nIndicates the option is active and can be set or retrieved. If false, the\nvalue\nproperty will not be set. -\nisAdvanced\nboolean\nIndicates that the UI should not display this option by default.\n-\nisAutoSettable\nboolean\nCan be automatically set by the scanner driver.\n-\nisDetectable\nboolean\nIndicates that this option can be detected from software.\n-\nisEmulated\nboolean\nEmulated by the scanner driver if true.\n-\nname\nstring\nThe option name using lowercase ASCII letters, numbers, and dashes. Diacritics are not allowed.\n-\ntitle\nstring\nA printable one-line title.\n-\ntype\nThe data type contained in the\nvalue\nproperty, which is needed for setting this option. -\nunit\nThe unit of measurement for this option.\n-\nvalue\nstring | number | boolean | number[] optional\nThe current value of the option, if relevant. Note that the data type of this property must match the data type specified in\ntype\n.\nScanOptions\nProperties\n-\nmaxImages\nnumber optional\nThe number of scanned images allowed. The default is 1.\n-\nmimeTypes\nstring[] optional\nThe MIME types that are accepted by the caller.\nScanResults\nProperties\n-\ndataUrls\nstring[]\nAn array of data image URLs in a form that can be passed as the \"src\" value to an image tag.\n-\nmimeType\nstring\nThe MIME type of the\ndataUrls\n.\nSetOptionResult\nProperties\n-\nname\nstring\nIndicates the name of the option that was set.\n-\nresult\nIndicates the result of setting the option.\nSetOptionsResponse\nProperties\n-\noptions\nobject optional\nAn updated key-value mapping from option names to\nScannerOption\nvalues containing the new configuration after attempting to set all supplied options. This has the same structure as theoptions\nproperty inOpenScannerResponse\n.This property will be set even if some options were not set successfully, but will be unset if retrieving the updated configuration fails (for example, if the scanner is disconnected in the middle of scanning).\n-\nresults\nAn array of results, one each for every passed-in\nOptionSetting\n. -\nscannerHandle\nstring\nProvides the scanner handle passed to\nsetOptions()\n.\nStartScanOptions\nProperties\n-\nformat\nstring\nSpecifies the MIME type to return scanned data in.\n-\nmaxReadSize\nnumber optional\nIf a non-zero value is specified, limits the maximum scanned bytes returned in a single\nreadScanData\nresponse to that value. The smallest allowed value is 32768 (32 KB). If this property is not specified, the size of a returned chunk may be as large as the entire scanned image.\nStartScanResponse\nProperties\n-\njob\nstring optional\nIf\nresult\nisSUCCESS\n, provides a handle that can be used to read scan data or cancel the job. -\nresult\nThe result of starting a scan. If the value of this is\nSUCCESS\n, thejob\nproperty will be populated. -\nscannerHandle\nstring\nProvides the same scanner handle that was passed to\nstartScan()\n.\nMethods\ncancelScan()\nchrome.documentScan.cancelScan(\njob: string,\ncallback?: function,\n)\nCancels a started scan and returns a Promise that resolves with a CancelScanResponse\nobject. If a callback is used, the object is passed to it instead.\nParameters\n-\njob\nstring\nThe handle of an active scan job previously returned from a call to\nstartScan\n. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(response: CancelScanResponse) => void\n-\nresponse\n-\nReturns\n-\nPromise<CancelScanResponse>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ncloseScanner()\nchrome.documentScan.closeScanner(\nscannerHandle: string,\ncallback?: function,\n)\nCloses the scanner with the passed in handle and returns a Promise that resolves with a CloseScannerResponse\nobject. If a callback is used, the object is passed to it instead. Even if the response is not a success, the supplied handle becomes invalid and should not be used for further operations.\nParameters\n-\nscannerHandle\nstring\nSpecifies the handle of an open scanner that was previously returned from a call to\nopenScanner\n. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(response: CloseScannerResponse) => void\n-\nresponse\n-\nReturns\n-\nPromise<CloseScannerResponse>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetOptionGroups()\nchrome.documentScan.getOptionGroups(\nscannerHandle: string,\ncallback?: function,\n)\nGets the group names and member options from a scanner previously opened by openScanner\n. This method returns a Promise that resolves with a GetOptionGroupsResponse\nobject. If a callback is passed to this function, returned data is passed to it instead.\nParameters\n-\nscannerHandle\nstring\nThe handle of an open scanner returned from a call to\nopenScanner\n. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(response: GetOptionGroupsResponse) => void\n-\nresponse\n-\nReturns\n-\nPromise<GetOptionGroupsResponse>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetScannerList()\nchrome.documentScan.getScannerList(\nfilter: DeviceFilter,\ncallback?: function,\n)\nGets the list of available scanners and returns a Promise that resolves with a GetScannerListResponse\nobject. If a callback is passed to this function, returned data is passed to it instead.\nParameters\n-\nfilter\nA\nDeviceFilter\nindicating which types of scanners should be returned. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(response: GetScannerListResponse) => void\n-\nresponse\n-\nReturns\n-\nPromise<GetScannerListResponse>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nopenScanner()\nchrome.documentScan.openScanner(\nscannerId: string,\ncallback?: function,\n)\nOpens a scanner for exclusive access and returns a Promise that resolves with an OpenScannerResponse\nobject. If a callback is passed to this function, returned data is passed to it instead.\nParameters\n-\nscannerId\nstring\nThe ID of a scanner to be opened. This value is one returned from a previous call to\ngetScannerList\n. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(response: OpenScannerResponse) => void\n-\nresponse\n-\nReturns\n-\nPromise<OpenScannerResponse>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nreadScanData()\nchrome.documentScan.readScanData(\njob: string,\ncallback?: function,\n)\nReads the next chunk of available image data from an active job handle, and returns a Promise that resolves with a ReadScanDataResponse\nobject. If a callback is used, the object is passed to it instead.\n**Note:**It is valid for a response result to be SUCCESS\nwith a zero-length data\nmember. This means the scanner is still working but does not yet have additional data ready. The caller should wait a short time and try again.\nWhen the scan job completes, the response will have the result value of EOF\n. This response may contain a final non-zero data\nmember.\nParameters\n-\njob\nstring\nActive job handle previously returned from\nstartScan\n. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(response: ReadScanDataResponse) => void\n-\nresponse\n-\nReturns\n-\nPromise<ReadScanDataResponse>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nscan()\nchrome.documentScan.scan(\noptions: ScanOptions,\ncallback?: function,\n)\nPerforms a document scan and returns a Promise that resolves with a ScanResults\nobject. If a callback is passed to this function, the returned data is passed to it instead.\nParameters\n-\noptions\nAn object containing scan parameters.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: ScanResults) => void\n-\nresult\n-\nReturns\n-\nPromise<ScanResults>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetOptions()\nchrome.documentScan.setOptions(\nscannerHandle: string,\noptions: OptionSetting[],\ncallback?: function,\n)\nSets options on the specified scanner and returns a Promise that resolves with a SetOptionsResponse\nobject containing the result of trying to set every value in the order of the passed-in OptionSetting\nobject. If a callback is used, the object is passed to it instead.\nParameters\n-\nscannerHandle\nstring\nThe handle of the scanner to set options on. This should be a value previously returned from a call to\nopenScanner\n. -\noptions\nA list of\nOptionSetting\nobjects to be applied to the scanner. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(response: SetOptionsResponse) => void\n-\nresponse\n-\nReturns\n-\nPromise<SetOptionsResponse>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nstartScan()\nchrome.documentScan.startScan(\nscannerHandle: string,\noptions: StartScanOptions,\ncallback?: function,\n)\nStarts a scan on the specified scanner and returns a Promise that resolves with a StartScanResponse\n. If a callback is used, the object is passed to it instead. If the call was successful, the response includes a job handle that can be used in subsequent calls to read scan data or cancel a scan.\nParameters\n-\nscannerHandle\nstring\nThe handle of an open scanner. This should be a value previously returned from a call to\nopenScanner\n. -\noptions\nA\nStartScanOptions\nobject indicating the options to be used for the scan. TheStartScanOptions.format\nproperty must match one of the entries returned in the scanner'sScannerInfo\n. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(response: StartScanResponse) => void\n-\nresponse\n-\nReturns\n-\nPromise<StartScanResponse>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/dom", "title": "chrome.dom | API | Chrome for Developers", "text": "chrome.dom\nStay organized with collections\nSave and categorize content based on your preferences.\nDescription\nUse the chrome.dom\nAPI to access special DOM APIs for Extensions\nAvailability\nMethods\nopenOrClosedShadowRoot()\nchrome.dom.openOrClosedShadowRoot(\nelement: HTMLElement,\n)\nGets the open shadow root or the closed shadow root hosted by the specified element. If the element doesn't attach the shadow root, it will return null.\nExcept as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License, and code samples are licensed under the Apache 2.0 License. For details, see the Google Developers Site Policies. Java is a registered trademark of Oracle and/or its affiliates.\nLast updated 2024-05-24 UTC.\n[[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2024-05-24 UTC.\"],[],[]]"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/downloads", "title": "chrome.downloads | API | Chrome for Developers", "text": "Description\nUse the chrome.downloads\nAPI to programmatically initiate, monitor, manipulate, and search for downloads.\nPermissions\ndownloads\nYou must declare the \"downloads\"\npermission in the extension manifest to use this API.\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"downloads\"\n],\n}\nExamples\nYou can find simple examples of using the chrome.downloads\nAPI in the examples/api/downloads\ndirectory. For other examples and for help in viewing the source code, see Samples.\nTypes\nBooleanDelta\nProperties\n-\ncurrent\nboolean optional\n-\nprevious\nboolean optional\nDangerType\nfile\nThe download's filename is suspicious.\nurl\nThe download's URL is known to be malicious.\ncontent\nThe downloaded file is known to be malicious.\nuncommon\nThe download's URL is not commonly downloaded and could be dangerous.\nhost\nThe download came from a host known to distribute malicious binaries and is likely dangerous.\nunwanted\nThe download is potentially unwanted or unsafe. E.g. it could make changes to browser or computer settings.\nsafe\nThe download presents no known danger to the user's computer.\naccepted\nThe user has accepted the dangerous download.\nEnum\n\"file\" \"url\" \"content\" \"uncommon\" \"host\" \"unwanted\" \"safe\" \"accepted\" \"allowlistedByPolicy\" \"asyncScanning\" \"asyncLocalPasswordScanning\" \"passwordProtected\" \"blockedTooLarge\" \"sensitiveContentWarning\" \"sensitiveContentBlock\" \"deepScannedFailed\" \"deepScannedSafe\" \"deepScannedOpenedDangerous\" \"promptForScanning\" \"promptForLocalPasswordScanning\" \"accountCompromise\" \"blockedScanFailed\"\nDoubleDelta\nProperties\n-\ncurrent\nnumber optional\n-\nprevious\nnumber optional\nDownloadDelta\nProperties\n-\ncanResume\nBooleanDelta optional\nThe change in\ncanResume\n, if any. -\ndanger\nStringDelta optional\nThe change in\ndanger\n, if any. -\nendTime\nStringDelta optional\nThe change in\nendTime\n, if any. -\nerror\nStringDelta optional\nThe change in\nerror\n, if any. -\nexists\nBooleanDelta optional\nThe change in\nexists\n, if any. -\nfileSize\nDoubleDelta optional\nThe change in\nfileSize\n, if any. -\nfilename\nStringDelta optional\nThe change in\nfilename\n, if any. -\nfinalUrl\nStringDelta optional\nChrome 54+The change in\nfinalUrl\n, if any. -\nid\nnumber\nThe\nid\nof theDownloadItem\nthat changed. -\nmime\nStringDelta optional\nThe change in\nmime\n, if any. -\npaused\nBooleanDelta optional\nThe change in\npaused\n, if any. -\nstartTime\nStringDelta optional\nThe change in\nstartTime\n, if any. -\nstate\nStringDelta optional\nThe change in\nstate\n, if any. -\ntotalBytes\nDoubleDelta optional\nThe change in\ntotalBytes\n, if any. -\nurl\nStringDelta optional\nThe change in\nurl\n, if any.\nDownloadItem\nProperties\n-\nbyExtensionId\nstring optional\nThe identifier for the extension that initiated this download if this download was initiated by an extension. Does not change once it is set.\n-\nbyExtensionName\nstring optional\nThe localized name of the extension that initiated this download if this download was initiated by an extension. May change if the extension changes its name or if the user changes their locale.\n-\nbytesReceived\nnumber\nNumber of bytes received so far from the host, without considering file compression.\n-\ncanResume\nboolean\nTrue if the download is in progress and paused, or else if it is interrupted and can be resumed starting from where it was interrupted.\n-\ndanger\nIndication of whether this download is thought to be safe or known to be suspicious.\n-\nendTime\nstring optional\nThe time when the download ended in ISO 8601 format. May be passed directly to the Date constructor:\nchrome.downloads.search({}, function(items){items.forEach(function(item){if (item.endTime) console.log(new Date(item.endTime))})})\n-\nerror\nInterruptReason optional\nWhy the download was interrupted. Several kinds of HTTP errors may be grouped under one of the errors beginning with\nSERVER_\n. Errors relating to the network begin withNETWORK_\n, errors relating to the process of writing the file to the file system begin withFILE_\n, and interruptions initiated by the user begin withUSER_\n. -\nestimatedEndTime\nstring optional\nEstimated time when the download will complete in ISO 8601 format. May be passed directly to the Date constructor:\nchrome.downloads.search({}, function(items){items.forEach(function(item){if (item.estimatedEndTime) console.log(new Date(item.estimatedEndTime))})})\n-\nexists\nboolean\nWhether the downloaded file still exists. This information may be out of date because Chrome does not automatically watch for file removal. Call\nsearch\n() in order to trigger the check for file existence. When the existence check completes, if the file has been deleted, then anonChanged\nevent will fire. Note thatsearch\n() does not wait for the existence check to finish before returning, so results fromsearch\n() may not accurately reflect the file system. Also,search\n() may be called as often as necessary, but will not check for file existence any more frequently than once every 10 seconds. -\nfileSize\nnumber\nNumber of bytes in the whole file post-decompression, or -1 if unknown.\n-\nfilename\nstring\nAbsolute local path.\n-\nfinalUrl\nstring\nChrome 54+The absolute URL that this download is being made from, after all redirects.\n-\nid\nnumber\nAn identifier that is persistent across browser sessions.\n-\nincognito\nboolean\nFalse if this download is recorded in the history, true if it is not recorded.\n-\nmime\nstring\nThe file's MIME type.\n-\npaused\nboolean\nTrue if the download has stopped reading data from the host, but kept the connection open.\n-\nreferrer\nstring\nAbsolute URL.\n-\nstartTime\nstring\nThe time when the download began in ISO 8601 format. May be passed directly to the Date constructor:\nchrome.downloads.search({}, function(items){items.forEach(function(item){console.log(new Date(item.startTime))})})\n-\nstate\nIndicates whether the download is progressing, interrupted, or complete.\n-\ntotalBytes\nnumber\nNumber of bytes in the whole file, without considering file compression, or -1 if unknown.\n-\nurl\nstring\nThe absolute URL that this download initiated from, before any redirects.\nDownloadOptions\nProperties\n-\nbody\nstring optional\nPost body.\n-\nconflictAction\nFilenameConflictAction optional\nThe action to take if\nfilename\nalready exists. -\nfilename\nstring optional\nA file path relative to the Downloads directory to contain the downloaded file, possibly containing subdirectories. Absolute paths, empty paths, and paths containing back-references \"..\" will cause an error.\nonDeterminingFilename\nallows suggesting a filename after the file's MIME type and a tentative filename have been determined. -\nheaders\nHeaderNameValuePair[] optional\nExtra HTTP headers to send with the request if the URL uses the HTTP[s] protocol. Each header is represented as a dictionary containing the keys\nname\nand eithervalue\norbinaryValue\n, restricted to those allowed by XMLHttpRequest. -\nmethod\nHttpMethod optional\nThe HTTP method to use if the URL uses the HTTP[S] protocol.\n-\nsaveAs\nboolean optional\nUse a file-chooser to allow the user to select a filename regardless of whether\nfilename\nis set or already exists. -\nurl\nstring\nThe URL to download.\nDownloadQuery\nProperties\n-\nbytesReceived\nnumber optional\nNumber of bytes received so far from the host, without considering file compression.\n-\ndanger\nDangerType optional\nIndication of whether this download is thought to be safe or known to be suspicious.\n-\nendTime\nstring optional\nThe time when the download ended in ISO 8601 format.\n-\nendedAfter\nstring optional\nLimits results to\nDownloadItem\nthat ended after the given ms in ISO 8601 format -\nendedBefore\nstring optional\nLimits results to\nDownloadItem\nthat ended before the given ms in ISO 8601 format. -\nerror\nInterruptReason optional\nWhy a download was interrupted.\n-\nexists\nboolean optional\nWhether the downloaded file exists;\n-\nfileSize\nnumber optional\nNumber of bytes in the whole file post-decompression, or -1 if unknown.\n-\nfilename\nstring optional\nAbsolute local path.\n-\nfilenameRegex\nstring optional\nLimits results to\nDownloadItem\nwhosefilename\nmatches the given regular expression. -\nfinalUrl\nstring optional\nChrome 54+The absolute URL that this download is being made from, after all redirects.\n-\nfinalUrlRegex\nstring optional\nChrome 54+Limits results to\nDownloadItem\nwhosefinalUrl\nmatches the given regular expression. -\nid\nnumber optional\nThe\nid\nof theDownloadItem\nto query. -\nlimit\nnumber optional\nThe maximum number of matching\nDownloadItem\nreturned. Defaults to 1000. Set to 0 in order to return all matchingDownloadItem\n. Seesearch\nfor how to page through results. -\nmime\nstring optional\nThe file's MIME type.\n-\norderBy\nstring[] optional\nSet elements of this array to\nDownloadItem\nproperties in order to sort search results. For example, settingorderBy=['startTime']\nsorts theDownloadItem\nby their start time in ascending order. To specify descending order, prefix with a hyphen: '-startTime'. -\npaused\nboolean optional\nTrue if the download has stopped reading data from the host, but kept the connection open.\n-\nquery\nstring[] optional\nThis array of search terms limits results to\nDownloadItem\nwhosefilename\norurl\norfinalUrl\ncontain all of the search terms that do not begin with a dash '-' and none of the search terms that do begin with a dash. -\nstartTime\nstring optional\nThe time when the download began in ISO 8601 format.\n-\nstartedAfter\nstring optional\nLimits results to\nDownloadItem\nthat started after the given ms in ISO 8601 format. -\nstartedBefore\nstring optional\nLimits results to\nDownloadItem\nthat started before the given ms in ISO 8601 format. -\nstate\nState optional\nIndicates whether the download is progressing, interrupted, or complete.\n-\ntotalBytes\nnumber optional\nNumber of bytes in the whole file, without considering file compression, or -1 if unknown.\n-\ntotalBytesGreater\nnumber optional\nLimits results to\nDownloadItem\nwhosetotalBytes\nis greater than the given integer. -\ntotalBytesLess\nnumber optional\nLimits results to\nDownloadItem\nwhosetotalBytes\nis less than the given integer. -\nurl\nstring optional\nThe absolute URL that this download initiated from, before any redirects.\n-\nurlRegex\nstring optional\nLimits results to\nDownloadItem\nwhoseurl\nmatches the given regular expression.\nFilenameConflictAction\nuniquify\nTo avoid duplication, the filename\nis changed to include a counter before the filename extension.\noverwrite\nThe existing file will be overwritten with the new file.\nprompt\nThe user will be prompted with a file chooser dialog.\nEnum\n\"uniquify\" \"overwrite\" \"prompt\"\nFilenameSuggestion\nProperties\n-\nconflictAction\nFilenameConflictAction optional\nThe action to take if\nfilename\nalready exists. -\nfilename\nstring\nThe\nDownloadItem\n's new targetDownloadItem.filename\n, as a path relative to the user's default Downloads directory, possibly containing subdirectories. Absolute paths, empty paths, and paths containing back-references \"..\" will be ignored.filename\nis ignored if there are anyonDeterminingFilename\nlisteners registered by any extensions.\nGetFileIconOptions\nProperties\n-\nsize\nnumber optional\nThe size of the returned icon. The icon will be square with dimensions size * size pixels. The default and largest size for the icon is 32x32 pixels. The only supported sizes are 16 and 32. It is an error to specify any other size.\nHeaderNameValuePair\nProperties\n-\nname\nstring\nName of the HTTP header.\n-\nvalue\nstring\nValue of the HTTP header.\nHttpMethod\nEnum\n\"GET\" \"POST\"\nInterruptReason\nEnum\n\"FILE_FAILED\" \"FILE_ACCESS_DENIED\" \"FILE_NO_SPACE\" \"FILE_NAME_TOO_LONG\" \"FILE_TOO_LARGE\" \"FILE_VIRUS_INFECTED\" \"FILE_TRANSIENT_ERROR\" \"FILE_BLOCKED\" \"FILE_SECURITY_CHECK_FAILED\" \"FILE_TOO_SHORT\" \"FILE_HASH_MISMATCH\" \"FILE_SAME_AS_SOURCE\" \"NETWORK_FAILED\" \"NETWORK_TIMEOUT\" \"NETWORK_DISCONNECTED\" \"NETWORK_SERVER_DOWN\" \"NETWORK_INVALID_REQUEST\" \"SERVER_FAILED\" \"SERVER_NO_RANGE\" \"SERVER_BAD_CONTENT\" \"SERVER_UNAUTHORIZED\" \"SERVER_CERT_PROBLEM\" \"SERVER_FORBIDDEN\" \"SERVER_UNREACHABLE\" \"SERVER_CONTENT_LENGTH_MISMATCH\" \"SERVER_CROSS_ORIGIN_REDIRECT\" \"USER_CANCELED\" \"USER_SHUTDOWN\" \"CRASH\"\nState\nin_progress\nThe download is currently receiving data from the server.\ninterrupted\nAn error broke the connection with the file host.\ncomplete\nThe download completed successfully.\nEnum\n\"in_progress\" \"interrupted\" \"complete\"\nStringDelta\nProperties\n-\ncurrent\nstring optional\n-\nprevious\nstring optional\nUiOptions\nProperties\n-\nenabled\nboolean\nEnable or disable the download UI.\nMethods\nacceptDanger()\nchrome.downloads.acceptDanger(\ndownloadId: number,\ncallback?: function,\n)\nPrompt the user to accept a dangerous download. Can only be called from a visible context (tab, window, or page/browser action popup). Does not automatically accept dangerous downloads. If the download is accepted, then an onChanged\nevent will fire, otherwise nothing will happen. When all the data is fetched into a temporary file and either the download is not dangerous or the danger has been accepted, then the temporary file is renamed to the target filename, the state\nchanges to 'complete', and onChanged\nfires.\nParameters\n-\ndownloadId\nnumber\nThe identifier for the\nDownloadItem\n. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ncancel()\nchrome.downloads.cancel(\ndownloadId: number,\ncallback?: function,\n)\nCancel a download. When callback\nis run, the download is cancelled, completed, interrupted or doesn't exist anymore.\nParameters\n-\ndownloadId\nnumber\nThe id of the download to cancel.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ndownload()\nchrome.downloads.download(\noptions: DownloadOptions,\ncallback?: function,\n)\nDownload a URL. If the URL uses the HTTP[S] protocol, then the request will include all cookies currently set for its hostname. If both filename\nand saveAs\nare specified, then the Save As dialog will be displayed, pre-populated with the specified filename\n. If the download started successfully, callback\nwill be called with the new DownloadItem\n's downloadId\n. If there was an error starting the download, then callback\nwill be called with downloadId=undefined\nand runtime.lastError\nwill contain a descriptive string. The error strings are not guaranteed to remain backwards compatible between releases. Extensions must not parse it.\nParameters\n-\noptions\nWhat to download and how.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(downloadId: number) => void\n-\ndownloadId\nnumber\n-\nReturns\n-\nPromise<number>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nerase()\nchrome.downloads.erase(\nquery: DownloadQuery,\ncallback?: function,\n)\nErase matching DownloadItem\nfrom history without deleting the downloaded file. An onErased\nevent will fire for each DownloadItem\nthat matches query\n, then callback\nwill be called.\nParameters\n-\nquery\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(erasedIds: number[]) => void\n-\nerasedIds\nnumber[]\n-\nReturns\n-\nPromise<number[]>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetFileIcon()\nchrome.downloads.getFileIcon(\ndownloadId: number,\noptions?: GetFileIconOptions,\ncallback?: function,\n)\nRetrieve an icon for the specified download. For new downloads, file icons are available after the onCreated\nevent has been received. The image returned by this function while a download is in progress may be different from the image returned after the download is complete. Icon retrieval is done by querying the underlying operating system or toolkit depending on the platform. The icon that is returned will therefore depend on a number of factors including state of the download, platform, registered file types and visual theme. If a file icon cannot be determined, runtime.lastError\nwill contain an error message.\nParameters\n-\ndownloadId\nnumber\nThe identifier for the download.\n-\noptions\nGetFileIconOptions optional\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(iconURL?: string) => void\n-\niconURL\nstring optional\n-\nReturns\n-\nPromise<string | undefined>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nopen()\nchrome.downloads.open(\ndownloadId: number,\ncallback?: function,\n)\nOpens the downloaded file now if the DownloadItem\nis complete; otherwise returns an error through runtime.lastError\n. This method requires the \"downloads.open\"\npermission in addition to the \"downloads\"\npermission. An onChanged\nevent fires when the item is opened for the first time. This method can only be called in response to a user gesture.\nParameters\n-\ndownloadId\nnumber\nThe identifier for the downloaded file.\n-\ncallback\nfunction optional\nChrome 123+The\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 123+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\npause()\nchrome.downloads.pause(\ndownloadId: number,\ncallback?: function,\n)\nPause the download. If the request was successful the download is in a paused state. Otherwise runtime.lastError\ncontains an error message. The request will fail if the download is not active.\nParameters\n-\ndownloadId\nnumber\nThe id of the download to pause.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveFile()\nchrome.downloads.removeFile(\ndownloadId: number,\ncallback?: function,\n)\nRemove the downloaded file if it exists and the DownloadItem\nis complete; otherwise return an error through runtime.lastError\n.\nParameters\n-\ndownloadId\nnumber\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nresume()\nchrome.downloads.resume(\ndownloadId: number,\ncallback?: function,\n)\nResume a paused download. If the request was successful the download is in progress and unpaused. Otherwise runtime.lastError\ncontains an error message. The request will fail if the download is not active.\nParameters\n-\ndownloadId\nnumber\nThe id of the download to resume.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsearch()\nchrome.downloads.search(\nquery: DownloadQuery,\ncallback?: function,\n)\nFind DownloadItem\n. Set query\nto the empty object to get all DownloadItem\n. To get a specific DownloadItem\n, set only the id\nfield. To page through a large number of items, set orderBy: ['-startTime']\n, set limit\nto the number of items per page, and set startedAfter\nto the startTime\nof the last item from the last page.\nParameters\n-\nquery\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(results: DownloadItem[]) => void\n-\nresults\n-\nReturns\n-\nPromise<DownloadItem[]>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetShelfEnabled()\nchrome.downloads.setShelfEnabled(\nenabled: boolean,\n)\nUse setUiOptions\ninstead.\nEnable or disable the gray shelf at the bottom of every window associated with the current browser profile. The shelf will be disabled as long as at least one extension has disabled it. Enabling the shelf while at least one other extension has disabled it will return an error through runtime.lastError\n. Requires the \"downloads.shelf\"\npermission in addition to the \"downloads\"\npermission.\nParameters\n-\nenabled\nboolean\nsetUiOptions()\nchrome.downloads.setUiOptions(\noptions: UiOptions,\ncallback?: function,\n)\nChange the download UI of every window associated with the current browser profile. As long as at least one extension has set UiOptions.enabled\nto false, the download UI will be hidden. Setting UiOptions.enabled\nto true while at least one other extension has disabled it will return an error through runtime.lastError\n. Requires the \"downloads.ui\"\npermission in addition to the \"downloads\"\npermission.\nParameters\n-\noptions\nEncapsulate a change to the download UI.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nshow()\nchrome.downloads.show(\ndownloadId: number,\n)\nShow the downloaded file in its folder in a file manager.\nParameters\n-\ndownloadId\nnumber\nThe identifier for the downloaded file.\nshowDefaultFolder()\nchrome.downloads.showDefaultFolder()\nShow the default Downloads folder in a file manager.\nEvents\nonChanged\nchrome.downloads.onChanged.addListener(\ncallback: function,\n)\nWhen any of a DownloadItem\n's properties except bytesReceived\nand estimatedEndTime\nchanges, this event fires with the downloadId\nand an object containing the properties that changed.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(downloadDelta: DownloadDelta) => void\n-\ndownloadDelta\n-\nonCreated\nchrome.downloads.onCreated.addListener(\ncallback: function,\n)\nThis event fires with the DownloadItem\nobject when a download begins.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(downloadItem: DownloadItem) => void\n-\ndownloadItem\n-\nonDeterminingFilename\nchrome.downloads.onDeterminingFilename.addListener(\ncallback: function,\n)\nDuring the filename determination process, extensions will be given the opportunity to override the target DownloadItem.filename\n. Each extension may not register more than one listener for this event. Each listener must call suggest\nexactly once, either synchronously or asynchronously. If the listener calls suggest\nasynchronously, then it must return true\n. If the listener neither calls suggest\nsynchronously nor returns true\n, then suggest\nwill be called automatically. The DownloadItem\nwill not complete until all listeners have called suggest\n. Listeners may call suggest\nwithout any arguments in order to allow the download to use downloadItem.filename\nfor its filename, or pass a suggestion\nobject to suggest\nin order to override the target filename. If more than one extension overrides the filename, then the last extension installed whose listener passes a suggestion\nobject to suggest\nwins. In order to avoid confusion regarding which extension will win, users should not install extensions that may conflict. If the download is initiated by download\nand the target filename is known before the MIME type and tentative filename have been determined, pass filename\nto download\ninstead.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(downloadItem: DownloadItem, suggest: function) => void\n-\ndownloadItem\n-\nsuggest\nfunction\nThe\nsuggest\nparameter looks like:(suggestion?: FilenameSuggestion) => void\n-\nsuggestion\nFilenameSuggestion optional\n-\n-\nonErased\nchrome.downloads.onErased.addListener(\ncallback: function,\n)\nFires with the downloadId\nwhen a download is erased from history.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(downloadId: number) => void\n-\ndownloadId\nnumber\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/enterprise/deviceAttributes", "title": "chrome.enterprise.deviceAttributes | API | Chrome for Developers", "text": "Description\nUse the chrome.enterprise.deviceAttributes\nAPI to read device attributes. Note: This API is only available to extensions force-installed by enterprise policy.\nPermissions\nenterprise.deviceAttributes\nAvailability\nMethods\ngetDeviceAnnotatedLocation()\nchrome.enterprise.deviceAttributes.getDeviceAnnotatedLocation(\ncallback?: function,\n)\nFetches the administrator-annotated Location. If the current user is not affiliated or no Annotated Location has been set by the administrator, returns an empty string.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(annotatedLocation: string) => void\n-\nannotatedLocation\nstring\n-\nReturns\n-\nPromise<string>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetDeviceAssetId()\nchrome.enterprise.deviceAttributes.getDeviceAssetId(\ncallback?: function,\n)\nFetches the administrator-annotated Asset Id. If the current user is not affiliated or no Asset Id has been set by the administrator, returns an empty string.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(assetId: string) => void\n-\nassetId\nstring\n-\nReturns\n-\nPromise<string>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetDeviceHostname()\nchrome.enterprise.deviceAttributes.getDeviceHostname(\ncallback?: function,\n)\nFetches the device's hostname as set by DeviceHostnameTemplate policy. If the current user is not affiliated or no hostname has been set by the enterprise policy, returns an empty string.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(hostname: string) => void\n-\nhostname\nstring\n-\nReturns\n-\nPromise<string>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetDeviceSerialNumber()\nchrome.enterprise.deviceAttributes.getDeviceSerialNumber(\ncallback?: function,\n)\nFetches the device's serial number. Please note the purpose of this API is to administrate the device (e.g. generating Certificate Sign Requests for device-wide certificates). This API may not be used for tracking devices without the consent of the device's administrator. If the current user is not affiliated, returns an empty string.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(serialNumber: string) => void\n-\nserialNumber\nstring\n-\nReturns\n-\nPromise<string>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetDirectoryDeviceId()\nchrome.enterprise.deviceAttributes.getDirectoryDeviceId(\ncallback?: function,\n)\nFetches the value of the device identifier of the directory API, that is generated by the server and identifies the cloud record of the device for querying in the cloud directory API. If the current user is not affiliated, returns an empty string.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(deviceId: string) => void\n-\ndeviceId\nstring\n-\nReturns\n-\nPromise<string>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/enterprise/hardwarePlatform", "title": "chrome.enterprise.hardwarePlatform | API | Chrome for Developers", "text": "Description\nUse the chrome.enterprise.hardwarePlatform\nAPI to get the manufacturer and model of the hardware platform where the browser runs. Note: This API is only available to extensions installed by enterprise policy.\nPermissions\nenterprise.hardwarePlatform\nAvailability\nTypes\nHardwarePlatformInfo\nProperties\n-\nmanufacturer\nstring\n-\nmodel\nstring\nMethods\ngetHardwarePlatformInfo()\nchrome.enterprise.hardwarePlatform.getHardwarePlatformInfo(\ncallback?: function,\n)\nObtains the manufacturer and model for the hardware platform and, if the extension is authorized, returns it via callback\n.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(info: HardwarePlatformInfo) => void\n-\ninfo\n-\nReturns\n-\nPromise<HardwarePlatformInfo>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/enterprise/networkingAttributes", "title": "chrome.enterprise.networkingAttributes | API | Chrome for Developers", "text": "Description\nUse the chrome.enterprise.networkingAttributes\nAPI to read information about your current network. Note: This API is only available to extensions force-installed by enterprise policy.\nPermissions\nenterprise.networkingAttributes\nAvailability\nTypes\nNetworkDetails\nProperties\n-\nipv4\nstring optional\nThe device's local IPv4 address (undefined if not configured).\n-\nipv6\nstring optional\nThe device's local IPv6 address (undefined if not configured).\n-\nmacAddress\nstring\nThe device's MAC address.\nMethods\ngetNetworkDetails()\nchrome.enterprise.networkingAttributes.getNetworkDetails(\ncallback?: function,\n)\nRetrieves the network details of the device's default network. If the user is not affiliated or the device is not connected to a network, runtime.lastError\nwill be set with a failure reason.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(networkAddresses: NetworkDetails) => void\n-\nnetworkAddresses\n-\nReturns\n-\nPromise<NetworkDetails>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/enterprise/platformKeys", "title": "chrome.enterprise.platformKeys | API | Chrome for Developers", "text": "Description\nUse the chrome.enterprise.platformKeys\nAPI to generate keys and install certificates for these keys. The certificates will be managed by the platform and can be used for TLS authentication, network access or by other extension through chrome.platformKeys.\nPermissions\nenterprise.platformKeys\nAvailability\nConcepts and usage\nTypical usage of this API to enroll a client certificate follows these steps:\nGet all available tokens using\nenterprise.platformKeys.getTokens()\n.Find the Token with\nid\nequal to\"user\"\n. Use this Token subsequently.Generate a key pair using the\ngenerateKey()\nToken method (defined in SubtleCrypto). This will return handle to the key.Export the public key using the\nexportKey()\nToken method (defined in SubtleCrypto).Create the signature of the certification request's data using the\nsign()\nToken method (defined in SubtleCrypto).Complete the certification request and send it to the certification authority.\nIf a certificate is received, import it using [\nenterprise.platformKeys.importCertificate()\n`[3]\nHere's an example that shows the major API interaction except the building and sending of the certification request:\nfunction getUserToken(callback) {\nchrome.enterprise.platformKeys.getTokens(function(tokens) {\nfor (var i = 0; i < tokens.length; i++) {\nif (tokens[i].id == \"user\") {\ncallback(tokens[i]);\nreturn;\n}\n}\ncallback(undefined);\n});\n}\nfunction generateAndSign(userToken) {\nvar data = new Uint8Array([0, 5, 1, 2, 3, 4, 5, 6]);\nvar algorithm = {\nname: \"RSASSA-PKCS1-v1_5\",\n// RsaHashedKeyGenParams\nmodulusLength: 2048,\npublicExponent:\nnew Uint8Array([0x01, 0x00, 0x01]), // Equivalent to 65537\nhash: {\nname: \"SHA-256\",\n}\n};\nvar cachedKeyPair;\nuserToken.subtleCrypto.generateKey(algorithm, false, [\"sign\"])\n.then(function(keyPair) {\ncachedKeyPair = keyPair;\nreturn userToken.subtleCrypto.exportKey(\"spki\", keyPair.publicKey);\n},\nconsole.log.bind(console))\n.then(function(publicKeySpki) {\n// Build the Certification Request using the public key.\nreturn userToken.subtleCrypto.sign(\n{name : \"RSASSA-PKCS1-v1_5\"}, cachedKeyPair.privateKey, data);\n},\nconsole.log.bind(console))\n.then(function(signature) {\n// Complete the Certification Request with |signature|.\n// Send out the request to the CA, calling back\n// onClientCertificateReceived.\n},\nconsole.log.bind(console));\n}\nfunction onClientCertificateReceived(userToken, certificate) {\nchrome.enterprise.platformKeys.importCertificate(userToken.id, certificate);\n}\ngetUserToken(generateAndSign);\nTypes\nAlgorithm\nType of key to generate.\nEnum\n\"RSA\" \"ECDSA\"\nChallengeKeyOptions\nProperties\n-\nchallenge\nArrayBuffer\nA challenge as emitted by the Verified Access Web API.\n-\nregisterKey\nRegisterKeyOptions optional\nIf present, registers the challenged key with the specified\nscope\n's token. The key can then be associated with a certificate and used like any other signing key. Subsequent calls to this function will then generate a new Enterprise Key in the specifiedscope\n. -\nscope\nWhich Enterprise Key to challenge.\nRegisterKeyOptions\nProperties\n-\nalgorithm\nWhich algorithm the registered key should use.\nScope\nWhether to use the Enterprise User Key or the Enterprise Machine Key.\nEnum\n\"USER\" \"MACHINE\"\nToken\nProperties\n-\nid\nstring\nUniquely identifies this\nToken\n.Static IDs are\n\"user\"\nand\"system\"\n, referring to the platform's user-specific and the system-wide hardware token, respectively. Any other tokens (with other identifiers) might be returned byenterprise.platformKeys.getTokens\n. -\nsoftwareBackedSubtleCrypto\nSubtleCrypto\nChrome 97+Implements the WebCrypto's SubtleCrypto interface. The cryptographic operations, including key generation, are software-backed. Protection of the keys, and thus implementation of the non-extractable property, is done in software, so the keys are less protected than hardware-backed keys.\nOnly non-extractable keys can be generated. The supported key types are RSASSA-PKCS1-V1_5 and RSA-OAEP (on Chrome versions 134+) with\nmodulusLength\nup to 2048. Each RSASSA-PKCS1-V1_5 key can be used for signing data at most once, unless the extension is allowlisted through the KeyPermissions policy, in which case the key can be used indefinitely. RSA-OAEP keys are supported since Chrome version 134 and can be used by extensions allowlisted through that same policy to unwrap other keys.Keys generated on a specific\nToken\ncannot be used with any other Tokens, nor can they be used withwindow.crypto.subtle\n. Equally,Key\nobjects created withwindow.crypto.subtle\ncannot be used with this interface. -\nsubtleCrypto\nSubtleCrypto\nImplements the WebCrypto's SubtleCrypto interface. The cryptographic operations, including key generation, are hardware-backed.\nOnly non-extractable keys can be generated. The supported key types are RSASSA-PKCS1-V1_5 and RSA-OAEP (on Chrome versions 134+) with\nmodulusLength\nup to 2048 and ECDSA withnamedCurve\nP-256. Each RSASSA-PKCS1-V1_5 and ECDSA key can be used for signing data at most once, unless the extension is allowlisted through the KeyPermissions policy, in which case the key can be used indefinitely. RSA-OAEP keys are supported since Chrome version 134 and can be used by extensions allowlisted through that same policy to unwrap other keys.Keys generated on a specific\nToken\ncannot be used with any other Tokens, nor can they be used withwindow.crypto.subtle\n. Equally,Key\nobjects created withwindow.crypto.subtle\ncannot be used with this interface.\nMethods\nchallengeKey()\nchrome.enterprise.platformKeys.challengeKey(\noptions: ChallengeKeyOptions,\ncallback?: function,\n)\nSimilar to challengeMachineKey\nand challengeUserKey\n, but allows specifying the algorithm of a registered key. Challenges a hardware-backed Enterprise Machine Key and emits the response as part of a remote attestation protocol. Only useful on ChromeOS and in conjunction with the Verified Access Web API which both issues challenges and verifies responses.\nA successful verification by the Verified Access Web API is a strong signal that the current device is a legitimate ChromeOS device, the current device is managed by the domain specified during verification, the current signed-in user is managed by the domain specified during verification, and the current device state complies with enterprise device policy. For example, a policy may specify that the device must not be in developer mode. Any device identity emitted by the verification is tightly bound to the hardware of the current device. If \"user\"\nScope is specified, the identity is also tightly bound to the current signed-in user.\nThis function is highly restricted and will fail if the current device is not managed, the current user is not managed, or if this operation has not explicitly been enabled for the caller by enterprise device policy. The challenged key does not reside in the \"system\"\nor \"user\"\ntoken and is not accessible by any other API.\nParameters\n-\noptions\nObject containing the fields defined in\nChallengeKeyOptions\n. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(response: ArrayBuffer) => void\n-\nresponse\nArrayBuffer\nThe challenge response.\n-\nReturns\n-\nPromise<ArrayBuffer>\nChrome 131+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nchallengeMachineKey()\nchrome.enterprise.platformKeys.challengeMachineKey(\nchallenge: ArrayBuffer,\nregisterKey?: boolean,\ncallback?: function,\n)\nUse challengeKey\ninstead.\nChallenges a hardware-backed Enterprise Machine Key and emits the response as part of a remote attestation protocol. Only useful on ChromeOS and in conjunction with the Verified Access Web API which both issues challenges and verifies responses. A successful verification by the Verified Access Web API is a strong signal of all of the following: * The current device is a legitimate ChromeOS device. * The current device is managed by the domain specified during verification. * The current signed-in user is managed by the domain specified during verification. * The current device state complies with enterprise device policy. For example, a policy may specify that the device must not be in developer mode. * Any device identity emitted by the verification is tightly bound to the hardware of the current device. This function is highly restricted and will fail if the current device is not managed, the current user is not managed, or if this operation has not explicitly been enabled for the caller by enterprise device policy. The Enterprise Machine Key does not reside in the \"system\"\ntoken and is not accessible by any other API.\nParameters\n-\nchallenge\nArrayBuffer\nA challenge as emitted by the Verified Access Web API.\n-\nregisterKey\nboolean optional\nChrome 59+If set, the current Enterprise Machine Key is registered with the\n\"system\"\ntoken and relinquishes the Enterprise Machine Key role. The key can then be associated with a certificate and used like any other signing key. This key is 2048-bit RSA. Subsequent calls to this function will then generate a new Enterprise Machine Key. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(response: ArrayBuffer) => void\n-\nresponse\nArrayBuffer\nThe challenge response.\n-\nReturns\n-\nPromise<ArrayBuffer>\nChrome 131+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nchallengeUserKey()\nchrome.enterprise.platformKeys.challengeUserKey(\nchallenge: ArrayBuffer,\nregisterKey: boolean,\ncallback?: function,\n)\nUse challengeKey\ninstead.\nChallenges a hardware-backed Enterprise User Key and emits the response as part of a remote attestation protocol. Only useful on ChromeOS and in conjunction with the Verified Access Web API which both issues challenges and verifies responses. A successful verification by the Verified Access Web API is a strong signal of all of the following: * The current device is a legitimate ChromeOS device. * The current device is managed by the domain specified during verification. * The current signed-in user is managed by the domain specified during verification. * The current device state complies with enterprise user policy. For example, a policy may specify that the device must not be in developer mode. * The public key emitted by the verification is tightly bound to the hardware of the current device and to the current signed-in user. This function is highly restricted and will fail if the current device is not managed, the current user is not managed, or if this operation has not explicitly been enabled for the caller by enterprise user policy. The Enterprise User Key does not reside in the \"user\"\ntoken and is not accessible by any other API.\nParameters\n-\nchallenge\nArrayBuffer\nA challenge as emitted by the Verified Access Web API.\n-\nregisterKey\nboolean\nIf set, the current Enterprise User Key is registered with the\n\"user\"\ntoken and relinquishes the Enterprise User Key role. The key can then be associated with a certificate and used like any other signing key. This key is 2048-bit RSA. Subsequent calls to this function will then generate a new Enterprise User Key. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(response: ArrayBuffer) => void\n-\nresponse\nArrayBuffer\nThe challenge response.\n-\nReturns\n-\nPromise<ArrayBuffer>\nChrome 131+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetCertificates()\nchrome.enterprise.platformKeys.getCertificates(\ntokenId: string,\ncallback?: function,\n)\nReturns the list of all client certificates available from the given token. Can be used to check for the existence and expiration of client certificates that are usable for a certain authentication.\nParameters\n-\ntokenId\nstring\nThe id of a Token returned by\ngetTokens\n. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(certificates: ArrayBuffer[]) => void\n-\ncertificates\nArrayBuffer[]\nThe list of certificates, each in DER encoding of a X.509 certificate.\n-\nReturns\n-\nPromise<ArrayBuffer[]>\nChrome 131+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetTokens()\nchrome.enterprise.platformKeys.getTokens(\ncallback?: function,\n)\nReturns the available Tokens. In a regular user's session the list will always contain the user's token with id\n\"user\"\n. If a system-wide TPM token is available, the returned list will also contain the system-wide token with id\n\"system\"\n. The system-wide token will be the same for all sessions on this device (device in the sense of e.g. a Chromebook).\nParameters\nReturns\n-\nPromise<Token[]>\nChrome 131+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nimportCertificate()\nchrome.enterprise.platformKeys.importCertificate(\ntokenId: string,\ncertificate: ArrayBuffer,\ncallback?: function,\n)\nImports certificate\nto the given token if the certified key is already stored in this token. After a successful certification request, this function should be used to store the obtained certificate and to make it available to the operating system and browser for authentication.\nParameters\n-\ntokenId\nstring\nThe id of a Token returned by\ngetTokens\n. -\ncertificate\nArrayBuffer\nThe DER encoding of a X.509 certificate.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 131+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveCertificate()\nchrome.enterprise.platformKeys.removeCertificate(\ntokenId: string,\ncertificate: ArrayBuffer,\ncallback?: function,\n)\nRemoves certificate\nfrom the given token if present. Should be used to remove obsolete certificates so that they are not considered during authentication and do not clutter the certificate choice. Should be used to free storage in the certificate store.\nParameters\n-\ntokenId\nstring\nThe id of a Token returned by\ngetTokens\n. -\ncertificate\nArrayBuffer\nThe DER encoding of a X.509 certificate.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 131+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/events", "title": "chrome.events | API | Chrome for Developers", "text": "Description\nThe chrome.events\nnamespace contains common types used by APIs dispatching events to notify you when something interesting happens.\nConcepts and usage\nAn Event\nis an object that lets you be notified when something interesting happens. Here's an\nexample of using the chrome.alarms.onAlarm\nevent to be notified whenever an alarm has elapsed:\nchrome.alarms.onAlarm.addListener((alarm) => {\nappendToLog(`alarms.onAlarm -- name: ${alarm.name}, scheduledTime: ${alarm.scheduledTime}`);\n});\nAs the example shows, you register for notification using addListener()\n. The argument to\naddListener()\nis always a function that you define to handle the event, but the parameters to the\nfunction depend on which event you're handling. Checking the documentation for alarms.onAlarm\n,\nyou can see that the function has a single parameter: an alarms.Alarm\nobject that has details\nabout the elapsed alarm.\nExample APIs using Events: alarms, i18n, identity, runtime. Most chrome APIs do.\nDeclarative Event Handlers\nThe declarative event handlers provide a means to define rules consisting of declarative conditions and actions. Conditions are evaluated in the browser rather than the JavaScript engine which reduces roundtrip latencies and allows for very high efficiency.\nDeclarative event handlers are used for example in the Declarative Content API. This page describes the underlying concepts of all declarative event handlers.\nRules\nThe simplest possible rule consists of one or more conditions and one or more actions:\nconst rule = {\nconditions: [ /* my conditions */ ],\nactions: [ /* my actions */ ]\n};\nIf any of the conditions is fulfilled, all actions are executed.\nIn addition to conditions and actions you may give each rule an identifier, which simplifies unregistering previously registered rules, and a priority to define precedences among rules. Priorities are only considered if rules conflict each other or need to be executed in a specific order. Actions are executed in descending order of the priority of their rules.\nconst rule = {\nid: \"my rule\", // optional, will be generated if not set.\npriority: 100, // optional, defaults to 100.\nconditions: [ /* my conditions */ ],\nactions: [ /* my actions */ ]\n};\nEvent objects\nEvent objects may support rules. These event objects don't call a callback function when\nevents happen but test whether any registered rule has at least one fulfilled condition and execute\nthe actions associated with this rule. Event objects supporting the declarative API have three\nrelevant methods: events.Event.addRules()\n, events.Event.removeRules()\n, and\nevents.Event.getRules()\n.\nAdd rules\nTo add rules call the addRules()\nfunction of the event object. It takes an array of rule instances\nas its first parameter and a callback function that is called on completion.\nconst rule_list = [rule1, rule2, ...];\naddRules(rule_list, (details) => {...});\nIf the rules were inserted successfully, the details\nparameter contains an array of inserted rules\nappearing in the same order as in the passed rule_list\nwhere the optional parameters id\nand\npriority\nwere filled with the generated values. If any rule is invalid, for example, because it contained\nan invalid condition or action, none of the rules are added and the runtime.lastError variable\nis set when the callback function is called. Each rule in rule_list\nmust contain a unique\nidentifier that is not already used by another rule or an empty identifier.\nRemove rules\nTo remove rules call the removeRules()\nfunction. It accepts an optional array of rule identifiers\nas its first parameter and a callback function as its second parameter.\nconst rule_ids = [\"id1\", \"id2\", ...];\nremoveRules(rule_ids, () => {...});\nIf rule_ids\nis an array of identifiers, all rules having identifiers listed in the array are\nremoved. If rule_ids\nlists an identifier, that is unknown, this identifier is silently ignored. If\nrule_ids\nis undefined\n, all registered rules of this extension are removed. The callback()\nfunction is called when the rules were removed.\nRetrieve rules\nTo retrieve a list of registered rules, call the getRules()\nfunction. It accepts an\noptional array of rule identifiers with the same semantics as removeRules()\nand a callback function.\nconst rule_ids = [\"id1\", \"id2\", ...];\ngetRules(rule_ids, (details) => {...});\nThe details\nparameter passed to the callback()\nfunction refers to an array of rules including\nfilled optional parameters.\nPerformance\nTo achieve maximum performance, you should keep the following guidelines in mind.\nRegister and unregister rules in bulk. After each registration or unregistration, Chrome needs to update internal data structures. This update is an expensive operation.\nconst rule1 = {...}; const rule2 = {...}; chrome.declarativeWebRequest.onRequest.addRules([rule1]); chrome.declarativeWebRequest.onRequest.addRules([rule2]);\nconst rule1 = {...}; const rule2 = {...}; chrome.declarativeWebRequest.onRequest.addRules([rule1, rule2]);\nPrefer substring matching over regular expressions in an events.UrlFilter. Substring based matching is extremely fast.\nconst match = new chrome.declarativeWebRequest.RequestMatcher({ url: {urlMatches: \"example.com/[^?]*foo\" } });\nconst match = new chrome.declarativeWebRequest.RequestMatcher({ url: {hostSuffix: \"example.com\", pathContains: \"foo\"} });\nIf there are many rules that share the same actions, merge the rules into one. Rules trigger their actions as soon as a single condition is fulfilled. This speeds up the matching and reduces memory consumption for duplicate action sets.\nconst condition1 = new chrome.declarativeWebRequest.RequestMatcher({ url: { hostSuffix: 'example.com' } }); const condition2 = new chrome.declarativeWebRequest.RequestMatcher({ url: { hostSuffix: 'foobar.com' } }); const rule1 = { conditions: [condition1], actions: [new chrome.declarativeWebRequest.CancelRequest()] }; const rule2 = { conditions: [condition2], actions: [new chrome.declarativeWebRequest.CancelRequest()] }; chrome.declarativeWebRequest.onRequest.addRules([rule1, rule2]);\nconst condition1 = new chrome.declarativeWebRequest.RequestMatcher({ url: { hostSuffix: 'example.com' } }); const condition2 = new chrome.declarativeWebRequest.RequestMatcher({ url: { hostSuffix: 'foobar.com' } }); const rule = { conditions: [condition1, condition2], actions: [new chrome.declarativeWebRequest.CancelRequest()] }; chrome.declarativeWebRequest.onRequest.addRules([rule]);\nFiltered events\nFiltered events are a mechanism that allows listeners to specify a subset of events that they are interested in. A listener that uses a filter won't be invoked for events that don't pass the filter, which makes the listening code more declarative and efficient. A service worker need not be woken up to handle events it doesn't care about.\nFiltered events are intended to allow a transition from manual filtering code.\nchrome.webNavigation.onCommitted.addListener((event) => { if (hasHostSuffix(event.url, 'google.com') || hasHostSuffix(event.url, 'google.com.au')) { // ... } });\nchrome.webNavigation.onCommitted.addListener((event) => { // ... }, {url: [{hostSuffix: 'google.com'}, {hostSuffix: 'google.com.au'}]});\nEvents support specific filters that are meaningful to that event. The list of filters that an event supports will be listed in the documentation for that event in the \"filters\" section.\nWhen matching URLs (as in the example above), event filters support the same URL matching\ncapabilities as expressible with a events.UrlFilter\n, except for scheme and port matching.\nTypes\nEvent\nAn object which allows the addition and removal of listeners for a Chrome event.\nProperties\n-\naddListener\nvoid\nRegisters an event listener callback to an event.\nThe\naddListener\nfunction looks like:(callback: H) => {...}\n-\ncallback\nH\nCalled when an event occurs. The parameters of this function depend on the type of event.\n-\n-\naddRules\nvoid\nRegisters rules to handle events.\nThe\naddRules\nfunction looks like: [], callback?: function) => {...}(rules: Rule<anyany>\n-\ngetRules\nvoid\nReturns currently registered rules.\nThe\ngetRules\nfunction looks like:(ruleIdentifiers?: string[], callback: function) => {...}\n-\nruleIdentifiers\nstring[] optional\nIf an array is passed, only rules with identifiers contained in this array are returned.\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like: []) => void(rules: Rule<anyany>\n-\nrules\nRule<anyany>[]\nRules that were registered, the optional parameters are filled with values.\n-\n-\n-\nhasListener\nvoid\nThe\nhasListener\nfunction looks like:(callback: H) => {...}\n-\ncallback\nH\nListener whose registration status shall be tested.\n-\nreturns\nboolean\nTrue if callback is registered to the event.\n-\n-\nhasListeners\nvoid\nThe\nhasListeners\nfunction looks like:() => {...}\n-\nreturns\nboolean\nTrue if any event listeners are registered to the event.\n-\n-\nremoveListener\nvoid\nDeregisters an event listener callback from an event.\nThe\nremoveListener\nfunction looks like:(callback: H) => {...}\n-\ncallback\nH\nListener that shall be unregistered.\n-\n-\nremoveRules\nvoid\nUnregisters currently registered rules.\nThe\nremoveRules\nfunction looks like:(ruleIdentifiers?: string[], callback?: function) => {...}\n-\nruleIdentifiers\nstring[] optional\nIf an array is passed, only rules with identifiers contained in this array are unregistered.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\n-\nRule\nDescription of a declarative rule for handling events.\nProperties\n-\nactions\nany[]\nList of actions that are triggered if one of the conditions is fulfilled.\n-\nconditions\nany[]\nList of conditions that can trigger the actions.\n-\nid\nstring optional\nOptional identifier that allows referencing this rule.\n-\npriority\nnumber optional\nOptional priority of this rule. Defaults to 100.\n-\ntags\nstring[] optional\nTags can be used to annotate rules and perform operations on sets of rules.\nUrlFilter\nFilters URLs for various criteria. See event filtering. All criteria are case sensitive.\nProperties\n-\ncidrBlocks\nstring[] optional\nChrome 123+Matches if the host part of the URL is an IP address and is contained in any of the CIDR blocks specified in the array.\n-\nhostContains\nstring optional\nMatches if the host name of the URL contains a specified string. To test whether a host name component has a prefix 'foo', use hostContains: '.foo'. This matches 'www.foobar.com' and 'foo.com', because an implicit dot is added at the beginning of the host name. Similarly, hostContains can be used to match against component suffix ('foo.') and to exactly match against components ('.foo.'). Suffix- and exact-matching for the last components need to be done separately using hostSuffix, because no implicit dot is added at the end of the host name.\n-\nhostEquals\nstring optional\nMatches if the host name of the URL is equal to a specified string.\n-\nhostPrefix\nstring optional\nMatches if the host name of the URL starts with a specified string.\n-\nhostSuffix\nstring optional\nMatches if the host name of the URL ends with a specified string.\n-\noriginAndPathMatches\nstring optional\nMatches if the URL without query segment and fragment identifier matches a specified regular expression. Port numbers are stripped from the URL if they match the default port number. The regular expressions use the RE2 syntax.\n-\npathContains\nstring optional\nMatches if the path segment of the URL contains a specified string.\n-\npathEquals\nstring optional\nMatches if the path segment of the URL is equal to a specified string.\n-\npathPrefix\nstring optional\nMatches if the path segment of the URL starts with a specified string.\n-\npathSuffix\nstring optional\nMatches if the path segment of the URL ends with a specified string.\n-\nports\n(number | number[])[] optional\nMatches if the port of the URL is contained in any of the specified port lists. For example\n[80, 443, [1000, 1200]]\nmatches all requests on port 80, 443 and in the range 1000-1200. -\nqueryContains\nstring optional\nMatches if the query segment of the URL contains a specified string.\n-\nqueryEquals\nstring optional\nMatches if the query segment of the URL is equal to a specified string.\n-\nqueryPrefix\nstring optional\nMatches if the query segment of the URL starts with a specified string.\n-\nquerySuffix\nstring optional\nMatches if the query segment of the URL ends with a specified string.\n-\nschemes\nstring[] optional\nMatches if the scheme of the URL is equal to any of the schemes specified in the array.\n-\nurlContains\nstring optional\nMatches if the URL (without fragment identifier) contains a specified string. Port numbers are stripped from the URL if they match the default port number.\n-\nurlEquals\nstring optional\nMatches if the URL (without fragment identifier) is equal to a specified string. Port numbers are stripped from the URL if they match the default port number.\n-\nurlMatches\nstring optional\nMatches if the URL (without fragment identifier) matches a specified regular expression. Port numbers are stripped from the URL if they match the default port number. The regular expressions use the RE2 syntax.\n-\nurlPrefix\nstring optional\nMatches if the URL (without fragment identifier) starts with a specified string. Port numbers are stripped from the URL if they match the default port number.\n-\nurlSuffix\nstring optional\nMatches if the URL (without fragment identifier) ends with a specified string. Port numbers are stripped from the URL if they match the default port number."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/extension", "title": "chrome.extension | API | Chrome for Developers", "text": "Description\nThe chrome.extension\nAPI has utilities that can be used by any extension page. It includes support for exchanging messages between an extension and its content scripts or between extensions, as described in detail in Message Passing.\nTypes\nViewType\nThe type of extension view.\nEnum\n\"tab\" \"popup\"\nProperties\ninIncognitoContext\nTrue for content scripts running inside incognito tabs, and for extension pages running inside an incognito process. The latter only applies to extensions with 'split' incognito_behavior.\nType\nboolean\nMethods\ngetBackgroundPage()\nchrome.extension.getBackgroundPage()\nReturns the JavaScript 'window' object for the background page running inside the current extension. Returns null if the extension has no background page.\nReturns\n-\nWindow | undefined\ngetViews()\nchrome.extension.getViews(\nfetchProperties?: object,\n)\nReturns an array of the JavaScript 'window' objects for each of the pages running inside the current extension.\nParameters\n-\nfetchProperties\nobject optional\n-\ntabId\nnumber optional\nChrome 54+Find a view according to a tab id. If this field is omitted, returns all views.\n-\ntype\nViewType optional\nThe type of view to get. If omitted, returns all views (including background pages and tabs).\n-\nwindowId\nnumber optional\nThe window to restrict the search to. If omitted, returns all views.\n-\nReturns\n-\nWindow[]\nArray of global objects\nisAllowedFileSchemeAccess()\nchrome.extension.isAllowedFileSchemeAccess(\ncallback?: function,\n)\nRetrieves the state of the extension's access to the 'file://' scheme. This corresponds to the user-controlled per-extension 'Allow access to File URLs' setting accessible via the chrome://extensions page.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(isAllowedAccess: boolean) => void\n-\nisAllowedAccess\nboolean\nTrue if the extension can access the 'file://' scheme, false otherwise.\n-\nReturns\n-\nPromise<boolean>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nisAllowedIncognitoAccess()\nchrome.extension.isAllowedIncognitoAccess(\ncallback?: function,\n)\nRetrieves the state of the extension's access to Incognito-mode. This corresponds to the user-controlled per-extension 'Allowed in Incognito' setting accessible via the chrome://extensions page.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(isAllowedAccess: boolean) => void\n-\nisAllowedAccess\nboolean\nTrue if the extension has access to Incognito mode, false otherwise.\n-\nReturns\n-\nPromise<boolean>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetUpdateUrlData()\nchrome.extension.setUpdateUrlData(\ndata: string,\n)\nSets the value of the ap CGI parameter used in the extension's update URL. This value is ignored for extensions that are hosted in the Chrome Extension Gallery.\nParameters\n-\ndata\nstring"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/extensionTypes", "title": "chrome.extensionTypes | API | Chrome for Developers", "text": "Description\nThe chrome.extensionTypes\nAPI contains type declarations for Chrome extensions.\nTypes\nEnum\n\"author\" \"user\"\nDeleteInjectionDetails\nDetails of the CSS to remove. Either the code or the file property must be set, but both may not be set at the same time.\nProperties\n-\nallFrames\nboolean optional\nIf allFrames is\ntrue\n, implies that the CSS should be removed from all frames of current page. By default, it'sfalse\nand is only removed from the top frame. Iftrue\nandframeId\nis set, then the code is removed from the selected frame and all of its child frames. -\ncode\nstring optional\nCSS code to remove.\n-\ncssOrigin\nCSSOrigin optional\nThe origin of the CSS to remove. Defaults to\n\"author\"\n. -\nfile\nstring optional\nCSS file to remove.\n-\nframeId\nnumber optional\nThe frame from where the CSS should be removed. Defaults to 0 (the top-level frame).\n-\nmatchAboutBlank\nboolean optional\nIf matchAboutBlank is true, then the code is also removed from about:blank and about:srcdoc frames if your extension has access to its parent document. By default it is\nfalse\n.\nDocumentLifecycle\nThe document lifecycle of the frame.\nEnum\n\"prerender\" \"active\" \"cached\" \"pending_deletion\"\nExecutionWorld\nThe JavaScript world for a script to execute within. Can either be an isolated world unique to this extension, the main world of the DOM which is shared with the page's JavaScript, or a user scripts world that is only available for scripts registered with the User Scripts API.\nEnum\n\"ISOLATED\" \"MAIN\" \"USER_SCRIPT\"\nFrameType\nThe type of frame.\nEnum\n\"outermost_frame\" \"fenced_frame\" \"sub_frame\"\nImageDetails\nDetails about the format and quality of an image.\nProperties\n-\nformat\nImageFormat optional\nThe format of the resulting image. Default is\n\"jpeg\"\n. -\nquality\nnumber optional\nWhen format is\n\"jpeg\"\n, controls the quality of the resulting image. This value is ignored for PNG images. As quality is decreased, the resulting image will have more visual artifacts, and the number of bytes needed to store it will decrease.\nImageFormat\nThe format of an image.\nEnum\n\"jpeg\" \"png\"\nInjectDetails\nDetails of the script or CSS to inject. Either the code or the file property must be set, but both may not be set at the same time.\nProperties\n-\nallFrames\nboolean optional\nIf allFrames is\ntrue\n, implies that the JavaScript or CSS should be injected into all frames of current page. By default, it'sfalse\nand is only injected into the top frame. Iftrue\nandframeId\nis set, then the code is inserted in the selected frame and all of its child frames. -\ncode\nstring optional\nJavaScript or CSS code to inject.\nWarning: Be careful using the\ncode\nparameter. Incorrect use of it may open your extension to cross site scripting attacks -\ncssOrigin\nCSSOrigin optional\nChrome 66+The origin of the CSS to inject. This may only be specified for CSS, not JavaScript. Defaults to\n\"author\"\n. -\nfile\nstring optional\nJavaScript or CSS file to inject.\n-\nframeId\nnumber optional\nChrome 50+The frame where the script or CSS should be injected. Defaults to 0 (the top-level frame).\n-\nmatchAboutBlank\nboolean optional\nIf matchAboutBlank is true, then the code is also injected in about:blank and about:srcdoc frames if your extension has access to its parent document. Code cannot be inserted in top-level about:-frames. By default it is\nfalse\n. -\nrunAt\nRunAt optional\nThe soonest that the JavaScript or CSS will be injected into the tab. Defaults to \"document_idle\".\nRunAt\nThe soonest that the JavaScript or CSS will be injected into the tab.\nEnum\n\"document_start\" \"document_end\" \"document_idle\"\nScript is injected after any files from css, but before any other DOM is constructed or any other script is run.\nScript is injected immediately after the DOM is complete, but before subresources like images and frames have loaded.\nThe browser chooses a time to inject the script between \"document_end\" and immediately after the window.onload\nevent fires. The exact moment of injection depends on how complex the document is and how long it is taking to load, and is optimized for page load speed. Content scripts running at \"document_idle\" don't need to listen for the window.onload\nevent; they are guaranteed to run after the DOM completes. If a script definitely needs to run after window.onload\n, the extension can check if onload\nhas already fired by using the document.readyState\nproperty."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/extensionTypes", "title": "chrome.extensionTypes | API | Chrome for Developers", "text": "Description\nThe chrome.extensionTypes\nAPI contains type declarations for Chrome extensions.\nTypes\nEnum\n\"author\" \"user\"\nDeleteInjectionDetails\nDetails of the CSS to remove. Either the code or the file property must be set, but both may not be set at the same time.\nProperties\n-\nallFrames\nboolean optional\nIf allFrames is\ntrue\n, implies that the CSS should be removed from all frames of current page. By default, it'sfalse\nand is only removed from the top frame. Iftrue\nandframeId\nis set, then the code is removed from the selected frame and all of its child frames. -\ncode\nstring optional\nCSS code to remove.\n-\ncssOrigin\nCSSOrigin optional\nThe origin of the CSS to remove. Defaults to\n\"author\"\n. -\nfile\nstring optional\nCSS file to remove.\n-\nframeId\nnumber optional\nThe frame from where the CSS should be removed. Defaults to 0 (the top-level frame).\n-\nmatchAboutBlank\nboolean optional\nIf matchAboutBlank is true, then the code is also removed from about:blank and about:srcdoc frames if your extension has access to its parent document. By default it is\nfalse\n.\nDocumentLifecycle\nThe document lifecycle of the frame.\nEnum\n\"prerender\" \"active\" \"cached\" \"pending_deletion\"\nExecutionWorld\nThe JavaScript world for a script to execute within. Can either be an isolated world unique to this extension, the main world of the DOM which is shared with the page's JavaScript, or a user scripts world that is only available for scripts registered with the User Scripts API.\nEnum\n\"ISOLATED\" \"MAIN\" \"USER_SCRIPT\"\nFrameType\nThe type of frame.\nEnum\n\"outermost_frame\" \"fenced_frame\" \"sub_frame\"\nImageDetails\nDetails about the format and quality of an image.\nProperties\n-\nformat\nImageFormat optional\nThe format of the resulting image. Default is\n\"jpeg\"\n. -\nquality\nnumber optional\nWhen format is\n\"jpeg\"\n, controls the quality of the resulting image. This value is ignored for PNG images. As quality is decreased, the resulting image will have more visual artifacts, and the number of bytes needed to store it will decrease.\nImageFormat\nThe format of an image.\nEnum\n\"jpeg\" \"png\"\nInjectDetails\nDetails of the script or CSS to inject. Either the code or the file property must be set, but both may not be set at the same time.\nProperties\n-\nallFrames\nboolean optional\nIf allFrames is\ntrue\n, implies that the JavaScript or CSS should be injected into all frames of current page. By default, it'sfalse\nand is only injected into the top frame. Iftrue\nandframeId\nis set, then the code is inserted in the selected frame and all of its child frames. -\ncode\nstring optional\nJavaScript or CSS code to inject.\nWarning: Be careful using the\ncode\nparameter. Incorrect use of it may open your extension to cross site scripting attacks -\ncssOrigin\nCSSOrigin optional\nChrome 66+The origin of the CSS to inject. This may only be specified for CSS, not JavaScript. Defaults to\n\"author\"\n. -\nfile\nstring optional\nJavaScript or CSS file to inject.\n-\nframeId\nnumber optional\nChrome 50+The frame where the script or CSS should be injected. Defaults to 0 (the top-level frame).\n-\nmatchAboutBlank\nboolean optional\nIf matchAboutBlank is true, then the code is also injected in about:blank and about:srcdoc frames if your extension has access to its parent document. Code cannot be inserted in top-level about:-frames. By default it is\nfalse\n. -\nrunAt\nRunAt optional\nThe soonest that the JavaScript or CSS will be injected into the tab. Defaults to \"document_idle\".\nRunAt\nThe soonest that the JavaScript or CSS will be injected into the tab.\nEnum\n\"document_start\" \"document_end\" \"document_idle\"\nScript is injected after any files from css, but before any other DOM is constructed or any other script is run.\nScript is injected immediately after the DOM is complete, but before subresources like images and frames have loaded.\nThe browser chooses a time to inject the script between \"document_end\" and immediately after the window.onload\nevent fires. The exact moment of injection depends on how complex the document is and how long it is taking to load, and is optimized for page load speed. Content scripts running at \"document_idle\" don't need to listen for the window.onload\nevent; they are guaranteed to run after the DOM completes. If a script definitely needs to run after window.onload\n, the extension can check if onload\nhas already fired by using the document.readyState\nproperty."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/fileBrowserHandler", "title": "chrome.fileBrowserHandler | API | Chrome for Developers", "text": "Description\nUse the chrome.fileBrowserHandler\nAPI to extend the Chrome OS file browser. For example, you can use this API to enable users to upload files to your website.\nConcepts and usage\nThe ChromeOS file browser comes up when the user either presses Alt+Shift+M or connects an external storage device, such as an SD card, USB key, external drive, or digital camera. Besides showing the files on external devices, the file browser can also display files that the user has previously saved to the system.\nWhen the user selects one or more files, the file browser adds buttons representing the valid handlers for those files. For example, in the following screenshot, selecting a file with a \".png\" suffix results in an \"Save to Gallery\" button that the user can click.\nPermissions\nfileBrowserHandler\nYou must declare the \"fileBrowserHandler\"\npermission in the extension manifest.\nAvailability\nYou must use the \"file_browser_handlers\"\nfield to register the extension as a handler of at least one file type. You should also provide a 16 by 16 icon to be displayed on the button. For example:\n{\n\"name\": \"My extension\",\n...\n\"file_browser_handlers\": [\n{\n\"id\": \"upload\",\n\"default_title\": \"Save to Gallery\", // What the button will display\n\"file_filters\": [\n\"filesystem:*.jpg\", // To match all files, use \"filesystem:*.*\"\n\"filesystem:*.jpeg\",\n\"filesystem:*.png\"\n]\n}\n],\n\"permissions\" : [\n\"fileBrowserHandler\"\n],\n\"icons\": {\n\"16\": \"icon16.png\",\n\"48\": \"icon48.png\",\n\"128\": \"icon128.png\"\n},\n...\n}\nImplement a file browser handler\nTo use this API, you must implement a function that handles the onExecute\nevent of chrome.fileBrowserHandler\n. Your function will be called whenever the user clicks the button that represents your file browser handler. In your function, use the File System API to get access to the file contents. Here is an example:\nchrome.fileBrowserHandler.onExecute.addListener(async (id, details) => {\nif (id !== 'upload') {\nreturn; // check if you have multiple file_browser_handlers\n}\nfor (const entry of detail.entries) {\n// the FileSystemFileEntry doesn't have a Promise API, wrap in one\nconst file = await new Promise((resolve, reject) => {\nentry.file(resolve, reject);\n});\nconst buffer = await file.arrayBuffer();\n// do something with buffer\n}\n});\nYour event handler is passed two arguments:\nid\n- The\nid\nvalue from the manifest file. If your extension implements multiple handlers, you can check the ID value to see which handler has been triggered. details\n- An object describing the event. You can get the file or files that the user has selected from the\nentries\nfield of this object, which is an array ofFileSystemFileEntry\nobjects.\nTypes\nFileHandlerExecuteEventDetails\nEvent details payload for fileBrowserHandler.onExecute event.\nProperties\n-\nentries\nany[]\nArray of Entry instances representing files that are targets of this action (selected in ChromeOS file browser).\n-\ntab_id\nnumber optional\nThe ID of the tab that raised this event. Tab IDs are unique within a browser session.\nEvents\nonExecute\nchrome.fileBrowserHandler.onExecute.addListener(\ncallback: function,\n)\nFired when file system action is executed from ChromeOS file browser.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(id: string, details: FileHandlerExecuteEventDetails) => void\n-\nid\nstring\n-\ndetails\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/fileSystemProvider", "title": "chrome.fileSystemProvider | API | Chrome for Developers", "text": "Description\nUse the chrome.fileSystemProvider\nAPI to create file systems, that can be accessible from the file manager on Chrome OS.\nPermissions\nfileSystemProvider\nAvailability\nYou must declare the \"fileSystemProvider\" permission and section in the extension manifest to use the File System Provider API. For example:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"fileSystemProvider\"\n],\n...\n\"file_system_provider_capabilities\": {\n\"configurable\": true,\n\"watchable\": false,\n\"multiple_mounts\": true,\n\"source\": \"network\"\n},\n...\n}\nThe file_system_provider section must be declared as follows:\nconfigurable\n(boolean) - optional- Whether configuring via onConfigureRequested is supported. By default: false.\nmultiple_mounts\n(boolean) - optional- Whether multiple (more than one) mounted file systems are supported. By default: false.\nwatchable\n(boolean) - optional- Whether setting watchers and notifying about changes is supported. By default: false.\nsource\n(enum of \"file\", \"device\", or \"network\") - required- Source of data for mounted file systems.\nFiles app uses above information in order to render related UI elements appropriately. For example, if configurable\nis set to true, then a menu item for configuring volumes will be rendered. Similarly, if multiple_mounts\nis set to true\n, then Files app will allow to add more than one mount points from the UI. If watchable\nis false\n, then a refresh button will be rendered. Note, that if possible you should add support for watchers, so changes on the file system can be reflected immediately and automatically.\nOverview\nFile System Provider API allows extensions to support virtual file systems, which are available in the file manager on ChromeOS. Use cases include decompressing archives and accessing files in a cloud service other than Drive.\nMounting file systems\nProviding extensions can either provide file system contents from an external source (such as a remote server or a USB device), or using a local file (such as an archive) as its input.\nIn order to write file systems which are file handlers (source is \"file\"\n) the provider must be a packaged app, as the onLaunched\nevent is not available to extensions.\nIf the source is network or a device, then the file system should be mounted when onMountRequested event is called.\n| Source of the file system data | Entry point |\n|---|---|\n\"file\" |\nAvailable to packaged apps only. |\n\"device\" or \"network\" |\nonMountRequested |\nConfiguring file systems\nProvided file systems once mounted can be configured via the onConfigureRequested event. It's especially useful for file systems which provide contents via network in order to set proper credentials. Handling this event is optional.\nLife cycle\nProvided file systems once mounted are remembered by Chrome and remounted automatically after reboot or restart. Hence, once a file system is mounted by a providing extension, it will stay until either the extension is unloaded, or the extension calls the unmount method.\nTypes\nAbortRequestedOptions\nProperties\n-\nfileSystemId\nstring\nThe identifier of the file system related to this operation.\n-\noperationRequestId\nnumber\nAn ID of the request to be aborted.\n-\nrequestId\nnumber\nThe unique identifier of this request.\nAction\nProperties\n-\nid\nstring\nThe identifier of the action. Any string or\nCommonActionId\nfor common actions. -\ntitle\nstring optional\nThe title of the action. It may be ignored for common actions.\nAddWatcherRequestedOptions\nProperties\n-\nentryPath\nstring\nThe path of the entry to be observed.\n-\nfileSystemId\nstring\nThe identifier of the file system related to this operation.\n-\nrecursive\nboolean\nWhether observing should include all child entries recursively. It can be true for directories only.\n-\nrequestId\nnumber\nThe unique identifier of this request.\nChange\nProperties\n-\nchangeType\nThe type of the change which happened to the entry.\n-\ncloudFileInfo\nCloudFileInfo optional\nChrome 125+Information relating to the file if backed by a cloud file system.\n-\nentryPath\nstring\nThe path of the changed entry.\nChangeType\nType of a change detected on the observed directory.\nEnum\n\"CHANGED\" \"DELETED\"\nCloseFileRequestedOptions\nProperties\n-\nfileSystemId\nstring\nThe identifier of the file system related to this operation.\n-\nopenRequestId\nnumber\nA request ID used to open the file.\n-\nrequestId\nnumber\nThe unique identifier of this request.\nCloudFileInfo\nProperties\n-\nversionTag\nstring optional\nA tag that represents the version of the file.\nCloudIdentifier\nProperties\n-\nid\nstring\nThe provider's identifier for the given file/directory.\n-\nproviderName\nstring\nIdentifier for the cloud storage provider (e.g. 'drive.google.com').\nCommonActionId\nList of common actions. \"SHARE\"\nis for sharing files with others. \"SAVE_FOR_OFFLINE\"\nfor pinning (saving for offline access). \"OFFLINE_NOT_NECESSARY\"\nfor notifying that the file doesn't need to be stored for offline access anymore. Used by onGetActionsRequested\nand onExecuteActionRequested\n.\nEnum\n\"SAVE_FOR_OFFLINE\" \"OFFLINE_NOT_NECESSARY\" \"SHARE\"\nConfigureRequestedOptions\nProperties\n-\nfileSystemId\nstring\nThe identifier of the file system to be configured.\n-\nrequestId\nnumber\nThe unique identifier of this request.\nCopyEntryRequestedOptions\nProperties\n-\nfileSystemId\nstring\nThe identifier of the file system related to this operation.\n-\nrequestId\nnumber\nThe unique identifier of this request.\n-\nsourcePath\nstring\nThe source path of the entry to be copied.\n-\ntargetPath\nstring\nThe destination path for the copy operation.\nCreateDirectoryRequestedOptions\nProperties\n-\ndirectoryPath\nstring\nThe path of the directory to be created.\n-\nfileSystemId\nstring\nThe identifier of the file system related to this operation.\n-\nrecursive\nboolean\nWhether the operation is recursive (for directories only).\n-\nrequestId\nnumber\nThe unique identifier of this request.\nCreateFileRequestedOptions\nProperties\n-\nfilePath\nstring\nThe path of the file to be created.\n-\nfileSystemId\nstring\nThe identifier of the file system related to this operation.\n-\nrequestId\nnumber\nThe unique identifier of this request.\nDeleteEntryRequestedOptions\nProperties\n-\nentryPath\nstring\nThe path of the entry to be deleted.\n-\nfileSystemId\nstring\nThe identifier of the file system related to this operation.\n-\nrecursive\nboolean\nWhether the operation is recursive (for directories only).\n-\nrequestId\nnumber\nThe unique identifier of this request.\nEntryMetadata\nProperties\n-\ncloudFileInfo\nCloudFileInfo optional\nChrome 125+Information that identifies a specific file in the underlying cloud file system. Must be provided if requested in\noptions\nand the file is backed by cloud storage. -\ncloudIdentifier\nCloudIdentifier optional\nChrome 117+Cloud storage representation of this entry. Must be provided if requested in\noptions\nand the file is backed by cloud storage. For local files not backed by cloud storage, it should be undefined when requested. -\nisDirectory\nboolean optional\nTrue if it is a directory. Must be provided if requested in\noptions\n. -\nmimeType\nstring optional\nMime type for the entry. Always optional, but should be provided if requested in\noptions\n. -\nmodificationTime\nDate optional\nThe last modified time of this entry. Must be provided if requested in\noptions\n. -\nname\nstring optional\nName of this entry (not full path name). Must not contain '/'. For root it must be empty. Must be provided if requested in\noptions\n. -\nsize\nnumber optional\nFile size in bytes. Must be provided if requested in\noptions\n. -\nthumbnail\nstring optional\nThumbnail image as a data URI in either PNG, JPEG or WEBP format, at most 32 KB in size. Optional, but can be provided only when explicitly requested by the\nonGetMetadataRequested\nevent.\nExecuteActionRequestedOptions\nProperties\n-\nactionId\nstring\nThe identifier of the action to be executed.\n-\nentryPaths\nstring[]\nChrome 47+The set of paths of the entries to be used for the action.\n-\nfileSystemId\nstring\nThe identifier of the file system related to this operation.\n-\nrequestId\nnumber\nThe unique identifier of this request.\nFileSystemInfo\nProperties\n-\ndisplayName\nstring\nA human-readable name for the file system.\n-\nfileSystemId\nstring\nThe identifier of the file system.\n-\nopenedFiles\nList of currently opened files.\n-\nopenedFilesLimit\nnumber\nThe maximum number of files that can be opened at once. If 0, then not limited.\n-\nsupportsNotifyTag\nboolean optional\nChrome 45+Whether the file system supports the\ntag\nfield for observing directories. -\nwatchers\nWatcher[]\nChrome 45+List of watchers.\n-\nwritable\nboolean\nWhether the file system supports operations which may change contents of the file system (such as creating, deleting or writing to files).\nGetActionsRequestedOptions\nProperties\n-\nentryPaths\nstring[]\nChrome 47+List of paths of entries for the list of actions.\n-\nfileSystemId\nstring\nThe identifier of the file system related to this operation.\n-\nrequestId\nnumber\nThe unique identifier of this request.\nGetMetadataRequestedOptions\nProperties\n-\ncloudFileInfo\nboolean\nChrome 125+Set to\ntrue\nifcloudFileInfo\nvalue is requested. -\ncloudIdentifier\nboolean\nChrome 117+Set to\ntrue\nifcloudIdentifier\nvalue is requested. -\nentryPath\nstring\nThe path of the entry to fetch metadata about.\n-\nfileSystemId\nstring\nThe identifier of the file system related to this operation.\n-\nisDirectory\nboolean\nChrome 49+Set to\ntrue\nifis_directory\nvalue is requested. -\nmimeType\nboolean\nChrome 49+Set to\ntrue\nifmimeType\nvalue is requested. -\nmodificationTime\nboolean\nChrome 49+Set to\ntrue\nifmodificationTime\nvalue is requested. -\nname\nboolean\nChrome 49+Set to\ntrue\nifname\nvalue is requested. -\nrequestId\nnumber\nThe unique identifier of this request.\n-\nsize\nboolean\nChrome 49+Set to\ntrue\nifsize\nvalue is requested. -\nthumbnail\nboolean\nSet to\ntrue\nifthumbnail\nvalue is requested.\nMountOptions\nProperties\n-\ndisplayName\nstring\nA human-readable name for the file system.\n-\nfileSystemId\nstring\nThe string indentifier of the file system. Must be unique per each extension.\n-\nopenedFilesLimit\nnumber optional\nThe maximum number of files that can be opened at once. If not specified, or 0, then not limited.\n-\npersistent\nboolean optional\nChrome 64+Whether the framework should resume the file system at the next sign-in session. True by default.\n-\nsupportsNotifyTag\nboolean optional\nChrome 45+Whether the file system supports the\ntag\nfield for observed directories. -\nwritable\nboolean optional\nWhether the file system supports operations which may change contents of the file system (such as creating, deleting or writing to files).\nMoveEntryRequestedOptions\nProperties\n-\nfileSystemId\nstring\nThe identifier of the file system related to this operation.\n-\nrequestId\nnumber\nThe unique identifier of this request.\n-\nsourcePath\nstring\nThe source path of the entry to be moved into a new place.\n-\ntargetPath\nstring\nThe destination path for the copy operation.\nNotifyOptions\nProperties\n-\nchangeType\nThe type of the change which happened to the observed entry. If it is DELETED, then the observed entry will be automatically removed from the list of observed entries.\n-\nchanges\nChange[] optional\nList of changes to entries within the observed directory (including the entry itself)\n-\nfileSystemId\nstring\nThe identifier of the file system related to this change.\n-\nobservedPath\nstring\nThe path of the observed entry.\n-\nrecursive\nboolean\nMode of the observed entry.\n-\ntag\nstring optional\nTag for the notification. Required if the file system was mounted with the\nsupportsNotifyTag\noption. Note, that this flag is necessary to provide notifications about changes which changed even when the system was shutdown.\nOpenedFile\nProperties\n-\nfilePath\nstring\nThe path of the opened file.\n-\nmode\nWhether the file was opened for reading or writing.\n-\nopenRequestId\nnumber\nA request ID to be be used by consecutive read/write and close requests.\nOpenFileMode\nMode of opening a file. Used by onOpenFileRequested\n.\nEnum\n\"READ\" \"WRITE\"\nOpenFileRequestedOptions\nProperties\n-\nfilePath\nstring\nThe path of the file to be opened.\n-\nfileSystemId\nstring\nThe identifier of the file system related to this operation.\n-\nmode\nWhether the file will be used for reading or writing.\n-\nrequestId\nnumber\nA request ID which will be used by consecutive read/write and close requests.\nProviderError\nError codes used by providing extensions in response to requests as well as in case of errors when calling methods of the API. For success, \"OK\"\nmust be used.\nEnum\n\"OK\" \"FAILED\" \"IN_USE\" \"EXISTS\" \"NOT_FOUND\" \"ACCESS_DENIED\" \"TOO_MANY_OPENED\" \"NO_MEMORY\" \"NO_SPACE\" \"NOT_A_DIRECTORY\" \"INVALID_OPERATION\" \"SECURITY\" \"ABORT\" \"NOT_A_FILE\" \"NOT_EMPTY\" \"INVALID_URL\" \"IO\"\nReadDirectoryRequestedOptions\nProperties\n-\ndirectoryPath\nstring\nThe path of the directory which contents are requested.\n-\nfileSystemId\nstring\nThe identifier of the file system related to this operation.\n-\nisDirectory\nboolean\nChrome 49+Set to\ntrue\nifis_directory\nvalue is requested. -\nmimeType\nboolean\nChrome 49+Set to\ntrue\nifmimeType\nvalue is requested. -\nmodificationTime\nboolean\nChrome 49+Set to\ntrue\nifmodificationTime\nvalue is requested. -\nname\nboolean\nChrome 49+Set to\ntrue\nifname\nvalue is requested. -\nrequestId\nnumber\nThe unique identifier of this request.\n-\nsize\nboolean\nChrome 49+Set to\ntrue\nifsize\nvalue is requested. -\nthumbnail\nboolean\nChrome 49+Set to\ntrue\nifthumbnail\nvalue is requested.\nReadFileRequestedOptions\nProperties\n-\nfileSystemId\nstring\nThe identifier of the file system related to this operation.\n-\nlength\nnumber\nNumber of bytes to be returned.\n-\noffset\nnumber\nPosition in the file (in bytes) to start reading from.\n-\nopenRequestId\nnumber\nA request ID used to open the file.\n-\nrequestId\nnumber\nThe unique identifier of this request.\nRemoveWatcherRequestedOptions\nProperties\n-\nentryPath\nstring\nThe path of the watched entry.\n-\nfileSystemId\nstring\nThe identifier of the file system related to this operation.\n-\nrecursive\nboolean\nMode of the watcher.\n-\nrequestId\nnumber\nThe unique identifier of this request.\nTruncateRequestedOptions\nProperties\n-\nfilePath\nstring\nThe path of the file to be truncated.\n-\nfileSystemId\nstring\nThe identifier of the file system related to this operation.\n-\nlength\nnumber\nNumber of bytes to be retained after the operation completes.\n-\nrequestId\nnumber\nThe unique identifier of this request.\nUnmountOptions\nProperties\n-\nfileSystemId\nstring\nThe identifier of the file system to be unmounted.\nUnmountRequestedOptions\nProperties\n-\nfileSystemId\nstring\nThe identifier of the file system to be unmounted.\n-\nrequestId\nnumber\nThe unique identifier of this request.\nWatcher\nProperties\n-\nentryPath\nstring\nThe path of the entry being observed.\n-\nlastTag\nstring optional\nTag used by the last notification for the watcher.\n-\nrecursive\nboolean\nWhether watching should include all child entries recursively. It can be true for directories only.\nWriteFileRequestedOptions\nProperties\n-\ndata\nArrayBuffer\nBuffer of bytes to be written to the file.\n-\nfileSystemId\nstring\nThe identifier of the file system related to this operation.\n-\noffset\nnumber\nPosition in the file (in bytes) to start writing the bytes from.\n-\nopenRequestId\nnumber\nA request ID used to open the file.\n-\nrequestId\nnumber\nThe unique identifier of this request.\nMethods\nget()\nchrome.fileSystemProvider.get(\nfileSystemId: string,\ncallback?: function,\n)\nReturns information about a file system with the passed fileSystemId\n.\nParameters\n-\nfileSystemId\nstring\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(fileSystem: FileSystemInfo) => void\n-\nfileSystem\n-\nReturns\n-\nPromise<FileSystemInfo>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetAll()\nchrome.fileSystemProvider.getAll(\ncallback?: function,\n)\nReturns all file systems mounted by the extension.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(fileSystems: FileSystemInfo[]) => void\n-\nfileSystems\n-\nReturns\n-\nPromise<FileSystemInfo[]>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nmount()\nchrome.fileSystemProvider.mount(\noptions: MountOptions,\ncallback?: function,\n)\nMounts a file system with the given fileSystemId\nand displayName\n. displayName\nwill be shown in the left panel of the Files app. displayName\ncan contain any characters including '/', but cannot be an empty string. displayName\nmust be descriptive but doesn't have to be unique. The fileSystemId\nmust not be an empty string.\nDepending on the type of the file system being mounted, the source\noption must be set appropriately.\nIn case of an error, runtime.lastError\nwill be set with a corresponding error code.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nnotify()\nchrome.fileSystemProvider.notify(\noptions: NotifyOptions,\ncallback?: function,\n)\nNotifies about changes in the watched directory at observedPath\nin recursive\nmode. If the file system is mounted with supportsNotifyTag\n, then tag\nmust be provided, and all changes since the last notification always reported, even if the system was shutdown. The last tag can be obtained with getAll\n.\nTo use, the file_system_provider.notify\nmanifest option must be set to true.\nValue of tag\ncan be any string which is unique per call, so it's possible to identify the last registered notification. Eg. if the providing extension starts after a reboot, and the last registered notification's tag is equal to \"123\", then it should call notify\nfor all changes which happened since the change tagged as \"123\". It cannot be an empty string.\nNot all providers are able to provide a tag, but if the file system has a changelog, then the tag can be eg. a change number, or a revision number.\nNote that if a parent directory is removed, then all descendant entries are also removed, and if they are watched, then the API must be notified about the fact. Also, if a directory is renamed, then all descendant entries are in fact removed, as there is no entry under their original paths anymore.\nIn case of an error, runtime.lastError\nwill be set will a corresponding error code.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nunmount()\nchrome.fileSystemProvider.unmount(\noptions: UnmountOptions,\ncallback?: function,\n)\nUnmounts a file system with the given fileSystemId\n. It must be called after onUnmountRequested\nis invoked. Also, the providing extension can decide to perform unmounting if not requested (eg. in case of lost connection, or a file error).\nIn case of an error, runtime.lastError\nwill be set with a corresponding error code.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonAbortRequested\nchrome.fileSystemProvider.onAbortRequested.addListener(\ncallback: function,\n)\nRaised when aborting an operation with operationRequestId\nis requested. The operation executed with operationRequestId\nmust be immediately stopped and successCallback\nof this abort request executed. If aborting fails, then errorCallback\nmust be called. Note, that callbacks of the aborted operation must not be called, as they will be ignored. Despite calling errorCallback\n, the request may be forcibly aborted.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(options: AbortRequestedOptions, successCallback: function, errorCallback: function) => void\n-\noptions\n-\nsuccessCallback\nfunction\nThe\nsuccessCallback\nparameter looks like:() => void\n-\nerrorCallback\nfunction\nThe\nerrorCallback\nparameter looks like:(error: ProviderError) => void\n-\nerror\n-\n-\nonAddWatcherRequested\nchrome.fileSystemProvider.onAddWatcherRequested.addListener(\ncallback: function,\n)\nRaised when setting a new directory watcher is requested. If an error occurs, then errorCallback\nmust be called.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(options: AddWatcherRequestedOptions, successCallback: function, errorCallback: function) => void\n-\noptions\n-\nsuccessCallback\nfunction\nThe\nsuccessCallback\nparameter looks like:() => void\n-\nerrorCallback\nfunction\nThe\nerrorCallback\nparameter looks like:(error: ProviderError) => void\n-\nerror\n-\n-\nonCloseFileRequested\nchrome.fileSystemProvider.onCloseFileRequested.addListener(\ncallback: function,\n)\nRaised when opening a file previously opened with openRequestId\nis requested to be closed.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(options: CloseFileRequestedOptions, successCallback: function, errorCallback: function) => void\n-\noptions\n-\nsuccessCallback\nfunction\nThe\nsuccessCallback\nparameter looks like:() => void\n-\nerrorCallback\nfunction\nThe\nerrorCallback\nparameter looks like:(error: ProviderError) => void\n-\nerror\n-\n-\nonConfigureRequested\nchrome.fileSystemProvider.onConfigureRequested.addListener(\ncallback: function,\n)\nRaised when showing a configuration dialog for fileSystemId\nis requested. If it's handled, the file_system_provider.configurable\nmanfiest option must be set to true.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(options: ConfigureRequestedOptions, successCallback: function, errorCallback: function) => void\n-\noptions\n-\nsuccessCallback\nfunction\nThe\nsuccessCallback\nparameter looks like:() => void\n-\nerrorCallback\nfunction\nThe\nerrorCallback\nparameter looks like:(error: ProviderError) => void\n-\nerror\n-\n-\nonCopyEntryRequested\nchrome.fileSystemProvider.onCopyEntryRequested.addListener(\ncallback: function,\n)\nRaised when copying an entry (recursively if a directory) is requested. If an error occurs, then errorCallback\nmust be called.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(options: CopyEntryRequestedOptions, successCallback: function, errorCallback: function) => void\n-\noptions\n-\nsuccessCallback\nfunction\nThe\nsuccessCallback\nparameter looks like:() => void\n-\nerrorCallback\nfunction\nThe\nerrorCallback\nparameter looks like:(error: ProviderError) => void\n-\nerror\n-\n-\nonCreateDirectoryRequested\nchrome.fileSystemProvider.onCreateDirectoryRequested.addListener(\ncallback: function,\n)\nRaised when creating a directory is requested. The operation must fail with the EXISTS error if the target directory already exists. If recursive\nis true, then all of the missing directories on the directory path must be created.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(options: CreateDirectoryRequestedOptions, successCallback: function, errorCallback: function) => void\n-\noptions\n-\nsuccessCallback\nfunction\nThe\nsuccessCallback\nparameter looks like:() => void\n-\nerrorCallback\nfunction\nThe\nerrorCallback\nparameter looks like:(error: ProviderError) => void\n-\nerror\n-\n-\nonCreateFileRequested\nchrome.fileSystemProvider.onCreateFileRequested.addListener(\ncallback: function,\n)\nRaised when creating a file is requested. If the file already exists, then errorCallback\nmust be called with the \"EXISTS\"\nerror code.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(options: CreateFileRequestedOptions, successCallback: function, errorCallback: function) => void\n-\noptions\n-\nsuccessCallback\nfunction\nThe\nsuccessCallback\nparameter looks like:() => void\n-\nerrorCallback\nfunction\nThe\nerrorCallback\nparameter looks like:(error: ProviderError) => void\n-\nerror\n-\n-\nonDeleteEntryRequested\nchrome.fileSystemProvider.onDeleteEntryRequested.addListener(\ncallback: function,\n)\nRaised when deleting an entry is requested. If recursive\nis true, and the entry is a directory, then all of the entries inside must be recursively deleted as well.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(options: DeleteEntryRequestedOptions, successCallback: function, errorCallback: function) => void\n-\noptions\n-\nsuccessCallback\nfunction\nThe\nsuccessCallback\nparameter looks like:() => void\n-\nerrorCallback\nfunction\nThe\nerrorCallback\nparameter looks like:(error: ProviderError) => void\n-\nerror\n-\n-\nonExecuteActionRequested\nchrome.fileSystemProvider.onExecuteActionRequested.addListener(\ncallback: function,\n)\nRaised when executing an action for a set of files or directories is\\ requested. After the action is completed, successCallback\nmust be called. On error, errorCallback\nmust be called.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(options: ExecuteActionRequestedOptions, successCallback: function, errorCallback: function) => void\n-\noptions\n-\nsuccessCallback\nfunction\nThe\nsuccessCallback\nparameter looks like:() => void\n-\nerrorCallback\nfunction\nThe\nerrorCallback\nparameter looks like:(error: ProviderError) => void\n-\nerror\n-\n-\nonGetActionsRequested\nchrome.fileSystemProvider.onGetActionsRequested.addListener(\ncallback: function,\n)\nRaised when a list of actions for a set of files or directories at entryPaths\nis requested. All of the returned actions must be applicable to each entry. If there are no such actions, an empty array should be returned. The actions must be returned with the successCallback\ncall. In case of an error, errorCallback\nmust be called.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(options: GetActionsRequestedOptions, successCallback: function, errorCallback: function) => void\n-\noptions\n-\nsuccessCallback\nfunction\nThe\nsuccessCallback\nparameter looks like:(actions: Action[]) => void\n-\nactions\nAction[]\n-\n-\nerrorCallback\nfunction\nThe\nerrorCallback\nparameter looks like:(error: ProviderError) => void\n-\nerror\n-\n-\nonGetMetadataRequested\nchrome.fileSystemProvider.onGetMetadataRequested.addListener(\ncallback: function,\n)\nRaised when metadata of a file or a directory at entryPath\nis requested. The metadata must be returned with the successCallback\ncall. In case of an error, errorCallback\nmust be called.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(options: GetMetadataRequestedOptions, successCallback: function, errorCallback: function) => void\n-\noptions\n-\nsuccessCallback\nfunction\nThe\nsuccessCallback\nparameter looks like:(metadata: EntryMetadata) => void\n-\nmetadata\n-\n-\nerrorCallback\nfunction\nThe\nerrorCallback\nparameter looks like:(error: ProviderError) => void\n-\nerror\n-\n-\nonMountRequested\nchrome.fileSystemProvider.onMountRequested.addListener(\ncallback: function,\n)\nRaised when showing a dialog for mounting a new file system is requested. If the extension/app is a file handler, then this event shouldn't be handled. Instead app.runtime.onLaunched\nshould be handled in order to mount new file systems when a file is opened. For multiple mounts, the file_system_provider.multiple_mounts\nmanifest option must be set to true.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(successCallback: function, errorCallback: function) => void\n-\nsuccessCallback\nfunction\nThe\nsuccessCallback\nparameter looks like:() => void\n-\nerrorCallback\nfunction\nThe\nerrorCallback\nparameter looks like:(error: ProviderError) => void\n-\nerror\n-\n-\nonMoveEntryRequested\nchrome.fileSystemProvider.onMoveEntryRequested.addListener(\ncallback: function,\n)\nRaised when moving an entry (recursively if a directory) is requested. If an error occurs, then errorCallback\nmust be called.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(options: MoveEntryRequestedOptions, successCallback: function, errorCallback: function) => void\n-\noptions\n-\nsuccessCallback\nfunction\nThe\nsuccessCallback\nparameter looks like:() => void\n-\nerrorCallback\nfunction\nThe\nerrorCallback\nparameter looks like:(error: ProviderError) => void\n-\nerror\n-\n-\nonOpenFileRequested\nchrome.fileSystemProvider.onOpenFileRequested.addListener(\ncallback: function,\n)\nRaised when opening a file at filePath\nis requested. If the file does not exist, then the operation must fail. Maximum number of files opened at once can be specified with MountOptions\n.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(options: OpenFileRequestedOptions, successCallback: function, errorCallback: function) => void\n-\noptions\n-\nsuccessCallback\nfunction\nThe\nsuccessCallback\nparameter looks like:(metadata?: EntryMetadata) => void\n-\nmetadata\nEntryMetadata optional\n-\n-\nerrorCallback\nfunction\nThe\nerrorCallback\nparameter looks like:(error: ProviderError) => void\n-\nerror\n-\n-\nonReadDirectoryRequested\nchrome.fileSystemProvider.onReadDirectoryRequested.addListener(\ncallback: function,\n)\nRaised when contents of a directory at directoryPath\nare requested. The results must be returned in chunks by calling the successCallback\nseveral times. In case of an error, errorCallback\nmust be called.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(options: ReadDirectoryRequestedOptions, successCallback: function, errorCallback: function) => void\n-\noptions\n-\nsuccessCallback\nfunction\nThe\nsuccessCallback\nparameter looks like:(entries: EntryMetadata[], hasMore: boolean) => void\n-\nentries\n-\nhasMore\nboolean\n-\n-\nerrorCallback\nfunction\nThe\nerrorCallback\nparameter looks like:(error: ProviderError) => void\n-\nerror\n-\n-\nonReadFileRequested\nchrome.fileSystemProvider.onReadFileRequested.addListener(\ncallback: function,\n)\nRaised when reading contents of a file opened previously with openRequestId\nis requested. The results must be returned in chunks by calling successCallback\nseveral times. In case of an error, errorCallback\nmust be called.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(options: ReadFileRequestedOptions, successCallback: function, errorCallback: function) => void\n-\noptions\n-\nsuccessCallback\nfunction\nThe\nsuccessCallback\nparameter looks like:(data: ArrayBuffer, hasMore: boolean) => void\n-\ndata\nArrayBuffer\n-\nhasMore\nboolean\n-\n-\nerrorCallback\nfunction\nThe\nerrorCallback\nparameter looks like:(error: ProviderError) => void\n-\nerror\n-\n-\nonRemoveWatcherRequested\nchrome.fileSystemProvider.onRemoveWatcherRequested.addListener(\ncallback: function,\n)\nRaised when the watcher should be removed. If an error occurs, then errorCallback\nmust be called.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(options: RemoveWatcherRequestedOptions, successCallback: function, errorCallback: function) => void\n-\noptions\n-\nsuccessCallback\nfunction\nThe\nsuccessCallback\nparameter looks like:() => void\n-\nerrorCallback\nfunction\nThe\nerrorCallback\nparameter looks like:(error: ProviderError) => void\n-\nerror\n-\n-\nonTruncateRequested\nchrome.fileSystemProvider.onTruncateRequested.addListener(\ncallback: function,\n)\nRaised when truncating a file to a desired length is requested. If an error occurs, then errorCallback\nmust be called.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(options: TruncateRequestedOptions, successCallback: function, errorCallback: function) => void\n-\noptions\n-\nsuccessCallback\nfunction\nThe\nsuccessCallback\nparameter looks like:() => void\n-\nerrorCallback\nfunction\nThe\nerrorCallback\nparameter looks like:(error: ProviderError) => void\n-\nerror\n-\n-\nonUnmountRequested\nchrome.fileSystemProvider.onUnmountRequested.addListener(\ncallback: function,\n)\nRaised when unmounting for the file system with the fileSystemId\nidentifier is requested. In the response, the unmount\nAPI method must be called together with successCallback\n. If unmounting is not possible (eg. due to a pending operation), then errorCallback\nmust be called.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(options: UnmountRequestedOptions, successCallback: function, errorCallback: function) => void\n-\noptions\n-\nsuccessCallback\nfunction\nThe\nsuccessCallback\nparameter looks like:() => void\n-\nerrorCallback\nfunction\nThe\nerrorCallback\nparameter looks like:(error: ProviderError) => void\n-\nerror\n-\n-\nonWriteFileRequested\nchrome.fileSystemProvider.onWriteFileRequested.addListener(\ncallback: function,\n)\nRaised when writing contents to a file opened previously with openRequestId\nis requested.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(options: WriteFileRequestedOptions, successCallback: function, errorCallback: function) => void\n-\noptions\n-\nsuccessCallback\nfunction\nThe\nsuccessCallback\nparameter looks like:() => void\n-\nerrorCallback\nfunction\nThe\nerrorCallback\nparameter looks like:(error: ProviderError) => void\n-\nerror\n-\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/fontSettings", "title": "chrome.fontSettings | API | Chrome for Developers", "text": "Description\nUse the chrome.fontSettings\nAPI to manage Chrome's font settings.\nPermissions\nfontSettings\nTo use the Font Settings API, you must declare the \"fontSettings\"\npermission in the extension\nmanifest. For example:\n{\n\"name\": \"My Font Settings Extension\",\n\"description\": \"Customize your fonts\",\n\"version\": \"0.2\",\n\"permissions\": [\n\"fontSettings\"\n],\n...\n}\nConcepts and usage\nChrome allows for some font settings to depend on certain generic font families and language scripts. For example, the font used for sans-serif Simplified Chinese may be different than the font used for serif Japanese.\nThe generic font families supported by Chrome are based on CSS generic font families and are\nlisted under GenericReference\n. When a web page specifies a generic font family, Chrome selects\nthe font based on the corresponding setting. If no generic font family is specified, Chrome uses the\nsetting for the \"standard\" generic font family.\nWhen a web page specifies a language, Chrome selects the font based on the setting for the corresponding language script. If no language is specified, Chrome uses the setting for the default, or global, script.\nThe supported language scripts are specified by ISO 15924 script code and listed under\nScriptCode\n. Technically, Chrome settings are not strictly per-script but also depend on\nlanguage. For example, Chrome chooses the font for Cyrillic (ISO 15924 script code \"Cyrl\") when a\nweb page specifies the Russian language, and uses this font not just for Cyrillic script but for\neverything the font covers, such as Latin.\nExamples\nThe following code gets the standard font for Arabic.\nchrome.fontSettings.getFont(\n{ genericFamily: 'standard', script: 'Arab' },\nfunction(details) { console.log(details.fontId); }\n);\nThe next snippet sets the sans-serif font for Japanese.\nchrome.fontSettings.setFont(\n{ genericFamily: 'sansserif', script: 'Jpan', fontId: 'MS PGothic' }\n);\nTo try this API, install the fontSettings API example from the chrome-extension-samples repository.\nTypes\nFontName\nRepresents a font name.\nProperties\n-\ndisplayName\nstring\nThe display name of the font.\n-\nfontId\nstring\nThe font ID.\nGenericFamily\nA CSS generic font family.\nEnum\n\"standard\" \"sansserif\" \"serif\" \"fixed\" \"cursive\" \"fantasy\" \"math\"\nLevelOfControl\nOne of\nnot\\_controllable\n: cannot be controlled by any extension\ncontrolled\\_by\\_other\\_extensions\n: controlled by extensions with higher precedence\ncontrollable\\_by\\_this\\_extension\n: can be controlled by this extension\ncontrolled\\_by\\_this\\_extension\n: controlled by this extension\nEnum\n\"not_controllable\" \"controlled_by_other_extensions\" \"controllable_by_this_extension\" \"controlled_by_this_extension\"\nScriptCode\nAn ISO 15924 script code. The default, or global, script is represented by script code \"Zyyy\".\nEnum\n\"Afak\" \"Arab\" \"Armi\" \"Armn\" \"Avst\" \"Bali\" \"Bamu\" \"Bass\" \"Batk\" \"Beng\" \"Blis\" \"Bopo\" \"Brah\" \"Brai\" \"Bugi\" \"Buhd\" \"Cakm\" \"Cans\" \"Cari\" \"Cham\" \"Cher\" \"Cirt\" \"Copt\" \"Cprt\" \"Cyrl\" \"Cyrs\" \"Deva\" \"Dsrt\" \"Dupl\" \"Egyd\" \"Egyh\" \"Egyp\" \"Elba\" \"Ethi\" \"Geor\" \"Geok\" \"Glag\" \"Goth\" \"Gran\" \"Grek\" \"Gujr\" \"Guru\" \"Hang\" \"Hani\" \"Hano\" \"Hans\" \"Hant\" \"Hebr\" \"Hluw\" \"Hmng\" \"Hung\" \"Inds\" \"Ital\" \"Java\" \"Jpan\" \"Jurc\" \"Kali\" \"Khar\" \"Khmr\" \"Khoj\" \"Knda\" \"Kpel\" \"Kthi\" \"Lana\" \"Laoo\" \"Latf\" \"Latg\" \"Latn\" \"Lepc\" \"Limb\" \"Lina\" \"Linb\" \"Lisu\" \"Loma\" \"Lyci\" \"Lydi\" \"Mand\" \"Mani\" \"Maya\" \"Mend\" \"Merc\" \"Mero\" \"Mlym\" \"Moon\" \"Mong\" \"Mroo\" \"Mtei\" \"Mymr\" \"Narb\" \"Nbat\" \"Nkgb\" \"Nkoo\" \"Nshu\" \"Ogam\" \"Olck\" \"Orkh\" \"Orya\" \"Osma\" \"Palm\" \"Perm\" \"Phag\" \"Phli\" \"Phlp\" \"Phlv\" \"Phnx\" \"Plrd\" \"Prti\" \"Rjng\" \"Roro\" \"Runr\" \"Samr\" \"Sara\" \"Sarb\" \"Saur\" \"Sgnw\" \"Shaw\" \"Shrd\" \"Sind\" \"Sinh\" \"Sora\" \"Sund\" \"Sylo\" \"Syrc\" \"Syre\" \"Syrj\" \"Syrn\" \"Tagb\" \"Takr\" \"Tale\" \"Talu\" \"Taml\" \"Tang\" \"Tavt\" \"Telu\" \"Teng\" \"Tfng\" \"Tglg\" \"Thaa\" \"Thai\" \"Tibt\" \"Tirh\" \"Ugar\" \"Vaii\" \"Visp\" \"Wara\" \"Wole\" \"Xpeo\" \"Xsux\" \"Yiii\" \"Zmth\" \"Zsym\" \"Zyyy\"\nMethods\nclearDefaultFixedFontSize()\nchrome.fontSettings.clearDefaultFixedFontSize(\ndetails?: object,\ncallback?: function,\n)\nClears the default fixed font size set by this extension, if any.\nParameters\n-\ndetails\nobject optional\nThis parameter is currently unused.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nclearDefaultFontSize()\nchrome.fontSettings.clearDefaultFontSize(\ndetails?: object,\ncallback?: function,\n)\nClears the default font size set by this extension, if any.\nParameters\n-\ndetails\nobject optional\nThis parameter is currently unused.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nclearFont()\nchrome.fontSettings.clearFont(\ndetails: object,\ncallback?: function,\n)\nClears the font set by this extension, if any.\nParameters\n-\ndetails\nobject\n-\ngenericFamily\nThe generic font family for which the font should be cleared.\n-\nscript\nScriptCode optional\nThe script for which the font should be cleared. If omitted, the global script font setting is cleared.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nclearMinimumFontSize()\nchrome.fontSettings.clearMinimumFontSize(\ndetails?: object,\ncallback?: function,\n)\nClears the minimum font size set by this extension, if any.\nParameters\n-\ndetails\nobject optional\nThis parameter is currently unused.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetDefaultFixedFontSize()\nchrome.fontSettings.getDefaultFixedFontSize(\ndetails?: object,\ncallback?: function,\n)\nGets the default size for fixed width fonts.\nParameters\n-\ndetails\nobject optional\nThis parameter is currently unused.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nlevelOfControl\nThe level of control this extension has over the setting.\n-\npixelSize\nnumber\nThe font size in pixels.\n-\n-\nReturns\n-\nPromise<object>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetDefaultFontSize()\nchrome.fontSettings.getDefaultFontSize(\ndetails?: object,\ncallback?: function,\n)\nGets the default font size.\nParameters\n-\ndetails\nobject optional\nThis parameter is currently unused.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nlevelOfControl\nThe level of control this extension has over the setting.\n-\npixelSize\nnumber\nThe font size in pixels.\n-\n-\nReturns\n-\nPromise<object>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetFont()\nchrome.fontSettings.getFont(\ndetails: object,\ncallback?: function,\n)\nGets the font for a given script and generic font family.\nParameters\n-\ndetails\nobject\n-\ngenericFamily\nThe generic font family for which the font should be retrieved.\n-\nscript\nScriptCode optional\nThe script for which the font should be retrieved. If omitted, the font setting for the global script (script code \"Zyyy\") is retrieved.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nfontId\nstring\nThe font ID. Rather than the literal font ID preference value, this may be the ID of the font that the system resolves the preference value to. So,\nfontId\ncan differ from the font passed tosetFont\n, if, for example, the font is not available on the system. The empty string signifies fallback to the global script font setting. -\nlevelOfControl\nThe level of control this extension has over the setting.\n-\n-\nReturns\n-\nPromise<object>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetFontList()\nchrome.fontSettings.getFontList(\ncallback?: function,\n)\nGets a list of fonts on the system.\nParameters\nReturns\n-\nPromise<FontName[]>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetMinimumFontSize()\nchrome.fontSettings.getMinimumFontSize(\ndetails?: object,\ncallback?: function,\n)\nGets the minimum font size.\nParameters\n-\ndetails\nobject optional\nThis parameter is currently unused.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nlevelOfControl\nThe level of control this extension has over the setting.\n-\npixelSize\nnumber\nThe font size in pixels.\n-\n-\nReturns\n-\nPromise<object>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetDefaultFixedFontSize()\nchrome.fontSettings.setDefaultFixedFontSize(\ndetails: object,\ncallback?: function,\n)\nSets the default size for fixed width fonts.\nParameters\n-\ndetails\nobject\n-\npixelSize\nnumber\nThe font size in pixels.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetDefaultFontSize()\nchrome.fontSettings.setDefaultFontSize(\ndetails: object,\ncallback?: function,\n)\nSets the default font size.\nParameters\n-\ndetails\nobject\n-\npixelSize\nnumber\nThe font size in pixels.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetFont()\nchrome.fontSettings.setFont(\ndetails: object,\ncallback?: function,\n)\nSets the font for a given script and generic font family.\nParameters\n-\ndetails\nobject\n-\nfontId\nstring\nThe font ID. The empty string means to fallback to the global script font setting.\n-\ngenericFamily\nThe generic font family for which the font should be set.\n-\nscript\nScriptCode optional\nThe script code which the font should be set. If omitted, the font setting for the global script (script code \"Zyyy\") is set.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetMinimumFontSize()\nchrome.fontSettings.setMinimumFontSize(\ndetails: object,\ncallback?: function,\n)\nSets the minimum font size.\nParameters\n-\ndetails\nobject\n-\npixelSize\nnumber\nThe font size in pixels.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonDefaultFixedFontSizeChanged\nchrome.fontSettings.onDefaultFixedFontSizeChanged.addListener(\ncallback: function,\n)\nFired when the default fixed font size setting changes.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nlevelOfControl\nThe level of control this extension has over the setting.\n-\npixelSize\nnumber\nThe font size in pixels.\n-\n-\nonDefaultFontSizeChanged\nchrome.fontSettings.onDefaultFontSizeChanged.addListener(\ncallback: function,\n)\nFired when the default font size setting changes.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nlevelOfControl\nThe level of control this extension has over the setting.\n-\npixelSize\nnumber\nThe font size in pixels.\n-\n-\nonFontChanged\nchrome.fontSettings.onFontChanged.addListener(\ncallback: function,\n)\nFired when a font setting changes.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nfontId\nstring\nThe font ID. See the description in\ngetFont\n. -\ngenericFamily\nThe generic font family for which the font setting has changed.\n-\nlevelOfControl\nThe level of control this extension has over the setting.\n-\nscript\nScriptCode optional\nThe script code for which the font setting has changed.\n-\n-\nonMinimumFontSizeChanged\nchrome.fontSettings.onMinimumFontSizeChanged.addListener(\ncallback: function,\n)\nFired when the minimum font size setting changes.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nlevelOfControl\nThe level of control this extension has over the setting.\n-\npixelSize\nnumber\nThe font size in pixels.\n-\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/gcm", "title": "chrome.gcm | API | Chrome for Developers", "text": "Description\nUse chrome.gcm\nto enable apps and extensions to send and receive messages through Firebase Cloud Messaging (FCM).\nPermissions\ngcm\nProperties\nMAX_MESSAGE_SIZE\nThe maximum size (in bytes) of all key/value pairs in a message.\nValue\n4096\nMethods\nregister()\nchrome.gcm.register(\nsenderIds: string[],\ncallback?: function,\n)\nRegisters the application with FCM. The registration ID will be returned by the callback\n. If register\nis called again with the same list of senderIds\n, the same registration ID will be returned.\nParameters\n-\nsenderIds\nstring[]\nA list of server IDs that are allowed to send messages to the application. It should contain at least one and no more than 100 sender IDs.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(registrationId: string) => void\n-\nregistrationId\nstring\nA registration ID assigned to the application by the FCM.\n-\nReturns\n-\nPromise<string>\nChrome 116+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsend()\nchrome.gcm.send(\nmessage: object,\ncallback?: function,\n)\nSends a message according to its contents.\nParameters\n-\nmessage\nobject\nA message to send to the other party via FCM.\n-\ndata\nobject\nMessage data to send to the server. Case-insensitive\ngoog.\nandgoogle\n, as well as case-sensitivecollapse_key\nare disallowed as key prefixes. Sum of all key/value pairs should not exceedgcm.MAX_MESSAGE_SIZE\n. -\ndestinationId\nstring\nThe ID of the server to send the message to as assigned by Google API Console.\n-\nmessageId\nstring\nThe ID of the message. It must be unique for each message in scope of the applications. See the Cloud Messaging documentation for advice for picking and handling an ID.\n-\ntimeToLive\nnumber optional\nTime-to-live of the message in seconds. If it is not possible to send the message within that time, an onSendError event will be raised. A time-to-live of 0 indicates that the message should be sent immediately or fail if it's not possible. The default value of time-to-live is 86,400 seconds (1 day) and the maximum value is 2,419,200 seconds (28 days).\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(messageId: string) => void\n-\nmessageId\nstring\nThe ID of the message that the callback was issued for.\n-\nReturns\n-\nPromise<string>\nChrome 116+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nunregister()\nchrome.gcm.unregister(\ncallback?: function,\n)\nUnregisters the application from FCM.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 116+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonMessage\nchrome.gcm.onMessage.addListener(\ncallback: function,\n)\nFired when a message is received through FCM.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(message: object) => void\n-\nmessage\nobject\n-\ncollapseKey\nstring optional\nThe collapse key of a message. See the Non-collapsible and collapsible messages for details.\n-\ndata\nobject\nThe message data.\n-\nfrom\nstring optional\nThe sender who issued the message.\n-\n-\nonMessagesDeleted\nchrome.gcm.onMessagesDeleted.addListener(\ncallback: function,\n)\nFired when a FCM server had to delete messages sent by an app server to the application. See Lifetime of a message for details on handling this event.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonSendError\nchrome.gcm.onSendError.addListener(\ncallback: function,\n)\nFired when it was not possible to send a message to the FCM server.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(error: object) => void\n-\nerror\nobject\n-\ndetails\nobject\nAdditional details related to the error, when available.\n-\nerrorMessage\nstring\nThe error message describing the problem.\n-\nmessageId\nstring optional\nThe ID of the message with this error, if error is related to a specific message.\n-\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/history", "title": "chrome.history | API | Chrome for Developers", "text": "Description\nUse the chrome.history\nAPI to interact with the browser's record of visited pages. You can add, remove, and query for URLs in the browser's history. To override the history page with your own version, see Override Pages.\nPermissions\nhistory\nTo interact with the user's browser history, use the history API.\nTo use the history API, declare the \"history\"\npermission in the extension manifest. For\nexample:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"history\"\n],\n...\n}\nConcepts and usage\nTransition types\nThe history API uses transition types to describe how the browser navigated to a particular URL on a particular visit. For example, if a user visits a page by clicking a link on another page, the transition type is \"link\". See the reference content for a list of transition types.\nExamples\nTo try this API, install the history API example from the chrome-extension-samples repository.\nTypes\nHistoryItem\nAn object encapsulating one result of a history query.\nProperties\n-\nid\nstring\nThe unique identifier for the item.\n-\nlastVisitTime\nnumber optional\nWhen this page was last loaded, represented in milliseconds since the epoch.\n-\ntitle\nstring optional\nThe title of the page when it was last loaded.\n-\ntypedCount\nnumber optional\nThe number of times the user has navigated to this page by typing in the address.\n-\nurl\nstring optional\nThe URL navigated to by a user.\n-\nvisitCount\nnumber optional\nThe number of times the user has navigated to this page.\nEnum\n\"link\" \"typed\" \"auto_bookmark\" \"auto_subframe\" \"manual_subframe\" \"generated\" \"auto_toplevel\" \"form_submit\" \"reload\" \"keyword\" \"keyword_generated\"\nThe user arrived at this page by clicking a link on another page.\nThe user arrived at this page by typing the URL in the address bar. This is also used for other explicit navigation actions.\nThe user arrived at this page through a suggestion in the UI, for example, through a menu item.\nThe user arrived at this page through subframe navigation that they didn't request, such as through an ad loading in a frame on the previous page. These don't always generate new navigation entries in the back and forward menus.\nThe user arrived at this page by selecting something in a subframe.\nThe user arrived at this page by typing in the address bar and selecting an entry that didn't look like a URL, such as a Google Search suggestion. For example, a match might have the URL of a Google Search result page, but it might appear to the user as \"Search Google for ...\". These are different from typed navigations because the user didn't type or see the destination URL. They're also related to keyword navigations.\nThe page was specified in the command line or is the start page.\nThe user arrived at this page by filling out values in a form and submitting the form. Not all form submissions use this transition type.\nThe user reloaded the page, either by clicking the reload button or by pressing Enter in the address bar. Session restore and Reopen closed tab also use this transition type.\nThe URL for this page was generated from a replaceable keyword other than the default search provider.\nCorresponds to a visit generated for a keyword.\nUrlDetails\nProperties\n-\nurl\nstring\nThe URL for the operation. It must be in the format as returned from a call to\nhistory.search()\n.\nVisitItem\nAn object encapsulating one visit to a URL.\nProperties\n-\nid\nstring\nThe unique identifier for the corresponding\nhistory.HistoryItem\n. -\nisLocal\nboolean\nChrome 115+True if the visit originated on this device. False if it was synced from a different device.\n-\nreferringVisitId\nstring\nThe visit ID of the referrer.\n-\ntransition\nThe transition type for this visit from its referrer.\n-\nvisitId\nstring\nThe unique identifier for this visit.\n-\nvisitTime\nnumber optional\nWhen this visit occurred, represented in milliseconds since the epoch.\nMethods\naddUrl()\nchrome.history.addUrl(\ndetails: UrlDetails,\ncallback?: function,\n)\nAdds a URL to the history at the current time with a transition type of \"link\".\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ndeleteAll()\nchrome.history.deleteAll(\ncallback?: function,\n)\nDeletes all items from the history.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ndeleteRange()\nchrome.history.deleteRange(\nrange: object,\ncallback?: function,\n)\nRemoves all items within the specified date range from the history. Pages will not be removed from the history unless all visits fall within the range.\nParameters\n-\nrange\nobject\n-\nendTime\nnumber\nItems added to history before this date, represented in milliseconds since the epoch.\n-\nstartTime\nnumber\nItems added to history after this date, represented in milliseconds since the epoch.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ndeleteUrl()\nchrome.history.deleteUrl(\ndetails: UrlDetails,\ncallback?: function,\n)\nRemoves all occurrences of the given URL from the history.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetVisits()\nchrome.history.getVisits(\ndetails: UrlDetails,\ncallback?: function,\n)\nRetrieves information about visits to a URL.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(results: VisitItem[]) => void\n-\nresults\n-\nReturns\n-\nPromise<VisitItem[]>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsearch()\nchrome.history.search(\nquery: object,\ncallback?: function,\n)\nSearches the history for the last visit time of each page matching the query.\nParameters\n-\nquery\nobject\n-\nendTime\nnumber optional\nLimit results to those visited before this date, represented in milliseconds since the epoch.\n-\nmaxResults\nnumber optional\nThe maximum number of results to retrieve. Defaults to 100.\n-\nstartTime\nnumber optional\nLimit results to those visited after this date, represented in milliseconds since the epoch. If property is not specified, it will default to 24 hours.\n-\ntext\nstring\nA free-text query to the history service. Leave this empty to retrieve all pages.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(results: HistoryItem[]) => void\n-\nresults\n-\nReturns\n-\nPromise<HistoryItem[]>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonVisited\nchrome.history.onVisited.addListener(\ncallback: function,\n)\nFired when a URL is visited, providing the HistoryItem\ndata for that URL. This event fires before the page has loaded.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(result: HistoryItem) => void\n-\nresult\n-\nonVisitRemoved\nchrome.history.onVisitRemoved.addListener(\ncallback: function,\n)\nFired when one or more URLs are removed from history. When all visits have been removed the URL is purged from history.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(removed: object) => void\n-\nremoved\nobject\n-\nallHistory\nboolean\nTrue if all history was removed. If true, then urls will be empty.\n-\nurls\nstring[] optional\n-\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/i18n", "title": "chrome.i18n | API | Chrome for Developers", "text": "Description\nUse the chrome.i18n\ninfrastructure to implement internationalization across your whole app or extension.\nManifest\nIf an extension has a /_locales\ndirectory, the manifest must define \"default_locale\"\n.\nConcepts and usage\nYou need to put all of its user-visible strings into a file named messages.json\n. Each time\nyou add a new locale, you add a messages file under a directory named /_locales/_localeCode_\n, where\nlocaleCode is a code such as en\nfor English.\nHere's the file hierarchy for an internationalized extension that supports English (en\n), Spanish\n(es\n), and Korean (ko\n):\nSupport multiple languages\nSay you have an extension with the files shown in the following figure:\nTo internationalize this extension, you name each user-visible string and put it into a messages file. The extension's manifest, CSS files, and JavaScript code use each string's name to get its localized version.\nHere's what the extension looks like when it's internationalized (note that it still has only English strings):\nSome notes about internationalizing:\n- You can use any of the supported locales. If you use an unsupported locale, Google Chrome ignores it.\nIn\nmanifest.json\nand CSS files, refer to a string named messagename like this:__MSG_messagename__\nIn your extension or app's JavaScript code, refer to a string named messagename like this:\nchrome.i18n.getMessage(\"messagename\")\nIn each call to\ngetMessage()\n, you can supply up to 9 strings to be included in the message. See Examples: getMessage for details.Some messages, such as\n@@bidi_dir\nand@@ui_locale\n, are provided by the internationalization system. See the Predefined messages section for a full list of predefined message names.In\nmessages.json\n, each user-visible string has a name, a \"message\" item, and an optional \"description\" item. The name is a key such as \"extName\" or \"search_string\" that identifies the string. The \"message\" specifies the value of the string in this locale. The optional \"description\" provides help to translators, who might not be able to see how the string is used in your extension. For example:{ \"search_string\": { \"message\": \"hello%20world\", \"description\": \"The string we search for. Put %20 between words that go together.\" }, ... }\nFor more information, see Formats: Locale-Specific Messages.\nOnce an extension is internationalized, translating it is straightforward. You copy messages.json\n,\ntranslate it, and put the copy into a new directory under /_locales\n. For example, to support\nSpanish, just put a translated copy of messages.json\nunder /_locales/es\n. The following figure\nshows the previous extension with a new Spanish translation.\nPredefined messages\nThe internationalization system provides a few predefined messages to help you localize. These\ninclude @@ui_locale\n, so you can detect the current UI locale, and a few @@bidi_...\nmessages that\nlet you detect the text direction. The latter messages have similar names to constants in the\ngadgets BIDI (bi-directional) API.\nThe special message @@extension_id\ncan be used in the CSS and JavaScript files, whether or not the\nextension or app is localized. This message doesn't work in manifest files.\nThe following table describes each predefined message.\n| Message name | Description |\n|---|---|\n@@extension_id | The extension or app ID; you might use this string to construct URLs for resources inside the extension. Even unlocalized extensions can use this message. Note: You can't use this message in a manifest file. |\n@@ui_locale | The current locale; you might use this string to construct locale-specific URLs. |\n@@bidi_dir | The text direction for the current locale, either \"ltr\" for left-to-right languages such as English or \"rtl\" for right-to-left languages such as Arabic. |\n@@bidi_reversed_dir | If the @@bidi_dir is \"ltr\", then this is \"rtl\"; otherwise, it's \"ltr\". |\n@@bidi_start_edge | If the @@bidi_dir is \"ltr\", then this is \"left\"; otherwise, it's \"right\". |\n@@bidi_end_edge | If the @@bidi_dir is \"ltr\", then this is \"right\"; otherwise, it's \"left\". |\nHere's an example of using @@extension_id\nin a CSS file to construct a URL:\nbody {\nbackground-image:url('chrome-extension://__MSG_@@extension_id__/background.png');\n}\nIf the extension ID is abcdefghijklmnopqrstuvwxyzabcdef, then the bold line in the previous code snippet becomes:\nbackground-image:url('chrome-extension://abcdefghijklmnopqrstuvwxyzabcdef/background.png');\nHere's an example of using @@bidi_*\nmessages in a CSS file:\nbody {\ndirection: __MSG_@@bidi_dir__;\n}\ndiv#header {\nmargin-bottom: 1.05em;\noverflow: hidden;\npadding-bottom: 1.5em;\npadding-__MSG_@@bidi_start_edge__: 0;\npadding-__MSG_@@bidi_end_edge__: 1.5em;\nposition: relative;\n}\nFor left-to-right languages such as English, the bold lines become:\ndir: ltr;\npadding-left: 0;\npadding-right: 1.5em;\nLocales\nYou can choose from many locales, including some (such as en\n) that let a single translation support multiple variations of a language (such as en_GB\nand en_US\n).\nYou can localize your extension to any locale that is supported by the Chrome Web Store. If your locale is not listed here, choose the closest alternative. For example, if the default locale of your extension is \"de_CH\"\n, choose \"de\"\nin the Chrome Web Store.\n| Locale code | Language (region) |\n|---|---|\n| ar | Arabic |\n| am | Amharic |\n| bg | Bulgarian |\n| bn | Bengali |\n| ca | Catalan |\n| cs | Czech |\n| da | Danish |\n| de | German |\n| el | Greek |\n| en | English |\n| en_AU | English (Australia) |\n| en_GB | English (Great Britain) |\n| en_US | English (USA) |\n| es | Spanish |\n| es_419 | Spanish (Latin America and Caribbean) |\n| et | Estonian |\n| fa | Persian |\n| fi | Finnish |\n| fil | Filipino |\n| fr | French |\n| gu | Gujarati |\n| he | Hebrew |\n| hi | Hindi |\n| hr | Croatian |\n| hu | Hungarian |\n| id | Indonesian |\n| it | Italian |\n| ja | Japanese |\n| kn | Kannada |\n| ko | Korean |\n| lt | Lithuanian |\n| lv | Latvian |\n| ml | Malayalam |\n| mr | Marathi |\n| ms | Malay |\n| nl | Dutch |\n| no | Norwegian |\n| pl | Polish |\n| pt_BR | Portuguese (Brazil) |\n| pt_PT | Portuguese (Portugal) |\n| ro | Romanian |\n| ru | Russian |\n| sk | Slovak |\n| sl | Slovenian |\n| sr | Serbian |\n| sv | Swedish |\n| sw | Swahili |\n| ta | Tamil |\n| te | Telugu |\n| th | Thai |\n| tr | Turkish |\n| uk | Ukrainian |\n| vi | Vietnamese |\n| zh_CN | Chinese (China) |\n| zh_TW | Chinese (Taiwan) |\nSearch for messages\nYou don't have to define every string for every supported locale. As long as the default locale's\nmessages.json\nfile has a value for every string, your extension or app will run no matter how\nsparse a translation is. Here's how the extension system searches for a message:\n- Search the messages file (if any) for the user's preferred locale. For example, when Google\nChrome's locale is set to British English (\nen_GB\n), the system first looks for the message in/_locales/en_GB/messages.json\n. If that file exists and the message is there, the system looks no further. - If the user's preferred locale has a region (that is, the locale has an underscore: _), search\nthe locale without that region. For example, if the\nen_GB\nmessages file doesn't exist or doesn't contain the message, the system looks in theen\nmessages file. If that file exists and the message is there, the system looks no further. - Search the messages file for the default locale. For example, if the extension's\n\"default_locale\" is set to \"es\", and neither\n/_locales/en_GB/messages.json\nnor/_locales/en/messages.json\ncontains the message, the extension uses the message from/_locales/es/messages.json\n.\nIn the following figure, the message named \"colores\" is in all three locales that the extension supports, but \"extName\" is in only two of the locales. Wherever a user running Google Chrome in US English sees the label \"Colors\", a user of British English sees \"Colours\". Both US English and British English users see the extension name \"Hello World\". Because the default language is Spanish, users running Google Chrome in any non-English language see the label \"Colores\" and the extension name \"Hola mundo\".\nSet your browser's locale\nTo test translations, you might want to set your browser's locale. This section tells you how to set the locale in Windows, Mac OS, Linux, and ChromeOS.\nWindows\nYou can change the locale using either a locale-specific shortcut or the Google Chrome UI. The shortcut approach is quicker, once you've set it up, and it lets you use several languages at once.\nUse a locale-specific shortcut\nTo create and use a shortcut that launches Google Chrome with a particular locale:\n- Make a copy of the Google Chrome shortcut that's already on your desktop.\n- Rename the new shortcut to match the new locale.\nChange the shortcut's properties so that the Target field specifies the\n--lang\nand--user-data-dir\nflags. The target should look something like this:path_to_chrome.exe --lang=locale --user-data-dir=c:\\locale_profile_dir\nLaunch Google Chrome by double-clicking the shortcut.\nFor example, to create a shortcut that launches Google Chrome in Spanish (es\n), you might create a\nshortcut named chrome-es\nthat has the following target:\npath_to_chrome.exe --lang=es --user-data-dir=c:\\chrome-profile-es\nYou can create as many shortcuts as you like, making it straightforward to test in multiple languages. For example:\npath_to_chrome.exe --lang=en --user-data-dir=c:\\chrome-profile-en\npath_to_chrome.exe --lang=en_GB --user-data-dir=c:\\chrome-profile-en_GB\npath_to_chrome.exe --lang=ko --user-data-dir=c:\\chrome-profile-ko\nUse the UI\nHere's how to change the locale using the UI on Google Chrome for Windows:\n- App icon > Options\n- Choose the Under the Hood tab\n- Scroll to Web Content\n- Click Change font and language settings\n- Choose the Languages tab\n- Use the drop down to set the Google Chrome language\n- Restart Chrome\nMac OS\nTo change the locale on Mac, you use the system preferences.\n- From the Apple menu, choose System Preferences\n- Under the Personal section, choose International\n- Choose your language and location\n- Restart Chrome\nLinux\nTo change the locale on Linux, first quit Google Chrome. Then, all in one line, set the LANGUAGE environment variable and launch Google Chrome. For example:\nLANGUAGE=es ./chrome\nChromeOS\nTo change the locale on ChromeOS:\n- From the system tray, choose Settings.\n- Under the Languages and input section, choose the Language drop-down.\n- If your language is not listed, click Add languages and add it.\n- Once added, click the 3-dot More actions menu item next to your language and choose Display ChromeOS in this language.\n- Click the Restart button that appears next to the set language to restart ChromeOS.\nExamples\nYou can find examples of internationalization in the examples/api/i18n directory. For a complete example, see examples/extensions/news. For other examples and for help in viewing the source code, see Samples.\ngetMessage()\nThe following code gets a localized message from the browser and displays it as a string. It replaces two placeholders within the message with the strings \"string1\" and \"string2\".\nfunction getMessage() {\nvar message = chrome.i18n.getMessage(\"click_here\", [\"string1\", \"string2\"]);\ndocument.getElementById(\"languageSpan\").innerHTML = message;\n}\nHere's how you'd supply and use a single string:\n// In JavaScript code\nstatus.innerText = chrome.i18n.getMessage(\"error\", errorDetails);\n\"error\": {\n\"message\": \"Error: $details$\",\n\"description\": \"Generic error template. Expects error parameter to be passed in.\",\n\"placeholders\": {\n\"details\": {\n\"content\": \"$1\",\n\"example\": \"Failed to fetch RSS feed.\"\n}\n}\n}\nFor more information about placeholders, see the Locale-Specific Messages page. For details on\ncalling getMessage()\n, see the API reference.\ngetAcceptLanguages()\nThe following code gets accept-languages from the browser and displays them as a string by separating each accept-language with ','.\nfunction getAcceptLanguages() {\nchrome.i18n.getAcceptLanguages(function(languageList) {\nvar languages = languageList.join(\",\");\ndocument.getElementById(\"languageSpan\").innerHTML = languages;\n})\n}\nFor details on calling getAcceptLanguages()\n, see the API reference.\ndetectLanguage()\nThe following code detects up to 3 languages from the given string and displays the result as strings separated by new lines.\nfunction detectLanguage(inputText) {\nchrome.i18n.detectLanguage(inputText, function(result) {\nvar outputLang = \"Detected Language: \";\nvar outputPercent = \"Language Percentage: \";\nfor(i = 0; i < result.languages.length; i++) {\noutputLang += result.languages[i].language + \" \";\noutputPercent +=result.languages[i].percentage + \" \";\n}\ndocument.getElementById(\"languageSpan\").innerHTML = outputLang + \"\\n\" + outputPercent + \"\\nReliable: \" + result.isReliable;\n});\n}\nFor more details on calling detectLanguage(inputText)\n, see the API reference.\nTypes\nLanguageCode\nAn ISO language code such as en\nor fr\n. For a complete list of languages supported by this method, see kLanguageInfoTable. For an unknown language, und\nwill be returned, which means that [percentage] of the text is unknown to CLD\nType\nstring\nMethods\ndetectLanguage()\nchrome.i18n.detectLanguage(\ntext: string,\ncallback?: function,\n)\nDetects the language of the provided text using CLD.\nParameters\n-\ntext\nstring\nUser input string to be translated.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: object) => void\n-\nresult\nobject\nLanguageDetectionResult object that holds detected langugae reliability and array of DetectedLanguage\n-\nisReliable\nboolean\nCLD detected language reliability\n-\nlanguages\nobject[]\narray of detectedLanguage\n-\nlanguage\nstring\n-\npercentage\nnumber\nThe percentage of the detected language\n-\n-\n-\nReturns\n-\nPromise<object>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetAcceptLanguages()\nchrome.i18n.getAcceptLanguages(\ncallback?: function,\n)\nGets the accept-languages of the browser. This is different from the locale used by the browser; to get the locale, use i18n.getUILanguage\n.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(languages: string[]) => void\n-\nlanguages\nstring[]\nArray of LanguageCode\n-\nReturns\n-\nPromise<LanguageCode[]>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetMessage()\nchrome.i18n.getMessage(\nmessageName: string,\nsubstitutions?: any,\noptions?: object,\n)\nGets the localized string for the specified message. If the message is missing, this method returns an empty string (''). If the format of the getMessage()\ncall is wrong \u2014 for example, messageName is not a string or the substitutions array has more than 9 elements \u2014 this method returns undefined\n.\nParameters\n-\nmessageName\nstring\nThe name of the message, as specified in the\nmessages.json\nfile. -\nsubstitutions\nany optional\nUp to 9 substitution strings, if the message requires any.\n-\noptions\nobject optional\nChrome 79+-\nescapeLt\nboolean optional\nEscape\n<\nin translation to<\n. This applies only to the message itself, not to the placeholders. Developers might want to use this if the translation is used in an HTML context. Closure Templates used with Closure Compiler generate this automatically.\n-\nReturns\n-\nstring\nMessage localized for current locale.\ngetUILanguage()\nchrome.i18n.getUILanguage()\nGets the browser UI language of the browser. This is different from i18n.getAcceptLanguages\nwhich returns the preferred user languages.\nReturns\n-\nstring\nThe browser UI language code such as en-US or fr-FR."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/identity", "title": "chrome.identity | API | Chrome for Developers", "text": "Description\nUse the chrome.identity\nAPI to get OAuth2 access tokens.\nPermissions\nidentity\nTypes\nAccountInfo\nProperties\n-\nid\nstring\nA unique identifier for the account. This ID will not change for the lifetime of the account.\nAccountStatus\nEnum\n\"SYNC\" \"ANY\"\nSpecifies that Sync is enabled for the primary account.\nSpecifies the existence of a primary account, if any.\nGetAuthTokenResult\nProperties\n-\ngrantedScopes\nstring[] optional\nA list of OAuth2 scopes granted to the extension.\n-\ntoken\nstring optional\nThe specific token associated with the request.\nInvalidTokenDetails\nProperties\n-\ntoken\nstring\nThe specific token that should be removed from the cache.\nProfileDetails\nProperties\n-\naccountStatus\nAccountStatus optional\nA status of the primary account signed into a profile whose\nProfileUserInfo\nshould be returned. Defaults toSYNC\naccount status.\nProfileUserInfo\nProperties\n-\nemail\nstring\nAn email address for the user account signed into the current profile. Empty if the user is not signed in or the\nidentity.email\nmanifest permission is not specified. -\nid\nstring\nA unique identifier for the account. This ID will not change for the lifetime of the account. Empty if the user is not signed in or (in M41+) the\nidentity.email\nmanifest permission is not specified.\nTokenDetails\nProperties\n-\naccount\nAccountInfo optional\nThe account ID whose token should be returned. If not specified, the function will use an account from the Chrome profile: the Sync account if there is one, or otherwise the first Google web account.\n-\nenableGranularPermissions\nboolean optional\nChrome 87+The\nenableGranularPermissions\nflag allows extensions to opt-in early to the granular permissions consent screen, in which requested permissions are granted or denied individually. -\ninteractive\nboolean optional\nFetching a token may require the user to sign-in to Chrome, or approve the application's requested scopes. If the interactive flag is\ntrue\n,getAuthToken\nwill prompt the user as necessary. When the flag isfalse\nor omitted,getAuthToken\nwill return failure any time a prompt would be required. -\nscopes\nstring[] optional\nA list of OAuth2 scopes to request.\nWhen the\nscopes\nfield is present, it overrides the list of scopes specified in manifest.json.\nWebAuthFlowDetails\nProperties\n-\nabortOnLoadForNonInteractive\nboolean optional\nChrome 113+Whether to terminate\nlaunchWebAuthFlow\nfor non-interactive requests after the page loads. This parameter does not affect interactive flows.When set to\ntrue\n(default) the flow will terminate immediately after the page loads. When set tofalse\n, the flow will only terminate after thetimeoutMsForNonInteractive\npasses. This is useful for identity providers that use JavaScript to perform redirections after the page loads. -\ninteractive\nboolean optional\nWhether to launch auth flow in interactive mode.\nSince some auth flows may immediately redirect to a result URL,\nlaunchWebAuthFlow\nhides its web view until the first navigation either redirects to the final URL, or finishes loading a page meant to be displayed.If the\ninteractive\nflag istrue\n, the window will be displayed when a page load completes. If the flag isfalse\nor omitted,launchWebAuthFlow\nwill return with an error if the initial navigation does not complete the flow.For flows that use JavaScript for redirection,\nabortOnLoadForNonInteractive\ncan be set tofalse\nin combination with settingtimeoutMsForNonInteractive\nto give the page a chance to perform any redirects. -\ntimeoutMsForNonInteractive\nnumber optional\nChrome 113+The maximum amount of time, in miliseconds,\nlaunchWebAuthFlow\nis allowed to run in non-interactive mode in total. Only has an effect ifinteractive\nisfalse\n. -\nurl\nstring\nThe URL that initiates the auth flow.\nMethods\nclearAllCachedAuthTokens()\nchrome.identity.clearAllCachedAuthTokens(\ncallback?: function,\n)\nResets the state of the Identity API:\n- Removes all OAuth2 access tokens from the token cache\n- Removes user's account preferences\n- De-authorizes the user from all auth flows\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 106+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetAccounts()\nchrome.identity.getAccounts(\ncallback?: function,\n)\nRetrieves a list of AccountInfo objects describing the accounts present on the profile.\ngetAccounts\nis only supported on dev channel.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(accounts: AccountInfo[]) => void\n-\naccounts\n-\nReturns\n-\nPromise<AccountInfo[]>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetAuthToken()\nchrome.identity.getAuthToken(\ndetails?: TokenDetails,\ncallback?: function,\n)\nGets an OAuth2 access token using the client ID and scopes specified in the oauth2\nsection of manifest.json.\nThe Identity API caches access tokens in memory, so it's ok to call getAuthToken\nnon-interactively any time a token is required. The token cache automatically handles expiration.\nFor a good user experience it is important interactive token requests are initiated by UI in your app explaining what the authorization is for. Failing to do this will cause your users to get authorization requests, or Chrome sign in screens if they are not signed in, with with no context. In particular, do not use getAuthToken\ninteractively when your app is first launched.\nNote: When called with a callback, instead of returning an object this function will return the two properties as separate arguments passed to the callback.\nParameters\n-\ndetails\nTokenDetails optional\nToken options.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: GetAuthTokenResult) => void\n-\nresultChrome 105+\n-\nReturns\n-\nPromise<GetAuthTokenResult>\nChrome 105+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetProfileUserInfo()\nchrome.identity.getProfileUserInfo(\ndetails?: ProfileDetails,\ncallback?: function,\n)\nRetrieves email address and obfuscated gaia id of the user signed into a profile.\nRequires the identity.email\nmanifest permission. Otherwise, returns an empty result.\nThis API is different from identity.getAccounts in two ways. The information returned is available offline, and it only applies to the primary account for the profile.\nParameters\n-\ndetails\nProfileDetails optional\nChrome 84+Profile options.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(userInfo: ProfileUserInfo) => void\n-\nuserInfo\n-\nReturns\n-\nPromise<ProfileUserInfo>\nChrome 106+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetRedirectURL()\nchrome.identity.getRedirectURL(\npath?: string,\n)\nGenerates a redirect URL to be used in launchWebAuthFlow\n.\nThe generated URLs match the pattern https://<app-id>.chromiumapp.org/*\n.\nParameters\n-\npath\nstring optional\nThe path appended to the end of the generated URL.\nReturns\n-\nstring\nlaunchWebAuthFlow()\nchrome.identity.launchWebAuthFlow(\ndetails: WebAuthFlowDetails,\ncallback?: function,\n)\nStarts an auth flow at the specified URL.\nThis method enables auth flows with non-Google identity providers by launching a web view and navigating it to the first URL in the provider's auth flow. When the provider redirects to a URL matching the pattern https://<app-id>.chromiumapp.org/*\n, the window will close, and the final redirect URL will be passed to the callback\nfunction.\nFor a good user experience it is important interactive auth flows are initiated by UI in your app explaining what the authorization is for. Failing to do this will cause your users to get authorization requests with no context. In particular, do not launch an interactive auth flow when your app is first launched.\nParameters\n-\ndetails\nWebAuth flow options.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(responseUrl?: string) => void\n-\nresponseUrl\nstring optional\n-\nReturns\n-\nPromise<string | undefined>\nChrome 106+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveCachedAuthToken()\nchrome.identity.removeCachedAuthToken(\ndetails: InvalidTokenDetails,\ncallback?: function,\n)\nRemoves an OAuth2 access token from the Identity API's token cache.\nIf an access token is discovered to be invalid, it should be passed to removeCachedAuthToken to remove it from the cache. The app may then retrieve a fresh token with getAuthToken\n.\nParameters\n-\ndetails\nToken information.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 106+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonSignInChanged\nchrome.identity.onSignInChanged.addListener(\ncallback: function,\n)\nFired when signin state changes for an account on the user's profile.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(account: AccountInfo, signedIn: boolean) => void\n-\naccount\n-\nsignedIn\nboolean\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/idle", "title": "chrome.idle | API | Chrome for Developers", "text": "Description\nUse the chrome.idle\nAPI to detect when the machine's idle state changes.\nPermissions\nidle\nYou must declare the \"idle\"\npermission in your extension's manifest to use the idle API. For\nexample:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"idle\"\n],\n...\n}\nTypes\nIdleState\nEnum\n\"active\" \"idle\" \"locked\"\nMethods\ngetAutoLockDelay()\nchrome.idle.getAutoLockDelay(\ncallback?: function,\n)\nGets the time, in seconds, it takes until the screen is locked automatically while idle. Returns a zero duration if the screen is never locked automatically. Currently supported on Chrome OS only.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(delay: number) => void\n-\ndelay\nnumber\nTime, in seconds, until the screen is locked automatically while idle. This is zero if the screen never locks automatically.\n-\nReturns\n-\nPromise<number>\nChrome 116+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nqueryState()\nchrome.idle.queryState(\ndetectionIntervalInSeconds: number,\ncallback?: function,\n)\nReturns \"locked\" if the system is locked, \"idle\" if the user has not generated any input for a specified number of seconds, or \"active\" otherwise.\nParameters\n-\ndetectionIntervalInSeconds\nnumber\nThe system is considered idle if detectionIntervalInSeconds seconds have elapsed since the last user input detected.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(newState: IdleState) => void\n-\nnewState\n-\nReturns\n-\nPromise<IdleState>\nChrome 116+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetDetectionInterval()\nchrome.idle.setDetectionInterval(\nintervalInSeconds: number,\n)\nSets the interval, in seconds, used to determine when the system is in an idle state for onStateChanged events. The default interval is 60 seconds.\nParameters\n-\nintervalInSeconds\nnumber\nThreshold, in seconds, used to determine when the system is in an idle state.\nEvents\nonStateChanged\nchrome.idle.onStateChanged.addListener(\ncallback: function,\n)\nFired when the system changes to an active, idle or locked state. The event fires with \"locked\" if the screen is locked or the screensaver activates, \"idle\" if the system is unlocked and the user has not generated any input for a specified number of seconds, and \"active\" when the user generates input on an idle system."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/input/ime", "title": "chrome.input.ime | API | Chrome for Developers", "text": "Description\nUse the chrome.input.ime\nAPI to implement a custom IME for Chrome OS. This allows your extension to handle keystrokes, set the composition, and manage the candidate window.\nPermissions\ninput\nYou must declare the \"input\" permission in the extension manifest to use the input.ime API. For example:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"input\"\n],\n...\n}\nAvailability\nExamples\nThe following code creates an IME that converts typed letters to upper case.\nvar context_id = -1;\nchrome.input.ime.onFocus.addListener(function(context) {\ncontext_id = context.contextID;\n});\nchrome.input.ime.onKeyEvent.addListener(\nfunction(engineID, keyData) {\nif (keyData.type == \"keydown\" && keyData.key.match(/^[a-z]$/)) {\nchrome.input.ime.commitText({\"contextID\": context_id,\n\"text\": keyData.key.toUpperCase()});\nreturn true;\n} else {\nreturn false;\n}\n}\n);\nTypes\nAssistiveWindowButton\nID of buttons in assistive window.\nEnum\n\"undo\" \"addToDictionary\"\nAssistiveWindowProperties\nProperties of the assistive window.\nProperties\n-\nannounceString\nstring optional\nStrings for ChromeVox to announce.\n-\ntype\n\"undo\"\n-\nvisible\nboolean\nSets true to show AssistiveWindow, sets false to hide.\nAssistiveWindowType\nType of assistive window.\nValue\n\"undo\"\nAutoCapitalizeType\nThe auto-capitalize type of the text field.\nEnum\n\"characters\" \"words\" \"sentences\"\nInputContext\nDescribes an input Context\nProperties\n-\nautoCapitalizeChrome 69+\nThe auto-capitalize type of the text field.\n-\nautoComplete\nboolean\nWhether the text field wants auto-complete.\n-\nautoCorrect\nboolean\nWhether the text field wants auto-correct.\n-\ncontextID\nnumber\nThis is used to specify targets of text field operations. This ID becomes invalid as soon as onBlur is called.\n-\nshouldDoLearning\nboolean\nChrome 68+Whether text entered into the text field should be used to improve typing suggestions for the user.\n-\nspellCheck\nboolean\nWhether the text field wants spell-check.\n-\ntype\nType of value this text field edits, (Text, Number, URL, etc)\nInputContextType\nType of value this text field edits, (Text, Number, URL, etc)\nEnum\n\"text\" \"search\" \"tel\" \"url\" \"email\" \"number\" \"password\" \"null\"\nKeyboardEvent\nSee http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent\nProperties\n-\naltKey\nboolean optional\nWhether or not the ALT key is pressed.\n-\naltgrKey\nboolean optional\nChrome 79+Whether or not the ALTGR key is pressed.\n-\ncapsLock\nboolean optional\nWhether or not the CAPS_LOCK is enabled.\n-\ncode\nstring\nValue of the physical key being pressed. The value is not affected by current keyboard layout or modifier state.\n-\nctrlKey\nboolean optional\nWhether or not the CTRL key is pressed.\n-\nextensionId\nstring optional\nThe extension ID of the sender of this keyevent.\n-\nkey\nstring\nValue of the key being pressed\n-\nkeyCode\nnumber optional\nThe deprecated HTML keyCode, which is system- and implementation-dependent numerical code signifying the unmodified identifier associated with the key pressed.\n-\nrequestId\nstring optional\n(Deprecated) The ID of the request. Use the\nrequestId\nparam from theonKeyEvent\nevent instead. -\nshiftKey\nboolean optional\nWhether or not the SHIFT key is pressed.\n-\ntype\nOne of keyup or keydown.\nKeyboardEventType\nEnum\n\"keyup\" \"keydown\"\nMenuItem\nA menu item used by an input method to interact with the user from the language menu.\nProperties\n-\nchecked\nboolean optional\nIndicates this item should be drawn with a check.\n-\nenabled\nboolean optional\nIndicates this item is enabled.\n-\nid\nstring\nString that will be passed to callbacks referencing this MenuItem.\n-\nlabel\nstring optional\nText displayed in the menu for this item.\n-\nstyle\nMenuItemStyle optional\nThe type of menu item.\n-\nvisible\nboolean optional\nIndicates this item is visible.\nMenuItemStyle\nThe type of menu item. Radio buttons between separators are considered grouped.\nEnum\n\"check\" \"radio\" \"separator\"\nMenuParameters\nProperties\n-\nengineID\nstring\nID of the engine to use.\n-\nitems\nMenuItem[]\nMenuItems to add or update. They will be added in the order they exist in the array.\nMouseButton\nWhich mouse buttons was clicked.\nEnum\n\"left\" \"middle\" \"right\"\nScreenType\nThe screen type under which the IME is activated.\nEnum\n\"normal\" \"login\" \"lock\" \"secondary-login\"\nUnderlineStyle\nThe type of the underline to modify this segment.\nEnum\n\"underline\" \"doubleUnderline\" \"noUnderline\"\nWindowPosition\nWhere to display the candidate window. If set to 'cursor', the window follows the cursor. If set to 'composition', the window is locked to the beginning of the composition.\nEnum\n\"cursor\" \"composition\"\nMethods\nclearComposition()\nchrome.input.ime.clearComposition(\nparameters: object,\ncallback?: function,\n)\nClear the current composition. If this extension does not own the active IME, this fails.\nParameters\n-\nparameters\nobject\n-\ncontextID\nnumber\nID of the context where the composition will be cleared\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(success: boolean) => void\n-\nsuccess\nboolean\n-\nReturns\n-\nPromise<boolean>\nChrome 111+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ncommitText()\nchrome.input.ime.commitText(\nparameters: object,\ncallback?: function,\n)\nCommits the provided text to the current input.\nParameters\n-\nparameters\nobject\n-\ncontextID\nnumber\nID of the context where the text will be committed\n-\ntext\nstring\nThe text to commit\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(success: boolean) => void\n-\nsuccess\nboolean\n-\nReturns\n-\nPromise<boolean>\nChrome 111+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ndeleteSurroundingText()\nchrome.input.ime.deleteSurroundingText(\nparameters: object,\ncallback?: function,\n)\nDeletes the text around the caret.\nParameters\n-\nparameters\nobject\n-\ncontextID\nnumber\nID of the context where the surrounding text will be deleted.\n-\nengineID\nstring\nID of the engine receiving the event.\n-\nlength\nnumber\nThe number of characters to be deleted\n-\noffset\nnumber\nThe offset from the caret position where deletion will start. This value can be negative.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 111+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nhideInputView()\nchrome.input.ime.hideInputView()\nHides the input view window, which is popped up automatically by system. If the input view window is already hidden, this function will do nothing.\nkeyEventHandled()\nchrome.input.ime.keyEventHandled(\nrequestId: string,\nresponse: boolean,\n)\nIndicates that the key event received by onKeyEvent is handled. This should only be called if the onKeyEvent listener is asynchronous.\nParameters\n-\nrequestId\nstring\nRequest id of the event that was handled. This should come from keyEvent.requestId\n-\nresponse\nboolean\nTrue if the keystroke was handled, false if not\nsendKeyEvents()\nchrome.input.ime.sendKeyEvents(\nparameters: object,\ncallback?: function,\n)\nSends the key events. This function is expected to be used by virtual keyboards. When key(s) on a virtual keyboard is pressed by a user, this function is used to propagate that event to the system.\nParameters\n-\nparameters\nobject\n-\ncontextID\nnumber\nID of the context where the key events will be sent, or zero to send key events to non-input field.\n-\nkeyData\nData on the key event.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 111+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetAssistiveWindowButtonHighlighted()\nchrome.input.ime.setAssistiveWindowButtonHighlighted(\nparameters: object,\ncallback?: function,\n)\nHighlights/Unhighlights a button in an assistive window.\nParameters\n-\nparameters\nobject\n-\nannounceString\nstring optional\nThe text for the screenreader to announce.\n-\nbuttonID\nThe ID of the button\n-\ncontextID\nnumber\nID of the context owning the assistive window.\n-\nhighlighted\nboolean\nWhether the button should be highlighted.\n-\nwindowType\n\"undo\"\nThe window type the button belongs to.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 111+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetAssistiveWindowProperties()\nchrome.input.ime.setAssistiveWindowProperties(\nparameters: object,\ncallback?: function,\n)\nShows/Hides an assistive window with the given properties.\nParameters\n-\nparameters\nobject\n-\ncontextID\nnumber\nID of the context owning the assistive window.\n-\nproperties\nProperties of the assistive window.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(success: boolean) => void\n-\nsuccess\nboolean\n-\nReturns\n-\nPromise<boolean>\nChrome 111+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetCandidates()\nchrome.input.ime.setCandidates(\nparameters: object,\ncallback?: function,\n)\nSets the current candidate list. This fails if this extension doesn't own the active IME\nParameters\n-\nparameters\nobject\n-\ncandidates\nobject[]\nList of candidates to show in the candidate window\n-\nannotation\nstring optional\nAdditional text describing the candidate\n-\ncandidate\nstring\nThe candidate\n-\nid\nnumber\nThe candidate's id\n-\nlabel\nstring optional\nShort string displayed to next to the candidate, often the shortcut key or index\n-\nparentId\nnumber optional\nThe id to add these candidates under\n-\nusage\nobject optional\nThe usage or detail description of word.\n-\nbody\nstring\nThe body string of detail description.\n-\ntitle\nstring\nThe title string of details description.\n-\n-\n-\ncontextID\nnumber\nID of the context that owns the candidate window.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(success: boolean) => void\n-\nsuccess\nboolean\n-\nReturns\n-\nPromise<boolean>\nChrome 111+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetCandidateWindowProperties()\nchrome.input.ime.setCandidateWindowProperties(\nparameters: object,\ncallback?: function,\n)\nSets the properties of the candidate window. This fails if the extension doesn't own the active IME\nParameters\n-\nparameters\nobject\n-\nengineID\nstring\nID of the engine to set properties on.\n-\nproperties\nobject\n-\nauxiliaryText\nstring optional\nText that is shown at the bottom of the candidate window.\n-\nauxiliaryTextVisible\nboolean optional\nTrue to display the auxiliary text, false to hide it.\n-\ncurrentCandidateIndex\nnumber optional\nChrome 84+The index of the current chosen candidate out of total candidates.\n-\ncursorVisible\nboolean optional\nTrue to show the cursor, false to hide it.\n-\npageSize\nnumber optional\nThe number of candidates to display per page.\n-\ntotalCandidates\nnumber optional\nChrome 84+The total number of candidates for the candidate window.\n-\nvertical\nboolean optional\nTrue if the candidate window should be rendered vertical, false to make it horizontal.\n-\nvisible\nboolean optional\nTrue to show the Candidate window, false to hide it.\n-\nwindowPosition\nWindowPosition optional\nWhere to display the candidate window.\n-\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(success: boolean) => void\n-\nsuccess\nboolean\n-\nReturns\n-\nPromise<boolean>\nChrome 111+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetComposition()\nchrome.input.ime.setComposition(\nparameters: object,\ncallback?: function,\n)\nSet the current composition. If this extension does not own the active IME, this fails.\nParameters\n-\nparameters\nobject\n-\ncontextID\nnumber\nID of the context where the composition text will be set\n-\ncursor\nnumber\nPosition in the text of the cursor.\n-\nsegments\nobject[] optional\nList of segments and their associated types.\n-\nend\nnumber\nIndex of the character to end this segment after.\n-\nstart\nnumber\nIndex of the character to start this segment at\n-\nstyle\nThe type of the underline to modify this segment.\n-\n-\nselectionEnd\nnumber optional\nPosition in the text that the selection ends at.\n-\nselectionStart\nnumber optional\nPosition in the text that the selection starts at.\n-\ntext\nstring\nText to set\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(success: boolean) => void\n-\nsuccess\nboolean\n-\nReturns\n-\nPromise<boolean>\nChrome 111+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetCursorPosition()\nchrome.input.ime.setCursorPosition(\nparameters: object,\ncallback?: function,\n)\nSet the position of the cursor in the candidate window. This is a no-op if this extension does not own the active IME.\nParameters\n-\nparameters\nobject\n-\ncandidateID\nnumber\nID of the candidate to select.\n-\ncontextID\nnumber\nID of the context that owns the candidate window.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(success: boolean) => void\n-\nsuccess\nboolean\n-\nReturns\n-\nPromise<boolean>\nChrome 111+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetMenuItems()\nchrome.input.ime.setMenuItems(\nparameters: MenuParameters,\ncallback?: function,\n)\nAdds the provided menu items to the language menu when this IME is active.\nParameters\n-\nparameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 111+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdateMenuItems()\nchrome.input.ime.updateMenuItems(\nparameters: MenuParameters,\ncallback?: function,\n)\nUpdates the state of the MenuItems specified\nParameters\n-\nparameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 111+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonActivate\nchrome.input.ime.onActivate.addListener(\ncallback: function,\n)\nThis event is sent when an IME is activated. It signals that the IME will be receiving onKeyPress events.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(engineID: string, screen: ScreenType) => void\n-\nengineID\nstring\n-\nscreen\n-\nonAssistiveWindowButtonClicked\nchrome.input.ime.onAssistiveWindowButtonClicked.addListener(\ncallback: function,\n)\nThis event is sent when a button in an assistive window is clicked.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nbuttonID\nThe ID of the button clicked.\n-\nwindowType\nThe type of the assistive window.\n-\n-\nonBlur\nchrome.input.ime.onBlur.addListener(\ncallback: function,\n)\nThis event is sent when focus leaves a text box. It is sent to all extensions that are listening to this event, and enabled by the user.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(contextID: number) => void\n-\ncontextID\nnumber\n-\nonCandidateClicked\nchrome.input.ime.onCandidateClicked.addListener(\ncallback: function,\n)\nThis event is sent if this extension owns the active IME.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(engineID: string, candidateID: number, button: MouseButton) => void\n-\nengineID\nstring\n-\ncandidateID\nnumber\n-\nbutton\n-\nonDeactivated\nchrome.input.ime.onDeactivated.addListener(\ncallback: function,\n)\nThis event is sent when an IME is deactivated. It signals that the IME will no longer be receiving onKeyPress events.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(engineID: string) => void\n-\nengineID\nstring\n-\nonFocus\nchrome.input.ime.onFocus.addListener(\ncallback: function,\n)\nThis event is sent when focus enters a text box. It is sent to all extensions that are listening to this event, and enabled by the user.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(context: InputContext) => void\n-\ncontext\n-\nonInputContextUpdate\nchrome.input.ime.onInputContextUpdate.addListener(\ncallback: function,\n)\nThis event is sent when the properties of the current InputContext change, such as the the type. It is sent to all extensions that are listening to this event, and enabled by the user.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(context: InputContext) => void\n-\ncontext\n-\nonKeyEvent\nchrome.input.ime.onKeyEvent.addListener(\ncallback: function,\n)\nFired when a key event is sent from the operating system. The event will be sent to the extension if this extension owns the active IME. The listener function should return true if the event was handled false if it was not. If the event will be evaluated asynchronously, this function must return undefined and the IME must later call keyEventHandled() with the result.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(engineID: string, keyData: KeyboardEvent, requestId: string) => boolean | undefined\n-\nengineID\nstring\n-\nkeyData\n-\nrequestId\nstring\n-\nreturns\nboolean | undefined\n-\nonMenuItemActivated\nchrome.input.ime.onMenuItemActivated.addListener(\ncallback: function,\n)\nCalled when the user selects a menu item\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(engineID: string, name: string) => void\n-\nengineID\nstring\n-\nname\nstring\n-\nonReset\nchrome.input.ime.onReset.addListener(\ncallback: function,\n)\nThis event is sent when chrome terminates ongoing text input session.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(engineID: string) => void\n-\nengineID\nstring\n-\nonSurroundingTextChanged\nchrome.input.ime.onSurroundingTextChanged.addListener(\ncallback: function,\n)\nCalled when the editable string around caret is changed or when the caret position is moved. The text length is limited to 100 characters for each back and forth direction.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(engineID: string, surroundingInfo: object) => void\n-\nengineID\nstring\n-\nsurroundingInfo\nobject\n-\nanchor\nnumber\nThe beginning position of the selection. This value indicates caret position if there is no selection.\n-\nfocus\nnumber\nThe ending position of the selection. This value indicates caret position if there is no selection.\n-\noffset\nnumber\nChrome 46+The offset position of\ntext\n. Sincetext\nonly includes a subset of text around the cursor, offset indicates the absolute position of the first character oftext\n. -\ntext\nstring\nThe text around the cursor. This is only a subset of all text in the input field.\n-\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/instanceID", "title": "chrome.instanceID | API | Chrome for Developers", "text": "Description\nUse chrome.instanceID\nto access the Instance ID service.\nPermissions\ngcm\nAvailability\nMethods\ndeleteID()\nchrome.instanceID.deleteID(\ncallback?: function,\n)\nResets the app instance identifier and revokes all tokens associated with it.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ndeleteToken()\nchrome.instanceID.deleteToken(\ndeleteTokenParams: object,\ncallback?: function,\n)\nRevokes a granted token.\nParameters\n-\ndeleteTokenParams\nobject\nParameters for deleteToken.\n-\nauthorizedEntity\nstring\nChrome 46+The authorized entity that is used to obtain the token.\n-\nscope\nstring\nChrome 46+The scope that is used to obtain the token.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetCreationTime()\nchrome.instanceID.getCreationTime(\ncallback?: function,\n)\nRetrieves the time when the InstanceID has been generated. The creation time will be returned by the callback\n.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(creationTime: number) => void\n-\ncreationTime\nnumber\nThe time when the Instance ID has been generated, represented in milliseconds since the epoch.\n-\nReturns\n-\nPromise<number>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetID()\nchrome.instanceID.getID(\ncallback?: function,\n)\nRetrieves an identifier for the app instance. The instance ID will be returned by the callback\n. The same ID will be returned as long as the application identity has not been revoked or expired.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(instanceID: string) => void\n-\ninstanceID\nstring\nAn Instance ID assigned to the app instance.\n-\nReturns\n-\nPromise<string>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetToken()\nchrome.instanceID.getToken(\ngetTokenParams: object,\ncallback?: function,\n)\nReturn a token that allows the authorized entity to access the service defined by scope.\nParameters\n-\ngetTokenParams\nobject\nParameters for getToken.\n-\nauthorizedEntity\nstring\nChrome 46+Identifies the entity that is authorized to access resources associated with this Instance ID. It can be a project ID from Google developer console.\n-\noptions\nobject optional\nChrome 46+ Deprecated since Chrome 89options are deprecated and will be ignored.\nAllows including a small number of string key/value pairs that will be associated with the token and may be used in processing the request.\n-\nscope\nstring\nChrome 46+Identifies authorized actions that the authorized entity can take. E.g. for sending GCM messages,\nGCM\nscope should be used.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(token: string) => void\n-\ntoken\nstring\nA token assigned by the requested service.\n-\nReturns\n-\nPromise<string>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonTokenRefresh\nchrome.instanceID.onTokenRefresh.addListener(\ncallback: function,\n)\nFired when all the granted tokens need to be refreshed.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/loginState", "title": "chrome.loginState | API | Chrome for Developers", "text": "Description\nUse the chrome.loginState\nAPI to read and monitor the login state.\nPermissions\nloginState\nAvailability\nTypes\nProfileType\nEnum\n\"SIGNIN_PROFILE\" \"USER_PROFILE\"\nSpecifies that the extension is in the signin profile.\nSpecifies that the extension is in the user profile.\nSessionState\nEnum\n\"UNKNOWN\" \"IN_OOBE_SCREEN\" \"IN_LOGIN_SCREEN\" \"IN_SESSION\" \"IN_LOCK_SCREEN\" \"IN_RMA_SCREEN\"\nSpecifies that the session state is unknown.\nSpecifies that the user is in the out-of-box-experience screen.\nSpecifies that the user is in the login screen.\nSpecifies that the user is in the session.\nSpecifies that the user is in the lock screen.\nSpecifies that the device is in RMA mode, finalizing repairs.\nMethods\ngetProfileType()\nchrome.loginState.getProfileType(\ncallback?: function,\n)\nGets the type of the profile the extension is in.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: ProfileType) => void\n-\nresult\n-\nReturns\n-\nPromise<ProfileType>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetSessionState()\nchrome.loginState.getSessionState(\ncallback?: function,\n)\nGets the current session state.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: SessionState) => void\n-\nresult\n-\nReturns\n-\nPromise<SessionState>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonSessionStateChanged\nchrome.loginState.onSessionStateChanged.addListener(\ncallback: function,\n)\nDispatched when the session state changes. sessionState\nis the new session state.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(sessionState: SessionState) => void\n-\nsessionState\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/management", "title": "chrome.management | API | Chrome for Developers", "text": "Description\nThe chrome.management\nAPI provides ways to manage installed apps and extensions.\nPermissions\nmanagement\nYou must declare the \"management\" permission in the extension manifest to use the management API. For example:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"management\"\n],\n...\n}\nmanagement.getPermissionWarningsByManifest()\n, management.uninstallSelf()\n, and\nmanagement.getSelf()\ndo not require the management permission.\nTypes\nExtensionDisabledReason\nA reason the item is disabled.\nEnum\n\"unknown\" \"permissions_increase\"\nExtensionInfo\nInformation about an installed extension, app, or theme.\nProperties\n-\nappLaunchUrl\nstring optional\nThe launch url (only present for apps).\n-\navailableLaunchTypes\nLaunchType[] optional\nThe currently available launch types (only present for apps).\n-\ndescription\nstring\nThe description of this extension, app, or theme.\n-\ndisabledReason\nExtensionDisabledReason optional\nA reason the item is disabled.\n-\nenabled\nboolean\nWhether it is currently enabled or disabled.\n-\nhomepageUrl\nstring optional\nThe URL of the homepage of this extension, app, or theme.\n-\nhostPermissions\nstring[]\nReturns a list of host based permissions.\n-\nicons\nIconInfo[] optional\nA list of icon information. Note that this just reflects what was declared in the manifest, and the actual image at that url may be larger or smaller than what was declared, so you might consider using explicit width and height attributes on img tags referencing these images. See the manifest documentation on icons for more details.\n-\nid\nstring\nThe extension's unique identifier.\n-\ninstallType\nHow the extension was installed.\n-\nisApp\nboolean\nDeprecatedPlease use\nmanagement.ExtensionInfo.type\n.True if this is an app.\n-\nlaunchType\nLaunchType optional\nThe app launch type (only present for apps).\n-\nmayDisable\nboolean\nWhether this extension can be disabled or uninstalled by the user.\n-\nmayEnable\nboolean optional\nChrome 62+Whether this extension can be enabled by the user. This is only returned for extensions which are not enabled.\n-\nname\nstring\nThe name of this extension, app, or theme.\n-\nofflineEnabled\nboolean\nWhether the extension, app, or theme declares that it supports offline.\n-\noptionsUrl\nstring\nThe url for the item's options page, if it has one.\n-\npermissions\nstring[]\nReturns a list of API based permissions.\n-\nshortName\nstring\nA short version of the name of this extension, app, or theme.\n-\ntype\nThe type of this extension, app, or theme.\n-\nupdateUrl\nstring optional\nThe update URL of this extension, app, or theme.\n-\nversion\nstring\nThe version of this extension, app, or theme.\n-\nversionName\nstring optional\nChrome 50+The version name of this extension, app, or theme if the manifest specified one.\nExtensionInstallType\nHow the extension was installed. One of\nadmin\n: The extension was installed because of an administrative policy,\ndevelopment\n: The extension was loaded unpacked in developer mode,\nnormal\n: The extension was installed normally via a .crx file,\nsideload\n: The extension was installed by other software on the machine,\nother\n: The extension was installed by other means.\nEnum\n\"admin\" \"development\" \"normal\" \"sideload\" \"other\"\nExtensionType\nThe type of this extension, app, or theme.\nEnum\n\"extension\" \"hosted_app\" \"packaged_app\" \"legacy_packaged_app\" \"theme\" \"login_screen_extension\"\nIconInfo\nInformation about an icon belonging to an extension, app, or theme.\nProperties\n-\nsize\nnumber\nA number representing the width and height of the icon. Likely values include (but are not limited to) 128, 48, 24, and 16.\n-\nurl\nstring\nThe URL for this icon image. To display a grayscale version of the icon (to indicate that an extension is disabled, for example), append\n?grayscale=true\nto the URL.\nLaunchType\nThese are all possible app launch types.\nEnum\n\"OPEN_AS_REGULAR_TAB\" \"OPEN_AS_PINNED_TAB\" \"OPEN_AS_WINDOW\" \"OPEN_FULL_SCREEN\"\nUninstallOptions\nOptions for how to handle the extension's uninstallation.\nProperties\n-\nshowConfirmDialog\nboolean optional\nWhether or not a confirm-uninstall dialog should prompt the user. Defaults to false for self uninstalls. If an extension uninstalls another extension, this parameter is ignored and the dialog is always shown.\nMethods\ncreateAppShortcut()\nchrome.management.createAppShortcut(\nid: string,\ncallback?: function,\n)\nDisplay options to create shortcuts for an app. On Mac, only packaged app shortcuts can be created.\nParameters\n-\nid\nstring\nThis should be the id from an app item of\nmanagement.ExtensionInfo\n. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngenerateAppForLink()\nchrome.management.generateAppForLink(\nurl: string,\ntitle: string,\ncallback?: function,\n)\nGenerate an app for a URL. Returns the generated bookmark app.\nParameters\n-\nurl\nstring\nThe URL of a web page. The scheme of the URL can only be \"http\" or \"https\".\n-\ntitle\nstring\nThe title of the generated app.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: ExtensionInfo) => void\n-\nresult\n-\nReturns\n-\nPromise<ExtensionInfo>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nget()\nchrome.management.get(\nid: string,\ncallback?: function,\n)\nReturns information about the installed extension, app, or theme that has the given ID.\nParameters\n-\nid\nstring\nThe ID from an item of\nmanagement.ExtensionInfo\n. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: ExtensionInfo) => void\n-\nresult\n-\nReturns\n-\nPromise<ExtensionInfo>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetAll()\nchrome.management.getAll(\ncallback?: function,\n)\nReturns a list of information about installed extensions and apps.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: ExtensionInfo[]) => void\n-\nresult\n-\nReturns\n-\nPromise<ExtensionInfo[]>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetPermissionWarningsById()\nchrome.management.getPermissionWarningsById(\nid: string,\ncallback?: function,\n)\nReturns a list of permission warnings for the given extension id.\nParameters\n-\nid\nstring\nThe ID of an already installed extension.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(permissionWarnings: string[]) => void\n-\npermissionWarnings\nstring[]\n-\nReturns\n-\nPromise<string[]>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetPermissionWarningsByManifest()\nchrome.management.getPermissionWarningsByManifest(\nmanifestStr: string,\ncallback?: function,\n)\nReturns a list of permission warnings for the given extension manifest string. Note: This function can be used without requesting the 'management' permission in the manifest.\nParameters\n-\nmanifestStr\nstring\nExtension manifest JSON string.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(permissionWarnings: string[]) => void\n-\npermissionWarnings\nstring[]\n-\nReturns\n-\nPromise<string[]>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetSelf()\nchrome.management.getSelf(\ncallback?: function,\n)\nReturns information about the calling extension, app, or theme. Note: This function can be used without requesting the 'management' permission in the manifest.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: ExtensionInfo) => void\n-\nresult\n-\nReturns\n-\nPromise<ExtensionInfo>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ninstallReplacementWebApp()\nchrome.management.installReplacementWebApp(\ncallback?: function,\n)\nLaunches the replacement_web_app specified in the manifest. Prompts the user to install if not already installed.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nlaunchApp()\nchrome.management.launchApp(\nid: string,\ncallback?: function,\n)\nLaunches an application.\nParameters\n-\nid\nstring\nThe extension id of the application.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetEnabled()\nchrome.management.setEnabled(\nid: string,\nenabled: boolean,\ncallback?: function,\n)\nEnables or disables an app or extension. In most cases this function must be called in the context of a user gesture (e.g. an onclick handler for a button), and may present the user with a native confirmation UI as a way of preventing abuse.\nParameters\n-\nid\nstring\nThis should be the id from an item of\nmanagement.ExtensionInfo\n. -\nenabled\nboolean\nWhether this item should be enabled or disabled.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetLaunchType()\nchrome.management.setLaunchType(\nid: string,\nlaunchType: LaunchType,\ncallback?: function,\n)\nSet the launch type of an app.\nParameters\n-\nid\nstring\nThis should be the id from an app item of\nmanagement.ExtensionInfo\n. -\nlaunchType\nThe target launch type. Always check and make sure this launch type is in\nExtensionInfo.availableLaunchTypes\n, because the available launch types vary on different platforms and configurations. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nuninstall()\nchrome.management.uninstall(\nid: string,\noptions?: UninstallOptions,\ncallback?: function,\n)\nUninstalls a currently installed app or extension. Note: This function does not work in managed environments when the user is not allowed to uninstall the specified extension/app. If the uninstall fails (e.g. the user cancels the dialog) the promise will be rejected or the callback will be called with runtime.lastError\nset.\nParameters\n-\nid\nstring\nThis should be the id from an item of\nmanagement.ExtensionInfo\n. -\noptions\nUninstallOptions optional\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nuninstallSelf()\nchrome.management.uninstallSelf(\noptions?: UninstallOptions,\ncallback?: function,\n)\nUninstalls the calling extension. Note: This function can be used without requesting the 'management' permission in the manifest. This function does not work in managed environments when the user is not allowed to uninstall the specified extension/app.\nParameters\n-\noptions\nUninstallOptions optional\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonDisabled\nchrome.management.onDisabled.addListener(\ncallback: function,\n)\nFired when an app or extension has been disabled.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(info: ExtensionInfo) => void\n-\ninfo\n-\nonEnabled\nchrome.management.onEnabled.addListener(\ncallback: function,\n)\nFired when an app or extension has been enabled.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(info: ExtensionInfo) => void\n-\ninfo\n-\nonInstalled\nchrome.management.onInstalled.addListener(\ncallback: function,\n)\nFired when an app or extension has been installed.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(info: ExtensionInfo) => void\n-\ninfo\n-\nonUninstalled\nchrome.management.onUninstalled.addListener(\ncallback: function,\n)\nFired when an app or extension has been uninstalled.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(id: string) => void\n-\nid\nstring\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/notifications", "title": "chrome.notifications | API | Chrome for Developers", "text": "Description\nUse the chrome.notifications\nAPI to create rich notifications using templates and show these notifications to users in the system tray.\nPermissions\nnotifications\nTypes\nNotificationBitmap\nNotificationButton\nProperties\n-\niconUrl\nstring optional\nDeprecated since Chrome 59Button icons not visible for Mac OS X users.\n-\ntitle\nstring\nNotificationItem\nProperties\n-\nmessage\nstring\nAdditional details about this item.\n-\ntitle\nstring\nTitle of one item of a list notification.\nNotificationOptions\nProperties\n-\nappIconMaskUrl\nstring optional\nDeprecated since Chrome 59The app icon mask is not visible for Mac OS X users.\nA URL to the app icon mask. URLs have the same restrictions as iconUrl.\nThe app icon mask should be in alpha channel, as only the alpha channel of the image will be considered.\n-\nbuttons\nNotificationButton[] optional\nText and icons for up to two notification action buttons.\n-\ncontextMessage\nstring optional\nAlternate notification content with a lower-weight font.\n-\neventTime\nnumber optional\nA timestamp associated with the notification, in milliseconds past the epoch (e.g.\nDate.now() + n\n). -\niconUrl\nstring optional\nA URL to the sender's avatar, app icon, or a thumbnail for image notifications.\nURLs can be a data URL, a blob URL, or a URL relative to a resource within this extension's .crx file\n**Note:**This value is required for the\nnotifications.create\n()\nmethod. -\nimageUrl\nstring optional\nDeprecated since Chrome 59The image is not visible for Mac OS X users.\nA URL to the image thumbnail for image-type notifications. URLs have the same restrictions as iconUrl.\n-\nisClickable\nboolean optional\nDeprecated since Chrome 67This UI hint is ignored as of Chrome 67\n-\nitems\nNotificationItem[] optional\nItems for multi-item notifications. Users on Mac OS X only see the first item.\n-\nmessage\nstring optional\nMain notification content.\n**Note:**This value is required for the\nnotifications.create\n()\nmethod. -\npriority\nnumber optional\nPriority ranges from -2 to 2. -2 is lowest priority. 2 is highest. Zero is default. On platforms that don't support a notification center (Windows, Linux & Mac), -2 and -1 result in an error as notifications with those priorities will not be shown at all.\n-\nprogress\nnumber optional\nCurrent progress ranges from 0 to 100.\n-\nrequireInteraction\nboolean optional\nChrome 50+Indicates that the notification should remain visible on screen until the user activates or dismisses the notification. This defaults to false.\n-\nsilent\nboolean optional\nChrome 70+Indicates that no sounds or vibrations should be made when the notification is being shown. This defaults to false.\n-\ntitle\nstring optional\nTitle of the notification (e.g. sender name for email).\n**Note:**This value is required for the\nnotifications.create\n()\nmethod. -\ntype\nTemplateType optional\nWhich type of notification to display. Required for\nnotifications.create\nmethod.\nPermissionLevel\nEnum\n\"granted\" \"denied\"\nSpecifies that the user has elected to show notifications from the app or extension. This is the default at install time.\nSpecifies that the user has elected not to show notifications from the app or extension.\nTemplateType\nEnum\n\"basic\" \"image\" \"list\" \"progress\"\nContains an icon, title, message, expandedMessage, and up to two buttons.\nContains an icon, title, message, expandedMessage, image, and up to two buttons.\nContains an icon, title, message, items, and up to two buttons. Users on Mac OS X only see the first item.\nContains an icon, title, message, progress, and up to two buttons.\nMethods\nclear()\nchrome.notifications.clear(\nnotificationId: string,\ncallback?: function,\n)\nClears the specified notification.\nParameters\n-\nnotificationId\nstring\nThe id of the notification to be cleared. This is returned by\nnotifications.create\nmethod. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(wasCleared: boolean) => void\n-\nwasCleared\nboolean\n-\nReturns\n-\nPromise<boolean>\nChrome 116+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ncreate()\nchrome.notifications.create(\nnotificationId?: string,\noptions: NotificationOptions,\ncallback?: function,\n)\nCreates and displays a notification.\nParameters\n-\nnotificationId\nstring optional\nIdentifier of the notification. If not set or empty, an ID will automatically be generated. If it matches an existing notification, this method first clears that notification before proceeding with the create operation. The identifier may not be longer than 500 characters.\nThe\nnotificationId\nparameter is required before Chrome 42. -\noptions\nContents of the notification.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(notificationId: string) => void\n-\nnotificationId\nstring\n-\nReturns\n-\nPromise<string>\nChrome 116+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetAll()\nchrome.notifications.getAll(\ncallback?: function,\n)\nRetrieves all the notifications of this app or extension.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(notifications: object) => void\n-\nnotifications\nobject\n-\nReturns\n-\nPromise<object>\nChrome 116+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetPermissionLevel()\nchrome.notifications.getPermissionLevel(\ncallback?: function,\n)\nRetrieves whether the user has enabled notifications from this app or extension.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(level: PermissionLevel) => void\n-\nlevel\n-\nReturns\n-\nPromise<PermissionLevel>\nChrome 116+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdate()\nchrome.notifications.update(\nnotificationId: string,\noptions: NotificationOptions,\ncallback?: function,\n)\nUpdates an existing notification.\nParameters\n-\nnotificationId\nstring\nThe id of the notification to be updated. This is returned by\nnotifications.create\nmethod. -\noptions\nContents of the notification to update to.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(wasUpdated: boolean) => void\n-\nwasUpdated\nboolean\n-\nReturns\n-\nPromise<boolean>\nChrome 116+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonButtonClicked\nchrome.notifications.onButtonClicked.addListener(\ncallback: function,\n)\nThe user pressed a button in the notification.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(notificationId: string, buttonIndex: number) => void\n-\nnotificationId\nstring\n-\nbuttonIndex\nnumber\n-\nonClicked\nchrome.notifications.onClicked.addListener(\ncallback: function,\n)\nThe user clicked in a non-button area of the notification.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(notificationId: string) => void\n-\nnotificationId\nstring\n-\nonClosed\nchrome.notifications.onClosed.addListener(\ncallback: function,\n)\nThe notification closed, either by the system or by user action.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(notificationId: string, byUser: boolean) => void\n-\nnotificationId\nstring\n-\nbyUser\nboolean\n-\nonPermissionLevelChanged\nchrome.notifications.onPermissionLevelChanged.addListener(\ncallback: function,\n)\nThe user changes the permission level. As of Chrome 47, only ChromeOS has UI that dispatches this event.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(level: PermissionLevel) => void\n-\nlevel\n-\nonShowSettings\nchrome.notifications.onShowSettings.addListener(\ncallback: function,\n)\nCustom notification settings button is no longer supported.\nThe user clicked on a link for the app's notification settings. As of Chrome 47, only ChromeOS has UI that dispatches this event. As of Chrome 65, that UI has been removed from ChromeOS, too.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/offscreen", "title": "chrome.offscreen | API | Chrome for Developers", "text": "Description\nUse the offscreen\nAPI to create and manage offscreen documents.\nPermissions\noffscreen\nTo use the Offscreen API, declare the \"offscreen\"\npermission in the extension manifest. For example:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"offscreen\"\n],\n...\n}\nAvailability\nConcepts and usage\nService workers don't have DOM access, and many websites have content security policies that\nlimit the functionality of content scripts. The Offscreen API allows the extension to use DOM\nAPIs in a hidden document without interrupting the user experience by opening new windows or\ntabs. The runtime\nAPI is the only extensions API\nsupported by offscreen documents.\nPages loaded as offscreen documents are handled differently from other types of extension pages.\nThe extension's permissions carry over to offscreen documents, but with limits on extension API\naccess. For example, because the chrome.runtime\nAPI is the only\nextensions API supported by offscreen documents, messaging must be handled\nusing members of that API.\nThe following are other ways offscreen documents behave differently from normal pages:\n- An offscreen document's URL must be a static HTML file bundled with the extension.\n- Offscreen documents can't be focused.\n- An offscreen document is an instance of\nwindow\n, but the value of itsopener\nproperty is alwaysnull\n. - Though an extension package can contain multiple offscreen documents, an installed extension can only have one open at a time. If the extension is running in split mode with an active incognito profile, the normal and incognito profiles can each have one offscreen document.\nUse chrome.offscreen.createDocument()\nand\nchrome.offscreen.closeDocument()\nto create and close an offscreen\ndocument. createDocument()\nrequires the document's url\n, a reason, and a justification:\nchrome.offscreen.createDocument({\nurl: 'off_screen.html',\nreasons: ['CLIPBOARD'],\njustification: 'reason for needing the document',\n});\nReasons\nFor a list of valid reasons, see the Reasons section. Reasons are set during\ndocument creation to determine the document's lifespan. The AUDIO_PLAYBACK\nreason sets the\ndocument to close after 30 seconds without audio playing. All other reasons don't set lifetime limits.\nExamples\nMaintain the lifecycle of an offscreen document\nThe following example shows how to ensure that an offscreen document exists. The\nsetupOffscreenDocument()\nfunction calls runtime.getContexts()\nto find\nan existing offscreen document, or creates the document if it doesn't already exist.\nlet creating; // A global promise to avoid concurrency issues\nasync function setupOffscreenDocument(path) {\n// Check all windows controlled by the service worker to see if one\n// of them is the offscreen document with the given path\nconst offscreenUrl = chrome.runtime.getURL(path);\nconst existingContexts = await chrome.runtime.getContexts({\ncontextTypes: ['OFFSCREEN_DOCUMENT'],\ndocumentUrls: [offscreenUrl]\n});\nif (existingContexts.length > 0) {\nreturn;\n}\n// create offscreen document\nif (creating) {\nawait creating;\n} else {\ncreating = chrome.offscreen.createDocument({\nurl: path,\nreasons: ['CLIPBOARD'],\njustification: 'reason for needing the document',\n});\nawait creating;\ncreating = null;\n}\n}\nBefore sending a message to an offscreen document, call setupOffscreenDocument()\nto make sure\nthe document exists, as demonstrated in the following example.\nchrome.action.onClicked.addListener(async () => {\nawait setupOffscreenDocument('off_screen.html');\n// Send message to offscreen document\nchrome.runtime.sendMessage({\ntype: '...',\ntarget: 'offscreen',\ndata: '...'\n});\n});\nFor complete examples, see the offscreen-clipboard and offscreen-dom demos on GitHub.\nBefore Chrome 116: check if an offscreen document is open\nruntime.getContexts()\nwas added in Chrome 116. In earlier versions of\nChrome, use clients.matchAll()\nto check for an existing offscreen document:\nasync function hasOffscreenDocument() {\nif ('getContexts' in chrome.runtime) {\nconst contexts = await chrome.runtime.getContexts({\ncontextTypes: ['OFFSCREEN_DOCUMENT'],\ndocumentUrls: [OFFSCREEN_DOCUMENT_PATH]\n});\nreturn Boolean(contexts.length);\n} else {\nconst matchedClients = await clients.matchAll();\nreturn matchedClients.some(client => {\nreturn client.url.includes(chrome.runtime.id);\n});\n}\n}\nTypes\nCreateParameters\nProperties\n-\njustification\nstring\nA developer-provided string that explains, in more detail, the need for the background context. The user agent _may_ use this in display to the user.\n-\nreasons\nReason[]\nThe reason(s) the extension is creating the offscreen document.\n-\nurl\nstring\nThe (relative) URL to load in the document.\nReason\nEnum\n\"TESTING\" \"AUDIO_PLAYBACK\" \"IFRAME_SCRIPTING\" \"DOM_SCRAPING\" \"BLOBS\" \"DOM_PARSER\" \"USER_MEDIA\" \"DISPLAY_MEDIA\" \"WEB_RTC\" \"CLIPBOARD\" \"LOCAL_STORAGE\" \"WORKERS\" \"BATTERY_STATUS\" \"MATCH_MEDIA\" \"GEOLOCATION\"\nA reason used for testing purposes only.\nSpecifies that the offscreen document is responsible for playing audio.\nSpecifies that the offscreen document needs to embed and script an iframe in order to modify the iframe's content.\nSpecifies that the offscreen document needs to embed an iframe and scrape its DOM to extract information.\nSpecifies that the offscreen document needs to interact with Blob objects (including URL.createObjectURL()\n).\nSpecifies that the offscreen document needs to use the DOMParser API.\nSpecifies that the offscreen document needs to interact with media streams from user media (e.g. getUserMedia()\n).\nSpecifies that the offscreen document needs to interact with media streams from display media (e.g. getDisplayMedia()\n).\nSpecifies that the offscreen document needs to use WebRTC APIs.\nSpecifies that the offscreen document needs to interact with the Clipboard API.\nSpecifies that the offscreen document needs access to localStorage.\nSpecifies that the offscreen document needs to spawn workers.\nSpecifies that the offscreen document needs to use navigator.getBattery.\nSpecifies that the offscreen document needs to use window.matchMedia.\nSpecifies that the offscreen document needs to use navigator.geolocation.\nMethods\ncloseDocument()\nchrome.offscreen.closeDocument(\ncallback?: function,\n)\nCloses the currently-open offscreen document for the extension.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ncreateDocument()\nchrome.offscreen.createDocument(\nparameters: CreateParameters,\ncallback?: function,\n)\nCreates a new offscreen document for the extension.\nParameters\n-\nparameters\nThe parameters describing the offscreen document to create.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/omnibox", "title": "chrome.omnibox | API | Chrome for Developers", "text": "Description\nThe omnibox API allows you to register a keyword with Google Chrome's address bar, which is also known as the omnibox.\nWhen the user enters your extension's keyword, the user starts interacting solely with your extension. Each keystroke is sent to your extension, and you can provide suggestions in response.\nThe suggestions can be richly formatted in a variety of ways. When the user accepts a suggestion, your extension is notified and can take action.\nManifest\nYou must include an \"omnibox.keyword\"\nfield in the manifest to use the omnibox API. You\nshould also specify a 16 by 16-pixel icon, which will be displayed in the address bar when suggesting\nthat users enter keyword mode.\nFor example:\n{\n\"name\": \"Aaron's omnibox extension\",\n\"version\": \"1.0\",\n\"omnibox\": { \"keyword\" : \"aaron\" },\n\"icons\": {\n\"16\": \"16-full-color.png\"\n},\n\"background\": {\n\"persistent\": false,\n\"scripts\": [\"background.js\"]\n}\n}\nExamples\nTo try this API, install the omnibox API example from the chrome-extension-samples repository.\nTypes\nDefaultSuggestResult\nA suggest result.\nProperties\n-\ndescription\nstring\nThe text that is displayed in the URL dropdown. Can contain XML-style markup for styling. The supported tags are 'url' (for a literal URL), 'match' (for highlighting text that matched what the user's query), and 'dim' (for dim helper text). The styles can be nested, eg. dimmed match.\nDescriptionStyleType\nThe style type.\nEnum\n\"url\" \"match\" \"dim\"\nOnInputEnteredDisposition\nThe window disposition for the omnibox query. This is the recommended context to display results. For example, if the omnibox command is to navigate to a certain URL, a disposition of 'newForegroundTab' means the navigation should take place in a new selected tab.\nEnum\n\"currentTab\" \"newForegroundTab\" \"newBackgroundTab\"\nSuggestResult\nA suggest result.\nProperties\n-\ncontent\nstring\nThe text that is put into the URL bar, and that is sent to the extension when the user chooses this entry.\n-\ndeletable\nboolean optional\nChrome 63+Whether the suggest result can be deleted by the user.\n-\ndescription\nstring\nThe text that is displayed in the URL dropdown. Can contain XML-style markup for styling. The supported tags are 'url' (for a literal URL), 'match' (for highlighting text that matched what the user's query), and 'dim' (for dim helper text). The styles can be nested, eg. dimmed match. You must escape the five predefined entities to display them as text: stackoverflow.com/a/1091953/89484\nMethods\nsetDefaultSuggestion()\nchrome.omnibox.setDefaultSuggestion(\nsuggestion: DefaultSuggestResult,\ncallback?: function,\n)\nSets the description and styling for the default suggestion. The default suggestion is the text that is displayed in the first suggestion row underneath the URL bar.\nParameters\n-\nsuggestion\nA partial SuggestResult object, without the 'content' parameter.\n-\ncallback\nfunction optional\nChrome 100+The\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 100+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonDeleteSuggestion\nchrome.omnibox.onDeleteSuggestion.addListener(\ncallback: function,\n)\nUser has deleted a suggested result.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(text: string) => void\n-\ntext\nstring\n-\nonInputCancelled\nchrome.omnibox.onInputCancelled.addListener(\ncallback: function,\n)\nUser has ended the keyword input session without accepting the input.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonInputChanged\nchrome.omnibox.onInputChanged.addListener(\ncallback: function,\n)\nUser has changed what is typed into the omnibox.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(text: string, suggest: function) => void\n-\ntext\nstring\n-\nsuggest\nfunction\nThe\nsuggest\nparameter looks like:(suggestResults: SuggestResult[]) => void\n-\nsuggestResults\nArray of suggest results\n-\n-\nonInputEntered\nchrome.omnibox.onInputEntered.addListener(\ncallback: function,\n)\nUser has accepted what is typed into the omnibox.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(text: string, disposition: OnInputEnteredDisposition) => void\n-\ntext\nstring\n-\ndisposition\n-\nonInputStarted\nchrome.omnibox.onInputStarted.addListener(\ncallback: function,\n)\nUser has started a keyword input session by typing the extension's keyword. This is guaranteed to be sent exactly once per input session, and before any onInputChanged events.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/pageCapture", "title": "chrome.pageCapture | API | Chrome for Developers", "text": "Description\nUse the chrome.pageCapture\nAPI to save a tab as MHTML.\nMHTML is a standard format supported by most browsers. It encapsulates in a single file a page and all its resources (CSS files, images..).\nNote that for security reasons a MHTML file can only be loaded from the file system and that it can only be loaded in the main frame.\nPermissions\npageCapture\nYou must declare the \"pageCapture\" permission in the extension manifest to use the pageCapture API. For example:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"pageCapture\"\n],\n...\n}\nMethods\nsaveAsMHTML()\nchrome.pageCapture.saveAsMHTML(\ndetails: object,\ncallback?: function,\n)\nSaves the content of the tab with given id as MHTML.\nParameters\n-\ndetails\nobject\n-\ntabId\nnumber\nThe id of the tab to save as MHTML.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(mhtmlData?: Blob) => void\n-\nmhtmlData\nBlob optional\nThe MHTML data as a Blob.\n-\nReturns\n-\nPromise<Blob | undefined>\nChrome 116+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/permissions", "title": "chrome.permissions | API | Chrome for Developers", "text": "Description\nUse the chrome.permissions\nAPI to request declared optional permissions at run time rather than install time, so users understand why the permissions are needed and grant only those that are necessary.\nConcepts and usage\nPermission warnings exist to describe the capabilities granted by an API, but some of these warnings may not be obvious. The Permissions API allows developers to explain permission warnings and introduce new features gradually which gives users a risk-free introduction to the extension. This way, users can specify how much access they are willing to grant and which features they want to enable.\nFor example, the optional permissions extension's core functionality is overriding the new tab page. One feature is displaying the user's goal of the day. This feature only requires the storage permission, which does not include a warning. The extension has an additional feature, that users can enable by clicking the following button:\nDisplaying the user's top sites requires the topSites permission, which has the following warning.\nImplement optional permissions\nStep 1: Decide which permissions are required and which are optional\nAn extension can declare both required and optional permissions. In general, you should:\n- Use required permissions when they are needed for your extension's basic functionality.\n- Use optional permissions when they are needed for optional features in your extension.\nAdvantages of required permissions:\n- Fewer prompts: An extension can prompt the user once to accept all permissions.\n- Simpler development: Required permissions are guaranteed to be present.\nAdvantages of optional permissions:\n- Better security: Extensions run with fewer permissions since users only enable permissions that are needed.\n- Better information for users: An extension can explain why it needs a particular permission when the user enables the relevant feature.\n- Easier upgrades: When you upgrade your extension, Chrome won't disable it for your users if the upgrade adds optional rather than required permissions.\nStep 2: Declare optional permissions in the manifest\nDeclare optional permissions in your extension manifest with the optional_permissions\nkey,\nusing the same format as the permissions field:\n{\n\"name\": \"My extension\",\n...\n\"optional_permissions\": [\"tabs\"],\n\"optional_host_permissions\": [\"https://www.google.com/\"],\n...\n}\nIf you want to request hosts that you only discover at runtime, include \"https://*/*\"\nin your extension's optional_host_permissions\nfield. This lets you specify any origin in \"Permissions.origins\"\nas long as it has a matching\nscheme.\nPermissions that can not be specified as optional\nMost Chrome extension permissions can be specified as optional, with the following exceptions.\n| Permission | Description |\n|---|---|\n\"debugger\" |\nThe chrome.debugger API serves as an alternate transport for Chrome's remote debugging protocol. |\n\"declarativeNetRequest\" |\nGrants the extension access to the chrome.declarativeNetRequest API. |\n\"devtools\" |\nAllows extension to expand Chrome DevTools functionality. |\n\"geolocation\" |\nAllows the extension to use the HTML5 geolocation API. |\n\"mdns\" |\nGrants the extension access to the chrome.mdns API. |\n\"proxy\" |\nGrants the extension access to the chrome.proxy API to manage Chrome's proxy settings. |\n\"tts\" |\nThe chrome.tts API plays synthesized text-to-speech (TTS). |\n\"ttsEngine\" |\nThe chrome.ttsEngine API implements a text-to-speech (TTS) engine using an extension. |\n\"wallpaper\" |\nChromeOS only. Use the chrome.wallpaper API change the ChromeOS wallpaper. |\nView Declare Permissions for further information on available permissions and their warnings.\nStep 3: Request optional permissions\nRequest the permissions from within a user gesture using permissions.request()\n:\ndocument.querySelector('#my-button').addEventListener('click', (event) => {\n// Permissions must be requested from inside a user gesture, like a button's\n// click handler.\nchrome.permissions.request({\npermissions: ['tabs'],\norigins: ['https://www.google.com/']\n}, (granted) => {\n// The callback argument will be true if the user granted the permissions.\nif (granted) {\ndoSomething();\n} else {\ndoSomethingElse();\n}\n});\n});\nChrome prompts the user if adding the permissions results in different warning messages than the user has already seen and accepted. For example, the previous code might result in a prompt like this:\nStep 4: Check the extension's current permissions\nTo check whether your extension has a specific permission or set of permissions, use\npermission.contains()\n:\nchrome.permissions.contains({\npermissions: ['tabs'],\norigins: ['https://www.google.com/']\n}, (result) => {\nif (result) {\n// The extension has the permissions.\n} else {\n// The extension doesn't have the permissions.\n}\n});\nStep 5: Remove the permissions\nYou should remove permissions when you no longer need them. After a permission has been removed,\ncalling permissions.request()\nusually adds the permission back without prompting the user.\nchrome.permissions.remove({\npermissions: ['tabs'],\norigins: ['https://www.google.com/']\n}, (removed) => {\nif (removed) {\n// The permissions have been removed.\n} else {\n// The permissions have not been removed (e.g., you tried to remove\n// required permissions).\n}\n});\nTypes\nPermissions\nProperties\n-\norigins\nstring[] optional\nThe list of host permissions, including those specified in the\noptional_permissions\norpermissions\nkeys in the manifest, and those associated with Content Scripts. -\npermissions\nstring[] optional\nList of named permissions (does not include hosts or origins).\nMethods\naddHostAccessRequest()\nchrome.permissions.addHostAccessRequest(\nrequest: object,\ncallback?: function,\n)\nAdds a host access request. Request will only be signaled to the user if extension can be granted access to the host in the request. Request will be reset on cross-origin navigation. When accepted, grants persistent access to the site\u2019s top origin\nParameters\n-\nrequest\nobject\n-\ndocumentId\nstring optional\nThe id of a document where host access requests can be shown. Must be the top-level document within a tab. If provided, the request is shown on the tab of the specified document and is removed when the document navigates to a new origin. Adding a new request will override any existent request for\ntabId\n. This ortabId\nmust be specified. -\npattern\nstring optional\nThe URL pattern where host access requests can be shown. If provided, host access requests will only be shown on URLs that match this pattern.\n-\ntabId\nnumber optional\nThe id of the tab where host access requests can be shown. If provided, the request is shown on the specified tab and is removed when the tab navigates to a new origin. Adding a new request will override an existent request for\ndocumentId\n. This ordocumentId\nmust be specified.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ncontains()\nchrome.permissions.contains(\npermissions: Permissions,\ncallback?: function,\n)\nChecks if the extension has the specified permissions.\nParameters\n-\npermissions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: boolean) => void\n-\nresult\nboolean\nTrue if the extension has the specified permissions. If an origin is specified as both an optional permission and a content script match pattern, this will return\nfalse\nunless both permissions are granted.\n-\nReturns\n-\nPromise<boolean>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetAll()\nchrome.permissions.getAll(\ncallback?: function,\n)\nGets the extension's current set of permissions.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(permissions: Permissions) => void\n-\npermissions\nThe extension's active permissions. Note that the\norigins\nproperty will contain granted origins from those specified in thepermissions\nandoptional_permissions\nkeys in the manifest and those associated with Content Scripts.\n-\nReturns\n-\nPromise<Permissions>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremove()\nchrome.permissions.remove(\npermissions: Permissions,\ncallback?: function,\n)\nRemoves access to the specified permissions. If there are any problems removing the permissions, runtime.lastError\nwill be set.\nParameters\n-\npermissions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(removed: boolean) => void\n-\nremoved\nboolean\nTrue if the permissions were removed.\n-\nReturns\n-\nPromise<boolean>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveHostAccessRequest()\nchrome.permissions.removeHostAccessRequest(\nrequest: object,\ncallback?: function,\n)\nRemoves a host access request, if existent.\nParameters\n-\nrequest\nobject\n-\ndocumentId\nstring optional\nThe id of a document where host access request will be removed. Must be the top-level document within a tab. This or\ntabId\nmust be specified. -\npattern\nstring optional\nThe URL pattern where host access request will be removed. If provided, this must exactly match the pattern of an existing host access request.\n-\ntabId\nnumber optional\nThe id of the tab where host access request will be removed. This or\ndocumentId\nmust be specified.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nrequest()\nchrome.permissions.request(\npermissions: Permissions,\ncallback?: function,\n)\nRequests access to the specified permissions, displaying a prompt to the user if necessary. These permissions must either be defined in the optional_permissions\nfield of the manifest or be required permissions that were withheld by the user. Paths on origin patterns will be ignored. You can request subsets of optional origin permissions; for example, if you specify *://*\\/*\nin the optional_permissions\nsection of the manifest, you can request http://example.com/\n. If there are any problems requesting the permissions, runtime.lastError\nwill be set.\nParameters\n-\npermissions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(granted: boolean) => void\n-\ngranted\nboolean\nTrue if the user granted the specified permissions.\n-\nReturns\n-\nPromise<boolean>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonAdded\nchrome.permissions.onAdded.addListener(\ncallback: function,\n)\nFired when the extension acquires new permissions.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(permissions: Permissions) => void\n-\npermissions\n-\nonRemoved\nchrome.permissions.onRemoved.addListener(\ncallback: function,\n)\nFired when access to permissions has been removed from the extension.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(permissions: Permissions) => void\n-\npermissions\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/platformKeys", "title": "chrome.platformKeys | API | Chrome for Developers", "text": "Description\nUse the chrome.platformKeys\nAPI to access client certificates managed by the platform. If the user or policy grants the permission, an extension can use such a certficate in its custom authentication protocol. E.g. this allows usage of platform managed certificates in third party VPNs (see chrome.vpnProvider).\nPermissions\nplatformKeys\nAvailability\nTypes\nClientCertificateRequest\nProperties\n-\ncertificateAuthorities\nArrayBuffer[]\nList of distinguished names of certificate authorities allowed by the server. Each entry must be a DER-encoded X.509 DistinguishedName.\n-\ncertificateTypes\nThis field is a list of the types of certificates requested, sorted in order of the server's preference. Only certificates of a type contained in this list will be retrieved. If\ncertificateTypes\nis the empty list, however, certificates of any type will be returned.\nClientCertificateType\nEnum\n\"rsaSign\" \"ecdsaSign\"\nMatch\nProperties\n-\ncertificate\nArrayBuffer\nThe DER encoding of a X.509 certificate.\n-\nkeyAlgorithm\nobject\nThe KeyAlgorithm of the certified key. This contains algorithm parameters that are inherent to the key of the certificate (e.g. the key length). Other parameters like the hash function used by the sign function are not included.\nSelectDetails\nProperties\n-\nclientCerts\nArrayBuffer[] optional\nIf given, the\nselectClientCertificates\noperates on this list. Otherwise, obtains the list of all certificates from the platform's certificate stores that are available to this extensions. Entries that the extension doesn't have permission for or which doesn't match the request, are removed. -\ninteractive\nboolean\nIf true, the filtered list is presented to the user to manually select a certificate and thereby granting the extension access to the certificate(s) and key(s). Only the selected certificate(s) will be returned. If is false, the list is reduced to all certificates that the extension has been granted access to (automatically or manually).\n-\nrequest\nOnly certificates that match this request will be returned.\nVerificationDetails\nProperties\n-\nhostname\nstring\nThe hostname of the server to verify the certificate for, e.g. the server that presented the\nserverCertificateChain\n. -\nserverCertificateChain\nArrayBuffer[]\nEach chain entry must be the DER encoding of a X.509 certificate, the first entry must be the server certificate and each entry must certify the entry preceding it.\nVerificationResult\nProperties\n-\ndebug_errors\nstring[]\nIf the trust verification failed, this array contains the errors reported by the underlying network layer. Otherwise, this array is empty.\nNote: This list is meant for debugging only and may not contain all relevant errors. The errors returned may change in future revisions of this API, and are not guaranteed to be forwards or backwards compatible.\n-\ntrusted\nboolean\nThe result of the trust verification: true if trust for the given verification details could be established and false if trust is rejected for any reason.\nMethods\ngetKeyPair()\nchrome.platformKeys.getKeyPair(\ncertificate: ArrayBuffer,\nparameters: object,\ncallback: function,\n)\nPasses the key pair of certificate\nfor usage with platformKeys.subtleCrypto\nto callback\n.\nParameters\n-\ncertificate\nArrayBuffer\nThe certificate of a\nMatch\nreturned byselectClientCertificates\n. -\nparameters\nobject\nDetermines signature/hash algorithm parameters additionally to the parameters fixed by the key itself. The same parameters are accepted as by WebCrypto's importKey function, e.g.\nRsaHashedImportParams\nfor a RSASSA-PKCS1-v1_5 key andEcKeyImportParams\nfor EC key. Additionally for RSASSA-PKCS1-v1_5 keys, hashing algorithm name parameter can be specified with one of the following values: \"none\", \"SHA-1\", \"SHA-256\", \"SHA-384\", or \"SHA-512\", e.g.{\"hash\": { \"name\": \"none\" } }\n. The sign function will then apply PKCS#1 v1.5 padding but not hash the given data.Currently, this method only supports the \"RSASSA-PKCS1-v1_5\" and \"ECDSA\" algorithms.\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(publicKey: object, privateKey?: object) => void\n-\npublicKey\nobject\n-\nprivateKey\nobject optional\nMight be\nnull\nif this extension does not have access to it.\n-\ngetKeyPairBySpki()\nchrome.platformKeys.getKeyPairBySpki(\npublicKeySpkiDer: ArrayBuffer,\nparameters: object,\ncallback: function,\n)\nPasses the key pair identified by publicKeySpkiDer\nfor usage with platformKeys.subtleCrypto\nto callback\n.\nParameters\n-\npublicKeySpkiDer\nArrayBuffer\nA DER-encoded X.509 SubjectPublicKeyInfo, obtained e.g. by calling WebCrypto's exportKey function with format=\"spki\".\n-\nparameters\nobject\nProvides signature and hash algorithm parameters, in addition to those fixed by the key itself. The same parameters are accepted as by WebCrypto's importKey function, e.g.\nRsaHashedImportParams\nfor a RSASSA-PKCS1-v1_5 key. For RSASSA-PKCS1-v1_5 keys, we need to also pass a \"hash\" parameter{ \"hash\": { \"name\": string } }\n. The \"hash\" parameter represents the name of the hashing algorithm to be used in the digest operation before a sign. It is possible to pass \"none\" as the hash name, in which case the sign function will apply PKCS#1 v1.5 padding and but not hash the given data.Currently, this method supports the \"ECDSA\" algorithm with named-curve P-256 and \"RSASSA-PKCS1-v1_5\" algorithm with one of the hashing algorithms \"none\", \"SHA-1\", \"SHA-256\", \"SHA-384\", and \"SHA-512\".\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(publicKey: object, privateKey?: object) => void\n-\npublicKey\nobject\n-\nprivateKey\nobject optional\nMight be\nnull\nif this extension does not have access to it.\n-\nselectClientCertificates()\nchrome.platformKeys.selectClientCertificates(\ndetails: SelectDetails,\ncallback?: function,\n)\nThis method filters from a list of client certificates the ones that are known to the platform, match request\nand for which the extension has permission to access the certificate and its private key. If interactive\nis true, the user is presented a dialog where they can select from matching certificates and grant the extension access to the certificate. The selected/filtered client certificates will be passed to callback\n.\nParameters\nReturns\n-\nPromise<Match[]>\nChrome 121+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsubtleCrypto()\nchrome.platformKeys.subtleCrypto()\nAn implementation of WebCrypto's SubtleCrypto that allows crypto operations on keys of client certificates that are available to this extension.\nReturns\n-\nobject | undefined\nverifyTLSServerCertificate()\nchrome.platformKeys.verifyTLSServerCertificate(\ndetails: VerificationDetails,\ncallback?: function,\n)\nChecks whether details.serverCertificateChain\ncan be trusted for details.hostname\naccording to the trust settings of the platform. Note: The actual behavior of the trust verification is not fully specified and might change in the future. The API implementation verifies certificate expiration, validates the certification path and checks trust by a known CA. The implementation is supposed to respect the EKU serverAuth and to support subject alternative names.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: VerificationResult) => void\n-\nresult\n-\nReturns\n-\nPromise<VerificationResult>\nChrome 121+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/power", "title": "chrome.power | API | Chrome for Developers", "text": "Description\nUse the chrome.power\nAPI to override the system's power management features.\nPermissions\npower\nConcepts and usage\nBy default, operating systems dim the screen when users are inactive and eventually suspend the system. With the power API, an app or extension can keep the system awake.\nUsing this API, you can specify the Level to which power management is disabled. The \"system\"\nlevel keeps the system active, but allows the screen to be dimmed or turned off. For example, a\ncommunication app can continue to receive messages while the screen is off. The \"display\"\nlevel\nkeeps the screen and system active. E-book and presentation apps, for example, can keep the screen\nand system active while users read.\nWhen a user has more than one app or extension active, each with its own power level, the\nhighest-precedence level takes effect; \"display\"\nalways takes precedence over \"system\"\n. For\nexample, if app A asks for \"system\"\npower management, and app B asks for \"display\"\n, \"display\"\nis used until app B is unloaded or releases its request. If app A is still active, \"system\"\nis\nthen used.\nTypes\nLevel\nEnum\n\"system\" \"display\"\nPrevents the system from sleeping in response to user inactivity.\nPrevents the display from being turned off or dimmed, or the system from sleeping in response to user inactivity.\nMethods\nreleaseKeepAwake()\nchrome.power.releaseKeepAwake()\nReleases a request previously made via requestKeepAwake().\nreportActivity()\nchrome.power.reportActivity(\ncallback?: function,\n)\nReports a user activity in order to awake the screen from a dimmed or turned off state or from a screensaver. Exits the screensaver if it is currently active.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nrequestKeepAwake()\nchrome.power.requestKeepAwake(\nlevel: Level,\n)\nRequests that power management be temporarily disabled. level\ndescribes the degree to which power management should be disabled. If a request previously made by the same app is still active, it will be replaced by the new request.\nParameters\n-\nlevel"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/printerProvider", "title": "chrome.printerProvider | API | Chrome for Developers", "text": "Description\nThe chrome.printerProvider\nAPI exposes events used by print manager to query printers controlled by extensions, to query their capabilities and to submit print jobs to these printers.\nPermissions\nprinterProvider\nAvailability\nTypes\nPrinterInfo\nProperties\n-\ndescription\nstring optional\nPrinter's human readable description.\n-\nid\nstring\nUnique printer ID.\n-\nname\nstring\nPrinter's human readable name.\nPrintError\nError codes returned in response to onPrintRequested\nevent.\nEnum\n\"OK\" \"FAILED\" \"INVALID_TICKET\" \"INVALID_DATA\"\nSpecifies that the operation was completed successfully.\nSpecifies that a general failure occured.\nSpecifies that the print ticket is invalid. For example, the ticket is inconsistent with some capabilities, or the extension is not able to handle all settings from the ticket.\nSpecifies that the document is invalid. For example, data may be corrupted or the format is incompatible with the extension.\nPrintJob\nProperties\n-\ncontentType\nstring\nThe document content type. Supported formats are\n\"application/pdf\"\nand\"image/pwg-raster\"\n. -\ndocument\nBlob\nBlob containing the document data to print. Format must match\ncontentType\n. -\nprinterId\nstring\nID of the printer which should handle the job.\n-\nticket\nobject\nPrint ticket in CJT format.\nThe CJT reference is marked as deprecated. It is deprecated for Google Cloud Print only. is not deprecated for ChromeOS printing.\n-\ntitle\nstring\nThe print job title.\nEvents\nonGetCapabilityRequested\nchrome.printerProvider.onGetCapabilityRequested.addListener(\ncallback: function,\n)\nEvent fired when print manager requests printer capabilities.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(printerId: string, resultCallback: function) => void\n-\nprinterId\nstring\n-\nresultCallback\nfunction\nThe\nresultCallback\nparameter looks like:(capabilities: object) => void\n-\ncapabilities\nobject\nDevice capabilities in CDD format.\n-\n-\nonGetPrintersRequested\nchrome.printerProvider.onGetPrintersRequested.addListener(\ncallback: function,\n)\nEvent fired when print manager requests printers provided by extensions.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(resultCallback: function) => void\n-\nresultCallback\nfunction\nThe\nresultCallback\nparameter looks like:(printerInfo: PrinterInfo[]) => void\n-\nprinterInfo\n-\n-\nonGetUsbPrinterInfoRequested\nchrome.printerProvider.onGetUsbPrinterInfoRequested.addListener(\ncallback: function,\n)\nEvent fired when print manager requests information about a USB device that may be a printer.\nNote: An application should not rely on this event being fired more than once per device. If a connected device is supported it should be returned in the onGetPrintersRequested\nevent.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(device: usb.Device, resultCallback: function) => void\n-\ndevice\n-\nresultCallback\nfunction\nThe\nresultCallback\nparameter looks like:(printerInfo?: PrinterInfo) => void\n-\nprinterInfo\nPrinterInfo optional\n-\n-\nonPrintRequested\nchrome.printerProvider.onPrintRequested.addListener(\ncallback: function,\n)\nEvent fired when print manager requests printing.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(printJob: PrintJob, resultCallback: function) => void\n-\nprintJob\n-\nresultCallback\nfunction\nThe\nresultCallback\nparameter looks like:(result: PrintError) => void\n-\nresult\n-\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/printing", "title": "chrome.printing | API | Chrome for Developers", "text": "Description\nUse the chrome.printing\nAPI to send print jobs to printers installed on Chromebook.\nPermissions\nprinting\nAvailability\nAll chrome.printing\nmethods and events require you to declare the \"printing\"\npermission in the extension manifest. For example:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"printing\"\n],\n...\n}\nExamples\nThe examples below demonstrate using each of the methods in the printing namespace. This code is copied from or based on the api-samples/printing in the extensions-samples Github repo.\ncancelJob()\nThis example uses the onJobStatusChanged\nhandler to hide a 'cancel' button when the jobStatus\nis neither PENDING\nor IN_PROGRESS\n. Note that on some networks or when a Chromebook is connected directly to the printer, these states may pass too quickly for the cancel button to be visible long enough to be called. This is greatly simplified printing example.\nchrome.printing.onJobStatusChanged.addListener((jobId, status) => {\nconst cancelButton = document.getElementById(\"cancelButton\");\ncancelButton.addEventListener('click', () => {\nchrome.printing.cancelJob(jobId).then((response) => {\nif (response !== undefined) {\nconsole.log(response.status);\n}\nif (chrome.runtime.lastError !== undefined) {\nconsole.log(chrome.runtime.lastError.message);\n}\n});\n});\nif (status !== \"PENDING\" && status !== \"IN_PROGRESS\") {\ncancelButton.style.visibility = 'hidden';\n} else {\ncancelButton.style.visibility = 'visible';\n}\n}\ngetPrinters() and getPrinterInfo()\nA single example is used for these functions because getting printer information requires a printer ID, which is retrieved by calling getPrinters()\n. This example logs the name and description of the default printer to the console. This is a simplified version of the printing example.\nconst printers = await chrome.printing.getPrinters();\nconst defaultPrinter = printers.find((printer) => {\nconst printerInfo = await chrome.printing.getPrinterInfo(printer.id);\nreturn printerInfo.isDefault;\n}\nconsole.log(`Default printer: ${defaultPrinter.name}.\\n\\t${defaultPrinter.description}`);\nsubmitJob()\nThe submitJob()\nmethod requires three things.\n- A\nticket\nstructure specifying which capabilities of the printer are to be used. If the user needs to select from available capabilities, you can retrieve them for a specific printer usinggetPrinterInfo()\n. - A\nSubmitJobRequest\nstructure, which specifies the printer to use, and the file or date to print. This structure contains a reference to theticket\nstructure. - A blob of the file or data to print.\nCalling submitJob()\ntriggers a dialog box asking the user to confirm printing. Use the PrintingAPIExtensionsAllowlist\nto bypass confirmation.\nThis is a simplified version of the printing example. Notice that the ticket\nis attached to the SubmitJobRequest\nstructure (line 8) and that the data to print is converted to a blob (line 10). Getting the ID of the printer (line 1) is more complicated in the sample than is shown here.\nconst defaultPrinter = getDefaultPrinter();\nconst ticket = getPrinterTicket(defaultPrinter);\nconst arrayBuffer = getPrintData();\nconst submitJobRequest = {\njob: {\nprinterId: defaultPrinter,\ntitle: 'test job',\nticket: ticket,\ncontentType: 'application/pdf',\ndocument: new Blob([new Uint8Array(arrayBuffer)], {\ntype: 'application/pdf'\n});\n}\n};\nchrome.printing.submitJob(submitJobRequest, (response) => {\nif (response !== undefined) {\nconsole.log(response.status);\n}\nif (chrome.runtime.lastError !== undefined) {\nconsole.log(chrome.runtime.lastError.message);\n}\n});\nRoll printing\nThis example shows how to build a printer ticket for continuous (or roll) printing, which is often used with receipt printing. The submitJobRequest\nobject for roll printing is the same as that shown for the submitJob()\nexample.\nIf you need to change the default value for paper cutting, use the vendor_ticket_item\nkey. (The default varies from printer to printer.) To change the value, provide an array with one member: an object whose id\nis 'finishings'\n. The value can either be 'trim'\nfor printers that cut the roll at the end of printing or 'none'\nfor printers that require the print job to be torn off.\nconst ticket = {\nversion: '1.0',\nprint: {\nvendor_ticket_item: [{id: 'finishings', value: 'trim'}],\ncolor: {type: 'STANDARD_MONOCHROME'},\nduplex: {type: 'NO_DUPLEX'},\npage_orientation: {type: 'PORTRAIT'},\ncopies: {copies: 1},\ndpi: {horizontal_dpi: 300, vertical_dpi: 300},\nmedia_size: {\nwidth_microns: 72320,\nheight_microns: 100000\n},\ncollate: {collate: false}\n}\n};\nSome printers do not support the \"finishings\"\noption. To determine if your printer does, call getPrinterInfo()\nand look for a \"display_name\"\nof \"finishings/11\"\n.\n\"vendor_capability\": [\n{\n\"display_name\": \"finishings/11\",\n\"id\": \"finishings/11\",\n\"type\": \"TYPED_VALUE\",\n\"typed_value_cap\": {\n\"value_type\": \"BOOLEAN\"\n}\n},\n...\n]\nThe values in a ticket's media_size\nkey are specific to each printer. To select an appropriate size call getPrinterInfo()\n. The returned GetPrinterResponse\ncontains an array of supported media sizes at \"media_size\".\"option\"\n. Choose an option whose \"is_continuous_feed\"\nvalue is true. Use its height and width values for the ticket.\n\"media_size\": {\n\"option\": [\n{\n\"custom_display_name\": \"\",\n\"is_continuous_feed\": true,\n\"max_height_microns\": 2000000,\n\"min_height_microns\": 25400,\n\"width_microns\": 50800\n},\n...\n]\n}\nTypes\nGetPrinterInfoResponse\nProperties\n-\ncapabilities\nobject optional\nPrinter capabilities in CDD format. The property may be missing.\n-\nstatus\nThe status of the printer.\nJobStatus\nStatus of the print job.\nEnum\n\"PENDING\" \"IN_PROGRESS\" \"FAILED\" \"CANCELED\" \"PRINTED\"\nPrint job is received on Chrome side but was not processed yet.\nPrint job is sent for printing.\nPrint job was interrupted due to some error.\nPrint job was canceled by the user or via API.\nPrint job was printed without any errors.\nPrinter\nProperties\n-\ndescription\nstring\nThe human-readable description of the printer.\n-\nid\nstring\nThe printer's identifier; guaranteed to be unique among printers on the device.\n-\nisDefault\nboolean\nThe flag which shows whether the printer fits DefaultPrinterSelection rules. Note that several printers could be flagged.\n-\nname\nstring\nThe name of the printer.\n-\nrecentlyUsedRank\nnumber optional\nThe value showing how recent the printer was used for printing from Chrome. The lower the value is the more recent the printer was used. The minimum value is 0. Missing value indicates that the printer wasn't used recently. This value is guaranteed to be unique amongst printers.\n-\nsource\nThe source of the printer (user or policy configured).\n-\nuri\nstring\nThe printer URI. This can be used by extensions to choose the printer for the user.\nPrinterSource\nThe source of the printer.\nEnum\n\"USER\" \"POLICY\"\nPrinter was added by user.\nPrinter was added via policy.\nPrinterStatus\nThe status of the printer.\nEnum\n\"DOOR_OPEN\" \"TRAY_MISSING\" \"OUT_OF_INK\" \"OUT_OF_PAPER\" \"OUTPUT_FULL\" \"PAPER_JAM\" \"GENERIC_ISSUE\" \"STOPPED\" \"UNREACHABLE\" \"EXPIRED_CERTIFICATE\" \"AVAILABLE\"\nThe door of the printer is open. Printer still accepts print jobs.\nThe tray of the printer is missing. Printer still accepts print jobs.\nThe printer is out of ink. Printer still accepts print jobs.\nThe printer is out of paper. Printer still accepts print jobs.\nThe output area of the printer (e.g. tray) is full. Printer still accepts print jobs.\nThe printer has a paper jam. Printer still accepts print jobs.\nSome generic issue. Printer still accepts print jobs.\nThe printer is stopped and doesn't print but still accepts print jobs.\nThe printer is unreachable and doesn't accept print jobs.\nThe SSL certificate is expired. Printer accepts jobs but they fail.\nThe printer is available.\nSubmitJobRequest\nProperties\n-\njob\nThe print job to be submitted. The only supported content type is \"application/pdf\", and the Cloud Job Ticket shouldn't include\nFitToPageTicketItem\n,PageRangeTicketItem\n,ReverseOrderTicketItem\nandVendorTicketItem\nfields since they are irrelevant for native printing. All other fields must be present.\nSubmitJobResponse\nProperties\n-\njobId\nstring optional\nThe id of created print job. This is a unique identifier among all print jobs on the device. If status is not OK, jobId will be null.\n-\nstatus\nThe status of the request.\nSubmitJobStatus\nThe status of submitJob\nrequest.\nEnum\n\"OK\" \"USER_REJECTED\"\nSent print job request is accepted.\nSent print job request is rejected by the user.\nProperties\nMAX_GET_PRINTER_INFO_CALLS_PER_MINUTE\nThe maximum number of times that getPrinterInfo\ncan be called per minute.\nValue\n20\nMAX_SUBMIT_JOB_CALLS_PER_MINUTE\nThe maximum number of times that submitJob\ncan be called per minute.\nValue\n40\nMethods\ncancelJob()\nchrome.printing.cancelJob(\njobId: string,\ncallback?: function,\n)\nCancels previously submitted job.\nParameters\n-\njobId\nstring\nThe id of the print job to cancel. This should be the same id received in a\nSubmitJobResponse\n. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 100+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetPrinterInfo()\nchrome.printing.getPrinterInfo(\nprinterId: string,\ncallback?: function,\n)\nReturns the status and capabilities of the printer in CDD format. This call will fail with a runtime error if no printers with given id are installed.\nParameters\n-\nprinterId\nstring\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(response: GetPrinterInfoResponse) => void\n-\nresponse\n-\nReturns\n-\nPromise<GetPrinterInfoResponse>\nChrome 100+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetPrinters()\nchrome.printing.getPrinters(\ncallback?: function,\n)\nReturns the list of available printers on the device. This includes manually added, enterprise and discovered printers.\nParameters\nReturns\n-\nPromise<Printer[]>\nChrome 100+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsubmitJob()\nchrome.printing.submitJob(\nrequest: SubmitJobRequest,\ncallback?: function,\n)\nSubmits the job for printing. If the extension is not listed in the PrintingAPIExtensionsAllowlist\npolicy, the user is prompted to accept the print job.\nBefore Chrome 120, this function did not return a promise.\nParameters\n-\nrequest\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(response: SubmitJobResponse) => void\n-\nresponse\n-\nReturns\n-\nPromise<SubmitJobResponse>\nChrome 100+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonJobStatusChanged\nchrome.printing.onJobStatusChanged.addListener(\ncallback: function,\n)\nEvent fired when the status of the job is changed. This is only fired for the jobs created by this extension."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/printingMetrics", "title": "chrome.printingMetrics | API | Chrome for Developers", "text": "Description\nUse the chrome.printingMetrics\nAPI to fetch data about printing usage.\nPermissions\nprintingMetrics\nAvailability\nTypes\nColorMode\nEnum\n\"BLACK_AND_WHITE\" \"COLOR\"\nSpecifies that black and white mode was used.\nSpecifies that color mode was used.\nDuplexMode\nEnum\n\"ONE_SIDED\" \"TWO_SIDED_LONG_EDGE\" \"TWO_SIDED_SHORT_EDGE\"\nSpecifies that one-sided printing was used.\nSpecifies that two-sided printing was used, flipping on long edge.\nSpecifies that two-sided printing was used, flipping on short edge.\nMediaSize\nProperties\n-\nheight\nnumber\nHeight (in micrometers) of the media used for printing.\n-\nvendorId\nstring\nVendor-provided ID, e.g. \"iso_a3_297x420mm\" or \"na_index-3x5_3x5in\". Possible values are values of \"media\" IPP attribute and can be found on IANA page .\n-\nwidth\nnumber\nWidth (in micrometers) of the media used for printing.\nPrinter\nProperties\n-\nname\nstring\nDisplayed name of the printer.\n-\nsource\nThe source of the printer.\n-\nuri\nstring\nThe full path for the printer. Contains protocol, hostname, port, and queue.\nPrinterSource\nThe source of the printer.\nEnum\n\"USER\" \"POLICY\"\nSpecifies that the printer was added by user.\nSpecifies that the printer was added via policy.\nPrintJobInfo\nProperties\n-\ncompletionTime\nnumber\nThe job completion time (in milliseconds past the Unix epoch).\n-\ncreationTime\nnumber\nThe job creation time (in milliseconds past the Unix epoch).\n-\nid\nstring\nThe ID of the job.\n-\nnumberOfPages\nnumber\nThe number of pages in the document.\n-\nprinter\nThe info about the printer which printed the document.\n-\nprinter_statusChrome 85+\nThe status of the printer.\n-\nsettings\nThe settings of the print job.\n-\nsource\nSource showing who initiated the print job.\n-\nsourceId\nstring optional\nID of source. Null if source is PRINT_PREVIEW or ANDROID_APP.\n-\nstatus\nThe final status of the job.\n-\ntitle\nstring\nThe title of the document which was printed.\nPrintJobSource\nThe source of the print job.\nEnum\n\"PRINT_PREVIEW\" \"ANDROID_APP\" \"EXTENSION\" \"ISOLATED_WEB_APP\"\nSpecifies that the job was created from the Print Preview page initiated by the user.\nSpecifies that the job was created from an Android App.\nSpecifies that the job was created by extension via Chrome API.\nSpecifies that the job was created by an Isolated Web App via API.\nPrintJobStatus\nSpecifies the final status of the print job.\nEnum\n\"FAILED\" \"CANCELED\" \"PRINTED\"\nSpecifies that the print job was interrupted due to some error.\nSpecifies that the print job was canceled by the user or via API.\nSpecifies that the print job was printed without any errors.\nPrintSettings\nProperties\n-\ncolor\nThe requested color mode.\n-\ncopies\nnumber\nThe requested number of copies.\n-\nduplex\nThe requested duplex mode.\n-\nmediaSize\nThe requested media size.\nMethods\ngetPrintJobs()\nchrome.printingMetrics.getPrintJobs(\ncallback?: function,\n)\nReturns the list of the finished print jobs.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(jobs: PrintJobInfo[]) => void\n-\njobs\n-\nReturns\n-\nPromise<PrintJobInfo[]>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonPrintJobFinished\nchrome.printingMetrics.onPrintJobFinished.addListener(\ncallback: function,\n)\nEvent fired when the print job is finished. This includes any of termination statuses: FAILED, CANCELED and PRINTED.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(jobInfo: PrintJobInfo) => void\n-\njobInfo\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/privacy", "title": "chrome.privacy | API | Chrome for Developers", "text": "Description\nUse the chrome.privacy\nAPI to control usage of the features in Chrome that can affect a user's privacy. This API relies on the ChromeSetting prototype of the type API for getting and setting Chrome's configuration.\nPermissions\nprivacy\nYou must declare the \"privacy\" permission in your extension's manifest to use the API. For example:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"privacy\"\n],\n...\n}\nConcepts and usage\nReading the current value of a Chrome setting is straightforward. You'll first need to find the\nproperty you're interested in, then you'll call get()\non that object in order to retrieve its\ncurrent value and your extension's level of control. For example, to determine if Chrome's credit card autofill\nfeature is enabled, you'd write:\nchrome.privacy.services.autofillCreditCardEnabled.get({}, function(details) {\nif (details.value) {\nconsole.log('Autofill is on!');\n} else {\nconsole.log('Autofill is off!');\n}\n});\nChanging the value of a setting is a little bit more complex, because you first must verify\nthat your extension can control the setting. The user won't see any change to their settings if your\nextension toggles a setting that is either locked to a specific value by enterprise policies\n(levelOfControl\nwill be set to \"not_controllable\"), or if another extension is controlling the\nvalue (levelOfControl\nwill be set to \"controlled_by_other_extensions\"). The set()\ncall will\nsucceed, but the setting will be immediately overridden. As this might be confusing, it is advisable\nto warn the user when the settings they've chosen aren't practically applied.\nThis means that you ought to use the get()\nmethod to determine your level of access, and then only\ncall set()\nif your extension can grab control over the setting (in fact if your extension can't\ncontrol the setting it's probably a good idea to visually disable the feature to reduce user\nconfusion):\nchrome.privacy.services.autofillCreditCardEnabled.get({}, function(details) {\nif (details.levelOfControl === 'controllable_by_this_extension') {\nchrome.privacy.services.autofillCreditCardEnabled.set({ value: true }, function() {\nif (chrome.runtime.lastError === undefined) {\nconsole.log(\"Hooray, it worked!\");\n} else {\nconsole.log(\"Sadness!\", chrome.runtime.lastError);\n}\n});\n}\n});\nIf you're interested in changes to a setting's value, add a listener to its onChange\nevent. Among\nother uses, this will allow you to warn the user if a more recently installed extension grabs\ncontrol of a setting, or if enterprise policy overrides your control. To listen for changes to\ncredit card autofill status, for example, the following code would suffice:\nchrome.privacy.services.autofillCreditCardEnabled.onChange.addListener(\nfunction (details) {\n// The new value is stored in `details.value`, the new level of control\n// in `details.levelOfControl`, and `details.incognitoSpecific` will be\n// `true` if the value is specific to Incognito mode.\n}\n);\nExamples\nTo try this API, install the privacy API example from the chrome-extension-samples repository.\nTypes\nIPHandlingPolicy\nThe IP handling policy of WebRTC.\nEnum\n\"default\" \"default_public_and_private_interfaces\" \"default_public_interface_only\" \"disable_non_proxied_udp\"\nProperties\nnetwork\nSettings that influence Chrome's handling of network connections in general.\nType\nobject\nProperties\n-\nnetworkPredictionEnabled\ntypes.ChromeSetting<boolean>\nIf enabled, Chrome attempts to speed up your web browsing experience by pre-resolving DNS entries and preemptively opening TCP and SSL connections to servers. This preference only affects actions taken by Chrome's internal prediction service. It does not affect webpage-initiated prefectches or preconnects. This preference's value is a boolean, defaulting to\ntrue\n. -\nwebRTCIPHandlingPolicyChrome 48+\nAllow users to specify the media performance/privacy tradeoffs which impacts how WebRTC traffic will be routed and how much local address information is exposed. This preference's value is of type IPHandlingPolicy, defaulting to\ndefault\n.\nservices\nSettings that enable or disable features that require third-party network services provided by Google and your default search provider.\nType\nobject\nProperties\n-\nalternateErrorPagesEnabled\ntypes.ChromeSetting<boolean>\nIf enabled, Chrome uses a web service to help resolve navigation errors. This preference's value is a boolean, defaulting to\ntrue\n. -\nautofillAddressEnabled\ntypes.ChromeSetting<boolean>\nChrome 70+If enabled, Chrome offers to automatically fill in addresses and other form data. This preference's value is a boolean, defaulting to\ntrue\n. -\nautofillCreditCardEnabled\ntypes.ChromeSetting<boolean>\nChrome 70+If enabled, Chrome offers to automatically fill in credit card forms. This preference's value is a boolean, defaulting to\ntrue\n. -\nautofillEnabled\ntypes.ChromeSetting<boolean>\nDeprecated since Chrome 70Please use privacy.services.autofillAddressEnabled and privacy.services.autofillCreditCardEnabled. This remains for backward compatibility in this release and will be removed in the future.\nIf enabled, Chrome offers to automatically fill in forms. This preference's value is a boolean, defaulting to\ntrue\n. -\npasswordSavingEnabled\ntypes.ChromeSetting<boolean>\nIf enabled, the password manager will ask if you want to save passwords. This preference's value is a boolean, defaulting to\ntrue\n. -\nsafeBrowsingEnabled\ntypes.ChromeSetting<boolean>\nIf enabled, Chrome does its best to protect you from phishing and malware. This preference's value is a boolean, defaulting to\ntrue\n. -\nsafeBrowsingExtendedReportingEnabled\ntypes.ChromeSetting<boolean>\nIf enabled, Chrome will send additional information to Google when SafeBrowsing blocks a page, such as the content of the blocked page. This preference's value is a boolean, defaulting to\nfalse\n. -\nsearchSuggestEnabled\ntypes.ChromeSetting<boolean>\nIf enabled, Chrome sends the text you type into the Omnibox to your default search engine, which provides predictions of websites and searches that are likely completions of what you've typed so far. This preference's value is a boolean, defaulting to\ntrue\n. -\nspellingServiceEnabled\ntypes.ChromeSetting<boolean>\nIf enabled, Chrome uses a web service to help correct spelling errors. This preference's value is a boolean, defaulting to\nfalse\n. -\ntranslationServiceEnabled\ntypes.ChromeSetting<boolean>\nIf enabled, Chrome offers to translate pages that aren't in a language you read. This preference's value is a boolean, defaulting to\ntrue\n.\nwebsites\nSettings that determine what information Chrome makes available to websites.\nType\nobject\nProperties\n-\nadMeasurementEnabled\ntypes.ChromeSetting<boolean>\nChrome 111+If disabled, the Attribution Reporting API and Private Aggregation API are deactivated. The value of this preference is of type boolean, and the default value is\ntrue\n. Extensions may only disable these APIs by setting the value tofalse\n. If you try setting these APIs totrue\n, it will throw an error. -\ndoNotTrackEnabled\ntypes.ChromeSetting<boolean>\nChrome 65+If enabled, Chrome sends 'Do Not Track' (\nDNT: 1\n) header with your requests. The value of this preference is of type boolean, and the default value isfalse\n. -\nfledgeEnabled\ntypes.ChromeSetting<boolean>\nChrome 111+If disabled, the Fledge API is deactivated. The value of this preference is of type boolean, and the default value is\ntrue\n. Extensions may only disable this API by setting the value tofalse\n. If you try setting this API totrue\n, it will throw an error. -\nhyperlinkAuditingEnabled\ntypes.ChromeSetting<boolean>\nIf enabled, Chrome sends auditing pings when requested by a website (\n<a ping>\n). The value of this preference is of type boolean, and the default value istrue\n. -\nprotectedContentEnabled\ntypes.ChromeSetting<boolean>\nAvailable on Windows and ChromeOS only: If enabled, Chrome provides a unique ID to plugins in order to run protected content. The value of this preference is of type boolean, and the default value is\ntrue\n. -\nreferrersEnabled\ntypes.ChromeSetting<boolean>\nIf enabled, Chrome sends\nreferer\nheaders with your requests. Yes, the name of this preference doesn't match the misspelled header. No, we're not going to change it. The value of this preference is of type boolean, and the default value istrue\n. -\ntypes.ChromeSetting<boolean>\nChrome 121+If disabled, Related Website Sets is deactivated. The value of this preference is of type boolean, and the default value is\ntrue\n. Extensions may only disable this API by setting the value tofalse\n. If you try setting this API totrue\n, it will throw an error. -\nthirdPartyCookiesAllowed\ntypes.ChromeSetting<boolean>\nIf disabled, Chrome blocks third-party sites from setting cookies. The value of this preference is of type boolean, and the default value is\ntrue\n. -\ntopicsEnabled\ntypes.ChromeSetting<boolean>\nChrome 111+If disabled, the Topics API is deactivated. The value of this preference is of type boolean, and the default value is\ntrue\n. Extensions may only disable this API by setting the value tofalse\n. If you try setting this API totrue\n, it will throw an error."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/processes", "title": "chrome.processes | API | Chrome for Developers", "text": "Description\nUse the chrome.processes\nAPI to interact with the browser's processes.\nPermissions\nprocesses\nAvailability\nTypes\nCache\nProperties\n-\nliveSize\nnumber\nThe part of the cache that is utilized, in bytes.\n-\nsize\nnumber\nThe size of the cache, in bytes.\nProcess\nProperties\n-\ncpu\nnumber optional\nThe most recent measurement of the process's CPU usage, expressed as the percentage of a single CPU core used in total, by all of the process's threads. This gives a value from zero to CpuInfo.numOfProcessors*100, which can exceed 100% in multi-threaded processes. Only available when receiving the object as part of a callback from onUpdated or onUpdatedWithMemory.\n-\ncssCache\nCache optional\nThe most recent information about the CSS cache for the process. Only available when receiving the object as part of a callback from onUpdated or onUpdatedWithMemory.\n-\nid\nnumber\nUnique ID of the process provided by the browser.\n-\nimageCache\nCache optional\nThe most recent information about the image cache for the process. Only available when receiving the object as part of a callback from onUpdated or onUpdatedWithMemory.\n-\njsMemoryAllocated\nnumber optional\nThe most recent measurement of the process JavaScript allocated memory, in bytes. Only available when receiving the object as part of a callback from onUpdated or onUpdatedWithMemory.\n-\njsMemoryUsed\nnumber optional\nThe most recent measurement of the process JavaScript memory used, in bytes. Only available when receiving the object as part of a callback from onUpdated or onUpdatedWithMemory.\n-\nnaclDebugPort\nnumber\nThe debugging port for Native Client processes. Zero for other process types and for NaCl processes that do not have debugging enabled.\n-\nnetwork\nnumber optional\nThe most recent measurement of the process network usage, in bytes per second. Only available when receiving the object as part of a callback from onUpdated or onUpdatedWithMemory.\n-\nosProcessId\nnumber\nThe ID of the process, as provided by the OS.\n-\nprivateMemory\nnumber optional\nThe most recent measurement of the process private memory usage, in bytes. Only available when receiving the object as part of a callback from onUpdatedWithMemory or getProcessInfo with the includeMemory flag.\n-\nprofile\nstring\nThe profile which the process is associated with.\n-\nscriptCache\nCache optional\nThe most recent information about the script cache for the process. Only available when receiving the object as part of a callback from onUpdated or onUpdatedWithMemory.\n-\nsqliteMemory\nnumber optional\nThe most recent measurement of the process's SQLite memory usage, in bytes. Only available when receiving the object as part of a callback from onUpdated or onUpdatedWithMemory.\n-\ntasks\nTaskInfo[]\nArray of TaskInfos representing the tasks running on this process.\n-\ntype\nThe type of process.\nProcessType\nThe types of the browser processes.\nEnum\n\"browser\" \"renderer\" \"extension\" \"notification\" \"plugin\" \"worker\" \"nacl\" \"service_worker\" \"utility\" \"gpu\" \"other\"\nTaskInfo\nProperties\n-\ntabId\nnumber optional\nOptional tab ID, if this task represents a tab running on a renderer process.\n-\ntitle\nstring\nThe title of the task.\nMethods\ngetProcessIdForTab()\nchrome.processes.getProcessIdForTab(\ntabId: number,\ncallback?: function,\n)\nReturns the ID of the renderer process for the specified tab.\nParameters\n-\ntabId\nnumber\nThe ID of the tab for which the renderer process ID is to be returned.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(processId: number) => void\n-\nprocessId\nnumber\nProcess ID of the tab's renderer process.\n-\nReturns\n-\nPromise<number>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetProcessInfo()\nchrome.processes.getProcessInfo(\nprocessIds: number | number[],\nincludeMemory: boolean,\ncallback?: function,\n)\nRetrieves the process information for each process ID specified.\nParameters\n-\nprocessIds\nnumber | number[]\nThe list of process IDs or single process ID for which to return the process information. An empty list indicates all processes are requested.\n-\nincludeMemory\nboolean\nTrue if detailed memory usage is required. Note, collecting memory usage information incurs extra CPU usage and should only be queried for when needed.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(processes: object) => void\n-\nprocesses\nobject\nA dictionary of\nProcess\nobjects for each requested process that is a live child process of the current browser process, indexed by process ID. Metrics requiring aggregation over time will not be populated in each Process object.\n-\nReturns\n-\nPromise<object>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nterminate()\nchrome.processes.terminate(\nprocessId: number,\ncallback?: function,\n)\nTerminates the specified renderer process. Equivalent to visiting about:crash, but without changing the tab's URL.\nParameters\n-\nprocessId\nnumber\nThe ID of the process to be terminated.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(didTerminate: boolean) => void\n-\ndidTerminate\nboolean\nTrue if terminating the process was successful, and false otherwise.\n-\nReturns\n-\nPromise<boolean>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonCreated\nchrome.processes.onCreated.addListener(\ncallback: function,\n)\nFired each time a process is created, providing the corrseponding Process object.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(process: Process) => void\n-\nprocess\n-\nonExited\nchrome.processes.onExited.addListener(\ncallback: function,\n)\nFired each time a process is terminated, providing the type of exit.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(processId: number, exitType: number, exitCode: number) => void\n-\nprocessId\nnumber\n-\nexitType\nnumber\n-\nexitCode\nnumber\n-\nonUnresponsive\nchrome.processes.onUnresponsive.addListener(\ncallback: function,\n)\nFired each time a process becomes unresponsive, providing the corrseponding Process object.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(process: Process) => void\n-\nprocess\n-\nonUpdated\nchrome.processes.onUpdated.addListener(\ncallback: function,\n)\nFired each time the Task Manager updates its process statistics, providing the dictionary of updated Process objects, indexed by process ID.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(processes: object) => void\n-\nprocesses\nobject\n-\nonUpdatedWithMemory\nchrome.processes.onUpdatedWithMemory.addListener(\ncallback: function,\n)\nFired each time the Task Manager updates its process statistics, providing the dictionary of updated Process objects, indexed by process ID. Identical to onUpdate, with the addition of memory usage details included in each Process object. Note, collecting memory usage information incurs extra CPU usage and should only be listened for when needed.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(processes: object) => void\n-\nprocesses\nobject\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/proxy", "title": "chrome.proxy | API | Chrome for Developers", "text": "Description\nUse the chrome.proxy\nAPI to manage Chrome's proxy settings. This API relies on the ChromeSetting prototype of the type API for getting and setting the proxy configuration.\nPermissions\nproxy\nYou must declare the \"proxy\" permission in the extension manifest to use the proxy settings API. For example:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"proxy\"\n],\n...\n}\nConcepts and usage\nProxy settings are defined in a proxy.ProxyConfig\nobject. Depending on Chrome's proxy settings,\nthe settings may contain proxy.ProxyRules\nor a proxy.PacScript\n.\nProxy modes\nA ProxyConfig object's mode\nattribute determines the overall behavior of Chrome with regards to\nproxy usage. It can take the following values:\ndirect\n- In\ndirect\nmode all connections are created directly, without any proxy involved. This mode allows no further parameters in theProxyConfig\nobject. auto_detect\n- In\nauto_detect\nmode the proxy configuration is determined by a PAC script that can be downloaded at http://wpad/wpad.dat. This mode allows no further parameters in theProxyConfig\nobject. pac_script\n- In\npac_script\nmode the proxy configuration is determined by a PAC script that is either retrieved from the URL specified in theproxy.PacScript\nobject or taken literally from thedata\nelement specified in theproxy.PacScript\nobject. Besides this, this mode allows no further parameters in theProxyConfig\nobject. fixed_servers\n- In\nfixed_servers\nmode the proxy configuration is codified in aproxy.ProxyRules\nobject. Its structure is described in Proxy rules. Besides this, thefixed_servers\nmode allows no further parameters in theProxyConfig\nobject. system\n- In\nsystem\nmode the proxy configuration is taken from the operating system. This mode allows no further parameters in theProxyConfig\nobject. Note that thesystem\nmode is different from setting no proxy configuration. In the latter case, Chrome falls back to the system settings only if no command-line options influence the proxy configuration.\nProxy rules\nThe proxy.ProxyRules\nobject can contain either a singleProxy\nattribute or a subset of\nproxyForHttp\n, proxyForHttps\n, proxyForFtp\n, and fallbackProxy\n.\nIn the first case, HTTP, HTTPS and FTP traffic is proxied through the specified proxy server. Other\ntraffic is sent directly. In the latter case the behavior is slightly more subtle: If a proxy server\nis configured for the HTTP, HTTPS or FTP protocol, the respective traffic is proxied through the\nspecified server. If no such proxy server is specified or traffic uses a different protocol than\nHTTP, HTTPS or FTP, the fallbackProxy\nis used. If no fallbackProxy\nis specified, traffic is sent\ndirectly without a proxy server.\nProxy server objects\nA proxy server is configured in a proxy.ProxyServer\nobject. The connection to the proxy server\n(defined by the host\nattribute) uses the protocol defined in the scheme\nattribute. If no\nscheme\nis specified, the proxy connection defaults to http\n.\nIf no port\nis defined in a proxy.ProxyServer\nobject, the port is derived from the scheme.\nThe default ports are:\n| Scheme | Port |\n|---|---|\n| http | 80 |\n| https | 443 |\n| socks4 | 1080 |\n| socks5 | 1080 |\nBypass list\nIndividual servers may be excluded from being proxied with the bypassList\n. This list may contain\nthe following entries:\n[SCHEME://]HOST_PATTERN[:PORT]\nMatch all hostnames that match the pattern\nHOST_PATTERN\n. A leading\".\"\nis interpreted as a\"*.\"\n.Examples:\n\"foobar.com\", \"*foobar.com\", \"*.foobar.com\", \"*foobar.com:99\", \"https://x.*.y.com:99\"\n.Pattern Matches Does not match \".foobar.com\"\n\"www.foobar.com\"\n\"foobar.com\"\n\"*.foobar.com\"\n\"www.foobar.com\"\n\"foobar.com\"\n\"foobar.com\"\n\"foobar.com\"\n\"www.foobar.com\"\n\"*foobar.com\"\n\"foobar.com\"\n,\"www.foobar.com\"\n,\"foofoobar.com\"\n[SCHEME://]IP_LITERAL[:PORT]\nMatch URLs that are IP address literals. Conceptually this is the similar to the first case, but with special cases to handle IP literal canonicalization. For example, matching on \"[0:0:0::1]\" is the same as matching on \"[::1]\" because the IPv6 canonicalization is done internally.\nExamples:\n127.0.1\n,[0:0::1]\n,[::1]:80\n,https://[::1]:443\nIP_LITERAL/PREFIX_LENGTH_IN_BITS\nMatch any URL containing an IP literal (\nIP_LITERAL\n) within the given range. The IP range (PREFIX_LENGTH_IN_BITS\n) is specified using CIDR notation.Match any URL containing an IP literal within the given range. The IP range is specified using CIDR notation. Examples:\n\"192.168.1.1/16\", \"fefe:13::abc/33\"\n<local>\nThe literal string\n<local>\nmatches simple hostnames. A simple hostname is one that contains no dots and is not an IP literal. For instanceexample\nandlocalhost\nare simple hostnames, whereasexample.com\n,example.\n, and[::1]\nare not.Example:\n\"<local>\"\nExamples\nThe following code sets a SOCKS 5 proxy for HTTP connections to all servers but foobar.com and uses direct connections for all other protocols. The settings apply to regular and incognito windows, as incognito windows inherit settings from regular windows. See also the Types API documentation.\nvar config = {\nmode: \"fixed_servers\",\nrules: {\nproxyForHttp: {\nscheme: \"socks5\",\nhost: \"1.2.3.4\"\n},\nbypassList: [\"foobar.com\"]\n}\n};\nchrome.proxy.settings.set(\n{value: config, scope: 'regular'},\nfunction() {}\n);\nThe following code sets a custom PAC script.\nvar config = {\nmode: \"pac_script\",\npacScript: {\ndata: \"function FindProxyForURL(url, host) {\\n\" +\n\" if (host == 'foobar.com')\\n\" +\n\" return 'PROXY blackhole:80';\\n\" +\n\" return 'DIRECT';\\n\" +\n\"}\"\n}\n};\nchrome.proxy.settings.set(\n{value: config, scope: 'regular'},\nfunction() {}\n);\nThe next snippet queries the current effective proxy settings. The effective proxy settings can be determined by another extension or by a policy. See the Types API documentation for details.\nchrome.proxy.settings.get(\n{'incognito': false},\nfunction(config) {\nconsole.log(JSON.stringify(config));\n}\n);\nNote that the value\nobject passed to set()\nis not identical to the value\nobject passed to\ncallback function of get()\n. The latter will contain a rules.proxyForHttp.port\nelement.\nTypes\nMode\nEnum\n\"direct\" \"auto_detect\" \"pac_script\" \"fixed_servers\" \"system\"\nPacScript\nAn object holding proxy auto-config information. Exactly one of the fields should be non-empty.\nProperties\n-\ndata\nstring optional\nA PAC script.\n-\nmandatory\nboolean optional\nIf true, an invalid PAC script will prevent the network stack from falling back to direct connections. Defaults to false.\n-\nurl\nstring optional\nURL of the PAC file to be used.\nProxyConfig\nAn object encapsulating a complete proxy configuration.\nProperties\n-\nmode\n'direct' = Never use a proxy 'auto_detect' = Auto detect proxy settings 'pac_script' = Use specified PAC script 'fixed_servers' = Manually specify proxy servers 'system' = Use system proxy settings\n-\npacScript\nPacScript optional\nThe proxy auto-config (PAC) script for this configuration. Use this for 'pac_script' mode.\n-\nrules\nProxyRules optional\nThe proxy rules describing this configuration. Use this for 'fixed_servers' mode.\nProxyRules\nAn object encapsulating the set of proxy rules for all protocols. Use either 'singleProxy' or (a subset of) 'proxyForHttp', 'proxyForHttps', 'proxyForFtp' and 'fallbackProxy'.\nProperties\n-\nbypassList\nstring[] optional\nList of servers to connect to without a proxy server.\n-\nfallbackProxy\nProxyServer optional\nThe proxy server to be used for everthing else or if any of the specific proxyFor... is not specified.\n-\nproxyForFtp\nProxyServer optional\nThe proxy server to be used for FTP requests.\n-\nproxyForHttp\nProxyServer optional\nThe proxy server to be used for HTTP requests.\n-\nproxyForHttps\nProxyServer optional\nThe proxy server to be used for HTTPS requests.\n-\nsingleProxy\nProxyServer optional\nThe proxy server to be used for all per-URL requests (that is http, https, and ftp).\nProxyServer\nAn object encapsulating a single proxy server's specification.\nProperties\n-\nhost\nstring\nThe hostname or IP address of the proxy server. Hostnames must be in ASCII (in Punycode format). IDNA is not supported, yet.\n-\nport\nnumber optional\nThe port of the proxy server. Defaults to a port that depends on the scheme.\n-\nscheme\nScheme optional\nThe scheme (protocol) of the proxy server itself. Defaults to 'http'.\nScheme\nEnum\n\"http\" \"https\" \"quic\" \"socks4\" \"socks5\"\nProperties\nsettings\nProxy settings to be used. The value of this setting is a ProxyConfig object.\nEvents\nonProxyError\nchrome.proxy.onProxyError.addListener(\ncallback: function,\n)\nNotifies about proxy errors.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndetails\nstring\nAdditional details about the error such as a JavaScript runtime error.\n-\nerror\nstring\nThe error description.\n-\nfatal\nboolean\nIf true, the error was fatal and the network transaction was aborted. Otherwise, a direct connection is used instead.\n-\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/readingList", "title": "chrome.readingList | API | Chrome for Developers", "text": "Description\nUse the chrome.readingList\nAPI to read from and modify the items in the Reading List.\nPermissions\nreadingList\nTo use the Reading List API, add the \"readingList\"\npermission in the extension manifest file:\nmanifest.json:\n{\n\"name\": \"My reading list extension\",\n...\n\"permissions\": [\n\"readingList\"\n]\n}\nAvailability\nChrome features a reading list located on the side panel. It lets users save web pages to read later or when offline. Use the Reading List API to retrieve existing items and add or remove items from the list.\nConcepts and usage\nItem ordering\nItems in the reading list are not in any guaranteed order.\nItem uniqueness\nItems are keyed by URL. This includes the hash and query string.\nUse cases\nThe following sections demonstrate some common use cases for the Reading List API. See Extension samples for complete extension examples.\nAdd an item\nTo add an item to the reading list, use chrome.readingList.addEntry()\n:\nchrome.readingList.addEntry({\ntitle: \"New to the web platform in September | web.dev\",\nurl: \"https://developer.chrome.com/\",\nhasBeenRead: false\n});\nDisplay items\nTo display items from the reading list, use the chrome.readingList.query()\nmethod to retrieve them.\nmethod.\nconst items = await chrome.readingList.query({});\nfor (const item of items) {\n// Do something do display the item\n}\nMark an item as read\nYou can use chrome.readingList.updateEntry()\nto update the title, URL, and read status. The following code marks an item as read:\nchrome.readingList.updateEntry({\nurl: \"https://developer.chrome.com/\",\nhasBeenRead: true\n});\nRemove an item\nTo remove an item, use chrome.readingList.removeEntry()\n:\nchrome.readingList.removeEntry({\nurl: \"https://developer.chrome.com/\"\n});\nExtension samples\nFor more Reading List API extensions demos, see the Reading List API sample.\nTypes\nAddEntryOptions\nProperties\n-\nhasBeenRead\nboolean\nWill be\ntrue\nif the entry has been read. -\ntitle\nstring\nThe title of the entry.\n-\nurl\nstring\nThe url of the entry.\nQueryInfo\nProperties\n-\nhasBeenRead\nboolean optional\nIndicates whether to search for read (\ntrue\n) or unread (false\n) items. -\ntitle\nstring optional\nA title to search for.\n-\nurl\nstring optional\nA url to search for.\nReadingListEntry\nProperties\n-\ncreationTime\nnumber\nThe time the entry was created. Recorded in milliseconds since Jan 1, 1970.\n-\nhasBeenRead\nboolean\nWill be\ntrue\nif the entry has been read. -\nlastUpdateTime\nnumber\nThe last time the entry was updated. This value is in milliseconds since Jan 1, 1970.\n-\ntitle\nstring\nThe title of the entry.\n-\nurl\nstring\nThe url of the entry.\nRemoveOptions\nProperties\n-\nurl\nstring\nThe url to remove.\nUpdateEntryOptions\nProperties\n-\nhasBeenRead\nboolean optional\nThe updated read status. The existing status remains if a value isn't provided.\n-\ntitle\nstring optional\nThe new title. The existing tile remains if a value isn't provided.\n-\nurl\nstring\nThe url that will be updated.\nMethods\naddEntry()\nchrome.readingList.addEntry(\nentry: AddEntryOptions,\ncallback?: function,\n)\nAdds an entry to the reading list if it does not exist.\nParameters\n-\nentry\nThe entry to add to the reading list.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nquery()\nchrome.readingList.query(\ninfo: QueryInfo,\ncallback?: function,\n)\nRetrieves all entries that match the QueryInfo\nproperties. Properties that are not provided will not be matched.\nParameters\n-\ninfo\nThe properties to search for.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(entries: ReadingListEntry[]) => void\n-\nentries\n-\nReturns\n-\nPromise<ReadingListEntry[]>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveEntry()\nchrome.readingList.removeEntry(\ninfo: RemoveOptions,\ncallback?: function,\n)\nRemoves an entry from the reading list if it exists.\nParameters\n-\ninfo\nThe entry to remove from the reading list.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdateEntry()\nchrome.readingList.updateEntry(\ninfo: UpdateEntryOptions,\ncallback?: function,\n)\nUpdates a reading list entry if it exists.\nParameters\n-\ninfo\nThe entry to update.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonEntryAdded\nchrome.readingList.onEntryAdded.addListener(\ncallback: function,\n)\nTriggered when a ReadingListEntry\nis added to the reading list.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(entry: ReadingListEntry) => void\n-\nentry\n-\nonEntryRemoved\nchrome.readingList.onEntryRemoved.addListener(\ncallback: function,\n)\nTriggered when a ReadingListEntry\nis removed from the reading list.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(entry: ReadingListEntry) => void\n-\nentry\n-\nonEntryUpdated\nchrome.readingList.onEntryUpdated.addListener(\ncallback: function,\n)\nTriggered when a ReadingListEntry\nis updated in the reading list.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(entry: ReadingListEntry) => void\n-\nentry\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/runtime", "title": "chrome.runtime | API | Chrome for Developers", "text": "Description\nUse the chrome.runtime\nAPI to retrieve the service worker, return details about the manifest, and listen for and respond to events in the extension lifecycle. You can also use this API to convert the relative path of URLs to fully-qualified URLs.\nMost members of this API do not require any permissions. This permission is needed for connectNative()\n, sendNativeMessage()\nand onNativeConnect\n.\nThe following example shows how to declare the \"nativeMessaging\"\npermission in the manifest:\nmanifest.json:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"nativeMessaging\"\n],\n...\n}\nConcepts and usage\nThe Runtime API provides methods to support a number of areas that your extensions can use:\n- Message passing\n- Your extension can communicate with different contexts within your extension and also with other extensions using these methods and events:\nconnect()\n,onConnect\n,onConnectExternal\n,sendMessage()\n,onMessage\nandonMessageExternal\n. In addition, your extension can pass messages to native applications on the user's device usingconnectNative()\nandsendNativeMessage()\n.\n- Accessing extension and platform metadata\n- These methods let you retrieve several specific pieces of metadata about the extension and the\nplatform. Methods in this category include\ngetManifest()\n, andgetPlatformInfo()\n. - Managing extension lifecycle and options\n- These properties let you perform some meta-operations on the extension, and display the options page.\nMethods and events in this category include\nonInstalled\n,onStartup\n,openOptionsPage()\n,reload()\n,requestUpdateCheck()\n, andsetUninstallURL()\n. - Helper utilities\n- These methods provide utility such as the conversion of internal resource representations to\nexternal formats. Methods in this category include\ngetURL()\n. - Kiosk mode utilities\n- These methods are available only on ChromeOS, and exist mainly to support kiosk implementations.\nMethods in this category include\nrestart()\nandrestartAfterDelay()\n`.\nUnpacked extension behavior\nWhen an unpacked extension is reloaded, this is treated as an update. This means that the\nchrome.runtime.onInstalled\nevent will fire with the \"update\"\nreason. This\nincludes when the extension is reloaded with chrome.runtime.reload()\n.\nUse cases\nAdd an image to a web page\nFor a web page to access an asset hosted on another domain, it must specify the resource's full URL\n(e.g. <img src=\"https://example.com/logo.png\">\n). The same is true to include an extension asset on\na web page. The two differences are that the extension's assets must be exposed as web\naccessible resources and that typically content scripts are responsible for injecting\nextension assets.\nIn this example, the extension will add logo.png\nto the page that the content\nscript is being injected into by using runtime.getURL()\nto create a\nfully-qualified URL. But first, the asset must be declared as a web accessible resource in the manifest.\nmanifest.json:\n{\n...\n\"web_accessible_resources\": [\n{\n\"resources\": [ \"logo.png\" ],\n\"matches\": [ \"https://*/*\" ]\n}\n],\n...\n}\ncontent.js:\n{ // Block used to avoid setting global variables\nconst img = document.createElement('img');\nimg.src = chrome.runtime.getURL('logo.png');\ndocument.body.append(img);\n}\nSend data from a content script to the service worker\nIts common for an extension's content scripts to need data managed by another part of the extension, like the service worker. Much like two browser windows opened to the same web page, these two contexts cannot directly access each other's values. Instead, the extension can use message passing to coordinate across these different contexts.\nIn this example, the content script needs some data from the extension's service worker to\ninitialize its UI. To get this data, it passes the developer-defined get-user-data\nmessage\nto the service worker, and it responds with a copy of the user's information.\ncontent.js:\n// 1. Send a message to the service worker requesting the user's data\nchrome.runtime.sendMessage('get-user-data', (response) => {\n// 3. Got an asynchronous response with the data from the service worker\nconsole.log('received user data', response);\ninitializeUI(response);\n});\nservice-worker.js:\n// Example of a simple user data object\nconst user = {\nusername: 'demo-user'\n};\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n// 2. A page requested user data, respond with a copy of `user`\nif (message === 'get-user-data') {\nsendResponse(user);\n}\n});\nGather feedback on uninstall\nMany extensions use post-uninstall surveys to understand how the extension could better serve its users and improve retention. The following example shows how to add this functionality.\nbackground.js:\nchrome.runtime.onInstalled.addListener(details => {\nif (details.reason === chrome.runtime.OnInstalledReason.INSTALL) {\nchrome.runtime.setUninstallURL('https://example.com/extension-survey');\n}\n});\nExamples\nSee the Manifest V3 - Web Accessible Resources demo for more Runtime API examples.\nTypes\nContextFilter\nA filter to match against certain extension contexts. Matching contexts must match all specified filters; any filter that is not specified matches all available contexts. Thus, a filter of `{}` will match all available contexts.\nProperties\n-\ncontextIds\nstring[] optional\n-\ncontextTypes\nContextType[] optional\n-\ndocumentIds\nstring[] optional\n-\ndocumentOrigins\nstring[] optional\n-\ndocumentUrls\nstring[] optional\n-\nframeIds\nnumber[] optional\n-\nincognito\nboolean optional\n-\ntabIds\nnumber[] optional\n-\nwindowIds\nnumber[] optional\nContextType\nEnum\n\"TAB\" \"POPUP\" \"BACKGROUND\" \"OFFSCREEN_DOCUMENT\" \"SIDE_PANEL\" \"DEVELOPER_TOOLS\"\nSpecifies the context type as a tab\nSpecifies the context type as an extension popup window\nSpecifies the context type as a service worker.\nSpecifies the context type as an offscreen document.\nSpecifies the context type as a side panel.\nSpecifies the context type as developer tools.\nExtensionContext\nA context hosting extension content.\nProperties\n-\ncontextId\nstring\nA unique identifier for this context\n-\ncontextType\nThe type of context this corresponds to.\n-\ndocumentId\nstring optional\nA UUID for the document associated with this context, or undefined if this context is hosted not in a document.\n-\ndocumentOrigin\nstring optional\nThe origin of the document associated with this context, or undefined if the context is not hosted in a document.\n-\ndocumentUrl\nstring optional\nThe URL of the document associated with this context, or undefined if the context is not hosted in a document.\n-\nframeId\nnumber\nThe ID of the frame for this context, or -1 if this context is not hosted in a frame.\n-\nincognito\nboolean\nWhether the context is associated with an incognito profile.\n-\ntabId\nnumber\nThe ID of the tab for this context, or -1 if this context is not hosted in a tab.\n-\nwindowId\nnumber\nThe ID of the window for this context, or -1 if this context is not hosted in a window.\nMessageSender\nAn object containing information about the script context that sent a message or request.\nProperties\n-\ndocumentId\nstring optional\nChrome 106+A UUID of the document that opened the connection.\n-\ndocumentLifecycle\nstring optional\nChrome 106+The lifecycle the document that opened the connection is in at the time the port was created. Note that the lifecycle state of the document may have changed since port creation.\n-\nframeId\nnumber optional\nThe frame that opened the connection. 0 for top-level frames, positive for child frames. This will only be set when\ntab\nis set. -\nid\nstring optional\nThe ID of the extension that opened the connection, if any.\n-\nnativeApplication\nstring optional\nChrome 74+The name of the native application that opened the connection, if any.\n-\norigin\nstring optional\nChrome 80+The origin of the page or frame that opened the connection. It can vary from the url property (e.g., about:blank) or can be opaque (e.g., sandboxed iframes). This is useful for identifying if the origin can be trusted if we can't immediately tell from the URL.\n-\ntab\nTab optional\nThe\ntabs.Tab\nwhich opened the connection, if any. This property will only be present when the connection was opened from a tab (including content scripts), and only if the receiver is an extension, not an app. -\ntlsChannelId\nstring optional\nThe TLS channel ID of the page or frame that opened the connection, if requested by the extension, and if available.\n-\nurl\nstring optional\nThe URL of the page or frame that opened the connection. If the sender is in an iframe, it will be iframe's URL not the URL of the page which hosts it.\nOnInstalledReason\nThe reason that this event is being dispatched.\nEnum\n\"install\" \"update\" \"chrome_update\" \"shared_module_update\"\nSpecifies the event reason as an installation.\nSpecifies the event reason as an extension update.\nSpecifies the event reason as a Chrome update.\nSpecifies the event reason as an update to a shared module.\nOnRestartRequiredReason\nThe reason that the event is being dispatched. 'app_update' is used when the restart is needed because the application is updated to a newer version. 'os_update' is used when the restart is needed because the browser/OS is updated to a newer version. 'periodic' is used when the system runs for more than the permitted uptime set in the enterprise policy.\nEnum\n\"app_update\" \"os_update\" \"periodic\"\nSpecifies the event reason as an update to the app.\nSpecifies the event reason as an update to the operating system.\nSpecifies the event reason as a periodic restart of the app.\nPlatformArch\nThe machine's processor architecture.\nEnum\n\"arm\" \"arm64\" \"x86-32\" \"x86-64\" \"mips\" \"mips64\"\nSpecifies the processer architecture as arm.\nSpecifies the processer architecture as arm64.\nSpecifies the processer architecture as x86-32.\nSpecifies the processer architecture as x86-64.\nSpecifies the processer architecture as mips.\nSpecifies the processer architecture as mips64.\nPlatformInfo\nAn object containing information about the current platform.\nProperties\n-\narch\nThe machine's processor architecture.\n-\nnacl_arch\nThe native client architecture. This may be different from arch on some platforms.\n-\nos\nThe operating system Chrome is running on.\nPlatformNaclArch\nThe native client architecture. This may be different from arch on some platforms.\nEnum\n\"arm\" \"x86-32\" \"x86-64\" \"mips\" \"mips64\"\nSpecifies the native client architecture as arm.\nSpecifies the native client architecture as x86-32.\nSpecifies the native client architecture as x86-64.\nSpecifies the native client architecture as mips.\nSpecifies the native client architecture as mips64.\nPlatformOs\nThe operating system Chrome is running on.\nEnum\n\"mac\" \"win\" \"android\" \"cros\" \"linux\" \"openbsd\" \"fuchsia\"\nSpecifies the MacOS operating system.\nSpecifies the Windows operating system.\nSpecifies the Android operating system.\nSpecifies the Chrome operating system.\nSpecifies the Linux operating system.\nSpecifies the OpenBSD operating system.\nSpecifies the Fuchsia operating system.\nPort\nAn object which allows two way communication with other pages. See Long-lived connections for more information.\nProperties\n-\nname\nstring\nThe name of the port, as specified in the call to\nruntime.connect\n. -\nonDisconnect\nEvent<functionvoidvoid>\nFired when the port is disconnected from the other end(s).\nruntime.lastError\nmay be set if the port was disconnected by an error. If the port is closed via disconnect, then this event is only fired on the other end. This event is fired at most once (see also Port lifetime).The\nonDisconnect.addListener\nfunction looks like:(callback: function) => {...}\n-\nonMessage\nEvent<functionvoidvoid>\nThis event is fired when postMessage is called by the other end of the port.\nThe\nonMessage.addListener\nfunction looks like:(callback: function) => {...}\n-\nsender\nMessageSender optional\nThis property will only be present on ports passed to onConnect / onConnectExternal / onConnectNative listeners.\n-\ndisconnect\nvoid\nImmediately disconnect the port. Calling\ndisconnect()\non an already-disconnected port has no effect. When a port is disconnected, no new events will be dispatched to this port.The\ndisconnect\nfunction looks like:() => {...}\n-\npostMessage\nvoid\nSend a message to the other end of the port. If the port is disconnected, an error is thrown.\nThe\npostMessage\nfunction looks like:(message: any) => {...}\n-\nmessage\nany\nChrome 52+The message to send. This object should be JSON-ifiable.\n-\nRequestUpdateCheckStatus\nResult of the update check.\nEnum\n\"throttled\" \"no_update\" \"update_available\"\nSpecifies that the status check has been throttled. This can occur after repeated checks within a short amount of time.\nSpecifies that there are no available updates to install.\nSpecifies that there is an available update to install.\nProperties\nid\nThe ID of the extension/app.\nType\nstring\nlastError\nPopulated with an error message if calling an API function fails; otherwise undefined. This is only defined within the scope of that function's callback. If an error is produced, but runtime.lastError\nis not accessed within the callback, a message is logged to the console listing the API function that produced the error. API functions that return promises do not set this property.\nType\nobject\nProperties\n-\nmessage\nstring optional\nDetails about the error which occurred.\nMethods\nconnect()\nchrome.runtime.connect(\nextensionId?: string,\nconnectInfo?: object,\n)\nAttempts to connect listeners within an extension (such as the background page), or other extensions/apps. This is useful for content scripts connecting to their extension processes, inter-app/extension communication, and web messaging. Note that this does not connect to any listeners in a content script. Extensions may connect to content scripts embedded in tabs via tabs.connect\n.\nParameters\n-\nextensionId\nstring optional\nThe ID of the extension to connect to. If omitted, a connection will be attempted with your own extension. Required if sending messages from a web page for web messaging.\n-\nconnectInfo\nobject optional\n-\nincludeTlsChannelId\nboolean optional\nWhether the TLS channel ID will be passed into onConnectExternal for processes that are listening for the connection event.\n-\nname\nstring optional\nWill be passed into onConnect for processes that are listening for the connection event.\n-\nReturns\n-\nPort through which messages can be sent and received. The port's onDisconnect event is fired if the extension does not exist.\nconnectNative()\nchrome.runtime.connectNative(\napplication: string,\n)\nConnects to a native application in the host machine. This method requires the \"nativeMessaging\"\npermission. See Native Messaging for more information.\nParameters\n-\napplication\nstring\nThe name of the registered application to connect to.\nReturns\n-\nPort through which messages can be sent and received with the application\ngetBackgroundPage()\nchrome.runtime.getBackgroundPage(\ncallback?: function,\n)\nBackground pages do not exist in MV3 extensions.\nRetrieves the JavaScript 'window' object for the background page running inside the current extension/app. If the background page is an event page, the system will ensure it is loaded before calling the callback. If there is no background page, an error is set.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(backgroundPage?: Window) => void\n-\nbackgroundPage\nWindow optional\nThe JavaScript 'window' object for the background page.\n-\nReturns\n-\nPromise<Window | undefined>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetContexts()\nchrome.runtime.getContexts(\nfilter: ContextFilter,\ncallback?: function,\n)\nFetches information about active contexts associated with this extension\nParameters\n-\nfilter\nA filter to find matching contexts. A context matches if it matches all specified fields in the filter. Any unspecified field in the filter matches all contexts.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(contexts: ExtensionContext[]) => void\n-\ncontexts\nThe matching contexts, if any.\n-\nReturns\n-\nPromise<ExtensionContext[]>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetManifest()\nchrome.runtime.getManifest()\nReturns details about the app or extension from the manifest. The object returned is a serialization of the full manifest file.\nReturns\n-\nobject\nThe manifest details.\ngetPackageDirectoryEntry()\nchrome.runtime.getPackageDirectoryEntry(\ncallback?: function,\n)\nReturns a DirectoryEntry for the package directory.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(directoryEntry: DirectoryEntry) => void\n-\ndirectoryEntry\nDirectoryEntry\n-\nReturns\n-\nPromise<DirectoryEntry>\nChrome 122+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetPlatformInfo()\nchrome.runtime.getPlatformInfo(\ncallback?: function,\n)\nReturns information about the current platform.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(platformInfo: PlatformInfo) => void\n-\nplatformInfo\n-\nReturns\n-\nPromise<PlatformInfo>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetURL()\nchrome.runtime.getURL(\npath: string,\n)\nConverts a relative path within an app/extension install directory to a fully-qualified URL.\nParameters\n-\npath\nstring\nA path to a resource within an app/extension expressed relative to its install directory.\nReturns\n-\nstring\nThe fully-qualified URL to the resource.\nopenOptionsPage()\nchrome.runtime.openOptionsPage(\ncallback?: function,\n)\nOpen your Extension's options page, if possible.\nThe precise behavior may depend on your manifest's options_ui\nor options_page\nkey, or what Chrome happens to support at the time. For example, the page may be opened in a new tab, within chrome://extensions, within an App, or it may just focus an open options page. It will never cause the caller page to reload.\nIf your Extension does not declare an options page, or Chrome failed to create one for some other reason, the callback will set lastError\n.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nreload()\nchrome.runtime.reload()\nReloads the app or extension. This method is not supported in kiosk mode. For kiosk mode, use chrome.runtime.restart() method.\nrequestUpdateCheck()\nchrome.runtime.requestUpdateCheck(\ncallback?: function,\n)\nRequests an immediate update check be done for this app/extension.\nImportant: Most extensions/apps should not use this method, since Chrome already does automatic checks every few hours, and you can listen for the runtime.onUpdateAvailable\nevent without needing to call requestUpdateCheck.\nThis method is only appropriate to call in very limited circumstances, such as if your extension talks to a backend service, and the backend service has determined that the client extension version is very far out of date and you'd like to prompt a user to update. Most other uses of requestUpdateCheck, such as calling it unconditionally based on a repeating timer, probably only serve to waste client, network, and server resources.\nNote: When called with a callback, instead of returning an object this function will return the two properties as separate arguments passed to the callback.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: object) => void\n-\nresult\nobject\nChrome 109+RequestUpdateCheckResult object that holds the status of the update check and any details of the result if there is an update available\n-\nstatus\nResult of the update check.\n-\nversion\nstring optional\nIf an update is available, this contains the version of the available update.\n-\n-\nReturns\n-\nPromise<object>\nChrome 109+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nrestart()\nchrome.runtime.restart()\nRestart the ChromeOS device when the app runs in kiosk mode. Otherwise, it's no-op.\nrestartAfterDelay()\nchrome.runtime.restartAfterDelay(\nseconds: number,\ncallback?: function,\n)\nRestart the ChromeOS device when the app runs in kiosk mode after the given seconds. If called again before the time ends, the reboot will be delayed. If called with a value of -1, the reboot will be cancelled. It's a no-op in non-kiosk mode. It's only allowed to be called repeatedly by the first extension to invoke this API.\nParameters\n-\nseconds\nnumber\nTime to wait in seconds before rebooting the device, or -1 to cancel a scheduled reboot.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsendMessage()\nchrome.runtime.sendMessage(\nextensionId?: string,\nmessage: any,\noptions?: object,\ncallback?: function,\n)\nSends a single message to event listeners within your extension or a different extension/app. Similar to runtime.connect\nbut only sends a single message, with an optional response. If sending to your extension, the runtime.onMessage\nevent will be fired in every frame of your extension (except for the sender's frame), or runtime.onMessageExternal\n, if a different extension. Note that extensions cannot send messages to content scripts using this method. To send messages to content scripts, use tabs.sendMessage\n.\nParameters\n-\nextensionId\nstring optional\nThe ID of the extension to send the message to. If omitted, the message will be sent to your own extension/app. Required if sending messages from a web page for web messaging.\n-\nmessage\nany\nThe message to send. This message should be a JSON-ifiable object.\n-\noptions\nobject optional\n-\nincludeTlsChannelId\nboolean optional\nWhether the TLS channel ID will be passed into onMessageExternal for processes that are listening for the connection event.\n-\n-\ncallback\nfunction optional\nChrome 99+The\ncallback\nparameter looks like:(response: any) => void\n-\nresponse\nany\nThe JSON response object sent by the handler of the message. If an error occurs while connecting to the extension, the callback will be called with no arguments and\nruntime.lastError\nwill be set to the error message.\n-\nReturns\n-\nPromise<any>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsendNativeMessage()\nchrome.runtime.sendNativeMessage(\napplication: string,\nmessage: object,\ncallback?: function,\n)\nSend a single message to a native application. This method requires the \"nativeMessaging\"\npermission.\nParameters\n-\napplication\nstring\nThe name of the native messaging host.\n-\nmessage\nobject\nThe message that will be passed to the native messaging host.\n-\ncallback\nfunction optional\nChrome 99+The\ncallback\nparameter looks like:(response: any) => void\n-\nresponse\nany\nThe response message sent by the native messaging host. If an error occurs while connecting to the native messaging host, the callback will be called with no arguments and\nruntime.lastError\nwill be set to the error message.\n-\nReturns\n-\nPromise<any>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetUninstallURL()\nchrome.runtime.setUninstallURL(\nurl: string,\ncallback?: function,\n)\nSets the URL to be visited upon uninstallation. This may be used to clean up server-side data, do analytics, and implement surveys. Maximum 1023 characters.\nParameters\n-\nurl\nstring\nURL to be opened after the extension is uninstalled. This URL must have an http: or https: scheme. Set an empty string to not open a new tab upon uninstallation.\n-\ncallback\nfunction optional\nChrome 45+The\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonBrowserUpdateAvailable\nchrome.runtime.onBrowserUpdateAvailable.addListener(\ncallback: function,\n)\nPlease use runtime.onRestartRequired\n.\nFired when a Chrome update is available, but isn't installed immediately because a browser restart is required.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonConnect\nchrome.runtime.onConnect.addListener(\ncallback: function,\n)\nFired when a connection is made from either an extension process or a content script (by runtime.connect\n).\nonConnectExternal\nchrome.runtime.onConnectExternal.addListener(\ncallback: function,\n)\nFired when a connection is made from another extension (by runtime.connect\n), or from an externally connectable web site.\nonConnectNative\nchrome.runtime.onConnectNative.addListener(\ncallback: function,\n)\nFired when a connection is made from a native application. This event requires the \"nativeMessaging\"\npermission. It is only supported on Chrome OS.\nonInstalled\nchrome.runtime.onInstalled.addListener(\ncallback: function,\n)\nFired when the extension is first installed, when the extension is updated to a new version, and when Chrome is updated to a new version.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nid\nstring optional\nIndicates the ID of the imported shared module extension which updated. This is present only if 'reason' is 'shared_module_update'.\n-\npreviousVersion\nstring optional\nIndicates the previous version of the extension, which has just been updated. This is present only if 'reason' is 'update'.\n-\nreason\nThe reason that this event is being dispatched.\n-\n-\nonMessage\nchrome.runtime.onMessage.addListener(\ncallback: function,\n)\nFired when a message is sent from either an extension process (by runtime.sendMessage\n) or a content script (by tabs.sendMessage\n).\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(message: any, sender: MessageSender, sendResponse: function) => boolean | undefined\n-\nmessage\nany\n-\nsender\n-\nsendResponse\nfunction\nThe\nsendResponse\nparameter looks like:() => void\n-\nreturns\nboolean | undefined\n-\nonMessageExternal\nchrome.runtime.onMessageExternal.addListener(\ncallback: function,\n)\nFired when a message is sent from another extension (by runtime.sendMessage\n). Cannot be used in a content script.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(message: any, sender: MessageSender, sendResponse: function) => boolean | undefined\n-\nmessage\nany\n-\nsender\n-\nsendResponse\nfunction\nThe\nsendResponse\nparameter looks like:() => void\n-\nreturns\nboolean | undefined\n-\nonRestartRequired\nchrome.runtime.onRestartRequired.addListener(\ncallback: function,\n)\nFired when an app or the device that it runs on needs to be restarted. The app should close all its windows at its earliest convenient time to let the restart to happen. If the app does nothing, a restart will be enforced after a 24-hour grace period has passed. Currently, this event is only fired for Chrome OS kiosk apps.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(reason: OnRestartRequiredReason) => void\n-\nreason\n-\nonStartup\nchrome.runtime.onStartup.addListener(\ncallback: function,\n)\nFired when a profile that has this extension installed first starts up. This event is not fired when an incognito profile is started, even if this extension is operating in 'split' incognito mode.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonSuspend\nchrome.runtime.onSuspend.addListener(\ncallback: function,\n)\nSent to the event page just before it is unloaded. This gives the extension opportunity to do some clean up. Note that since the page is unloading, any asynchronous operations started while handling this event are not guaranteed to complete. If more activity for the event page occurs before it gets unloaded the onSuspendCanceled event will be sent and the page won't be unloaded.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonSuspendCanceled\nchrome.runtime.onSuspendCanceled.addListener(\ncallback: function,\n)\nSent after onSuspend to indicate that the app won't be unloaded after all.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonUpdateAvailable\nchrome.runtime.onUpdateAvailable.addListener(\ncallback: function,\n)\nFired when an update is available, but isn't installed immediately because the app is currently running. If you do nothing, the update will be installed the next time the background page gets unloaded, if you want it to be installed sooner you can explicitly call chrome.runtime.reload(). If your extension is using a persistent background page, the background page of course never gets unloaded, so unless you call chrome.runtime.reload() manually in response to this event the update will not get installed until the next time Chrome itself restarts. If no handlers are listening for this event, and your extension has a persistent background page, it behaves as if chrome.runtime.reload() is called in response to this event.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nversion\nstring\nThe version number of the available update.\n-\n-\nonUserScriptConnect\nchrome.runtime.onUserScriptConnect.addListener(\ncallback: function,\n)\nFired when a connection is made from a user script from this extension.\nonUserScriptMessage\nchrome.runtime.onUserScriptMessage.addListener(\ncallback: function,\n)\nFired when a message is sent from a user script associated with the same extension.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(message: any, sender: MessageSender, sendResponse: function) => boolean | undefined\n-\nmessage\nany\n-\nsender\n-\nsendResponse\nfunction\nThe\nsendResponse\nparameter looks like:() => void\n-\nreturns\nboolean | undefined\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/runtime", "title": "chrome.runtime | API | Chrome for Developers", "text": "Description\nUse the chrome.runtime\nAPI to retrieve the service worker, return details about the manifest, and listen for and respond to events in the extension lifecycle. You can also use this API to convert the relative path of URLs to fully-qualified URLs.\nMost members of this API do not require any permissions. This permission is needed for connectNative()\n, sendNativeMessage()\nand onNativeConnect\n.\nThe following example shows how to declare the \"nativeMessaging\"\npermission in the manifest:\nmanifest.json:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"nativeMessaging\"\n],\n...\n}\nConcepts and usage\nThe Runtime API provides methods to support a number of areas that your extensions can use:\n- Message passing\n- Your extension can communicate with different contexts within your extension and also with other extensions using these methods and events:\nconnect()\n,onConnect\n,onConnectExternal\n,sendMessage()\n,onMessage\nandonMessageExternal\n. In addition, your extension can pass messages to native applications on the user's device usingconnectNative()\nandsendNativeMessage()\n.\n- Accessing extension and platform metadata\n- These methods let you retrieve several specific pieces of metadata about the extension and the\nplatform. Methods in this category include\ngetManifest()\n, andgetPlatformInfo()\n. - Managing extension lifecycle and options\n- These properties let you perform some meta-operations on the extension, and display the options page.\nMethods and events in this category include\nonInstalled\n,onStartup\n,openOptionsPage()\n,reload()\n,requestUpdateCheck()\n, andsetUninstallURL()\n. - Helper utilities\n- These methods provide utility such as the conversion of internal resource representations to\nexternal formats. Methods in this category include\ngetURL()\n. - Kiosk mode utilities\n- These methods are available only on ChromeOS, and exist mainly to support kiosk implementations.\nMethods in this category include\nrestart()\nandrestartAfterDelay()\n`.\nUnpacked extension behavior\nWhen an unpacked extension is reloaded, this is treated as an update. This means that the\nchrome.runtime.onInstalled\nevent will fire with the \"update\"\nreason. This\nincludes when the extension is reloaded with chrome.runtime.reload()\n.\nUse cases\nAdd an image to a web page\nFor a web page to access an asset hosted on another domain, it must specify the resource's full URL\n(e.g. <img src=\"https://example.com/logo.png\">\n). The same is true to include an extension asset on\na web page. The two differences are that the extension's assets must be exposed as web\naccessible resources and that typically content scripts are responsible for injecting\nextension assets.\nIn this example, the extension will add logo.png\nto the page that the content\nscript is being injected into by using runtime.getURL()\nto create a\nfully-qualified URL. But first, the asset must be declared as a web accessible resource in the manifest.\nmanifest.json:\n{\n...\n\"web_accessible_resources\": [\n{\n\"resources\": [ \"logo.png\" ],\n\"matches\": [ \"https://*/*\" ]\n}\n],\n...\n}\ncontent.js:\n{ // Block used to avoid setting global variables\nconst img = document.createElement('img');\nimg.src = chrome.runtime.getURL('logo.png');\ndocument.body.append(img);\n}\nSend data from a content script to the service worker\nIts common for an extension's content scripts to need data managed by another part of the extension, like the service worker. Much like two browser windows opened to the same web page, these two contexts cannot directly access each other's values. Instead, the extension can use message passing to coordinate across these different contexts.\nIn this example, the content script needs some data from the extension's service worker to\ninitialize its UI. To get this data, it passes the developer-defined get-user-data\nmessage\nto the service worker, and it responds with a copy of the user's information.\ncontent.js:\n// 1. Send a message to the service worker requesting the user's data\nchrome.runtime.sendMessage('get-user-data', (response) => {\n// 3. Got an asynchronous response with the data from the service worker\nconsole.log('received user data', response);\ninitializeUI(response);\n});\nservice-worker.js:\n// Example of a simple user data object\nconst user = {\nusername: 'demo-user'\n};\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n// 2. A page requested user data, respond with a copy of `user`\nif (message === 'get-user-data') {\nsendResponse(user);\n}\n});\nGather feedback on uninstall\nMany extensions use post-uninstall surveys to understand how the extension could better serve its users and improve retention. The following example shows how to add this functionality.\nbackground.js:\nchrome.runtime.onInstalled.addListener(details => {\nif (details.reason === chrome.runtime.OnInstalledReason.INSTALL) {\nchrome.runtime.setUninstallURL('https://example.com/extension-survey');\n}\n});\nExamples\nSee the Manifest V3 - Web Accessible Resources demo for more Runtime API examples.\nTypes\nContextFilter\nA filter to match against certain extension contexts. Matching contexts must match all specified filters; any filter that is not specified matches all available contexts. Thus, a filter of `{}` will match all available contexts.\nProperties\n-\ncontextIds\nstring[] optional\n-\ncontextTypes\nContextType[] optional\n-\ndocumentIds\nstring[] optional\n-\ndocumentOrigins\nstring[] optional\n-\ndocumentUrls\nstring[] optional\n-\nframeIds\nnumber[] optional\n-\nincognito\nboolean optional\n-\ntabIds\nnumber[] optional\n-\nwindowIds\nnumber[] optional\nContextType\nEnum\n\"TAB\" \"POPUP\" \"BACKGROUND\" \"OFFSCREEN_DOCUMENT\" \"SIDE_PANEL\" \"DEVELOPER_TOOLS\"\nSpecifies the context type as a tab\nSpecifies the context type as an extension popup window\nSpecifies the context type as a service worker.\nSpecifies the context type as an offscreen document.\nSpecifies the context type as a side panel.\nSpecifies the context type as developer tools.\nExtensionContext\nA context hosting extension content.\nProperties\n-\ncontextId\nstring\nA unique identifier for this context\n-\ncontextType\nThe type of context this corresponds to.\n-\ndocumentId\nstring optional\nA UUID for the document associated with this context, or undefined if this context is hosted not in a document.\n-\ndocumentOrigin\nstring optional\nThe origin of the document associated with this context, or undefined if the context is not hosted in a document.\n-\ndocumentUrl\nstring optional\nThe URL of the document associated with this context, or undefined if the context is not hosted in a document.\n-\nframeId\nnumber\nThe ID of the frame for this context, or -1 if this context is not hosted in a frame.\n-\nincognito\nboolean\nWhether the context is associated with an incognito profile.\n-\ntabId\nnumber\nThe ID of the tab for this context, or -1 if this context is not hosted in a tab.\n-\nwindowId\nnumber\nThe ID of the window for this context, or -1 if this context is not hosted in a window.\nMessageSender\nAn object containing information about the script context that sent a message or request.\nProperties\n-\ndocumentId\nstring optional\nChrome 106+A UUID of the document that opened the connection.\n-\ndocumentLifecycle\nstring optional\nChrome 106+The lifecycle the document that opened the connection is in at the time the port was created. Note that the lifecycle state of the document may have changed since port creation.\n-\nframeId\nnumber optional\nThe frame that opened the connection. 0 for top-level frames, positive for child frames. This will only be set when\ntab\nis set. -\nid\nstring optional\nThe ID of the extension that opened the connection, if any.\n-\nnativeApplication\nstring optional\nChrome 74+The name of the native application that opened the connection, if any.\n-\norigin\nstring optional\nChrome 80+The origin of the page or frame that opened the connection. It can vary from the url property (e.g., about:blank) or can be opaque (e.g., sandboxed iframes). This is useful for identifying if the origin can be trusted if we can't immediately tell from the URL.\n-\ntab\nTab optional\nThe\ntabs.Tab\nwhich opened the connection, if any. This property will only be present when the connection was opened from a tab (including content scripts), and only if the receiver is an extension, not an app. -\ntlsChannelId\nstring optional\nThe TLS channel ID of the page or frame that opened the connection, if requested by the extension, and if available.\n-\nurl\nstring optional\nThe URL of the page or frame that opened the connection. If the sender is in an iframe, it will be iframe's URL not the URL of the page which hosts it.\nOnInstalledReason\nThe reason that this event is being dispatched.\nEnum\n\"install\" \"update\" \"chrome_update\" \"shared_module_update\"\nSpecifies the event reason as an installation.\nSpecifies the event reason as an extension update.\nSpecifies the event reason as a Chrome update.\nSpecifies the event reason as an update to a shared module.\nOnRestartRequiredReason\nThe reason that the event is being dispatched. 'app_update' is used when the restart is needed because the application is updated to a newer version. 'os_update' is used when the restart is needed because the browser/OS is updated to a newer version. 'periodic' is used when the system runs for more than the permitted uptime set in the enterprise policy.\nEnum\n\"app_update\" \"os_update\" \"periodic\"\nSpecifies the event reason as an update to the app.\nSpecifies the event reason as an update to the operating system.\nSpecifies the event reason as a periodic restart of the app.\nPlatformArch\nThe machine's processor architecture.\nEnum\n\"arm\" \"arm64\" \"x86-32\" \"x86-64\" \"mips\" \"mips64\"\nSpecifies the processer architecture as arm.\nSpecifies the processer architecture as arm64.\nSpecifies the processer architecture as x86-32.\nSpecifies the processer architecture as x86-64.\nSpecifies the processer architecture as mips.\nSpecifies the processer architecture as mips64.\nPlatformInfo\nAn object containing information about the current platform.\nProperties\n-\narch\nThe machine's processor architecture.\n-\nnacl_arch\nThe native client architecture. This may be different from arch on some platforms.\n-\nos\nThe operating system Chrome is running on.\nPlatformNaclArch\nThe native client architecture. This may be different from arch on some platforms.\nEnum\n\"arm\" \"x86-32\" \"x86-64\" \"mips\" \"mips64\"\nSpecifies the native client architecture as arm.\nSpecifies the native client architecture as x86-32.\nSpecifies the native client architecture as x86-64.\nSpecifies the native client architecture as mips.\nSpecifies the native client architecture as mips64.\nPlatformOs\nThe operating system Chrome is running on.\nEnum\n\"mac\" \"win\" \"android\" \"cros\" \"linux\" \"openbsd\" \"fuchsia\"\nSpecifies the MacOS operating system.\nSpecifies the Windows operating system.\nSpecifies the Android operating system.\nSpecifies the Chrome operating system.\nSpecifies the Linux operating system.\nSpecifies the OpenBSD operating system.\nSpecifies the Fuchsia operating system.\nPort\nAn object which allows two way communication with other pages. See Long-lived connections for more information.\nProperties\n-\nname\nstring\nThe name of the port, as specified in the call to\nruntime.connect\n. -\nonDisconnect\nEvent<functionvoidvoid>\nFired when the port is disconnected from the other end(s).\nruntime.lastError\nmay be set if the port was disconnected by an error. If the port is closed via disconnect, then this event is only fired on the other end. This event is fired at most once (see also Port lifetime).The\nonDisconnect.addListener\nfunction looks like:(callback: function) => {...}\n-\nonMessage\nEvent<functionvoidvoid>\nThis event is fired when postMessage is called by the other end of the port.\nThe\nonMessage.addListener\nfunction looks like:(callback: function) => {...}\n-\nsender\nMessageSender optional\nThis property will only be present on ports passed to onConnect / onConnectExternal / onConnectNative listeners.\n-\ndisconnect\nvoid\nImmediately disconnect the port. Calling\ndisconnect()\non an already-disconnected port has no effect. When a port is disconnected, no new events will be dispatched to this port.The\ndisconnect\nfunction looks like:() => {...}\n-\npostMessage\nvoid\nSend a message to the other end of the port. If the port is disconnected, an error is thrown.\nThe\npostMessage\nfunction looks like:(message: any) => {...}\n-\nmessage\nany\nChrome 52+The message to send. This object should be JSON-ifiable.\n-\nRequestUpdateCheckStatus\nResult of the update check.\nEnum\n\"throttled\" \"no_update\" \"update_available\"\nSpecifies that the status check has been throttled. This can occur after repeated checks within a short amount of time.\nSpecifies that there are no available updates to install.\nSpecifies that there is an available update to install.\nProperties\nid\nThe ID of the extension/app.\nType\nstring\nlastError\nPopulated with an error message if calling an API function fails; otherwise undefined. This is only defined within the scope of that function's callback. If an error is produced, but runtime.lastError\nis not accessed within the callback, a message is logged to the console listing the API function that produced the error. API functions that return promises do not set this property.\nType\nobject\nProperties\n-\nmessage\nstring optional\nDetails about the error which occurred.\nMethods\nconnect()\nchrome.runtime.connect(\nextensionId?: string,\nconnectInfo?: object,\n)\nAttempts to connect listeners within an extension (such as the background page), or other extensions/apps. This is useful for content scripts connecting to their extension processes, inter-app/extension communication, and web messaging. Note that this does not connect to any listeners in a content script. Extensions may connect to content scripts embedded in tabs via tabs.connect\n.\nParameters\n-\nextensionId\nstring optional\nThe ID of the extension to connect to. If omitted, a connection will be attempted with your own extension. Required if sending messages from a web page for web messaging.\n-\nconnectInfo\nobject optional\n-\nincludeTlsChannelId\nboolean optional\nWhether the TLS channel ID will be passed into onConnectExternal for processes that are listening for the connection event.\n-\nname\nstring optional\nWill be passed into onConnect for processes that are listening for the connection event.\n-\nReturns\n-\nPort through which messages can be sent and received. The port's onDisconnect event is fired if the extension does not exist.\nconnectNative()\nchrome.runtime.connectNative(\napplication: string,\n)\nConnects to a native application in the host machine. This method requires the \"nativeMessaging\"\npermission. See Native Messaging for more information.\nParameters\n-\napplication\nstring\nThe name of the registered application to connect to.\nReturns\n-\nPort through which messages can be sent and received with the application\ngetBackgroundPage()\nchrome.runtime.getBackgroundPage(\ncallback?: function,\n)\nBackground pages do not exist in MV3 extensions.\nRetrieves the JavaScript 'window' object for the background page running inside the current extension/app. If the background page is an event page, the system will ensure it is loaded before calling the callback. If there is no background page, an error is set.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(backgroundPage?: Window) => void\n-\nbackgroundPage\nWindow optional\nThe JavaScript 'window' object for the background page.\n-\nReturns\n-\nPromise<Window | undefined>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetContexts()\nchrome.runtime.getContexts(\nfilter: ContextFilter,\ncallback?: function,\n)\nFetches information about active contexts associated with this extension\nParameters\n-\nfilter\nA filter to find matching contexts. A context matches if it matches all specified fields in the filter. Any unspecified field in the filter matches all contexts.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(contexts: ExtensionContext[]) => void\n-\ncontexts\nThe matching contexts, if any.\n-\nReturns\n-\nPromise<ExtensionContext[]>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetManifest()\nchrome.runtime.getManifest()\nReturns details about the app or extension from the manifest. The object returned is a serialization of the full manifest file.\nReturns\n-\nobject\nThe manifest details.\ngetPackageDirectoryEntry()\nchrome.runtime.getPackageDirectoryEntry(\ncallback?: function,\n)\nReturns a DirectoryEntry for the package directory.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(directoryEntry: DirectoryEntry) => void\n-\ndirectoryEntry\nDirectoryEntry\n-\nReturns\n-\nPromise<DirectoryEntry>\nChrome 122+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetPlatformInfo()\nchrome.runtime.getPlatformInfo(\ncallback?: function,\n)\nReturns information about the current platform.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(platformInfo: PlatformInfo) => void\n-\nplatformInfo\n-\nReturns\n-\nPromise<PlatformInfo>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetURL()\nchrome.runtime.getURL(\npath: string,\n)\nConverts a relative path within an app/extension install directory to a fully-qualified URL.\nParameters\n-\npath\nstring\nA path to a resource within an app/extension expressed relative to its install directory.\nReturns\n-\nstring\nThe fully-qualified URL to the resource.\nopenOptionsPage()\nchrome.runtime.openOptionsPage(\ncallback?: function,\n)\nOpen your Extension's options page, if possible.\nThe precise behavior may depend on your manifest's options_ui\nor options_page\nkey, or what Chrome happens to support at the time. For example, the page may be opened in a new tab, within chrome://extensions, within an App, or it may just focus an open options page. It will never cause the caller page to reload.\nIf your Extension does not declare an options page, or Chrome failed to create one for some other reason, the callback will set lastError\n.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nreload()\nchrome.runtime.reload()\nReloads the app or extension. This method is not supported in kiosk mode. For kiosk mode, use chrome.runtime.restart() method.\nrequestUpdateCheck()\nchrome.runtime.requestUpdateCheck(\ncallback?: function,\n)\nRequests an immediate update check be done for this app/extension.\nImportant: Most extensions/apps should not use this method, since Chrome already does automatic checks every few hours, and you can listen for the runtime.onUpdateAvailable\nevent without needing to call requestUpdateCheck.\nThis method is only appropriate to call in very limited circumstances, such as if your extension talks to a backend service, and the backend service has determined that the client extension version is very far out of date and you'd like to prompt a user to update. Most other uses of requestUpdateCheck, such as calling it unconditionally based on a repeating timer, probably only serve to waste client, network, and server resources.\nNote: When called with a callback, instead of returning an object this function will return the two properties as separate arguments passed to the callback.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: object) => void\n-\nresult\nobject\nChrome 109+RequestUpdateCheckResult object that holds the status of the update check and any details of the result if there is an update available\n-\nstatus\nResult of the update check.\n-\nversion\nstring optional\nIf an update is available, this contains the version of the available update.\n-\n-\nReturns\n-\nPromise<object>\nChrome 109+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nrestart()\nchrome.runtime.restart()\nRestart the ChromeOS device when the app runs in kiosk mode. Otherwise, it's no-op.\nrestartAfterDelay()\nchrome.runtime.restartAfterDelay(\nseconds: number,\ncallback?: function,\n)\nRestart the ChromeOS device when the app runs in kiosk mode after the given seconds. If called again before the time ends, the reboot will be delayed. If called with a value of -1, the reboot will be cancelled. It's a no-op in non-kiosk mode. It's only allowed to be called repeatedly by the first extension to invoke this API.\nParameters\n-\nseconds\nnumber\nTime to wait in seconds before rebooting the device, or -1 to cancel a scheduled reboot.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsendMessage()\nchrome.runtime.sendMessage(\nextensionId?: string,\nmessage: any,\noptions?: object,\ncallback?: function,\n)\nSends a single message to event listeners within your extension or a different extension/app. Similar to runtime.connect\nbut only sends a single message, with an optional response. If sending to your extension, the runtime.onMessage\nevent will be fired in every frame of your extension (except for the sender's frame), or runtime.onMessageExternal\n, if a different extension. Note that extensions cannot send messages to content scripts using this method. To send messages to content scripts, use tabs.sendMessage\n.\nParameters\n-\nextensionId\nstring optional\nThe ID of the extension to send the message to. If omitted, the message will be sent to your own extension/app. Required if sending messages from a web page for web messaging.\n-\nmessage\nany\nThe message to send. This message should be a JSON-ifiable object.\n-\noptions\nobject optional\n-\nincludeTlsChannelId\nboolean optional\nWhether the TLS channel ID will be passed into onMessageExternal for processes that are listening for the connection event.\n-\n-\ncallback\nfunction optional\nChrome 99+The\ncallback\nparameter looks like:(response: any) => void\n-\nresponse\nany\nThe JSON response object sent by the handler of the message. If an error occurs while connecting to the extension, the callback will be called with no arguments and\nruntime.lastError\nwill be set to the error message.\n-\nReturns\n-\nPromise<any>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsendNativeMessage()\nchrome.runtime.sendNativeMessage(\napplication: string,\nmessage: object,\ncallback?: function,\n)\nSend a single message to a native application. This method requires the \"nativeMessaging\"\npermission.\nParameters\n-\napplication\nstring\nThe name of the native messaging host.\n-\nmessage\nobject\nThe message that will be passed to the native messaging host.\n-\ncallback\nfunction optional\nChrome 99+The\ncallback\nparameter looks like:(response: any) => void\n-\nresponse\nany\nThe response message sent by the native messaging host. If an error occurs while connecting to the native messaging host, the callback will be called with no arguments and\nruntime.lastError\nwill be set to the error message.\n-\nReturns\n-\nPromise<any>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetUninstallURL()\nchrome.runtime.setUninstallURL(\nurl: string,\ncallback?: function,\n)\nSets the URL to be visited upon uninstallation. This may be used to clean up server-side data, do analytics, and implement surveys. Maximum 1023 characters.\nParameters\n-\nurl\nstring\nURL to be opened after the extension is uninstalled. This URL must have an http: or https: scheme. Set an empty string to not open a new tab upon uninstallation.\n-\ncallback\nfunction optional\nChrome 45+The\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonBrowserUpdateAvailable\nchrome.runtime.onBrowserUpdateAvailable.addListener(\ncallback: function,\n)\nPlease use runtime.onRestartRequired\n.\nFired when a Chrome update is available, but isn't installed immediately because a browser restart is required.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonConnect\nchrome.runtime.onConnect.addListener(\ncallback: function,\n)\nFired when a connection is made from either an extension process or a content script (by runtime.connect\n).\nonConnectExternal\nchrome.runtime.onConnectExternal.addListener(\ncallback: function,\n)\nFired when a connection is made from another extension (by runtime.connect\n), or from an externally connectable web site.\nonConnectNative\nchrome.runtime.onConnectNative.addListener(\ncallback: function,\n)\nFired when a connection is made from a native application. This event requires the \"nativeMessaging\"\npermission. It is only supported on Chrome OS.\nonInstalled\nchrome.runtime.onInstalled.addListener(\ncallback: function,\n)\nFired when the extension is first installed, when the extension is updated to a new version, and when Chrome is updated to a new version.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nid\nstring optional\nIndicates the ID of the imported shared module extension which updated. This is present only if 'reason' is 'shared_module_update'.\n-\npreviousVersion\nstring optional\nIndicates the previous version of the extension, which has just been updated. This is present only if 'reason' is 'update'.\n-\nreason\nThe reason that this event is being dispatched.\n-\n-\nonMessage\nchrome.runtime.onMessage.addListener(\ncallback: function,\n)\nFired when a message is sent from either an extension process (by runtime.sendMessage\n) or a content script (by tabs.sendMessage\n).\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(message: any, sender: MessageSender, sendResponse: function) => boolean | undefined\n-\nmessage\nany\n-\nsender\n-\nsendResponse\nfunction\nThe\nsendResponse\nparameter looks like:() => void\n-\nreturns\nboolean | undefined\n-\nonMessageExternal\nchrome.runtime.onMessageExternal.addListener(\ncallback: function,\n)\nFired when a message is sent from another extension (by runtime.sendMessage\n). Cannot be used in a content script.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(message: any, sender: MessageSender, sendResponse: function) => boolean | undefined\n-\nmessage\nany\n-\nsender\n-\nsendResponse\nfunction\nThe\nsendResponse\nparameter looks like:() => void\n-\nreturns\nboolean | undefined\n-\nonRestartRequired\nchrome.runtime.onRestartRequired.addListener(\ncallback: function,\n)\nFired when an app or the device that it runs on needs to be restarted. The app should close all its windows at its earliest convenient time to let the restart to happen. If the app does nothing, a restart will be enforced after a 24-hour grace period has passed. Currently, this event is only fired for Chrome OS kiosk apps.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(reason: OnRestartRequiredReason) => void\n-\nreason\n-\nonStartup\nchrome.runtime.onStartup.addListener(\ncallback: function,\n)\nFired when a profile that has this extension installed first starts up. This event is not fired when an incognito profile is started, even if this extension is operating in 'split' incognito mode.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonSuspend\nchrome.runtime.onSuspend.addListener(\ncallback: function,\n)\nSent to the event page just before it is unloaded. This gives the extension opportunity to do some clean up. Note that since the page is unloading, any asynchronous operations started while handling this event are not guaranteed to complete. If more activity for the event page occurs before it gets unloaded the onSuspendCanceled event will be sent and the page won't be unloaded.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonSuspendCanceled\nchrome.runtime.onSuspendCanceled.addListener(\ncallback: function,\n)\nSent after onSuspend to indicate that the app won't be unloaded after all.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonUpdateAvailable\nchrome.runtime.onUpdateAvailable.addListener(\ncallback: function,\n)\nFired when an update is available, but isn't installed immediately because the app is currently running. If you do nothing, the update will be installed the next time the background page gets unloaded, if you want it to be installed sooner you can explicitly call chrome.runtime.reload(). If your extension is using a persistent background page, the background page of course never gets unloaded, so unless you call chrome.runtime.reload() manually in response to this event the update will not get installed until the next time Chrome itself restarts. If no handlers are listening for this event, and your extension has a persistent background page, it behaves as if chrome.runtime.reload() is called in response to this event.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nversion\nstring\nThe version number of the available update.\n-\n-\nonUserScriptConnect\nchrome.runtime.onUserScriptConnect.addListener(\ncallback: function,\n)\nFired when a connection is made from a user script from this extension.\nonUserScriptMessage\nchrome.runtime.onUserScriptMessage.addListener(\ncallback: function,\n)\nFired when a message is sent from a user script associated with the same extension.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(message: any, sender: MessageSender, sendResponse: function) => boolean | undefined\n-\nmessage\nany\n-\nsender\n-\nsendResponse\nfunction\nThe\nsendResponse\nparameter looks like:() => void\n-\nreturns\nboolean | undefined\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/scripting", "title": "chrome.scripting | API | Chrome for Developers", "text": "Description\nUse the chrome.scripting\nAPI to execute script in different contexts.\nPermissions\nscripting\nAvailability\nManifest\nTo use the chrome.scripting\nAPI, declare the \"scripting\"\npermission in the manifest plus the host permissions for the pages to inject scripts into. Use the \"host_permissions\"\nkey or the \"activeTab\"\npermission, which grants temporary host permissions. The following example uses the activeTab permission.\n{\n\"name\": \"Scripting Extension\",\n\"manifest_version\": 3,\n\"permissions\": [\"scripting\", \"activeTab\"],\n...\n}\nConcepts and usage\nYou can use the chrome.scripting\nAPI to inject JavaScript and CSS into\nwebsites. This is similar to what you can do with content\nscripts. But by using the chrome.scripting\nnamespace, extensions\ncan make decisions at runtime.\nInjection targets\nYou can use the target\nparameter to specify a target to inject JavaScript or\nCSS into.\nThe only required field is tabId\n. By default, an injection will run in the\nmain frame of the specified tab.\nfunction getTabId() { ... }\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId()},\nfiles : [ \"script.js\" ],\n})\n.then(() => console.log(\"script injected\"));\nTo run in all frames of the specified tab, you can set the allFrames\nboolean\nto true\n.\nfunction getTabId() { ... }\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId(), allFrames : true},\nfiles : [ \"script.js\" ],\n})\n.then(() => console.log(\"script injected in all frames\"));\nYou can also inject into specific frames of a tab by specifying individual frame\nIDs. For more information on frame IDs, see the chrome.webNavigation\nAPI.\nfunction getTabId() { ... }\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId(), frameIds : [ frameId1, frameId2 ]},\nfiles : [ \"script.js\" ],\n})\n.then(() => console.log(\"script injected on target frames\"));\nInjected code\nExtensions can specify the code to be injected either via an external file or a runtime variable.\nFiles\nFiles are specified as strings that are paths relative to the extension's root\ndirectory. The following code will inject the file script.js\ninto the main\nframe of the tab.\nfunction getTabId() { ... }\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId()},\nfiles : [ \"script.js\" ],\n})\n.then(() => console.log(\"injected script file\"));\nRuntime functions\nWhen injecting JavaScript with scripting.executeScript()\n, you can specify a\nfunction to be executed instead of a file. This function should be a function\nvariable available to the current extension context.\nfunction getTabId() { ... }\nfunction getTitle() { return document.title; }\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId()},\nfunc : getTitle,\n})\n.then(() => console.log(\"injected a function\"));\nfunction getTabId() { ... }\nfunction getUserColor() { ... }\nfunction changeBackgroundColor() {\ndocument.body.style.backgroundColor = getUserColor();\n}\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId()},\nfunc : changeBackgroundColor,\n})\n.then(() => console.log(\"injected a function\"));\nYou can work around this by using the args\nproperty:\nfunction getTabId() { ... }\nfunction getUserColor() { ... }\nfunction changeBackgroundColor(backgroundColor) {\ndocument.body.style.backgroundColor = backgroundColor;\n}\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId()},\nfunc : changeBackgroundColor,\nargs : [ getUserColor() ],\n})\n.then(() => console.log(\"injected a function\"));\nRuntime strings\nIf injecting CSS within a page, you can also specify a string to be used in the\ncss\nproperty. This option is only available for scripting.insertCSS()\n; you\ncan't execute a string using scripting.executeScript()\n.\nfunction getTabId() { ... }\nconst css = \"body { background-color: red; }\";\nchrome.scripting\n.insertCSS({\ntarget : {tabId : getTabId()},\ncss : css,\n})\n.then(() => console.log(\"CSS injected\"));\nHandle the results\nThe results of executing JavaScript are passed to the extension. A single result is included per-frame. The main frame is guaranteed to be the first index in the resulting array; all other frames are in a non-deterministic order.\nfunction getTabId() { ... }\nfunction getTitle() { return document.title; }\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId(), allFrames : true},\nfunc : getTitle,\n})\n.then(injectionResults => {\nfor (const {frameId, result} of injectionResults) {\nconsole.log(`Frame ${frameId} result:`, result);\n}\n});\nscripting.insertCSS()\ndoes not return any results.\nPromises\nIf the resulting value of the script execution is a promise, Chrome will wait for the promise to settle and return the resulting value.\nfunction getTabId() { ... }\nasync function addIframe() {\nconst iframe = document.createElement(\"iframe\");\nconst loadComplete =\nnew Promise(resolve => iframe.addEventListener(\"load\", resolve));\niframe.src = \"https://example.com\";\ndocument.body.appendChild(iframe);\nawait loadComplete;\nreturn iframe.contentWindow.document.title;\n}\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId(), allFrames : true},\nfunc : addIframe,\n})\n.then(injectionResults => {\nfor (const frameResult of injectionResults) {\nconst {frameId, result} = frameResult;\nconsole.log(`Frame ${frameId} result:`, result);\n}\n});\nExamples\nUnregister all dynamic content scripts\nThe following snippet contains a function that unregisters all dynamic content scripts the extension has previously registered.\nasync function unregisterAllDynamicContentScripts() {\ntry {\nconst scripts = await chrome.scripting.getRegisteredContentScripts();\nconst scriptIds = scripts.map(script => script.id);\nreturn chrome.scripting.unregisterContentScripts(scriptIds);\n} catch (error) {\nconst message = [\n\"An unexpected error occurred while\",\n\"unregistering dynamic content scripts.\",\n].join(\" \");\nthrow new Error(message, {cause : error});\n}\n}\nTo try the chrome.scripting\nAPI,\ninstall the scripting sample from the Chrome extension samples\nrepository.\nTypes\nContentScriptFilter\nProperties\n-\nids\nstring[] optional\nIf specified,\ngetRegisteredContentScripts\nwill only return scripts with an id specified in this list.\nCSSInjection\nProperties\n-\ncss\nstring optional\nA string containing the CSS to inject. Exactly one of\nfiles\nandcss\nmust be specified. -\nfiles\nstring[] optional\nThe path of the CSS files to inject, relative to the extension's root directory. Exactly one of\nfiles\nandcss\nmust be specified. -\norigin\nStyleOrigin optional\nThe style origin for the injection. Defaults to\n'AUTHOR'\n. -\ntarget\nDetails specifying the target into which to insert the CSS.\nExecutionWorld\nThe JavaScript world for a script to execute within.\nEnum\n\"ISOLATED\" \"MAIN\"\nSpecifies the isolated world, which is the execution environment unique to this extension.\nSpecifies the main world of the DOM, which is the execution environment shared with the host page's JavaScript.\nInjectionResult\nProperties\n-\ndocumentId\nstring\nChrome 106+The document associated with the injection.\n-\nframeId\nnumber\nChrome 90+The frame associated with the injection.\n-\nresult\nany optional\nThe result of the script execution.\nInjectionTarget\nProperties\n-\nallFrames\nboolean optional\nWhether the script should inject into all frames within the tab. Defaults to false. This must not be true if\nframeIds\nis specified. -\ndocumentIds\nstring[] optional\nChrome 106+The IDs of specific documentIds to inject into. This must not be set if\nframeIds\nis set. -\nframeIds\nnumber[] optional\nThe IDs of specific frames to inject into.\n-\ntabId\nnumber\nThe ID of the tab into which to inject.\nRegisteredContentScript\nProperties\n-\nallFrames\nboolean optional\nIf specified true, it will inject into all frames, even if the frame is not the top-most frame in the tab. Each frame is checked independently for URL requirements; it will not inject into child frames if the URL requirements are not met. Defaults to false, meaning that only the top frame is matched.\n-\ncss\nstring[] optional\nThe list of CSS files to be injected into matching pages. These are injected in the order they appear in this array, before any DOM is constructed or displayed for the page.\n-\nexcludeMatches\nstring[] optional\nExcludes pages that this content script would otherwise be injected into. See Match Patterns for more details on the syntax of these strings.\n-\nid\nstring\nThe id of the content script, specified in the API call. Must not start with a '_' as it's reserved as a prefix for generated script IDs.\n-\njs\nstring[] optional\nThe list of JavaScript files to be injected into matching pages. These are injected in the order they appear in this array.\n-\nmatchOriginAsFallback\nboolean optional\nChrome 119+Indicates whether the script can be injected into frames where the URL contains an unsupported scheme; specifically: about:, data:, blob:, or filesystem:. In these cases, the URL's origin is checked to determine if the script should be injected. If the origin is\nnull\n(as is the case for data: URLs) then the used origin is either the frame that created the current frame or the frame that initiated the navigation to this frame. Note that this may not be the parent frame. -\nmatches\nstring[] optional\nSpecifies which pages this content script will be injected into. See Match Patterns for more details on the syntax of these strings. Must be specified for\nregisterContentScripts\n. -\npersistAcrossSessions\nboolean optional\nSpecifies if this content script will persist into future sessions. The default is true.\n-\nrunAt\nRunAt optional\nSpecifies when JavaScript files are injected into the web page. The preferred and default value is\ndocument_idle\n. -\nworld\nExecutionWorld optional\nChrome 102+The JavaScript \"world\" to run the script in. Defaults to\nISOLATED\n.\nScriptInjection\nProperties\n-\nargs\nany[] optional\nChrome 92+The arguments to pass to the provided function. This is only valid if the\nfunc\nparameter is specified. These arguments must be JSON-serializable. -\nfiles\nstring[] optional\nThe path of the JS or CSS files to inject, relative to the extension's root directory. Exactly one of\nfiles\norfunc\nmust be specified. -\ninjectImmediately\nboolean optional\nChrome 102+Whether the injection should be triggered in the target as soon as possible. Note that this is not a guarantee that injection will occur prior to page load, as the page may have already loaded by the time the script reaches the target.\n-\ntarget\nDetails specifying the target into which to inject the script.\n-\nworld\nExecutionWorld optional\nChrome 95+The JavaScript \"world\" to run the script in. Defaults to\nISOLATED\n. -\nfunc\nvoid optional\nChrome 92+A JavaScript function to inject. This function will be serialized, and then deserialized for injection. This means that any bound parameters and execution context will be lost. Exactly one of\nfiles\norfunc\nmust be specified.The\nfunc\nfunction looks like:() => {...}\nStyleOrigin\nThe origin for a style change. See style origins for more info.\nEnum\n\"AUTHOR\" \"USER\"\nMethods\nexecuteScript()\nchrome.scripting.executeScript(\ninjection: ScriptInjection,\ncallback?: function,\n)\nInjects a script into a target context. By default, the script will be run at document_idle\n, or immediately if the page has already loaded. If the injectImmediately\nproperty is set, the script will inject without waiting, even if the page has not finished loading. If the script evaluates to a promise, the browser will wait for the promise to settle and return the resulting value.\nParameters\n-\ninjection\nThe details of the script which to inject.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(results: InjectionResult[]) => void\n-\nresults\n-\nReturns\n-\nPromise<InjectionResult[]>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetRegisteredContentScripts()\nchrome.scripting.getRegisteredContentScripts(\nfilter?: ContentScriptFilter,\ncallback?: function,\n)\nReturns all dynamically registered content scripts for this extension that match the given filter.\nParameters\n-\nfilter\nContentScriptFilter optional\nAn object to filter the extension's dynamically registered scripts.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(scripts: RegisteredContentScript[]) => void\n-\nscripts\n-\nReturns\n-\nPromise<RegisteredContentScript[]>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ninsertCSS()\nchrome.scripting.insertCSS(\ninjection: CSSInjection,\ncallback?: function,\n)\nInserts a CSS stylesheet into a target context. If multiple frames are specified, unsuccessful injections are ignored.\nParameters\n-\ninjection\nThe details of the styles to insert.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nregisterContentScripts()\nchrome.scripting.registerContentScripts(\nscripts: RegisteredContentScript[],\ncallback?: function,\n)\nRegisters one or more content scripts for this extension.\nParameters\n-\nscripts\nContains a list of scripts to be registered. If there are errors during script parsing/file validation, or if the IDs specified already exist, then no scripts are registered.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveCSS()\nchrome.scripting.removeCSS(\ninjection: CSSInjection,\ncallback?: function,\n)\nRemoves a CSS stylesheet that was previously inserted by this extension from a target context.\nParameters\n-\ninjection\nThe details of the styles to remove. Note that the\ncss\n,files\n, andorigin\nproperties must exactly match the stylesheet inserted throughinsertCSS\n. Attempting to remove a non-existent stylesheet is a no-op. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nunregisterContentScripts()\nchrome.scripting.unregisterContentScripts(\nfilter?: ContentScriptFilter,\ncallback?: function,\n)\nUnregisters content scripts for this extension.\nParameters\n-\nfilter\nContentScriptFilter optional\nIf specified, only unregisters dynamic content scripts which match the filter. Otherwise, all of the extension's dynamic content scripts are unregistered.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdateContentScripts()\nchrome.scripting.updateContentScripts(\nscripts: RegisteredContentScript[],\ncallback?: function,\n)\nUpdates one or more content scripts for this extension.\nParameters\n-\nscripts\nContains a list of scripts to be updated. A property is only updated for the existing script if it is specified in this object. If there are errors during script parsing/file validation, or if the IDs specified do not correspond to a fully registered script, then no scripts are updated.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/search", "title": "chrome.search | API | Chrome for Developers", "text": "Description\nUse the chrome.search\nAPI to search via the default provider.\nPermissions\nsearch\nAvailability\nTypes\nDisposition\nEnum\n\"CURRENT_TAB\" \"NEW_TAB\" \"NEW_WINDOW\"\nSpecifies that the search results display in the calling tab or the tab from the active browser.\nSpecifies that the search results display in a new tab.\nSpecifies that the search results display in a new window.\nQueryInfo\nProperties\n-\ndisposition\nDisposition optional\nLocation where search results should be displayed.\nCURRENT_TAB\nis the default. -\ntabId\nnumber optional\nLocation where search results should be displayed.\ntabId\ncannot be used withdisposition\n. -\ntext\nstring\nString to query with the default search provider.\nMethods\nquery()\nchrome.search.query(\nqueryInfo: QueryInfo,\ncallback?: function,\n)\nUsed to query the default search provider. In case of an error, runtime.lastError\nwill be set.\nParameters\n-\nqueryInfo\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/sessions", "title": "chrome.sessions | API | Chrome for Developers", "text": "Description\nUse the chrome.sessions\nAPI to query and restore tabs and windows from a browsing session.\nPermissions\nsessions\nTypes\nDevice\nProperties\n-\ndeviceName\nstring\nThe name of the foreign device.\n-\nsessions\nSession[]\nA list of open window sessions for the foreign device, sorted from most recently to least recently modified session.\nFilter\nProperties\n-\nmaxResults\nnumber optional\nThe maximum number of entries to be fetched in the requested list. Omit this parameter to fetch the maximum number of entries (\nsessions.MAX_SESSION_RESULTS\n).\nSession\nProperties\n-\nlastModified\nnumber\nThe time when the window or tab was closed or modified, represented in milliseconds since the epoch.\n-\ntab\nTab optional\nThe\ntabs.Tab\n, if this entry describes a tab. Either this orsessions.Session.window\nwill be set. -\nwindow\nWindow optional\nThe\nwindows.Window\n, if this entry describes a window. Either this orsessions.Session.tab\nwill be set.\nProperties\nMAX_SESSION_RESULTS\nThe maximum number of sessions.Session\nthat will be included in a requested list.\nValue\n25\nMethods\ngetDevices()\nchrome.sessions.getDevices(\nfilter?: Filter,\ncallback?: function,\n)\nRetrieves all devices with synced sessions.\nParameters\n-\nfilter\nFilter optional\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(devices: Device[]) => void\n-\ndevices\nDevice[]\nThe list of\nsessions.Device\nobjects for each synced session, sorted in order from device with most recently modified session to device with least recently modified session.tabs.Tab\nobjects are sorted by recency in thewindows.Window\nof thesessions.Session\nobjects.\n-\nReturns\n-\nPromise<Device[]>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetRecentlyClosed()\nchrome.sessions.getRecentlyClosed(\nfilter?: Filter,\ncallback?: function,\n)\nGets the list of recently closed tabs and/or windows.\nParameters\n-\nfilter\nFilter optional\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(sessions: Session[]) => void\n-\nsessions\nSession[]\nThe list of closed entries in reverse order that they were closed (the most recently closed tab or window will be at index\n0\n). The entries may contain either tabs or windows.\n-\nReturns\n-\nPromise<Session[]>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nrestore()\nchrome.sessions.restore(\nsessionId?: string,\ncallback?: function,\n)\nReopens a windows.Window\nor tabs.Tab\n, with an optional callback to run when the entry has been restored.\nParameters\n-\nsessionId\nstring optional\nThe\nwindows.Window.sessionId\n, ortabs.Tab.sessionId\nto restore. If this parameter is not specified, the most recently closed session is restored. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(restoredSession: Session) => void\n-\nrestoredSession\nA\nsessions.Session\ncontaining the restoredwindows.Window\nortabs.Tab\nobject.\n-\nReturns\n-\nPromise<Session>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonChanged\nchrome.sessions.onChanged.addListener(\ncallback: function,\n)\nFired when recently closed tabs and/or windows are changed. This event does not monitor synced sessions changes.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/sessions", "title": "chrome.sessions | API | Chrome for Developers", "text": "Description\nUse the chrome.sessions\nAPI to query and restore tabs and windows from a browsing session.\nPermissions\nsessions\nTypes\nDevice\nProperties\n-\ndeviceName\nstring\nThe name of the foreign device.\n-\nsessions\nSession[]\nA list of open window sessions for the foreign device, sorted from most recently to least recently modified session.\nFilter\nProperties\n-\nmaxResults\nnumber optional\nThe maximum number of entries to be fetched in the requested list. Omit this parameter to fetch the maximum number of entries (\nsessions.MAX_SESSION_RESULTS\n).\nSession\nProperties\n-\nlastModified\nnumber\nThe time when the window or tab was closed or modified, represented in milliseconds since the epoch.\n-\ntab\nTab optional\nThe\ntabs.Tab\n, if this entry describes a tab. Either this orsessions.Session.window\nwill be set. -\nwindow\nWindow optional\nThe\nwindows.Window\n, if this entry describes a window. Either this orsessions.Session.tab\nwill be set.\nProperties\nMAX_SESSION_RESULTS\nThe maximum number of sessions.Session\nthat will be included in a requested list.\nValue\n25\nMethods\ngetDevices()\nchrome.sessions.getDevices(\nfilter?: Filter,\ncallback?: function,\n)\nRetrieves all devices with synced sessions.\nParameters\n-\nfilter\nFilter optional\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(devices: Device[]) => void\n-\ndevices\nDevice[]\nThe list of\nsessions.Device\nobjects for each synced session, sorted in order from device with most recently modified session to device with least recently modified session.tabs.Tab\nobjects are sorted by recency in thewindows.Window\nof thesessions.Session\nobjects.\n-\nReturns\n-\nPromise<Device[]>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetRecentlyClosed()\nchrome.sessions.getRecentlyClosed(\nfilter?: Filter,\ncallback?: function,\n)\nGets the list of recently closed tabs and/or windows.\nParameters\n-\nfilter\nFilter optional\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(sessions: Session[]) => void\n-\nsessions\nSession[]\nThe list of closed entries in reverse order that they were closed (the most recently closed tab or window will be at index\n0\n). The entries may contain either tabs or windows.\n-\nReturns\n-\nPromise<Session[]>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nrestore()\nchrome.sessions.restore(\nsessionId?: string,\ncallback?: function,\n)\nReopens a windows.Window\nor tabs.Tab\n, with an optional callback to run when the entry has been restored.\nParameters\n-\nsessionId\nstring optional\nThe\nwindows.Window.sessionId\n, ortabs.Tab.sessionId\nto restore. If this parameter is not specified, the most recently closed session is restored. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(restoredSession: Session) => void\n-\nrestoredSession\nA\nsessions.Session\ncontaining the restoredwindows.Window\nortabs.Tab\nobject.\n-\nReturns\n-\nPromise<Session>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonChanged\nchrome.sessions.onChanged.addListener(\ncallback: function,\n)\nFired when recently closed tabs and/or windows are changed. This event does not monitor synced sessions changes.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/sidePanel", "title": "chrome.sidePanel | API | Chrome for Developers", "text": "Description\nUse the chrome.sidePanel\nAPI to host content in the browser's side panel alongside the main content of a webpage.\nPermissions\nsidePanel\nTo use the Side Panel API, add the \"sidePanel\"\npermission in the extension manifest file:\nmanifest.json:\n{\n\"name\": \"My side panel extension\",\n...\n\"permissions\": [\n\"sidePanel\"\n]\n}\nAvailability\nConcepts and usage\nThe Side Panel API allows extensions to display their own UI in the side panel, enabling persistent experiences that complement the user's browsing journey.\nSome features include:\n- The side panel remains open when navigating between tabs (if set to do so).\n- It can be available only on specific websites.\n- As an extension page, side panels have access to all Chrome APIs.\n- Within Chrome's settings, users can specify which side the panel should be displayed on.\nUse cases\nThe following sections demonstrate some common use cases for the Side Panel API. See Extension samples for complete extension examples.\nDisplay the same side panel on every site\nThe side panel can be set initially from the \"default_path\"\nproperty in the \"side_panel\"\nkey of the manifest to display the same side panel on every site. This should point to a relative path within the extension directory.\nmanifest.json:\n{\n\"name\": \"My side panel extension\",\n...\n\"side_panel\": {\n\"default_path\": \"sidepanel.html\"\n}\n...\n}\nsidepanel.html:\n<!DOCTYPE html>\n<html>\n<head>\n<title>My Sidepanel</title>\n</head>\n<body>\n<h1>All sites sidepanel extension</h1>\n<p>This side panel is enabled on all sites</p>\n</body>\n</html>\nEnable a side panel on a specific site\nAn extension can use sidepanel.setOptions()\nto enable a side panel on a specific tab. This example uses chrome.tabs.onUpdated()\nto listen for any updates made to the tab. It checks if the URL is www.google.com and enables the side panel. Otherwise, it disables it.\nservice-worker.js:\nconst GOOGLE_ORIGIN = 'https://www.google.com';\nchrome.tabs.onUpdated.addListener(async (tabId, info, tab) => {\nif (!tab.url) return;\nconst url = new URL(tab.url);\n// Enables the side panel on google.com\nif (url.origin === GOOGLE_ORIGIN) {\nawait chrome.sidePanel.setOptions({\ntabId,\npath: 'sidepanel.html',\nenabled: true\n});\n} else {\n// Disables the side panel on all other sites\nawait chrome.sidePanel.setOptions({\ntabId,\nenabled: false\n});\n}\n});\nWhen a user temporarily switches to a tab where the side panel is not enabled, the side panel will be hidden. It will automatically show again when the user switches to a tab where it was previously open.\nWhen the user navigates to a site where the side panel is not enabled, the side panel will close, and the extension won't show in the side panel drop-down menu.\nFor a complete example, see the Tab-specific side panel sample.\nOpen the side panel by clicking the toolbar icon\nDevelopers can allow users to open the side panel when they click the action toolbar icon with sidePanel.setPanelBehavior()\n. First, declare the \"action\"\nkey in the manifest:\nmanifest.json:\n{\n\"name\": \"My side panel extension\",\n...\n\"action\": {\n\"default_title\": \"Click to open panel\"\n},\n...\n}\nNow, add this code to the previous example:\nservice-worker.js:\nconst GOOGLE_ORIGIN = 'https://www.google.com';\n// Allows users to open the side panel by clicking on the action toolbar icon\nchrome.sidePanel\n.setPanelBehavior({ openPanelOnActionClick: true })\n.catch((error) => console.error(error));\n...\nProgrammatically open the side panel on user interaction\nChrome 116 introduces sidePanel.open()\n. It allows extensions to open the side panel through an extension user gesture, such as clicking on the action icon. Or a user interaction on an extension page or content script, such as clicking a button. For a complete demo, see the Open Side Panel sample extension.\nThe following code shows how to open a global side panel on the current window when the user clicks on a context menu. When using sidePanel.open()\n, you must choose the context in which it should open. Use windowId\nto open a global side panel. Alternatively, set the tabId\nto open the side panel only on a specific tab.\nservice-worker.js:\nchrome.runtime.onInstalled.addListener(() => {\nchrome.contextMenus.create({\nid: 'openSidePanel',\ntitle: 'Open side panel',\ncontexts: ['all']\n});\n});\nchrome.contextMenus.onClicked.addListener((info, tab) => {\nif (info.menuItemId === 'openSidePanel') {\n// This will open the panel in all the pages on the current window.\nchrome.sidePanel.open({ windowId: tab.windowId });\n}\n});\nSwitch to a different panel\nExtensions can use sidepanel.getOptions()\nto retrieve the current side panel. The following example sets a welcome side panel on runtime.onInstalled()\n. Then when the user navigates to a different tab, it replaces it with the main side panel.\nservice-worker.js:\nconst welcomePage = 'sidepanels/welcome-sp.html';\nconst mainPage = 'sidepanels/main-sp.html';\nchrome.runtime.onInstalled.addListener(() => {\nchrome.sidePanel.setOptions({ path: welcomePage });\nchrome.sidePanel.setPanelBehavior({ openPanelOnActionClick: true });\n});\nchrome.tabs.onActivated.addListener(async ({ tabId }) => {\nconst { path } = await chrome.sidePanel.getOptions({ tabId });\nif (path === welcomePage) {\nchrome.sidePanel.setOptions({ path: mainPage });\n}\n});\nSee the Multiple side panels sample for the full code.\nSide panel user experience\nUsers will see Chrome's built-in side panels first. Each side panel displays the extension's icon in the side panel menu. If no icons are included, it will show a placeholder icon with the first letter of the extension's name.\nOpen the side panel\nTo allow users to open the side panel, use an action icon in combination\nwith sidePanel.setPanelBehavior()\n. Alternatively, make a call to sidePanel.open()\nfollowing a user interaction, such as:\n- An action click\n- A keyboard shortcut\n- A context menu\n- A user gesture on an extension page or content script.\nPin the side panel\nThe side panel toolbar displays a pin icon when your side panel is open. Clicking the icon pins your extension's action icon. Clicking the action icon once pinned will perform the default action for your action icon and will only open the side panel if this has been explicitly configured.\nExamples\nFor more Side Panel API extensions demos, explore any of the following extensions:\n- Dictionary side panel.\n- Global side panel.\n- Multiple side panels.\n- Open Side panel.\n- Site-specific side panel.\nTypes\nGetPanelOptions\nProperties\n-\ntabId\nnumber optional\nIf specified, the side panel options for the given tab will be returned. Otherwise, returns the default side panel options (used for any tab that doesn't have specific settings).\nOpenOptions\nProperties\n-\ntabId\nnumber optional\nThe tab in which to open the side panel. If the corresponding tab has a tab-specific side panel, the panel will only be open for that tab. If there is not a tab-specific panel, the global panel will be open in the specified tab and any other tabs without a currently-open tab- specific panel. This will override any currently-active side panel (global or tab-specific) in the corresponding tab. At least one of this or\nwindowId\nmust be provided. -\nwindowId\nnumber optional\nThe window in which to open the side panel. This is only applicable if the extension has a global (non-tab-specific) side panel or\ntabId\nis also specified. This will override any currently-active global side panel the user has open in the given window. At least one of this ortabId\nmust be provided.\nPanelBehavior\nProperties\n-\nopenPanelOnActionClick\nboolean optional\nWhether clicking the extension's icon will toggle showing the extension's entry in the side panel. Defaults to false.\nPanelOptions\nProperties\n-\nenabled\nboolean optional\nWhether the side panel should be enabled. This is optional. The default value is true.\n-\npath\nstring optional\nThe path to the side panel HTML file to use. This must be a local resource within the extension package.\n-\ntabId\nnumber optional\nIf specified, the side panel options will only apply to the tab with this id. If omitted, these options set the default behavior (used for any tab that doesn't have specific settings). Note: if the same path is set for this tabId and the default tabId, then the panel for this tabId will be a different instance than the panel for the default tabId.\nSidePanel\nProperties\n-\ndefault_path\nstring\nDeveloper specified path for side panel display.\nMethods\ngetOptions()\nchrome.sidePanel.getOptions(\noptions: GetPanelOptions,\ncallback?: function,\n)\nReturns the active panel configuration.\nParameters\n-\noptions\nSpecifies the context to return the configuration for.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(options: PanelOptions) => void\n-\noptions\n-\nReturns\n-\nPromise<PanelOptions>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetPanelBehavior()\nchrome.sidePanel.getPanelBehavior(\ncallback?: function,\n)\nReturns the extension's current side panel behavior.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(behavior: PanelBehavior) => void\n-\nbehavior\n-\nReturns\n-\nPromise<PanelBehavior>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nopen()\nchrome.sidePanel.open(\noptions: OpenOptions,\ncallback?: function,\n)\nOpens the side panel for the extension. This may only be called in response to a user action.\nParameters\n-\noptions\nSpecifies the context in which to open the side panel.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetOptions()\nchrome.sidePanel.setOptions(\noptions: PanelOptions,\ncallback?: function,\n)\nConfigures the side panel.\nParameters\n-\noptions\nThe configuration options to apply to the panel.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetPanelBehavior()\nchrome.sidePanel.setPanelBehavior(\nbehavior: PanelBehavior,\ncallback?: function,\n)\nConfigures the extension's side panel behavior. This is an upsert operation.\nParameters\n-\nbehavior\nThe new behavior to be set.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/storage", "title": "chrome.storage | API | Chrome for Developers", "text": "Description\nUse the chrome.storage\nAPI to store, retrieve, and track changes to user data.\nPermissions\nstorage\nTo use the storage API, declare the \"storage\"\npermission in the extension\nmanifest. For example:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"storage\"\n],\n...\n}\nConcepts and usage\nThe Storage API provides an extension-specific way to persist user data and state. It's similar to the web platform's storage APIs (IndexedDB, and Storage), but was designed to meet the storage needs of extensions. The following are a few key features:\n- All extension contexts, including the extension service worker and content scripts have access to the Storage API.\n- The JSON serializable values are stored as object properties.\n- The Storage API is asynchronous with bulk read and write operations.\n- Even if the user clears the cache and browsing history, the data persists.\n- Stored settings persist even when using split incognito.\n- Includes an exclusive read-only managed storage area for enterprise policies.\nCan extensions use web storage APIs?\nWhile extensions can use the Storage\ninterface (accessible from window.localStorage\n) in some contexts (popup and other HTML pages), we don't recommend it for the following reasons:\n- Extension service workers can't use the Web Storage API.\n- Content scripts share storage with the host page.\n- Data saved using the Web Storage API is lost when the user clears their browsing history.\nTo move data from web storage APIs to extension storage APIs from a service worker:\n- Prepare an offscreen document html page and script file. The script file should contain a conversion routine and an\nonMessage\nhandler. - In the extension service worker, check\nchrome.storage\nfor your data. - If your data isn't found, call\ncreateDocument()\n. - After the returned Promise resolves, call\nsendMessage()\nto start the conversion routine. - Inside the offscreen document's\nonMessage\nhandler, call the conversion routine.\nThere are also some nuances to how web storage APIs work in extensions. Learn more in the Storage and Cookies article.\nStorage areas\nThe Storage API is divided into the following storage areas:\nstorage.local\n- Data is stored locally and cleared when the extension is removed. The storage limit is 10 MB (5 MB in Chrome 113 and earlier), but can be increased by requesting the\n\"unlimitedStorage\"\npermission. We recommend usingstorage.local\nto store larger amounts of data. storage.managed\n- Managed storage is read-only storage for policy installed extensions and managed by system administrators using a developer-defined schema and enterprise policies. Policies are analogous to options but are configured by a system administrator instead of the user, allowing the extension to be preconfigured for all users of an organization. For information on policies, see Documentation for Administrators. To learn more about the\nmanaged\nstorage area, see Manifest for storage areas. storage.session\n- Holds data in memory for the duration of a browser session. By default, it's not exposed to content scripts, but this behavior can be changed by setting\nchrome.storage.session.setAccessLevel()\n. The storage limit is 10 MB (1 MB in Chrome 111 and earlier). Thestorage.session\ninterface is one of several we recommend for service workers. storage.sync\n- If syncing is enabled, the data is synced to any Chrome browser that the user is logged into. If disabled, it behaves like\nstorage.local\n. Chrome stores the data locally when the browser is offline and resumes syncing when it's back online. The quota limitation is approximately 100 KB, 8 KB per item. We recommend usingstorage.sync\nto preserve user settings across synced browsers. If you're working with sensitive user data, instead usestorage.session\n.\nStorage and throttling limits\nThe Storage API has the following usage limitations:\n- Storing data often comes with performance costs, and the API includes storage quotas. We recommend being careful about what data you store so that you don't lose the ability to store data.\n- Storage can take time to complete. Make sure to structure your code to account for that time.\nFor details on storage area limitations and what happens when they're exceeded, see the quota information for sync\n, local\n, and session\n.\nUse cases\nThe following sections demonstrate common use cases for the Storage API.\nSynchronous response to storage updates\nTo track changes made to storage, add a listener to its onChanged\nevent. When anything changes in storage, that event fires. The sample code listens for these changes:\nbackground.js:\nchrome.storage.onChanged.addListener((changes, namespace) => {\nfor (let [key, { oldValue, newValue }] of Object.entries(changes)) {\nconsole.log(\n`Storage key \"${key}\" in namespace \"${namespace}\" changed.`,\n`Old value was \"${oldValue}\", new value is \"${newValue}\".`\n);\n}\n});\nWe can take this idea even further. In this example, we have an options page that\nallows the user to toggle a \"debug mode\" (implementation not shown here). The options page immediately saves the new settings to storage.sync\n, and the service worker uses storage.onChanged\nto apply the setting as soon as possible.\noptions.html:\n<!-- type=\"module\" allows you to use top level await -->\n<script defer src=\"options.js\" type=\"module\"></script>\n<form id=\"optionsForm\">\n<label for=\"debug\">\n<input type=\"checkbox\" name=\"debug\" id=\"debug\">\nEnable debug mode\n</label>\n</form>\noptions.js:\n// In-page cache of the user's options\nconst options = {};\nconst optionsForm = document.getElementById(\"optionsForm\");\n// Immediately persist options changes\noptionsForm.debug.addEventListener(\"change\", (event) => {\noptions.debug = event.target.checked;\nchrome.storage.sync.set({ options });\n});\n// Initialize the form with the user's option settings\nconst data = await chrome.storage.sync.get(\"options\");\nObject.assign(options, data.options);\noptionsForm.debug.checked = Boolean(options.debug);\nbackground.js:\nfunction setDebugMode() { /* ... */ }\n// Watch for changes to the user's options & apply them\nchrome.storage.onChanged.addListener((changes, area) => {\nif (area === 'sync' && changes.options?.newValue) {\nconst debugMode = Boolean(changes.options.newValue.debug);\nconsole.log('enable debug mode?', debugMode);\nsetDebugMode(debugMode);\n}\n});\nAsynchronous preload from storage\nBecause service workers don't run all the time, Manifest V3 extensions sometimes need to\nasynchronously load data from storage before they execute their event handlers. To do this, the\nfollowing snippet uses an async action.onClicked\nevent handler that waits for the storageCache\nglobal to be populated before executing its logic.\nbackground.js:\n// Where we will expose all the data we retrieve from storage.sync.\nconst storageCache = { count: 0 };\n// Asynchronously retrieve data from storage.sync, then cache it.\nconst initStorageCache = chrome.storage.sync.get().then((items) => {\n// Copy the data retrieved from storage into storageCache.\nObject.assign(storageCache, items);\n});\nchrome.action.onClicked.addListener(async (tab) => {\ntry {\nawait initStorageCache;\n} catch (e) {\n// Handle error that occurred during storage initialization.\n}\n// Normal action handler logic.\nstorageCache.count++;\nstorageCache.lastTabId = tab.id;\nchrome.storage.sync.set(storageCache);\n});\nExamples\nThe following samples demonstrate the local\n, sync\n, and\nsession\nstorage areas:\nLocal\nchrome.storage.local.set({ key: value }).then(() => {\nconsole.log(\"Value is set\");\n});\nchrome.storage.local.get([\"key\"]).then((result) => {\nconsole.log(\"Value is \" + result.key);\n});\nSync\nchrome.storage.sync.set({ key: value }).then(() => {\nconsole.log(\"Value is set\");\n});\nchrome.storage.sync.get([\"key\"]).then((result) => {\nconsole.log(\"Value is \" + result.key);\n});\nSession\nchrome.storage.session.set({ key: value }).then(() => {\nconsole.log(\"Value was set\");\n});\nchrome.storage.session.get([\"key\"]).then((result) => {\nconsole.log(\"Value is \" + result.key);\n});\nTo see other demos of the Storage API, explore any of the following samples:\nTypes\nAccessLevel\nThe storage area's access level.\nEnum\n\"TRUSTED_CONTEXTS\" \"TRUSTED_AND_UNTRUSTED_CONTEXTS\"\nSpecifies contexts originating from the extension itself.\nSpecifies contexts originating from outside the extension.\nStorageArea\nProperties\n-\nonChanged\nEvent<functionvoidvoid>\nChrome 73+Fired when one or more items change.\nThe\nonChanged.addListener\nfunction looks like:(callback: function) => {...}\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(changes: object) => void\n-\nchanges\nobject\n-\n-\n-\nclear\nvoid\nPromiseRemoves all items from storage.\nThe\nclear\nfunction looks like:(callback?: function) => {...}\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\n-\nreturns\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\nget\nvoid\nPromiseGets one or more items from storage.\nThe\nget\nfunction looks like:(keys?: string | string[] | object, callback?: function) => {...}\n-\nkeys\nstring | string[] | object optional\nA single key to get, list of keys to get, or a dictionary specifying default values (see description of the object). An empty list or object will return an empty result object. Pass in\nnull\nto get the entire contents of storage. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(items: object) => void\n-\nitems\nobject\nObject with items in their key-value mappings.\n-\n-\nreturns\nPromise<object>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\ngetBytesInUse\nvoid\nPromiseGets the amount of space (in bytes) being used by one or more items.\nThe\ngetBytesInUse\nfunction looks like:(keys?: string | string[], callback?: function) => {...}\n-\nkeys\nstring | string[] optional\nA single key or list of keys to get the total usage for. An empty list will return 0. Pass in\nnull\nto get the total usage of all of storage. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(bytesInUse: number) => void\n-\nbytesInUse\nnumber\nAmount of space being used in storage, in bytes.\n-\n-\nreturns\nPromise<number>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\ngetKeys\nvoid\nPromise Chrome 130+Gets all keys from storage.\nThe\ngetKeys\nfunction looks like:(callback?: function) => {...}\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(keys: string[]) => void\n-\nkeys\nstring[]\nArray with keys read from storage.\n-\n-\nreturns\nPromise<string[]>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\nremove\nvoid\nPromiseRemoves one or more items from storage.\nThe\nremove\nfunction looks like:(keys: string | string[], callback?: function) => {...}\n-\nkeys\nstring | string[]\nA single key or a list of keys for items to remove.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\n-\nreturns\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\nset\nvoid\nPromiseSets multiple items.\nThe\nset\nfunction looks like:(items: object, callback?: function) => {...}\n-\nitems\nobject\nAn object which gives each key/value pair to update storage with. Any other key/value pairs in storage will not be affected.\nPrimitive values such as numbers will serialize as expected. Values with a\ntypeof\n\"object\"\nand\"function\"\nwill typically serialize to{}\n, with the exception ofArray\n(serializes as expected),Date\n, andRegex\n(serialize using theirString\nrepresentation). -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\n-\nreturns\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\nsetAccessLevel\nvoid\nPromise Chrome 102+Sets the desired access level for the storage area. The default will be only trusted contexts.\nThe\nsetAccessLevel\nfunction looks like:(accessOptions: object, callback?: function) => {...}\n-\naccessOptions\nobject\n-\naccessLevel\nThe access level of the storage area.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\n-\nreturns\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\nStorageChange\nProperties\n-\nnewValue\nany optional\nThe new value of the item, if there is a new value.\n-\noldValue\nany optional\nThe old value of the item, if there was an old value.\nProperties\nlocal\nItems in the local\nstorage area are local to each machine.\nType\nStorageArea & object\nProperties\n-\nQUOTA_BYTES\n10485760\nThe maximum amount (in bytes) of data that can be stored in local storage, as measured by the JSON stringification of every value plus every key's length. This value will be ignored if the extension has the\nunlimitedStorage\npermission. Updates that would cause this limit to be exceeded fail immediately and setruntime.lastError\nwhen using a callback, or a rejected Promise if using async/await.\nmanaged\nItems in the managed\nstorage area are set by an enterprise policy configured by the domain administrator, and are read-only for the extension; trying to modify this namespace results in an error. For information on configuring a policy, see Manifest for storage areas.\nType\nsession\nItems in the session\nstorage area are stored in-memory and will not be persisted to disk.\nType\nStorageArea & object\nProperties\n-\nQUOTA_BYTES\n10485760\nThe maximum amount (in bytes) of data that can be stored in memory, as measured by estimating the dynamically allocated memory usage of every value and key. Updates that would cause this limit to be exceeded fail immediately and set\nruntime.lastError\nwhen using a callback, or when a Promise is rejected.\nsync\nItems in the sync\nstorage area are synced using Chrome Sync.\nType\nStorageArea & object\nProperties\n-\nMAX_ITEMS\n512\nThe maximum number of items that can be stored in sync storage. Updates that would cause this limit to be exceeded will fail immediately and set\nruntime.lastError\nwhen using a callback, or when a Promise is rejected. -\nMAX_SUSTAINED_WRITE_OPERATIONS_PER_MINUTE\n1000000\nDeprecatedThe storage.sync API no longer has a sustained write operation quota.\n-\nMAX_WRITE_OPERATIONS_PER_HOUR\n1800\nThe maximum number of\nset\n,remove\n, orclear\noperations that can be performed each hour. This is 1 every 2 seconds, a lower ceiling than the short term higher writes-per-minute limit.Updates that would cause this limit to be exceeded fail immediately and set\nruntime.lastError\nwhen using a callback, or when a Promise is rejected. -\nMAX_WRITE_OPERATIONS_PER_MINUTE\n120\nThe maximum number of\nset\n,remove\n, orclear\noperations that can be performed each minute. This is 2 per second, providing higher throughput than writes-per-hour over a shorter period of time.Updates that would cause this limit to be exceeded fail immediately and set\nruntime.lastError\nwhen using a callback, or when a Promise is rejected. -\nQUOTA_BYTES\n102400\nThe maximum total amount (in bytes) of data that can be stored in sync storage, as measured by the JSON stringification of every value plus every key's length. Updates that would cause this limit to be exceeded fail immediately and set\nruntime.lastError\nwhen using a callback, or when a Promise is rejected. -\nQUOTA_BYTES_PER_ITEM\n8192\nThe maximum size (in bytes) of each individual item in sync storage, as measured by the JSON stringification of its value plus its key length. Updates containing items larger than this limit will fail immediately and set\nruntime.lastError\nwhen using a callback, or when a Promise is rejected.\nEvents\nonChanged\nchrome.storage.onChanged.addListener(\ncallback: function,\n)\nFired when one or more items change.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(changes: object, areaName: string) => void\n-\nchanges\nobject\n-\nareaName\nstring\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/system/cpu", "title": "chrome.system.cpu | API | Chrome for Developers", "text": "Description\nUse the system.cpu\nAPI to query CPU metadata.\nPermissions\nsystem.cpu\nTypes\nCpuInfo\nProperties\n-\narchName\nstring\nThe architecture name of the processors.\n-\nfeatures\nstring[]\nA set of feature codes indicating some of the processor's capabilities. The currently supported codes are \"mmx\", \"sse\", \"sse2\", \"sse3\", \"ssse3\", \"sse4_1\", \"sse4_2\", and \"avx\".\n-\nmodelName\nstring\nThe model name of the processors.\n-\nnumOfProcessors\nnumber\nThe number of logical processors.\n-\nprocessors\nInformation about each logical processor.\n-\ntemperatures\nnumber[]\nChrome 60+List of CPU temperature readings from each thermal zone of the CPU. Temperatures are in degrees Celsius.\nCurrently supported on Chrome OS only.\nCpuTime\nProperties\n-\nidle\nnumber\nThe cumulative time spent idle by this processor.\n-\nkernel\nnumber\nThe cumulative time used by kernel programs on this processor.\n-\ntotal\nnumber\nThe total cumulative time for this processor. This value is equal to user + kernel + idle.\n-\nuser\nnumber\nThe cumulative time used by userspace programs on this processor.\nProcessorInfo\nProperties\n-\nusage\nCumulative usage info for this logical processor.\nMethods\ngetInfo()\nchrome.system.cpu.getInfo(\ncallback?: function,\n)\nQueries basic CPU information of the system.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(info: CpuInfo) => void\n-\ninfo\n-\nReturns\n-\nPromise<CpuInfo>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/system/display", "title": "chrome.system.display | API | Chrome for Developers", "text": "Description\nUse the system.display\nAPI to query display metadata.\nPermissions\nsystem.display\nTypes\nActiveState\nAn enum to tell if the display is detected and used by the system. The display is considered 'inactive', if it is not detected by the system (maybe disconnected, or considered disconnected due to sleep mode, etc). This state is used to keep existing display when the all displays are disconnected, for example.\nEnum\n\"active\" \"inactive\"\nBounds\nProperties\n-\nheight\nnumber\nThe height of the display in pixels.\n-\nleft\nnumber\nThe x-coordinate of the upper-left corner.\n-\ntop\nnumber\nThe y-coordinate of the upper-left corner.\n-\nwidth\nnumber\nThe width of the display in pixels.\nDisplayLayout\nProperties\n-\nid\nstring\nThe unique identifier of the display.\n-\noffset\nnumber\nThe offset of the display along the connected edge. 0 indicates that the topmost or leftmost corners are aligned.\n-\nparentId\nstring\nThe unique identifier of the parent display. Empty if this is the root.\n-\nposition\nThe layout position of this display relative to the parent. This will be ignored for the root.\nDisplayMode\nProperties\n-\ndeviceScaleFactor\nnumber\nThe display mode device scale factor.\n-\nheight\nnumber\nThe display mode height in device independent (user visible) pixels.\n-\nheightInNativePixels\nnumber\nThe display mode height in native pixels.\n-\nisInterlaced\nboolean optional\nChrome 74+True if this mode is interlaced, false if not provided.\n-\nisNative\nboolean\nTrue if the mode is the display's native mode.\n-\nisSelected\nboolean\nTrue if the display mode is currently selected.\n-\nrefreshRate\nnumber\nChrome 67+The display mode refresh rate in hertz.\n-\nuiScale\nnumber optional\nDeprecated since Chrome 70Use\ndisplayZoomFactor\nThe display mode UI scale factor.\n-\nwidth\nnumber\nThe display mode width in device independent (user visible) pixels.\n-\nwidthInNativePixels\nnumber\nThe display mode width in native pixels.\nDisplayProperties\nProperties\n-\nboundsOriginX\nnumber optional\nIf set, updates the display's logical bounds origin along the x-axis. Applied together with\nboundsOriginY\n. Defaults to the current value if not set andboundsOriginY\nis set. Note that when updating the display origin, some constraints will be applied, so the final bounds origin may be different than the one set. The final bounds can be retrieved usinggetInfo\n. The bounds origin cannot be changed on the primary display. -\nboundsOriginY\nnumber optional\nIf set, updates the display's logical bounds origin along the y-axis. See documentation for\nboundsOriginX\nparameter. -\ndisplayMode\nDisplayMode optional\nChrome 52+If set, updates the display mode to the mode matching this value. If other parameters are invalid, this will not be applied. If the display mode is invalid, it will not be applied and an error will be set, but other properties will still be applied.\n-\ndisplayZoomFactor\nnumber optional\nChrome 65+If set, updates the zoom associated with the display. This zoom performs re-layout and repaint thus resulting in a better quality zoom than just performing a pixel by pixel stretch enlargement.\n-\nisPrimary\nboolean optional\nIf set to true, makes the display primary. No-op if set to false. Note: If set, the display is considered primary for all other properties (i.e.\nisUnified\nmay be set and bounds origin may not). -\nisUnified\nboolean optional\nChrome 59+ChromeOS only. If set to true, changes the display mode to unified desktop (see\nenableUnifiedDesktop\nfor details). If set to false, unified desktop mode will be disabled. This is only valid for the primary display. If provided, mirroringSourceId must not be provided and other properties will be ignored. This is has no effect if not provided. -\nmirroringSourceId\nstring optional\nDeprecated since Chrome 68Use\nsetMirrorMode\n.ChromeOS only. If set and not empty, enables mirroring for this display only. Otherwise disables mirroring for all displays. This value should indicate the id of the source display to mirror, which must not be the same as the id passed to setDisplayProperties. If set, no other property may be set.\n-\noverscan\nInsets optional\nIf set, sets the display's overscan insets to the provided values. Note that overscan values may not be negative or larger than a half of the screen's size. Overscan cannot be changed on the internal monitor.\n-\nrotation\nnumber optional\nIf set, updates the display's rotation. Legal values are [0, 90, 180, 270]. The rotation is set clockwise, relative to the display's vertical position.\nDisplayUnitInfo\nProperties\n-\nactiveStateChrome 117+\nActive if the display is detected and used by the system.\n-\navailableDisplayZoomFactors\nnumber[]\nChrome 67+A list of zoom factor values that can be set for the display.\n-\nbounds\nThe display's logical bounds.\n-\ndisplayZoomFactor\nnumber\nChrome 65+The ratio between the display's current and default zoom. For example, value 1 is equivalent to 100% zoom, and value 1.5 is equivalent to 150% zoom.\n-\ndpiX\nnumber\nThe number of pixels per inch along the x-axis.\n-\ndpiY\nnumber\nThe number of pixels per inch along the y-axis.\n-\nedid\nEdid optional\nChrome 67+NOTE: This is only available to ChromeOS Kiosk apps and Web UI.\n-\nhasTouchSupport\nboolean\nChrome 57+True if this display has a touch input device associated with it.\n-\nid\nstring\nThe unique identifier of the display.\n-\nisEnabled\nboolean\nTrue if this display is enabled.\n-\nisPrimary\nboolean\nTrue if this is the primary display.\n-\nisUnified\nboolean\nChrome 59+True for all displays when in unified desktop mode. See documentation for\nenableUnifiedDesktop\n. -\nmirroringDestinationIds\nstring[]\nChrome 64+ChromeOS only. Identifiers of the displays to which the source display is being mirrored. Empty if no displays are being mirrored. This will be set to the same value for all displays. This must not include\nmirroringSourceId\n. -\nmirroringSourceId\nstring\nChromeOS only. Identifier of the display that is being mirrored if mirroring is enabled, otherwise empty. This will be set for all displays (including the display being mirrored).\n-\nmodesChrome 52+\nThe list of available display modes. The current mode will have isSelected=true. Only available on ChromeOS. Will be set to an empty array on other platforms.\n-\nname\nstring\nThe user-friendly name (e.g. \"HP LCD monitor\").\n-\noverscan\nThe display's insets within its screen's bounds. Currently exposed only on ChromeOS. Will be set to empty insets on other platforms.\n-\nrotation\nnumber\nThe display's clockwise rotation in degrees relative to the vertical position. Currently exposed only on ChromeOS. Will be set to 0 on other platforms. A value of -1 will be interpreted as auto-rotate when the device is in a physical tablet state.\n-\nworkArea\nThe usable work area of the display within the display bounds. The work area excludes areas of the display reserved for OS, for example taskbar and launcher.\nEdid\nProperties\n-\nmanufacturerId\nstring\n3 character manufacturer code. See Sec. 3.4.1 page 21. Required in v1.4.\n-\nproductId\nstring\n2 byte manufacturer-assigned code, Sec. 3.4.2 page 21. Required in v1.4.\n-\nyearOfManufacture\nnumber\nYear of manufacturer, Sec. 3.4.4 page 22. Required in v1.4.\nGetInfoFlags\nProperties\n-\nsingleUnified\nboolean optional\nIf set to true, only a single\nDisplayUnitInfo\nwill be returned bygetInfo\nwhen in unified desktop mode (seeenableUnifiedDesktop\n). Defaults to false.\nInsets\nProperties\n-\nbottom\nnumber\nThe y-axis distance from the bottom bound.\n-\nleft\nnumber\nThe x-axis distance from the left bound.\n-\nright\nnumber\nThe x-axis distance from the right bound.\n-\ntop\nnumber\nThe y-axis distance from the top bound.\nLayoutPosition\nLayout position, i.e. edge of parent that the display is attached to.\nEnum\n\"top\" \"right\" \"bottom\" \"left\"\nMirrorMode\nMirror mode, i.e. different ways of how a display is mirrored to other displays.\nEnum\n\"off\" \"normal\" \"mixed\"\nSpecifies the default mode (extended or unified desktop).\nSpecifies that the default source display will be mirrored to all other displays.\nSpecifies that the specified source display will be mirrored to the provided destination displays. All other connected displays will be extended.\nMirrorModeInfo\nProperties\n-\nmirroringDestinationIds\nstring[] optional\nThe ids of the mirroring destination displays. This is only valid for 'mixed'.\n-\nmirroringSourceId\nstring optional\nThe id of the mirroring source display. This is only valid for 'mixed'.\n-\nmode\nThe mirror mode that should be set.\nPoint\nProperties\n-\nx\nnumber\nThe x-coordinate of the point.\n-\ny\nnumber\nThe y-coordinate of the point.\nTouchCalibrationPair\nProperties\n-\ndisplayPoint\nThe coordinates of the display point.\n-\ntouchPoint\nThe coordinates of the touch point corresponding to the display point.\nTouchCalibrationPairQuad\nProperties\n-\npair1\nFirst pair of touch and display point required for touch calibration.\n-\npair2\nSecond pair of touch and display point required for touch calibration.\n-\npair3\nThird pair of touch and display point required for touch calibration.\n-\npair4\nFourth pair of touch and display point required for touch calibration.\nMethods\nclearTouchCalibration()\nchrome.system.display.clearTouchCalibration(\nid: string,\n)\nResets the touch calibration for the display and brings it back to its default state by clearing any touch calibration data associated with the display.\nParameters\n-\nid\nstring\nThe display's unique identifier.\ncompleteCustomTouchCalibration()\nchrome.system.display.completeCustomTouchCalibration(\npairs: TouchCalibrationPairQuad,\nbounds: Bounds,\n)\nSets the touch calibration pairs for a display. These pairs\nwould be used to calibrate the touch screen for display with id\ncalled in startCustomTouchCalibration(). Always call startCustomTouchCalibration\nbefore calling this method. If another touch calibration is already in progress this will throw an error.\nParameters\n-\npairs\nThe pairs of point used to calibrate the display.\n-\nbounds\nBounds of the display when the touch calibration was performed.\nbounds.left\nandbounds.top\nvalues are ignored.\nenableUnifiedDesktop()\nchrome.system.display.enableUnifiedDesktop(\nenabled: boolean,\n)\nEnables/disables the unified desktop feature. If enabled while mirroring is active, the desktop mode will not change until mirroring is turned off. Otherwise, the desktop mode will switch to unified immediately. NOTE: This is only available to ChromeOS Kiosk apps and Web UI.\nParameters\n-\nenabled\nboolean\nTrue if unified desktop should be enabled.\ngetDisplayLayout()\nchrome.system.display.getDisplayLayout(\ncallback?: function,\n)\nRequests the layout info for all displays. NOTE: This is only available to ChromeOS Kiosk apps and Web UI.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(layouts: DisplayLayout[]) => void\n-\nlayouts\n-\nReturns\n-\nPromise<DisplayLayout[]>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetInfo()\nchrome.system.display.getInfo(\nflags?: GetInfoFlags,\ncallback?: function,\n)\nRequests the information for all attached display devices.\nParameters\n-\nflags\nGetInfoFlags optional\nChrome 59+Options affecting how the information is returned.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(displayInfo: DisplayUnitInfo[]) => void\n-\ndisplayInfo\n-\nReturns\n-\nPromise<DisplayUnitInfo[]>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\noverscanCalibrationAdjust()\nchrome.system.display.overscanCalibrationAdjust(\nid: string,\ndelta: Insets,\n)\nAdjusts the current overscan insets for a display. Typically this should either move the display along an axis (e.g. left+right have the same value) or scale it along an axis (e.g. top+bottom have opposite values). Each Adjust call is cumulative with previous calls since Start.\nParameters\n-\nid\nstring\nThe display's unique identifier.\n-\ndelta\nThe amount to change the overscan insets.\noverscanCalibrationComplete()\nchrome.system.display.overscanCalibrationComplete(\nid: string,\n)\nComplete overscan adjustments for a display by saving the current values and hiding the overlay.\nParameters\n-\nid\nstring\nThe display's unique identifier.\noverscanCalibrationReset()\nchrome.system.display.overscanCalibrationReset(\nid: string,\n)\nResets the overscan insets for a display to the last saved value (i.e before Start was called).\nParameters\n-\nid\nstring\nThe display's unique identifier.\noverscanCalibrationStart()\nchrome.system.display.overscanCalibrationStart(\nid: string,\n)\nStarts overscan calibration for a display. This will show an overlay on the screen indicating the current overscan insets. If overscan calibration for display id\nis in progress this will reset calibration.\nParameters\n-\nid\nstring\nThe display's unique identifier.\nsetDisplayLayout()\nchrome.system.display.setDisplayLayout(\nlayouts: DisplayLayout[],\ncallback?: function,\n)\nSet the layout for all displays. Any display not included will use the default layout. If a layout would overlap or be otherwise invalid it will be adjusted to a valid layout. After layout is resolved, an onDisplayChanged event will be triggered. NOTE: This is only available to ChromeOS Kiosk apps and Web UI.\nParameters\n-\nlayouts\nThe layout information, required for all displays except the primary display.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetDisplayProperties()\nchrome.system.display.setDisplayProperties(\nid: string,\ninfo: DisplayProperties,\ncallback?: function,\n)\nUpdates the properties for the display specified by id\n, according to the information provided in info\n. On failure, runtime.lastError\nwill be set. NOTE: This is only available to ChromeOS Kiosk apps and Web UI.\nParameters\n-\nid\nstring\nThe display's unique identifier.\n-\ninfo\nThe information about display properties that should be changed. A property will be changed only if a new value for it is specified in\ninfo\n. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetMirrorMode()\nchrome.system.display.setMirrorMode(\ninfo: MirrorModeInfo,\ncallback?: function,\n)\nSets the display mode to the specified mirror mode. Each call resets the state from previous calls. Calling setDisplayProperties() will fail for the mirroring destination displays. NOTE: This is only available to ChromeOS Kiosk apps and Web UI.\nParameters\n-\ninfo\nThe information of the mirror mode that should be applied to the display mode.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nshowNativeTouchCalibration()\nchrome.system.display.showNativeTouchCalibration(\nid: string,\ncallback?: function,\n)\nDisplays the native touch calibration UX for the display with id\nas display id. This will show an overlay on the screen with required instructions on how to proceed. The callback will be invoked in case of successful calibration only. If the calibration fails, this will throw an error.\nParameters\n-\nid\nstring\nThe display's unique identifier.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(success: boolean) => void\n-\nsuccess\nboolean\n-\nReturns\n-\nPromise<boolean>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nstartCustomTouchCalibration()\nchrome.system.display.startCustomTouchCalibration(\nid: string,\n)\nStarts custom touch calibration for a display. This should be called when using a custom UX for collecting calibration data. If another touch calibration is already in progress this will throw an error.\nParameters\n-\nid\nstring\nThe display's unique identifier.\nEvents\nonDisplayChanged\nchrome.system.display.onDisplayChanged.addListener(\ncallback: function,\n)\nFired when anything changes to the display configuration.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/system/memory", "title": "chrome.system.memory | API | Chrome for Developers", "text": "Description\nThe chrome.system.memory\nAPI.\nPermissions\nsystem.memory\nTypes\nMemoryInfo\nProperties\n-\navailableCapacity\nnumber\nThe amount of available capacity, in bytes.\n-\ncapacity\nnumber\nThe total amount of physical memory capacity, in bytes.\nMethods\ngetInfo()\nchrome.system.memory.getInfo(\ncallback?: function,\n)\nGet physical memory information.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(info: MemoryInfo) => void\n-\ninfo\n-\nReturns\n-\nPromise<MemoryInfo>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/system/storage", "title": "chrome.system.storage | API | Chrome for Developers", "text": "Description\nUse the chrome.system.storage\nAPI to query storage device information and be notified when a removable storage device is attached and detached.\nPermissions\nsystem.storage\nTypes\nEjectDeviceResultCode\nEnum\n\"success\" \"in_use\" \"no_such_device\" \"failure\"\nThe ejection command is successful -- the application can prompt the user to remove the device.\nThe device is in use by another application. The ejection did not succeed; the user should not remove the device until the other application is done with the device.\nThere is no such device known.\nThe ejection command failed.\nStorageAvailableCapacityInfo\nProperties\n-\navailableCapacity\nnumber\nThe available capacity of the storage device, in bytes.\n-\nid\nstring\nA copied\nid\nof getAvailableCapacity function parameterid\n.\nStorageUnitInfo\nProperties\n-\ncapacity\nnumber\nThe total amount of the storage space, in bytes.\n-\nid\nstring\nThe transient ID that uniquely identifies the storage device. This ID will be persistent within the same run of a single application. It will not be a persistent identifier between different runs of an application, or between different applications.\n-\nname\nstring\nThe name of the storage unit.\n-\ntype\nThe media type of the storage unit.\nStorageUnitType\nEnum\n\"fixed\" \"removable\" \"unknown\"\nThe storage has fixed media, e.g. hard disk or SSD.\nThe storage is removable, e.g. USB flash drive.\nThe storage type is unknown.\nMethods\nejectDevice()\nchrome.system.storage.ejectDevice(\nid: string,\ncallback?: function,\n)\nEjects a removable storage device.\nParameters\n-\nid\nstring\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: EjectDeviceResultCode) => void\n-\nresult\n-\nReturns\n-\nPromise<EjectDeviceResultCode>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetAvailableCapacity()\nchrome.system.storage.getAvailableCapacity(\nid: string,\ncallback?: function,\n)\nGet the available capacity of a specified id\nstorage device. The id\nis the transient device ID from StorageUnitInfo.\nParameters\n-\nid\nstring\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(info: StorageAvailableCapacityInfo) => void\nReturns\n-\nPromise<StorageAvailableCapacityInfo>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetInfo()\nchrome.system.storage.getInfo(\ncallback?: function,\n)\nGet the storage information from the system. The argument passed to the callback is an array of StorageUnitInfo objects.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(info: StorageUnitInfo[]) => void\n-\ninfo\n-\nReturns\n-\nPromise<StorageUnitInfo[]>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonAttached\nchrome.system.storage.onAttached.addListener(\ncallback: function,\n)\nFired when a new removable storage is attached to the system.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(info: StorageUnitInfo) => void\n-\ninfo\n-\nonDetached\nchrome.system.storage.onDetached.addListener(\ncallback: function,\n)\nFired when a removable storage is detached from the system.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(id: string) => void\n-\nid\nstring\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/systemLog", "title": "chrome.systemLog | API | Chrome for Developers", "text": "Description\nUse the chrome.systemLog\nAPI to record Chrome system logs from extensions.\nPermissions\nsystemLog\nAvailability\nTypes\nMessageOptions\nProperties\n-\nmessage\nstring\nMethods\nadd()\nchrome.systemLog.add(\noptions: MessageOptions,\ncallback?: function,\n)\nAdds a new log record.\nParameters\n-\noptions\nThe logging options.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/tabCapture", "title": "chrome.tabCapture | API | Chrome for Developers", "text": "Description\nUse the chrome.tabCapture\nAPI to interact with tab media streams.\nPermissions\ntabCapture\nConcepts and usage\nThe chrome.tabCapture API lets you access a MediaStream\ncontaining video and\naudio of the current tab. It can only be called after the user invokes an extension, such as by\nclicking the extension's action button. This is similar to the behavior of the\n\"activeTab\"\npermission.\nPreserve system audio\nWhen a MediaStream\nis obtained for a tab, audio in that tab will no longer be played\nto the user. This is similar to the behavior of the getDisplayMedia()\nfunction when\nthe suppressLocalAudioPlayback\nflag is set to true.\nTo continue playing audio to the user, use the following:\nconst output = new AudioContext();\nconst source = output.createMediaStreamSource(stream);\nsource.connect(output.destination);\nThis creates a new AudioContext\nand connects the audio of the tab's MediaStream\nto the default\ndestination.\nStream IDs\nCalling chrome.tabCapture.getMediaStreamId()\nwill return a stream ID. To later\naccess a MediaStream\nfrom the ID, use the following:\nnavigator.mediaDevices.getUserMedia({\naudio: {\nmandatory: {\nchromeMediaSource: \"tab\",\nchromeMediaSourceId: id,\n},\n},\nvideo: {\nmandatory: {\nchromeMediaSource: \"tab\",\nchromeMediaSourceId: id,\n},\n},\n});\nUsage restrictions\nAfter calling getMediaStreamId()\n, there are restrictions on where the\nreturned stream ID can be used:\n- If\nconsumerTabId\nis specified, the ID can be used by agetUserMedia()\ncall in any frame in the given tab which has the same security origin. - When this is not specified, beginning in Chrome 116, the ID can be used in any frame with the same security origin in the same render process as the caller. This means that a stream ID obtained in a service worker can be used in an offscreen document.\nPrior to Chrome 116, when a consumerTabId\nwas not specified, the stream ID was restricted to both\nthe security origin, render process and render frame of the caller.\nLearn more\nTo learn more about how to use the chrome.tabCapture\nAPI, see\nAudio recording and screen capture. This demonstrates how to use\ntabCapture\nand related APIs to solve a number of common use cases.\nTypes\nCaptureInfo\nProperties\n-\nfullscreen\nboolean\nWhether an element in the tab being captured is in fullscreen mode.\n-\nstatus\nThe new capture status of the tab.\n-\ntabId\nnumber\nThe id of the tab whose status changed.\nCaptureOptions\nProperties\n-\naudio\nboolean optional\n-\naudioConstraints\nMediaStreamConstraint optional\n-\nvideo\nboolean optional\n-\nvideoConstraints\nMediaStreamConstraint optional\nGetMediaStreamOptions\nProperties\n-\nconsumerTabId\nnumber optional\nOptional tab id of the tab which will later invoke\ngetUserMedia()\nto consume the stream. If not specified then the resulting stream can be used only by the calling extension. The stream can only be used by frames in the given tab whose security origin matches the consumber tab's origin. The tab's origin must be a secure origin, e.g. HTTPS. -\ntargetTabId\nnumber optional\nOptional tab id of the tab which will be captured. If not specified then the current active tab will be selected. Only tabs for which the extension has been granted the\nactiveTab\npermission can be used as the target tab.\nMediaStreamConstraint\nProperties\n-\nmandatory\nobject\n-\noptional\nobject optional\nTabCaptureState\nEnum\n\"pending\" \"active\" \"stopped\" \"error\"\nMethods\ncapture()\nchrome.tabCapture.capture(\noptions: CaptureOptions,\ncallback: function,\n)\nCaptures the visible area of the currently active tab. Capture can only be started on the currently active tab after the extension has been invoked, similar to the way that activeTab works. Capture is maintained across page navigations within the tab, and stops when the tab is closed, or the media stream is closed by the extension.\nParameters\n-\noptions\nConfigures the returned media stream.\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(stream: LocalMediaStream) => void\n-\nstream\nLocalMediaStream\n-\ngetCapturedTabs()\nchrome.tabCapture.getCapturedTabs(\ncallback?: function,\n)\nReturns a list of tabs that have requested capture or are being captured, i.e. status != stopped and status != error. This allows extensions to inform the user that there is an existing tab capture that would prevent a new tab capture from succeeding (or to prevent redundant requests for the same tab).\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: CaptureInfo[]) => void\n-\nresult\n-\nReturns\n-\nPromise<CaptureInfo[]>\nChrome 116+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetMediaStreamId()\nchrome.tabCapture.getMediaStreamId(\noptions?: GetMediaStreamOptions,\ncallback?: function,\n)\nCreates a stream ID to capture the target tab. Similar to chrome.tabCapture.capture() method, but returns a media stream ID, instead of a media stream, to the consumer tab.\nParameters\n-\noptions\nGetMediaStreamOptions optional\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(streamId: string) => void\n-\nstreamId\nstring\n-\nReturns\n-\nPromise<string>\nChrome 116+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonStatusChanged\nchrome.tabCapture.onStatusChanged.addListener(\ncallback: function,\n)\nEvent fired when the capture status of a tab changes. This allows extension authors to keep track of the capture status of tabs to keep UI elements like page actions in sync.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(info: CaptureInfo) => void\n-\ninfo\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/tabGroups", "title": "chrome.tabGroups | API | Chrome for Developers", "text": "Description\nUse the chrome.tabGroups\nAPI to interact with the browser's tab grouping system. You can use this API to modify and rearrange tab groups in the browser. To group and ungroup tabs, or to query what tabs are in groups, use the chrome.tabs\nAPI.\nPermissions\ntabGroups\nAvailability\nTypes\nColor\nThe group's color.\nEnum\n\"grey\" \"blue\" \"red\" \"yellow\" \"green\" \"pink\" \"purple\" \"cyan\" \"orange\"\nTabGroup\nProperties\n-\ncollapsed\nboolean\nWhether the group is collapsed. A collapsed group is one whose tabs are hidden.\n-\ncolor\nThe group's color.\n-\nid\nnumber\nThe ID of the group. Group IDs are unique within a browser session.\n-\ntitle\nstring optional\nThe title of the group.\n-\nwindowId\nnumber\nThe ID of the window that contains the group.\nProperties\nTAB_GROUP_ID_NONE\nAn ID that represents the absence of a group.\nValue\n-1\nMethods\nget()\nchrome.tabGroups.get(\ngroupId: number,\ncallback?: function,\n)\nRetrieves details about the specified group.\nParameters\n-\ngroupId\nnumber\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(group: TabGroup) => void\n-\ngroup\n-\nReturns\n-\nPromise<TabGroup>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nmove()\nchrome.tabGroups.move(\ngroupId: number,\nmoveProperties: object,\ncallback?: function,\n)\nMoves the group and all its tabs within its window, or to a new window.\nParameters\n-\ngroupId\nnumber\nThe ID of the group to move.\n-\nmoveProperties\nobject\n-\nindex\nnumber\nThe position to move the group to. Use\n-1\nto place the group at the end of the window. -\nwindowId\nnumber optional\nThe window to move the group to. Defaults to the window the group is currently in. Note that groups can only be moved to and from windows with\nwindows.WindowType\ntype\"normal\"\n.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(group?: TabGroup) => void\n-\ngroup\nTabGroup optional\nDetails about the moved group.\n-\nReturns\n-\nPromise<TabGroup | undefined>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nquery()\nchrome.tabGroups.query(\nqueryInfo: object,\ncallback?: function,\n)\nGets all groups that have the specified properties, or all groups if no properties are specified.\nParameters\n-\nqueryInfo\nobject\n-\ncollapsed\nboolean optional\nWhether the groups are collapsed.\n-\ncolor\nColor optional\nThe color of the groups.\n-\ntitle\nstring optional\nMatch group titles against a pattern.\n-\nwindowId\nnumber optional\nThe ID of the parent window, or\nwindows.WINDOW_ID_CURRENT\nfor the current window.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: TabGroup[]) => void\n-\nresult\nTabGroup[]\n-\nReturns\n-\nPromise<TabGroup[]>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdate()\nchrome.tabGroups.update(\ngroupId: number,\nupdateProperties: object,\ncallback?: function,\n)\nModifies the properties of a group. Properties that are not specified in updateProperties\nare not modified.\nParameters\n-\ngroupId\nnumber\nThe ID of the group to modify.\n-\nupdateProperties\nobject\n-\ncollapsed\nboolean optional\nWhether the group should be collapsed.\n-\ncolor\nColor optional\nThe color of the group.\n-\ntitle\nstring optional\nThe title of the group.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(group?: TabGroup) => void\n-\ngroup\nTabGroup optional\nDetails about the updated group.\n-\nReturns\n-\nPromise<TabGroup | undefined>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonCreated\nchrome.tabGroups.onCreated.addListener(\ncallback: function,\n)\nFired when a group is created.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(group: TabGroup) => void\n-\ngroup\n-\nonMoved\nchrome.tabGroups.onMoved.addListener(\ncallback: function,\n)\nFired when a group is moved within a window. Move events are still fired for the individual tabs within the group, as well as for the group itself. This event is not fired when a group is moved between windows; instead, it will be removed from one window and created in another.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(group: TabGroup) => void\n-\ngroup\n-\nonRemoved\nchrome.tabGroups.onRemoved.addListener(\ncallback: function,\n)\nFired when a group is closed, either directly by the user or automatically because it contained zero tabs.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(group: TabGroup) => void\n-\ngroup\n-\nonUpdated\nchrome.tabGroups.onUpdated.addListener(\ncallback: function,\n)\nFired when a group is updated."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/tabs", "title": "chrome.tabs | API | Chrome for Developers", "text": "Description\nUse the chrome.tabs\nAPI to interact with the browser's tab system. You can use this API to create, modify, and rearrange tabs in the browser.\nThe Tabs API not only offers features for manipulating and managing tabs, but can also detect the language of the tab, take a screenshot, and communicate with a tab's content scripts.\nPermissions\nMost features don't require any permissions to use. For example: creating a new tab, reloading a tab, navigating to another URL, etc.\nThere are three permissions developers should be aware of when working with the Tabs API.\n- The \"tabs\" permission\nThis permission does not give access to the\nchrome.tabs\nnamespace. Instead, it grants an extension the ability to calltabs.query()\nagainst four sensitive properties ontabs.Tab\ninstances:url\n,pendingUrl\n,title\n, andfavIconUrl\n.{ \"name\": \"My extension\", ... \"permissions\": [ \"tabs\" ], ... }\n- Host permissions\nHost permissions allow an extension to read and query a matching tab's four sensitive\ntabs.Tab\nproperties. They can also interact directly with the matching tabs using methods such astabs.captureVisibleTab()\n,tabs.executeScript()\n,tabs.insertCSS()\n, andtabs.removeCSS()\n.{ \"name\": \"My extension\", ... \"host_permissions\": [ \"http://*/*\", \"https://*/*\" ], ... }\n- The \"activeTab\" permission\nactiveTab\ngrants an extension temporary host permission for the current tab in response to a user invocation. Unlike host permissions,activeTab\ndoes not trigger any warnings.{ \"name\": \"My extension\", ... \"permissions\": [ \"activeTab\" ], ... }\nUse cases\nThe following sections demonstrate some common use cases.\nOpen an extension page in a new tab\nA common pattern for extensions is to open an onboarding page in a new tab when the extension is installed. The following example shows how to do this.\nbackground.js:\nchrome.runtime.onInstalled.addListener(({reason}) => {\nif (reason === 'install') {\nchrome.tabs.create({\nurl: \"onboarding.html\"\n});\n}\n});\nGet the current tab\nThis example demonstrates how an extension's service worker can retrieve the active tab from the currently-focused window (or most recently-focused window, if no Chrome windows are focused). This can usually be thought of as the user's current tab.\nasync function getCurrentTab() {\nlet queryOptions = { active: true, lastFocusedWindow: true };\n// `tab` will either be a `tabs.Tab` instance or `undefined`.\nlet [tab] = await chrome.tabs.query(queryOptions);\nreturn tab;\n}\nfunction getCurrentTab(callback) {\nlet queryOptions = { active: true, lastFocusedWindow: true };\nchrome.tabs.query(queryOptions, ([tab]) => {\nif (chrome.runtime.lastError)\nconsole.error(chrome.runtime.lastError);\n// `tab` will either be a `tabs.Tab` instance or `undefined`.\ncallback(tab);\n});\n}\nMute the specified tab\nThis example shows how an extension can toggle the muted state for a given tab.\nasync function toggleMuteState(tabId) {\nconst tab = await chrome.tabs.get(tabId);\nconst muted = !tab.mutedInfo.muted;\nawait chrome.tabs.update(tabId, {muted});\nconsole.log(`Tab ${tab.id} is ${muted ? \"muted\" : \"unmuted\"}`);\n}\nfunction toggleMuteState(tabId) {\nchrome.tabs.get(tabId, async (tab) => {\nlet muted = !tab.mutedInfo.muted;\nawait chrome.tabs.update(tabId, { muted });\nconsole.log(`Tab ${tab.id} is ${ muted ? \"muted\" : \"unmuted\" }`);\n});\n}\nMove the current tab to the first position when clicked\nThis example shows how to move a tab while a drag may or may not be in progress. While this example\nuses chrome.tabs.move\n, you can use the same waiting pattern for other calls that modify tabs while\na drag is in progress.\nchrome.tabs.onActivated.addListener(moveToFirstPosition);\nasync function moveToFirstPosition(activeInfo) {\ntry {\nawait chrome.tabs.move(activeInfo.tabId, {index: 0});\nconsole.log(\"Success.\");\n} catch (error) {\nif (error == \"Error: Tabs cannot be edited right now (user may be dragging a tab).\") {\nsetTimeout(() => moveToFirstPosition(activeInfo), 50);\n} else {\nconsole.error(error);\n}\n}\n}\nchrome.tabs.onActivated.addListener(moveToFirstPositionMV2);\nfunction moveToFirstPositionMV2(activeInfo) {\nchrome.tabs.move(activeInfo.tabId, { index: 0 }, () => {\nif (chrome.runtime.lastError) {\nconst error = chrome.runtime.lastError;\nif (error == \"Error: Tabs cannot be edited right now (user may be dragging a tab).\") {\nsetTimeout(() => moveToFirstPositionMV2(activeInfo), 50);\n} else {\nconsole.error(error);\n}\n} else {\nconsole.log(\"Success.\");\n}\n});\n}\nPass a message to a selected tab's content script\nThis example demonstrates how an extension's service worker can communicate with content scripts in specific browser tabs using tabs.sendMessage()\n.\nfunction sendMessageToActiveTab(message) {\nconst [tab] = await chrome.tabs.query({ active: true, lastFocusedWindow: true });\nconst response = await chrome.tabs.sendMessage(tab.id, message);\n// TODO: Do something with the response.\n}\nExtension examples\nFor more Tabs API extensions demos, explore any of the following:\nTypes\nMutedInfo\nThe tab's muted state and the reason for the last state change.\nProperties\n-\nextensionId\nstring optional\nThe ID of the extension that changed the muted state. Not set if an extension was not the reason the muted state last changed.\n-\nmuted\nboolean\nWhether the tab is muted (prevented from playing sound). The tab may be muted even if it has not played or is not currently playing sound. Equivalent to whether the 'muted' audio indicator is showing.\n-\nreason\nMutedInfoReason optional\nThe reason the tab was muted or unmuted. Not set if the tab's mute state has never been changed.\nMutedInfoReason\nAn event that caused a muted state change.\nEnum\n\"user\" \"capture\" \"extension\"\nA user input action set the muted state.\nTab capture was started, forcing a muted state change.\nAn extension, identified by the extensionId field, set the muted state.\nTab\nProperties\n-\nactive\nboolean\nWhether the tab is active in its window. Does not necessarily mean the window is focused.\n-\naudible\nboolean optional\nChrome 45+Whether the tab has produced sound over the past couple of seconds (but it might not be heard if also muted). Equivalent to whether the 'speaker audio' indicator is showing.\n-\nautoDiscardable\nboolean\nChrome 54+Whether the tab can be discarded automatically by the browser when resources are low.\n-\ndiscarded\nboolean\nChrome 54+Whether the tab is discarded. A discarded tab is one whose content has been unloaded from memory, but is still visible in the tab strip. Its content is reloaded the next time it is activated.\n-\nfavIconUrl\nstring optional\nThe URL of the tab's favicon. This property is only present if the extension's manifest includes the\n\"tabs\"\npermission. It may also be an empty string if the tab is loading. -\nfrozen\nboolean\nPendingWhether the tab is frozen. A frozen tab cannot execute tasks, including event handlers or timers. It is visible in the tab strip and its content is loaded in memory. It is unfrozen on activation.\n-\ngroupId\nnumber\nChrome 88+The ID of the group that the tab belongs to.\n-\nheight\nnumber optional\nThe height of the tab in pixels.\n-\nhighlighted\nboolean\nWhether the tab is highlighted.\n-\nid\nnumber optional\nThe ID of the tab. Tab IDs are unique within a browser session. Under some circumstances a tab may not be assigned an ID; for example, when querying foreign tabs using the\nsessions\nAPI, in which case a session ID may be present. Tab ID can also be set tochrome.tabs.TAB_ID_NONE\nfor apps and devtools windows. -\nincognito\nboolean\nWhether the tab is in an incognito window.\n-\nindex\nnumber\nThe zero-based index of the tab within its window.\n-\nlastAccessed\nnumber\nChrome 121+The last time the tab was accessed as the number of milliseconds since epoch.\n-\nmutedInfo\nMutedInfo optional\nChrome 46+The tab's muted state and the reason for the last state change.\n-\nopenerTabId\nnumber optional\nThe ID of the tab that opened this tab, if any. This property is only present if the opener tab still exists.\n-\npendingUrl\nstring optional\nChrome 79+The URL the tab is navigating to, before it has committed. This property is only present if the extension's manifest includes the\n\"tabs\"\npermission and there is a pending navigation. -\npinned\nboolean\nWhether the tab is pinned.\n-\nselected\nboolean\nDeprecatedPlease use\ntabs.Tab.highlighted\n.Whether the tab is selected.\n-\nsessionId\nstring optional\nThe session ID used to uniquely identify a tab obtained from the\nsessions\nAPI. -\nstatus\nTabStatus optional\nThe tab's loading status.\n-\ntitle\nstring optional\nThe title of the tab. This property is only present if the extension's manifest includes the\n\"tabs\"\npermission. -\nurl\nstring optional\nThe last committed URL of the main frame of the tab. This property is only present if the extension's manifest includes the\n\"tabs\"\npermission and may be an empty string if the tab has not yet committed. See alsoTab.pendingUrl\n. -\nwidth\nnumber optional\nThe width of the tab in pixels.\n-\nwindowId\nnumber\nThe ID of the window that contains the tab.\nTabStatus\nThe tab's loading status.\nEnum\n\"unloaded\" \"loading\" \"complete\"\nWindowType\nThe type of window.\nEnum\n\"normal\" \"popup\" \"panel\" \"app\" \"devtools\"\nZoomSettings\nDefines how zoom changes in a tab are handled and at what scope.\nProperties\n-\ndefaultZoomFactor\nnumber optional\nChrome 43+Used to return the default zoom level for the current tab in calls to tabs.getZoomSettings.\n-\nmode\nZoomSettingsMode optional\nDefines how zoom changes are handled, i.e., which entity is responsible for the actual scaling of the page; defaults to\nautomatic\n. -\nscope\nZoomSettingsScope optional\nDefines whether zoom changes persist for the page's origin, or only take effect in this tab; defaults to\nper-origin\nwhen inautomatic\nmode, andper-tab\notherwise.\nZoomSettingsMode\nDefines how zoom changes are handled, i.e., which entity is responsible for the actual scaling of the page; defaults to automatic\n.\nEnum\n\"automatic\" \"manual\" \"disabled\"\nZoom changes are handled automatically by the browser.\nOverrides the automatic handling of zoom changes. The onZoomChange\nevent will still be dispatched, and it is the extension's responsibility to listen for this event and manually scale the page. This mode does not support per-origin\nzooming, and thus ignores the scope\nzoom setting and assumes per-tab\n.\nDisables all zooming in the tab. The tab reverts to the default zoom level, and all attempted zoom changes are ignored.\nZoomSettingsScope\nDefines whether zoom changes persist for the page's origin, or only take effect in this tab; defaults to per-origin\nwhen in automatic\nmode, and per-tab\notherwise.\nEnum\n\"per-origin\" \"per-tab\"\nZoom changes persist in the zoomed page's origin, i.e., all other tabs navigated to that same origin are zoomed as well. Moreover, per-origin\nzoom changes are saved with the origin, meaning that when navigating to other pages in the same origin, they are all zoomed to the same zoom factor. The per-origin\nscope is only available in the automatic\nmode.\nZoom changes only take effect in this tab, and zoom changes in other tabs do not affect the zooming of this tab. Also, per-tab\nzoom changes are reset on navigation; navigating a tab always loads pages with their per-origin\nzoom factors.\nProperties\nMAX_CAPTURE_VISIBLE_TAB_CALLS_PER_SECOND\nThe maximum number of times that captureVisibleTab\ncan be called per second. captureVisibleTab\nis expensive and should not be called too often.\nValue\n2\nTAB_ID_NONE\nAn ID that represents the absence of a browser tab.\nValue\n-1\nTAB_INDEX_NONE\nAn index that represents the absence of a tab index in a tab_strip.\nValue\n-1\nMethods\ncaptureVisibleTab()\nchrome.tabs.captureVisibleTab(\nwindowId?: number,\noptions?: ImageDetails,\ncallback?: function,\n)\nCaptures the visible area of the currently active tab in the specified window. In order to call this method, the extension must have either the <all_urls> permission or the activeTab permission. In addition to sites that extensions can normally access, this method allows extensions to capture sensitive sites that are otherwise restricted, including chrome:-scheme pages, other extensions' pages, and data: URLs. These sensitive sites can only be captured with the activeTab permission. File URLs may be captured only if the extension has been granted file access.\nParameters\n-\nwindowId\nnumber optional\nThe target window. Defaults to the current window.\n-\noptions\nImageDetails optional\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(dataUrl: string) => void\n-\ndataUrl\nstring\nA data URL that encodes an image of the visible area of the captured tab. May be assigned to the 'src' property of an HTML\nimg\nelement for display.\n-\nReturns\n-\nPromise<string>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nconnect()\nchrome.tabs.connect(\ntabId: number,\nconnectInfo?: object,\n)\nConnects to the content script(s) in the specified tab. The runtime.onConnect\nevent is fired in each content script running in the specified tab for the current extension. For more details, see Content Script Messaging.\nParameters\n-\ntabId\nnumber\n-\nconnectInfo\nobject optional\n-\ndocumentId\nstring optional\nChrome 106+Open a port to a specific document identified by\ndocumentId\ninstead of all frames in the tab. -\nframeId\nnumber optional\nOpen a port to a specific frame identified by\nframeId\ninstead of all frames in the tab. -\nname\nstring optional\nIs passed into onConnect for content scripts that are listening for the connection event.\n-\nReturns\n-\nA port that can be used to communicate with the content scripts running in the specified tab. The port's\nruntime.Port\nevent is fired if the tab closes or does not exist.\ncreate()\nchrome.tabs.create(\ncreateProperties: object,\ncallback?: function,\n)\nCreates a new tab.\nParameters\n-\ncreateProperties\nobject\n-\nactive\nboolean optional\nWhether the tab should become the active tab in the window. Does not affect whether the window is focused (see\nwindows.update\n). Defaults totrue\n. -\nindex\nnumber optional\nThe position the tab should take in the window. The provided value is clamped to between zero and the number of tabs in the window.\n-\nopenerTabId\nnumber optional\nThe ID of the tab that opened this tab. If specified, the opener tab must be in the same window as the newly created tab.\n-\npinned\nboolean optional\nWhether the tab should be pinned. Defaults to\nfalse\n-\nselected\nboolean optional\nDeprecatedPlease use active.\nWhether the tab should become the selected tab in the window. Defaults to\ntrue\n-\nurl\nstring optional\nThe URL to initially navigate the tab to. Fully-qualified URLs must include a scheme (i.e., 'http://www.google.com', not 'www.google.com'). Relative URLs are relative to the current page within the extension. Defaults to the New Tab Page.\n-\nwindowId\nnumber optional\nThe window in which to create the new tab. Defaults to the current window.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(tab: Tab) => void\n-\ntab\nThe created tab.\n-\nReturns\n-\nPromise<Tab>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ndetectLanguage()\nchrome.tabs.detectLanguage(\ntabId?: number,\ncallback?: function,\n)\nDetects the primary language of the content in a tab.\nParameters\n-\ntabId\nnumber optional\nDefaults to the active tab of the current window.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(language: string) => void\n-\nlanguage\nstring\nAn ISO language code such as\nen\norfr\n. For a complete list of languages supported by this method, see kLanguageInfoTable. The second to fourth columns are checked and the first non-NULL value is returned, except for Simplified Chinese for whichzh-CN\nis returned. For an unknown/undefined language,und\nis returned.\n-\nReturns\n-\nPromise<string>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ndiscard()\nchrome.tabs.discard(\ntabId?: number,\ncallback?: function,\n)\nDiscards a tab from memory. Discarded tabs are still visible on the tab strip and are reloaded when activated.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to be discarded. If specified, the tab is discarded unless it is active or already discarded. If omitted, the browser discards the least important tab. This can fail if no discardable tabs exist.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(tab?: Tab) => void\n-\ntab\nTab optional\nThe discarded tab, if it was successfully discarded; undefined otherwise.\n-\nReturns\n-\nPromise<Tab | undefined>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nduplicate()\nchrome.tabs.duplicate(\ntabId: number,\ncallback?: function,\n)\nDuplicates a tab.\nParameters\n-\ntabId\nnumber\nThe ID of the tab to duplicate.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(tab?: Tab) => void\nReturns\n-\nPromise<Tab | undefined>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nget()\nchrome.tabs.get(\ntabId: number,\ncallback?: function,\n)\nRetrieves details about the specified tab.\nParameters\n-\ntabId\nnumber\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(tab: Tab) => void\n-\ntab\n-\nReturns\n-\nPromise<Tab>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetCurrent()\nchrome.tabs.getCurrent(\ncallback?: function,\n)\nGets the tab that this script call is being made from. Returns undefined\nif called from a non-tab context (for example, a background page or popup view).\nParameters\nReturns\n-\nPromise<Tab | undefined>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetZoom()\nchrome.tabs.getZoom(\ntabId?: number,\ncallback?: function,\n)\nGets the current zoom factor of a specified tab.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to get the current zoom factor from; defaults to the active tab of the current window.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(zoomFactor: number) => void\n-\nzoomFactor\nnumber\nThe tab's current zoom factor.\n-\nReturns\n-\nPromise<number>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetZoomSettings()\nchrome.tabs.getZoomSettings(\ntabId?: number,\ncallback?: function,\n)\nGets the current zoom settings of a specified tab.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to get the current zoom settings from; defaults to the active tab of the current window.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(zoomSettings: ZoomSettings) => void\n-\nzoomSettings\nThe tab's current zoom settings.\n-\nReturns\n-\nPromise<ZoomSettings>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngoBack()\nchrome.tabs.goBack(\ntabId?: number,\ncallback?: function,\n)\nGo back to the previous page, if one is available.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to navigate back; defaults to the selected tab of the current window.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngoForward()\nchrome.tabs.goForward(\ntabId?: number,\ncallback?: function,\n)\nGo foward to the next page, if one is available.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to navigate forward; defaults to the selected tab of the current window.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngroup()\nchrome.tabs.group(\noptions: object,\ncallback?: function,\n)\nAdds one or more tabs to a specified group, or if no group is specified, adds the given tabs to a newly created group.\nParameters\n-\noptions\nobject\n-\ncreateProperties\nobject optional\nConfigurations for creating a group. Cannot be used if groupId is already specified.\n-\nwindowId\nnumber optional\nThe window of the new group. Defaults to the current window.\n-\n-\ngroupId\nnumber optional\nThe ID of the group to add the tabs to. If not specified, a new group will be created.\n-\ntabIds\nnumber | [number, ...number[]]\nThe tab ID or list of tab IDs to add to the specified group.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(groupId: number) => void\n-\ngroupId\nnumber\nThe ID of the group that the tabs were added to.\n-\nReturns\n-\nPromise<number>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nhighlight()\nchrome.tabs.highlight(\nhighlightInfo: object,\ncallback?: function,\n)\nHighlights the given tabs and focuses on the first of group. Will appear to do nothing if the specified tab is currently active.\nParameters\n-\nhighlightInfo\nobject\n-\ntabs\nnumber | number[]\nOne or more tab indices to highlight.\n-\nwindowId\nnumber optional\nThe window that contains the tabs.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(window: Window) => void\n-\nwindow\nContains details about the window whose tabs were highlighted.\n-\nReturns\n-\nPromise<windows.Window>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nmove()\nchrome.tabs.move(\ntabIds: number | number[],\nmoveProperties: object,\ncallback?: function,\n)\nMoves one or more tabs to a new position within its window, or to a new window. Note that tabs can only be moved to and from normal (window.type === \"normal\") windows.\nParameters\n-\ntabIds\nnumber | number[]\nThe tab ID or list of tab IDs to move.\n-\nmoveProperties\nobject\n-\nindex\nnumber\nThe position to move the window to. Use\n-1\nto place the tab at the end of the window. -\nwindowId\nnumber optional\nDefaults to the window the tab is currently in.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(tabs: Tab | Tab[]) => void\nReturns\n-\nChrome 88+\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nquery()\nchrome.tabs.query(\nqueryInfo: object,\ncallback?: function,\n)\nGets all tabs that have the specified properties, or all tabs if no properties are specified.\nParameters\n-\nqueryInfo\nobject\n-\nactive\nboolean optional\nWhether the tabs are active in their windows.\n-\naudible\nboolean optional\nChrome 45+Whether the tabs are audible.\n-\nautoDiscardable\nboolean optional\nChrome 54+Whether the tabs can be discarded automatically by the browser when resources are low.\n-\ncurrentWindow\nboolean optional\nWhether the tabs are in the current window.\n-\ndiscarded\nboolean optional\nChrome 54+Whether the tabs are discarded. A discarded tab is one whose content has been unloaded from memory, but is still visible in the tab strip. Its content is reloaded the next time it is activated.\n-\nfrozen\nboolean optional\nPendingWhether the tabs are frozen. A frozen tab cannot execute tasks, including event handlers or timers. It is visible in the tab strip and its content is loaded in memory. It is unfrozen on activation.\n-\ngroupId\nnumber optional\nChrome 88+The ID of the group that the tabs are in, or\ntabGroups.TAB_GROUP_ID_NONE\nfor ungrouped tabs. -\nhighlighted\nboolean optional\nWhether the tabs are highlighted.\n-\nindex\nnumber optional\nThe position of the tabs within their windows.\n-\nlastFocusedWindow\nboolean optional\nWhether the tabs are in the last focused window.\n-\nmuted\nboolean optional\nChrome 45+Whether the tabs are muted.\n-\npinned\nboolean optional\nWhether the tabs are pinned.\n-\nstatus\nTabStatus optional\nThe tab loading status.\n-\ntitle\nstring optional\nMatch page titles against a pattern. This property is ignored if the extension does not have the\n\"tabs\"\npermission. -\nurl\nstring | string[] optional\nMatch tabs against one or more URL patterns. Fragment identifiers are not matched. This property is ignored if the extension does not have the\n\"tabs\"\npermission. -\nwindowId\nnumber optional\nThe ID of the parent window, or\nwindows.WINDOW_ID_CURRENT\nfor the current window. -\nwindowType\nWindowType optional\nThe type of window the tabs are in.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: Tab[]) => void\n-\nresult\nTab[]\n-\nReturns\n-\nPromise<Tab[]>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nreload()\nchrome.tabs.reload(\ntabId?: number,\nreloadProperties?: object,\ncallback?: function,\n)\nReload a tab.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to reload; defaults to the selected tab of the current window.\n-\nreloadProperties\nobject optional\n-\nbypassCache\nboolean optional\nWhether to bypass local caching. Defaults to\nfalse\n.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremove()\nchrome.tabs.remove(\ntabIds: number | number[],\ncallback?: function,\n)\nCloses one or more tabs.\nParameters\n-\ntabIds\nnumber | number[]\nThe tab ID or list of tab IDs to close.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsendMessage()\nchrome.tabs.sendMessage(\ntabId: number,\nmessage: any,\noptions?: object,\ncallback?: function,\n)\nSends a single message to the content script(s) in the specified tab, with an optional callback to run when a response is sent back. The runtime.onMessage\nevent is fired in each content script running in the specified tab for the current extension.\nParameters\n-\ntabId\nnumber\n-\nmessage\nany\nThe message to send. This message should be a JSON-ifiable object.\n-\noptions\nobject optional\n-\ncallback\nfunction optional\nChrome 99+The\ncallback\nparameter looks like:(response: any) => void\n-\nresponse\nany\nThe JSON response object sent by the handler of the message. If an error occurs while connecting to the specified tab, the callback is called with no arguments and\nruntime.lastError\nis set to the error message.\n-\nReturns\n-\nPromise<any>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetZoom()\nchrome.tabs.setZoom(\ntabId?: number,\nzoomFactor: number,\ncallback?: function,\n)\nZooms a specified tab.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to zoom; defaults to the active tab of the current window.\n-\nzoomFactor\nnumber\nThe new zoom factor. A value of\n0\nsets the tab to its current default zoom factor. Values greater than0\nspecify a (possibly non-default) zoom factor for the tab. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetZoomSettings()\nchrome.tabs.setZoomSettings(\ntabId?: number,\nzoomSettings: ZoomSettings,\ncallback?: function,\n)\nSets the zoom settings for a specified tab, which define how zoom changes are handled. These settings are reset to defaults upon navigating the tab.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to change the zoom settings for; defaults to the active tab of the current window.\n-\nzoomSettings\nDefines how zoom changes are handled and at what scope.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nungroup()\nchrome.tabs.ungroup(\ntabIds: number | [number, ...number[]],\ncallback?: function,\n)\nRemoves one or more tabs from their respective groups. If any groups become empty, they are deleted.\nParameters\n-\ntabIds\nnumber | [number, ...number[]]\nThe tab ID or list of tab IDs to remove from their respective groups.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdate()\nchrome.tabs.update(\ntabId?: number,\nupdateProperties: object,\ncallback?: function,\n)\nModifies the properties of a tab. Properties that are not specified in updateProperties\nare not modified.\nParameters\n-\ntabId\nnumber optional\nDefaults to the selected tab of the current window.\n-\nupdateProperties\nobject\n-\nactive\nboolean optional\nWhether the tab should be active. Does not affect whether the window is focused (see\nwindows.update\n). -\nautoDiscardable\nboolean optional\nChrome 54+Whether the tab should be discarded automatically by the browser when resources are low.\n-\nhighlighted\nboolean optional\nAdds or removes the tab from the current selection.\n-\nmuted\nboolean optional\nChrome 45+Whether the tab should be muted.\n-\nopenerTabId\nnumber optional\nThe ID of the tab that opened this tab. If specified, the opener tab must be in the same window as this tab.\n-\npinned\nboolean optional\nWhether the tab should be pinned.\n-\nselected\nboolean optional\nDeprecatedPlease use highlighted.\nWhether the tab should be selected.\n-\nurl\nstring optional\nA URL to navigate the tab to. JavaScript URLs are not supported; use\nscripting.executeScript\ninstead.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(tab?: Tab) => void\nReturns\n-\nPromise<Tab | undefined>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonActivated\nchrome.tabs.onActivated.addListener(\ncallback: function,\n)\nFires when the active tab in a window changes. Note that the tab's URL may not be set at the time this event fired, but you can listen to onUpdated events so as to be notified when a URL is set.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(activeInfo: object) => void\n-\nactiveInfo\nobject\n-\ntabId\nnumber\nThe ID of the tab that has become active.\n-\nwindowId\nnumber\nThe ID of the window the active tab changed inside of.\n-\n-\nonAttached\nchrome.tabs.onAttached.addListener(\ncallback: function,\n)\nFired when a tab is attached to a window; for example, because it was moved between windows.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(tabId: number, attachInfo: object) => void\n-\ntabId\nnumber\n-\nattachInfo\nobject\n-\nnewPosition\nnumber\n-\nnewWindowId\nnumber\n-\n-\nonCreated\nchrome.tabs.onCreated.addListener(\ncallback: function,\n)\nFired when a tab is created. Note that the tab's URL and tab group membership may not be set at the time this event is fired, but you can listen to onUpdated events so as to be notified when a URL is set or the tab is added to a tab group.\nonDetached\nchrome.tabs.onDetached.addListener(\ncallback: function,\n)\nFired when a tab is detached from a window; for example, because it was moved between windows.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(tabId: number, detachInfo: object) => void\n-\ntabId\nnumber\n-\ndetachInfo\nobject\n-\noldPosition\nnumber\n-\noldWindowId\nnumber\n-\n-\nonHighlighted\nchrome.tabs.onHighlighted.addListener(\ncallback: function,\n)\nFired when the highlighted or selected tabs in a window changes.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(highlightInfo: object) => void\n-\nhighlightInfo\nobject\n-\ntabIds\nnumber[]\nAll highlighted tabs in the window.\n-\nwindowId\nnumber\nThe window whose tabs changed.\n-\n-\nonMoved\nchrome.tabs.onMoved.addListener(\ncallback: function,\n)\nFired when a tab is moved within a window. Only one move event is fired, representing the tab the user directly moved. Move events are not fired for the other tabs that must move in response to the manually-moved tab. This event is not fired when a tab is moved between windows; for details, see tabs.onDetached\n.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(tabId: number, moveInfo: object) => void\n-\ntabId\nnumber\n-\nmoveInfo\nobject\n-\nfromIndex\nnumber\n-\ntoIndex\nnumber\n-\nwindowId\nnumber\n-\n-\nonRemoved\nchrome.tabs.onRemoved.addListener(\ncallback: function,\n)\nFired when a tab is closed.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(tabId: number, removeInfo: object) => void\n-\ntabId\nnumber\n-\nremoveInfo\nobject\n-\nisWindowClosing\nboolean\nTrue when the tab was closed because its parent window was closed.\n-\nwindowId\nnumber\nThe window whose tab is closed.\n-\n-\nonReplaced\nchrome.tabs.onReplaced.addListener(\ncallback: function,\n)\nFired when a tab is replaced with another tab due to prerendering or instant.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(addedTabId: number, removedTabId: number) => void\n-\naddedTabId\nnumber\n-\nremovedTabId\nnumber\n-\nonUpdated\nchrome.tabs.onUpdated.addListener(\ncallback: function,\n)\nFired when a tab is updated.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(tabId: number, changeInfo: object, tab: Tab) => void\n-\ntabId\nnumber\n-\nchangeInfo\nobject\n-\naudible\nboolean optional\nChrome 45+The tab's new audible state.\n-\nautoDiscardable\nboolean optional\nChrome 54+The tab's new auto-discardable state.\n-\ndiscarded\nboolean optional\nChrome 54+The tab's new discarded state.\n-\nfavIconUrl\nstring optional\nThe tab's new favicon URL.\n-\nfrozen\nboolean optional\nPendingThe tab's new frozen state.\n-\ngroupId\nnumber optional\nChrome 88+The tab's new group.\n-\nmutedInfo\nMutedInfo optional\nChrome 46+The tab's new muted state and the reason for the change.\n-\npinned\nboolean optional\nThe tab's new pinned state.\n-\nstatus\nTabStatus optional\nThe tab's loading status.\n-\ntitle\nstring optional\nChrome 48+The tab's new title.\n-\nurl\nstring optional\nThe tab's URL if it has changed.\n-\n-\ntab\n-\nonZoomChange\nchrome.tabs.onZoomChange.addListener(\ncallback: function,\n)\nFired when a tab is zoomed.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(ZoomChangeInfo: object) => void\n-\nZoomChangeInfo\nobject\n-\nnewZoomFactor\nnumber\n-\noldZoomFactor\nnumber\n-\ntabId\nnumber\n-\nzoomSettings\n-\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/tabs", "title": "chrome.tabs | API | Chrome for Developers", "text": "Description\nUse the chrome.tabs\nAPI to interact with the browser's tab system. You can use this API to create, modify, and rearrange tabs in the browser.\nThe Tabs API not only offers features for manipulating and managing tabs, but can also detect the language of the tab, take a screenshot, and communicate with a tab's content scripts.\nPermissions\nMost features don't require any permissions to use. For example: creating a new tab, reloading a tab, navigating to another URL, etc.\nThere are three permissions developers should be aware of when working with the Tabs API.\n- The \"tabs\" permission\nThis permission does not give access to the\nchrome.tabs\nnamespace. Instead, it grants an extension the ability to calltabs.query()\nagainst four sensitive properties ontabs.Tab\ninstances:url\n,pendingUrl\n,title\n, andfavIconUrl\n.{ \"name\": \"My extension\", ... \"permissions\": [ \"tabs\" ], ... }\n- Host permissions\nHost permissions allow an extension to read and query a matching tab's four sensitive\ntabs.Tab\nproperties. They can also interact directly with the matching tabs using methods such astabs.captureVisibleTab()\n,tabs.executeScript()\n,tabs.insertCSS()\n, andtabs.removeCSS()\n.{ \"name\": \"My extension\", ... \"host_permissions\": [ \"http://*/*\", \"https://*/*\" ], ... }\n- The \"activeTab\" permission\nactiveTab\ngrants an extension temporary host permission for the current tab in response to a user invocation. Unlike host permissions,activeTab\ndoes not trigger any warnings.{ \"name\": \"My extension\", ... \"permissions\": [ \"activeTab\" ], ... }\nUse cases\nThe following sections demonstrate some common use cases.\nOpen an extension page in a new tab\nA common pattern for extensions is to open an onboarding page in a new tab when the extension is installed. The following example shows how to do this.\nbackground.js:\nchrome.runtime.onInstalled.addListener(({reason}) => {\nif (reason === 'install') {\nchrome.tabs.create({\nurl: \"onboarding.html\"\n});\n}\n});\nGet the current tab\nThis example demonstrates how an extension's service worker can retrieve the active tab from the currently-focused window (or most recently-focused window, if no Chrome windows are focused). This can usually be thought of as the user's current tab.\nasync function getCurrentTab() {\nlet queryOptions = { active: true, lastFocusedWindow: true };\n// `tab` will either be a `tabs.Tab` instance or `undefined`.\nlet [tab] = await chrome.tabs.query(queryOptions);\nreturn tab;\n}\nfunction getCurrentTab(callback) {\nlet queryOptions = { active: true, lastFocusedWindow: true };\nchrome.tabs.query(queryOptions, ([tab]) => {\nif (chrome.runtime.lastError)\nconsole.error(chrome.runtime.lastError);\n// `tab` will either be a `tabs.Tab` instance or `undefined`.\ncallback(tab);\n});\n}\nMute the specified tab\nThis example shows how an extension can toggle the muted state for a given tab.\nasync function toggleMuteState(tabId) {\nconst tab = await chrome.tabs.get(tabId);\nconst muted = !tab.mutedInfo.muted;\nawait chrome.tabs.update(tabId, {muted});\nconsole.log(`Tab ${tab.id} is ${muted ? \"muted\" : \"unmuted\"}`);\n}\nfunction toggleMuteState(tabId) {\nchrome.tabs.get(tabId, async (tab) => {\nlet muted = !tab.mutedInfo.muted;\nawait chrome.tabs.update(tabId, { muted });\nconsole.log(`Tab ${tab.id} is ${ muted ? \"muted\" : \"unmuted\" }`);\n});\n}\nMove the current tab to the first position when clicked\nThis example shows how to move a tab while a drag may or may not be in progress. While this example\nuses chrome.tabs.move\n, you can use the same waiting pattern for other calls that modify tabs while\na drag is in progress.\nchrome.tabs.onActivated.addListener(moveToFirstPosition);\nasync function moveToFirstPosition(activeInfo) {\ntry {\nawait chrome.tabs.move(activeInfo.tabId, {index: 0});\nconsole.log(\"Success.\");\n} catch (error) {\nif (error == \"Error: Tabs cannot be edited right now (user may be dragging a tab).\") {\nsetTimeout(() => moveToFirstPosition(activeInfo), 50);\n} else {\nconsole.error(error);\n}\n}\n}\nchrome.tabs.onActivated.addListener(moveToFirstPositionMV2);\nfunction moveToFirstPositionMV2(activeInfo) {\nchrome.tabs.move(activeInfo.tabId, { index: 0 }, () => {\nif (chrome.runtime.lastError) {\nconst error = chrome.runtime.lastError;\nif (error == \"Error: Tabs cannot be edited right now (user may be dragging a tab).\") {\nsetTimeout(() => moveToFirstPositionMV2(activeInfo), 50);\n} else {\nconsole.error(error);\n}\n} else {\nconsole.log(\"Success.\");\n}\n});\n}\nPass a message to a selected tab's content script\nThis example demonstrates how an extension's service worker can communicate with content scripts in specific browser tabs using tabs.sendMessage()\n.\nfunction sendMessageToActiveTab(message) {\nconst [tab] = await chrome.tabs.query({ active: true, lastFocusedWindow: true });\nconst response = await chrome.tabs.sendMessage(tab.id, message);\n// TODO: Do something with the response.\n}\nExtension examples\nFor more Tabs API extensions demos, explore any of the following:\nTypes\nMutedInfo\nThe tab's muted state and the reason for the last state change.\nProperties\n-\nextensionId\nstring optional\nThe ID of the extension that changed the muted state. Not set if an extension was not the reason the muted state last changed.\n-\nmuted\nboolean\nWhether the tab is muted (prevented from playing sound). The tab may be muted even if it has not played or is not currently playing sound. Equivalent to whether the 'muted' audio indicator is showing.\n-\nreason\nMutedInfoReason optional\nThe reason the tab was muted or unmuted. Not set if the tab's mute state has never been changed.\nMutedInfoReason\nAn event that caused a muted state change.\nEnum\n\"user\" \"capture\" \"extension\"\nA user input action set the muted state.\nTab capture was started, forcing a muted state change.\nAn extension, identified by the extensionId field, set the muted state.\nTab\nProperties\n-\nactive\nboolean\nWhether the tab is active in its window. Does not necessarily mean the window is focused.\n-\naudible\nboolean optional\nChrome 45+Whether the tab has produced sound over the past couple of seconds (but it might not be heard if also muted). Equivalent to whether the 'speaker audio' indicator is showing.\n-\nautoDiscardable\nboolean\nChrome 54+Whether the tab can be discarded automatically by the browser when resources are low.\n-\ndiscarded\nboolean\nChrome 54+Whether the tab is discarded. A discarded tab is one whose content has been unloaded from memory, but is still visible in the tab strip. Its content is reloaded the next time it is activated.\n-\nfavIconUrl\nstring optional\nThe URL of the tab's favicon. This property is only present if the extension's manifest includes the\n\"tabs\"\npermission. It may also be an empty string if the tab is loading. -\nfrozen\nboolean\nPendingWhether the tab is frozen. A frozen tab cannot execute tasks, including event handlers or timers. It is visible in the tab strip and its content is loaded in memory. It is unfrozen on activation.\n-\ngroupId\nnumber\nChrome 88+The ID of the group that the tab belongs to.\n-\nheight\nnumber optional\nThe height of the tab in pixels.\n-\nhighlighted\nboolean\nWhether the tab is highlighted.\n-\nid\nnumber optional\nThe ID of the tab. Tab IDs are unique within a browser session. Under some circumstances a tab may not be assigned an ID; for example, when querying foreign tabs using the\nsessions\nAPI, in which case a session ID may be present. Tab ID can also be set tochrome.tabs.TAB_ID_NONE\nfor apps and devtools windows. -\nincognito\nboolean\nWhether the tab is in an incognito window.\n-\nindex\nnumber\nThe zero-based index of the tab within its window.\n-\nlastAccessed\nnumber\nChrome 121+The last time the tab was accessed as the number of milliseconds since epoch.\n-\nmutedInfo\nMutedInfo optional\nChrome 46+The tab's muted state and the reason for the last state change.\n-\nopenerTabId\nnumber optional\nThe ID of the tab that opened this tab, if any. This property is only present if the opener tab still exists.\n-\npendingUrl\nstring optional\nChrome 79+The URL the tab is navigating to, before it has committed. This property is only present if the extension's manifest includes the\n\"tabs\"\npermission and there is a pending navigation. -\npinned\nboolean\nWhether the tab is pinned.\n-\nselected\nboolean\nDeprecatedPlease use\ntabs.Tab.highlighted\n.Whether the tab is selected.\n-\nsessionId\nstring optional\nThe session ID used to uniquely identify a tab obtained from the\nsessions\nAPI. -\nstatus\nTabStatus optional\nThe tab's loading status.\n-\ntitle\nstring optional\nThe title of the tab. This property is only present if the extension's manifest includes the\n\"tabs\"\npermission. -\nurl\nstring optional\nThe last committed URL of the main frame of the tab. This property is only present if the extension's manifest includes the\n\"tabs\"\npermission and may be an empty string if the tab has not yet committed. See alsoTab.pendingUrl\n. -\nwidth\nnumber optional\nThe width of the tab in pixels.\n-\nwindowId\nnumber\nThe ID of the window that contains the tab.\nTabStatus\nThe tab's loading status.\nEnum\n\"unloaded\" \"loading\" \"complete\"\nWindowType\nThe type of window.\nEnum\n\"normal\" \"popup\" \"panel\" \"app\" \"devtools\"\nZoomSettings\nDefines how zoom changes in a tab are handled and at what scope.\nProperties\n-\ndefaultZoomFactor\nnumber optional\nChrome 43+Used to return the default zoom level for the current tab in calls to tabs.getZoomSettings.\n-\nmode\nZoomSettingsMode optional\nDefines how zoom changes are handled, i.e., which entity is responsible for the actual scaling of the page; defaults to\nautomatic\n. -\nscope\nZoomSettingsScope optional\nDefines whether zoom changes persist for the page's origin, or only take effect in this tab; defaults to\nper-origin\nwhen inautomatic\nmode, andper-tab\notherwise.\nZoomSettingsMode\nDefines how zoom changes are handled, i.e., which entity is responsible for the actual scaling of the page; defaults to automatic\n.\nEnum\n\"automatic\" \"manual\" \"disabled\"\nZoom changes are handled automatically by the browser.\nOverrides the automatic handling of zoom changes. The onZoomChange\nevent will still be dispatched, and it is the extension's responsibility to listen for this event and manually scale the page. This mode does not support per-origin\nzooming, and thus ignores the scope\nzoom setting and assumes per-tab\n.\nDisables all zooming in the tab. The tab reverts to the default zoom level, and all attempted zoom changes are ignored.\nZoomSettingsScope\nDefines whether zoom changes persist for the page's origin, or only take effect in this tab; defaults to per-origin\nwhen in automatic\nmode, and per-tab\notherwise.\nEnum\n\"per-origin\" \"per-tab\"\nZoom changes persist in the zoomed page's origin, i.e., all other tabs navigated to that same origin are zoomed as well. Moreover, per-origin\nzoom changes are saved with the origin, meaning that when navigating to other pages in the same origin, they are all zoomed to the same zoom factor. The per-origin\nscope is only available in the automatic\nmode.\nZoom changes only take effect in this tab, and zoom changes in other tabs do not affect the zooming of this tab. Also, per-tab\nzoom changes are reset on navigation; navigating a tab always loads pages with their per-origin\nzoom factors.\nProperties\nMAX_CAPTURE_VISIBLE_TAB_CALLS_PER_SECOND\nThe maximum number of times that captureVisibleTab\ncan be called per second. captureVisibleTab\nis expensive and should not be called too often.\nValue\n2\nTAB_ID_NONE\nAn ID that represents the absence of a browser tab.\nValue\n-1\nTAB_INDEX_NONE\nAn index that represents the absence of a tab index in a tab_strip.\nValue\n-1\nMethods\ncaptureVisibleTab()\nchrome.tabs.captureVisibleTab(\nwindowId?: number,\noptions?: ImageDetails,\ncallback?: function,\n)\nCaptures the visible area of the currently active tab in the specified window. In order to call this method, the extension must have either the <all_urls> permission or the activeTab permission. In addition to sites that extensions can normally access, this method allows extensions to capture sensitive sites that are otherwise restricted, including chrome:-scheme pages, other extensions' pages, and data: URLs. These sensitive sites can only be captured with the activeTab permission. File URLs may be captured only if the extension has been granted file access.\nParameters\n-\nwindowId\nnumber optional\nThe target window. Defaults to the current window.\n-\noptions\nImageDetails optional\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(dataUrl: string) => void\n-\ndataUrl\nstring\nA data URL that encodes an image of the visible area of the captured tab. May be assigned to the 'src' property of an HTML\nimg\nelement for display.\n-\nReturns\n-\nPromise<string>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nconnect()\nchrome.tabs.connect(\ntabId: number,\nconnectInfo?: object,\n)\nConnects to the content script(s) in the specified tab. The runtime.onConnect\nevent is fired in each content script running in the specified tab for the current extension. For more details, see Content Script Messaging.\nParameters\n-\ntabId\nnumber\n-\nconnectInfo\nobject optional\n-\ndocumentId\nstring optional\nChrome 106+Open a port to a specific document identified by\ndocumentId\ninstead of all frames in the tab. -\nframeId\nnumber optional\nOpen a port to a specific frame identified by\nframeId\ninstead of all frames in the tab. -\nname\nstring optional\nIs passed into onConnect for content scripts that are listening for the connection event.\n-\nReturns\n-\nA port that can be used to communicate with the content scripts running in the specified tab. The port's\nruntime.Port\nevent is fired if the tab closes or does not exist.\ncreate()\nchrome.tabs.create(\ncreateProperties: object,\ncallback?: function,\n)\nCreates a new tab.\nParameters\n-\ncreateProperties\nobject\n-\nactive\nboolean optional\nWhether the tab should become the active tab in the window. Does not affect whether the window is focused (see\nwindows.update\n). Defaults totrue\n. -\nindex\nnumber optional\nThe position the tab should take in the window. The provided value is clamped to between zero and the number of tabs in the window.\n-\nopenerTabId\nnumber optional\nThe ID of the tab that opened this tab. If specified, the opener tab must be in the same window as the newly created tab.\n-\npinned\nboolean optional\nWhether the tab should be pinned. Defaults to\nfalse\n-\nselected\nboolean optional\nDeprecatedPlease use active.\nWhether the tab should become the selected tab in the window. Defaults to\ntrue\n-\nurl\nstring optional\nThe URL to initially navigate the tab to. Fully-qualified URLs must include a scheme (i.e., 'http://www.google.com', not 'www.google.com'). Relative URLs are relative to the current page within the extension. Defaults to the New Tab Page.\n-\nwindowId\nnumber optional\nThe window in which to create the new tab. Defaults to the current window.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(tab: Tab) => void\n-\ntab\nThe created tab.\n-\nReturns\n-\nPromise<Tab>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ndetectLanguage()\nchrome.tabs.detectLanguage(\ntabId?: number,\ncallback?: function,\n)\nDetects the primary language of the content in a tab.\nParameters\n-\ntabId\nnumber optional\nDefaults to the active tab of the current window.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(language: string) => void\n-\nlanguage\nstring\nAn ISO language code such as\nen\norfr\n. For a complete list of languages supported by this method, see kLanguageInfoTable. The second to fourth columns are checked and the first non-NULL value is returned, except for Simplified Chinese for whichzh-CN\nis returned. For an unknown/undefined language,und\nis returned.\n-\nReturns\n-\nPromise<string>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ndiscard()\nchrome.tabs.discard(\ntabId?: number,\ncallback?: function,\n)\nDiscards a tab from memory. Discarded tabs are still visible on the tab strip and are reloaded when activated.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to be discarded. If specified, the tab is discarded unless it is active or already discarded. If omitted, the browser discards the least important tab. This can fail if no discardable tabs exist.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(tab?: Tab) => void\n-\ntab\nTab optional\nThe discarded tab, if it was successfully discarded; undefined otherwise.\n-\nReturns\n-\nPromise<Tab | undefined>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nduplicate()\nchrome.tabs.duplicate(\ntabId: number,\ncallback?: function,\n)\nDuplicates a tab.\nParameters\n-\ntabId\nnumber\nThe ID of the tab to duplicate.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(tab?: Tab) => void\nReturns\n-\nPromise<Tab | undefined>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nget()\nchrome.tabs.get(\ntabId: number,\ncallback?: function,\n)\nRetrieves details about the specified tab.\nParameters\n-\ntabId\nnumber\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(tab: Tab) => void\n-\ntab\n-\nReturns\n-\nPromise<Tab>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetCurrent()\nchrome.tabs.getCurrent(\ncallback?: function,\n)\nGets the tab that this script call is being made from. Returns undefined\nif called from a non-tab context (for example, a background page or popup view).\nParameters\nReturns\n-\nPromise<Tab | undefined>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetZoom()\nchrome.tabs.getZoom(\ntabId?: number,\ncallback?: function,\n)\nGets the current zoom factor of a specified tab.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to get the current zoom factor from; defaults to the active tab of the current window.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(zoomFactor: number) => void\n-\nzoomFactor\nnumber\nThe tab's current zoom factor.\n-\nReturns\n-\nPromise<number>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetZoomSettings()\nchrome.tabs.getZoomSettings(\ntabId?: number,\ncallback?: function,\n)\nGets the current zoom settings of a specified tab.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to get the current zoom settings from; defaults to the active tab of the current window.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(zoomSettings: ZoomSettings) => void\n-\nzoomSettings\nThe tab's current zoom settings.\n-\nReturns\n-\nPromise<ZoomSettings>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngoBack()\nchrome.tabs.goBack(\ntabId?: number,\ncallback?: function,\n)\nGo back to the previous page, if one is available.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to navigate back; defaults to the selected tab of the current window.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngoForward()\nchrome.tabs.goForward(\ntabId?: number,\ncallback?: function,\n)\nGo foward to the next page, if one is available.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to navigate forward; defaults to the selected tab of the current window.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngroup()\nchrome.tabs.group(\noptions: object,\ncallback?: function,\n)\nAdds one or more tabs to a specified group, or if no group is specified, adds the given tabs to a newly created group.\nParameters\n-\noptions\nobject\n-\ncreateProperties\nobject optional\nConfigurations for creating a group. Cannot be used if groupId is already specified.\n-\nwindowId\nnumber optional\nThe window of the new group. Defaults to the current window.\n-\n-\ngroupId\nnumber optional\nThe ID of the group to add the tabs to. If not specified, a new group will be created.\n-\ntabIds\nnumber | [number, ...number[]]\nThe tab ID or list of tab IDs to add to the specified group.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(groupId: number) => void\n-\ngroupId\nnumber\nThe ID of the group that the tabs were added to.\n-\nReturns\n-\nPromise<number>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nhighlight()\nchrome.tabs.highlight(\nhighlightInfo: object,\ncallback?: function,\n)\nHighlights the given tabs and focuses on the first of group. Will appear to do nothing if the specified tab is currently active.\nParameters\n-\nhighlightInfo\nobject\n-\ntabs\nnumber | number[]\nOne or more tab indices to highlight.\n-\nwindowId\nnumber optional\nThe window that contains the tabs.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(window: Window) => void\n-\nwindow\nContains details about the window whose tabs were highlighted.\n-\nReturns\n-\nPromise<windows.Window>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nmove()\nchrome.tabs.move(\ntabIds: number | number[],\nmoveProperties: object,\ncallback?: function,\n)\nMoves one or more tabs to a new position within its window, or to a new window. Note that tabs can only be moved to and from normal (window.type === \"normal\") windows.\nParameters\n-\ntabIds\nnumber | number[]\nThe tab ID or list of tab IDs to move.\n-\nmoveProperties\nobject\n-\nindex\nnumber\nThe position to move the window to. Use\n-1\nto place the tab at the end of the window. -\nwindowId\nnumber optional\nDefaults to the window the tab is currently in.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(tabs: Tab | Tab[]) => void\nReturns\n-\nChrome 88+\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nquery()\nchrome.tabs.query(\nqueryInfo: object,\ncallback?: function,\n)\nGets all tabs that have the specified properties, or all tabs if no properties are specified.\nParameters\n-\nqueryInfo\nobject\n-\nactive\nboolean optional\nWhether the tabs are active in their windows.\n-\naudible\nboolean optional\nChrome 45+Whether the tabs are audible.\n-\nautoDiscardable\nboolean optional\nChrome 54+Whether the tabs can be discarded automatically by the browser when resources are low.\n-\ncurrentWindow\nboolean optional\nWhether the tabs are in the current window.\n-\ndiscarded\nboolean optional\nChrome 54+Whether the tabs are discarded. A discarded tab is one whose content has been unloaded from memory, but is still visible in the tab strip. Its content is reloaded the next time it is activated.\n-\nfrozen\nboolean optional\nPendingWhether the tabs are frozen. A frozen tab cannot execute tasks, including event handlers or timers. It is visible in the tab strip and its content is loaded in memory. It is unfrozen on activation.\n-\ngroupId\nnumber optional\nChrome 88+The ID of the group that the tabs are in, or\ntabGroups.TAB_GROUP_ID_NONE\nfor ungrouped tabs. -\nhighlighted\nboolean optional\nWhether the tabs are highlighted.\n-\nindex\nnumber optional\nThe position of the tabs within their windows.\n-\nlastFocusedWindow\nboolean optional\nWhether the tabs are in the last focused window.\n-\nmuted\nboolean optional\nChrome 45+Whether the tabs are muted.\n-\npinned\nboolean optional\nWhether the tabs are pinned.\n-\nstatus\nTabStatus optional\nThe tab loading status.\n-\ntitle\nstring optional\nMatch page titles against a pattern. This property is ignored if the extension does not have the\n\"tabs\"\npermission. -\nurl\nstring | string[] optional\nMatch tabs against one or more URL patterns. Fragment identifiers are not matched. This property is ignored if the extension does not have the\n\"tabs\"\npermission. -\nwindowId\nnumber optional\nThe ID of the parent window, or\nwindows.WINDOW_ID_CURRENT\nfor the current window. -\nwindowType\nWindowType optional\nThe type of window the tabs are in.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: Tab[]) => void\n-\nresult\nTab[]\n-\nReturns\n-\nPromise<Tab[]>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nreload()\nchrome.tabs.reload(\ntabId?: number,\nreloadProperties?: object,\ncallback?: function,\n)\nReload a tab.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to reload; defaults to the selected tab of the current window.\n-\nreloadProperties\nobject optional\n-\nbypassCache\nboolean optional\nWhether to bypass local caching. Defaults to\nfalse\n.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremove()\nchrome.tabs.remove(\ntabIds: number | number[],\ncallback?: function,\n)\nCloses one or more tabs.\nParameters\n-\ntabIds\nnumber | number[]\nThe tab ID or list of tab IDs to close.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsendMessage()\nchrome.tabs.sendMessage(\ntabId: number,\nmessage: any,\noptions?: object,\ncallback?: function,\n)\nSends a single message to the content script(s) in the specified tab, with an optional callback to run when a response is sent back. The runtime.onMessage\nevent is fired in each content script running in the specified tab for the current extension.\nParameters\n-\ntabId\nnumber\n-\nmessage\nany\nThe message to send. This message should be a JSON-ifiable object.\n-\noptions\nobject optional\n-\ncallback\nfunction optional\nChrome 99+The\ncallback\nparameter looks like:(response: any) => void\n-\nresponse\nany\nThe JSON response object sent by the handler of the message. If an error occurs while connecting to the specified tab, the callback is called with no arguments and\nruntime.lastError\nis set to the error message.\n-\nReturns\n-\nPromise<any>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetZoom()\nchrome.tabs.setZoom(\ntabId?: number,\nzoomFactor: number,\ncallback?: function,\n)\nZooms a specified tab.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to zoom; defaults to the active tab of the current window.\n-\nzoomFactor\nnumber\nThe new zoom factor. A value of\n0\nsets the tab to its current default zoom factor. Values greater than0\nspecify a (possibly non-default) zoom factor for the tab. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetZoomSettings()\nchrome.tabs.setZoomSettings(\ntabId?: number,\nzoomSettings: ZoomSettings,\ncallback?: function,\n)\nSets the zoom settings for a specified tab, which define how zoom changes are handled. These settings are reset to defaults upon navigating the tab.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to change the zoom settings for; defaults to the active tab of the current window.\n-\nzoomSettings\nDefines how zoom changes are handled and at what scope.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nungroup()\nchrome.tabs.ungroup(\ntabIds: number | [number, ...number[]],\ncallback?: function,\n)\nRemoves one or more tabs from their respective groups. If any groups become empty, they are deleted.\nParameters\n-\ntabIds\nnumber | [number, ...number[]]\nThe tab ID or list of tab IDs to remove from their respective groups.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdate()\nchrome.tabs.update(\ntabId?: number,\nupdateProperties: object,\ncallback?: function,\n)\nModifies the properties of a tab. Properties that are not specified in updateProperties\nare not modified.\nParameters\n-\ntabId\nnumber optional\nDefaults to the selected tab of the current window.\n-\nupdateProperties\nobject\n-\nactive\nboolean optional\nWhether the tab should be active. Does not affect whether the window is focused (see\nwindows.update\n). -\nautoDiscardable\nboolean optional\nChrome 54+Whether the tab should be discarded automatically by the browser when resources are low.\n-\nhighlighted\nboolean optional\nAdds or removes the tab from the current selection.\n-\nmuted\nboolean optional\nChrome 45+Whether the tab should be muted.\n-\nopenerTabId\nnumber optional\nThe ID of the tab that opened this tab. If specified, the opener tab must be in the same window as this tab.\n-\npinned\nboolean optional\nWhether the tab should be pinned.\n-\nselected\nboolean optional\nDeprecatedPlease use highlighted.\nWhether the tab should be selected.\n-\nurl\nstring optional\nA URL to navigate the tab to. JavaScript URLs are not supported; use\nscripting.executeScript\ninstead.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(tab?: Tab) => void\nReturns\n-\nPromise<Tab | undefined>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonActivated\nchrome.tabs.onActivated.addListener(\ncallback: function,\n)\nFires when the active tab in a window changes. Note that the tab's URL may not be set at the time this event fired, but you can listen to onUpdated events so as to be notified when a URL is set.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(activeInfo: object) => void\n-\nactiveInfo\nobject\n-\ntabId\nnumber\nThe ID of the tab that has become active.\n-\nwindowId\nnumber\nThe ID of the window the active tab changed inside of.\n-\n-\nonAttached\nchrome.tabs.onAttached.addListener(\ncallback: function,\n)\nFired when a tab is attached to a window; for example, because it was moved between windows.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(tabId: number, attachInfo: object) => void\n-\ntabId\nnumber\n-\nattachInfo\nobject\n-\nnewPosition\nnumber\n-\nnewWindowId\nnumber\n-\n-\nonCreated\nchrome.tabs.onCreated.addListener(\ncallback: function,\n)\nFired when a tab is created. Note that the tab's URL and tab group membership may not be set at the time this event is fired, but you can listen to onUpdated events so as to be notified when a URL is set or the tab is added to a tab group.\nonDetached\nchrome.tabs.onDetached.addListener(\ncallback: function,\n)\nFired when a tab is detached from a window; for example, because it was moved between windows.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(tabId: number, detachInfo: object) => void\n-\ntabId\nnumber\n-\ndetachInfo\nobject\n-\noldPosition\nnumber\n-\noldWindowId\nnumber\n-\n-\nonHighlighted\nchrome.tabs.onHighlighted.addListener(\ncallback: function,\n)\nFired when the highlighted or selected tabs in a window changes.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(highlightInfo: object) => void\n-\nhighlightInfo\nobject\n-\ntabIds\nnumber[]\nAll highlighted tabs in the window.\n-\nwindowId\nnumber\nThe window whose tabs changed.\n-\n-\nonMoved\nchrome.tabs.onMoved.addListener(\ncallback: function,\n)\nFired when a tab is moved within a window. Only one move event is fired, representing the tab the user directly moved. Move events are not fired for the other tabs that must move in response to the manually-moved tab. This event is not fired when a tab is moved between windows; for details, see tabs.onDetached\n.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(tabId: number, moveInfo: object) => void\n-\ntabId\nnumber\n-\nmoveInfo\nobject\n-\nfromIndex\nnumber\n-\ntoIndex\nnumber\n-\nwindowId\nnumber\n-\n-\nonRemoved\nchrome.tabs.onRemoved.addListener(\ncallback: function,\n)\nFired when a tab is closed.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(tabId: number, removeInfo: object) => void\n-\ntabId\nnumber\n-\nremoveInfo\nobject\n-\nisWindowClosing\nboolean\nTrue when the tab was closed because its parent window was closed.\n-\nwindowId\nnumber\nThe window whose tab is closed.\n-\n-\nonReplaced\nchrome.tabs.onReplaced.addListener(\ncallback: function,\n)\nFired when a tab is replaced with another tab due to prerendering or instant.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(addedTabId: number, removedTabId: number) => void\n-\naddedTabId\nnumber\n-\nremovedTabId\nnumber\n-\nonUpdated\nchrome.tabs.onUpdated.addListener(\ncallback: function,\n)\nFired when a tab is updated.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(tabId: number, changeInfo: object, tab: Tab) => void\n-\ntabId\nnumber\n-\nchangeInfo\nobject\n-\naudible\nboolean optional\nChrome 45+The tab's new audible state.\n-\nautoDiscardable\nboolean optional\nChrome 54+The tab's new auto-discardable state.\n-\ndiscarded\nboolean optional\nChrome 54+The tab's new discarded state.\n-\nfavIconUrl\nstring optional\nThe tab's new favicon URL.\n-\nfrozen\nboolean optional\nPendingThe tab's new frozen state.\n-\ngroupId\nnumber optional\nChrome 88+The tab's new group.\n-\nmutedInfo\nMutedInfo optional\nChrome 46+The tab's new muted state and the reason for the change.\n-\npinned\nboolean optional\nThe tab's new pinned state.\n-\nstatus\nTabStatus optional\nThe tab's loading status.\n-\ntitle\nstring optional\nChrome 48+The tab's new title.\n-\nurl\nstring optional\nThe tab's URL if it has changed.\n-\n-\ntab\n-\nonZoomChange\nchrome.tabs.onZoomChange.addListener(\ncallback: function,\n)\nFired when a tab is zoomed.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(ZoomChangeInfo: object) => void\n-\nZoomChangeInfo\nobject\n-\nnewZoomFactor\nnumber\n-\noldZoomFactor\nnumber\n-\ntabId\nnumber\n-\nzoomSettings\n-\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/topSites", "title": "chrome.topSites | API | Chrome for Developers", "text": "Description\nUse the chrome.topSites\nAPI to access the top sites (i.e. most visited sites) that are displayed on the new tab page. These do not include shortcuts customized by the user.\nPermissions\ntopSites\nYou must declare the \"topSites\" permission in your extension's manifest to use this API.\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"topSites\",\n],\n...\n}\nExamples\nTo try this API, install the topSites API example from the chrome-extension-samples repository.\nTypes\nMostVisitedURL\nAn object encapsulating a most visited URL, such as the default shortcuts on the new tab page.\nProperties\n-\ntitle\nstring\nThe title of the page\n-\nurl\nstring\nThe most visited URL.\nMethods\nget()\nchrome.topSites.get(\ncallback?: function,\n)\nGets a list of top sites.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(data: MostVisitedURL[]) => void\n-\ndata\n-\nReturns\n-\nPromise<MostVisitedURL[]>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/tts", "title": "chrome.tts | API | Chrome for Developers", "text": "Description\nUse the chrome.tts\nAPI to play synthesized text-to-speech (TTS). See also the related ttsEngine\nAPI, which allows an extension to implement a speech engine.\nChrome provides this capability on Windows (using SAPI 5), Mac OS X, and ChromeOS, using speech synthesis capabilities provided by the operating system. On all platforms, the user can install extensions that register themselves as alternative speech engines.\nPermissions\ntts\nConcepts and usage\nGenerate speech\nCall speak()\nfrom your extension to speak. For example:\nchrome.tts.speak('Hello, world.');\nTo stop speaking immediately, just call stop()\n:\nchrome.tts.stop();\nYou can provide options that control various properties of the speech, such as its rate, pitch, and more. For example:\nchrome.tts.speak('Hello, world.', {'rate': 2.0});\nIt's also a good idea to specify the language so that a synthesizer supporting that language (and regional dialect, if applicable) is chosen.\nchrome.tts.speak('Hello, world.', {'lang': 'en-US', 'rate': 2.0});\nBy default, each call to speak()\ninterrupts any ongoing speech and speaks immediately. To\ndetermine if a call would be interrupting anything, you can call isSpeaking()\n. In addition, you\ncan use the enqueue\noption to cause this utterance to be added to a queue of utterances that will\nbe spoken when the current utterance has finished.\nchrome.tts.speak('Speak this first.');\nchrome.tts.speak(\n'Speak this next, when the first sentence is done.', {'enqueue': true});\nA complete description of all options can be found under tts.speak()\n. Not all speech\nengines will support all options.\nTo catch errors and make sure you're calling speak()\ncorrectly, pass a callback function that\ntakes no arguments. Inside the callback, check runtime.lastError\nto see if there were any\nerrors.\nchrome.tts.speak(\nutterance,\noptions,\nfunction() {\nif (chrome.runtime.lastError) {\nconsole.log('Error: ' + chrome.runtime.lastError.message);\n}\n}\n);\nThe callback returns right away, before the engine has started generating speech. The purpose of the callback is to alert you to syntax errors in your use of the TTS API, not to catch all possible errors that might occur in the process of synthesizing and outputting speech. To catch these errors too, you need to use an event listener, described in the next section.\nListen to events\nTo get more real-time information about the status of synthesized speech, pass an event listener in\nthe options to speak()\n, like this:\nchrome.tts.speak(\nutterance,\n{\nonEvent: function(event) {\nconsole.log('Event ' + event.type + ' at position ' + event.charIndex);\nif (event.type == 'error') {\nconsole.log('Error: ' + event.errorMessage);\n}\n}\n},\ncallback\n);\nEach event includes an event type, the character index of the current speech relative to the utterance, and for error events, an optional error message. The event types are:\n'start'\n: The engine has started speaking the utterance.'word'\n: A word boundary was reached. Useevent.charIndex\nto determine the current speech position.'sentence'\n: A sentence boundary was reached. Useevent.charIndex\nto determine the current speech position.'marker'\n: An SSML marker was reached. Useevent.charIndex\nto determine the current speech position.'end'\n: The engine has finished speaking the utterance.'interrupted'\n: This utterance was interrupted by another call tospeak()\norstop()\nand did not finish.'cancelled'\n: This utterance was queued, but then cancelled by another call tospeak()\norstop()\nand never began to speak at all.'error'\n: An engine-specific error occurred and this utterance cannot be spoken. Checkevent.errorMessage\nfor details.\nFour of the event types\u2014'end'\n, 'interrupted'\n, 'cancelled'\n, and 'error'\n\u2014are final. After\none of those events is received, this utterance will no longer speak and no new events from this\nutterance will be received.\nSome voices may not support all event types, and some voices may not send any events at all. If you\ndon't want to use a voice unless it sends certain events, pass the events you require in the\nrequiredEventTypes\nmember of the options object, or use getVoices()\nto choose a voice that meets\nyour requirements. Both are described in what follows.\nSSML markup\nUtterances used in this API may include markup using the Speech Synthesis Markup Language\n(SSML). If you use SSML, the first argument to speak()\nshould be a complete SSML document with\nan XML header and a top-level <speak>\ntag, not a document fragment.\nFor example:\nchrome.tts.speak(\n'<?xml version=\"1.0\"?>' +\n'<speak>' +\n' The <emphasis>second</emphasis> ' +\n' word of this sentence was emphasized.' +\n'</speak>'\n);\nNot all speech engines will support all SSML tags, and some may not support SSML at all, but all engines are required to ignore any SSML they don't support and to still speak the underlying text.\nChoose a voice\nBy default, Chrome chooses the most appropriate voice for each utterance you want to speak, based on the language. On most Windows, Mac OS X, and ChromeOS systems, speech synthesis provided by the operating system should be able to speak any text in at least one language. Some users may have a variety of voices available, though, from their operating system and from speech engines implemented by other Chrome extensions. In those cases, you can implement custom code to choose the appropriate voice, or to present the user with a list of choices.\nTo get a list of all voices, call getVoices()\nand pass it a function that receives an array of\nTtsVoice\nobjects as its argument:\nchrome.tts.getVoices(\nfunction(voices) {\nfor (var i = 0; i < voices.length; i++) {\nconsole.log('Voice ' + i + ':');\nconsole.log(' name: ' + voices[i].voiceName);\nconsole.log(' lang: ' + voices[i].lang);\nconsole.log(' extension id: ' + voices[i].extensionId);\nconsole.log(' event types: ' + voices[i].eventTypes);\n}\n}\n);\nTypes\nEventType\nEnum\n\"start\" \"end\" \"word\" \"sentence\" \"marker\" \"interrupted\" \"cancelled\" \"error\" \"pause\" \"resume\"\nTtsEvent\nAn event from the TTS engine to communicate the status of an utterance.\nProperties\n-\ncharIndex\nnumber optional\nThe index of the current character in the utterance. For word events, the event fires at the end of one word and before the beginning of the next. The\ncharIndex\nrepresents a point in the text at the beginning of the next word to be spoken. -\nerrorMessage\nstring optional\nThe error description, if the event type is\nerror\n. -\nlength\nnumber optional\nChrome 74+The length of the next part of the utterance. For example, in a\nword\nevent, this is the length of the word which will be spoken next. It will be set to -1 if not set by the speech engine. -\ntype\nThe type can be\nstart\nas soon as speech has started,word\nwhen a word boundary is reached,sentence\nwhen a sentence boundary is reached,marker\nwhen an SSML mark element is reached,end\nwhen the end of the utterance is reached,interrupted\nwhen the utterance is stopped or interrupted before reaching the end,cancelled\nwhen it's removed from the queue before ever being synthesized, orerror\nwhen any other error occurs. When pausing speech, apause\nevent is fired if a particular utterance is paused in the middle, andresume\nif an utterance resumes speech. Note that pause and resume events may not fire if speech is paused in-between utterances.\nTtsOptions\nThe speech options for the TTS engine.\nProperties\n-\ndesiredEventTypes\nstring[] optional\nThe TTS event types that you are interested in listening to. If missing, all event types may be sent.\n-\nenqueue\nboolean optional\nIf true, enqueues this utterance if TTS is already in progress. If false (the default), interrupts any current speech and flushes the speech queue before speaking this new utterance.\n-\nextensionId\nstring optional\nThe extension ID of the speech engine to use, if known.\n-\ngender\nVoiceGender optional\nDeprecated since Chrome 77Gender is deprecated and will be ignored.\nGender of voice for synthesized speech.\n-\nlang\nstring optional\nThe language to be used for synthesis, in the form language-region. Examples: 'en', 'en-US', 'en-GB', 'zh-CN'.\n-\npitch\nnumber optional\nSpeaking pitch between 0 and 2 inclusive, with 0 being lowest and 2 being highest. 1.0 corresponds to a voice's default pitch.\n-\nrate\nnumber optional\nSpeaking rate relative to the default rate for this voice. 1.0 is the default rate, normally around 180 to 220 words per minute. 2.0 is twice as fast, and 0.5 is half as fast. Values below 0.1 or above 10.0 are strictly disallowed, but many voices will constrain the minimum and maximum rates further\u2014for example a particular voice may not actually speak faster than 3 times normal even if you specify a value larger than 3.0.\n-\nrequiredEventTypes\nstring[] optional\nThe TTS event types the voice must support.\n-\nvoiceName\nstring optional\nThe name of the voice to use for synthesis. If empty, uses any available voice.\n-\nvolume\nnumber optional\nSpeaking volume between 0 and 1 inclusive, with 0 being lowest and 1 being highest, with a default of 1.0.\n-\nonEvent\nvoid optional\nThis function is called with events that occur in the process of speaking the utterance.\nThe\nonEvent\nfunction looks like:(event: TtsEvent) => {...}\n-\nevent\nThe update event from the text-to-speech engine indicating the status of this utterance.\n-\nTtsVoice\nA description of a voice available for speech synthesis.\nProperties\n-\neventTypes\nEventType[] optional\nAll of the callback event types that this voice is capable of sending.\n-\nextensionId\nstring optional\nThe ID of the extension providing this voice.\n-\ngender\nVoiceGender optional\nDeprecated since Chrome 70Gender is deprecated and will be ignored.\nThis voice's gender.\n-\nlang\nstring optional\nThe language that this voice supports, in the form language-region. Examples: 'en', 'en-US', 'en-GB', 'zh-CN'.\n-\nremote\nboolean optional\nIf true, the synthesis engine is a remote network resource. It may be higher latency and may incur bandwidth costs.\n-\nvoiceName\nstring optional\nThe name of the voice.\nVoiceGender\nGender is deprecated and is ignored.\nEnum\n\"male\" \"female\"\nMethods\ngetVoices()\nchrome.tts.getVoices(\ncallback?: function,\n)\nGets an array of all available voices.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(voices: TtsVoice[]) => void\n-\nvoices\nTtsVoice[]\nArray of\ntts.TtsVoice\nobjects representing the available voices for speech synthesis.\n-\nReturns\n-\nPromise<TtsVoice[]>\nChrome 101+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nisSpeaking()\nchrome.tts.isSpeaking(\ncallback?: function,\n)\nChecks whether the engine is currently speaking. On Mac OS X, the result is true whenever the system speech engine is speaking, even if the speech wasn't initiated by Chrome.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(speaking: boolean) => void\n-\nspeaking\nboolean\nTrue if speaking, false otherwise.\n-\nReturns\n-\nPromise<boolean>\nChrome 101+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\npause()\nchrome.tts.pause()\nPauses speech synthesis, potentially in the middle of an utterance. A call to resume or stop will un-pause speech.\nresume()\nchrome.tts.resume()\nIf speech was paused, resumes speaking where it left off.\nspeak()\nchrome.tts.speak(\nutterance: string,\noptions?: TtsOptions,\ncallback?: function,\n)\nSpeaks text using a text-to-speech engine.\nParameters\n-\nutterance\nstring\nThe text to speak, either plain text or a complete, well-formed SSML document. Speech engines that do not support SSML will strip away the tags and speak the text. The maximum length of the text is 32,768 characters.\n-\noptions\nTtsOptions optional\nThe speech options.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 101+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nstop()\nchrome.tts.stop()\nStops any current speech and flushes the queue of any pending utterances. In addition, if speech was paused, it will now be un-paused for the next call to speak.\nEvents\nonVoicesChanged\nchrome.tts.onVoicesChanged.addListener(\ncallback: function,\n)\nCalled when the list of tts.TtsVoice\nthat would be returned by getVoices has changed.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/ttsEngine", "title": "chrome.ttsEngine | API | Chrome for Developers", "text": "Description\nUse the chrome.ttsEngine\nAPI to implement a text-to-speech(TTS) engine using an extension. If your extension registers using this API, it will receive events containing an utterance to be spoken and other parameters when any extension or Chrome App uses the tts\nAPI to generate speech. Your extension can then use any available web technology to synthesize and output the speech, and send events back to the calling function to report the status.\nPermissions\nttsEngine\nConcepts and usage\nAn extension can register itself as a speech engine. By doing so, it can intercept some or all calls\nto functions such as tts.speak()\nand tts.stop()\nand provide an alternate implementation.\nExtensions are free to use any available web technology to provide speech, including streaming audio\nfrom a server, HTML5 audio. An extension could even do something different\nwith the utterances, like display closed captions in a popup or send them as log messages to\na remote server.\nTo implement a TTS engine, an extension must declare the \"ttsEngine\" permission and then declare all voices it provides in the extension manifest, like this:\n{\n\"name\": \"My TTS Engine\",\n\"version\": \"1.0\",\n\"permissions\": [\"ttsEngine\"],\n\"tts_engine\": {\n\"voices\": [\n{\n\"voice_name\": \"Alice\",\n\"lang\": \"en-US\",\n\"event_types\": [\"start\", \"marker\", \"end\"]\n},\n{\n\"voice_name\": \"Pat\",\n\"lang\": \"en-US\",\n\"event_types\": [\"end\"]\n}\n]\n},\n\"background\": {\n\"page\": \"background.html\",\n\"persistent\": false\n}\n}\nAn extension can specify any number of voices.\nThe voice_name\nparameter is required. The name should be descriptive enough that it identifies the\nname of the voice and the engine used. In the unlikely event that two extensions register voices\nwith the same name, a client can specify the ID of the extension that should do the synthesis.\nThe lang\nparameter is optional, but highly recommended. Almost always, a voice can synthesize\nspeech in just a single language. When an engine supports more than one language, it can easily\nregister a separate voice for each language. Under rare circumstances where a single voice can\nhandle more than one language, it's easiest to just list two separate voices and handle them using\nthe same logic internally. However, if you want to create a voice that will handle utterances in any\nlanguage, leave out the lang\nparameter from your extension's manifest.\nFinally, the event_types\nparameter is required if the engine can send events to update the client\non the progress of speech synthesis. At a minimum, supporting the 'end'\nevent type to indicate\nwhen speech is finished is highly recommended, otherwise Chrome cannot schedule queued utterances.\nOnce loaded, an extension can replace the list of declared voices by calling\nchrome.ttsEngine.updateVoices\n. (Note that the parameters used in the programatic call to\nupdateVoices\nare in camel case: e.g., voiceName\n, unlike the manifest file which uses\nvoice_name\n.)\nThe possible event types that you can send correspond to the event types that the speak()\nmethod\nreceives:\n'start'\n: The engine has started speaking the utterance.'word'\n: A word boundary was reached. Useevent.charIndex\nto determine the current speech position.'sentence'\n: A sentence boundary was reached. Useevent.charIndex\nto determine the current speech position.'marker'\n: An SSML marker was reached. Useevent.charIndex\nto determine the current speech position.'end'\n: The engine has finished speaking the utterance.'error'\n: An engine-specific error occurred and this utterance cannot be spoken. Pass more information inevent.errorMessage\n.\nThe 'interrupted'\nand 'cancelled'\nevents are not sent by the speech engine; they are generated\nautomatically by Chrome.\nText-to-speech clients can get the voice information from your extension's manifest by calling\ntts.getVoices\n, assuming you've registered speech event listeners as described below.\nHandle speech events\nTo generate speech at the request of clients, your extension must register listeners for both\nonSpeak\nand onStop\n, like this:\nconst speakListener = (utterance, options, sendTtsEvent) => {\nsendTtsEvent({type: 'start', charIndex: 0})\n// (start speaking)\nsendTtsEvent({type: 'end', charIndex: utterance.length})\n};\nconst stopListener = () => {\n// (stop all speech)\n};\nchrome.ttsEngine.onSpeak.addListener(speakListener);\nchrome.ttsEngine.onStop.addListener(stopListener);\nThe decision of whether or not to send a given speech request to an extension is based solely on\nwhether the extension supports the given voice parameters in its manifest and has registered\nlisteners for onSpeak\nand onStop\n. In other words, there's no way for an extension to receive a\nspeech request and dynamically decide whether to handle it.\nTypes\nAudioBuffer\nParameters containing an audio buffer and associated data.\nProperties\n-\naudioBuffer\nArrayBuffer\nThe audio buffer from the text-to-speech engine. It should have length exactly audioStreamOptions.bufferSize and encoded as mono, at audioStreamOptions.sampleRate, and as linear pcm, 32-bit signed float i.e. the Float32Array type in javascript.\n-\ncharIndex\nnumber optional\nThe character index associated with this audio buffer.\n-\nisLastBuffer\nboolean optional\nTrue if this audio buffer is the last for the text being spoken.\nAudioStreamOptions\nContains the audio stream format expected to be produced by an engine.\nProperties\n-\nbufferSize\nnumber\nThe number of samples within an audio buffer.\n-\nsampleRate\nnumber\nThe sample rate expected in an audio buffer.\nLanguageInstallStatus\nThe install status of a voice.\nEnum\n\"notInstalled\" \"installing\" \"installed\" \"failed\"\nLanguageStatus\nInstall status of a language.\nProperties\n-\nerror\nstring optional\nDetail about installation failures. Optionally populated if the language failed to install.\n-\ninstallStatus\nInstallation status.\n-\nlang\nstring\nLanguage string in the form of language code-region code, where the region may be omitted. Examples are en, en-AU, zh-CH.\nLanguageUninstallOptions\nOptions for uninstalling a given language.\nProperties\n-\nuninstallImmediately\nboolean\nTrue if the TTS client wants the language to be immediately uninstalled. The engine may choose whether or when to uninstall the language, based on this parameter and the requestor information. If false, it may use other criteria, such as recent usage, to determine when to uninstall.\nSpeakOptions\nOptions specified to the tts.speak() method.\nProperties\n-\ngender\nVoiceGender optional\nDeprecated since Chrome 92Gender is deprecated and will be ignored.\nGender of voice for synthesized speech.\n-\nlang\nstring optional\nThe language to be used for synthesis, in the form language-region. Examples: 'en', 'en-US', 'en-GB', 'zh-CN'.\n-\npitch\nnumber optional\nSpeaking pitch between 0 and 2 inclusive, with 0 being lowest and 2 being highest. 1.0 corresponds to this voice's default pitch.\n-\nrate\nnumber optional\nSpeaking rate relative to the default rate for this voice. 1.0 is the default rate, normally around 180 to 220 words per minute. 2.0 is twice as fast, and 0.5 is half as fast. This value is guaranteed to be between 0.1 and 10.0, inclusive. When a voice does not support this full range of rates, don't return an error. Instead, clip the rate to the range the voice supports.\n-\nvoiceName\nstring optional\nThe name of the voice to use for synthesis.\n-\nvolume\nnumber optional\nSpeaking volume between 0 and 1 inclusive, with 0 being lowest and 1 being highest, with a default of 1.0.\nTtsClient\nIdentifier for the client requesting status.\nProperties\n-\nid\nstring\nClient making a language management request. For an extension, this is the unique extension ID. For Chrome features, this is the human-readable name of the feature.\n-\nsource\nType of requestor.\nTtsClientSource\nType of requestor.\nEnum\n\"chromefeature\" \"extension\"\nVoiceGender\nGender is deprecated and will be ignored.\nEnum\n\"male\" \"female\"\nMethods\nupdateLanguage()\nchrome.ttsEngine.updateLanguage(\nstatus: LanguageStatus,\n)\nCalled by an engine when a language install is attempted, and when a language is uninstalled. Also called in response to a status request from a client. When a voice is installed or uninstalled, the engine should also call ttsEngine.updateVoices to register the voice.\nParameters\n-\nstatus\nThe install status of the language.\nupdateVoices()\nchrome.ttsEngine.updateVoices(\nvoices: TtsVoice[],\n)\nCalled by an engine to update its list of voices. This list overrides any voices declared in this extension's manifest.\nParameters\n-\nvoices\nTtsVoice[]\nArray of\ntts.TtsVoice\nobjects representing the available voices for speech synthesis.\nEvents\nonInstallLanguageRequest\nchrome.ttsEngine.onInstallLanguageRequest.addListener(\ncallback: function,\n)\nFired when a TTS client requests to install a new language. The engine should attempt to download and install the language, and call ttsEngine.updateLanguage with the result. On success, the engine should also call ttsEngine.updateVoices to register the newly available voices.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(requestor: TtsClient, lang: string) => void\n-\nrequestor\n-\nlang\nstring\n-\nonLanguageStatusRequest\nchrome.ttsEngine.onLanguageStatusRequest.addListener(\ncallback: function,\n)\nFired when a TTS client requests the install status of a language.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(requestor: TtsClient, lang: string) => void\n-\nrequestor\n-\nlang\nstring\n-\nonPause\nchrome.ttsEngine.onPause.addListener(\ncallback: function,\n)\nOptional: if an engine supports the pause event, it should pause the current utterance being spoken, if any, until it receives a resume event or stop event. Note that a stop event should also clear the paused state.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonResume\nchrome.ttsEngine.onResume.addListener(\ncallback: function,\n)\nOptional: if an engine supports the pause event, it should also support the resume event, to continue speaking the current utterance, if any. Note that a stop event should also clear the paused state.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonSpeak\nchrome.ttsEngine.onSpeak.addListener(\ncallback: function,\n)\nCalled when the user makes a call to tts.speak() and one of the voices from this extension's manifest is the first to match the options object.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(utterance: string, options: SpeakOptions, sendTtsEvent: function) => void\n-\nutterance\nstring\n-\noptions\n-\nsendTtsEvent\nfunction\nThe\nsendTtsEvent\nparameter looks like:(event: tts.TtsEvent) => void\n-\nevent\nThe event from the text-to-speech engine indicating the status of this utterance.\n-\n-\nonSpeakWithAudioStream\nchrome.ttsEngine.onSpeakWithAudioStream.addListener(\ncallback: function,\n)\nCalled when the user makes a call to tts.speak() and one of the voices from this extension's manifest is the first to match the options object. Differs from ttsEngine.onSpeak in that Chrome provides audio playback services and handles dispatching tts events.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(utterance: string, options: SpeakOptions, audioStreamOptions: AudioStreamOptions, sendTtsAudio: function, sendError: function) => void\n-\nutterance\nstring\n-\noptions\n-\naudioStreamOptions\n-\nsendTtsAudio\nfunction\nThe\nsendTtsAudio\nparameter looks like:(audioBufferParams: AudioBuffer) => void\n-\naudioBufferParams\nParameters containing an audio buffer and associated data.\n-\n-\nsendError\nfunction\nChrome 94+The\nsendError\nparameter looks like:(errorMessage?: string) => void\n-\nerrorMessage\nstring optional\nA string describing the error.\n-\n-\nonStop\nchrome.ttsEngine.onStop.addListener(\ncallback: function,\n)\nFired when a call is made to tts.stop and this extension may be in the middle of speaking. If an extension receives a call to onStop and speech is already stopped, it should do nothing (not raise an error). If speech is in the paused state, this should cancel the paused state.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonUninstallLanguageRequest\nchrome.ttsEngine.onUninstallLanguageRequest.addListener(\ncallback: function,\n)\nFired when a TTS client indicates a language is no longer needed.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(requestor: TtsClient, lang: string, uninstallOptions: LanguageUninstallOptions) => void\n-\nrequestor\n-\nlang\nstring\n-\nuninstallOptions\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/types", "title": "chrome.types | API | Chrome for Developers", "text": "Description\nThe chrome.types\nAPI contains type declarations for Chrome.\nChrome settings\nThe ChromeSetting\ntype provides a common set of functions (get()\n, set()\n, and clear()\n)\nas well as an event publisher (onChange\n) for settings of the Chrome browser. The proxy settings\nexamples demonstrate how these functions are intended to be used.\nScope and lifecycle\nChrome distinguishes between three different scopes of browser settings:\nregular\n- Settings set in the\nregular\nscope apply to regular browser windows and are inherited by incognito windows if they are not overwritten. These settings are stored to disk and remain in place until they are cleared by the governing extension, or the governing extension is disabled or uninstalled. incognito_persistent\n- Settings set in the\nincognito_persistent\nscope apply only to incognito windows. For these, they overrideregular\nsettings. These settings are stored to disk and remain in place until they are cleared by the governing extension, or the governing extension is disabled or uninstalled. incognito_session_only\n- Settings set in the\nincognito_session_only\nscope apply only to incognito windows. For these, they overrideregular\nandincognito_persistent\nsettings. These settings are not stored to disk and are cleared when the last incognito window is closed. They can only be set when at least one incognito window is open.\nPrecedence\nChrome manages settings on different layers. The following list describes the layers that may influence the effective settings, in increasing order of precedence.\n- System settings provided by the operating system\n- Command-line parameters\n- Settings provided by extensions\n- Policies\nAs the list implies, policies might overrule any changes that you specify with your extension. You\ncan use the get()\nfunction to determine whether your extension is capable of providing a setting\nor whether this setting would be overridden.\nAs discussed previously, Chrome allows using different settings for regular windows and incognito windows. The following example illustrates the behavior. Assume that no policy overrides the settings and that an extension can set settings for regular windows (R) and settings for incognito windows (I).\n- If only (R) is set, these settings are effective for both regular and incognito windows.\n- If only (I) is set, these settings are effective for only incognito windows. Regular windows use the settings determined by the lower layers (command-line options and system settings).\n- If both (R) and (I) are set, the respective settings are used for regular and incognito windows.\nIf two or more extensions want to set the same setting to different values, the extension installed most recently takes precedence over the other extensions. If the most recently installed extension sets only (I), the settings of regular windows can be defined by previously installed extensions.\nThe effective value of a setting is the one that results from considering the precedence rules. It is used by Chrome.\nTypes\nChromeSetting\nAn interface that allows access to a Chrome browser setting. See accessibilityFeatures\nfor an example.\nProperties\n-\nonChange\nEvent<functionvoidvoid>\nFired after the setting changes.\nThe\nonChange.addListener\nfunction looks like:(callback: function) => {...}\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nincognitoSpecific\nboolean optional\nWhether the value that has changed is specific to the incognito session. This property will only be present if the user has enabled the extension in incognito mode.\n-\nlevelOfControl\nThe level of control of the setting.\n-\nvalue\nT\nThe value of the setting after the change.\n-\n-\n-\n-\nclear\nvoid\nPromiseClears the setting, restoring any default value.\nThe\nclear\nfunction looks like:(details: object, callback?: function) => {...}\n-\ndetails\nobject\nWhich setting to clear.\n-\nscope\nChromeSettingScope optional\nWhere to clear the setting (default: regular).\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\n-\nreturns\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\nget\nvoid\nPromiseGets the value of a setting.\nThe\nget\nfunction looks like:(details: object, callback?: function) => {...}\n-\ndetails\nobject\nWhich setting to consider.\n-\nincognito\nboolean optional\nWhether to return the value that applies to the incognito session (default false).\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\nDetails of the currently effective value.\n-\nincognitoSpecific\nboolean optional\nWhether the effective value is specific to the incognito session. This property will only be present if the\nincognito\nproperty in thedetails\nparameter ofget()\nwas true. -\nlevelOfControl\nThe level of control of the setting.\n-\nvalue\nT\nThe value of the setting.\n-\n-\n-\nreturns\nPromise<object>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\nset\nvoid\nPromiseSets the value of a setting.\nThe\nset\nfunction looks like:(details: object, callback?: function) => {...}\n-\ndetails\nobject\nWhich setting to change.\n-\nscope\nChromeSettingScope optional\nWhere to set the setting (default: regular).\n-\nvalue\nT\nThe value of the setting. Note that every setting has a specific value type, which is described together with the setting. An extension should not set a value of a different type.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\n-\nreturns\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\nChromeSettingScope\nThe scope of the ChromeSetting. One of\nregular\n: setting for the regular profile (which is inherited by the incognito profile if not overridden elsewhere),regular\\_only\n: setting for the regular profile only (not inherited by the incognito profile),incognito\\_persistent\n: setting for the incognito profile that survives browser restarts (overrides regular preferences),incognito\\_session\\_only\n: setting for the incognito profile that can only be set during an incognito session and is deleted when the incognito session ends (overrides regular and incognito_persistent preferences).\nEnum\n\"regular\" \"regular_only\" \"incognito_persistent\" \"incognito_session_only\"\nLevelOfControl\nOne of\nnot\\_controllable\n: cannot be controlled by any extensioncontrolled\\_by\\_other\\_extensions\n: controlled by extensions with higher precedencecontrollable\\_by\\_this\\_extension\n: can be controlled by this extensioncontrolled\\_by\\_this\\_extension\n: controlled by this extension\nEnum\n\"not_controllable\" \"controlled_by_other_extensions\" \"controllable_by_this_extension\" \"controlled_by_this_extension\""},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/userScripts", "title": "chrome.userScripts | API | Chrome for Developers", "text": "Description\nUse the userScripts\nAPI to execute user scripts in the User Scripts context.\nPermissions\nuserScripts\nTo use the chrome.userScripts\nAPI, add the \"userScripts\"\npermission to your manifest.json and \"host_permissions\"\nfor sites you want to run scripts on.\n{\n\"name\": \"User script test extension\",\n\"manifest_version\": 3,\n\"minimum_chrome_version\": \"120\",\n\"permissions\": [\n\"userScripts\"\n],\n\"host_permissions\": [\n\"*://example.com/*\"\n]\n}\nAvailability\nConcepts and usage\nA user script is a bit of code injected into a web page to modify its appearance or behavior. Scripts are either created by users or downloaded from a script repository or a user script extension.\nDeveloper mode for extension users\nAs an extension developer, you already have Developer mode enabled in your installation of Chrome. For user script extensions, your users will also need to enable developer mode. Here are instructions that you can copy and paste into your own documentation.\n- Go to the Extensions page by entering\nchrome://extensions\nin a new tab. (By designchrome://\nURLs are not linkable.) Enable Developer Mode by clicking the toggle switch next to Developer mode.\nExtensions page (chrome://extensions)\nYou can determine if developer mode is enabled by checking whether chrome.userScripts\nthrows an error. For example:\nfunction isUserScriptsAvailable() {\ntry {\n// Property access which throws if developer mode is not enabled.\nchrome.userScripts;\nreturn true;\n} catch {\n// Not available.\nreturn false;\n}\n}\nWork in isolated worlds\nBoth user and content scripts can run in an isolated world or in the main world. An isolated world is an execution environment that isn't accessible to a host page or other extensions. This lets a user script change its JavaScript environment without affecting the host page or other extensions' user and content scripts. Conversely, user scripts (and content scripts) are not visible to the host page or the user and content scripts of other extensions. Scripts running in the main world are accessible to host pages and other extensions and are visible to host pages and to other extensions. To select the world, pass \"USER_SCRIPT\"\nor \"MAIN\"\nwhen calling userScripts.register()\n.\nTo configure a content security policy for the USER_SCRIPT\nworld, call userScripts.configureWorld()\n:\nchrome.userScripts.configureWorld({\ncsp: \"script-src 'self'\"\n});\nMessaging\nLike content scripts and offscreen documents, user scripts communicate with other parts of an extension using messaging (meaning they can call runtime.sendMessage()\nand runtime.connect()\nas any other part of an extension would). However, they're received using dedicated event handlers (meaning, they don't use onMessage\nor onConnect\n). These handlers are called runtime.onUserScriptMessage\nand runtime.onUserScriptConnect\n. Dedicated handlers make it easier to identify messages from user scripts, which are a less-trusted context.\nBefore sending a message, you must call configureWorld()\nwith the messaging\nargument set to true\n. Note that both the csp\nand messaging\narguments can be passed at the same time.\nchrome.userScripts.configureWorld({\nmessaging: true\n});\nExtension updates\nUser scripts are cleared when an extension updates. You can add them back by running code in the runtime.onInstalled\nevent handler in the extension service worker. Respond only to the \"update\"\nreason passed to the event callback.\nExample\nThis example is from the userScript sample in our samples repository.\nRegister a script\nThe following example shows a basic call to register()\n. The first argument is an array of objects defining the scripts to be registered. There are more options than are shown here.\nchrome.userScripts.register([{\nid: 'test',\nmatches: ['*://*/*'],\njs: [{code: 'alert(\"Hi!\")'}]\n}]);\nTypes\nExecutionWorld\nThe JavaScript world for a user script to execute within.\nEnum\n\"MAIN\" \"USER_SCRIPT\"\nSpecifies the execution environment of the DOM, which is the execution environment shared with the host page's JavaScript.\nSpecifies the execution environment that is specific to user scripts and is exempt from the page's CSP.\nRegisteredUserScript\nProperties\n-\nallFrames\nboolean optional\nIf true, it will inject into all frames, even if the frame is not the top-most frame in the tab. Each frame is checked independently for URL requirements; it will not inject into child frames if the URL requirements are not met. Defaults to false, meaning that only the top frame is matched.\n-\nexcludeGlobs\nstring[] optional\nSpecifies wildcard patterns for pages this user script will NOT be injected into.\n-\nexcludeMatches\nstring[] optional\nExcludes pages that this user script would otherwise be injected into. See Match Patterns for more details on the syntax of these strings.\n-\nid\nstring\nThe ID of the user script specified in the API call. This property must not start with a '_' as it's reserved as a prefix for generated script IDs.\n-\nincludeGlobs\nstring[] optional\nSpecifies wildcard patterns for pages this user script will be injected into.\n-\njs\nScriptSource[] optional\nThe list of ScriptSource objects defining sources of scripts to be injected into matching pages. This property must be specified for ${ref:register}, and when specified it must be a non-empty array.\n-\nmatches\nstring[] optional\nSpecifies which pages this user script will be injected into. See Match Patterns for more details on the syntax of these strings. This property must be specified for ${ref:register}.\n-\nrunAt\nRunAt optional\nSpecifies when JavaScript files are injected into the web page. The preferred and default value is\ndocument_idle\n. -\nworld\nExecutionWorld optional\nThe JavaScript execution environment to run the script in. The default is\n`USER_SCRIPT`\n. -\nworldId\nstring optional\nPendingIf specified, specifies a specific user script world ID to execute in. Only valid if\nworld\nis omitted or isUSER_SCRIPT\n. If omitted, the script will execute in the default user script world. Values with leading underscores (_\n) are reserved.\nScriptSource\nProperties\n-\ncode\nstring optional\nA string containing the JavaScript code to inject. Exactly one of\nfile\norcode\nmust be specified. -\nfile\nstring optional\nThe path of the JavaScript file to inject relative to the extension's root directory. Exactly one of\nfile\norcode\nmust be specified.\nUserScriptFilter\nProperties\n-\nids\nstring[] optional\ngetScripts\nonly returns scripts with the IDs specified in this list.\nWorldProperties\nProperties\n-\ncsp\nstring optional\nSpecifies the world csp. The default is the\n`ISOLATED`\nworld csp. -\nmessaging\nboolean optional\nSpecifies whether messaging APIs are exposed. The default is\nfalse\n. -\nworldId\nstring optional\nPendingSpecifies the ID of the specific user script world to update. If not provided, updates the properties of the default user script world. Values with leading underscores (\n_\n) are reserved.\nMethods\nconfigureWorld()\nchrome.userScripts.configureWorld(\nproperties: WorldProperties,\ncallback?: function,\n)\nConfigures the `USER_SCRIPT`\nexecution environment.\nParameters\n-\nproperties\nContains the user script world configuration.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetScripts()\nchrome.userScripts.getScripts(\nfilter?: UserScriptFilter,\ncallback?: function,\n)\nReturns all dynamically-registered user scripts for this extension.\nParameters\n-\nfilter\nUserScriptFilter optional\nIf specified, this method returns only the user scripts that match it.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(scripts: RegisteredUserScript[]) => void\n-\nscripts\n-\nReturns\n-\nPromise<RegisteredUserScript[]>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetWorldConfigurations()\nchrome.userScripts.getWorldConfigurations(\ncallback?: function,\n)\nRetrieves all registered world configurations.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(worlds: WorldProperties[]) => void\n-\nworlds\n-\nReturns\n-\nPromise<WorldProperties[]>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nregister()\nchrome.userScripts.register(\nscripts: RegisteredUserScript[],\ncallback?: function,\n)\nRegisters one or more user scripts for this extension.\nParameters\n-\nscripts\nContains a list of user scripts to be registered.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nresetWorldConfiguration()\nchrome.userScripts.resetWorldConfiguration(\nworldId?: string,\ncallback?: function,\n)\nResets the configuration for a user script world. Any scripts that inject into the world with the specified ID will use the default world configuration.\nParameters\n-\nworldId\nstring optional\nThe ID of the user script world to reset. If omitted, resets the default world's configuration.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nunregister()\nchrome.userScripts.unregister(\nfilter?: UserScriptFilter,\ncallback?: function,\n)\nUnregisters all dynamically-registered user scripts for this extension.\nParameters\n-\nfilter\nUserScriptFilter optional\nIf specified, this method unregisters only the user scripts that match it.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdate()\nchrome.userScripts.update(\nscripts: RegisteredUserScript[],\ncallback?: function,\n)\nUpdates one or more user scripts for this extension.\nParameters\n-\nscripts\nContains a list of user scripts to be updated. A property is only updated for the existing script if it is specified in this object. If there are errors during script parsing/file validation, or if the IDs specified do not correspond to a fully registered script, then no scripts are updated.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/vpnProvider", "title": "chrome.vpnProvider | API | Chrome for Developers", "text": "Description\nUse the chrome.vpnProvider\nAPI to implement a VPN client.\nPermissions\nvpnProvider\nAvailability\nConcepts and usage\nTypical usage of chrome.vpnProvider\nis as follows:\nCreate VPN configurations by calling\ncreateConfig()\n. A VPN configuration is a persistent entry shown to the user in a ChromeOS UI. The user can select a VPN configuration from a list and connect to it or disconnect from it.Add listeners to the\nonPlatformMessage\n,onPacketReceived\n, andonConfigRemoved\nevents.When the user connects to the VPN configuration,\nonPlatformMessage\nwill be received with the message\"connected\"\n. The period between the\"connected\"\nand\"disconnected\"\nmessages is called a \"VPN session\". In this time period, the extension that receives the message is said to own the VPN session.Initiate connection to the VPN server and start the VPN client.\nSet the Parameters of the connection by calling\nsetParameters()\n.Notify the connection state as\n\"connected\"\nby callingnotifyConnectionStateChanged()\n.When the steps previous are completed without errors, a virtual tunnel is created to the network stack of ChromeOS. IP packets can be sent through the tunnel by calling\nsendPacket()\nand any packets originating on the ChromeOS device will be received using theonPacketReceived\nevent handler.When the user disconnects from the VPN configuration,\nonPlatformMessage\nwill be fired with the message\"disconnected\"\n.If the VPN configuration is no longer necessary, it can be destroyed by calling\ndestroyConfig()\n.\nTypes\nParameters\nProperties\n-\naddress\nstring\nIP address for the VPN interface in CIDR notation. IPv4 is currently the only supported mode.\n-\nbroadcastAddress\nstring optional\nBroadcast address for the VPN interface. (default: deduced from IP address and mask)\n-\ndnsServers\nstring[]\nA list of IPs for the DNS servers.\n-\ndomainSearch\nstring[] optional\nA list of search domains. (default: no search domain)\n-\nexclusionList\nstring[]\nExclude network traffic to the list of IP blocks in CIDR notation from the tunnel. This can be used to bypass traffic to and from the VPN server. When many rules match a destination, the rule with the longest matching prefix wins. Entries that correspond to the same CIDR block are treated as duplicates. Such duplicates in the collated (exclusionList + inclusionList) list are eliminated and the exact duplicate entry that will be eliminated is undefined.\n-\ninclusionList\nstring[]\nInclude network traffic to the list of IP blocks in CIDR notation to the tunnel. This parameter can be used to set up a split tunnel. By default no traffic is directed to the tunnel. Adding the entry \"0.0.0.0/0\" to this list gets all the user traffic redirected to the tunnel. When many rules match a destination, the rule with the longest matching prefix wins. Entries that correspond to the same CIDR block are treated as duplicates. Such duplicates in the collated (exclusionList + inclusionList) list are eliminated and the exact duplicate entry that will be eliminated is undefined.\n-\nmtu\nstring optional\nMTU setting for the VPN interface. (default: 1500 bytes)\n-\nreconnect\nstring optional\nChrome 51+Whether or not the VPN extension implements auto-reconnection.\nIf true, the\nlinkDown\n,linkUp\n,linkChanged\n,suspend\n, andresume\nplatform messages will be used to signal the respective events. If false, the system will forcibly disconnect the VPN if the network topology changes, and the user will need to reconnect manually. (default: false)This property is new in Chrome 51; it will generate an exception in earlier versions. try/catch can be used to conditionally enable the feature based on browser support.\nPlatformMessage\nThe enum is used by the platform to notify the client of the VPN session status.\nEnum\n\"connected\" \"disconnected\" \"error\" \"linkDown\" \"linkUp\" \"linkChanged\" \"suspend\" \"resume\"\nIndicates that the VPN configuration connected.\nIndicates that the VPN configuration disconnected.\nIndicates that an error occurred in VPN connection, for example a timeout. A description of the error is given as the error argument to onPlatformMessage.\nIndicates that the default physical network connection is down.\nIndicates that the default physical network connection is back up.\nIndicates that the default physical network connection changed, e.g. wifi->mobile.\nIndicates that the OS is preparing to suspend, so the VPN should drop its connection. The extension is not guaranteed to receive this event prior to suspending.\nIndicates that the OS has resumed and the user has logged back in, so the VPN should try to reconnect.\nUIEvent\nThe enum is used by the platform to indicate the event that triggered onUIEvent\n.\nEnum\n\"showAddDialog\" \"showConfigureDialog\"\nRequests that the VPN client show the add configuration dialog box to the user.\nRequests that the VPN client show the configuration settings dialog box to the user.\nVpnConnectionState\nThe enum is used by the VPN client to inform the platform of its current state. This helps provide meaningful messages to the user.\nEnum\n\"connected\" \"failure\"\nSpecifies that VPN connection was successful.\nSpecifies that VPN connection has failed.\nMethods\ncreateConfig()\nchrome.vpnProvider.createConfig(\nname: string,\ncallback?: function,\n)\nCreates a new VPN configuration that persists across multiple login sessions of the user.\nParameters\n-\nname\nstring\nThe name of the VPN configuration.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(id: string) => void\n-\nid\nstring\nA unique ID for the created configuration, or\nundefined\non failure.\n-\nReturns\n-\nPromise<string>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ndestroyConfig()\nchrome.vpnProvider.destroyConfig(\nid: string,\ncallback?: function,\n)\nDestroys a VPN configuration created by the extension.\nParameters\n-\nid\nstring\nID of the VPN configuration to destroy.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nnotifyConnectionStateChanged()\nchrome.vpnProvider.notifyConnectionStateChanged(\nstate: VpnConnectionState,\ncallback?: function,\n)\nNotifies the VPN session state to the platform. This will succeed only when the VPN session is owned by the extension.\nParameters\n-\nstate\nThe VPN session state of the VPN client.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsendPacket()\nchrome.vpnProvider.sendPacket(\ndata: ArrayBuffer,\ncallback?: function,\n)\nSends an IP packet through the tunnel created for the VPN session. This will succeed only when the VPN session is owned by the extension.\nParameters\n-\ndata\nArrayBuffer\nThe IP packet to be sent to the platform.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetParameters()\nchrome.vpnProvider.setParameters(\nparameters: Parameters,\ncallback?: function,\n)\nSets the parameters for the VPN session. This should be called immediately after \"connected\"\nis received from the platform. This will succeed only when the VPN session is owned by the extension.\nParameters\n-\nparameters\nThe parameters for the VPN session.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonConfigCreated\nchrome.vpnProvider.onConfigCreated.addListener(\ncallback: function,\n)\nTriggered when a configuration is created by the platform for the extension.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(id: string, name: string, data: object) => void\n-\nid\nstring\n-\nname\nstring\n-\ndata\nobject\n-\nonConfigRemoved\nchrome.vpnProvider.onConfigRemoved.addListener(\ncallback: function,\n)\nTriggered when a configuration created by the extension is removed by the platform.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(id: string) => void\n-\nid\nstring\n-\nonPacketReceived\nchrome.vpnProvider.onPacketReceived.addListener(\ncallback: function,\n)\nTriggered when an IP packet is received via the tunnel for the VPN session owned by the extension.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(data: ArrayBuffer) => void\n-\ndata\nArrayBuffer\n-\nonPlatformMessage\nchrome.vpnProvider.onPlatformMessage.addListener(\ncallback: function,\n)\nTriggered when a message is received from the platform for a VPN configuration owned by the extension.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(id: string, message: PlatformMessage, error: string) => void\n-\nid\nstring\n-\nmessage\n-\nerror\nstring\n-\nonUIEvent\nchrome.vpnProvider.onUIEvent.addListener(\ncallback: function,\n)\nTriggered when there is a UI event for the extension. UI events are signals from the platform that indicate to the app that a UI dialog needs to be shown to the user."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/wallpaper", "title": "chrome.wallpaper | API | Chrome for Developers", "text": "Description\nUse the chrome.wallpaper\nAPI to change the ChromeOS wallpaper.\nPermissions\nwallpaper\nYou must declare the \"wallpaper\" permission in the app's manifest to use the wallpaper API. For example:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"wallpaper\"\n],\n...\n}\nAvailability\nExamples\nFor example, to set the wallpaper as the image at\nhttps://example.com/a_file.png\n, you can call chrome.wallpaper.setWallpaper\nthis way:\nchrome.wallpaper.setWallpaper(\n{\n'url': 'https://example.com/a_file.jpg',\n'layout': 'CENTER_CROPPED',\n'filename': 'test_wallpaper'\n},\nfunction() {}\n);\nTypes\nWallpaperLayout\nThe supported wallpaper layouts.\nEnum\n\"STRETCH\" \"CENTER\" \"CENTER_CROPPED\"\nMethods\nsetWallpaper()\nchrome.wallpaper.setWallpaper(\ndetails: object,\ncallback?: function,\n)\nSets wallpaper to the image at url or wallpaperData with the specified layout\nParameters\n-\ndetails\nobject\n-\ndata\nArrayBuffer optional\nThe jpeg or png encoded wallpaper image as an ArrayBuffer.\n-\nfilename\nstring\nThe file name of the saved wallpaper.\n-\nlayout\nThe supported wallpaper layouts.\n-\nthumbnail\nboolean optional\nTrue if a 128x60 thumbnail should be generated. Layout and ratio are not supported yet.\n-\nurl\nstring optional\nThe URL of the wallpaper to be set (can be relative).\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(thumbnail?: ArrayBuffer) => void\n-\nthumbnail\nArrayBuffer optional\nThe jpeg encoded wallpaper thumbnail. It is generated by resizing the wallpaper to 128x60.\n-\nReturns\n-\nPromise<ArrayBuffer | undefined>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/webAuthenticationProxy", "title": "chrome.webAuthenticationProxy | API | Chrome for Developers", "text": "Description\nThe chrome.webAuthenticationProxy\nAPI lets remote desktop software running on a remote host intercept Web Authentication API (WebAuthn) requests in order to handle them on a local client.\nPermissions\nwebAuthenticationProxy\nAvailability\nTypes\nCreateRequest\nProperties\n-\nrequestDetailsJson\nstring\nThe\nPublicKeyCredentialCreationOptions\npassed tonavigator.credentials.create()\n, serialized as a JSON string. The serialization format is compatible withPublicKeyCredential.parseCreationOptionsFromJSON()\n. -\nrequestId\nnumber\nAn opaque identifier for the request.\nCreateResponseDetails\nProperties\n-\nerror\nDOMExceptionDetails optional\nThe\nDOMException\nyielded by the remote request, if any. -\nrequestId\nnumber\nThe\nrequestId\nof theCreateRequest\n. -\nresponseJson\nstring optional\nThe\nPublicKeyCredential\n, yielded by the remote request, if any, serialized as a JSON string by calling href=\"https://w3c.github.io/webauthn/#dom-publickeycredential-tojson\">PublicKeyCredential.toJSON()\n.\nDOMExceptionDetails\nProperties\n-\nmessage\nstring\n-\nname\nstring\nGetRequest\nProperties\n-\nrequestDetailsJson\nstring\nThe\nPublicKeyCredentialRequestOptions\npassed tonavigator.credentials.get()\n, serialized as a JSON string. The serialization format is compatible withPublicKeyCredential.parseRequestOptionsFromJSON()\n. -\nrequestId\nnumber\nAn opaque identifier for the request.\nGetResponseDetails\nProperties\n-\nerror\nDOMExceptionDetails optional\nThe\nDOMException\nyielded by the remote request, if any. -\nrequestId\nnumber\nThe\nrequestId\nof theCreateRequest\n. -\nresponseJson\nstring optional\nThe\nPublicKeyCredential\n, yielded by the remote request, if any, serialized as a JSON string by calling href=\"https://w3c.github.io/webauthn/#dom-publickeycredential-tojson\">PublicKeyCredential.toJSON()\n.\nIsUvpaaRequest\nProperties\n-\nrequestId\nnumber\nAn opaque identifier for the request.\nIsUvpaaResponseDetails\nProperties\n-\nisUvpaa\nboolean\n-\nrequestId\nnumber\nMethods\nattach()\nchrome.webAuthenticationProxy.attach(\ncallback?: function,\n)\nMakes this extension the active Web Authentication API request proxy.\nRemote desktop extensions typically call this method after detecting attachment of a remote session to this host. Once this method returns without error, regular processing of WebAuthn requests is suspended, and events from this extension API are raised.\nThis method fails with an error if a different extension is already attached.\nThe attached extension must call detach()\nonce the remote desktop session has ended in order to resume regular WebAuthn request processing. Extensions automatically become detached if they are unloaded.\nRefer to the onRemoteSessionStateChange\nevent for signaling a change of remote session attachment from a native application to to the (possibly suspended) extension.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(error?: string) => void\n-\nerror\nstring optional\n-\nReturns\n-\nPromise<string | undefined>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ncompleteCreateRequest()\nchrome.webAuthenticationProxy.completeCreateRequest(\ndetails: CreateResponseDetails,\ncallback?: function,\n)\nReports the result of a navigator.credentials.create()\ncall. The extension must call this for every onCreateRequest\nevent it has received, unless the request was canceled (in which case, an onRequestCanceled\nevent is fired).\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ncompleteGetRequest()\nchrome.webAuthenticationProxy.completeGetRequest(\ndetails: GetResponseDetails,\ncallback?: function,\n)\nReports the result of a navigator.credentials.get()\ncall. The extension must call this for every onGetRequest\nevent it has received, unless the request was canceled (in which case, an onRequestCanceled\nevent is fired).\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ncompleteIsUvpaaRequest()\nchrome.webAuthenticationProxy.completeIsUvpaaRequest(\ndetails: IsUvpaaResponseDetails,\ncallback?: function,\n)\nReports the result of a PublicKeyCredential.isUserVerifyingPlatformAuthenticator()\ncall. The extension must call this for every onIsUvpaaRequest\nevent it has received.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ndetach()\nchrome.webAuthenticationProxy.detach(\ncallback?: function,\n)\nRemoves this extension from being the active Web Authentication API request proxy.\nThis method is typically called when the extension detects that a remote desktop session was terminated. Once this method returns, the extension ceases to be the active Web Authentication API request proxy.\nRefer to the onRemoteSessionStateChange\nevent for signaling a change of remote session attachment from a native application to to the (possibly suspended) extension.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(error?: string) => void\n-\nerror\nstring optional\n-\nReturns\n-\nPromise<string | undefined>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonCreateRequest\nchrome.webAuthenticationProxy.onCreateRequest.addListener(\ncallback: function,\n)\nFires when a WebAuthn navigator.credentials.create()\ncall occurs. The extension must supply a response by calling completeCreateRequest()\nwith the requestId\nfrom requestInfo\n.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(requestInfo: CreateRequest) => void\n-\nrequestInfo\n-\nonGetRequest\nchrome.webAuthenticationProxy.onGetRequest.addListener(\ncallback: function,\n)\nFires when a WebAuthn navigator.credentials.get() call occurs. The extension must supply a response by calling completeGetRequest()\nwith the requestId\nfrom requestInfo\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(requestInfo: GetRequest) => void\n-\nrequestInfo\n-\nonIsUvpaaRequest\nchrome.webAuthenticationProxy.onIsUvpaaRequest.addListener(\ncallback: function,\n)\nFires when a PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()\ncall occurs. The extension must supply a response by calling completeIsUvpaaRequest()\nwith the requestId\nfrom requestInfo\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(requestInfo: IsUvpaaRequest) => void\n-\nrequestInfo\n-\nonRemoteSessionStateChange\nchrome.webAuthenticationProxy.onRemoteSessionStateChange.addListener(\ncallback: function,\n)\nA native application associated with this extension can cause this event to be fired by writing to a file with a name equal to the extension's ID in a directory named WebAuthenticationProxyRemoteSessionStateChange\ninside the default user data directory\nThe contents of the file should be empty. I.e., it is not necessary to change the contents of the file in order to trigger this event.\nThe native host application may use this event mechanism to signal a possible remote session state change (i.e. from detached to attached, or vice versa) while the extension service worker is possibly suspended. In the handler for this event, the extension can call the attach()\nor detach()\nAPI methods accordingly.\nThe event listener must be registered synchronously at load time.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonRequestCanceled\nchrome.webAuthenticationProxy.onRequestCanceled.addListener(\ncallback: function,\n)\nFires when a onCreateRequest\nor onGetRequest\nevent is canceled (because the WebAuthn request was aborted by the caller, or because it timed out). When receiving this event, the extension should cancel processing of the corresponding request on the client side. Extensions cannot complete a request once it has been canceled.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(requestId: number) => void\n-\nrequestId\nnumber\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/webNavigation", "title": "chrome.webNavigation | API | Chrome for Developers", "text": "Description\nUse the chrome.webNavigation\nAPI to receive notifications about the status of navigation requests in-flight.\nPermissions\nwebNavigation\nAll chrome.webNavigation\nmethods and events require you to declare the \"webNavigation\"\npermission\nin the extension manifest. For example:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"webNavigation\"\n],\n...\n}\nConcepts and usage\nEvent order\nFor a navigation that is successfully completed, events are fired in the following order:\nonBeforeNavigate -> onCommitted -> [onDOMContentLoaded] -> onCompleted\nAny error that occurs during the process results in an onErrorOccurred\nevent. For a specific\nnavigation, there are no further events fired after onErrorOccurred\n.\nIf a navigating frame contains subframes, its onCommitted\nis fired before any of its children's\nonBeforeNavigate\n; while onCompleted\nis fired after all of its children's onCompleted\n.\nIf the reference fragment of a frame is changed, a onReferenceFragmentUpdated\nevent is fired. This\nevent can fire any time after onDOMContentLoaded\n, even after onCompleted\n.\nIf the history API is used to modify the state of a frame (e.g. using history.pushState()\n, a\nonHistoryStateUpdated\nevent is fired. This event can fire any time after onDOMContentLoaded\n.\nIf a navigation restored a page from the Back Forward Cache, the onDOMContentLoaded\nevent\nwon't fire. The event is not fired because the content has already completed load when the page\nwas first visited.\nIf a navigation was triggered using Chrome Instant or Instant Pages, a completely loaded\npage is swapped into the current tab. In that case, an onTabReplaced\nevent is fired.\nRelation to webRequest events\nThere is no defined ordering between events of the webRequest API and the events of the webNavigation API. It is possible that webRequest events are still received for frames that already started a new navigation, or that a navigation only proceeds after the network resources are already fully loaded.\nIn general, the webNavigation events are closely related to the navigation state that is displayed in the UI, while the webRequest events correspond to the state of the network stack which is generally opaque to the user.\nTab IDs\nNot all navigating tabs correspond to actual tabs in Chrome's UI, for example, a tab that is being\npre-rendered. Such tabs are not accessible using the tabs API nor can you request information\nabout them by calling webNavigation.getFrame()\nor webNavigation.getAllFrames()\n. Once such a tab\nis swapped in, an onTabReplaced\nevent is fired and they become accessible through these APIs.\nTimestamps\nIt's important to note that some technical oddities in the OS's handling of distinct Chrome\nprocesses can cause the clock to be skewed between the browser itself and extension processes. That\nmeans that the timeStamp\nproperty of the WebNavigation\nevent timeStamp\nproperty is only guaranteed\nto be internally consistent. Comparing one event to another event will give you the correct offset\nbetween them, but comparing them to the current time inside the extension (using (new Date()).getTime()\n,\nfor instance) might give unexpected results.\nFrame IDs\nFrames within a tab can be identified by a frame ID. The frame ID of the main frame is always 0, the ID of child frames is a positive number. Once a document is constructed in a frame, its frame ID remains constant during the lifetime of the document. As of Chrome 49, this ID is also constant for the lifetime of the frame (across multiple navigations).\nDue to the multi-process nature of Chrome, a tab might use different processes to render the source\nand destination of a web page. Therefore, if a navigation takes place in a new process, you might\nreceive events both from the new and the old page until the new navigation is committed (i.e. the\nonCommitted\nevent is sent for the new main frame). In other words, it is possible to have more\nthan one pending sequence of webNavigation events with the same frameId\n. The sequences can be\ndistinguished by the processId\nkey.\nAlso note that during a provisional load the process might be switched several times. This happens\nwhen the load is redirected to a different site. In this case, you will receive repeated\nonBeforeNavigate\nand onErrorOccurred\nevents, until you receive the final onCommitted\nevent.\nAnother concept that is problematic with extensions is the lifecycle of the frame. A frame hosts a document (which is associated with a committed URL). The document can change (say by navigating) but the frameId won't, and so it is difficult to associate that something happened in a specific document with just frameIds. We are introducing a concept of a documentId which is a unique identifier per document. If a frame is navigated and opens a new document the identifier will change. This field is useful for determining when pages change their lifecycle state (between prerender/active/cached) because it remains the same.\nTransition types and qualifiers\nThe webNavigation\nonCommitted\nevent has a transitionType\nand a transitionQualifiers\nproperty. The transition type is the same as used in the history API describing how the\nbrowser navigated to this particular URL. In addition, several transition qualifiers can be\nreturned that further define the navigation.\nThe following transition qualifiers exist:\n| Transition qualifier | Description |\n|---|---|\n| \"client_redirect\" | One or more redirects caused by JavaScript or meta refresh tags on the page happened during the navigation. |\n| \"server_redirect\" | One or more redirects caused by HTTP headers sent from the server happened during the navigation. |\n| \"forward_back\" | The user used the Forward or Back button to initiate the navigation. |\n| \"from_address_bar\" | The user initiated the navigation from the address bar (aka Omnibox). |\nExamples\nTo try this API, install the webNavigation API example from the chrome-extension-samples repository.\nTypes\nTransitionQualifier\nEnum\n\"client_redirect\" \"server_redirect\" \"forward_back\" \"from_address_bar\"\nTransitionType\nCause of the navigation. The same transition types as defined in the history API are used. These are the same transition types as defined in the history API except with \"start_page\"\nin place of \"auto_toplevel\"\n(for backwards compatibility).\nEnum\n\"link\" \"typed\" \"auto_bookmark\" \"auto_subframe\" \"manual_subframe\" \"generated\" \"start_page\" \"form_submit\" \"reload\" \"keyword\" \"keyword_generated\"\nMethods\ngetAllFrames()\nchrome.webNavigation.getAllFrames(\ndetails: object,\ncallback?: function,\n)\nRetrieves information about all frames of a given tab.\nParameters\n-\ndetails\nobject\nInformation about the tab to retrieve all frames from.\n-\ntabId\nnumber\nThe ID of the tab.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(details?: object[]) => void\n-\ndetails\nobject[] optional\nA list of frames in the given tab, null if the specified tab ID is invalid.\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nerrorOccurred\nboolean\nTrue if the last navigation in this frame was interrupted by an error, i.e. the onErrorOccurred event fired.\n-\nframeId\nnumber\nThe ID of the frame. 0 indicates that this is the main frame; a positive value indicates the ID of a subframe.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nThe ID of the parent frame, or\n-1\nif this is the main frame. -\nprocessId\nnumber\nThe ID of the process that runs the renderer for this frame.\n-\nurl\nstring\nThe URL currently associated with this frame.\n-\n-\nReturns\n-\nPromise<object[] | undefined>\nChrome 93+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetFrame()\nchrome.webNavigation.getFrame(\ndetails: object,\ncallback?: function,\n)\nRetrieves information about the given frame. A frame refers to an <iframe> or a <frame> of a web page and is identified by a tab ID and a frame ID.\nParameters\n-\ndetails\nobject\nInformation about the frame to retrieve information about.\n-\ndocumentId\nstring optional\nChrome 106+The UUID of the document. If the frameId and/or tabId are provided they will be validated to match the document found by provided document ID.\n-\nframeId\nnumber optional\nThe ID of the frame in the given tab.\n-\nprocessId\nnumber optional\nDeprecated since Chrome 49Frames are now uniquely identified by their tab ID and frame ID; the process ID is no longer needed and therefore ignored.\nThe ID of the process that runs the renderer for this tab.\n-\ntabId\nnumber optional\nThe ID of the tab in which the frame is.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(details?: object) => void\n-\ndetails\nobject optional\nInformation about the requested frame, null if the specified frame ID and/or tab ID are invalid.\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nerrorOccurred\nboolean\nTrue if the last navigation in this frame was interrupted by an error, i.e. the onErrorOccurred event fired.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nThe ID of the parent frame, or\n-1\nif this is the main frame. -\nurl\nstring\nThe URL currently associated with this frame, if the frame identified by the frameId existed at one point in the given tab. The fact that an URL is associated with a given frameId does not imply that the corresponding frame still exists.\n-\n-\nReturns\n-\nPromise<object | undefined>\nChrome 93+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonBeforeNavigate\nchrome.webNavigation.onBeforeNavigate.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when a navigation is about to occur.\nParameters\n-\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\nobject\n-\nChrome 106+\nThe lifecycle the document is in.\n-\nnumber\n0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique for a given tab and process.\n-\nChrome 106+\nThe type of frame the navigation occurred in.\n-\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nnumber\nThe ID of the parent frame, or\n-1\nif this is the main frame. -\nnumber\nDeprecated since Chrome 50The processId is no longer set for this event, since the process which will render the resulting document is not known until onCommit.\nThe value of -1.\n-\nnumber\nThe ID of the tab in which the navigation is about to occur.\n-\nnumber\nThe time when the browser was about to start the navigation, in milliseconds since the epoch.\n-\nstring\n-\n-\n-\nobject optional\n-\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonCommitted\nchrome.webNavigation.onCommitted.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when a navigation is committed. The document (and the resources it refers to, such as images and subframes) might still be downloading, but at least part of the document has been received from the server and the browser has decided to switch to the new document.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\n0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique within a tab.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nChrome 74+The ID of the parent frame, or\n-1\nif this is the main frame. -\nprocessId\nnumber\nThe ID of the process that runs the renderer for this frame.\n-\ntabId\nnumber\nThe ID of the tab in which the navigation occurs.\n-\ntimeStamp\nnumber\nThe time when the navigation was committed, in milliseconds since the epoch.\n-\ntransitionQualifiers\nA list of transition qualifiers.\n-\ntransitionType\nCause of the navigation.\n-\nurl\nstring\n-\n-\n-\nfilters\nobject optional\n-\nurl\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonCompleted\nchrome.webNavigation.onCompleted.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when a document, including the resources it refers to, is completely loaded and initialized.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\n0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique within a tab.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nChrome 74+The ID of the parent frame, or\n-1\nif this is the main frame. -\nprocessId\nnumber\nThe ID of the process that runs the renderer for this frame.\n-\ntabId\nnumber\nThe ID of the tab in which the navigation occurs.\n-\ntimeStamp\nnumber\nThe time when the document finished loading, in milliseconds since the epoch.\n-\nurl\nstring\n-\n-\n-\nfilters\nobject optional\n-\nurl\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonCreatedNavigationTarget\nchrome.webNavigation.onCreatedNavigationTarget.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when a new window, or a new tab in an existing window, is created to host a navigation.\nParameters\n-\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\nobject\n-\nnumber\nThe ID of the frame with sourceTabId in which the navigation is triggered. 0 indicates the main frame.\n-\nnumber\nThe ID of the process that runs the renderer for the source frame.\n-\nnumber\nThe ID of the tab in which the navigation is triggered.\n-\nnumber\nThe ID of the tab in which the url is opened\n-\nnumber\nThe time when the browser was about to create a new view, in milliseconds since the epoch.\n-\nstring\nThe URL to be opened in the new window.\n-\n-\n-\nobject optional\n-\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonDOMContentLoaded\nchrome.webNavigation.onDOMContentLoaded.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when the page's DOM is fully constructed, but the referenced resources may not finish loading.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\n0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique within a tab.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nChrome 74+The ID of the parent frame, or\n-1\nif this is the main frame. -\nprocessId\nnumber\nThe ID of the process that runs the renderer for this frame.\n-\ntabId\nnumber\nThe ID of the tab in which the navigation occurs.\n-\ntimeStamp\nnumber\nThe time when the page's DOM was fully constructed, in milliseconds since the epoch.\n-\nurl\nstring\n-\n-\n-\nfilters\nobject optional\n-\nurl\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonErrorOccurred\nchrome.webNavigation.onErrorOccurred.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when an error occurs and the navigation is aborted. This can happen if either a network error occurred, or the user aborted the navigation.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nerror\nstring\nThe error description.\n-\nframeId\nnumber\n0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique within a tab.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nChrome 74+The ID of the parent frame, or\n-1\nif this is the main frame. -\nprocessId\nnumber\nDeprecated since Chrome 50The processId is no longer set for this event.\nThe value of -1.\n-\ntabId\nnumber\nThe ID of the tab in which the navigation occurs.\n-\ntimeStamp\nnumber\nThe time when the error occurred, in milliseconds since the epoch.\n-\nurl\nstring\n-\n-\n-\nfilters\nobject optional\n-\nurl\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonHistoryStateUpdated\nchrome.webNavigation.onHistoryStateUpdated.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when the frame's history was updated to a new URL. All future events for that frame will use the updated URL.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\n0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique within a tab.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nChrome 74+The ID of the parent frame, or\n-1\nif this is the main frame. -\nprocessId\nnumber\nThe ID of the process that runs the renderer for this frame.\n-\ntabId\nnumber\nThe ID of the tab in which the navigation occurs.\n-\ntimeStamp\nnumber\nThe time when the navigation was committed, in milliseconds since the epoch.\n-\ntransitionQualifiers\nA list of transition qualifiers.\n-\ntransitionType\nCause of the navigation.\n-\nurl\nstring\n-\n-\n-\nfilters\nobject optional\n-\nurl\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonReferenceFragmentUpdated\nchrome.webNavigation.onReferenceFragmentUpdated.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when the reference fragment of a frame was updated. All future events for that frame will use the updated URL.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\n0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique within a tab.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nChrome 74+The ID of the parent frame, or\n-1\nif this is the main frame. -\nprocessId\nnumber\nThe ID of the process that runs the renderer for this frame.\n-\ntabId\nnumber\nThe ID of the tab in which the navigation occurs.\n-\ntimeStamp\nnumber\nThe time when the navigation was committed, in milliseconds since the epoch.\n-\ntransitionQualifiers\nA list of transition qualifiers.\n-\ntransitionType\nCause of the navigation.\n-\nurl\nstring\n-\n-\n-\nfilters\nobject optional\n-\nurl\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonTabReplaced\nchrome.webNavigation.onTabReplaced.addListener(\ncallback: function,\n)\nFired when the contents of the tab is replaced by a different (usually previously pre-rendered) tab.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nreplacedTabId\nnumber\nThe ID of the tab that was replaced.\n-\ntabId\nnumber\nThe ID of the tab that replaced the old tab.\n-\ntimeStamp\nnumber\nThe time when the replacement happened, in milliseconds since the epoch.\n-\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/webRequest", "title": "chrome.webRequest | API | Chrome for Developers", "text": "Description\nUse the chrome.webRequest\nAPI to observe and analyze traffic and to intercept, block, or modify requests in-flight.\nPermissions\nwebRequest\nYou must declare the \"webRequest\"\npermission in the extension manifest to use the web request\nAPI, along with the necessary host permissions. To intercept a sub-resource request, the\nextension must have access to both the requested URL and its initiator. For example:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"webRequest\"\n],\n\"host_permissions\": [\n\"*://*.google.com/*\"\n],\n...\n}\nwebRequestBlocking\nRequired to register blocking event handlers. As of Manifest V3, this is only available to policy installed extensions.\nwebRequestAuthProvider\nRequired to use the onAuthRequired\nmethod. See\nHandling authentication.\nConcepts and usage\nLife cycle of requests\nThe web request API defines a set of events that follow the life cycle of a web request. You can use these events to observe and analyze traffic. Certain synchronous events will allow you to intercept, block, or modify a request.\nThe event life cycle for successful requests is illustrated here, followed by event definitions:\nonBeforeRequest\n(optionally synchronous)- Fires when a request is about to occur. This event is sent before any TCP connection is made and can be used to cancel or redirect requests.\nonBeforeSendHeaders\n(optionally synchronous)- Fires when a request is about to occur and the initial headers have been prepared. The event is\nintended to allow extensions to add, modify, and delete request headers (*). The\nonBeforeSendHeaders\nevent is passed to all subscribers, so different subscribers may attempt to modify the request; see the Implementation details section for how this is handled. This event can be used to cancel the request. onSendHeaders\n- Fires after all extensions have had a chance to modify the request headers, and presents the final (*) version. The event is triggered before the headers are sent to the network. This event is informational and handled asynchronously. It does not allow modifying or cancelling the request.\nonHeadersReceived\n(optionally synchronous)- Fires each time that an HTTP(S) response header is received. Due to redirects and authentication requests this can happen multiple times per request. This event is intended to allow extensions to add, modify, and delete response headers, such as incoming Content-Type headers. The caching directives are processed before this event is triggered, so modifying headers such as Cache-Control has no influence on the browser's cache. It also allows you to cancel or redirect the request.\nonAuthRequired\n(optionally synchronous)- Fires when a request requires authentication of the user. This event can be handled synchronously to provide authentication credentials. Note that extensions may provide invalid credentials. Take care not to enter an infinite loop by repeatedly providing invalid credentials. This can also be used to cancel the request.\nonBeforeRedirect\n- Fires when a redirect is about to be executed. A redirection can be triggered by an HTTP response code or by an extension. This event is informational and handled asynchronously. It does not allow you to modify or cancel the request.\nonResponseStarted\n- Fires when the first byte of the response body is received. For HTTP requests, this means that the status line and response headers are available. This event is informational and handled asynchronously. It does not allow modifying or canceling the request.\nonCompleted\n- Fires when a request has been processed successfully.\nonErrorOccurred\n- Fires when a request could not be processed successfully.\nThe web request API guarantees that for each request, either onCompleted\nor onErrorOccurred\nis\nfired as the final event with one exception: If a request is redirected to a data://\nURL,\nonBeforeRedirect\nis the last reported event.\n* Note that the web request API presents an abstraction of the network stack to the extension. Internally, one URL request can be split into several HTTP requests (for example, to fetch individual byte ranges from a large file) or can be handled by the network stack without communicating with the network. For this reason, the API does not provide the final HTTP headers that are sent to the network. For example, all headers that are related to caching are invisible to the extension.\nThe following headers are currently not provided to the onBeforeSendHeaders\nevent. This list\nis not guaranteed to be complete or stable.\n- Authorization\n- Cache-Control\n- Connection\n- Content-Length\n- Host\n- If-Modified-Since\n- If-None-Match\n- If-Range\n- Partial-Data\n- Pragma\n- Proxy-Authorization\n- Proxy-Connection\n- Transfer-Encoding\nStarting from Chrome 79, request header modifications affect Cross-Origin Resource Sharing (CORS)\nchecks. If modified headers for cross-origin requests do not meet the criteria, it will result in\nsending a CORS preflight to ask the server if such headers can be accepted. If you really need to\nmodify headers in a way to violate the CORS protocol, you need to specify 'extraHeaders'\nin\nopt_extraInfoSpec\n. On the other hand, response header modifications do not work to deceive CORS\nchecks. If you need to deceive the CORS protocol, you also need to specify 'extraHeaders'\nfor the\nresponse modifications.\nStarting from Chrome 79, the webRequest API does not intercept CORS preflight requests and\nresponses by default. A CORS preflight for a request URL is visible to an extension if there is a\nlistener with 'extraHeaders'\nspecified in opt_extraInfoSpec\nfor the request URL.\nonBeforeRequest\ncan also take 'extraHeaders'\nfrom Chrome 79.\nStarting from Chrome 79, the following request header is not provided and cannot be modified or\nremoved without specifying 'extraHeaders'\nin opt_extraInfoSpec\n:\n- Origin\nStarting from Chrome 72, if you need to modify responses before Cross Origin Read Blocking\n(CORB) can block the response, you need to specify 'extraHeaders'\nin opt_extraInfoSpec\n.\nStarting from Chrome 72, the following request headers are not provided and cannot be modified\nor removed without specifying 'extraHeaders'\nin opt_extraInfoSpec\n:\n- Accept-Language\n- Accept-Encoding\n- Referer\n- Cookie\nStarting from Chrome 72, the Set-Cookie\nresponse header is not provided and cannot be modified\nor removed without specifying 'extraHeaders'\nin opt_extraInfoSpec\n.\nStarting from Chrome 89, the X-Frame-Options\nresponse header cannot be effectively modified\nor removed without specifying 'extraHeaders'\nin opt_extraInfoSpec\n.\nThe webRequest API only exposes requests that the extension has permission to see, given its host\npermissions. Moreover, only the following schemes are accessible: http://\n, https://\n,\nftp://\n, file://\n, ws://\n(since Chrome 58), wss://\n(since Chrome 58), urn:\n(since Chrome 91), or\nchrome-extension://\n. In addition, even certain requests with URLs using one of the above schemes\nare hidden. These include chrome-extension://other_extension_id\nwhere other_extension_id\nis not\nthe ID of the extension to handle the request, https://www.google.com/chrome\n, and other sensitive\nrequests core to browser functionality. Also synchronous XMLHttpRequests from your extension are\nhidden from blocking event handlers in order to prevent deadlocks. Note that for some of the\nsupported schemes the set of available events might be limited due to the nature of the\ncorresponding protocol. For example, for the file: scheme, only onBeforeRequest\n,\nonResponseStarted\n, onCompleted\n, and onErrorOccurred\nmay be dispatched.\nStarting from Chrome 58, the webRequest API supports intercepting the WebSocket handshake request. Since the handshake is done by means of an HTTP upgrade request, its flow fits into HTTP-oriented webRequest model. Note that the API does not intercept:\n- Individual messages sent over an established WebSocket connection.\n- WebSocket closing connection.\nRedirects are not supported for WebSocket requests.\nStarting from Chrome 72, an extension will be able to intercept a request only if it has host permissions to both the requested URL and the request initiator.\nStarting from Chrome 96, the webRequest API supports intercepting the WebTransport over HTTP/3 handshake request. Since the handshake is done by means of an HTTP CONNECT request, its flow fits into HTTP-oriented webRequest model. Note that:\n- Once the session is established, extensions cannot observe or intervene in the session via the webRequest API.\n- Modifying HTTP request headers in\nonBeforeSendHeaders\nis ignored. - Redirects and authentications are not supported in WebTransport over HTTP/3.\nRequest IDs\nEach request is identified by a request ID. This ID is unique within a browser session and the context of an extension. It remains constant during the life cycle of a request and can be used to match events for the same request. Note that several HTTP requests are mapped to one web request in case of HTTP redirection or HTTP authentication.\nRegistering event listeners\nTo register an event listener for a web request, you use a variation on the usual addListener()\nfunction. In addition to specifying a callback function, you have to specify a filter argument, and you may specify an optional extra info argument.\nThe three arguments to the web request API's addListener()\nhave the following definitions:\nvar callback = function(details) {...};\nvar filter = {...};\nvar opt_extraInfoSpec = [...];\nHere's an example of listening for the onBeforeRequest\nevent:\nchrome.webRequest.onBeforeRequest.addListener(\ncallback, filter, opt_extraInfoSpec);\nEach addListener()\ncall takes a mandatory callback function as the first parameter. This callback\nfunction is passed a dictionary containing information about the current URL request. The\ninformation in this dictionary depends on the specific event type as well as the content of\nopt_extraInfoSpec\n.\nIf the optional opt_extraInfoSpec\narray contains the string 'blocking'\n(only allowed for\nspecific events), the callback function is handled synchronously. That means that the request is\nblocked until the callback function returns. In this case, the callback can return a\nwebRequest.BlockingResponse\nthat determines the further life cycle of the request. Depending\non the context, this response allows canceling or redirecting a request (onBeforeRequest\n),\ncanceling a request or modifying headers (onBeforeSendHeaders\n, onHeadersReceived\n), and\ncanceling a request or providing authentication credentials (onAuthRequired\n).\nIf the optional opt_extraInfoSpec\narray contains the string 'asyncBlocking'\ninstead (only\nallowed for onAuthRequired\n), the extension can generate the webRequest.BlockingResponse\nasynchronously.\nThe webRequest.RequestFilter\nfilter\nallows limiting the requests for which events are\ntriggered in various dimensions:\n- URLs\n- URL patterns such as\n*://www.google.com/foo*bar\n. - Types\n- Request types such as\nmain_frame\n(a document that is loaded for a top-level frame),sub_frame\n(a document that is loaded for an embedded frame), andimage\n(an image on a web site). SeewebRequest.RequestFilter\n. - Tab ID\n- The identifier for one tab.\n- Window ID\n- The identifier for a window.\nDepending on the event type, you can specify strings in opt_extraInfoSpec\nto ask for additional\ninformation about the request. This is used to provide detailed information on request's data only\nif explicitly requested.\nHandling authentication\nTo handle requests for HTTP authentication, add the \"webRequestAuthProvider\"\npermission to your manifest file:\n{\n\"permissions\": [\n\"webRequest\",\n\"webRequestAuthProvider\"\n]\n}\nNote that this permission is not required for a policy installed extension with\nthe \"webRequestBlocking\"\npermission.\nTo provide credentials synchronously:\nchrome.webRequest.onAuthRequired.addListener((details) => {\nreturn {\nauthCredentials: {\nusername: 'guest',\npassword: 'guest'\n}\n};\n},\n{ urls: ['https://httpbin.org/basic-auth/guest/guest'] },\n['blocking']\n);\nTo provide credentials asynchronously:\nchrome.webRequest.onAuthRequired.addListener((details, callback) => {\ncallback({\nauthCredentials: {\nusername: 'guest',\npassword: 'guest'\n}\n});\n},\n{ urls: ['https://httpbin.org/basic-auth/guest/guest'] },\n['asyncBlocking']\n);\nImplementation details\nSeveral implementation details can be important to understand when developing an extension that uses the web request API:\nweb_accessible_resources\nWhen an extension uses webRequest APIs to redirect a public resource request to a resource that is not web accessible, it is blocked and will result in an error. The above holds true even if the resource that is not web accessible is owned by the redirecting extension. To declare resources for use with declarativeWebRequest APIs, the \"web_accessible_resources\"\narray must be declared and populated in the manifest as documented here.\nConflict resolution\nIn the current implementation of the web request API, a request is considered canceled if at\nleast one extension instructs to cancel the request. If an extension cancels a request, all\nextensions are notified by an onErrorOccurred\nevent. Only one extension can redirect a\nrequest or modify a header at a time. If more than one extension attempts to modify the request, the\nmost recently installed extension wins, and all others are ignored. An extension is not notified if\nits instruction to modify or redirect has been ignored.\nCaching\nChrome employs two caches\u2014an on-disk cache and a very fast in-memory cache. The lifetime of an\nin-memory cache is attached to the lifetime of a render process, which roughly corresponds to a tab.\nRequests that are answered from the in-memory cache are invisible to the web request API. If a\nrequest handler changes its behavior (for example, the behavior according to which requests are\nblocked), a simple page refresh might not respect this changed behavior. To ensure the behavior\nchange goes through, call handlerBehaviorChanged()\nto flush the in-memory cache. But don't do it\noften; flushing the cache is a very expensive operation. You don't need to call\nhandlerBehaviorChanged()\nafter registering or unregistering an event listener.\nTimestamps\nThe timestamp\nproperty of web request events is only guaranteed to be internally consistent.\nComparing one event to another event will give you the correct offset between them, but comparing\nthem to the current time inside the extension (via (new Date()).getTime()\n, for instance) might\ngive unexpected results.\nError handling\nIf you try to register an event with invalid arguments, then a JavaScript error will be thrown, and the event handler will not be registered. If an error is thrown while an event is handled or if an event handler returns an invalid blocking response, an error message is logged to your extension's console, and the handler is ignored for that request.\nExamples\nThe following example illustrates how to block all requests to www.evil.com\n:\nchrome.webRequest.onBeforeRequest.addListener(\nfunction(details) {\nreturn {cancel: details.url.indexOf(\"://www.evil.com/\") != -1};\n},\n{urls: [\"<all_urls>\"]},\n[\"blocking\"]\n);\nAs this function uses a blocking event handler, it requires the \"webRequest\"\nas well as the\n\"webRequestBlocking\"\npermission in the manifest file.\nThe following example achieves the same goal in a more efficient way because requests that are not\ntargeted to www.evil.com\ndo not need to be passed to the extension:\nchrome.webRequest.onBeforeRequest.addListener(\nfunction(details) { return {cancel: true}; },\n{urls: [\"*://www.evil.com/*\"]},\n[\"blocking\"]\n);\nThe following example illustrates how to delete the User-Agent header from all requests:\nchrome.webRequest.onBeforeSendHeaders.addListener(\nfunction(details) {\nfor (var i = 0; i < details.requestHeaders.length; ++i) {\nif (details.requestHeaders[i].name === 'User-Agent') {\ndetails.requestHeaders.splice(i, 1);\nbreak;\n}\n}\nreturn {requestHeaders: details.requestHeaders};\n},\n{urls: [\"<all_urls>\"]},\n[\"blocking\", \"requestHeaders\"]\n);\nTo try the chrome.webRequest\nAPI,\ninstall the webRequest sample from the chrome-extension-samples\nrepository.\nTypes\nBlockingResponse\nReturns value for event handlers that have the 'blocking' extraInfoSpec applied. Allows the event handler to modify network requests.\nProperties\n-\nauthCredentials\nobject optional\nOnly used as a response to the onAuthRequired event. If set, the request is made using the supplied credentials.\n-\npassword\nstring\n-\nusername\nstring\n-\n-\ncancel\nboolean optional\nIf true, the request is cancelled. This prevents the request from being sent. This can be used as a response to the onBeforeRequest, onBeforeSendHeaders, onHeadersReceived and onAuthRequired events.\n-\nredirectUrl\nstring optional\nOnly used as a response to the onBeforeRequest and onHeadersReceived events. If set, the original request is prevented from being sent/completed and is instead redirected to the given URL. Redirections to non-HTTP schemes such as\ndata:\nare allowed. Redirects initiated by a redirect action use the original request method for the redirect, with one exception: If the redirect is initiated at the onHeadersReceived stage, then the redirect will be issued using the GET method. Redirects from URLs withws://\nandwss://\nschemes are ignored. -\nrequestHeaders\nHttpHeaders optional\nOnly used as a response to the onBeforeSendHeaders event. If set, the request is made with these request headers instead.\n-\nresponseHeaders\nHttpHeaders optional\nOnly used as a response to the onHeadersReceived event. If set, the server is assumed to have responded with these response headers instead. Only return\nresponseHeaders\nif you really want to modify the headers in order to limit the number of conflicts (only one extension may modifyresponseHeaders\nfor each request).\nFormDataItem\nContains data passed within form data. For urlencoded form it is stored as string if data is utf-8 string and as ArrayBuffer otherwise. For form-data it is ArrayBuffer. If form-data represents uploading file, it is string with filename, if the filename is provided.\nEnum\nArrayBuffer string\nHttpHeaders\nAn array of HTTP headers. Each header is represented as a dictionary containing the keys name\nand either value\nor binaryValue\n.\nType\nobject[]\nProperties\n-\nbinaryValue\nnumber[] optional\nValue of the HTTP header if it cannot be represented by UTF-8, stored as individual byte values (0..255).\n-\nname\nstring\nName of the HTTP header.\n-\nvalue\nstring optional\nValue of the HTTP header if it can be represented by UTF-8.\nIgnoredActionType\nEnum\n\"redirect\" \"request_headers\" \"response_headers\" \"auth_credentials\"\nOnAuthRequiredOptions\nEnum\n\"responseHeaders\" \"blocking\" \"asyncBlocking\" \"extraHeaders\"\nSpecifies that the response headers should be included in the event.\nSpecifies the request is blocked until the callback function returns.\nSpecifies that the callback function is handled asynchronously.\nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\nOnBeforeRedirectOptions\nEnum\n\"responseHeaders\" \"extraHeaders\"\nSpecifies that the response headers should be included in the event.\nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\nOnBeforeRequestOptions\nEnum\n\"blocking\" \"requestBody\" \"extraHeaders\"\nSpecifies the request is blocked until the callback function returns.\nSpecifies that the request body should be included in the event.\nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\nOnBeforeSendHeadersOptions\nEnum\n\"requestHeaders\" \"blocking\" \"extraHeaders\"\nSpecifies that the request header should be included in the event.\nSpecifies the request is blocked until the callback function returns.\nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\nOnCompletedOptions\nEnum\n\"responseHeaders\" \"extraHeaders\"\nSpecifies that the response headers should be included in the event.\nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\nOnErrorOccurredOptions\nValue\n\"extraHeaders\"\nOnHeadersReceivedOptions\nEnum\n\"blocking\" \"responseHeaders\" \"extraHeaders\"\nSpecifies the request is blocked until the callback function returns.\nSpecifies that the response headers should be included in the event.\nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\nOnResponseStartedOptions\nEnum\n\"responseHeaders\" \"extraHeaders\"\nSpecifies that the response headers should be included in the event.\nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\nOnSendHeadersOptions\nEnum\n\"requestHeaders\" \"extraHeaders\"\nSpecifies that the request header should be included in the event.\nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\nRequestFilter\nAn object describing filters to apply to webRequest events.\nProperties\n-\ntabId\nnumber optional\n-\ntypes\nResourceType[] optional\nA list of request types. Requests that cannot match any of the types will be filtered out.\n-\nurls\nstring[]\nA list of URLs or URL patterns. Requests that cannot match any of the URLs will be filtered out.\n-\nwindowId\nnumber optional\nResourceType\nEnum\n\"main_frame\" \"sub_frame\" \"stylesheet\" \"script\" \"image\" \"font\" \"object\" \"xmlhttprequest\" \"ping\" \"csp_report\" \"media\" \"websocket\" \"webbundle\" \"other\"\nSpecifies the resource as the main frame.\nSpecifies the resource as a sub frame.\nSpecifies the resource as a stylesheet.\nSpecifies the resource as a script.\nSpecifies the resource as an image.\nSpecifies the resource as a font.\nSpecifies the resource as an object.\nSpecifies the resource as an XMLHttpRequest.\nSpecifies the resource as a ping.\nSpecifies the resource as a Content Security Policy (CSP) report.\nSpecifies the resource as a media object.\nSpecifies the resource as a WebSocket.\nSpecifies the resource as a WebBundle.\nSpecifies the resource as a type not included in the listed types.\nUploadData\nContains data uploaded in a URL request.\nProperties\n-\nbytes\nany optional\nAn ArrayBuffer with a copy of the data.\n-\nfile\nstring optional\nA string with the file's path and name.\nProperties\nMAX_HANDLER_BEHAVIOR_CHANGED_CALLS_PER_10_MINUTES\nThe maximum number of times that handlerBehaviorChanged\ncan be called per 10 minute sustained interval. handlerBehaviorChanged\nis an expensive function call that shouldn't be called often.\nValue\n20\nMethods\nhandlerBehaviorChanged()\nchrome.webRequest.handlerBehaviorChanged(\ncallback?: function,\n)\nNeeds to be called when the behavior of the webRequest handlers has changed to prevent incorrect handling due to caching. This function call is expensive. Don't call it often.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 116+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonActionIgnored\nchrome.webRequest.onActionIgnored.addListener(\ncallback: function,\n)\nFired when an extension's proposed modification to a network request is ignored. This happens in case of conflicts with other extensions.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\naction\nThe proposed action which was ignored.\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request.\n-\n-\nonAuthRequired\nchrome.webRequest.onAuthRequired.addListener(\ncallback: function,\nfilter: RequestFilter,\nextraInfoSpec?: OnAuthRequiredOptions[],\n)\nFired when an authentication failure is received. The listener has three options: it can provide authentication credentials, it can cancel the request and display the error page, or it can take no action on the challenge. If bad user credentials are provided, this may be called multiple times for the same request. Note, only one of 'blocking'\nor 'asyncBlocking'\nmodes must be specified in the extraInfoSpec\nparameter.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object, asyncCallback?: function) => BlockingResponse | undefined\n-\ndetails\nobject\n-\nchallenger\nobject\nThe server requesting authentication.\n-\nhost\nstring\n-\nport\nnumber\n-\n-\ndocumentId\nstring\nChrome 106+The UUID of the document making the request.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (\ntype\nismain_frame\norsub_frame\n),frameId\nindicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. -\nframeTypeChrome 106+\nThe type of frame the request occurred in.\n-\ninitiator\nstring optional\nChrome 63+The origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n-\nisProxy\nboolean\nTrue for Proxy-Authenticate, false for WWW-Authenticate.\n-\nmethod\nstring\nStandard HTTP method.\n-\nparentDocumentId\nstring optional\nChrome 106+The UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n-\nrealm\nstring optional\nThe authentication realm provided by the server, if there is one.\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request.\n-\nresponseHeaders\nHttpHeaders optional\nThe HTTP response headers that were received along with this response.\n-\nscheme\nstring\nThe authentication scheme, e.g. Basic or Digest.\n-\nstatusCode\nnumber\nChrome 43+Standard HTTP status code returned by the server.\n-\nstatusLine\nstring\nHTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9 responses (i.e., responses that lack a status line) or an empty string if there are no headers.\n-\ntabId\nnumber\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n-\ntimeStamp\nnumber\nThe time when this signal is triggered, in milliseconds since the epoch.\n-\ntype\nHow the requested resource will be used.\n-\nurl\nstring\n-\n-\nasyncCallback\nfunction optional\nChrome 58+The\nasyncCallback\nparameter looks like:(response: BlockingResponse) => void\n-\nresponse\n-\n-\nreturns\nBlockingResponse | undefined\nIf \"blocking\" is specified in the \"extraInfoSpec\" parameter, the event listener should return an object of this type.\n-\n-\nfilter\n-\nextraInfoSpec\nOnAuthRequiredOptions[] optional\nonBeforeRedirect\nchrome.webRequest.onBeforeRedirect.addListener(\ncallback: function,\nfilter: RequestFilter,\nextraInfoSpec?: OnBeforeRedirectOptions[],\n)\nFired when a server-initiated redirect is about to occur.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+The UUID of the document making the request.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (\ntype\nismain_frame\norsub_frame\n),frameId\nindicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. -\nframeTypeChrome 106+\nThe type of frame the request occurred in.\n-\nfromCache\nboolean\nIndicates if this response was fetched from disk cache.\n-\ninitiator\nstring optional\nChrome 63+The origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n-\nip\nstring optional\nThe server IP address that the request was actually sent to. Note that it may be a literal IPv6 address.\n-\nmethod\nstring\nStandard HTTP method.\n-\nparentDocumentId\nstring optional\nChrome 106+The UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n-\nredirectUrl\nstring\nThe new URL.\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request.\n-\nresponseHeaders\nHttpHeaders optional\nThe HTTP response headers that were received along with this redirect.\n-\nstatusCode\nnumber\nStandard HTTP status code returned by the server.\n-\nstatusLine\nstring\nHTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9 responses (i.e., responses that lack a status line) or an empty string if there are no headers.\n-\ntabId\nnumber\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n-\ntimeStamp\nnumber\nThe time when this signal is triggered, in milliseconds since the epoch.\n-\ntype\nHow the requested resource will be used.\n-\nurl\nstring\n-\n-\n-\nfilter\n-\nextraInfoSpec\nOnBeforeRedirectOptions[] optional\nonBeforeRequest\nchrome.webRequest.onBeforeRequest.addListener(\ncallback: function,\nfilter: RequestFilter,\nextraInfoSpec?: OnBeforeRequestOptions[],\n)\nFired when a request is about to occur.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => BlockingResponse | undefined\n-\ndetails\nobject\n-\ndocumentId\nstring optional\nChrome 106+The UUID of the document making the request.\n-\ndocumentLifecycle\nextensionTypes.DocumentLifecycle optional\nChrome 106+The lifecycle the document is in.\n-\nframeId\nnumber\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (\ntype\nismain_frame\norsub_frame\n),frameId\nindicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. -\nframeType\nextensionTypes.FrameType optional\nChrome 106+The type of frame the request occurred in.\n-\ninitiator\nstring optional\nChrome 63+The origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n-\nmethod\nstring\nStandard HTTP method.\n-\nparentDocumentId\nstring optional\nChrome 106+The UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n-\nrequestBody\nobject optional\nContains the HTTP request body data. Only provided if extraInfoSpec contains 'requestBody'.\n-\nerror\nstring optional\nErrors when obtaining request body data.\n-\nformData\nobject optional\nIf the request method is POST and the body is a sequence of key-value pairs encoded in UTF8, encoded as either multipart/form-data, or application/x-www-form-urlencoded, this dictionary is present and for each key contains the list of all values for that key. If the data is of another media type, or if it is malformed, the dictionary is not present. An example value of this dictionary is {'key': ['value1', 'value2']}.\n-\nraw\nUploadData[] optional\nIf the request method is PUT or POST, and the body is not already parsed in formData, then the unparsed request body elements are contained in this array.\n-\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request.\n-\ntabId\nnumber\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n-\ntimeStamp\nnumber\nThe time when this signal is triggered, in milliseconds since the epoch.\n-\ntype\nHow the requested resource will be used.\n-\nurl\nstring\n-\n-\nreturns\nBlockingResponse | undefined\nIf \"blocking\" is specified in the \"extraInfoSpec\" parameter, the event listener should return an object of this type.\n-\n-\nfilter\n-\nextraInfoSpec\nOnBeforeRequestOptions[] optional\nonBeforeSendHeaders\nchrome.webRequest.onBeforeSendHeaders.addListener(\ncallback: function,\nfilter: RequestFilter,\nextraInfoSpec?: OnBeforeSendHeadersOptions[],\n)\nFired before sending an HTTP request, once the request headers are available. This may occur after a TCP connection is made to the server, but before any HTTP data is sent.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => BlockingResponse | undefined\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+The UUID of the document making the request.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (\ntype\nismain_frame\norsub_frame\n),frameId\nindicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. -\nframeTypeChrome 106+\nThe type of frame the request occurred in.\n-\ninitiator\nstring optional\nChrome 63+The origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n-\nmethod\nstring\nStandard HTTP method.\n-\nparentDocumentId\nstring optional\nChrome 106+The UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n-\nrequestHeaders\nHttpHeaders optional\nThe HTTP request headers that are going to be sent out with this request.\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request.\n-\ntabId\nnumber\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n-\ntimeStamp\nnumber\nThe time when this signal is triggered, in milliseconds since the epoch.\n-\ntype\nHow the requested resource will be used.\n-\nurl\nstring\n-\n-\nreturns\nBlockingResponse | undefined\nIf \"blocking\" is specified in the \"extraInfoSpec\" parameter, the event listener should return an object of this type.\n-\n-\nfilter\n-\nextraInfoSpec\nOnBeforeSendHeadersOptions[] optional\nonCompleted\nchrome.webRequest.onCompleted.addListener(\ncallback: function,\nfilter: RequestFilter,\nextraInfoSpec?: OnCompletedOptions[],\n)\nFired when a request is completed.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+The UUID of the document making the request.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (\ntype\nismain_frame\norsub_frame\n),frameId\nindicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. -\nframeTypeChrome 106+\nThe type of frame the request occurred in.\n-\nfromCache\nboolean\nIndicates if this response was fetched from disk cache.\n-\ninitiator\nstring optional\nChrome 63+The origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n-\nip\nstring optional\nThe server IP address that the request was actually sent to. Note that it may be a literal IPv6 address.\n-\nmethod\nstring\nStandard HTTP method.\n-\nparentDocumentId\nstring optional\nChrome 106+The UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request.\n-\nresponseHeaders\nHttpHeaders optional\nThe HTTP response headers that were received along with this response.\n-\nstatusCode\nnumber\nStandard HTTP status code returned by the server.\n-\nstatusLine\nstring\nHTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9 responses (i.e., responses that lack a status line) or an empty string if there are no headers.\n-\ntabId\nnumber\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n-\ntimeStamp\nnumber\nThe time when this signal is triggered, in milliseconds since the epoch.\n-\ntype\nHow the requested resource will be used.\n-\nurl\nstring\n-\n-\n-\nfilter\n-\nextraInfoSpec\nOnCompletedOptions[] optional\nonErrorOccurred\nchrome.webRequest.onErrorOccurred.addListener(\ncallback: function,\nfilter: RequestFilter,\nextraInfoSpec?: OnErrorOccurredOptions[],\n)\nFired when an error occurs.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+The UUID of the document making the request. This value is not present if the request is a navigation of a frame.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nerror\nstring\nThe error description. This string is not guaranteed to remain backwards compatible between releases. You must not parse and act based upon its content.\n-\nframeId\nnumber\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (\ntype\nismain_frame\norsub_frame\n),frameId\nindicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. -\nframeTypeChrome 106+\nThe type of frame the request occurred in.\n-\nfromCache\nboolean\nIndicates if this response was fetched from disk cache.\n-\ninitiator\nstring optional\nChrome 63+The origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n-\nip\nstring optional\nThe server IP address that the request was actually sent to. Note that it may be a literal IPv6 address.\n-\nmethod\nstring\nStandard HTTP method.\n-\nparentDocumentId\nstring optional\nChrome 106+The UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request.\n-\ntabId\nnumber\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n-\ntimeStamp\nnumber\nThe time when this signal is triggered, in milliseconds since the epoch.\n-\ntype\nHow the requested resource will be used.\n-\nurl\nstring\n-\n-\n-\nfilter\n-\nextraInfoSpec\nOnErrorOccurredOptions[] optional\nonHeadersReceived\nchrome.webRequest.onHeadersReceived.addListener(\ncallback: function,\nfilter: RequestFilter,\nextraInfoSpec?: OnHeadersReceivedOptions[],\n)\nFired when HTTP response headers of a request have been received.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => BlockingResponse | undefined\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+The UUID of the document making the request.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (\ntype\nismain_frame\norsub_frame\n),frameId\nindicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. -\nframeTypeChrome 106+\nThe type of frame the request occurred in.\n-\ninitiator\nstring optional\nChrome 63+The origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n-\nmethod\nstring\nStandard HTTP method.\n-\nparentDocumentId\nstring optional\nChrome 106+The UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request.\n-\nresponseHeaders\nHttpHeaders optional\nThe HTTP response headers that have been received with this response.\n-\nstatusCode\nnumber\nChrome 43+Standard HTTP status code returned by the server.\n-\nstatusLine\nstring\nHTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9 responses (i.e., responses that lack a status line).\n-\ntabId\nnumber\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n-\ntimeStamp\nnumber\nThe time when this signal is triggered, in milliseconds since the epoch.\n-\ntype\nHow the requested resource will be used.\n-\nurl\nstring\n-\n-\nreturns\nBlockingResponse | undefined\nIf \"blocking\" is specified in the \"extraInfoSpec\" parameter, the event listener should return an object of this type.\n-\n-\nfilter\n-\nextraInfoSpec\nOnHeadersReceivedOptions[] optional\nonResponseStarted\nchrome.webRequest.onResponseStarted.addListener(\ncallback: function,\nfilter: RequestFilter,\nextraInfoSpec?: OnResponseStartedOptions[],\n)\nFired when the first byte of the response body is received. For HTTP requests, this means that the status line and response headers are available.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+The UUID of the document making the request.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (\ntype\nismain_frame\norsub_frame\n),frameId\nindicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. -\nframeTypeChrome 106+\nThe type of frame the request occurred in.\n-\nfromCache\nboolean\nIndicates if this response was fetched from disk cache.\n-\ninitiator\nstring optional\nChrome 63+The origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n-\nip\nstring optional\nThe server IP address that the request was actually sent to. Note that it may be a literal IPv6 address.\n-\nmethod\nstring\nStandard HTTP method.\n-\nparentDocumentId\nstring optional\nChrome 106+The UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request.\n-\nresponseHeaders\nHttpHeaders optional\nThe HTTP response headers that were received along with this response.\n-\nstatusCode\nnumber\nStandard HTTP status code returned by the server.\n-\nstatusLine\nstring\nHTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9 responses (i.e., responses that lack a status line) or an empty string if there are no headers.\n-\ntabId\nnumber\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n-\ntimeStamp\nnumber\nThe time when this signal is triggered, in milliseconds since the epoch.\n-\ntype\nHow the requested resource will be used.\n-\nurl\nstring\n-\n-\n-\nfilter\n-\nextraInfoSpec\nOnResponseStartedOptions[] optional\nonSendHeaders\nchrome.webRequest.onSendHeaders.addListener(\ncallback: function,\nfilter: RequestFilter,\nextraInfoSpec?: OnSendHeadersOptions[],\n)\nFired just before a request is going to be sent to the server (modifications of previous onBeforeSendHeaders callbacks are visible by the time onSendHeaders is fired).\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+The UUID of the document making the request.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (\ntype\nismain_frame\norsub_frame\n),frameId\nindicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. -\nframeTypeChrome 106+\nThe type of frame the request occurred in.\n-\ninitiator\nstring optional\nChrome 63+The origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n-\nmethod\nstring\nStandard HTTP method.\n-\nparentDocumentId\nstring optional\nChrome 106+The UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n-\nrequestHeaders\nHttpHeaders optional\nThe HTTP request headers that have been sent out with this request.\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request.\n-\ntabId\nnumber\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n-\ntimeStamp\nnumber\nThe time when this signal is triggered, in milliseconds since the epoch.\n-\ntype\nHow the requested resource will be used.\n-\nurl\nstring\n-\n-\n-\nfilter\n-\nextraInfoSpec\nOnSendHeadersOptions[] optional"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/windows", "title": "chrome.windows | API | Chrome for Developers", "text": "Description\nUse the chrome.windows\nAPI to interact with browser windows. You can use this API to create, modify, and rearrange windows in the browser.\nPermissions\nWhen requested, a windows.Window\ncontains an array of tabs.Tab\nobjects. You must\ndeclare the \"tabs\"\npermission in your manifest if you need access to the url\n,\npendingUrl\n, title\n, or favIconUrl\nproperties of tabs.Tab\n. For example:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\"tabs\"],\n...\n}\nConcepts and usage\nThe current window\nMany functions in the extension system take an optional windowId\nargument, which defaults to the\ncurrent window.\nThe current window is the window that contains the code that is currently executing. It's important to realize that this can be different from the topmost or focused window.\nFor example, say an extension creates a few tabs or windows from a single HTML file, and that the\nHTML file contains a call to tabs.query()\n. The current window is the window that contains the\npage that made the call, no matter what the topmost window is.\nIn the case of service workers, the value of the current window falls back to the last active window. Under some circumstances, there may be no current window for background pages.\nExamples\nTo try this API, install the windows API example from the chrome-extension-samples repository.\nTypes\nCreateType\nSpecifies what type of browser window to create. 'panel' is deprecated and is available only to existing allowlisted extensions on Chrome OS.\nEnum\n\"normal\" \"popup\" \"panel\"\nSpecifies the window as a standard window.\nSpecifies the window as a popup window.\nSpecifies the window as a panel.\nQueryOptions\nProperties\n-\npopulate\nboolean optional\nIf true, the\nwindows.Window\nobject has atabs\nproperty that contains a list of thetabs.Tab\nobjects. TheTab\nobjects only contain theurl\n,pendingUrl\n,title\n, andfavIconUrl\nproperties if the extension's manifest file includes the\"tabs\"\npermission. -\nwindowTypes\nWindowType[] optional\nIf set, the\nwindows.Window\nreturned is filtered based on its type. If unset, the default filter is set to['normal', 'popup']\n.\nWindow\nProperties\n-\nalwaysOnTop\nboolean\nWhether the window is set to be always on top.\n-\nfocused\nboolean\nWhether the window is currently the focused window.\n-\nheight\nnumber optional\nThe height of the window, including the frame, in pixels. In some circumstances a window may not be assigned a\nheight\nproperty; for example, when querying closed windows from thesessions\nAPI. -\nid\nnumber optional\nThe ID of the window. Window IDs are unique within a browser session. In some circumstances a window may not be assigned an\nID\nproperty; for example, when querying windows using thesessions\nAPI, in which case a session ID may be present. -\nincognito\nboolean\nWhether the window is incognito.\n-\nleft\nnumber optional\nThe offset of the window from the left edge of the screen in pixels. In some circumstances a window may not be assigned a\nleft\nproperty; for example, when querying closed windows from thesessions\nAPI. -\nsessionId\nstring optional\nThe session ID used to uniquely identify a window, obtained from the\nsessions\nAPI. -\nstate\nWindowState optional\nThe state of this browser window.\n-\ntabs\nTab[] optional\nArray of\ntabs.Tab\nobjects representing the current tabs in the window. -\ntop\nnumber optional\nThe offset of the window from the top edge of the screen in pixels. In some circumstances a window may not be assigned a\ntop\nproperty; for example, when querying closed windows from thesessions\nAPI. -\ntype\nWindowType optional\nThe type of browser window this is.\n-\nwidth\nnumber optional\nThe width of the window, including the frame, in pixels. In some circumstances a window may not be assigned a\nwidth\nproperty; for example, when querying closed windows from thesessions\nAPI.\nWindowState\nThe state of this browser window. In some circumstances a window may not be assigned a state\nproperty; for example, when querying closed windows from the sessions\nAPI.\nEnum\n\"normal\" \"minimized\" \"maximized\" \"fullscreen\" \"locked-fullscreen\"\nNormal window state (not minimized, maximized, or fullscreen).\nMinimized window state.\nMaximized window state.\nFullscreen window state.\nLocked fullscreen window state. This fullscreen state cannot be exited by user action and is available only to allowlisted extensions on Chrome OS.\nWindowType\nThe type of browser window this is. In some circumstances a window may not be assigned a type\nproperty; for example, when querying closed windows from the sessions\nAPI.\nEnum\n\"normal\" \"popup\" \"panel\" \"app\" \"devtools\"\nA normal browser window.\nA browser popup.\nDeprecated in this API. A Chrome App panel-style window. Extensions can only see their own panel windows.\nDeprecated in this API. A Chrome App window. Extensions can only see their app own windows.\nA Developer Tools window.\nProperties\nWINDOW_ID_CURRENT\nThe windowId value that represents the current window.\nValue\n-2\nWINDOW_ID_NONE\nThe windowId value that represents the absence of a Chrome browser window.\nValue\n-1\nMethods\ncreate()\nchrome.windows.create(\ncreateData?: object,\ncallback?: function,\n)\nCreates (opens) a new browser window with any optional sizing, position, or default URL provided.\nParameters\n-\ncreateData\nobject optional\n-\nfocused\nboolean optional\nIf\ntrue\n, opens an active window. Iffalse\n, opens an inactive window. -\nheight\nnumber optional\nThe height in pixels of the new window, including the frame. If not specified, defaults to a natural height.\n-\nincognito\nboolean optional\nWhether the new window should be an incognito window.\n-\nleft\nnumber optional\nThe number of pixels to position the new window from the left edge of the screen. If not specified, the new window is offset naturally from the last focused window. This value is ignored for panels.\n-\nsetSelfAsOpener\nboolean optional\nChrome 64+If\ntrue\n, the newly-created window's 'window.opener' is set to the caller and is in the same unit of related browsing contexts as the caller. -\nstate\nWindowState optional\nChrome 44+The initial state of the window. The\nminimized\n,maximized\n, andfullscreen\nstates cannot be combined withleft\n,top\n,width\n, orheight\n. -\ntabId\nnumber optional\nThe ID of the tab to add to the new window.\n-\ntop\nnumber optional\nThe number of pixels to position the new window from the top edge of the screen. If not specified, the new window is offset naturally from the last focused window. This value is ignored for panels.\n-\ntype\nCreateType optional\nSpecifies what type of browser window to create.\n-\nurl\nstring | string[] optional\nA URL or array of URLs to open as tabs in the window. Fully-qualified URLs must include a scheme, e.g., 'http://www.google.com', not 'www.google.com'. Non-fully-qualified URLs are considered relative within the extension. Defaults to the New Tab Page.\n-\nwidth\nnumber optional\nThe width in pixels of the new window, including the frame. If not specified, defaults to a natural width.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(window?: Window) => void\n-\nwindow\nWindow optional\nContains details about the created window.\n-\nReturns\n-\nPromise<Window | undefined>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nget()\nchrome.windows.get(\nwindowId: number,\nqueryOptions?: QueryOptions,\ncallback?: function,\n)\nGets details about a window.\nParameters\n-\nwindowId\nnumber\n-\nqueryOptions\nQueryOptions optional\nChrome 88+ -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(window: Window) => void\n-\nwindow\n-\nReturns\n-\nPromise<Window>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetAll()\nchrome.windows.getAll(\nqueryOptions?: QueryOptions,\ncallback?: function,\n)\nGets all windows.\nParameters\n-\nqueryOptions\nQueryOptions optional\nChrome 88+ -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(windows: Window[]) => void\n-\nwindows\nWindow[]\n-\nReturns\n-\nPromise<Window[]>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetCurrent()\nchrome.windows.getCurrent(\nqueryOptions?: QueryOptions,\ncallback?: function,\n)\nGets the current window.\nParameters\n-\nqueryOptions\nQueryOptions optional\nChrome 88+ -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(window: Window) => void\n-\nwindow\n-\nReturns\n-\nPromise<Window>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetLastFocused()\nchrome.windows.getLastFocused(\nqueryOptions?: QueryOptions,\ncallback?: function,\n)\nGets the window that was most recently focused \u2014 typically the window 'on top'.\nParameters\n-\nqueryOptions\nQueryOptions optional\nChrome 88+ -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(window: Window) => void\n-\nwindow\n-\nReturns\n-\nPromise<Window>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremove()\nchrome.windows.remove(\nwindowId: number,\ncallback?: function,\n)\nRemoves (closes) a window and all the tabs inside it.\nParameters\n-\nwindowId\nnumber\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdate()\nchrome.windows.update(\nwindowId: number,\nupdateInfo: object,\ncallback?: function,\n)\nUpdates the properties of a window. Specify only the properties that to be changed; unspecified properties are unchanged.\nParameters\n-\nwindowId\nnumber\n-\nupdateInfo\nobject\n-\ndrawAttention\nboolean optional\nIf\ntrue\n, causes the window to be displayed in a manner that draws the user's attention to the window, without changing the focused window. The effect lasts until the user changes focus to the window. This option has no effect if the window already has focus. Set tofalse\nto cancel a previousdrawAttention\nrequest. -\nfocused\nboolean optional\nIf\ntrue\n, brings the window to the front; cannot be combined with the state 'minimized'. Iffalse\n, brings the next window in the z-order to the front; cannot be combined with the state 'fullscreen' or 'maximized'. -\nheight\nnumber optional\nThe height to resize the window to in pixels. This value is ignored for panels.\n-\nleft\nnumber optional\nThe offset from the left edge of the screen to move the window to in pixels. This value is ignored for panels.\n-\nstate\nWindowState optional\nThe new state of the window. The 'minimized', 'maximized', and 'fullscreen' states cannot be combined with 'left', 'top', 'width', or 'height'.\n-\ntop\nnumber optional\nThe offset from the top edge of the screen to move the window to in pixels. This value is ignored for panels.\n-\nwidth\nnumber optional\nThe width to resize the window to in pixels. This value is ignored for panels.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(window: Window) => void\n-\nwindow\n-\nReturns\n-\nPromise<Window>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonBoundsChanged\nchrome.windows.onBoundsChanged.addListener(\ncallback: function,\n)\nFired when a window has been resized; this event is only dispatched when the new bounds are committed, and not for in-progress changes.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(window: Window) => void\n-\nwindow\n-\nonCreated\nchrome.windows.onCreated.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when a window is created.\nParameters\n-\ncallback\nfunction\nChrome 46+The\ncallback\nparameter looks like:(window: Window) => void\n-\nwindow\nDetails of the created window.\n-\n-\nfilters\nobject optional\n-\nwindowTypes\nConditions that the window's type being created must satisfy. By default it satisfies\n['normal', 'popup']\n.\n-\nonFocusChanged\nchrome.windows.onFocusChanged.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when the currently focused window changes. Returns chrome.windows.WINDOW_ID_NONE\nif all Chrome windows have lost focus. Note: On some Linux window managers, WINDOW_ID_NONE\nis always sent immediately preceding a switch from one Chrome window to another.\nParameters\n-\ncallback\nfunction\nChrome 46+The\ncallback\nparameter looks like:(windowId: number) => void\n-\nwindowId\nnumber\nID of the newly-focused window.\n-\n-\nfilters\nobject optional\n-\nwindowTypes\nConditions that the window's type being removed must satisfy. By default it satisfies\n['normal', 'popup']\n.\n-\nonRemoved\nchrome.windows.onRemoved.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when a window is removed (closed).\nParameters\n-\ncallback\nfunction\nChrome 46+The\ncallback\nparameter looks like:(windowId: number) => void\n-\nwindowId\nnumber\nID of the removed window.\n-\n-\nfilters\nobject optional\n-\nwindowTypes\nConditions that the window's type being removed must satisfy. By default it satisfies\n['normal', 'popup']\n.\n-"},
{"source": "https://developer.chrome.com/docs/extensions/mv2/reference/browserAction", "title": "chrome.browserAction | Reference | Chrome for Developers", "text": "Description\nUse browser actions to put icons in the main Google Chrome toolbar, to the right of the address bar. In addition to its icon, a browser action can have a tooltip, a badge, and a popup.\nAvailability\nIn the following figure, the multicolored square to the right of the address bar is the icon for a browser action. A popup is below the icon.\nIf you want to create an icon that isn't always active, use a page action instead of a browser action.\nManifest\nRegister your browser action in the extension manifest like this:\n{\n\"name\": \"My extension\",\n...\n\"browser_action\": {\n\"default_icon\": { // optional\n\"16\": \"images/icon16.png\", // optional\n\"24\": \"images/icon24.png\", // optional\n\"32\": \"images/icon32.png\" // optional\n},\n\"default_title\": \"Google Mail\", // optional, shown in tooltip\n\"default_popup\": \"popup.html\" // optional\n},\n...\n}\nYou can provide any size icon to be used in Chrome, and Chrome will select the closest one and scale it to the appropriate size to fill the 16-dip space. However, if the exact size isn't provided, this scaling can cause the icon to lose detail or look fuzzy.\nSince devices with less-common scale factors like 1.5x or 1.2x are becoming more common, you are encouraged to provide multiple sizes for your icons. This also ensures that if the icon display size is ever changed, you don't need to do any more work to provide different icons!\nThe old syntax for registering the default icon is still supported:\n{\n\"name\": \"My extension\",\n...\n\"browser_action\": {\n...\n\"default_icon\": \"images/icon32.png\" // optional\n// equivalent to \"default_icon\": { \"32\": \"images/icon32.png\" }\n},\n...\n}\nParts of the UI\nA browser action can have an icon, a tooltip, a badge, and a popup.\nIcon\nThe browser action icons in Chrome are 16 dips (device-independent pixels) wide and high. Larger icons are resized to fit, but for best results, use a 16-dip square icon.\nYou can set the icon in two ways: using a static image or using the HTML5 canvas element. Using static images is easier for simple applications, but you can create more dynamic UIs\u2014such as smooth animation\u2014using the canvas element.\nStatic images can be in any format WebKit can display, including BMP, GIF, ICO, JPEG, or PNG. For unpacked extensions, images must be in the PNG format.\nTo set the icon, use the default_icon field of browser_action in the manifest, or call\nthe browserAction.setIcon\nmethod.\nTo properly display icon when screen pixel density (ratio size_in_pixel / size_in_dip\n) is\ndifferent than 1, the icon can be defined as set of images with different sizes. The actual image to\ndisplay will be selected from the set to best fit the pixel size of 16 dip. The icon set can contain\nany size icon specification, and Chrome will select the most appropriate one.\nTooltip\nTo set the tooltip, use the default_title field of browser_action in the manifest, or\ncall the browserAction.setTitle\nmethod. You can specify locale-specific strings for the\ndefault_title field; see Internationalization for details.\nBadge\nBrowser actions can optionally display a badge\u2014a bit of text that is layered over the icon. Badges make it easy to update the browser action to display a small amount of information about the state of the extension.\nBecause the badge has limited space, it should have 4 characters or less.\nSet the text and color of the badge using browserAction.setBadgeText\nand\nbrowserAction.setBadgeBackgroundColor\n, respectively.\nPopup\nIf a browser action has a popup, the popup appears when the user clicks the extension's icon. The popup can contain any HTML contents that you like, and it's automatically sized to fit its contents. The popup cannot be smaller than 25x25 and cannot be larger than 800x600.\nTo add a popup to your browser action, create an HTML file with the popup's contents. Specify the\nHTML file in the default_popup field of browser_action in the manifest, or call the\nbrowserAction.setPopup\nmethod.\nTips\nFor the best visual impact, follow these guidelines:\n- Do use browser actions for features that make sense on most pages.\n- Don't use browser actions for features that make sense for only a few pages. Use page actions instead.\n- Do use big, colorful icons that make the most of the 16x16-dip space. Browser action icons should seem a little bigger and heavier than page action icons.\n- Don't attempt to mimic Google Chrome's monochrome menu icon. That doesn't work well with themes, and anyway, extensions should stand out a little.\n- Do use alpha transparency to add soft edges to your icon. Because many people use themes, your icon should look nice on a variety of background colors.\n- Don't constantly animate your icon. That's just annoying.\nExamples\nYou can find simple examples of using browser actions in the examples/api/browserAction directory. For other examples and for help in viewing the source code, see Samples.\nTypes\nColorArray\nType\n[number, number, number, number]\nImageDataType\nPixel data for an image. Must be an ImageData object; for example, from a canvas\nelement.\nType\nImageData\nTabDetails\nProperties\n-\ntabId\nnumber optional\nThe ID of the tab to query state for. If no tab is specified, the non-tab-specific state is returned.\nMethods\ndisable()\nchrome.browserAction.disable(\ntabId?: number,\ncallback?: function,\n)\nDisables the browser action for a tab.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab for which to modify the browser action.\n-\ncallback\nfunction optional\nChrome 67+The\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nenable()\nchrome.browserAction.enable(\ntabId?: number,\ncallback?: function,\n)\nEnables the browser action for a tab. Defaults to enabled.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab for which to modify the browser action.\n-\ncallback\nfunction optional\nChrome 67+The\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\ngetBadgeBackgroundColor()\nchrome.browserAction.getBadgeBackgroundColor(\ndetails: TabDetails,\ncallback?: function,\n)\nGets the background color of the browser action.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: ColorArray) => void\n-\nresult\n-\nReturns\n-\nPromise<ColorArray>\nChrome 88+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\ngetBadgeText()\nchrome.browserAction.getBadgeText(\ndetails: TabDetails,\ncallback?: function,\n)\nGets the badge text of the browser action. If no tab is specified, the non-tab-specific badge text is returned.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: string) => void\n-\nresult\nstring\n-\nReturns\n-\nPromise<string>\nChrome 88+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\ngetPopup()\nchrome.browserAction.getPopup(\ndetails: TabDetails,\ncallback?: function,\n)\nGets the HTML document that is set as the popup for this browser action.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: string) => void\n-\nresult\nstring\n-\nReturns\n-\nPromise<string>\nChrome 88+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\ngetTitle()\nchrome.browserAction.getTitle(\ndetails: TabDetails,\ncallback?: function,\n)\nGets the title of the browser action.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: string) => void\n-\nresult\nstring\n-\nReturns\n-\nPromise<string>\nChrome 88+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nsetBadgeBackgroundColor()\nchrome.browserAction.setBadgeBackgroundColor(\ndetails: object,\ncallback?: function,\n)\nSets the background color for the badge.\nParameters\n-\ndetails\nobject\n-\ncolor\nstring | ColorArray\nAn array of four integers in the range 0-255 that make up the RGBA color of the badge. Can also be a string with a CSS hex color value; for example,\n#FF0000\nor#F00\n(red). Renders colors at full opacity. -\ntabId\nnumber optional\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n-\n-\ncallback\nfunction optional\nChrome 67+The\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nsetBadgeText()\nchrome.browserAction.setBadgeText(\ndetails: object,\ncallback?: function,\n)\nSets the badge text for the browser action. The badge is displayed on top of the icon.\nParameters\n-\ndetails\nobject\n-\ntabId\nnumber optional\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n-\ntext\nstring optional\nAny number of characters can be passed, but only about four can fit into the space. If an empty string (\n''\n) is passed, the badge text is cleared. IftabId\nis specified andtext\nis null, the text for the specified tab is cleared and defaults to the global badge text.\n-\n-\ncallback\nfunction optional\nChrome 67+The\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nsetIcon()\nchrome.browserAction.setIcon(\ndetails: object,\ncallback?: function,\n)\nSets the icon for the browser action. The icon can be specified as the path to an image file, as the pixel data from a canvas element, or as a dictionary of one of those. Either the path\nor the imageData\nproperty must be specified.\nParameters\n-\ndetails\nobject\n-\nimageData\nImageData | object optional\nEither an ImageData object or a dictionary {size -> ImageData} representing an icon to be set. If the icon is specified as a dictionary, the image used is chosen depending on the screen's pixel density. If the number of image pixels that fit into one screen space unit equals\nscale\n, then an image with sizescale\n* n is selected, where n is the size of the icon in the UI. At least one image must be specified. Note that 'details.imageData = foo' is equivalent to 'details.imageData = {'16': foo}' -\npath\nstring | object optional\nEither a relative image path or a dictionary {size -> relative image path} pointing to an icon to be set. If the icon is specified as a dictionary, the image used is chosen depending on the screen's pixel density. If the number of image pixels that fit into one screen space unit equals\nscale\n, then an image with sizescale\n* n is selected, where n is the size of the icon in the UI. At least one image must be specified. Note that 'details.path = foo' is equivalent to 'details.path = {'16': foo}' -\ntabId\nnumber optional\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 116+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nsetPopup()\nchrome.browserAction.setPopup(\ndetails: object,\ncallback?: function,\n)\nSets the HTML document to be opened as a popup when the user clicks the browser action icon.\nParameters\n-\ndetails\nobject\n-\npopup\nstring\nThe relative path to the HTML file to show in a popup. If set to the empty string (\n''\n), no popup is shown. -\ntabId\nnumber optional\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n-\n-\ncallback\nfunction optional\nChrome 67+The\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nsetTitle()\nchrome.browserAction.setTitle(\ndetails: object,\ncallback?: function,\n)\nSets the title of the browser action. This title appears in the tooltip.\nParameters\n-\ndetails\nobject\n-\ntabId\nnumber optional\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n-\ntitle\nstring\nThe string the browser action should display when moused over.\n-\n-\ncallback\nfunction optional\nChrome 67+The\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/contentSettings", "title": "chrome.contentSettings | API | Chrome for Developers", "text": "Description\nUse the chrome.contentSettings\nAPI to change settings that control whether websites can use features such as cookies, JavaScript, and plugins. More generally speaking, content settings allow you to customize Chrome's behavior on a per-site basis instead of globally.\nPermissions\ncontentSettings\nYou must declare the \"contentSettings\"\npermission in your extension's manifest to use the API. For\nexample:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"contentSettings\"\n],\n...\n}\nConcepts and usage\nContent setting patterns\nYou can use patterns to specify the websites that each content setting affects. For example,\nhttps://*.youtube.com/*\nspecifies youtube.com and all of its subdomains. The syntax for content\nsetting patterns is the same as for match patterns, with a few differences:\n- For\nhttp\n,https\n, andftp\nURLs, the path must be a wildcard (/*\n). Forfile\nURLs, the path must be completely specified and must not contain wildcards. - In contrast to match patterns, content setting patterns can specify a port number. If a port number is specified, the pattern only matches websites with that port. If no port number is specified, the pattern matches all ports.\nPattern precedence\nWhen more than one content setting rule applies for a given site, the rule with the more specific pattern takes precedence.\nFor example, the following patterns are ordered by precedence:\nhttps://www.example.com/*\nhttps://*.example.com/*\n(matching example.com and all subdomains)<all_urls>\n(matching every URL)\nThree kinds of wildcards affect how specific a pattern is:\n- Wildcards in the port (for example\nhttps://www.example.com:*/*\n) - Wildcards in the scheme (for example\n*://www.example.com:123/*\n) - Wildcards in the hostname (for example\nhttps://*.example.com:123/*\n)\nIf a pattern is more specific than another pattern in one part but less specific in another part, the different parts are checked in the following order: hostname, scheme, port. For example, the following patterns are ordered by precedence:\nhttps://www.example.com:*/*\nSpecifies the hostname and scheme.*:/www.example.com:123/*\nNot as high, because although it specifies the hostname, it doesn't specify the scheme.https://*.example.com:123/*\nLower because although it specifies the port and scheme, it has a wildcard in the hostname.\nPrimary and secondary patterns\nThe URL taken into account when deciding which content setting to apply depends on the content type.\nFor example, for contentSettings.notifications\nsettings are based on the URL shown in the\nomnibox. This URL is called the \"primary\" URL.\nSome content types can take additional URLs into account. For example, whether a site is allowed to\nset a contentSettings.cookies\nis decided based on the URL of the HTTP request (which is the\nprimary URL in this case) as well as the URL shown in the omnibox (which is called the \"secondary\"\nURL).\nIf multiple rules have primary and secondary patterns, the rule with the more specific primary pattern takes precedence. If there multiple rules have the same primary pattern, the rule with the more specific secondary pattern takes precedence. For example, the following list of primary/secondary pattern pairs is ordered by precedence:\n| Precedence | Primary pattern | Secondary pattern |\n|---|---|---|\n| 1 | https://www.moose.com/* , | https://www.wombat.com/* |\n| 2 | https://www.moose.com/* , | <all_urls> |\n| 3 | <all_urls> , | https://www.wombat.com/* |\n| 4 | <all_urls> , | <all_urls> |\nSecondary patterns are not supported for the images content setting.\nResource identifiers\nResource identifiers allow you to specify content settings for specific subtypes of a content type.\nCurrently, the only content type that supports resource identifiers is contentSettings.plugins\n,\nwhere a resource identifier identifies a specific plugin. When applying content settings, first the\nsettings for the specific plugin are checked. If there are no settings found for the specific\nplugin, the general content settings for plugins are checked.\nFor example, if a content setting rule has the resource identifier adobe-flash-player\nand the\npattern <all_urls>\n, it takes precedence over a rule without a resource identifier and the pattern\nhttps://www.example.com/*\n, even if that pattern is more specific.\nYou can get a list of resource identifiers for a content type by calling the\ncontentSettings.ContentSetting.getResourceIdentifiers()\nmethod. The returned list can change with\nthe set of installed plugins on the user's machine, but Chrome tries to keep the identifiers stable\nacross plugin updates.\nExamples\nTo try this API, install the contentSettings API example from the chrome-extension-samples repository.\nTypes\nAutoVerifyContentSetting\nEnum\n\"allow\" \"block\"\nCameraContentSetting\nEnum\n\"allow\" \"block\" \"ask\"\nClipboardContentSetting\nEnum\n\"allow\" \"block\" \"ask\"\nContentSetting\nProperties\n-\nclear\nvoid\nPromiseClear all content setting rules set by this extension.\nThe\nclear\nfunction looks like:(details: object, callback?: function) => {...}\n-\ndetails\nobject\n-\nscope\nScope optional\nWhere to clear the setting (default: regular).\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\n-\nreturns\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\nget\nvoid\nPromiseGets the current content setting for a given pair of URLs.\nThe\nget\nfunction looks like:(details: object, callback?: function) => {...}\n-\ndetails\nobject\n-\nincognito\nboolean optional\nWhether to check the content settings for an incognito session. (default false)\n-\nprimaryUrl\nstring\nThe primary URL for which the content setting should be retrieved. Note that the meaning of a primary URL depends on the content type.\n-\nresourceIdentifier\nResourceIdentifier optional\nA more specific identifier of the type of content for which the settings should be retrieved.\n-\nsecondaryUrl\nstring optional\nThe secondary URL for which the content setting should be retrieved. Defaults to the primary URL. Note that the meaning of a secondary URL depends on the content type, and not all content types use secondary URLs.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nsetting\nT\nThe content setting. See the description of the individual ContentSetting objects for the possible values.\n-\n-\n-\nreturns\nPromise<object>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\ngetResourceIdentifiers\nvoid\nPromiseThe\ngetResourceIdentifiers\nfunction looks like:(callback?: function) => {...}\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(resourceIdentifiers?: ResourceIdentifier[]) => void\n-\nresourceIdentifiers\nResourceIdentifier[] optional\nA list of resource identifiers for this content type, or\nundefined\nif this content type does not use resource identifiers.\n-\n-\nreturns\nPromise<ResourceIdentifier[]>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\nset\nvoid\nPromiseApplies a new content setting rule.\nThe\nset\nfunction looks like:(details: object, callback?: function) => {...}\n-\ndetails\nobject\n-\nprimaryPattern\nstring\nThe pattern for the primary URL. For details on the format of a pattern, see Content Setting Patterns.\n-\nresourceIdentifier\nResourceIdentifier optional\nThe resource identifier for the content type.\n-\nscope\nScope optional\nWhere to set the setting (default: regular).\n-\nsecondaryPattern\nstring optional\nThe pattern for the secondary URL. Defaults to matching all URLs. For details on the format of a pattern, see Content Setting Patterns.\n-\nsetting\nany\nThe setting applied by this rule. See the description of the individual ContentSetting objects for the possible values.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\n-\nreturns\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\nCookiesContentSetting\nEnum\n\"allow\" \"block\" \"session_only\"\nFullscreenContentSetting\nValue\n\"allow\"\nImagesContentSetting\nEnum\n\"allow\" \"block\"\nJavascriptContentSetting\nEnum\n\"allow\" \"block\"\nLocationContentSetting\nEnum\n\"allow\" \"block\" \"ask\"\nMicrophoneContentSetting\nEnum\n\"allow\" \"block\" \"ask\"\nMouselockContentSetting\nValue\n\"allow\"\nMultipleAutomaticDownloadsContentSetting\nEnum\n\"allow\" \"block\" \"ask\"\nNotificationsContentSetting\nEnum\n\"allow\" \"block\" \"ask\"\nPluginsContentSetting\nValue\n\"block\"\nPopupsContentSetting\nEnum\n\"allow\" \"block\"\nPpapiBrokerContentSetting\nValue\n\"block\"\nResourceIdentifier\nThe only content type using resource identifiers is contentSettings.plugins\n. For more information, see Resource Identifiers.\nProperties\n-\ndescription\nstring optional\nA human readable description of the resource.\n-\nid\nstring\nThe resource identifier for the given content type.\nScope\nThe scope of the ContentSetting. One of\nregular\n: setting for regular profile (which is inherited by the incognito profile if not overridden elsewhere),\nincognito\\_session\\_only\n: setting for incognito profile that can only be set during an incognito session and is deleted when the incognito session ends (overrides regular settings).\nEnum\n\"regular\" \"incognito_session_only\"\nProperties\nautomaticDownloads\nWhether to allow sites to download multiple files automatically. One of\nallow\n: Allow sites to download multiple files automatically,\nblock\n: Don't allow sites to download multiple files automatically,\nask\n: Ask when a site wants to download files automatically after the first file.\nDefault is ask\n.\nThe primary URL is the URL of the top-level frame. The secondary URL is not used.\nautoVerify\nWhether to allow sites to use the Private State Tokens API. One of\nallow\n: Allow sites to use the Private State Tokens API,\nblock\n: Block sites from using the Private State Tokens API.\nDefault is allow\n.\nThe primary URL is the URL of the top-level frame. The secondary URL is not used. NOTE: When calling set()\n, the primary pattern must be .\ncamera\nWhether to allow sites to access the camera. One of\nallow\n: Allow sites to access the camera,\nblock\n: Don't allow sites to access the camera,\nask\n: Ask when a site wants to access the camera.\nDefault is ask\n.\nThe primary URL is the URL of the document which requested camera access. The secondary URL is not used.\nNOTE: The 'allow' setting is not valid if both patterns are ''.\nclipboard\nWhether to allow sites to access the clipboard via advanced capabilities of the Async Clipboard API. \"Advanced\" capabilities include anything besides writing built-in formats after a user gesture, i.e. the ability to read, the ability to write custom formats, and the ability to write without a user gesture. One of\nallow\n: Allow sites to use advanced clipboard capabilities,\nblock\n: Don't allow sites to use advanced clipboard capabilties,\nask\n: Ask when a site wants to use advanced clipboard capabilities.\nDefault is ask\n.\nThe primary URL is the URL of the document which requested clipboard access. The secondary URL is not used.\ncookies\nWhether to allow cookies and other local data to be set by websites. One of\nallow\n: Accept cookies,\nblock\n: Block cookies,\nsession\\_only\n: Accept cookies only for the current session.\nDefault is allow\n.\nThe primary URL is the URL representing the cookie origin. The secondary URL is the URL of the top-level frame.\nfullscreen\nDeprecated. No longer has any effect. Fullscreen permission is now automatically granted for all sites. Value is always allow\n.\nimages\nWhether to show images. One of\nallow\n: Show images,\nblock\n: Don't show images.\nDefault is allow\n.\nThe primary URL is the URL of the top-level frame. The secondary URL is the URL of the image.\njavascript\nWhether to run JavaScript. One of\nallow\n: Run JavaScript,\nblock\n: Don't run JavaScript.\nDefault is allow\n.\nThe primary URL is the URL of the top-level frame. The secondary URL is not used.\nlocation\nWhether to allow Geolocation. One of\nallow\n: Allow sites to track your physical location,\nblock\n: Don't allow sites to track your physical location,\nask\n: Ask before allowing sites to track your physical location.\nDefault is ask\n.\nThe primary URL is the URL of the document which requested location data. The secondary URL is the URL of the top-level frame (which may or may not differ from the requesting URL).\nmicrophone\nWhether to allow sites to access the microphone. One of\nallow\n: Allow sites to access the microphone,\nblock\n: Don't allow sites to access the microphone,\nask\n: Ask when a site wants to access the microphone.\nDefault is ask\n.\nThe primary URL is the URL of the document which requested microphone access. The secondary URL is not used.\nNOTE: The 'allow' setting is not valid if both patterns are ''.\nmouselock\nDeprecated. No longer has any effect. Mouse lock permission is now automatically granted for all sites. Value is always allow\n.\nnotifications\nWhether to allow sites to show desktop notifications. One of\nallow\n: Allow sites to show desktop notifications,\nblock\n: Don't allow sites to show desktop notifications,\nask\n: Ask when a site wants to show desktop notifications.\nDefault is ask\n.\nThe primary URL is the URL of the document which wants to show the notification. The secondary URL is not used.\nplugins\nDeprecated. With Flash support removed in Chrome 88, this permission no longer has any effect. Value is always block\n. Calls to set()\nand clear()\nwill be ignored.\npopups\nWhether to allow sites to show pop-ups. One of\nallow\n: Allow sites to show pop-ups,\nblock\n: Don't allow sites to show pop-ups.\nDefault is block\n.\nThe primary URL is the URL of the top-level frame. The secondary URL is not used.\nunsandboxedPlugins\nDeprecated. Previously, controlled whether to allow sites to run plugins unsandboxed, however, with the Flash broker process removed in Chrome 88, this permission no longer has any effect. Value is always block\n. Calls to set()\nand clear()\nwill be ignored."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/declarativeContent", "title": "chrome.declarativeContent | API | Chrome for Developers", "text": "Description\nUse the chrome.declarativeContent\nAPI to take actions depending on the content of a page, without requiring permission to read the page's content.\nPermissions\ndeclarativeContent\nConcepts and usage\nThe Declarative Content API lets you enable your extension's action depending on the URL of a web page, or if a CSS selector matches an element on the page, without needing to add host permissions or inject a content script.\nUse the activeTab permission to interact with a page after the user clicks on the extension's action.\nRules\nRules consists of conditions and actions. If any of the conditions is fulfilled, all actions are\nexecuted. The actions are setIcon()\nand showAction()\n.\nThe PageStateMatcher\nmatches web pages if and only if all listed\ncriteria are met. It can match a page url, a css compound selector\nor the bookmarked state of a page. The following rule enables\nthe extension's action on Google pages when a password field is present:\nlet rule1 = {\nconditions: [\nnew chrome.declarativeContent.PageStateMatcher({\npageUrl: { hostSuffix: '.google.com', schemes: ['https'] },\ncss: [\"input[type='password']\"]\n})\n],\nactions: [ new chrome.declarativeContent.ShowAction() ]\n};\nTo also enable the extension's action for Google sites with a video, you can add a second condition, as each condition is sufficient to trigger all specified actions:\nlet rule2 = {\nconditions: [\nnew chrome.declarativeContent.PageStateMatcher({\npageUrl: { hostSuffix: '.google.com', schemes: ['https'] },\ncss: [\"input[type='password']\"]\n}),\nnew chrome.declarativeContent.PageStateMatcher({\ncss: [\"video\"]\n})\n],\nactions: [ new chrome.declarativeContent.ShowAction() ]\n};\nThe onPageChanged\nevent tests whether any rule has at least one fulfilled\ncondition and executes the actions. Rules persist across browsing sessions; therefore, during\nextension installation time you should first use removeRules\nto clear\npreviously installed rules and then use addRules\nto register new ones.\nchrome.runtime.onInstalled.addListener(function(details) {\nchrome.declarativeContent.onPageChanged.removeRules(undefined, function() {\nchrome.declarativeContent.onPageChanged.addRules([rule2]);\n});\n});\nWith the activeTab permission, your extension won't display any permission warnings and when the user clicks the extension action, it will only run on relevant pages.\nPage URL matching\nThe PageStateMatcher.pageurl\nmatches when the URL criteria are fulfilled. The\nmost common criteria are a concatenation of either host, path, or URL, followed by Contains, Equals, Prefix, or\nSuffix. The following table contains a few examples:\n| Criteria | Matches |\n|---|---|\n{ hostSuffix: 'google.com' } |\nAll Google URLs |\n{ pathPrefix: '/docs/extensions' } |\nExtension docs URLs |\n{ urlContains: 'developer.chrome.com' } |\nAll chrome developers docs URLs |\nAll criteria are case sensitive. For a complete list of criteria, see UrlFilter.\nCSS Matching\nPageStateMatcher.css\nconditions must be compound selectors,\nmeaning that you can't include combinators like whitespace or \">\n\" in your\nselectors. This helps Chrome match the selectors more efficiently.\n| Compound Selectors (OK) | Complex Selectors (Not OK) |\n|---|---|\na |\ndiv p |\niframe.special[src^='http'] |\np>span.highlight |\nns|* |\np + ol |\n#abcd:checked |\np::first-line |\nCSS conditions only match displayed elements: if an element that matches your selector is\ndisplay:none\nor one of its parent elements is display:none\n, it doesn't cause the condition to\nmatch. Elements styled with visibility:hidden\n, positioned off-screen, or hidden by other elements\ncan still make your condition match.\nBookmarked state matching\nThe PageStateMatcher.isBookmarked\ncondition allows matching of the\nbookmarked state of the current URL in the user's profile. To make use of this condition the\n\"bookmarks\" permission must be declared in the extension manifest.\nTypes\nImageDataType\nSee https://developer.mozilla.org/en-US/docs/Web/API/ImageData.\nType\nImageData\nPageStateMatcher\nMatches the state of a web page based on various criteria.\nProperties\n-\nconstructor\nvoid\nThe\nconstructor\nfunction looks like:(arg: PageStateMatcher) => {...}\n-\narg\n-\nreturns\n-\n-\ncss\nstring[] optional\nMatches if all of the CSS selectors in the array match displayed elements in a frame with the same origin as the page's main frame. All selectors in this array must be compound selectors to speed up matching. Note: Listing hundreds of CSS selectors or listing CSS selectors that match hundreds of times per page can slow down web sites.\n-\nisBookmarked\nboolean optional\nChrome 45+Matches if the bookmarked state of the page is equal to the specified value. Requres the bookmarks permission.\n-\npageUrl\nUrlFilter optional\nMatches if the conditions of the\nUrlFilter\nare fulfilled for the top-level URL of the page.\nRequestContentScript\nDeclarative event action that injects a content script.\nWARNING: This action is still experimental and is not supported on stable builds of Chrome.\nProperties\n-\nconstructor\nvoid\nThe\nconstructor\nfunction looks like:(arg: RequestContentScript) => {...}\n-\nreturns\n-\n-\nallFrames\nboolean optional\nWhether the content script runs in all frames of the matching page, or in only the top frame. Default is\nfalse\n. -\ncss\nstring[] optional\nNames of CSS files to be injected as a part of the content script.\n-\njs\nstring[] optional\nNames of JavaScript files to be injected as a part of the content script.\n-\nmatchAboutBlank\nboolean optional\nWhether to insert the content script on\nabout:blank\nandabout:srcdoc\n. Default isfalse\n.\nSetIcon\nDeclarative event action that sets the n-dip square icon for the extension's page action or browser action while the corresponding conditions are met. This action can be used without host permissions, but the extension must have a page or browser action.\nExactly one of imageData\nor path\nmust be specified. Both are dictionaries mapping a number of pixels to an image representation. The image representation in imageData\nis an ImageData object; for example, from a canvas\nelement, while the image representation in path\nis the path to an image file relative to the extension's manifest. If scale\nscreen pixels fit into a device-independent pixel, the scale * n\nicon is used. If that scale is missing, another image is resized to the required size.\nProperties\n-\nconstructor\nvoid\nThe\nconstructor\nfunction looks like:(arg: SetIcon) => {...}\n-\narg\n-\nreturns\n-\n-\nimageData\nImageData | object optional\nEither an\nImageData\nobject or a dictionary {size -> ImageData} representing an icon to be set. If the icon is specified as a dictionary, the image used is chosen depending on the screen's pixel density. If the number of image pixels that fit into one screen space unit equalsscale\n, then an image with sizescale * n\nis selected, where n is the size of the icon in the UI. At least one image must be specified. Note thatdetails.imageData = foo\nis equivalent todetails.imageData = {'16': foo}\n.\nShowAction\nA declarative event action that sets the extension's toolbar action to an enabled state while the corresponding conditions are met. This action can be used without host permissions. If the extension has the activeTab permission, clicking the page action grants access to the active tab.\nOn pages where the conditions are not met the extension's toolbar action will be grey-scale, and clicking it will open the context menu, instead of triggering the action.\nProperties\n-\nconstructor\nvoid\nThe\nconstructor\nfunction looks like:(arg: ShowAction) => {...}\n-\narg\n-\nreturns\n-\nShowPageAction\nPlease use declarativeContent.ShowAction\n.\nA declarative event action that sets the extension's page action to an enabled state while the corresponding conditions are met. This action can be used without host permissions, but the extension must have a page action. If the extension has the activeTab permission, clicking the page action grants access to the active tab.\nOn pages where the conditions are not met the extension's toolbar action will be grey-scale, and clicking it will open the context menu, instead of triggering the action.\nProperties\n-\nconstructor\nvoid\nThe\nconstructor\nfunction looks like:(arg: ShowPageAction) => {...}\n-\narg\n-\nreturns\n-\nEvents\nonPageChanged\nProvides the Declarative Event API consisting of addRules\n, removeRules\n, and getRules\n."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/declarativeNetRequest", "title": "chrome.declarativeNetRequest | API | Chrome for Developers", "text": "Description\nThe chrome.declarativeNetRequest\nAPI is used to block or modify network requests by specifying declarative rules. This lets extensions modify network requests without intercepting them and viewing their content, thus providing more privacy.\nPermissions\ndeclarativeNetRequest\ndeclarativeNetRequestWithHostAccess\nThe \"declarativeNetRequest\n\" and \"declarativeNetRequestWithHostAccess\n\" permissions\nprovide the same capabilities. The differences between them is when permissions are\nrequested or granted.\n\"declarativeNetRequest\"\n- Triggers a permission warning at install time but provides implicit access to\nallow\n,allowAllRequests\nandblock\nrules. Use this when possible to avoid needing to request full access to hosts. \"declarativeNetRequestFeedback\"\n- Enables debugging features for unpacked extensions, specifically\ngetMatchedRules()\nandonRuleMatchedDebug\n. \"declarativeNetRequestWithHostAccess\"\n- A permission warning is not shown at install time, but you must request host permissions before you can perform any action on a host. This is appropriate when you want to use declarative net request rules in an extension which already has host permissions without generating additional warnings.\nAvailability\nManifest\nIn addition to the permissions described previously, certain types of rulesets, static rulesets specifically, require declaring the \"declarative_net_request\"\nmanifest key, which should be a dictionary with a single key called \"rule_resources\"\n. This key is an array containing dictionaries of type Ruleset\n, as shown in the following. (Note that the name 'Ruleset' does not appear in the manifest's JSON since it is merely an array.) Static rulesets are explained later in this document.\n{\n\"name\": \"My extension\",\n...\n\"declarative_net_request\" : {\n\"rule_resources\" : [{\n\"id\": \"ruleset_1\",\n\"enabled\": true,\n\"path\": \"rules_1.json\"\n}, {\n\"id\": \"ruleset_2\",\n\"enabled\": false,\n\"path\": \"rules_2.json\"\n}]\n},\n\"permissions\": [\n\"declarativeNetRequest\",\n\"declarativeNetRequestFeedback\",\n],\n\"host_permissions\": [\n\"http://www.blogger.com/*\",\n\"http://*.google.com/*\"\n],\n...\n}\nRules and rulesets\nTo use this API, specify one or more rulesets. A ruleset contains an array of rules. A single rule does one of the following:\n- Block a network request.\n- Upgrade the schema (http to https).\n- Prevent a request from getting blocked by negating any matching blocked rules.\n- Redirect a network request.\n- Modify request or response headers.\nThere are three types of rulesets, managed in slightly different ways.\n- Dynamic\n- Persist across browser sessions and extension upgrades and are managed using JavaScript while an extension is in use.\n- Session\n- Cleared when the browser shuts down and when a new version of the extension is installed. Session rules are managed using JavaScript while an extension is in use.\n- Static\n- Packaged, installed, and updated when an extension is installed or upgraded. Static rules are stored in JSON-formatted rule files and listed in the manifest file.\nDynamic and session-scoped rulesets\nDynamic and session rulesets are managed using JavaScript while an extension is in use.\n- Dynamic rules persist across browser sessions and extension upgrades.\n- Session rules are cleared when the browser shuts down and when a new version of the extension is installed.\nThere is only one each of these ruleset types. An extension can add or remove rules to them dynamically by calling updateDynamicRules()\nand updateSessionRules()\n, provided the rule limits aren't exceeded. For information on rule limits, see Rule limits. You can see an example of this under code examples.\nStatic rulesets\nUnlike dynamic and session rules, static rules are packaged, installed, and updated when an extension is installed or upgraded. They're stored in rule files in JSON format, which are indicated to the extension using the \"declarative_net_request\"\nand \"rule_resources\"\nkeys as described above, as well as one or more Ruleset\ndictionaries. A Ruleset\ndictionary contains a path to the rule file, an ID for the ruleset contained in the file, and whether the ruleset is enabled or disabled. The last two are important when you enable or disable a ruleset programmatically.\n{\n...\n\"declarative_net_request\" : {\n\"rule_resources\" : [{\n\"id\": \"ruleset_1\",\n\"enabled\": true,\n\"path\": \"rules_1.json\"\n},\n...\n]\n}\n...\n}\nTo test rule files, load your extension unpacked. Errors and warnings about invalid static rules are only displayed for unpacked extensions. Invalid static rules in packed extensions are ignored.\nExpedited review\nChanges to static rulesets may be eligible for expedited review. See expedited review for eligible changes.\nEnable and disable static rules and rulesets\nBoth individual static rules and complete static rulesets may be enabled or disabled at runtime.\nThe set of enabled static rules and rulesets is persisted across browser sessions. Neither are persisted across extension updates, meaning that only rules you chose to leave in your rule files are available after an update.\nFor performance reasons there are also limits to the number of rules and rulesets that may be enabled at one time. Call getAvailableStaticRuleCount()\nto check the number of additional rules that may be enabled. For information on rule limits, see Rule limits.\nTo enable or disable static rules, call updateStaticRules()\n. This method takes an UpdateStaticRulesOptions\nobject, which contains arrays of IDs of rules to enable or disable. The IDs are defined using the \"id\"\nkey of the Ruleset\ndictionary. There is a maximum limit of 5000 disabled static rules.\nTo enable or disable static rulesets, call updateEnabledRulesets()\n. This method takes an UpdateRulesetOptions\nobject, which contains arrays of IDs of rulesets to enable or disable. The IDs are defined using the \"id\"\nkey of the Ruleset\ndictionary.\nBuild rules\nRegardless of type, a rule starts with four fields as shown in the following. While the \"id\"\nand \"priority\"\nkeys take a number, the \"action\"\nand \"condition\"\nkeys may provide several blocking and redirecting conditions. The following rule blocks all script requests originating from \"foo.com\"\nto any URL with \"abc\"\nas a substring.\n{\n\"id\" : 1,\n\"priority\": 1,\n\"action\" : { \"type\" : \"block\" },\n\"condition\" : {\n\"urlFilter\" : \"abc\",\n\"initiatorDomains\" : [\"foo.com\"],\n\"resourceTypes\" : [\"script\"]\n}\n}\nURL matching\nDeclarative Net Request provides the ability to match URLs with either a pattern matching syntax or regular expressions.\nURL filter syntax\nA rule's \"condition\"\nkey allows a \"urlFilter\"\nkey for acting on URLs under a specified domain. You create patterns using pattern matching tokens. Here are a few examples.\nurlFilter |\nMatches | Does not match |\n|---|---|---|\n\"abc\" |\nhttps://abcd.com https://example.com/abcd |\nhttps://ab.com |\n\"abc*d\" |\nhttps://abcd.com https://example.com/abcxyzd |\nhttps://abc.com |\n\"||a.example.com\" |\nhttps://a.example.com/ https://b.a.example.com/xyz https://a.example.company |\nhttps://example.com/ |\n\"|https*\" |\nhttps://example.com | http://example.com/ http://https.com |\n\"example*^123|\" |\nhttps://example.com/123 http://abc.com/example?123 |\nhttps://example.com/1234 https://abc.com/example0123 |\nRegular expressions\nConditions can also use regular expressions. See the\n\"regexFilter\"\nkey. To learn about the\nlimits that apply to these conditions, see\nRules that use regular expressions.\nWrite good URL conditions\nTake care when writing rules to always match an entire domain. Otherwise, your rule may match in situations that are unexpected. For example, when using the pattern matching syntax:\ngoogle.com\nincorrectly matcheshttps://example.com/?param=google.com\n||google.com\nincorrectly matcheshttps://google.company\nhttps://www.google.com\nincorrectly matcheshttps://example.com/?param=https://www.google.com\nConsider using:\n||google.com/\n, which matches all paths and all subdomains.|https://www.google.com/\nwhich matches all paths and no subdomains.\nSimilarly, use the ^\nand /\ncharacters to anchor a regular expression. For\nexample, ^https:\\/\\/www\\.google\\.com\\/\nmatches any path on\nhttps://www.google.com.\nRule evaluation\nDNR rules are applied by the browser across various stages of the network request lifecycle.\nBefore the request\nBefore a request is made, an extension can block or redirect (including upgrading the scheme from HTTP to HTTPS) it with a matching rule.\nFor each extension, the browser determines a list of matching rules. Rules with a modifyHeaders\naction are not included here as they will be handled later. Additionally, rules with a responseHeaders\ncondition will be considered later (when response headers are available) and are not included.\nThen, for each extension, Chrome picks at most one candidate per request. Chrome finds a matching rule, by ordering all matching rules by priority. Rules with the same priority are ordered by action (allow\nor allowAllRequests\n> block\n> upgradeScheme\n> redirect\n).\nIf the candidate is an allow\nor allowAllRequests\nrule, or the frame the request is being made in previously matched an allowAllRequests\nrule of higher or equal priority from this extension, the request is \"allowed\" and the extension won't have any effect on the request.\nIf more than one extension wants to block or redirect this request, a single action to take is chosen. Chrome does this by sorting the rules in the order block\n> redirect\nor upgradeScheme\n> allow\nor allowAllRequests\n. If two rules are of the same type, Chrome chooses the rule from the most recently installed extension.\nBefore request headers are sent\nBefore Chrome sends request headers to the server, the headers are updated based on matching modifyHeaders\nrules.\nWithin a single extension, Chrome builds the list of modifications to perform by finding all matching modifyHeaders\nrules. Similar to before, only rules which have a higher priority than any matching allow\nor allowAllRequests\nrules are included.\nThese rules are applied by Chrome in an order such that rules from a more recently installed extension are always evaluated before rules from an older extension. Additionally, rules of a higher priority from one extension are always applied before rules of a lower priority from the same extension. Notably, even across extensions:\n- If a rule appends to a header, then lower priority rules can only append to that header. Set and remove operations are not allowed.\n- If a rule sets a header, then only lower priority rules from the same extension can append to that header. No other modifications are allowed.\n- If a rule removes a header, then lower priority rules cannot further modify the header.\nOnce a response is received\nOnce the response headers have been received, Chrome evaluates rules with a responseHeaders\ncondition.\nAfter sorting these rules by action\nand priority\nand excluding any rules made redundant by a matching allow\nor allowAllRequests\nrule (this happens identically to the steps in \"Before the request\"), Chrome may block or redirect the request on behalf of an extension.\nNote that if a request made it to this stage, the request has already been sent to the server and the server has received data like the request body. A block or redirect rule with a response headers condition will still run\u2013but cannot actually block or redirect the request.\nIn the case of a block rule, this is handled by the page which made the request receiving a blocked response and Chrome terminating the request early. In the case of a redirect rule, Chrome makes a new request to the redirected URL. Make sure to consider if these behaviors meet the privacy expectations for your extension.\nIf the request is not blocked or redirected, Chrome applies any modifyHeaders\nrules. Applying modifications to response headers works in the same way as described in \"Before request headers are sent\". Applying modifications to request headers does nothing, since the request has already been made.\nSafe rules\nSafe rules are defined as rules with an action of block\n, allow\n,\nallowAllRequests\nor upgradeScheme\n. These rules are subject to an increased\ndynamic rules quota.\nRule limits\nThere is a performance overhead to loading and evaluating rules in the browser, so some limits apply when using the API. Limits depend on the type of rule you're using.\nStatic rules\nStatic rules are those specified in rule files declared in the manifest file. An extension can specify up to 100 static rulesets as part of the \"rule_resources\"\nmanifest key, but only 50 of these rulesets can be enabled at a time. The latter is called the MAX_NUMBER_OF_ENABLED_STATIC_RULESETS\n. Collectively, those rulesets are guaranteed at least 30,000 rules. This is called the GUARANTEED_MINIMUM_STATIC_RULES\n.\nThe number of rules available after that depends on how many rules are enabled by all the extensions installed on a user's browser. You can find this number at runtime by calling getAvailableStaticRuleCount()\n. You can see an example of this under code examples.\nSession rules\nAn extension can have up to 5000 session rules. This is exposed as the\nMAX_NUMBER_OF_SESSION_RULES\n.\nBefore Chrome 120, there was a limit of 5000 combined dynamic and session rules.\nDynamic rules\nAn extension can have at least 5000 dynamic rules. This is exposed as the\nMAX_NUMBER_OF_UNSAFE_DYNAMIC_RULES\n.\nStarting in Chrome 121, there is a larger limit of 30,000 rules available for safe dynamic rules,\nexposed as the MAX_NUMBER_OF_DYNAMIC_RULES\n. Any\nunsafe rules added within the limit of 5000 will also count towards this limit.\nBefore Chrome 120, there was a 5000 combined dynamic and session rules limit.\nRules that use regular expressions\nAll types of rules can use regular expressions; however, the total number of regular expression rules of each type cannot exceed 1000. This is called the MAX_NUMBER_OF_REGEX_RULES.\nAdditionally, each rule must be less than 2KB once compiled. This roughly correlates with the complexity of the rule. If you try to load a rule that exceeds this limit, you will see a warning like the following and the rule will be ignored.\nrules_1.json: Rule with id 1 specified a more complex regex than allowed\nas part of the \"regexFilter\" key.\nInteractions with service workers\nA declarativeNetRequest only applies to requests that reach the network stack. This includes responses from the HTTP cache, but may not include responses that go through a service worker's onfetch\nhandler. declarativeNetRequest won't affect responses generated by the service worker or retrieved from CacheStorage\n, but it will affect calls to fetch()\nmade in a service worker.\nWeb accessible resources\nA declarativeNetRequest rule cannot redirect from a public resource request to a resource that is not web accessible. Doing so triggers an error. This is true even if the specified web accessible resource is owned by the redirecting extension. To declare resources for declarativeNetRequest, use the manifest's \"web_accessible_resources\"\narray.\nHeader modification\nThe append operation is only supported for the following headers: accept\n, accept-encoding\n, accept-language\n, access-control-request-headers\n, cache-control\n, connection\n, content-language\n, cookie\n, forwarded\n, if-match\n, if-none-match\n, keep-alive\n, range\n, te\n, trailer\n, transfer-encoding\n, upgrade\n, user-agent\n, via\n, want-digest\n, x-forwarded-for\n.\nExamples\nCode examples\nUpdate dynamic rules\nThe following example shows how to call updateDynamicRules()\n. The procedure for updateSessionRules()\nis the same.\n// Get arrays containing new and old rules\nconst newRules = await getNewRules();\nconst oldRules = await chrome.declarativeNetRequest.getDynamicRules();\nconst oldRuleIds = oldRules.map(rule => rule.id);\n// Use the arrays to update the dynamic rules\nawait chrome.declarativeNetRequest.updateDynamicRules({\nremoveRuleIds: oldRuleIds,\naddRules: newRules\n});\nUpdate static rulesets\nThe following example shows how to enable and disable rulesets while considering the number of available and the maximum number of enabled static rulesets. You would do this when the number of static rules you need exceeds the number allowed. For this to work, some of your rulesets should be installed with some of your rulesets disabled (setting \"Enabled\"\nto false\nwithin the manifest file).\nasync function updateStaticRules(enableRulesetIds, disableCandidateIds) {\n// Create the options structure for the call to updateEnabledRulesets()\nlet options = { enableRulesetIds: enableRulesetIds }\n// Get the number of enabled static rules\nconst enabledStaticCount = await chrome.declarativeNetRequest.getEnabledRulesets();\n// Compare rule counts to determine if anything needs to be disabled so that\n// new rules can be enabled\nconst proposedCount = enableRulesetIds.length;\nif (enabledStaticCount + proposedCount > chrome.declarativeNetRequest.MAX_NUMBER_OF_ENABLED_STATIC_RULESETS) {\noptions.disableRulesetIds = disableCandidateIds\n}\n// Update the enabled static rules\nawait chrome.declarativeNetRequest.updateEnabledRulesets(options);\n}\nRule examples\nThe following examples illustrate how Chrome prioritizes rules in an extension. When reviewing them, you may want to open the prioritization rules in a separate window.\nThe \"priority\" key\nThese examples require host permission to *://*.example.com/*\n.\nTo work out the priority of a particular URL, look at the (developer-defined) \"priority\"\nkey, the \"action\"\nkey and the \"urlFilter\"\nkey. These examples refer to the example rule file shown below them.\n- Navigation to https://google.com\n- Two rules cover this URL: the rules with IDs 1 and 4. The rule with ID 1 applies because\n\"block\"\nactions have a higher priority than\"redirect\"\nactions. The remaining rules don't apply because they are for longer URLs. - Navigation to https://google.com/1234\n- Because of the longer URL, the rule with ID 2 now matches in addition to the rules with IDs 1 and 4. The rule with ID 2 applies because\n\"allow\"\nhas a higher priority than\"block\"\nand\"redirect\"\n. - Navigation to https://google.com/12345\n- All four rules match this URL. The rule with ID 3 applies because its developer-defined priority is the highest of the group.\n[\n{\n\"id\": 1,\n\"priority\": 1,\n\"action\": { \"type\": \"block\" },\n\"condition\": {\"urlFilter\": \"||google.com/\", \"resourceTypes\": [\"main_frame\"] }\n},\n{\n\"id\": 2,\n\"priority\": 1,\n\"action\": { \"type\": \"allow\" },\n\"condition\": { \"urlFilter\": \"||google.com/123\", \"resourceTypes\": [\"main_frame\"] }\n},\n{\n\"id\": 3,\n\"priority\": 2,\n\"action\": { \"type\": \"block\" },\n\"condition\": { \"urlFilter\": \"||google.com/12345\", \"resourceTypes\": [\"main_frame\"] }\n},\n{\n\"id\": 4,\n\"priority\": 1,\n\"action\": { \"type\": \"redirect\", \"redirect\": { \"url\": \"https://example.com\" } },\n\"condition\": { \"urlFilter\": \"||google.com/\", \"resourceTypes\": [\"main_frame\"] }\n},\n]\nRedirects\nThe example below requires host permission to *://*.example.com/*\n.\nThe following example shows how to redirect a request from example.com to a page within the extension itself. The extension path /a.jpg\nresolves to chrome-extension://EXTENSION_ID/a.jpg\n, where EXTENSION_ID\nis the ID of your extension. For this to work the manifest should declare /a.jpg\nas a web accessible resource.\n{\n\"id\": 1,\n\"priority\": 1,\n\"action\": { \"type\": \"redirect\", \"redirect\": { \"extensionPath\": \"/a.jpg\" } },\n\"condition\": {\n\"urlFilter\": \"||https://www.example.com/\",\n\"resourceTypes\": [\"main_frame\"]\n}\n}\nThe following uses the \"transform\"\nkey to redirect to a subdomain of example.com. It uses a domain name anchor (\"||\") to intercept requests with any scheme from example.com. The \"scheme\"\nkey in \"transform\"\nspecifies that redirects to the subdomain will always use \"https\".\n{\n\"id\": 1,\n\"priority\": 1,\n\"action\": {\n\"type\": \"redirect\",\n\"redirect\": {\n\"transform\": { \"scheme\": \"https\", \"host\": \"new.example.com\" }\n}\n},\n\"condition\": {\n\"urlFilter\": \"||example.com/\",\n\"resourceTypes\": [\"main_frame\"]\n}\n}\nThe following example uses regular expressions to redirect from https://www.abc.xyz.com/path\nto https://abc.xyz.com/path\n. In the \"regexFilter\"\nkey, notice how periods are escaped and that the capturing group selects either \"abc\" or \"def\". The \"regexSubstitution\"\nkey specifies the first returned match of the regular expression using \"\\1\". In this case, \"abc\" is captured from the redirected URL and placed in the substitution.\n{\n\"id\": 1,\n\"priority\": 1,\n\"action\": {\n\"type\": \"redirect\",\n\"redirect\": {\n\"regexSubstitution\": \"https://\\\\1.xyz.com/\"\n}\n},\n\"condition\": {\n\"regexFilter\": \"^https://www\\\\.(abc|def)\\\\.xyz\\\\.com/\",\n\"resourceTypes\": [\n\"main_frame\"\n]\n}\n}\nHeaders\nThe following example removes all cookies from both a main frame and any sub frames.\n{\n\"id\": 1,\n\"priority\": 1,\n\"action\": {\n\"type\": \"modifyHeaders\",\n\"requestHeaders\": [{ \"header\": \"cookie\", \"operation\": \"remove\" }]\n},\n\"condition\": { \"resourceTypes\": [\"main_frame\", \"sub_frame\"] }\n}\nTypes\nDomainType\nThis describes whether the request is first or third party to the frame in which it originated. A request is said to be first party if it has the same domain (eTLD+1) as the frame in which the request originated.\nEnum\n\"firstParty\" \"thirdParty\"\nThe network request is first party to the frame in which it originated.\nThe network request is third party to the frame in which it originated.\nExtensionActionOptions\nProperties\n-\ndisplayActionCountAsBadgeText\nboolean optional\nWhether to automatically display the action count for a page as the extension's badge text. This preference is persisted across sessions.\n-\ntabUpdate\nTabActionCountUpdate optional\nChrome 89+Details of how the tab's action count should be adjusted.\nGetDisabledRuleIdsOptions\nProperties\n-\nrulesetId\nstring\nThe id corresponding to a static\nRuleset\n.\nGetRulesFilter\nProperties\n-\nruleIds\nnumber[] optional\nIf specified, only rules with matching IDs are included.\nHeaderInfo\nProperties\n-\nexcludedValues\nstring[] optional\nIf specified, this condition is not matched if the header exists but its value contains at least one element in this list. This uses the same match pattern syntax as\nvalues\n. -\nheader\nstring\nThe name of the header. This condition matches on the name only if both\nvalues\nandexcludedValues\nare not specified. -\nvalues\nstring[] optional\nIf specified, this condition matches if the header's value matches at least one pattern in this list. This supports case-insensitive header value matching plus the following constructs:\n'*' : Matches any number of characters.\n'?' : Matches zero or one character(s).\n'*' and '?' can be escaped with a backslash, e.g. '\\*' and '\\?'\nHeaderOperation\nThis describes the possible operations for a \"modifyHeaders\" rule.\nEnum\n\"append\" \"set\" \"remove\"\nAdds a new entry for the specified header. This operation is not supported for request headers.\nSets a new value for the specified header, removing any existing headers with the same name.\nRemoves all entries for the specified header.\nIsRegexSupportedResult\nProperties\n-\nisSupported\nboolean\n-\nreason\nUnsupportedRegexReason optional\nSpecifies the reason why the regular expression is not supported. Only provided if\nisSupported\nis false.\nMatchedRule\nProperties\n-\nruleId\nnumber\nA matching rule's ID.\n-\nrulesetId\nstring\nID of the\nRuleset\nthis rule belongs to. For a rule originating from the set of dynamic rules, this will be equal toDYNAMIC_RULESET_ID\n.\nMatchedRuleInfo\nProperties\n-\nrule\n-\ntabId\nnumber\nThe tabId of the tab from which the request originated if the tab is still active. Else -1.\n-\ntimeStamp\nnumber\nThe time the rule was matched. Timestamps will correspond to the Javascript convention for times, i.e. number of milliseconds since the epoch.\nMatchedRuleInfoDebug\nProperties\n-\nrequest\nDetails about the request for which the rule was matched.\n-\nrule\nMatchedRulesFilter\nProperties\n-\nminTimeStamp\nnumber optional\nIf specified, only matches rules after the given timestamp.\n-\ntabId\nnumber optional\nIf specified, only matches rules for the given tab. Matches rules not associated with any active tab if set to -1.\nModifyHeaderInfo\nProperties\n-\nheader\nstring\nThe name of the header to be modified.\n-\noperation\nThe operation to be performed on a header.\n-\nvalue\nstring optional\nThe new value for the header. Must be specified for\nappend\nandset\noperations.\nQueryKeyValue\nProperties\n-\nkey\nstring\n-\nreplaceOnly\nboolean optional\nChrome 94+If true, the query key is replaced only if it's already present. Otherwise, the key is also added if it's missing. Defaults to false.\n-\nvalue\nstring\nQueryTransform\nProperties\n-\naddOrReplaceParams\nQueryKeyValue[] optional\nThe list of query key-value pairs to be added or replaced.\n-\nremoveParams\nstring[] optional\nThe list of query keys to be removed.\nRedirect\nProperties\n-\nextensionPath\nstring optional\nPath relative to the extension directory. Should start with '/'.\n-\nregexSubstitution\nstring optional\nSubstitution pattern for rules which specify a\nregexFilter\n. The first match ofregexFilter\nwithin the url will be replaced with this pattern. WithinregexSubstitution\n, backslash-escaped digits (\\1 to \\9) can be used to insert the corresponding capture groups. \\0 refers to the entire matching text. -\ntransform\nURLTransform optional\nUrl transformations to perform.\n-\nurl\nstring optional\nThe redirect url. Redirects to JavaScript urls are not allowed.\nRegexOptions\nProperties\n-\nisCaseSensitive\nboolean optional\nWhether the\nregex\nspecified is case sensitive. Default is true. -\nregex\nstring\nThe regular expresson to check.\n-\nrequireCapturing\nboolean optional\nWhether the\nregex\nspecified requires capturing. Capturing is only required for redirect rules which specify aregexSubstition\naction. The default is false.\nRequestDetails\nProperties\n-\ndocumentId\nstring optional\nChrome 106+The unique identifier for the frame's document, if this request is for a frame.\n-\ndocumentLifecycle\nDocumentLifecycle optional\nChrome 106+The lifecycle of the frame's document, if this request is for a frame.\n-\nframeId\nnumber\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (\ntype\nismain_frame\norsub_frame\n),frameId\nindicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. -\nframeType\nFrameType optional\nChrome 106+The type of the frame, if this request is for a frame.\n-\ninitiator\nstring optional\nThe origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n-\nmethod\nstring\nStandard HTTP method.\n-\nparentDocumentId\nstring optional\nChrome 106+The unique identifier for the frame's parent document, if this request is for a frame and has a parent.\n-\nparentFrameId\nnumber\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session.\n-\ntabId\nnumber\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n-\ntype\nThe resource type of the request.\n-\nurl\nstring\nThe URL of the request.\nRequestMethod\nThis describes the HTTP request method of a network request.\nEnum\n\"connect\" \"delete\" \"get\" \"head\" \"options\" \"patch\" \"post\" \"put\" \"other\"\nResourceType\nThis describes the resource type of the network request.\nEnum\n\"main_frame\" \"sub_frame\" \"stylesheet\" \"script\" \"image\" \"font\" \"object\" \"xmlhttprequest\" \"ping\" \"csp_report\" \"media\" \"websocket\" \"webtransport\" \"webbundle\" \"other\"\nRule\nProperties\n-\naction\nThe action to take if this rule is matched.\n-\ncondition\nThe condition under which this rule is triggered.\n-\nid\nnumber\nAn id which uniquely identifies a rule. Mandatory and should be >= 1.\n-\npriority\nnumber optional\nRule priority. Defaults to 1. When specified, should be >= 1.\nRuleAction\nProperties\n-\nredirect\nRedirect optional\nDescribes how the redirect should be performed. Only valid for redirect rules.\n-\nrequestHeaders\nModifyHeaderInfo[] optional\nChrome 86+The request headers to modify for the request. Only valid if RuleActionType is \"modifyHeaders\".\n-\nresponseHeaders\nModifyHeaderInfo[] optional\nChrome 86+The response headers to modify for the request. Only valid if RuleActionType is \"modifyHeaders\".\n-\ntype\nThe type of action to perform.\nRuleActionType\nDescribes the kind of action to take if a given RuleCondition matches.\nEnum\n\"block\" \"redirect\" \"allow\" \"upgradeScheme\" \"modifyHeaders\" \"allowAllRequests\"\nBlock the network request.\nRedirect the network request.\nAllow the network request. The request won't be intercepted if there is an allow rule which matches it.\nUpgrade the network request url's scheme to https if the request is http or ftp.\nModify request/response headers from the network request.\nAllow all requests within a frame hierarchy, including the frame request itself.\nRuleCondition\nProperties\n-\ndomainType\nDomainType optional\nSpecifies whether the network request is first-party or third-party to the domain from which it originated. If omitted, all requests are accepted.\n-\ndomains\nstring[] optional\nDeprecated since Chrome 101Use\ninitiatorDomains\ninsteadThe rule will only match network requests originating from the list of\ndomains\n. -\nexcludedDomains\nstring[] optional\nDeprecated since Chrome 101Use\nexcludedInitiatorDomains\ninsteadThe rule will not match network requests originating from the list of\nexcludedDomains\n. -\nexcludedInitiatorDomains\nstring[] optional\nChrome 101+The rule will not match network requests originating from the list of\nexcludedInitiatorDomains\n. If the list is empty or omitted, no domains are excluded. This takes precedence overinitiatorDomains\n.Notes:\n- Sub-domains like \"a.example.com\" are also allowed.\n- The entries must consist of only ascii characters.\n- Use punycode encoding for internationalized domains.\n- This matches against the request initiator and not the request url.\n- Sub-domains of the listed domains are also excluded.\n-\nexcludedRequestDomains\nstring[] optional\nChrome 101+The rule will not match network requests when the domains matches one from the list of\nexcludedRequestDomains\n. If the list is empty or omitted, no domains are excluded. This takes precedence overrequestDomains\n.Notes:\n- Sub-domains like \"a.example.com\" are also allowed.\n- The entries must consist of only ascii characters.\n- Use punycode encoding for internationalized domains.\n- Sub-domains of the listed domains are also excluded.\n-\nexcludedRequestMethods\nRequestMethod[] optional\nChrome 91+List of request methods which the rule won't match. Only one of\nrequestMethods\nandexcludedRequestMethods\nshould be specified. If neither of them is specified, all request methods are matched. -\nexcludedResourceTypes\nResourceType[] optional\nList of resource types which the rule won't match. Only one of\nresourceTypes\nandexcludedResourceTypes\nshould be specified. If neither of them is specified, all resource types except \"main_frame\" are blocked. -\nexcludedResponseHeaders\nHeaderInfo[] optional\nChrome 128+Rule does not match if the request matches any response header condition in this list (if specified). If both\nexcludedResponseHeaders\nandresponseHeaders\nare specified, then theexcludedResponseHeaders\nproperty takes precedence. -\nexcludedTabIds\nnumber[] optional\nChrome 92+List of\ntabs.Tab.id\nwhich the rule should not match. An ID oftabs.TAB_ID_NONE\nexcludes requests which don't originate from a tab. Only supported for session-scoped rules. -\ninitiatorDomains\nstring[] optional\nChrome 101+The rule will only match network requests originating from the list of\ninitiatorDomains\n. If the list is omitted, the rule is applied to requests from all domains. An empty list is not allowed.Notes:\n- Sub-domains like \"a.example.com\" are also allowed.\n- The entries must consist of only ascii characters.\n- Use punycode encoding for internationalized domains.\n- This matches against the request initiator and not the request url.\n- Sub-domains of the listed domains are also matched.\n-\nisUrlFilterCaseSensitive\nboolean optional\nWhether the\nurlFilter\norregexFilter\n(whichever is specified) is case sensitive. Default is false. -\nregexFilter\nstring optional\nRegular expression to match against the network request url. This follows the RE2 syntax.\nNote: Only one of\nurlFilter\norregexFilter\ncan be specified.Note: The\nregexFilter\nmust be composed of only ASCII characters. This is matched against a url where the host is encoded in the punycode format (in case of internationalized domains) and any other non-ascii characters are url encoded in utf-8. -\nrequestDomains\nstring[] optional\nChrome 101+The rule will only match network requests when the domain matches one from the list of\nrequestDomains\n. If the list is omitted, the rule is applied to requests from all domains. An empty list is not allowed.Notes:\n- Sub-domains like \"a.example.com\" are also allowed.\n- The entries must consist of only ascii characters.\n- Use punycode encoding for internationalized domains.\n- Sub-domains of the listed domains are also matched.\n-\nrequestMethods\nRequestMethod[] optional\nChrome 91+List of HTTP request methods which the rule can match. An empty list is not allowed.\nNote: Specifying a\nrequestMethods\nrule condition will also exclude non-HTTP(s) requests, whereas specifyingexcludedRequestMethods\nwill not. -\nresourceTypes\nResourceType[] optional\nList of resource types which the rule can match. An empty list is not allowed.\nNote: this must be specified for\nallowAllRequests\nrules and may only include thesub_frame\nandmain_frame\nresource types. -\nresponseHeaders\nHeaderInfo[] optional\nChrome 128+Rule matches if the request matches any response header condition in this list (if specified).\n-\ntabIds\nnumber[] optional\nChrome 92+List of\ntabs.Tab.id\nwhich the rule should match. An ID oftabs.TAB_ID_NONE\nmatches requests which don't originate from a tab. An empty list is not allowed. Only supported for session-scoped rules. -\nurlFilter\nstring optional\nThe pattern which is matched against the network request url. Supported constructs:\n'*' : Wildcard: Matches any number of characters.\n'|' : Left/right anchor: If used at either end of the pattern, specifies the beginning/end of the url respectively.\n'||' : Domain name anchor: If used at the beginning of the pattern, specifies the start of a (sub-)domain of the URL.\n'^' : Separator character: This matches anything except a letter, a digit, or one of the following:\n_\n,-\n,.\n, or%\n. This also match the end of the URL.Therefore\nurlFilter\nis composed of the following parts: (optional Left/Domain name anchor) + pattern + (optional Right anchor).If omitted, all urls are matched. An empty string is not allowed.\nA pattern beginning with\n||*\nis not allowed. Use*\ninstead.Note: Only one of\nurlFilter\norregexFilter\ncan be specified.Note: The\nurlFilter\nmust be composed of only ASCII characters. This is matched against a url where the host is encoded in the punycode format (in case of internationalized domains) and any other non-ascii characters are url encoded in utf-8. For example, when the request url is http://abc.\u0440\u0444?q=\u0444, theurlFilter\nwill be matched against the url http://abc.xn--p1ai/?q=%D1%84.\nRuleset\nProperties\n-\nenabled\nboolean\nWhether the ruleset is enabled by default.\n-\nid\nstring\nA non-empty string uniquely identifying the ruleset. IDs beginning with '_' are reserved for internal use.\n-\npath\nstring\nThe path of the JSON ruleset relative to the extension directory.\nRulesMatchedDetails\nProperties\n-\nrulesMatchedInfo\nRules matching the given filter.\nTabActionCountUpdate\nProperties\n-\nincrement\nnumber\nThe amount to increment the tab's action count by. Negative values will decrement the count.\n-\ntabId\nnumber\nThe tab for which to update the action count.\nTestMatchOutcomeResult\nProperties\n-\nmatchedRules\nThe rules (if any) that match the hypothetical request.\nTestMatchRequestDetails\nProperties\n-\ninitiator\nstring optional\nThe initiator URL (if any) for the hypothetical request.\n-\nmethod\nRequestMethod optional\nStandard HTTP method of the hypothetical request. Defaults to \"get\" for HTTP requests and is ignored for non-HTTP requests.\n-\nresponseHeaders\nobject optional\nChrome 129+The headers provided by a hypothetical response if the request does not get blocked or redirected before it is sent. Represented as an object which maps a header name to a list of string values. If not specified, the hypothetical response would return empty response headers, which can match rules which match on the non-existence of headers. E.g.\n{\"content-type\": [\"text/html; charset=utf-8\", \"multipart/form-data\"]}\n-\ntabId\nnumber optional\nThe ID of the tab in which the hypothetical request takes place. Does not need to correspond to a real tab ID. Default is -1, meaning that the request isn't related to a tab.\n-\ntype\nThe resource type of the hypothetical request.\n-\nurl\nstring\nThe URL of the hypothetical request.\nUnsupportedRegexReason\nDescribes the reason why a given regular expression isn't supported.\nEnum\n\"syntaxError\" \"memoryLimitExceeded\"\nThe regular expression is syntactically incorrect, or uses features not available in the RE2 syntax.\nThe regular expression exceeds the memory limit.\nUpdateRuleOptions\nProperties\n-\naddRules\nRule[] optional\nRules to add.\n-\nremoveRuleIds\nnumber[] optional\nIDs of the rules to remove. Any invalid IDs will be ignored.\nUpdateRulesetOptions\nProperties\nUpdateStaticRulesOptions\nProperties\nURLTransform\nProperties\n-\nfragment\nstring optional\nThe new fragment for the request. Should be either empty, in which case the existing fragment is cleared; or should begin with '#'.\n-\nhost\nstring optional\nThe new host for the request.\n-\npassword\nstring optional\nThe new password for the request.\n-\npath\nstring optional\nThe new path for the request. If empty, the existing path is cleared.\n-\nport\nstring optional\nThe new port for the request. If empty, the existing port is cleared.\n-\nquery\nstring optional\nThe new query for the request. Should be either empty, in which case the existing query is cleared; or should begin with '?'.\n-\nqueryTransform\nQueryTransform optional\nAdd, remove or replace query key-value pairs.\n-\nscheme\nstring optional\nThe new scheme for the request. Allowed values are \"http\", \"https\", \"ftp\" and \"chrome-extension\".\n-\nusername\nstring optional\nThe new username for the request.\nProperties\nDYNAMIC_RULESET_ID\nRuleset ID for the dynamic rules added by the extension.\nValue\n\"_dynamic\"\nGETMATCHEDRULES_QUOTA_INTERVAL\nTime interval within which MAX_GETMATCHEDRULES_CALLS_PER_INTERVAL getMatchedRules\ncalls can be made, specified in minutes. Additional calls will fail immediately and set runtime.lastError\n. Note: getMatchedRules\ncalls associated with a user gesture are exempt from the quota.\nValue\n10\nGUARANTEED_MINIMUM_STATIC_RULES\nThe minimum number of static rules guaranteed to an extension across its enabled static rulesets. Any rules above this limit will count towards the global static rule limit.\nValue\n30000\nMAX_GETMATCHEDRULES_CALLS_PER_INTERVAL\nThe number of times getMatchedRules\ncan be called within a period of GETMATCHEDRULES_QUOTA_INTERVAL\n.\nValue\n20\nMAX_NUMBER_OF_DYNAMIC_RULES\nThe maximum number of dynamic rules that an extension can add.\nValue\n30000\nMAX_NUMBER_OF_ENABLED_STATIC_RULESETS\nThe maximum number of static Rulesets\nan extension can enable at any one time.\nValue\n50\nMAX_NUMBER_OF_REGEX_RULES\nThe maximum number of regular expression rules that an extension can add. This limit is evaluated separately for the set of dynamic rules and those specified in the rule resources file.\nValue\n1000\nMAX_NUMBER_OF_SESSION_RULES\nThe maximum number of session scoped rules that an extension can add.\nValue\n5000\nMAX_NUMBER_OF_STATIC_RULESETS\nThe maximum number of static Rulesets\nan extension can specify as part of the \"rule_resources\"\nmanifest key.\nValue\n100\nMAX_NUMBER_OF_UNSAFE_DYNAMIC_RULES\nThe maximum number of \"unsafe\" dynamic rules that an extension can add.\nValue\n5000\nMAX_NUMBER_OF_UNSAFE_SESSION_RULES\nThe maximum number of \"unsafe\" session scoped rules that an extension can add.\nValue\n5000\nSESSION_RULESET_ID\nRuleset ID for the session-scoped rules added by the extension.\nValue\n\"_session\"\nMethods\ngetAvailableStaticRuleCount()\nchrome.declarativeNetRequest.getAvailableStaticRuleCount(\ncallback?: function,\n)\nReturns the number of static rules an extension can enable before the global static rule limit is reached.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(count: number) => void\n-\ncount\nnumber\n-\nReturns\n-\nPromise<number>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetDisabledRuleIds()\nchrome.declarativeNetRequest.getDisabledRuleIds(\noptions: GetDisabledRuleIdsOptions,\ncallback?: function,\n)\nReturns the list of static rules in the given Ruleset\nthat are currently disabled.\nParameters\n-\noptions\nSpecifies the ruleset to query.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(disabledRuleIds: number[]) => void\n-\ndisabledRuleIds\nnumber[]\n-\nReturns\n-\nPromise<number[]>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetDynamicRules()\nchrome.declarativeNetRequest.getDynamicRules(\nfilter?: GetRulesFilter,\ncallback?: function,\n)\nReturns the current set of dynamic rules for the extension. Callers can optionally filter the list of fetched rules by specifying a filter\n.\nParameters\n-\nfilter\nGetRulesFilter optional\nChrome 111+An object to filter the list of fetched rules.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(rules: Rule[]) => void\n-\nrules\nRule[]\n-\nReturns\n-\nPromise<Rule[]>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetEnabledRulesets()\nchrome.declarativeNetRequest.getEnabledRulesets(\ncallback?: function,\n)\nReturns the ids for the current set of enabled static rulesets.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(rulesetIds: string[]) => void\n-\nrulesetIds\nstring[]\n-\nReturns\n-\nPromise<string[]>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetMatchedRules()\nchrome.declarativeNetRequest.getMatchedRules(\nfilter?: MatchedRulesFilter,\ncallback?: function,\n)\nReturns all rules matched for the extension. Callers can optionally filter the list of matched rules by specifying a filter\n. This method is only available to extensions with the \"declarativeNetRequestFeedback\"\npermission or having the \"activeTab\"\npermission granted for the tabId\nspecified in filter\n. Note: Rules not associated with an active document that were matched more than five minutes ago will not be returned.\nParameters\n-\nfilter\nMatchedRulesFilter optional\nAn object to filter the list of matched rules.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(details: RulesMatchedDetails) => void\n-\ndetails\n-\nReturns\n-\nPromise<RulesMatchedDetails>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetSessionRules()\nchrome.declarativeNetRequest.getSessionRules(\nfilter?: GetRulesFilter,\ncallback?: function,\n)\nReturns the current set of session scoped rules for the extension. Callers can optionally filter the list of fetched rules by specifying a filter\n.\nParameters\n-\nfilter\nGetRulesFilter optional\nChrome 111+An object to filter the list of fetched rules.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(rules: Rule[]) => void\n-\nrules\nRule[]\n-\nReturns\n-\nPromise<Rule[]>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nisRegexSupported()\nchrome.declarativeNetRequest.isRegexSupported(\nregexOptions: RegexOptions,\ncallback?: function,\n)\nChecks if the given regular expression will be supported as a regexFilter\nrule condition.\nParameters\n-\nregexOptions\nThe regular expression to check.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: IsRegexSupportedResult) => void\n-\nresult\n-\nReturns\n-\nPromise<IsRegexSupportedResult>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetExtensionActionOptions()\nchrome.declarativeNetRequest.setExtensionActionOptions(\noptions: ExtensionActionOptions,\ncallback?: function,\n)\nConfigures if the action count for tabs should be displayed as the extension action's badge text and provides a way for that action count to be incremented.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nChrome 89+The\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ntestMatchOutcome()\nchrome.declarativeNetRequest.testMatchOutcome(\nrequest: TestMatchRequestDetails,\ncallback?: function,\n)\nChecks if any of the extension's declarativeNetRequest rules would match a hypothetical request. Note: Only available for unpacked extensions as this is only intended to be used during extension development.\nParameters\n-\nrequest\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: TestMatchOutcomeResult) => void\n-\nresult\n-\nReturns\n-\nPromise<TestMatchOutcomeResult>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdateDynamicRules()\nchrome.declarativeNetRequest.updateDynamicRules(\noptions: UpdateRuleOptions,\ncallback?: function,\n)\nModifies the current set of dynamic rules for the extension. The rules with IDs listed in options.removeRuleIds\nare first removed, and then the rules given in options.addRules\nare added. Notes:\n- This update happens as a single atomic operation: either all specified rules are added and removed, or an error is returned.\n- These rules are persisted across browser sessions and across extension updates.\n- Static rules specified as part of the extension package can not be removed using this function.\nMAX_NUMBER_OF_DYNAMIC_RULES\nis the maximum number of dynamic rules an extension can add. The number of unsafe rules must not exceedMAX_NUMBER_OF_UNSAFE_DYNAMIC_RULES\n.\nParameters\n-\noptionsChrome 87+\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdateEnabledRulesets()\nchrome.declarativeNetRequest.updateEnabledRulesets(\noptions: UpdateRulesetOptions,\ncallback?: function,\n)\nUpdates the set of enabled static rulesets for the extension. The rulesets with IDs listed in options.disableRulesetIds\nare first removed, and then the rulesets listed in options.enableRulesetIds\nare added.\nNote that the set of enabled static rulesets is persisted across sessions but not across extension updates, i.e. the rule_resources\nmanifest key will determine the set of enabled static rulesets on each extension update.\nParameters\n-\noptionsChrome 87+\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdateSessionRules()\nchrome.declarativeNetRequest.updateSessionRules(\noptions: UpdateRuleOptions,\ncallback?: function,\n)\nModifies the current set of session scoped rules for the extension. The rules with IDs listed in options.removeRuleIds\nare first removed, and then the rules given in options.addRules\nare added. Notes:\n- This update happens as a single atomic operation: either all specified rules are added and removed, or an error is returned.\n- These rules are not persisted across sessions and are backed in memory.\nMAX_NUMBER_OF_SESSION_RULES\nis the maximum number of session rules an extension can add.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdateStaticRules()\nchrome.declarativeNetRequest.updateStaticRules(\noptions: UpdateStaticRulesOptions,\ncallback?: function,\n)\nDisables and enables individual static rules in a Ruleset\n. Changes to rules belonging to a disabled Ruleset\nwill take effect the next time that it becomes enabled.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonRuleMatchedDebug\nchrome.declarativeNetRequest.onRuleMatchedDebug.addListener(\ncallback: function,\n)\nFired when a rule is matched with a request. Only available for unpacked extensions with the \"declarativeNetRequestFeedback\"\npermission as this is intended to be used for debugging purposes only.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(info: MatchedRuleInfoDebug) => void\n-\ninfo\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/declarativeNetRequest", "title": "chrome.declarativeNetRequest | API | Chrome for Developers", "text": "Description\nThe chrome.declarativeNetRequest\nAPI is used to block or modify network requests by specifying declarative rules. This lets extensions modify network requests without intercepting them and viewing their content, thus providing more privacy.\nPermissions\ndeclarativeNetRequest\ndeclarativeNetRequestWithHostAccess\nThe \"declarativeNetRequest\n\" and \"declarativeNetRequestWithHostAccess\n\" permissions\nprovide the same capabilities. The differences between them is when permissions are\nrequested or granted.\n\"declarativeNetRequest\"\n- Triggers a permission warning at install time but provides implicit access to\nallow\n,allowAllRequests\nandblock\nrules. Use this when possible to avoid needing to request full access to hosts. \"declarativeNetRequestFeedback\"\n- Enables debugging features for unpacked extensions, specifically\ngetMatchedRules()\nandonRuleMatchedDebug\n. \"declarativeNetRequestWithHostAccess\"\n- A permission warning is not shown at install time, but you must request host permissions before you can perform any action on a host. This is appropriate when you want to use declarative net request rules in an extension which already has host permissions without generating additional warnings.\nAvailability\nManifest\nIn addition to the permissions described previously, certain types of rulesets, static rulesets specifically, require declaring the \"declarative_net_request\"\nmanifest key, which should be a dictionary with a single key called \"rule_resources\"\n. This key is an array containing dictionaries of type Ruleset\n, as shown in the following. (Note that the name 'Ruleset' does not appear in the manifest's JSON since it is merely an array.) Static rulesets are explained later in this document.\n{\n\"name\": \"My extension\",\n...\n\"declarative_net_request\" : {\n\"rule_resources\" : [{\n\"id\": \"ruleset_1\",\n\"enabled\": true,\n\"path\": \"rules_1.json\"\n}, {\n\"id\": \"ruleset_2\",\n\"enabled\": false,\n\"path\": \"rules_2.json\"\n}]\n},\n\"permissions\": [\n\"declarativeNetRequest\",\n\"declarativeNetRequestFeedback\",\n],\n\"host_permissions\": [\n\"http://www.blogger.com/*\",\n\"http://*.google.com/*\"\n],\n...\n}\nRules and rulesets\nTo use this API, specify one or more rulesets. A ruleset contains an array of rules. A single rule does one of the following:\n- Block a network request.\n- Upgrade the schema (http to https).\n- Prevent a request from getting blocked by negating any matching blocked rules.\n- Redirect a network request.\n- Modify request or response headers.\nThere are three types of rulesets, managed in slightly different ways.\n- Dynamic\n- Persist across browser sessions and extension upgrades and are managed using JavaScript while an extension is in use.\n- Session\n- Cleared when the browser shuts down and when a new version of the extension is installed. Session rules are managed using JavaScript while an extension is in use.\n- Static\n- Packaged, installed, and updated when an extension is installed or upgraded. Static rules are stored in JSON-formatted rule files and listed in the manifest file.\nDynamic and session-scoped rulesets\nDynamic and session rulesets are managed using JavaScript while an extension is in use.\n- Dynamic rules persist across browser sessions and extension upgrades.\n- Session rules are cleared when the browser shuts down and when a new version of the extension is installed.\nThere is only one each of these ruleset types. An extension can add or remove rules to them dynamically by calling updateDynamicRules()\nand updateSessionRules()\n, provided the rule limits aren't exceeded. For information on rule limits, see Rule limits. You can see an example of this under code examples.\nStatic rulesets\nUnlike dynamic and session rules, static rules are packaged, installed, and updated when an extension is installed or upgraded. They're stored in rule files in JSON format, which are indicated to the extension using the \"declarative_net_request\"\nand \"rule_resources\"\nkeys as described above, as well as one or more Ruleset\ndictionaries. A Ruleset\ndictionary contains a path to the rule file, an ID for the ruleset contained in the file, and whether the ruleset is enabled or disabled. The last two are important when you enable or disable a ruleset programmatically.\n{\n...\n\"declarative_net_request\" : {\n\"rule_resources\" : [{\n\"id\": \"ruleset_1\",\n\"enabled\": true,\n\"path\": \"rules_1.json\"\n},\n...\n]\n}\n...\n}\nTo test rule files, load your extension unpacked. Errors and warnings about invalid static rules are only displayed for unpacked extensions. Invalid static rules in packed extensions are ignored.\nExpedited review\nChanges to static rulesets may be eligible for expedited review. See expedited review for eligible changes.\nEnable and disable static rules and rulesets\nBoth individual static rules and complete static rulesets may be enabled or disabled at runtime.\nThe set of enabled static rules and rulesets is persisted across browser sessions. Neither are persisted across extension updates, meaning that only rules you chose to leave in your rule files are available after an update.\nFor performance reasons there are also limits to the number of rules and rulesets that may be enabled at one time. Call getAvailableStaticRuleCount()\nto check the number of additional rules that may be enabled. For information on rule limits, see Rule limits.\nTo enable or disable static rules, call updateStaticRules()\n. This method takes an UpdateStaticRulesOptions\nobject, which contains arrays of IDs of rules to enable or disable. The IDs are defined using the \"id\"\nkey of the Ruleset\ndictionary. There is a maximum limit of 5000 disabled static rules.\nTo enable or disable static rulesets, call updateEnabledRulesets()\n. This method takes an UpdateRulesetOptions\nobject, which contains arrays of IDs of rulesets to enable or disable. The IDs are defined using the \"id\"\nkey of the Ruleset\ndictionary.\nBuild rules\nRegardless of type, a rule starts with four fields as shown in the following. While the \"id\"\nand \"priority\"\nkeys take a number, the \"action\"\nand \"condition\"\nkeys may provide several blocking and redirecting conditions. The following rule blocks all script requests originating from \"foo.com\"\nto any URL with \"abc\"\nas a substring.\n{\n\"id\" : 1,\n\"priority\": 1,\n\"action\" : { \"type\" : \"block\" },\n\"condition\" : {\n\"urlFilter\" : \"abc\",\n\"initiatorDomains\" : [\"foo.com\"],\n\"resourceTypes\" : [\"script\"]\n}\n}\nURL matching\nDeclarative Net Request provides the ability to match URLs with either a pattern matching syntax or regular expressions.\nURL filter syntax\nA rule's \"condition\"\nkey allows a \"urlFilter\"\nkey for acting on URLs under a specified domain. You create patterns using pattern matching tokens. Here are a few examples.\nurlFilter |\nMatches | Does not match |\n|---|---|---|\n\"abc\" |\nhttps://abcd.com https://example.com/abcd |\nhttps://ab.com |\n\"abc*d\" |\nhttps://abcd.com https://example.com/abcxyzd |\nhttps://abc.com |\n\"||a.example.com\" |\nhttps://a.example.com/ https://b.a.example.com/xyz https://a.example.company |\nhttps://example.com/ |\n\"|https*\" |\nhttps://example.com | http://example.com/ http://https.com |\n\"example*^123|\" |\nhttps://example.com/123 http://abc.com/example?123 |\nhttps://example.com/1234 https://abc.com/example0123 |\nRegular expressions\nConditions can also use regular expressions. See the\n\"regexFilter\"\nkey. To learn about the\nlimits that apply to these conditions, see\nRules that use regular expressions.\nWrite good URL conditions\nTake care when writing rules to always match an entire domain. Otherwise, your rule may match in situations that are unexpected. For example, when using the pattern matching syntax:\ngoogle.com\nincorrectly matcheshttps://example.com/?param=google.com\n||google.com\nincorrectly matcheshttps://google.company\nhttps://www.google.com\nincorrectly matcheshttps://example.com/?param=https://www.google.com\nConsider using:\n||google.com/\n, which matches all paths and all subdomains.|https://www.google.com/\nwhich matches all paths and no subdomains.\nSimilarly, use the ^\nand /\ncharacters to anchor a regular expression. For\nexample, ^https:\\/\\/www\\.google\\.com\\/\nmatches any path on\nhttps://www.google.com.\nRule evaluation\nDNR rules are applied by the browser across various stages of the network request lifecycle.\nBefore the request\nBefore a request is made, an extension can block or redirect (including upgrading the scheme from HTTP to HTTPS) it with a matching rule.\nFor each extension, the browser determines a list of matching rules. Rules with a modifyHeaders\naction are not included here as they will be handled later. Additionally, rules with a responseHeaders\ncondition will be considered later (when response headers are available) and are not included.\nThen, for each extension, Chrome picks at most one candidate per request. Chrome finds a matching rule, by ordering all matching rules by priority. Rules with the same priority are ordered by action (allow\nor allowAllRequests\n> block\n> upgradeScheme\n> redirect\n).\nIf the candidate is an allow\nor allowAllRequests\nrule, or the frame the request is being made in previously matched an allowAllRequests\nrule of higher or equal priority from this extension, the request is \"allowed\" and the extension won't have any effect on the request.\nIf more than one extension wants to block or redirect this request, a single action to take is chosen. Chrome does this by sorting the rules in the order block\n> redirect\nor upgradeScheme\n> allow\nor allowAllRequests\n. If two rules are of the same type, Chrome chooses the rule from the most recently installed extension.\nBefore request headers are sent\nBefore Chrome sends request headers to the server, the headers are updated based on matching modifyHeaders\nrules.\nWithin a single extension, Chrome builds the list of modifications to perform by finding all matching modifyHeaders\nrules. Similar to before, only rules which have a higher priority than any matching allow\nor allowAllRequests\nrules are included.\nThese rules are applied by Chrome in an order such that rules from a more recently installed extension are always evaluated before rules from an older extension. Additionally, rules of a higher priority from one extension are always applied before rules of a lower priority from the same extension. Notably, even across extensions:\n- If a rule appends to a header, then lower priority rules can only append to that header. Set and remove operations are not allowed.\n- If a rule sets a header, then only lower priority rules from the same extension can append to that header. No other modifications are allowed.\n- If a rule removes a header, then lower priority rules cannot further modify the header.\nOnce a response is received\nOnce the response headers have been received, Chrome evaluates rules with a responseHeaders\ncondition.\nAfter sorting these rules by action\nand priority\nand excluding any rules made redundant by a matching allow\nor allowAllRequests\nrule (this happens identically to the steps in \"Before the request\"), Chrome may block or redirect the request on behalf of an extension.\nNote that if a request made it to this stage, the request has already been sent to the server and the server has received data like the request body. A block or redirect rule with a response headers condition will still run\u2013but cannot actually block or redirect the request.\nIn the case of a block rule, this is handled by the page which made the request receiving a blocked response and Chrome terminating the request early. In the case of a redirect rule, Chrome makes a new request to the redirected URL. Make sure to consider if these behaviors meet the privacy expectations for your extension.\nIf the request is not blocked or redirected, Chrome applies any modifyHeaders\nrules. Applying modifications to response headers works in the same way as described in \"Before request headers are sent\". Applying modifications to request headers does nothing, since the request has already been made.\nSafe rules\nSafe rules are defined as rules with an action of block\n, allow\n,\nallowAllRequests\nor upgradeScheme\n. These rules are subject to an increased\ndynamic rules quota.\nRule limits\nThere is a performance overhead to loading and evaluating rules in the browser, so some limits apply when using the API. Limits depend on the type of rule you're using.\nStatic rules\nStatic rules are those specified in rule files declared in the manifest file. An extension can specify up to 100 static rulesets as part of the \"rule_resources\"\nmanifest key, but only 50 of these rulesets can be enabled at a time. The latter is called the MAX_NUMBER_OF_ENABLED_STATIC_RULESETS\n. Collectively, those rulesets are guaranteed at least 30,000 rules. This is called the GUARANTEED_MINIMUM_STATIC_RULES\n.\nThe number of rules available after that depends on how many rules are enabled by all the extensions installed on a user's browser. You can find this number at runtime by calling getAvailableStaticRuleCount()\n. You can see an example of this under code examples.\nSession rules\nAn extension can have up to 5000 session rules. This is exposed as the\nMAX_NUMBER_OF_SESSION_RULES\n.\nBefore Chrome 120, there was a limit of 5000 combined dynamic and session rules.\nDynamic rules\nAn extension can have at least 5000 dynamic rules. This is exposed as the\nMAX_NUMBER_OF_UNSAFE_DYNAMIC_RULES\n.\nStarting in Chrome 121, there is a larger limit of 30,000 rules available for safe dynamic rules,\nexposed as the MAX_NUMBER_OF_DYNAMIC_RULES\n. Any\nunsafe rules added within the limit of 5000 will also count towards this limit.\nBefore Chrome 120, there was a 5000 combined dynamic and session rules limit.\nRules that use regular expressions\nAll types of rules can use regular expressions; however, the total number of regular expression rules of each type cannot exceed 1000. This is called the MAX_NUMBER_OF_REGEX_RULES.\nAdditionally, each rule must be less than 2KB once compiled. This roughly correlates with the complexity of the rule. If you try to load a rule that exceeds this limit, you will see a warning like the following and the rule will be ignored.\nrules_1.json: Rule with id 1 specified a more complex regex than allowed\nas part of the \"regexFilter\" key.\nInteractions with service workers\nA declarativeNetRequest only applies to requests that reach the network stack. This includes responses from the HTTP cache, but may not include responses that go through a service worker's onfetch\nhandler. declarativeNetRequest won't affect responses generated by the service worker or retrieved from CacheStorage\n, but it will affect calls to fetch()\nmade in a service worker.\nWeb accessible resources\nA declarativeNetRequest rule cannot redirect from a public resource request to a resource that is not web accessible. Doing so triggers an error. This is true even if the specified web accessible resource is owned by the redirecting extension. To declare resources for declarativeNetRequest, use the manifest's \"web_accessible_resources\"\narray.\nHeader modification\nThe append operation is only supported for the following headers: accept\n, accept-encoding\n, accept-language\n, access-control-request-headers\n, cache-control\n, connection\n, content-language\n, cookie\n, forwarded\n, if-match\n, if-none-match\n, keep-alive\n, range\n, te\n, trailer\n, transfer-encoding\n, upgrade\n, user-agent\n, via\n, want-digest\n, x-forwarded-for\n.\nExamples\nCode examples\nUpdate dynamic rules\nThe following example shows how to call updateDynamicRules()\n. The procedure for updateSessionRules()\nis the same.\n// Get arrays containing new and old rules\nconst newRules = await getNewRules();\nconst oldRules = await chrome.declarativeNetRequest.getDynamicRules();\nconst oldRuleIds = oldRules.map(rule => rule.id);\n// Use the arrays to update the dynamic rules\nawait chrome.declarativeNetRequest.updateDynamicRules({\nremoveRuleIds: oldRuleIds,\naddRules: newRules\n});\nUpdate static rulesets\nThe following example shows how to enable and disable rulesets while considering the number of available and the maximum number of enabled static rulesets. You would do this when the number of static rules you need exceeds the number allowed. For this to work, some of your rulesets should be installed with some of your rulesets disabled (setting \"Enabled\"\nto false\nwithin the manifest file).\nasync function updateStaticRules(enableRulesetIds, disableCandidateIds) {\n// Create the options structure for the call to updateEnabledRulesets()\nlet options = { enableRulesetIds: enableRulesetIds }\n// Get the number of enabled static rules\nconst enabledStaticCount = await chrome.declarativeNetRequest.getEnabledRulesets();\n// Compare rule counts to determine if anything needs to be disabled so that\n// new rules can be enabled\nconst proposedCount = enableRulesetIds.length;\nif (enabledStaticCount + proposedCount > chrome.declarativeNetRequest.MAX_NUMBER_OF_ENABLED_STATIC_RULESETS) {\noptions.disableRulesetIds = disableCandidateIds\n}\n// Update the enabled static rules\nawait chrome.declarativeNetRequest.updateEnabledRulesets(options);\n}\nRule examples\nThe following examples illustrate how Chrome prioritizes rules in an extension. When reviewing them, you may want to open the prioritization rules in a separate window.\nThe \"priority\" key\nThese examples require host permission to *://*.example.com/*\n.\nTo work out the priority of a particular URL, look at the (developer-defined) \"priority\"\nkey, the \"action\"\nkey and the \"urlFilter\"\nkey. These examples refer to the example rule file shown below them.\n- Navigation to https://google.com\n- Two rules cover this URL: the rules with IDs 1 and 4. The rule with ID 1 applies because\n\"block\"\nactions have a higher priority than\"redirect\"\nactions. The remaining rules don't apply because they are for longer URLs. - Navigation to https://google.com/1234\n- Because of the longer URL, the rule with ID 2 now matches in addition to the rules with IDs 1 and 4. The rule with ID 2 applies because\n\"allow\"\nhas a higher priority than\"block\"\nand\"redirect\"\n. - Navigation to https://google.com/12345\n- All four rules match this URL. The rule with ID 3 applies because its developer-defined priority is the highest of the group.\n[\n{\n\"id\": 1,\n\"priority\": 1,\n\"action\": { \"type\": \"block\" },\n\"condition\": {\"urlFilter\": \"||google.com/\", \"resourceTypes\": [\"main_frame\"] }\n},\n{\n\"id\": 2,\n\"priority\": 1,\n\"action\": { \"type\": \"allow\" },\n\"condition\": { \"urlFilter\": \"||google.com/123\", \"resourceTypes\": [\"main_frame\"] }\n},\n{\n\"id\": 3,\n\"priority\": 2,\n\"action\": { \"type\": \"block\" },\n\"condition\": { \"urlFilter\": \"||google.com/12345\", \"resourceTypes\": [\"main_frame\"] }\n},\n{\n\"id\": 4,\n\"priority\": 1,\n\"action\": { \"type\": \"redirect\", \"redirect\": { \"url\": \"https://example.com\" } },\n\"condition\": { \"urlFilter\": \"||google.com/\", \"resourceTypes\": [\"main_frame\"] }\n},\n]\nRedirects\nThe example below requires host permission to *://*.example.com/*\n.\nThe following example shows how to redirect a request from example.com to a page within the extension itself. The extension path /a.jpg\nresolves to chrome-extension://EXTENSION_ID/a.jpg\n, where EXTENSION_ID\nis the ID of your extension. For this to work the manifest should declare /a.jpg\nas a web accessible resource.\n{\n\"id\": 1,\n\"priority\": 1,\n\"action\": { \"type\": \"redirect\", \"redirect\": { \"extensionPath\": \"/a.jpg\" } },\n\"condition\": {\n\"urlFilter\": \"||https://www.example.com/\",\n\"resourceTypes\": [\"main_frame\"]\n}\n}\nThe following uses the \"transform\"\nkey to redirect to a subdomain of example.com. It uses a domain name anchor (\"||\") to intercept requests with any scheme from example.com. The \"scheme\"\nkey in \"transform\"\nspecifies that redirects to the subdomain will always use \"https\".\n{\n\"id\": 1,\n\"priority\": 1,\n\"action\": {\n\"type\": \"redirect\",\n\"redirect\": {\n\"transform\": { \"scheme\": \"https\", \"host\": \"new.example.com\" }\n}\n},\n\"condition\": {\n\"urlFilter\": \"||example.com/\",\n\"resourceTypes\": [\"main_frame\"]\n}\n}\nThe following example uses regular expressions to redirect from https://www.abc.xyz.com/path\nto https://abc.xyz.com/path\n. In the \"regexFilter\"\nkey, notice how periods are escaped and that the capturing group selects either \"abc\" or \"def\". The \"regexSubstitution\"\nkey specifies the first returned match of the regular expression using \"\\1\". In this case, \"abc\" is captured from the redirected URL and placed in the substitution.\n{\n\"id\": 1,\n\"priority\": 1,\n\"action\": {\n\"type\": \"redirect\",\n\"redirect\": {\n\"regexSubstitution\": \"https://\\\\1.xyz.com/\"\n}\n},\n\"condition\": {\n\"regexFilter\": \"^https://www\\\\.(abc|def)\\\\.xyz\\\\.com/\",\n\"resourceTypes\": [\n\"main_frame\"\n]\n}\n}\nHeaders\nThe following example removes all cookies from both a main frame and any sub frames.\n{\n\"id\": 1,\n\"priority\": 1,\n\"action\": {\n\"type\": \"modifyHeaders\",\n\"requestHeaders\": [{ \"header\": \"cookie\", \"operation\": \"remove\" }]\n},\n\"condition\": { \"resourceTypes\": [\"main_frame\", \"sub_frame\"] }\n}\nTypes\nDomainType\nThis describes whether the request is first or third party to the frame in which it originated. A request is said to be first party if it has the same domain (eTLD+1) as the frame in which the request originated.\nEnum\n\"firstParty\" \"thirdParty\"\nThe network request is first party to the frame in which it originated.\nThe network request is third party to the frame in which it originated.\nExtensionActionOptions\nProperties\n-\ndisplayActionCountAsBadgeText\nboolean optional\nWhether to automatically display the action count for a page as the extension's badge text. This preference is persisted across sessions.\n-\ntabUpdate\nTabActionCountUpdate optional\nChrome 89+Details of how the tab's action count should be adjusted.\nGetDisabledRuleIdsOptions\nProperties\n-\nrulesetId\nstring\nThe id corresponding to a static\nRuleset\n.\nGetRulesFilter\nProperties\n-\nruleIds\nnumber[] optional\nIf specified, only rules with matching IDs are included.\nHeaderInfo\nProperties\n-\nexcludedValues\nstring[] optional\nIf specified, this condition is not matched if the header exists but its value contains at least one element in this list. This uses the same match pattern syntax as\nvalues\n. -\nheader\nstring\nThe name of the header. This condition matches on the name only if both\nvalues\nandexcludedValues\nare not specified. -\nvalues\nstring[] optional\nIf specified, this condition matches if the header's value matches at least one pattern in this list. This supports case-insensitive header value matching plus the following constructs:\n'*' : Matches any number of characters.\n'?' : Matches zero or one character(s).\n'*' and '?' can be escaped with a backslash, e.g. '\\*' and '\\?'\nHeaderOperation\nThis describes the possible operations for a \"modifyHeaders\" rule.\nEnum\n\"append\" \"set\" \"remove\"\nAdds a new entry for the specified header. This operation is not supported for request headers.\nSets a new value for the specified header, removing any existing headers with the same name.\nRemoves all entries for the specified header.\nIsRegexSupportedResult\nProperties\n-\nisSupported\nboolean\n-\nreason\nUnsupportedRegexReason optional\nSpecifies the reason why the regular expression is not supported. Only provided if\nisSupported\nis false.\nMatchedRule\nProperties\n-\nruleId\nnumber\nA matching rule's ID.\n-\nrulesetId\nstring\nID of the\nRuleset\nthis rule belongs to. For a rule originating from the set of dynamic rules, this will be equal toDYNAMIC_RULESET_ID\n.\nMatchedRuleInfo\nProperties\n-\nrule\n-\ntabId\nnumber\nThe tabId of the tab from which the request originated if the tab is still active. Else -1.\n-\ntimeStamp\nnumber\nThe time the rule was matched. Timestamps will correspond to the Javascript convention for times, i.e. number of milliseconds since the epoch.\nMatchedRuleInfoDebug\nProperties\n-\nrequest\nDetails about the request for which the rule was matched.\n-\nrule\nMatchedRulesFilter\nProperties\n-\nminTimeStamp\nnumber optional\nIf specified, only matches rules after the given timestamp.\n-\ntabId\nnumber optional\nIf specified, only matches rules for the given tab. Matches rules not associated with any active tab if set to -1.\nModifyHeaderInfo\nProperties\n-\nheader\nstring\nThe name of the header to be modified.\n-\noperation\nThe operation to be performed on a header.\n-\nvalue\nstring optional\nThe new value for the header. Must be specified for\nappend\nandset\noperations.\nQueryKeyValue\nProperties\n-\nkey\nstring\n-\nreplaceOnly\nboolean optional\nChrome 94+If true, the query key is replaced only if it's already present. Otherwise, the key is also added if it's missing. Defaults to false.\n-\nvalue\nstring\nQueryTransform\nProperties\n-\naddOrReplaceParams\nQueryKeyValue[] optional\nThe list of query key-value pairs to be added or replaced.\n-\nremoveParams\nstring[] optional\nThe list of query keys to be removed.\nRedirect\nProperties\n-\nextensionPath\nstring optional\nPath relative to the extension directory. Should start with '/'.\n-\nregexSubstitution\nstring optional\nSubstitution pattern for rules which specify a\nregexFilter\n. The first match ofregexFilter\nwithin the url will be replaced with this pattern. WithinregexSubstitution\n, backslash-escaped digits (\\1 to \\9) can be used to insert the corresponding capture groups. \\0 refers to the entire matching text. -\ntransform\nURLTransform optional\nUrl transformations to perform.\n-\nurl\nstring optional\nThe redirect url. Redirects to JavaScript urls are not allowed.\nRegexOptions\nProperties\n-\nisCaseSensitive\nboolean optional\nWhether the\nregex\nspecified is case sensitive. Default is true. -\nregex\nstring\nThe regular expresson to check.\n-\nrequireCapturing\nboolean optional\nWhether the\nregex\nspecified requires capturing. Capturing is only required for redirect rules which specify aregexSubstition\naction. The default is false.\nRequestDetails\nProperties\n-\ndocumentId\nstring optional\nChrome 106+The unique identifier for the frame's document, if this request is for a frame.\n-\ndocumentLifecycle\nDocumentLifecycle optional\nChrome 106+The lifecycle of the frame's document, if this request is for a frame.\n-\nframeId\nnumber\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (\ntype\nismain_frame\norsub_frame\n),frameId\nindicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. -\nframeType\nFrameType optional\nChrome 106+The type of the frame, if this request is for a frame.\n-\ninitiator\nstring optional\nThe origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n-\nmethod\nstring\nStandard HTTP method.\n-\nparentDocumentId\nstring optional\nChrome 106+The unique identifier for the frame's parent document, if this request is for a frame and has a parent.\n-\nparentFrameId\nnumber\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session.\n-\ntabId\nnumber\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n-\ntype\nThe resource type of the request.\n-\nurl\nstring\nThe URL of the request.\nRequestMethod\nThis describes the HTTP request method of a network request.\nEnum\n\"connect\" \"delete\" \"get\" \"head\" \"options\" \"patch\" \"post\" \"put\" \"other\"\nResourceType\nThis describes the resource type of the network request.\nEnum\n\"main_frame\" \"sub_frame\" \"stylesheet\" \"script\" \"image\" \"font\" \"object\" \"xmlhttprequest\" \"ping\" \"csp_report\" \"media\" \"websocket\" \"webtransport\" \"webbundle\" \"other\"\nRule\nProperties\n-\naction\nThe action to take if this rule is matched.\n-\ncondition\nThe condition under which this rule is triggered.\n-\nid\nnumber\nAn id which uniquely identifies a rule. Mandatory and should be >= 1.\n-\npriority\nnumber optional\nRule priority. Defaults to 1. When specified, should be >= 1.\nRuleAction\nProperties\n-\nredirect\nRedirect optional\nDescribes how the redirect should be performed. Only valid for redirect rules.\n-\nrequestHeaders\nModifyHeaderInfo[] optional\nChrome 86+The request headers to modify for the request. Only valid if RuleActionType is \"modifyHeaders\".\n-\nresponseHeaders\nModifyHeaderInfo[] optional\nChrome 86+The response headers to modify for the request. Only valid if RuleActionType is \"modifyHeaders\".\n-\ntype\nThe type of action to perform.\nRuleActionType\nDescribes the kind of action to take if a given RuleCondition matches.\nEnum\n\"block\" \"redirect\" \"allow\" \"upgradeScheme\" \"modifyHeaders\" \"allowAllRequests\"\nBlock the network request.\nRedirect the network request.\nAllow the network request. The request won't be intercepted if there is an allow rule which matches it.\nUpgrade the network request url's scheme to https if the request is http or ftp.\nModify request/response headers from the network request.\nAllow all requests within a frame hierarchy, including the frame request itself.\nRuleCondition\nProperties\n-\ndomainType\nDomainType optional\nSpecifies whether the network request is first-party or third-party to the domain from which it originated. If omitted, all requests are accepted.\n-\ndomains\nstring[] optional\nDeprecated since Chrome 101Use\ninitiatorDomains\ninsteadThe rule will only match network requests originating from the list of\ndomains\n. -\nexcludedDomains\nstring[] optional\nDeprecated since Chrome 101Use\nexcludedInitiatorDomains\ninsteadThe rule will not match network requests originating from the list of\nexcludedDomains\n. -\nexcludedInitiatorDomains\nstring[] optional\nChrome 101+The rule will not match network requests originating from the list of\nexcludedInitiatorDomains\n. If the list is empty or omitted, no domains are excluded. This takes precedence overinitiatorDomains\n.Notes:\n- Sub-domains like \"a.example.com\" are also allowed.\n- The entries must consist of only ascii characters.\n- Use punycode encoding for internationalized domains.\n- This matches against the request initiator and not the request url.\n- Sub-domains of the listed domains are also excluded.\n-\nexcludedRequestDomains\nstring[] optional\nChrome 101+The rule will not match network requests when the domains matches one from the list of\nexcludedRequestDomains\n. If the list is empty or omitted, no domains are excluded. This takes precedence overrequestDomains\n.Notes:\n- Sub-domains like \"a.example.com\" are also allowed.\n- The entries must consist of only ascii characters.\n- Use punycode encoding for internationalized domains.\n- Sub-domains of the listed domains are also excluded.\n-\nexcludedRequestMethods\nRequestMethod[] optional\nChrome 91+List of request methods which the rule won't match. Only one of\nrequestMethods\nandexcludedRequestMethods\nshould be specified. If neither of them is specified, all request methods are matched. -\nexcludedResourceTypes\nResourceType[] optional\nList of resource types which the rule won't match. Only one of\nresourceTypes\nandexcludedResourceTypes\nshould be specified. If neither of them is specified, all resource types except \"main_frame\" are blocked. -\nexcludedResponseHeaders\nHeaderInfo[] optional\nChrome 128+Rule does not match if the request matches any response header condition in this list (if specified). If both\nexcludedResponseHeaders\nandresponseHeaders\nare specified, then theexcludedResponseHeaders\nproperty takes precedence. -\nexcludedTabIds\nnumber[] optional\nChrome 92+List of\ntabs.Tab.id\nwhich the rule should not match. An ID oftabs.TAB_ID_NONE\nexcludes requests which don't originate from a tab. Only supported for session-scoped rules. -\ninitiatorDomains\nstring[] optional\nChrome 101+The rule will only match network requests originating from the list of\ninitiatorDomains\n. If the list is omitted, the rule is applied to requests from all domains. An empty list is not allowed.Notes:\n- Sub-domains like \"a.example.com\" are also allowed.\n- The entries must consist of only ascii characters.\n- Use punycode encoding for internationalized domains.\n- This matches against the request initiator and not the request url.\n- Sub-domains of the listed domains are also matched.\n-\nisUrlFilterCaseSensitive\nboolean optional\nWhether the\nurlFilter\norregexFilter\n(whichever is specified) is case sensitive. Default is false. -\nregexFilter\nstring optional\nRegular expression to match against the network request url. This follows the RE2 syntax.\nNote: Only one of\nurlFilter\norregexFilter\ncan be specified.Note: The\nregexFilter\nmust be composed of only ASCII characters. This is matched against a url where the host is encoded in the punycode format (in case of internationalized domains) and any other non-ascii characters are url encoded in utf-8. -\nrequestDomains\nstring[] optional\nChrome 101+The rule will only match network requests when the domain matches one from the list of\nrequestDomains\n. If the list is omitted, the rule is applied to requests from all domains. An empty list is not allowed.Notes:\n- Sub-domains like \"a.example.com\" are also allowed.\n- The entries must consist of only ascii characters.\n- Use punycode encoding for internationalized domains.\n- Sub-domains of the listed domains are also matched.\n-\nrequestMethods\nRequestMethod[] optional\nChrome 91+List of HTTP request methods which the rule can match. An empty list is not allowed.\nNote: Specifying a\nrequestMethods\nrule condition will also exclude non-HTTP(s) requests, whereas specifyingexcludedRequestMethods\nwill not. -\nresourceTypes\nResourceType[] optional\nList of resource types which the rule can match. An empty list is not allowed.\nNote: this must be specified for\nallowAllRequests\nrules and may only include thesub_frame\nandmain_frame\nresource types. -\nresponseHeaders\nHeaderInfo[] optional\nChrome 128+Rule matches if the request matches any response header condition in this list (if specified).\n-\ntabIds\nnumber[] optional\nChrome 92+List of\ntabs.Tab.id\nwhich the rule should match. An ID oftabs.TAB_ID_NONE\nmatches requests which don't originate from a tab. An empty list is not allowed. Only supported for session-scoped rules. -\nurlFilter\nstring optional\nThe pattern which is matched against the network request url. Supported constructs:\n'*' : Wildcard: Matches any number of characters.\n'|' : Left/right anchor: If used at either end of the pattern, specifies the beginning/end of the url respectively.\n'||' : Domain name anchor: If used at the beginning of the pattern, specifies the start of a (sub-)domain of the URL.\n'^' : Separator character: This matches anything except a letter, a digit, or one of the following:\n_\n,-\n,.\n, or%\n. This also match the end of the URL.Therefore\nurlFilter\nis composed of the following parts: (optional Left/Domain name anchor) + pattern + (optional Right anchor).If omitted, all urls are matched. An empty string is not allowed.\nA pattern beginning with\n||*\nis not allowed. Use*\ninstead.Note: Only one of\nurlFilter\norregexFilter\ncan be specified.Note: The\nurlFilter\nmust be composed of only ASCII characters. This is matched against a url where the host is encoded in the punycode format (in case of internationalized domains) and any other non-ascii characters are url encoded in utf-8. For example, when the request url is http://abc.\u0440\u0444?q=\u0444, theurlFilter\nwill be matched against the url http://abc.xn--p1ai/?q=%D1%84.\nRuleset\nProperties\n-\nenabled\nboolean\nWhether the ruleset is enabled by default.\n-\nid\nstring\nA non-empty string uniquely identifying the ruleset. IDs beginning with '_' are reserved for internal use.\n-\npath\nstring\nThe path of the JSON ruleset relative to the extension directory.\nRulesMatchedDetails\nProperties\n-\nrulesMatchedInfo\nRules matching the given filter.\nTabActionCountUpdate\nProperties\n-\nincrement\nnumber\nThe amount to increment the tab's action count by. Negative values will decrement the count.\n-\ntabId\nnumber\nThe tab for which to update the action count.\nTestMatchOutcomeResult\nProperties\n-\nmatchedRules\nThe rules (if any) that match the hypothetical request.\nTestMatchRequestDetails\nProperties\n-\ninitiator\nstring optional\nThe initiator URL (if any) for the hypothetical request.\n-\nmethod\nRequestMethod optional\nStandard HTTP method of the hypothetical request. Defaults to \"get\" for HTTP requests and is ignored for non-HTTP requests.\n-\nresponseHeaders\nobject optional\nChrome 129+The headers provided by a hypothetical response if the request does not get blocked or redirected before it is sent. Represented as an object which maps a header name to a list of string values. If not specified, the hypothetical response would return empty response headers, which can match rules which match on the non-existence of headers. E.g.\n{\"content-type\": [\"text/html; charset=utf-8\", \"multipart/form-data\"]}\n-\ntabId\nnumber optional\nThe ID of the tab in which the hypothetical request takes place. Does not need to correspond to a real tab ID. Default is -1, meaning that the request isn't related to a tab.\n-\ntype\nThe resource type of the hypothetical request.\n-\nurl\nstring\nThe URL of the hypothetical request.\nUnsupportedRegexReason\nDescribes the reason why a given regular expression isn't supported.\nEnum\n\"syntaxError\" \"memoryLimitExceeded\"\nThe regular expression is syntactically incorrect, or uses features not available in the RE2 syntax.\nThe regular expression exceeds the memory limit.\nUpdateRuleOptions\nProperties\n-\naddRules\nRule[] optional\nRules to add.\n-\nremoveRuleIds\nnumber[] optional\nIDs of the rules to remove. Any invalid IDs will be ignored.\nUpdateRulesetOptions\nProperties\nUpdateStaticRulesOptions\nProperties\nURLTransform\nProperties\n-\nfragment\nstring optional\nThe new fragment for the request. Should be either empty, in which case the existing fragment is cleared; or should begin with '#'.\n-\nhost\nstring optional\nThe new host for the request.\n-\npassword\nstring optional\nThe new password for the request.\n-\npath\nstring optional\nThe new path for the request. If empty, the existing path is cleared.\n-\nport\nstring optional\nThe new port for the request. If empty, the existing port is cleared.\n-\nquery\nstring optional\nThe new query for the request. Should be either empty, in which case the existing query is cleared; or should begin with '?'.\n-\nqueryTransform\nQueryTransform optional\nAdd, remove or replace query key-value pairs.\n-\nscheme\nstring optional\nThe new scheme for the request. Allowed values are \"http\", \"https\", \"ftp\" and \"chrome-extension\".\n-\nusername\nstring optional\nThe new username for the request.\nProperties\nDYNAMIC_RULESET_ID\nRuleset ID for the dynamic rules added by the extension.\nValue\n\"_dynamic\"\nGETMATCHEDRULES_QUOTA_INTERVAL\nTime interval within which MAX_GETMATCHEDRULES_CALLS_PER_INTERVAL getMatchedRules\ncalls can be made, specified in minutes. Additional calls will fail immediately and set runtime.lastError\n. Note: getMatchedRules\ncalls associated with a user gesture are exempt from the quota.\nValue\n10\nGUARANTEED_MINIMUM_STATIC_RULES\nThe minimum number of static rules guaranteed to an extension across its enabled static rulesets. Any rules above this limit will count towards the global static rule limit.\nValue\n30000\nMAX_GETMATCHEDRULES_CALLS_PER_INTERVAL\nThe number of times getMatchedRules\ncan be called within a period of GETMATCHEDRULES_QUOTA_INTERVAL\n.\nValue\n20\nMAX_NUMBER_OF_DYNAMIC_RULES\nThe maximum number of dynamic rules that an extension can add.\nValue\n30000\nMAX_NUMBER_OF_ENABLED_STATIC_RULESETS\nThe maximum number of static Rulesets\nan extension can enable at any one time.\nValue\n50\nMAX_NUMBER_OF_REGEX_RULES\nThe maximum number of regular expression rules that an extension can add. This limit is evaluated separately for the set of dynamic rules and those specified in the rule resources file.\nValue\n1000\nMAX_NUMBER_OF_SESSION_RULES\nThe maximum number of session scoped rules that an extension can add.\nValue\n5000\nMAX_NUMBER_OF_STATIC_RULESETS\nThe maximum number of static Rulesets\nan extension can specify as part of the \"rule_resources\"\nmanifest key.\nValue\n100\nMAX_NUMBER_OF_UNSAFE_DYNAMIC_RULES\nThe maximum number of \"unsafe\" dynamic rules that an extension can add.\nValue\n5000\nMAX_NUMBER_OF_UNSAFE_SESSION_RULES\nThe maximum number of \"unsafe\" session scoped rules that an extension can add.\nValue\n5000\nSESSION_RULESET_ID\nRuleset ID for the session-scoped rules added by the extension.\nValue\n\"_session\"\nMethods\ngetAvailableStaticRuleCount()\nchrome.declarativeNetRequest.getAvailableStaticRuleCount(\ncallback?: function,\n)\nReturns the number of static rules an extension can enable before the global static rule limit is reached.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(count: number) => void\n-\ncount\nnumber\n-\nReturns\n-\nPromise<number>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetDisabledRuleIds()\nchrome.declarativeNetRequest.getDisabledRuleIds(\noptions: GetDisabledRuleIdsOptions,\ncallback?: function,\n)\nReturns the list of static rules in the given Ruleset\nthat are currently disabled.\nParameters\n-\noptions\nSpecifies the ruleset to query.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(disabledRuleIds: number[]) => void\n-\ndisabledRuleIds\nnumber[]\n-\nReturns\n-\nPromise<number[]>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetDynamicRules()\nchrome.declarativeNetRequest.getDynamicRules(\nfilter?: GetRulesFilter,\ncallback?: function,\n)\nReturns the current set of dynamic rules for the extension. Callers can optionally filter the list of fetched rules by specifying a filter\n.\nParameters\n-\nfilter\nGetRulesFilter optional\nChrome 111+An object to filter the list of fetched rules.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(rules: Rule[]) => void\n-\nrules\nRule[]\n-\nReturns\n-\nPromise<Rule[]>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetEnabledRulesets()\nchrome.declarativeNetRequest.getEnabledRulesets(\ncallback?: function,\n)\nReturns the ids for the current set of enabled static rulesets.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(rulesetIds: string[]) => void\n-\nrulesetIds\nstring[]\n-\nReturns\n-\nPromise<string[]>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetMatchedRules()\nchrome.declarativeNetRequest.getMatchedRules(\nfilter?: MatchedRulesFilter,\ncallback?: function,\n)\nReturns all rules matched for the extension. Callers can optionally filter the list of matched rules by specifying a filter\n. This method is only available to extensions with the \"declarativeNetRequestFeedback\"\npermission or having the \"activeTab\"\npermission granted for the tabId\nspecified in filter\n. Note: Rules not associated with an active document that were matched more than five minutes ago will not be returned.\nParameters\n-\nfilter\nMatchedRulesFilter optional\nAn object to filter the list of matched rules.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(details: RulesMatchedDetails) => void\n-\ndetails\n-\nReturns\n-\nPromise<RulesMatchedDetails>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetSessionRules()\nchrome.declarativeNetRequest.getSessionRules(\nfilter?: GetRulesFilter,\ncallback?: function,\n)\nReturns the current set of session scoped rules for the extension. Callers can optionally filter the list of fetched rules by specifying a filter\n.\nParameters\n-\nfilter\nGetRulesFilter optional\nChrome 111+An object to filter the list of fetched rules.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(rules: Rule[]) => void\n-\nrules\nRule[]\n-\nReturns\n-\nPromise<Rule[]>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nisRegexSupported()\nchrome.declarativeNetRequest.isRegexSupported(\nregexOptions: RegexOptions,\ncallback?: function,\n)\nChecks if the given regular expression will be supported as a regexFilter\nrule condition.\nParameters\n-\nregexOptions\nThe regular expression to check.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: IsRegexSupportedResult) => void\n-\nresult\n-\nReturns\n-\nPromise<IsRegexSupportedResult>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetExtensionActionOptions()\nchrome.declarativeNetRequest.setExtensionActionOptions(\noptions: ExtensionActionOptions,\ncallback?: function,\n)\nConfigures if the action count for tabs should be displayed as the extension action's badge text and provides a way for that action count to be incremented.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nChrome 89+The\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ntestMatchOutcome()\nchrome.declarativeNetRequest.testMatchOutcome(\nrequest: TestMatchRequestDetails,\ncallback?: function,\n)\nChecks if any of the extension's declarativeNetRequest rules would match a hypothetical request. Note: Only available for unpacked extensions as this is only intended to be used during extension development.\nParameters\n-\nrequest\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: TestMatchOutcomeResult) => void\n-\nresult\n-\nReturns\n-\nPromise<TestMatchOutcomeResult>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdateDynamicRules()\nchrome.declarativeNetRequest.updateDynamicRules(\noptions: UpdateRuleOptions,\ncallback?: function,\n)\nModifies the current set of dynamic rules for the extension. The rules with IDs listed in options.removeRuleIds\nare first removed, and then the rules given in options.addRules\nare added. Notes:\n- This update happens as a single atomic operation: either all specified rules are added and removed, or an error is returned.\n- These rules are persisted across browser sessions and across extension updates.\n- Static rules specified as part of the extension package can not be removed using this function.\nMAX_NUMBER_OF_DYNAMIC_RULES\nis the maximum number of dynamic rules an extension can add. The number of unsafe rules must not exceedMAX_NUMBER_OF_UNSAFE_DYNAMIC_RULES\n.\nParameters\n-\noptionsChrome 87+\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdateEnabledRulesets()\nchrome.declarativeNetRequest.updateEnabledRulesets(\noptions: UpdateRulesetOptions,\ncallback?: function,\n)\nUpdates the set of enabled static rulesets for the extension. The rulesets with IDs listed in options.disableRulesetIds\nare first removed, and then the rulesets listed in options.enableRulesetIds\nare added.\nNote that the set of enabled static rulesets is persisted across sessions but not across extension updates, i.e. the rule_resources\nmanifest key will determine the set of enabled static rulesets on each extension update.\nParameters\n-\noptionsChrome 87+\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdateSessionRules()\nchrome.declarativeNetRequest.updateSessionRules(\noptions: UpdateRuleOptions,\ncallback?: function,\n)\nModifies the current set of session scoped rules for the extension. The rules with IDs listed in options.removeRuleIds\nare first removed, and then the rules given in options.addRules\nare added. Notes:\n- This update happens as a single atomic operation: either all specified rules are added and removed, or an error is returned.\n- These rules are not persisted across sessions and are backed in memory.\nMAX_NUMBER_OF_SESSION_RULES\nis the maximum number of session rules an extension can add.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 91+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdateStaticRules()\nchrome.declarativeNetRequest.updateStaticRules(\noptions: UpdateStaticRulesOptions,\ncallback?: function,\n)\nDisables and enables individual static rules in a Ruleset\n. Changes to rules belonging to a disabled Ruleset\nwill take effect the next time that it becomes enabled.\nParameters\n-\noptions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonRuleMatchedDebug\nchrome.declarativeNetRequest.onRuleMatchedDebug.addListener(\ncallback: function,\n)\nFired when a rule is matched with a request. Only available for unpacked extensions with the \"declarativeNetRequestFeedback\"\npermission as this is intended to be used for debugging purposes only.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(info: MatchedRuleInfoDebug) => void\n-\ninfo\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/events", "title": "chrome.events | API | Chrome for Developers", "text": "Description\nThe chrome.events\nnamespace contains common types used by APIs dispatching events to notify you when something interesting happens.\nConcepts and usage\nAn Event\nis an object that lets you be notified when something interesting happens. Here's an\nexample of using the chrome.alarms.onAlarm\nevent to be notified whenever an alarm has elapsed:\nchrome.alarms.onAlarm.addListener((alarm) => {\nappendToLog(`alarms.onAlarm -- name: ${alarm.name}, scheduledTime: ${alarm.scheduledTime}`);\n});\nAs the example shows, you register for notification using addListener()\n. The argument to\naddListener()\nis always a function that you define to handle the event, but the parameters to the\nfunction depend on which event you're handling. Checking the documentation for alarms.onAlarm\n,\nyou can see that the function has a single parameter: an alarms.Alarm\nobject that has details\nabout the elapsed alarm.\nExample APIs using Events: alarms, i18n, identity, runtime. Most chrome APIs do.\nDeclarative Event Handlers\nThe declarative event handlers provide a means to define rules consisting of declarative conditions and actions. Conditions are evaluated in the browser rather than the JavaScript engine which reduces roundtrip latencies and allows for very high efficiency.\nDeclarative event handlers are used for example in the Declarative Content API. This page describes the underlying concepts of all declarative event handlers.\nRules\nThe simplest possible rule consists of one or more conditions and one or more actions:\nconst rule = {\nconditions: [ /* my conditions */ ],\nactions: [ /* my actions */ ]\n};\nIf any of the conditions is fulfilled, all actions are executed.\nIn addition to conditions and actions you may give each rule an identifier, which simplifies unregistering previously registered rules, and a priority to define precedences among rules. Priorities are only considered if rules conflict each other or need to be executed in a specific order. Actions are executed in descending order of the priority of their rules.\nconst rule = {\nid: \"my rule\", // optional, will be generated if not set.\npriority: 100, // optional, defaults to 100.\nconditions: [ /* my conditions */ ],\nactions: [ /* my actions */ ]\n};\nEvent objects\nEvent objects may support rules. These event objects don't call a callback function when\nevents happen but test whether any registered rule has at least one fulfilled condition and execute\nthe actions associated with this rule. Event objects supporting the declarative API have three\nrelevant methods: events.Event.addRules()\n, events.Event.removeRules()\n, and\nevents.Event.getRules()\n.\nAdd rules\nTo add rules call the addRules()\nfunction of the event object. It takes an array of rule instances\nas its first parameter and a callback function that is called on completion.\nconst rule_list = [rule1, rule2, ...];\naddRules(rule_list, (details) => {...});\nIf the rules were inserted successfully, the details\nparameter contains an array of inserted rules\nappearing in the same order as in the passed rule_list\nwhere the optional parameters id\nand\npriority\nwere filled with the generated values. If any rule is invalid, for example, because it contained\nan invalid condition or action, none of the rules are added and the runtime.lastError variable\nis set when the callback function is called. Each rule in rule_list\nmust contain a unique\nidentifier that is not already used by another rule or an empty identifier.\nRemove rules\nTo remove rules call the removeRules()\nfunction. It accepts an optional array of rule identifiers\nas its first parameter and a callback function as its second parameter.\nconst rule_ids = [\"id1\", \"id2\", ...];\nremoveRules(rule_ids, () => {...});\nIf rule_ids\nis an array of identifiers, all rules having identifiers listed in the array are\nremoved. If rule_ids\nlists an identifier, that is unknown, this identifier is silently ignored. If\nrule_ids\nis undefined\n, all registered rules of this extension are removed. The callback()\nfunction is called when the rules were removed.\nRetrieve rules\nTo retrieve a list of registered rules, call the getRules()\nfunction. It accepts an\noptional array of rule identifiers with the same semantics as removeRules()\nand a callback function.\nconst rule_ids = [\"id1\", \"id2\", ...];\ngetRules(rule_ids, (details) => {...});\nThe details\nparameter passed to the callback()\nfunction refers to an array of rules including\nfilled optional parameters.\nPerformance\nTo achieve maximum performance, you should keep the following guidelines in mind.\nRegister and unregister rules in bulk. After each registration or unregistration, Chrome needs to update internal data structures. This update is an expensive operation.\nconst rule1 = {...}; const rule2 = {...}; chrome.declarativeWebRequest.onRequest.addRules([rule1]); chrome.declarativeWebRequest.onRequest.addRules([rule2]);\nconst rule1 = {...}; const rule2 = {...}; chrome.declarativeWebRequest.onRequest.addRules([rule1, rule2]);\nPrefer substring matching over regular expressions in an events.UrlFilter. Substring based matching is extremely fast.\nconst match = new chrome.declarativeWebRequest.RequestMatcher({ url: {urlMatches: \"example.com/[^?]*foo\" } });\nconst match = new chrome.declarativeWebRequest.RequestMatcher({ url: {hostSuffix: \"example.com\", pathContains: \"foo\"} });\nIf there are many rules that share the same actions, merge the rules into one. Rules trigger their actions as soon as a single condition is fulfilled. This speeds up the matching and reduces memory consumption for duplicate action sets.\nconst condition1 = new chrome.declarativeWebRequest.RequestMatcher({ url: { hostSuffix: 'example.com' } }); const condition2 = new chrome.declarativeWebRequest.RequestMatcher({ url: { hostSuffix: 'foobar.com' } }); const rule1 = { conditions: [condition1], actions: [new chrome.declarativeWebRequest.CancelRequest()] }; const rule2 = { conditions: [condition2], actions: [new chrome.declarativeWebRequest.CancelRequest()] }; chrome.declarativeWebRequest.onRequest.addRules([rule1, rule2]);\nconst condition1 = new chrome.declarativeWebRequest.RequestMatcher({ url: { hostSuffix: 'example.com' } }); const condition2 = new chrome.declarativeWebRequest.RequestMatcher({ url: { hostSuffix: 'foobar.com' } }); const rule = { conditions: [condition1, condition2], actions: [new chrome.declarativeWebRequest.CancelRequest()] }; chrome.declarativeWebRequest.onRequest.addRules([rule]);\nFiltered events\nFiltered events are a mechanism that allows listeners to specify a subset of events that they are interested in. A listener that uses a filter won't be invoked for events that don't pass the filter, which makes the listening code more declarative and efficient. A service worker need not be woken up to handle events it doesn't care about.\nFiltered events are intended to allow a transition from manual filtering code.\nchrome.webNavigation.onCommitted.addListener((event) => { if (hasHostSuffix(event.url, 'google.com') || hasHostSuffix(event.url, 'google.com.au')) { // ... } });\nchrome.webNavigation.onCommitted.addListener((event) => { // ... }, {url: [{hostSuffix: 'google.com'}, {hostSuffix: 'google.com.au'}]});\nEvents support specific filters that are meaningful to that event. The list of filters that an event supports will be listed in the documentation for that event in the \"filters\" section.\nWhen matching URLs (as in the example above), event filters support the same URL matching\ncapabilities as expressible with a events.UrlFilter\n, except for scheme and port matching.\nTypes\nEvent\nAn object which allows the addition and removal of listeners for a Chrome event.\nProperties\n-\naddListener\nvoid\nRegisters an event listener callback to an event.\nThe\naddListener\nfunction looks like:(callback: H) => {...}\n-\ncallback\nH\nCalled when an event occurs. The parameters of this function depend on the type of event.\n-\n-\naddRules\nvoid\nRegisters rules to handle events.\nThe\naddRules\nfunction looks like: [], callback?: function) => {...}(rules: Rule<anyany>\n-\ngetRules\nvoid\nReturns currently registered rules.\nThe\ngetRules\nfunction looks like:(ruleIdentifiers?: string[], callback: function) => {...}\n-\nruleIdentifiers\nstring[] optional\nIf an array is passed, only rules with identifiers contained in this array are returned.\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like: []) => void(rules: Rule<anyany>\n-\nrules\nRule<anyany>[]\nRules that were registered, the optional parameters are filled with values.\n-\n-\n-\nhasListener\nvoid\nThe\nhasListener\nfunction looks like:(callback: H) => {...}\n-\ncallback\nH\nListener whose registration status shall be tested.\n-\nreturns\nboolean\nTrue if callback is registered to the event.\n-\n-\nhasListeners\nvoid\nThe\nhasListeners\nfunction looks like:() => {...}\n-\nreturns\nboolean\nTrue if any event listeners are registered to the event.\n-\n-\nremoveListener\nvoid\nDeregisters an event listener callback from an event.\nThe\nremoveListener\nfunction looks like:(callback: H) => {...}\n-\ncallback\nH\nListener that shall be unregistered.\n-\n-\nremoveRules\nvoid\nUnregisters currently registered rules.\nThe\nremoveRules\nfunction looks like:(ruleIdentifiers?: string[], callback?: function) => {...}\n-\nruleIdentifiers\nstring[] optional\nIf an array is passed, only rules with identifiers contained in this array are unregistered.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\n-\nRule\nDescription of a declarative rule for handling events.\nProperties\n-\nactions\nany[]\nList of actions that are triggered if one of the conditions is fulfilled.\n-\nconditions\nany[]\nList of conditions that can trigger the actions.\n-\nid\nstring optional\nOptional identifier that allows referencing this rule.\n-\npriority\nnumber optional\nOptional priority of this rule. Defaults to 100.\n-\ntags\nstring[] optional\nTags can be used to annotate rules and perform operations on sets of rules.\nUrlFilter\nFilters URLs for various criteria. See event filtering. All criteria are case sensitive.\nProperties\n-\ncidrBlocks\nstring[] optional\nChrome 123+Matches if the host part of the URL is an IP address and is contained in any of the CIDR blocks specified in the array.\n-\nhostContains\nstring optional\nMatches if the host name of the URL contains a specified string. To test whether a host name component has a prefix 'foo', use hostContains: '.foo'. This matches 'www.foobar.com' and 'foo.com', because an implicit dot is added at the beginning of the host name. Similarly, hostContains can be used to match against component suffix ('foo.') and to exactly match against components ('.foo.'). Suffix- and exact-matching for the last components need to be done separately using hostSuffix, because no implicit dot is added at the end of the host name.\n-\nhostEquals\nstring optional\nMatches if the host name of the URL is equal to a specified string.\n-\nhostPrefix\nstring optional\nMatches if the host name of the URL starts with a specified string.\n-\nhostSuffix\nstring optional\nMatches if the host name of the URL ends with a specified string.\n-\noriginAndPathMatches\nstring optional\nMatches if the URL without query segment and fragment identifier matches a specified regular expression. Port numbers are stripped from the URL if they match the default port number. The regular expressions use the RE2 syntax.\n-\npathContains\nstring optional\nMatches if the path segment of the URL contains a specified string.\n-\npathEquals\nstring optional\nMatches if the path segment of the URL is equal to a specified string.\n-\npathPrefix\nstring optional\nMatches if the path segment of the URL starts with a specified string.\n-\npathSuffix\nstring optional\nMatches if the path segment of the URL ends with a specified string.\n-\nports\n(number | number[])[] optional\nMatches if the port of the URL is contained in any of the specified port lists. For example\n[80, 443, [1000, 1200]]\nmatches all requests on port 80, 443 and in the range 1000-1200. -\nqueryContains\nstring optional\nMatches if the query segment of the URL contains a specified string.\n-\nqueryEquals\nstring optional\nMatches if the query segment of the URL is equal to a specified string.\n-\nqueryPrefix\nstring optional\nMatches if the query segment of the URL starts with a specified string.\n-\nquerySuffix\nstring optional\nMatches if the query segment of the URL ends with a specified string.\n-\nschemes\nstring[] optional\nMatches if the scheme of the URL is equal to any of the schemes specified in the array.\n-\nurlContains\nstring optional\nMatches if the URL (without fragment identifier) contains a specified string. Port numbers are stripped from the URL if they match the default port number.\n-\nurlEquals\nstring optional\nMatches if the URL (without fragment identifier) is equal to a specified string. Port numbers are stripped from the URL if they match the default port number.\n-\nurlMatches\nstring optional\nMatches if the URL (without fragment identifier) matches a specified regular expression. Port numbers are stripped from the URL if they match the default port number. The regular expressions use the RE2 syntax.\n-\nurlPrefix\nstring optional\nMatches if the URL (without fragment identifier) starts with a specified string. Port numbers are stripped from the URL if they match the default port number.\n-\nurlSuffix\nstring optional\nMatches if the URL (without fragment identifier) ends with a specified string. Port numbers are stripped from the URL if they match the default port number."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/extension", "title": "chrome.extension | API | Chrome for Developers", "text": "Description\nThe chrome.extension\nAPI has utilities that can be used by any extension page. It includes support for exchanging messages between an extension and its content scripts or between extensions, as described in detail in Message Passing.\nTypes\nViewType\nThe type of extension view.\nEnum\n\"tab\" \"popup\"\nProperties\ninIncognitoContext\nTrue for content scripts running inside incognito tabs, and for extension pages running inside an incognito process. The latter only applies to extensions with 'split' incognito_behavior.\nType\nboolean\nMethods\ngetBackgroundPage()\nchrome.extension.getBackgroundPage()\nReturns the JavaScript 'window' object for the background page running inside the current extension. Returns null if the extension has no background page.\nReturns\n-\nWindow | undefined\ngetViews()\nchrome.extension.getViews(\nfetchProperties?: object,\n)\nReturns an array of the JavaScript 'window' objects for each of the pages running inside the current extension.\nParameters\n-\nfetchProperties\nobject optional\n-\ntabId\nnumber optional\nChrome 54+Find a view according to a tab id. If this field is omitted, returns all views.\n-\ntype\nViewType optional\nThe type of view to get. If omitted, returns all views (including background pages and tabs).\n-\nwindowId\nnumber optional\nThe window to restrict the search to. If omitted, returns all views.\n-\nReturns\n-\nWindow[]\nArray of global objects\nisAllowedFileSchemeAccess()\nchrome.extension.isAllowedFileSchemeAccess(\ncallback?: function,\n)\nRetrieves the state of the extension's access to the 'file://' scheme. This corresponds to the user-controlled per-extension 'Allow access to File URLs' setting accessible via the chrome://extensions page.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(isAllowedAccess: boolean) => void\n-\nisAllowedAccess\nboolean\nTrue if the extension can access the 'file://' scheme, false otherwise.\n-\nReturns\n-\nPromise<boolean>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nisAllowedIncognitoAccess()\nchrome.extension.isAllowedIncognitoAccess(\ncallback?: function,\n)\nRetrieves the state of the extension's access to Incognito-mode. This corresponds to the user-controlled per-extension 'Allowed in Incognito' setting accessible via the chrome://extensions page.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(isAllowedAccess: boolean) => void\n-\nisAllowedAccess\nboolean\nTrue if the extension has access to Incognito mode, false otherwise.\n-\nReturns\n-\nPromise<boolean>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetUpdateUrlData()\nchrome.extension.setUpdateUrlData(\ndata: string,\n)\nSets the value of the ap CGI parameter used in the extension's update URL. This value is ignored for extensions that are hosted in the Chrome Extension Gallery.\nParameters\n-\ndata\nstring"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/extensionTypes", "title": "chrome.extensionTypes | API | Chrome for Developers", "text": "Description\nThe chrome.extensionTypes\nAPI contains type declarations for Chrome extensions.\nTypes\nEnum\n\"author\" \"user\"\nDeleteInjectionDetails\nDetails of the CSS to remove. Either the code or the file property must be set, but both may not be set at the same time.\nProperties\n-\nallFrames\nboolean optional\nIf allFrames is\ntrue\n, implies that the CSS should be removed from all frames of current page. By default, it'sfalse\nand is only removed from the top frame. Iftrue\nandframeId\nis set, then the code is removed from the selected frame and all of its child frames. -\ncode\nstring optional\nCSS code to remove.\n-\ncssOrigin\nCSSOrigin optional\nThe origin of the CSS to remove. Defaults to\n\"author\"\n. -\nfile\nstring optional\nCSS file to remove.\n-\nframeId\nnumber optional\nThe frame from where the CSS should be removed. Defaults to 0 (the top-level frame).\n-\nmatchAboutBlank\nboolean optional\nIf matchAboutBlank is true, then the code is also removed from about:blank and about:srcdoc frames if your extension has access to its parent document. By default it is\nfalse\n.\nDocumentLifecycle\nThe document lifecycle of the frame.\nEnum\n\"prerender\" \"active\" \"cached\" \"pending_deletion\"\nExecutionWorld\nThe JavaScript world for a script to execute within. Can either be an isolated world unique to this extension, the main world of the DOM which is shared with the page's JavaScript, or a user scripts world that is only available for scripts registered with the User Scripts API.\nEnum\n\"ISOLATED\" \"MAIN\" \"USER_SCRIPT\"\nFrameType\nThe type of frame.\nEnum\n\"outermost_frame\" \"fenced_frame\" \"sub_frame\"\nImageDetails\nDetails about the format and quality of an image.\nProperties\n-\nformat\nImageFormat optional\nThe format of the resulting image. Default is\n\"jpeg\"\n. -\nquality\nnumber optional\nWhen format is\n\"jpeg\"\n, controls the quality of the resulting image. This value is ignored for PNG images. As quality is decreased, the resulting image will have more visual artifacts, and the number of bytes needed to store it will decrease.\nImageFormat\nThe format of an image.\nEnum\n\"jpeg\" \"png\"\nInjectDetails\nDetails of the script or CSS to inject. Either the code or the file property must be set, but both may not be set at the same time.\nProperties\n-\nallFrames\nboolean optional\nIf allFrames is\ntrue\n, implies that the JavaScript or CSS should be injected into all frames of current page. By default, it'sfalse\nand is only injected into the top frame. Iftrue\nandframeId\nis set, then the code is inserted in the selected frame and all of its child frames. -\ncode\nstring optional\nJavaScript or CSS code to inject.\nWarning: Be careful using the\ncode\nparameter. Incorrect use of it may open your extension to cross site scripting attacks -\ncssOrigin\nCSSOrigin optional\nChrome 66+The origin of the CSS to inject. This may only be specified for CSS, not JavaScript. Defaults to\n\"author\"\n. -\nfile\nstring optional\nJavaScript or CSS file to inject.\n-\nframeId\nnumber optional\nChrome 50+The frame where the script or CSS should be injected. Defaults to 0 (the top-level frame).\n-\nmatchAboutBlank\nboolean optional\nIf matchAboutBlank is true, then the code is also injected in about:blank and about:srcdoc frames if your extension has access to its parent document. Code cannot be inserted in top-level about:-frames. By default it is\nfalse\n. -\nrunAt\nRunAt optional\nThe soonest that the JavaScript or CSS will be injected into the tab. Defaults to \"document_idle\".\nRunAt\nThe soonest that the JavaScript or CSS will be injected into the tab.\nEnum\n\"document_start\" \"document_end\" \"document_idle\"\nScript is injected after any files from css, but before any other DOM is constructed or any other script is run.\nScript is injected immediately after the DOM is complete, but before subresources like images and frames have loaded.\nThe browser chooses a time to inject the script between \"document_end\" and immediately after the window.onload\nevent fires. The exact moment of injection depends on how complex the document is and how long it is taking to load, and is optimized for page load speed. Content scripts running at \"document_idle\" don't need to listen for the window.onload\nevent; they are guaranteed to run after the DOM completes. If a script definitely needs to run after window.onload\n, the extension can check if onload\nhas already fired by using the document.readyState\nproperty."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/extensionTypes", "title": "chrome.extensionTypes | API | Chrome for Developers", "text": "Description\nThe chrome.extensionTypes\nAPI contains type declarations for Chrome extensions.\nTypes\nEnum\n\"author\" \"user\"\nDeleteInjectionDetails\nDetails of the CSS to remove. Either the code or the file property must be set, but both may not be set at the same time.\nProperties\n-\nallFrames\nboolean optional\nIf allFrames is\ntrue\n, implies that the CSS should be removed from all frames of current page. By default, it'sfalse\nand is only removed from the top frame. Iftrue\nandframeId\nis set, then the code is removed from the selected frame and all of its child frames. -\ncode\nstring optional\nCSS code to remove.\n-\ncssOrigin\nCSSOrigin optional\nThe origin of the CSS to remove. Defaults to\n\"author\"\n. -\nfile\nstring optional\nCSS file to remove.\n-\nframeId\nnumber optional\nThe frame from where the CSS should be removed. Defaults to 0 (the top-level frame).\n-\nmatchAboutBlank\nboolean optional\nIf matchAboutBlank is true, then the code is also removed from about:blank and about:srcdoc frames if your extension has access to its parent document. By default it is\nfalse\n.\nDocumentLifecycle\nThe document lifecycle of the frame.\nEnum\n\"prerender\" \"active\" \"cached\" \"pending_deletion\"\nExecutionWorld\nThe JavaScript world for a script to execute within. Can either be an isolated world unique to this extension, the main world of the DOM which is shared with the page's JavaScript, or a user scripts world that is only available for scripts registered with the User Scripts API.\nEnum\n\"ISOLATED\" \"MAIN\" \"USER_SCRIPT\"\nFrameType\nThe type of frame.\nEnum\n\"outermost_frame\" \"fenced_frame\" \"sub_frame\"\nImageDetails\nDetails about the format and quality of an image.\nProperties\n-\nformat\nImageFormat optional\nThe format of the resulting image. Default is\n\"jpeg\"\n. -\nquality\nnumber optional\nWhen format is\n\"jpeg\"\n, controls the quality of the resulting image. This value is ignored for PNG images. As quality is decreased, the resulting image will have more visual artifacts, and the number of bytes needed to store it will decrease.\nImageFormat\nThe format of an image.\nEnum\n\"jpeg\" \"png\"\nInjectDetails\nDetails of the script or CSS to inject. Either the code or the file property must be set, but both may not be set at the same time.\nProperties\n-\nallFrames\nboolean optional\nIf allFrames is\ntrue\n, implies that the JavaScript or CSS should be injected into all frames of current page. By default, it'sfalse\nand is only injected into the top frame. Iftrue\nandframeId\nis set, then the code is inserted in the selected frame and all of its child frames. -\ncode\nstring optional\nJavaScript or CSS code to inject.\nWarning: Be careful using the\ncode\nparameter. Incorrect use of it may open your extension to cross site scripting attacks -\ncssOrigin\nCSSOrigin optional\nChrome 66+The origin of the CSS to inject. This may only be specified for CSS, not JavaScript. Defaults to\n\"author\"\n. -\nfile\nstring optional\nJavaScript or CSS file to inject.\n-\nframeId\nnumber optional\nChrome 50+The frame where the script or CSS should be injected. Defaults to 0 (the top-level frame).\n-\nmatchAboutBlank\nboolean optional\nIf matchAboutBlank is true, then the code is also injected in about:blank and about:srcdoc frames if your extension has access to its parent document. Code cannot be inserted in top-level about:-frames. By default it is\nfalse\n. -\nrunAt\nRunAt optional\nThe soonest that the JavaScript or CSS will be injected into the tab. Defaults to \"document_idle\".\nRunAt\nThe soonest that the JavaScript or CSS will be injected into the tab.\nEnum\n\"document_start\" \"document_end\" \"document_idle\"\nScript is injected after any files from css, but before any other DOM is constructed or any other script is run.\nScript is injected immediately after the DOM is complete, but before subresources like images and frames have loaded.\nThe browser chooses a time to inject the script between \"document_end\" and immediately after the window.onload\nevent fires. The exact moment of injection depends on how complex the document is and how long it is taking to load, and is optimized for page load speed. Content scripts running at \"document_idle\" don't need to listen for the window.onload\nevent; they are guaranteed to run after the DOM completes. If a script definitely needs to run after window.onload\n, the extension can check if onload\nhas already fired by using the document.readyState\nproperty."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/history", "title": "chrome.history | API | Chrome for Developers", "text": "Description\nUse the chrome.history\nAPI to interact with the browser's record of visited pages. You can add, remove, and query for URLs in the browser's history. To override the history page with your own version, see Override Pages.\nPermissions\nhistory\nTo interact with the user's browser history, use the history API.\nTo use the history API, declare the \"history\"\npermission in the extension manifest. For\nexample:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"history\"\n],\n...\n}\nConcepts and usage\nTransition types\nThe history API uses transition types to describe how the browser navigated to a particular URL on a particular visit. For example, if a user visits a page by clicking a link on another page, the transition type is \"link\". See the reference content for a list of transition types.\nExamples\nTo try this API, install the history API example from the chrome-extension-samples repository.\nTypes\nHistoryItem\nAn object encapsulating one result of a history query.\nProperties\n-\nid\nstring\nThe unique identifier for the item.\n-\nlastVisitTime\nnumber optional\nWhen this page was last loaded, represented in milliseconds since the epoch.\n-\ntitle\nstring optional\nThe title of the page when it was last loaded.\n-\ntypedCount\nnumber optional\nThe number of times the user has navigated to this page by typing in the address.\n-\nurl\nstring optional\nThe URL navigated to by a user.\n-\nvisitCount\nnumber optional\nThe number of times the user has navigated to this page.\nEnum\n\"link\" \"typed\" \"auto_bookmark\" \"auto_subframe\" \"manual_subframe\" \"generated\" \"auto_toplevel\" \"form_submit\" \"reload\" \"keyword\" \"keyword_generated\"\nThe user arrived at this page by clicking a link on another page.\nThe user arrived at this page by typing the URL in the address bar. This is also used for other explicit navigation actions.\nThe user arrived at this page through a suggestion in the UI, for example, through a menu item.\nThe user arrived at this page through subframe navigation that they didn't request, such as through an ad loading in a frame on the previous page. These don't always generate new navigation entries in the back and forward menus.\nThe user arrived at this page by selecting something in a subframe.\nThe user arrived at this page by typing in the address bar and selecting an entry that didn't look like a URL, such as a Google Search suggestion. For example, a match might have the URL of a Google Search result page, but it might appear to the user as \"Search Google for ...\". These are different from typed navigations because the user didn't type or see the destination URL. They're also related to keyword navigations.\nThe page was specified in the command line or is the start page.\nThe user arrived at this page by filling out values in a form and submitting the form. Not all form submissions use this transition type.\nThe user reloaded the page, either by clicking the reload button or by pressing Enter in the address bar. Session restore and Reopen closed tab also use this transition type.\nThe URL for this page was generated from a replaceable keyword other than the default search provider.\nCorresponds to a visit generated for a keyword.\nUrlDetails\nProperties\n-\nurl\nstring\nThe URL for the operation. It must be in the format as returned from a call to\nhistory.search()\n.\nVisitItem\nAn object encapsulating one visit to a URL.\nProperties\n-\nid\nstring\nThe unique identifier for the corresponding\nhistory.HistoryItem\n. -\nisLocal\nboolean\nChrome 115+True if the visit originated on this device. False if it was synced from a different device.\n-\nreferringVisitId\nstring\nThe visit ID of the referrer.\n-\ntransition\nThe transition type for this visit from its referrer.\n-\nvisitId\nstring\nThe unique identifier for this visit.\n-\nvisitTime\nnumber optional\nWhen this visit occurred, represented in milliseconds since the epoch.\nMethods\naddUrl()\nchrome.history.addUrl(\ndetails: UrlDetails,\ncallback?: function,\n)\nAdds a URL to the history at the current time with a transition type of \"link\".\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ndeleteAll()\nchrome.history.deleteAll(\ncallback?: function,\n)\nDeletes all items from the history.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ndeleteRange()\nchrome.history.deleteRange(\nrange: object,\ncallback?: function,\n)\nRemoves all items within the specified date range from the history. Pages will not be removed from the history unless all visits fall within the range.\nParameters\n-\nrange\nobject\n-\nendTime\nnumber\nItems added to history before this date, represented in milliseconds since the epoch.\n-\nstartTime\nnumber\nItems added to history after this date, represented in milliseconds since the epoch.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ndeleteUrl()\nchrome.history.deleteUrl(\ndetails: UrlDetails,\ncallback?: function,\n)\nRemoves all occurrences of the given URL from the history.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetVisits()\nchrome.history.getVisits(\ndetails: UrlDetails,\ncallback?: function,\n)\nRetrieves information about visits to a URL.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(results: VisitItem[]) => void\n-\nresults\n-\nReturns\n-\nPromise<VisitItem[]>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsearch()\nchrome.history.search(\nquery: object,\ncallback?: function,\n)\nSearches the history for the last visit time of each page matching the query.\nParameters\n-\nquery\nobject\n-\nendTime\nnumber optional\nLimit results to those visited before this date, represented in milliseconds since the epoch.\n-\nmaxResults\nnumber optional\nThe maximum number of results to retrieve. Defaults to 100.\n-\nstartTime\nnumber optional\nLimit results to those visited after this date, represented in milliseconds since the epoch. If property is not specified, it will default to 24 hours.\n-\ntext\nstring\nA free-text query to the history service. Leave this empty to retrieve all pages.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(results: HistoryItem[]) => void\n-\nresults\n-\nReturns\n-\nPromise<HistoryItem[]>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonVisited\nchrome.history.onVisited.addListener(\ncallback: function,\n)\nFired when a URL is visited, providing the HistoryItem\ndata for that URL. This event fires before the page has loaded.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(result: HistoryItem) => void\n-\nresult\n-\nonVisitRemoved\nchrome.history.onVisitRemoved.addListener(\ncallback: function,\n)\nFired when one or more URLs are removed from history. When all visits have been removed the URL is purged from history.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(removed: object) => void\n-\nremoved\nobject\n-\nallHistory\nboolean\nTrue if all history was removed. If true, then urls will be empty.\n-\nurls\nstring[] optional\n-\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/i18n", "title": "chrome.i18n | API | Chrome for Developers", "text": "Description\nUse the chrome.i18n\ninfrastructure to implement internationalization across your whole app or extension.\nManifest\nIf an extension has a /_locales\ndirectory, the manifest must define \"default_locale\"\n.\nConcepts and usage\nYou need to put all of its user-visible strings into a file named messages.json\n. Each time\nyou add a new locale, you add a messages file under a directory named /_locales/_localeCode_\n, where\nlocaleCode is a code such as en\nfor English.\nHere's the file hierarchy for an internationalized extension that supports English (en\n), Spanish\n(es\n), and Korean (ko\n):\nSupport multiple languages\nSay you have an extension with the files shown in the following figure:\nTo internationalize this extension, you name each user-visible string and put it into a messages file. The extension's manifest, CSS files, and JavaScript code use each string's name to get its localized version.\nHere's what the extension looks like when it's internationalized (note that it still has only English strings):\nSome notes about internationalizing:\n- You can use any of the supported locales. If you use an unsupported locale, Google Chrome ignores it.\nIn\nmanifest.json\nand CSS files, refer to a string named messagename like this:__MSG_messagename__\nIn your extension or app's JavaScript code, refer to a string named messagename like this:\nchrome.i18n.getMessage(\"messagename\")\nIn each call to\ngetMessage()\n, you can supply up to 9 strings to be included in the message. See Examples: getMessage for details.Some messages, such as\n@@bidi_dir\nand@@ui_locale\n, are provided by the internationalization system. See the Predefined messages section for a full list of predefined message names.In\nmessages.json\n, each user-visible string has a name, a \"message\" item, and an optional \"description\" item. The name is a key such as \"extName\" or \"search_string\" that identifies the string. The \"message\" specifies the value of the string in this locale. The optional \"description\" provides help to translators, who might not be able to see how the string is used in your extension. For example:{ \"search_string\": { \"message\": \"hello%20world\", \"description\": \"The string we search for. Put %20 between words that go together.\" }, ... }\nFor more information, see Formats: Locale-Specific Messages.\nOnce an extension is internationalized, translating it is straightforward. You copy messages.json\n,\ntranslate it, and put the copy into a new directory under /_locales\n. For example, to support\nSpanish, just put a translated copy of messages.json\nunder /_locales/es\n. The following figure\nshows the previous extension with a new Spanish translation.\nPredefined messages\nThe internationalization system provides a few predefined messages to help you localize. These\ninclude @@ui_locale\n, so you can detect the current UI locale, and a few @@bidi_...\nmessages that\nlet you detect the text direction. The latter messages have similar names to constants in the\ngadgets BIDI (bi-directional) API.\nThe special message @@extension_id\ncan be used in the CSS and JavaScript files, whether or not the\nextension or app is localized. This message doesn't work in manifest files.\nThe following table describes each predefined message.\n| Message name | Description |\n|---|---|\n@@extension_id | The extension or app ID; you might use this string to construct URLs for resources inside the extension. Even unlocalized extensions can use this message. Note: You can't use this message in a manifest file. |\n@@ui_locale | The current locale; you might use this string to construct locale-specific URLs. |\n@@bidi_dir | The text direction for the current locale, either \"ltr\" for left-to-right languages such as English or \"rtl\" for right-to-left languages such as Arabic. |\n@@bidi_reversed_dir | If the @@bidi_dir is \"ltr\", then this is \"rtl\"; otherwise, it's \"ltr\". |\n@@bidi_start_edge | If the @@bidi_dir is \"ltr\", then this is \"left\"; otherwise, it's \"right\". |\n@@bidi_end_edge | If the @@bidi_dir is \"ltr\", then this is \"right\"; otherwise, it's \"left\". |\nHere's an example of using @@extension_id\nin a CSS file to construct a URL:\nbody {\nbackground-image:url('chrome-extension://__MSG_@@extension_id__/background.png');\n}\nIf the extension ID is abcdefghijklmnopqrstuvwxyzabcdef, then the bold line in the previous code snippet becomes:\nbackground-image:url('chrome-extension://abcdefghijklmnopqrstuvwxyzabcdef/background.png');\nHere's an example of using @@bidi_*\nmessages in a CSS file:\nbody {\ndirection: __MSG_@@bidi_dir__;\n}\ndiv#header {\nmargin-bottom: 1.05em;\noverflow: hidden;\npadding-bottom: 1.5em;\npadding-__MSG_@@bidi_start_edge__: 0;\npadding-__MSG_@@bidi_end_edge__: 1.5em;\nposition: relative;\n}\nFor left-to-right languages such as English, the bold lines become:\ndir: ltr;\npadding-left: 0;\npadding-right: 1.5em;\nLocales\nYou can choose from many locales, including some (such as en\n) that let a single translation support multiple variations of a language (such as en_GB\nand en_US\n).\nYou can localize your extension to any locale that is supported by the Chrome Web Store. If your locale is not listed here, choose the closest alternative. For example, if the default locale of your extension is \"de_CH\"\n, choose \"de\"\nin the Chrome Web Store.\n| Locale code | Language (region) |\n|---|---|\n| ar | Arabic |\n| am | Amharic |\n| bg | Bulgarian |\n| bn | Bengali |\n| ca | Catalan |\n| cs | Czech |\n| da | Danish |\n| de | German |\n| el | Greek |\n| en | English |\n| en_AU | English (Australia) |\n| en_GB | English (Great Britain) |\n| en_US | English (USA) |\n| es | Spanish |\n| es_419 | Spanish (Latin America and Caribbean) |\n| et | Estonian |\n| fa | Persian |\n| fi | Finnish |\n| fil | Filipino |\n| fr | French |\n| gu | Gujarati |\n| he | Hebrew |\n| hi | Hindi |\n| hr | Croatian |\n| hu | Hungarian |\n| id | Indonesian |\n| it | Italian |\n| ja | Japanese |\n| kn | Kannada |\n| ko | Korean |\n| lt | Lithuanian |\n| lv | Latvian |\n| ml | Malayalam |\n| mr | Marathi |\n| ms | Malay |\n| nl | Dutch |\n| no | Norwegian |\n| pl | Polish |\n| pt_BR | Portuguese (Brazil) |\n| pt_PT | Portuguese (Portugal) |\n| ro | Romanian |\n| ru | Russian |\n| sk | Slovak |\n| sl | Slovenian |\n| sr | Serbian |\n| sv | Swedish |\n| sw | Swahili |\n| ta | Tamil |\n| te | Telugu |\n| th | Thai |\n| tr | Turkish |\n| uk | Ukrainian |\n| vi | Vietnamese |\n| zh_CN | Chinese (China) |\n| zh_TW | Chinese (Taiwan) |\nSearch for messages\nYou don't have to define every string for every supported locale. As long as the default locale's\nmessages.json\nfile has a value for every string, your extension or app will run no matter how\nsparse a translation is. Here's how the extension system searches for a message:\n- Search the messages file (if any) for the user's preferred locale. For example, when Google\nChrome's locale is set to British English (\nen_GB\n), the system first looks for the message in/_locales/en_GB/messages.json\n. If that file exists and the message is there, the system looks no further. - If the user's preferred locale has a region (that is, the locale has an underscore: _), search\nthe locale without that region. For example, if the\nen_GB\nmessages file doesn't exist or doesn't contain the message, the system looks in theen\nmessages file. If that file exists and the message is there, the system looks no further. - Search the messages file for the default locale. For example, if the extension's\n\"default_locale\" is set to \"es\", and neither\n/_locales/en_GB/messages.json\nnor/_locales/en/messages.json\ncontains the message, the extension uses the message from/_locales/es/messages.json\n.\nIn the following figure, the message named \"colores\" is in all three locales that the extension supports, but \"extName\" is in only two of the locales. Wherever a user running Google Chrome in US English sees the label \"Colors\", a user of British English sees \"Colours\". Both US English and British English users see the extension name \"Hello World\". Because the default language is Spanish, users running Google Chrome in any non-English language see the label \"Colores\" and the extension name \"Hola mundo\".\nSet your browser's locale\nTo test translations, you might want to set your browser's locale. This section tells you how to set the locale in Windows, Mac OS, Linux, and ChromeOS.\nWindows\nYou can change the locale using either a locale-specific shortcut or the Google Chrome UI. The shortcut approach is quicker, once you've set it up, and it lets you use several languages at once.\nUse a locale-specific shortcut\nTo create and use a shortcut that launches Google Chrome with a particular locale:\n- Make a copy of the Google Chrome shortcut that's already on your desktop.\n- Rename the new shortcut to match the new locale.\nChange the shortcut's properties so that the Target field specifies the\n--lang\nand--user-data-dir\nflags. The target should look something like this:path_to_chrome.exe --lang=locale --user-data-dir=c:\\locale_profile_dir\nLaunch Google Chrome by double-clicking the shortcut.\nFor example, to create a shortcut that launches Google Chrome in Spanish (es\n), you might create a\nshortcut named chrome-es\nthat has the following target:\npath_to_chrome.exe --lang=es --user-data-dir=c:\\chrome-profile-es\nYou can create as many shortcuts as you like, making it straightforward to test in multiple languages. For example:\npath_to_chrome.exe --lang=en --user-data-dir=c:\\chrome-profile-en\npath_to_chrome.exe --lang=en_GB --user-data-dir=c:\\chrome-profile-en_GB\npath_to_chrome.exe --lang=ko --user-data-dir=c:\\chrome-profile-ko\nUse the UI\nHere's how to change the locale using the UI on Google Chrome for Windows:\n- App icon > Options\n- Choose the Under the Hood tab\n- Scroll to Web Content\n- Click Change font and language settings\n- Choose the Languages tab\n- Use the drop down to set the Google Chrome language\n- Restart Chrome\nMac OS\nTo change the locale on Mac, you use the system preferences.\n- From the Apple menu, choose System Preferences\n- Under the Personal section, choose International\n- Choose your language and location\n- Restart Chrome\nLinux\nTo change the locale on Linux, first quit Google Chrome. Then, all in one line, set the LANGUAGE environment variable and launch Google Chrome. For example:\nLANGUAGE=es ./chrome\nChromeOS\nTo change the locale on ChromeOS:\n- From the system tray, choose Settings.\n- Under the Languages and input section, choose the Language drop-down.\n- If your language is not listed, click Add languages and add it.\n- Once added, click the 3-dot More actions menu item next to your language and choose Display ChromeOS in this language.\n- Click the Restart button that appears next to the set language to restart ChromeOS.\nExamples\nYou can find examples of internationalization in the examples/api/i18n directory. For a complete example, see examples/extensions/news. For other examples and for help in viewing the source code, see Samples.\ngetMessage()\nThe following code gets a localized message from the browser and displays it as a string. It replaces two placeholders within the message with the strings \"string1\" and \"string2\".\nfunction getMessage() {\nvar message = chrome.i18n.getMessage(\"click_here\", [\"string1\", \"string2\"]);\ndocument.getElementById(\"languageSpan\").innerHTML = message;\n}\nHere's how you'd supply and use a single string:\n// In JavaScript code\nstatus.innerText = chrome.i18n.getMessage(\"error\", errorDetails);\n\"error\": {\n\"message\": \"Error: $details$\",\n\"description\": \"Generic error template. Expects error parameter to be passed in.\",\n\"placeholders\": {\n\"details\": {\n\"content\": \"$1\",\n\"example\": \"Failed to fetch RSS feed.\"\n}\n}\n}\nFor more information about placeholders, see the Locale-Specific Messages page. For details on\ncalling getMessage()\n, see the API reference.\ngetAcceptLanguages()\nThe following code gets accept-languages from the browser and displays them as a string by separating each accept-language with ','.\nfunction getAcceptLanguages() {\nchrome.i18n.getAcceptLanguages(function(languageList) {\nvar languages = languageList.join(\",\");\ndocument.getElementById(\"languageSpan\").innerHTML = languages;\n})\n}\nFor details on calling getAcceptLanguages()\n, see the API reference.\ndetectLanguage()\nThe following code detects up to 3 languages from the given string and displays the result as strings separated by new lines.\nfunction detectLanguage(inputText) {\nchrome.i18n.detectLanguage(inputText, function(result) {\nvar outputLang = \"Detected Language: \";\nvar outputPercent = \"Language Percentage: \";\nfor(i = 0; i < result.languages.length; i++) {\noutputLang += result.languages[i].language + \" \";\noutputPercent +=result.languages[i].percentage + \" \";\n}\ndocument.getElementById(\"languageSpan\").innerHTML = outputLang + \"\\n\" + outputPercent + \"\\nReliable: \" + result.isReliable;\n});\n}\nFor more details on calling detectLanguage(inputText)\n, see the API reference.\nTypes\nLanguageCode\nAn ISO language code such as en\nor fr\n. For a complete list of languages supported by this method, see kLanguageInfoTable. For an unknown language, und\nwill be returned, which means that [percentage] of the text is unknown to CLD\nType\nstring\nMethods\ndetectLanguage()\nchrome.i18n.detectLanguage(\ntext: string,\ncallback?: function,\n)\nDetects the language of the provided text using CLD.\nParameters\n-\ntext\nstring\nUser input string to be translated.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: object) => void\n-\nresult\nobject\nLanguageDetectionResult object that holds detected langugae reliability and array of DetectedLanguage\n-\nisReliable\nboolean\nCLD detected language reliability\n-\nlanguages\nobject[]\narray of detectedLanguage\n-\nlanguage\nstring\n-\npercentage\nnumber\nThe percentage of the detected language\n-\n-\n-\nReturns\n-\nPromise<object>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetAcceptLanguages()\nchrome.i18n.getAcceptLanguages(\ncallback?: function,\n)\nGets the accept-languages of the browser. This is different from the locale used by the browser; to get the locale, use i18n.getUILanguage\n.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(languages: string[]) => void\n-\nlanguages\nstring[]\nArray of LanguageCode\n-\nReturns\n-\nPromise<LanguageCode[]>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetMessage()\nchrome.i18n.getMessage(\nmessageName: string,\nsubstitutions?: any,\noptions?: object,\n)\nGets the localized string for the specified message. If the message is missing, this method returns an empty string (''). If the format of the getMessage()\ncall is wrong \u2014 for example, messageName is not a string or the substitutions array has more than 9 elements \u2014 this method returns undefined\n.\nParameters\n-\nmessageName\nstring\nThe name of the message, as specified in the\nmessages.json\nfile. -\nsubstitutions\nany optional\nUp to 9 substitution strings, if the message requires any.\n-\noptions\nobject optional\nChrome 79+-\nescapeLt\nboolean optional\nEscape\n<\nin translation to<\n. This applies only to the message itself, not to the placeholders. Developers might want to use this if the translation is used in an HTML context. Closure Templates used with Closure Compiler generate this automatically.\n-\nReturns\n-\nstring\nMessage localized for current locale.\ngetUILanguage()\nchrome.i18n.getUILanguage()\nGets the browser UI language of the browser. This is different from i18n.getAcceptLanguages\nwhich returns the preferred user languages.\nReturns\n-\nstring\nThe browser UI language code such as en-US or fr-FR."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest", "title": "Manifest file format | Chrome for Developers", "text": "Every extension must have a manifest.json\nfile in its root directory that\nlists important information about the structure and behavior of that extension.\nThis page explains the structure of extension manifests and the features they\ncan include.\nExamples\nThe following example manifests show the basic manifest structure and some commonly used features as a starting point for creating your own manifest:\nMinimal manifest\n{\n\"manifest_version\": 3,\n\"name\": \"Minimal Manifest\",\n\"version\": \"1.0.0\",\n\"description\": \"A basic example extension with only required keys\",\n\"icons\": {\n\"48\": \"images/icon-48.png\",\n\"128\": \"images/icon-128.png\"\n},\n}\nRegister a content script\n{\n\"manifest_version\": 3,\n\"name\": \"Run script automatically\",\n\"description\": \"Runs a script on www.example.com automatically when user installs the extension\",\n\"version\": \"1.0\",\n\"icons\": {\n\"16\": \"images/icon-16.png\",\n\"32\": \"images/icon-32.png\",\n\"48\": \"images/icon-48.png\",\n\"128\": \"images/icon-128.png\"\n},\n\"content_scripts\": [\n{\n\"js\": [\n\"content-script.js\"\n],\n\"matches\": [\n\"http://*.example.com//\"\n]\n}\n]\n}\nInject a content script\n{\n\"manifest_version\": 3,\n\"name\": \"Click to run\",\n\"description\": \"Runs a script when the user clicks the action toolbar icon.\",\n\"version\": \"1.0\",\n\"icons\": {\n\"16\": \"images/icon-16.png\",\n\"32\": \"images/icon-32.png\",\n\"48\": \"images/icon-48.png\",\n\"128\": \"images/icon-128.png\"\n},\n\"background\": {\n\"service_worker\": \"service-worker.js\"\n},\n\"action\": {\n\"default_icon\": {\n\"16\": \"images/icon-16.png\",\n\"32\": \"images/icon-32.png\",\n\"48\": \"images/icon-48.png\",\n\"128\": \"images/icon-128.png\"\n}\n},\n\"permissions\": [\"scripting\", \"activeTab\"]\n}\nPopup with permissions\n{\n\"manifest_version\": 3,\n\"name\": \"Popup extension that requests permissions\",\n\"description\": \"Extension that includes a popup and requests host permissions and storage permissions .\",\n\"version\": \"1.0\",\n\"icons\": {\n\"16\": \"images/icon-16.png\",\n\"32\": \"images/icon-32.png\",\n\"48\": \"images/icon-48.png\",\n\"128\": \"images/icon-128.png\"\n},\n\"action\": {\n\"default_popup\": \"popup.html\"\n},\n\"host_permissions\": [\n\"https://*.example.com/\"\n],\n\"permissions\": [\n\"storage\"\n]\n}\nSide panel\n{\n\"manifest_version\": 3,\n\"name\": \"Side panel extension\",\n\"version\": \"1.0\",\n\"description\": \"Extension with a default side panel.\",\n\"icons\": {\n\"16\": \"images/icon-16.png\",\n\"48\": \"images/icon-48.png\",\n\"128\": \"images/icon-128.png\"\n},\n\"side_panel\": {\n\"default_path\": \"sidepanel.html\"\n},\n\"permissions\": [\"sidePanel\"]\n}\nManifest keys\nThe following is a list of all supported manifest keys.\nKeys required by the Extensions platform\n\"manifest_version\"\n- An integer specifying the version of the manifest file format that your\nextension uses. The only supported value is\n3\n. \"name\"\n- A string that identifies the extension in the Chrome Web\nStore, the install dialog, and\nthe user's Chrome Extensions page (\nchrome://extensions\n). The maximum length is 75 characters. For information on using locale-specific names, see Internationalization. \"version\"\n- A string that identifies the extension's version number. For information on version number formatting, see Version.\nKeys required by Chrome Web Store\n\"description\"\n- A string that describes the extension on both the Chrome Web Store and the user's extension management page. The maximum length is 132 characters. For information on localizing descriptions, see Internationalization.\n\"icons\"\n- One or more icons that represent your extension. For information about best practices, see Icons.\nOptional keys\n\"action\"\n- Defines the appearance and behavior of the extension's icon in the Google\nToolbar. For more information, see\nchrome.action\n. \"author\"\n- Specifies the email address of the account that was used to create the extension.\n\"background\"\n- Specifies the JavaScript file containing the extension's service worker, which acts as an event handler. For more information, see About extension service workers.\n\"chrome_settings_overrides\"\n- Defines overrides for selected Chrome settings. For more information, see Overriding Chrome settings.\n\"chrome_url_overrides\"\n- Defines overrides for default Chrome pages. For more information, see Override Chrome pages.\n\"commands\"\n- Defines keyboard shortcuts within the extension. For more information, see chrome.commands.\n\"content_scripts\"\n- Specifies JavaScript or CSS files to be used when the user opens certain web pages. For more information, see Content scripts.\n\"content_security_policy\"\n- Defines restrictions on the scripts, styles, and other resources an extension can use. For more information, see Content security policy.\n\"cross_origin_embedder_policy\"\n- Specifies a value for the Cross-Origin-Embedder-Policy HTTP header, which configures embedding of cross-origin resources in an extension page.\n\"cross_origin_opener_policy\"\n- Specifies a value for the Cross-Origin-Opener-Policy HTTP header, which lets you ensure that a top-level extension page doesn't share a browsing context group with cross-origin documents.\n\"declarative_net_request\"\n- Defines static rules for the declarativeNetRequest API, which allows blocking and modifying of network requests.\n\"default_locale\"\n- A string that defines the default language of an extension that supports multiple locales. Examples include \"en\" and \"pt_BR\". This key is required in localized extensions, and must not be used in extensions that aren't localized. For more information, see Internationalization.\n\"devtools_page\"\n- Defines pages that use the DevTools APIs.\n\"export\"\n- Allows resources to be exported from the extension. For more information, see Export.\n\"externally_connectable\"\n- Specifies what other pages and extensions can connect to your extensions. For\nmore information, see\n\"externally_connectable\"\n. \"homepage_url\"\n- A string specifying a URL for the extension's homepage. If this is undefined, the homepage defaults to the extension's Chrome Web Store page. This field is particularly useful if you host the extension on your own site.\n\"host_permissions\"\n- Lists the web pages your extension is allowed to interact with, defined using URL match patterns. User permission for these sites is requested at install time. For more information, see Host permissions.\n\"import\"\n- Allows resources to be imported into the extension. For more information, see Import.\n\"incognito\"\n- Defines how the extension behaves in incognito mode. Supported values are\n\"spanning\"\n,\"split\"\n, and\"not_allowed\"\n. For more information, see Incognito. \"key\"\n- Specifies your extension's ID for various development use cases. For more information, see Key.\n\"minimum_chrome_version\"\n- Defines the oldest Chrome version that can install your extension. The value\nmust be a substring of an existing Chrome browser version string, such as\n\"107\"\nor\"107.0.5304.87\"\n. Users with versions of Chrome older than the minimum version see a \"Not compatible\" warning in the Chrome Web Store, and are unable to install your extension. If you add this to an existing extension, users whose Chrome version is older won't receive automatic updates to your extension. This includes business users in ephemeral mode. \"oauth2\"\n- Allows the use of an OAuth 2.0 security ID. The value of this key must be an\nobject with\n\"client_id\"\nand\"scopes\"\nproperties. For details, see the OAuth 2.0 tutorial. \"omnibox\"\n- Allows the extension to register a keyword in Chrome's address bar. For more information, see Omnibox.\n\"optional_host_permissions\"\n- Declares optional host permissions for your extension.\n\"optional_permissions\"\n- Declares optional permissions for your extension.\n\"options_page\"\n- Specifies a path to an options.html file for the extension to use as an options page. For more information, see Give users options.\n\"options_ui\"\n- Specifies a path to an HTML file that lets a user change extension options from the Chrome Extensions page. For more information, see Embedded options.\n\"permissions\"\n- Enables use of particular extension APIs. See Permissions for a general explanation. Reference pages for individual APIs list the permissions they require.\n\"requirements\"\n- Lists technologies required to use the extension. For a list of supported requirements, see Requirements.\n\"sandbox\"\n- Defines a set of extension pages that don't have access to extension APIs or direct access to non-sandboxed pages. For more information, see Sandbox.\n\"short_name\"\n- A string containing a shortened version of the extension's name to be used when character space is limited. The maximum length is 12 characters. If this is undefined, a truncated version of the \"name\" key displays instead.\n\"side_panel\"\n- Identifies an HTML file to display in a sidePanel.\n\"storage\"\n- Declares a JSON schema for the managed storage area. For more information, see Manifest for storage areas.\n\"tts_engine\"\n- Registers the extension as a text to speech engine. For more information, see the ttsEngine API.\n\"update_url\"\n- A string containing the URL of the extension's updates page. Use this key if you're hosting your extension outside the Chrome Web Store.\n\"version_name\"\n- A string describing the extension's version. Examples include\n\"1.0 beta\"\nand\"build rc2\"\n. If this is unspecified, the \"version\" value displays on the extension management page instead. \"web_accessible_resources\"\n- Defines files within the extension that can be accessed by web pages or other extensions. For more information, see Web Accessible Resources.\nOptional ChromeOS keys\n\"file_browser_handlers\"\n- Provides access to the\nfileBrowserHandler\nAPI, which lets extensions access the ChromeOS file browser. \"file_handlers\"\n- Specifies file types for ChromeOS extensions to handle. For more information,\nsee\nfile_handlers\n. \"file_system_provider_capabilities\"\n- Allows access to the\nfileSystemProvider\nAPI, which lets extensions create file systems that ChromeOS can use. \"input_components\"\n- Allows the use of the Input Method Editor API. For more information, see\ninput_components\n."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/active-trials", "title": "404 | Page Not Found | Chrome for Developers", "text": "developer.chrome.com uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic. Learn more."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/author", "title": "Manifest - Author | Chrome Extensions | Chrome for Developers", "text": "An optional manifest key that takes an object with an \"email\" key (see the example below). This is the email address of the extension author. When publishing a CRX file to the Chrome Web Store, this string MUST match the email address of the account used to publish the extension.\n{\n// ...\n\"author\": {\n\"email\": \"user@example.com\"\n},\n// ...\n}"},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/background", "title": "Manifest - background | Chrome Extensions | Chrome for Developers", "text": "Manifest - background\nStay organized with collections\nSave and categorize content based on your preferences.\nAn optional manifest key used to specify a javascript file as the extension service worker. A service worker is a background script that acts as the extension's main event handler. For more information, visit the more comprehensive introduction to service workers.\n{\n...\n\"background\": {\n\"service_worker\": \"service-worker.js\",\n\"type\": \"module\"\n},\n...\n}\nExcept as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License, and code samples are licensed under the Apache 2.0 License. For details, see the Google Developers Site Policies. Java is a registered trademark of Oracle and/or its affiliates.\nLast updated 2023-05-24 UTC.\n[[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2023-05-24 UTC.\"],[],[]]"},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/chrome-settings-override", "title": "Overriding Chrome settings | Chrome Extensions | Chrome for Developers", "text": "Settings overrides are a way for extensions to override selected Chrome settings. The API is available on Windows and Mac in all current versions of Chrome.\nHomepage, search provider, and startup pages\nHere is an example of how homepage, search provider, and startup pages can be modified in the extension manifest. Any domain used in the settings API must be verified (via Google Search Console) by the same developer account publishing the extension. Note that if you verify ownership for a domain (for example, https://example.com) you can use any subdomain or page (for example, https://app.example.com or https://example.com/page.html) within your extension.\nUsing the settings override permission while also requesting any additional capabilities or permissions is inconsistent with our single purpose policy. When Chrome detects that an item is potentially violating our single purpose policy, a confirmation dialog is shown to the user. Extensions that limit themselves to only modifying a single setting without seeking additional capabilities or permissions do not get a confirmation dialog.\nThis applies to Chrome 107 and later.\n{\n\"name\": \"My extension\",\n...\n\"chrome_settings_overrides\": {\n\"homepage\": \"https://www.homepage.com\",\n\"search_provider\": {\n\"name\": \"name.__MSG_url_domain__\",\n\"keyword\": \"keyword.__MSG_url_domain__\",\n\"search_url\": \"https://www.foo.__MSG_url_domain__/s?q={searchTerms}\",\n\"favicon_url\": \"https://www.foo.__MSG_url_domain__/favicon.ico\",\n\"suggest_url\": \"https://www.foo.__MSG_url_domain__/suggest?q={searchTerms}\",\n\"instant_url\": \"https://www.foo.__MSG_url_domain__/instant?q={searchTerms}\",\n\"image_url\": \"https://www.foo.__MSG_url_domain__/image?q={searchTerms}\",\n\"search_url_post_params\": \"search_lang=__MSG_url_domain__\",\n\"suggest_url_post_params\": \"suggest_lang=__MSG_url_domain__\",\n\"instant_url_post_params\": \"instant_lang=__MSG_url_domain__\",\n\"image_url_post_params\": \"image_lang=__MSG_url_domain__\",\n\"alternate_urls\": [\n\"https://www.moo.__MSG_url_domain__/s?q={searchTerms}\",\n\"https://www.noo.__MSG_url_domain__/s?q={searchTerms}\"\n],\n\"encoding\": \"UTF-8\",\n\"is_default\": true\n},\n\"startup_pages\": [\"https://www.startup.com\"]\n},\n\"default_locale\": \"de\",\n...\n}\nCustomizing values\nValues in the manifest can be customized in the following ways:\n- All values of the\nsearch_provider\n,homepage\n, andstartup_pages\nproperties can be localized using thechrome.i18n\nAPI. For external extensions, the\nsearch_provider\n,homepage\nandstartup_pages\nURL values can be parametrized using a registry key. Create a new registry entry next to the\"update_url\"\nkey (see instructions here). The key name is\"install_parameter\"\n, the value is an arbitrary string:{ \"update_url\": \"https://clients2.google.com/service/update2/crx\", \"install_parameter\": \"Value\" }\nAll occurrences of the substring\n\"__PARAM__\"\nin the manifest URLs will be substituted with the\"install_parameter\"\nvalue. If\"install_parameter\"\nis absent, occurrences of\"__PARAM__\"\nare removed. Note that\"__PARAM__\"\ncannot be part of the hostname. It needs to occur after the first '/' in the URL.\nReference\nAn extension can override one or more of the following properties in the manifest:\nalternate_urls\n(array of strings, optional)- A list of URL patterns that can be used in addition to\nsearch_url.\nencoding\n(string, optional)- The encoding used for search terms. This is required if you don't set\nprepopulated_id\n. favicon_url\n(string, optional)- An icon URL for the search engine. This is required if you don't set\nprepopulated_id\n. homepage\n(string, optional)- The new value for the homepage.\nimage_url\n(string, optional)- The URL the search engine uses for image search. If this isn't used, the engine doesn't support image search.\nimage_url_post_params\n(string, optional)- The post parameters for\nimage_url\n. is_default\n(boolean, required)- Specifies whether the search provider should be default.\nkeyword\n(string, optional)- An omnibox keyword for the search engine. This is required if you don't set\nprepopulated_id\n. name\n(string, optional)- Name of the search engine displayed to user. This is required if you don't set\nprepopulated_id\n. prepopulated_id\n(integer, optional)- An ID for Chrome's built-in search engine.\nsearch_provider\n(object, optional)- A search engine.\nsearch_url\n(string, required)- The search URL the search engine uses.\nsearch_url_post_params\n(string, optional)- The post parameters for\nsearch_url\n. startup_pages\n(array of strings, optional)- An array of length one containing a URL to be used as the startup page.\nsuggest_url\n(string, optional)- The URL the search engine uses for suggestions. If this isn't used, the engine doesn't support suggestions.\nsuggest_url_post_params\n(string, optional)- The post parameters for\nsuggest_url\n."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/content-scripts", "title": "Manifest - content scripts | Chrome Extensions | Chrome for Developers", "text": "The \"content_scripts\"\nkey specifies a statically loaded JavaScript or CSS file to be used every time a page is opened that matches a certain URL pattern. Extensions can also inject content scripts programmatically, see Injecting Scripts for details.\nManifest\nThese are the supported keys for \"content_scripts\"\n. Only the \"matches\"\nkey and either \"js\"\nor \"css\"\nare required.\nmanifest.json\n{\n\"name\": \"My extension\",\n...\n\"content_scripts\": [\n{\n\"matches\": [\"https://*.example.com/*\"],\n\"css\": [\"my-styles.css\"],\n\"js\": [\"content-script.js\"],\n\"exclude_matches\": [\"*://*/*foo*\"],\n\"include_globs\": [\"*example.com/???s/*\"],\n\"exclude_globs\": [\"*bar*\"],\n\"all_frames\": false,\n\"match_origin_as_fallback\": false,\n\"match_about_blank\": false,\n\"run_at\": \"document_idle\",\n\"world\": \"ISOLATED\",\n}\n],\n...\n}\nFiles\nEach file must contain a relative path to a resource in the extension's root directory. Leading slashes (/\n) are automatically trimmed. The \"run_at\"\nkey specifies when each file will be injected.\n\"css\"\n- Array- Optional. An array of CSS file paths, injected in the order of this array, and before any DOM construction or page rendering occurs.\n\"js\"\n- Array,- Optional. An array of JavaScript file paths, injected in the order they appear in this array, after css files are injected. Each string in the array must be a relative path to a resource in the extension's root directory. Leading slashes ('/') are automatically trimmed.\nMatch URLs\nOnly the \"matches\"\nproperty is required. Then you can use \"exclude_matches\"\n, \"include_globs\"\n, and \"exclude_globs\"\nto customize which URLs to inject code into. The \"matches\"\nkey will trigger a warning.\n\"matches\"\n- Array- Required. Specifies which URL patterns to inject the content scripts into. See Match Patterns for syntax.\n\"exclude_matches\"\n- Array- Optional. Excludes the URL patterns to inject the content scripts into. See Match Patterns for syntax.\n\"include_globs\"\n- Array- Optional. Applied after matches to include only those URLs that also match this glob. Intended to emulate the @include Greasemonkey keyword.\n\"exclude_globs\"\n- Array- Optional. Applied after matches to exclude URLs that match this glob. Intended to emulate the @exclude Greasemonkey keyword.\nGlob URLs are those that contain \"wildcards\" * and question marks. The wildcard * matches any string of any length, including an empty string, while the question mark ? matches any single character.\nThe content script is injected into a page if:\n- Its URL matches any\n\"matches\"\nand\"include_globs\"\npatterns. - And the URL doesn't match\n\"exclude_matches\"\nor\"exclude_globs\"\npatterns.\nGlobs and URL matching examples\n\"include_globs\"\nmanifest.json\n{\n...\n\"content_scripts\": [\n{\n\"matches\": [\"https://*.example.com/*\"],\n\"include_globs\": [\"https://???.example.com/foo/*\"],\n\"js\": [\"content-script.js\"]\n}\n],\n...\n}\nhttps://www.example.com/foo/bar https://the.example.com/foo/\nhttps://my.example.com/foo/bar https://example.com/foo/* https://www.example.com/foo\nmanifest.json\n{\n...\n\"content_scripts\": [\n{\n\"matches\": [\"https://*.example.com/*\"],\n\"include_globs\": [\"*example.com/???s/*\"],\n\"js\": [\"content-script.js\"]\n}\n],\n...\n}\nhttps://www.example.com/arts/index.html https://www.example.com/jobs/index.html\nhttps://www.example.com/sports/index.html https://www.example.com/music/index.html\n\"exclude_globs\"\nmanifest.json\n{\n...\n\"content_scripts\": [\n{\n\"matches\": [\"https://*.example.com/*\"],\n\"exclude_globs\": [\"*science*\"],\n\"js\": [\"content-script.js\"]\n}\n],\n...\n}\nhttps://history.example.com https://.example.com/music\nhttps://science.example.com https://www.example.com/science\nAdvanced customization example\nmanifest.json\n{\n...\n\"content_scripts\": [\n{\n\"matches\": [\"https://*.example.com/*\"],\n\"exclude_matches\": [\"*://*/*business*\"],\n\"include_globs\": [\"*example.com/???s/*\"],\n\"exclude_globs\": [\"*science*\"],\n\"js\": [\"content-script.js\"]\n}\n],\n...\n}\nhttps://www.example.com/arts/index.html https://.example.com/jobs/index.html\nhttps://science.example.com https://www.example.com/jobs/business https://www.example.com/science\nFrames\nThe \"all_frames\"\nkey specifies if the content script should be injected into all frames matching the specified URL requirements. If set to false\nit will only inject into the topmost frame. It can be used along with \"match_about_blank\"\nto inject into an about:blank\nframe.\nTo inject into other frames like data:\n, blob:\n, and filesystem:\n, set the \"match_origin_as_fallback\"\nto true\n. For details, see Inject in related frames\n\"all_frames\"\nBoolean- Optional. Defaults to\nfalse\n, meaning that only the top frame is matched. If set to true, it will inject into all frames, even if the frame is not the topmost frame in the tab. Each frame is checked independently for URL requirements, it won't inject into child frames if the URL requirements are not met. \"match_about_blank\"\n- Boolean- Optional. Defaults to\nfalse\n. Whether the script should inject into anabout:blank\nframe where the parent URL matches one of the patterns declared in\"matches\"\n. \"match_origin_as_fallback\"\n- Boolean- Optional. Defaults to\nfalse\n. Whether the script should inject in frames that were created by a matching origin, but whose URL or origin may not directly match the pattern. These include frames with different schemes, such asabout:\n,data:\n,blob:\n, andfilesystem:\n.\nRun time and execution environment\nBy default, content scripts are injected when the document and all resources are finished loading, and live in a private isolated execution environment that isn't accessible to the page or other extensions. You can change these defaults in the following keys:\n\"run_at\"\n-document_start\n|document_end\n|document_idle\n- Optional. Specifies when the script should be injected into the page. It corresponds with the loading states of Document.readyState:\n\"document_start\"\n: the DOM is still loading.\"document_end\"\n: the page's resources are still loading\"document_idle\"\n: the DOM and resources have finished loading. This is the default.\n\"world\"\n-ISOLATED\n|MAIN\n- Optional. The JavaScript world for a script to execute within. Defaults to\n\"ISOLATED\"\n, which is the execution environment unique to the content script. Choosing the\"MAIN\"\nworld means the script will share the execution environment with the host page's JavaScript. See Work in isolated worlds to learn more.\nExample\nSee the Run on every page tutorial to build an extension that injects a content script in the manifest."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/content-security-policy", "title": "Manifest - Content Security Policy | Chrome Extensions | Chrome for Developers", "text": "An optional manifest key containing a web platform content security policy which specifies restrictions on the scripts, styles, and other resources an extension can use. Within this manifest key, separate optional policies can be defined for both extension pages and sandboxed extension pages.\nThe \"extension pages\" policy applies to page and worker contexts in the extension. This would include the extension popup, background worker, and tabs with HTML pages or iframes that were opened by the extension. The sandbox policy applies to all pages specified as a sandbox page in the manifest.\nDefault Policy\nIf the content security policy is not defined by the user in the manifest, the default properties will be used for both extension pages and sandboxed extension pages.\nThese defaults are equivalent to specifying the following policies in your manifest:\n{\n// ...\n\"content_security_policy\": {\n\"extension_pages\": \"script-src 'self'; object-src 'self';\",\n\"sandbox\": \"sandbox allow-scripts allow-forms allow-popups allow-modals; script-src 'self' 'unsafe-inline' 'unsafe-eval'; child-src 'self';\"\n}\n// ...\n}\nIn this case, the extension will only load local scripts and objects from its own packaged resources. WebAssembly will be disabled, and the extension won't run inline Javascript or be able to evaluate strings as executable code. If a sandbox page is added, it will have more relaxed permissions for evaluating scripts from outside the extension.\nMinimum and customized Content Security Policies\nDevelopers may add or remove rules for their extension, or use the minimum required content security policy, to fit the needs of their project.\nExtension Pages Policy\nChrome enforces a minimum content security policy for extension pages. It is equivalent to specifying the following policy in your manifest:\n{\n// ...\n\"content_security_policy\": {\n\"extension_pages\": \"script-src 'self' 'wasm-unsafe-eval'; object-src 'self';\"\n}\n// ...\n}\nThe extension_pages\npolicy cannot be relaxed beyond this minimum value. In other words, you cannot add other script sources to directives, such as adding 'unsafe-eval'\nto script-src\n. If you add a disallowed source to your extension's policy, Chrome will throw an error like this at install time:\n'content_security_policy.extension_pages': Insecure CSP value \"'unsafe-eval'\" in directive 'script-src'.\nSandbox Pages Policy\nThe default policy for sandboxed pages is much more lenient than with extension pages, as the sandbox page does not have access to extension APIs, or direct access to non-sandboxed pages. The sandbox content security policy can be customized as needed."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/content_security_policy", "title": "404 | Page Not Found | Chrome for Developers", "text": "developer.chrome.com uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic. Learn more."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/cross-origin-embedder-policy", "title": "Cross-origin embedder policy | Chrome Extensions | Chrome for Developers", "text": "The cross_origin_embedder_policy\nmanifest key lets the extension specify a value for the\nCross-Origin-Embedder-Policy (COEP) response header for requests to the extension's\norigin. This includes the extension's service worker, popup, options page, tabs that are open to an extension resource, etc.\nTogether with cross_origin_opener_policy, this key allows the extension to opt into cross-origin isolation.\nManifest declaration\nThe cross_origin_embedder_policy\nmanifest key contains an object with one\nproperty named value\nthat takes a string. Chrome uses this string as the value of the\nCross-Origin-Embedder-Policy\nheader when serving resources from the extension's origin. For\nexample:\n{\n...\n\"cross_origin_embedder_policy\": {\n\"value\": \"require-corp\"\n},\n...\n}\nSee the Cross-origin isolation overview for more information about this feature."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/cross-origin-opener-policy", "title": "Cross-origin opener policy | Chrome Extensions | Chrome for Developers", "text": "The cross_origin_opener_policy\nmanifest key lets extensions specify a value for the\nCross-Origin-Opener-Policy (COOP) response header for requests to the extension's\norigin. This includes the extension's service worker, popup, options page, tabs that are open to an extension resource, etc.\nTogether with cross_origin_embedder_policy, this key allows extensions opt into cross-origin isolation.\nManifest declaration\nThe cross_origin_opener_policy\nmanifest key contains an object with one\nproperty named value\nthat takes a string. Chrome uses this string as the value of the\nCross-Origin-Opener-Policy\nheader when serving resources from the extension's origin. For example:\n{\n...\n\"cross_origin_opener_policy\": {\n\"value\": \"same-origin\"\n},\n...\n}\nSee Cross-origin isolation overview for more information about this feature."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/default-locale", "title": "Manifest - Default Locale | Chrome Extensions | Chrome for Developers", "text": "Defines the default language of an extension that supports multiple locales. It is the name of the subdirectory in _locales\nthat contains the default language for this extension. For example, the following code indicates that English is the default language:\n\"default_locale\": \"en\"\nThis field is required for localized extensions (those with a _locales\ndirectory), but must be absent in\nextensions that have no _locales\ndirectory. For details, see Internationalization."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/description", "title": "Manifest - Description | Chrome Extensions | Chrome for Developers", "text": "Manifest - Description\nStay organized with collections\nSave and categorize content based on your preferences.\nA plain text string (no HTML or other formatting; no more than 132 characters) that describes the\nextension. For example:\n\"description\": \"A description of my extension\"\nThe description should be suitable for both the browser's Extensions page (chrome://extensions) and the\nChrome Web Store. You can specify locale-specific strings for this field; see\nInternationalization for details.\nExcept as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License, and code samples are licensed under the Apache 2.0 License. For details, see the Google Developers Site Policies. Java is a registered trademark of Oracle and/or its affiliates.\nLast updated 2013-05-12 UTC.\n[[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2013-05-12 UTC.\"],[],[]]"},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/event-rules", "title": "event_rules | Chrome Extensions | Chrome for Developers", "text": "The event_rules\nmanifest property provides a mechanism to add rules that intercept, block, or\nmodify web requests in-flight using declarativeWebRequest or take actions depending on the\ncontent of a page, without requiring permission to read the page's content using\ndeclarativeContent.\nTranslating rules from javascript to manifest\nThe following defines a rule to display a page action if the current page has a video css tag in javascript:\nchrome.declarativeContent.onPageChanged.addRules([{\nactions: [\nnew chrome.declarativeContent.ShowPageAction()\n],\nconditions: [\nnew chrome.declarativeContent.PageStateMatcher(\n{css: [\"video\"]}\n)\n]\n}]);\nThis is the same definition in the manifest:\n{\n\"name\": \"Sample extension\",\n\"event_rules\": [{\n\"event\": \"declarativeContent.onPageChanged\",\n\"actions\": [{\n\"type\": \"declarativeContent.ShowPageAction\"\n}],\n\"conditions\": [{\n\"type\": \"declarativeContent.PageStateMatcher\",\n\"css\": [\"video\"]\n}]\n}],\n...\n}"},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable", "title": "externally_connectable | Chrome Extensions | Chrome for Developers", "text": "The \"externally_connectable\"\nmanifest property declares which extensions and web pages can\nconnect to your extension using runtime.connect()\nand runtime.sendMessage()\n.\nFor a tutorial on message passing, see cross-extension messaging and sending messages from web pages.\nConnect without externally_connectable\nIf the externally_connectable\nkey is not declared in your extension's manifest, all extensions can connect, but no web pages can connect. As a consequence, when updating your manifest to use\nexternally_connectable\n, if \"ids\": [\"*\"]\nis not specified, then other extensions will\nlose the ability to connect to your extension. This may be an unintended consequence, so keep it in\nmind.\nManifest\n{\n\"name\": \"My externally connectable extension\",\n\"externally_connectable\": {\n\"ids\": [\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n\"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",\n...\n],\n// If this field is not specified, no web pages can connect.\n\"matches\": [\n\"https://*.google.com/*\",\n\"*://*.chromium.org/*\",\n...\n],\n\"accepts_tls_channel_id\": false\n},\n...\n}\nReference\nThe \"externally_connectable\"\nmanifest key includes the following optional properties:\n\"ids\"\n- The IDs of extensions that are allowed to connect. If left empty or unspecified, no extensions or apps can connect. The wildcard\n\"*\"\nwill allow all extensions and apps to connect. \"matches\"\n- The URL patterns for web pages that are allowed to connect. If left empty or unspecified, no web pages can connect. Patterns cannot include wildcard domains nor subdomains of (effective) top-level domains, for example:\n| \u2705 Valid URLs | \u274c Invalid URLs |\n|---|---|\n*://example.com/ |\n*://example.com/one/ |\nhttp://*.example.org/* |\n<all_urls> |\nhttps://example.com/* |\nhttp://*/* |\n\"accepts_tls_channel_id\"\n- Enables the extension to use the TLS channel ID of the web page connecting to it. The web page must also opt to send the TLS channel ID to the extension by setting\nincludeTlsChannelId\ntotrue\nin runtime.connect's connectInfo or runtime.sendMessage's options. If set tofalse\n, runtime.MessageSender.tlsChannelId will never be set under any circumstance.\nThis does not affect content scripts."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/file-handlers", "title": "file_handlers | Chrome Extensions | Chrome for Developers", "text": "The \"file_handlers\"\nmanifest key specifies file types to be handled by a ChromeOS extension. To process a file, use the web platform's Launch Handler API. For extension specific information, see File Handling.\n\"file_handlers\": [\n{\n\"action\": \"/open_text.html\",\n\"name\": \"Plain text\",\n\"accept\": {\n\"text/plain\": [\".txt\"]\n}\n\"launch_type\": \"single-client\"\n}\n]\n\"file_handlers\"\n(dictionary, optional)- Specifies the file types the extension can open.\n\"action\"\n(string, required)- Specifies an HTML file to show when a file is opened. The file must be within your extension. Processing the file, whether it's displayed or used in some other way, is done with JavaScript using appropriate web platform APIs. This code must be in a separate JavaScript file included via a\n<script>\ntag. \"name\"\n(string, required)- A user friendly description of the action.\n\"accept\"\n(dictionary, required)- The file types that can be processed by the page specified in\n\"action\"\n. The items in the dictionary are a key/value pair where the key is a MIME type and the value is an array of file extensions. Only known MIME types are allowed for the key. Custom file types are allowed but the key for a custom type must be a known MIME type, and the mapping between the MIME type and the custom file type must be supported by the underlying operating system. \"launch_type\"\n(object, optional)- Specifies whether multiple files should be opened in a single client or multiple clients. Valid values are\n\"single-client\"\nand\"multiple-clients\"\n. The default value is\"single-client\"\n."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/homepage-url", "title": "Manifest - Homepage Url | Chrome Extensions | Chrome for Developers", "text": "Manifest - Homepage Url\nStay organized with collections\nSave and categorize content based on your preferences.\nAn optional manifest key containing a string for a valid homepage URL. Developers may choose to set the extension's homepage to their personal or company's website. If the parameter is left undefined, the default homepage will be the extension's Chrome Web Store page listed on the extensions management page (chrome://extensions). This field is particularly useful if you host the extension on your own site.\n{\n// ...\n\"homepage_url\": \"https://example.com,\",\n// ...\n}\n```\nExcept as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License, and code samples are licensed under the Apache 2.0 License. For details, see the Google Developers Site Policies. Java is a registered trademark of Oracle and/or its affiliates.\nLast updated 2013-05-12 UTC.\n[[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2013-05-12 UTC.\"],[],[]]"},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/icons", "title": "Manifest - Icons | Chrome Extensions | Chrome for Developers", "text": "One or more icons that represent the extension or theme. You should always provide a 128x128 icon; it's used during installation and by the Chrome Web Store. Extensions should also provide a 48x48 icon, which is used in the extensions management page (chrome://extensions). You can also specify a 16x16 icon to be used as the favicon for an extension's pages.\nIcons should generally be in PNG format, because PNG has the best support for transparency. They can, however, be in any raster format supported by Blink, including BMP, GIF, ICO, and JPEG.\nHere's an example of how to declare the icons in the manifest:\n\"icons\": {\n\"16\": \"icon16.png\",\n\"32\": \"icon32.png\",\n\"48\": \"icon48.png\",\n\"128\": \"icon128.png\"\n},\nSee Extension icons details on Chrome Web Store requirements and best practices."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/incognito", "title": "Manifest - Incognito | Chrome Extensions | Chrome for Developers", "text": "Use the \"incognito\"\nmanifest key with either \"spanning\"\nor \"split\"\nto specify how this\nextension will behave if allowed to run in incognito mode. Using \"not_allowed\"\nto prevent this\nextension from being enabled in incognito mode.\nSpanning mode\nThe default mode is \"spanning\"\n, which means that the extension will run in a single\nshared process. Any events or messages from an incognito tab will be sent to the shared process,\nwith an incognito flag indicating where it came from. Because incognito tabs cannot use this\nshared process, an extension using the \"spanning\"\nincognito mode will not be able to load pages\nfrom its extension package into the main frame of an incognito tab.\nSplit mode\nThe \"split\"\nmode means that all pages in an incognito window will run in their own incognito\nprocess. If the extension contains a background page, that will also run in the incognito process.\nThis incognito process runs along side the regular process, but has a separate memory-only cookie\nstore. Each process sees events and messages only from its own context (for example, the incognito\nprocess will see only incognito tab updates). The processes are unable to communicate with each\nother.\nNot allowed\nThe extension cannot be enabled in incognito mode. Available from Chrome 47.\nHow to choose\nAs a rule of thumb, if your extension needs to load a tab in an incognito browser, use split incognito behavior. If your extension needs to be logged into a remote server use spanning incognito behavior.\nchrome.storage.sync and chrome.storage.local are always shared between regular and incognito processes. It is recommended to use them for persisting your extension's settings."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/input-components", "title": "Manifest - input_components | Chrome Extensions | Chrome for Developers", "text": "An optional Manifest key enabling the use of the input.ime\nAPI (Input Method Editor) for use with ChromeOS. This allows your extension to handle keystrokes, set the composition, and open assistive windows. Developers must also declare the \"input\"\npermission in the extension's \"permissions\"\narray.\nThe key accepts an array of objects: name\n, id\n, language\n, layouts\n, input_view\n, and options_page\n(Refer to the table below).\n| Property | Type | Description |\n|---|---|---|\nname |\nstring | Required name of the input component object. |\nid |\nstring | Optional component object id. |\nlanguage |\nstring (or array of strings) | Optional specified language or list of applicable languages. Examples: \"en\", [\"en\", \"pt\"] |\nlayouts |\nstring (or array of strings) | Optional list of input methods. Note that ChromeOS only supports one layout per input method. If multiple layouts are specified, selection order is undefined. Extensions are therefore strongly encouraged to only specify one layout per input method. For keyboard layouts, a xkb: prefix indicates that this is a keyboard layout extension. |\n| Example: [\"us::eng\"] | ||\ninput_view |\nstring | Optional string specifying an extension resource. |\noptions_page |\nstring | Optional string specifying an extension resource. If not provided, the default extension's options page will be used. |\n{\n// ...\n\"input_components\": [{\n\"name\": \"ToUpperIME\",\n\"id\": \"ToUpperIME\",\n\"language\": \"en\",\n\"layouts\": [\"us::eng\"]\n}]\n// ...\n}"},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/key", "title": "Manifest - key | Chrome Extensions | Chrome for Developers", "text": "This value maintains the unique ID of an extension, or theme when it is loaded during development. The following are some common use cases:\n- To configure a server to only accept requests from your Chrome Extension origin.\n- So that other extensions or websites can send messages to your extension.\n- So that a website can access the\nweb_accessible_resources\nof your extension.\nKeep a consistent extension ID\nPreserving a single ID is essential during development. To keep a consistent ID, follow these steps:\nUpload extension to the developer dashboard\nPackage the extension directory into a .zip\nfile and upload it to the Chrome Developer\nDashboard without publishing it:\n- On the Developer Dashboard, click Add new item.\n- Click Browse files, select the extension's zip file, and upload it.\n- Go to the Package tab and click View public key.\nWhen the popup is open, follow these steps:\n- Copy the code in between\n-----BEGIN PUBLIC KEY-----\nand-----END PUBLIC KEY-----\n. - Remove the newlines in order to make it a single line of text.\nAdd the code to the manifest.json\nunder the \"key\"\nfield.\nThis way the extension will use the same ID.\n{ // manifest.json\n\"manifest_version\": 3,\n...\n\"key\": \"ThisKeyIsGoingToBeVeryLong/go8GGC2u3UD9WI3MkmBgyiDPP2OreImEQhPvwpliioUMJmERZK3zPAx72z8MDvGp7Fx7ZlzuZpL4yyp4zXBI+MUhFGoqEh32oYnm4qkS4JpjWva5Ktn4YpAWxd4pSCVs8I4MZms20+yx5OlnlmWQEwQiiIwPPwG1e1jRw0Ak5duPpE3uysVGZXkGhC5FyOFM+oVXwc1kMqrrKnQiMJ3lgh59LjkX4z1cDNX3MomyUMJ+I+DaWC2VdHggB74BNANSd+zkPQeNKg3o7FetlDJya1bk8ofdNBARxHFMBtMXu/ONfCT3Q2kCY9gZDRktmNRiHG/1cXhkIcN1RWrbsCkwIDAQAB\",\n}\nCompare IDs\nOpen the Extensions Management page at chrome://extensions\n, ensure Developer mode is enabled,\nand upload the unpackaged extension directory. Compare the extension ID on the extensions management\npage to the Item ID in the Developer Dashboard. They should match."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/manifest-version", "title": "Manifest Version | Chrome Extensions | Chrome for Developers", "text": "An integer specifying the version of the manifest file format your package requires. This key is required. For example:\n\"manifest_version\": 3\nSupported values for this key are:\n3\n: Use the Manifest V3 format and associated feature set.\nThe current version is Manifest V3. The Chrome Web Store no longer accepts manifest V2 extensions (see Manifest V2 support timeline for more details). There will be other manifest versions in the future (V4 and beyond), but these aren't scheduled yet."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/minimum-chrome-version", "title": "Manifest - Minimum Chrome Version | Chrome Extensions | Chrome for Developers", "text": "An optional manifest key containing a string that defines which versions of Chrome are able to install the extension. The value set for this string must be a substring of an existing Chrome browser version string. Use a full version number to specify a specific update to Chrome, or use the first number in the string to specify a particular major version.\n{\n// ...\n\"minimum_chrome_version\": \"126\",\n// ...\n}\nEnforcement\nNew Installs\nIn versions of Chrome older than the minimum version, the Chrome Web Store will show a \"Not compatible\" message in place of the install button. Users on these versions won't be able to install your extension.\nExisting Installs\nExisting users of your extension won't receive updates when the\nminimum_chrome_version\nis higher than their current browser version. This\nhappens silently so you should exercise caution and consider ways of letting\nexisting users know that they are no longer receiving updates."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/name", "title": "Manifest - name | Chrome Extensions | Chrome for Developers", "text": "The \"name\"\nkey (required) is a short, plain text string (maximum of 75\ncharacters) that identifies the extension. For example:\n{\n\"name\": \"My extension name\"\n}\nYou can specify a locale-specific string; see Internationalization for details.\nIt is displayed in the following locations:\n- Install dialog\n- Extensions page (chrome://extensions)\n- Chrome Web Store\nSee also Short Name."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/oauth2", "title": "Manifest - oauth2 | Chrome Extensions | Chrome for Developers", "text": "An optional manifest key enabling the use of an OAuth 2.0 security ID on the extension. This key takes an object with two required sub-properties: \"client_id\"\nand \"scopes\"\n. When developing an extension that uses an \"oauth2\"\nkey, consider also setting the extension's \"key\"\nto keep a consistent extension ID.\nFor more detailed implementation instructions, visit the full OAuth 2.0 tutorial.\n{\n// ...\n\"oauth2\": {\n\"client_id\": \"YOUR_EXTENSION_OAUTH_CLIENT_ID.apps.googleusercontent.com\",\n\"scopes\": [\"https://www.googleapis.com/auth/contacts.readonly\"]\n},\n\"key\": \"EXTENSION_PUBLIC_KEY\",\n// ...\n}\n```"},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/requirements", "title": "Manifest - Requirements | Chrome Extensions | Chrome for Developers", "text": "Technologies required by the extension. Hosting sites such as the Chrome Web Store may use this list to dissuade users from installing extensions that will not work on their computer. Additional requirements checks may be added in the future.\nThe \"3D\"\nrequirement denotes GPU hardware acceleration and takes either \"webgl\"\nor \"css3d\"\nas valid values. The \"webgl\"\nrequirement refers to the WebGL\nAPI. For more information on Chrome 3D graphics support, see the help article on WebGL and 3D\ngraphics. You can list the 3D-related features your extension requires, as demonstrated in the\nfollowing example:\n\"requirements\": {\n\"3D\": {\n\"features\": [\"webgl\"]\n}\n}\nNPAPI Plugin support for extensions has been discontinued as of Chrome version 45. As part of this, the \"plugins\" requirement has been deprecated, and can no longer be used in a manifest file."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/sandbox", "title": "Manifest - Sandbox | Chrome Extensions | Chrome for Developers", "text": "Defines a collection of extension pages that are to be served in a sandboxed unique origin. The\nContent Security Policy used by an extension's sandboxed pages is specified in the\n\"content_security_policy\"\nkey.\nBeing in a sandbox has two implications:\n- A sandboxed page won't have access to extension APIs, or direct access to\nnon-sandboxed pages (it may communicate with them using\npostMessage()\n). - A sandboxed page is not subject to the Content Security Policy (CSP) used by the rest of\nthe extension (it has its own separate CSP value). This means that, for example, it can\nuse inline script and\neval()\n.\nFor example, here's how to specify that two extension pages are to be served in a sandbox with a custom CSP:\n{\n...\n\"content_security_policy\": {\n\"sandbox\": \"sandbox allow-scripts; script-src 'self' https://example.com\"\n},\n\"sandbox\": {\n\"pages\": [\n\"page1.html\",\n\"directory/page2.html\"\n]\n},\n...\n}\nIf not specified, the default \"content_security_policy\"\nvalue is sandbox allow-scripts allow-forms\nallow-popups allow-modals; script-src 'self' 'unsafe-inline' 'unsafe-eval'; child-src 'self';\n.\nYou can specify your CSP value to restrict the sandbox even further, but it MUST include the\n\"sandbox\"\ndirective and MUST NOT have the allow-same-origin\ntoken (see the HTML5\nspecification for possible sandbox tokens).\nNote that you only need to list pages that you expect to be loaded in windows or frames. Resources\nused by sandboxed pages (e.g. stylesheets or JavaScript source files) don't need to appear in the\npages\nlist because they will use the sandbox of the frame that embeds them.\n\"Using eval() in Chrome Extensions\" goes into more detail about implementing a sandboxing workflow that enables the use of libraries that would otherwise have issues executing under extension's default Content Security Policy."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/shared-modules", "title": "Shared modules | Chrome Extensions | Chrome for Developers", "text": "Shared Modules are permissionless collections of resources that can be shared between extensions. Common uses of Shared Modules are:\n- As an API. You can distribute a Shared Module that can provide HTML, JS, and other resources to provide an API that can be updated independently of the extensions that depend on it.\n- As a download optimization. The Shared Module contains common resources used by many extensions. It's downloaded once, the first time a dependent extension is installed.\nManifest\nShared Modules are used through two manifest fields: \"export\"\nand \"import\"\n.\nExport\nThe export field indicates an extension is a Shared Module that exports its resources:\n{\n\"version\": \"1.0\",\n\"name\": \"My Shared Module\",\n\"export\": {\n// Optional list of extension IDs explicitly allowed to\n// import this Shared Module's resources. If no allowlist\n// is given, all extensions are allowed to import it.\n\"allowlist\": [\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n\"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\"\n]\n}\n// Note: no permissions are allowed in Shared Modules\n}\nImport\nThe import field is used by extensions and apps to declare that they depend on the resources from particular Shared Modules:\n{\n\"version\": \"1.0\",\n\"name\": \"My Importing Extension\",\n...\n\"import\": [\n{\"id\": \"cccccccccccccccccccccccccccccccc\"},\n{\"id\": \"dddddddddddddddddddddddddddddddd\"\n\"minimum_version\": \"0.5\" // optional\n},\n]\n}\nAccessing resources\nShared Module resources are accessed by a reserved path _modules/SHARED_MODULE_ID in the root\nof your importing extension. For example, to include the script foo.js\nfrom a Shared Module with\nID \"cccccccccccccccccccccccccccccccc\", use this path from the root of your extension:\n<script src=\"_modules/cccccccccccccccccccccccccccccccc/foo.js\">\nIf the importing extension has ID \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", then the full URL to resources in the Shared Module is:\nchrome-extension://aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/_modules/cccccccccccccccccccccccccccccccc/\nNote that since resources from Shared Modules are overlaid into the origin of the importing extension, all privileges granted to the importing extension are available to code in Shared Modules. Also, the Shared Module can access resources in the importing extension by using absolute paths.\nInstall / uninstall\nA Shared Module is automatically installed from the Chrome Web Store when needed by a dependent extension and automatically uninstalled when the last extension which references it is uninstalled. To upload an extension that uses a Shared Module, the Shared Module must be published in the Chrome Web Store and the extension must not be restricted from using the Shared Module by its allowlist.\nDuring development, you will need to manually install any Shared Modules your extension uses. Automatic installs do not happen for extensions that are side-loaded or loaded as unpacked extensions. For locally installed, unpacked Shared Modules, you must use the key field to ensure the Shared Modules use the correct IDs."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/short-name", "title": "Manifest - short_name | Chrome Extensions | Chrome for Developers", "text": "An optional manifest key defining the short version of the extension's name (maximum of 12 characters recommended). If this key is not specified, a truncated version of the \"name\"\nkey will be used. The short name is typically used where there is insufficient space to display the full name.\n{\n// ...\n\"short_name\": \"Short Name\"\n// ...\n}"},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/storage", "title": "Manifest for managed storage | Chrome Extensions | Chrome for Developers", "text": "Unlike the local\nand sync\nstorage areas, the managed\nstorage area requires its structure to be\ndeclared as JSON Schema and is strictly validated by Chrome. This schema must be stored in a\nfile indicated by the \"managed_schema\"\nproperty of the \"storage\"\nmanifest key and declares the\nenterprise policies supported by the extension.\nPolicies are analogous to options but are configured by a system administrator for policy installed extensions, allowing the extension to be preconfigured for all users of an organization. See how Chrome handles policies for examples from Chrome itself.\nAfter declaring the policies they can be read from the storage.managed API. It's up to the extension to enforce the policies configured by the administrator.\nSample manifest.json\nThe storage.managed_schema\nproperty indicates a file within the extension that contains the policy\nschema.\n{\n\"name\": \"My enterprise extension\",\n\"storage\": {\n\"managed_schema\": \"schema.json\"\n},\n...\n}\nChrome will then load these policies from the underlying operating system and from Google Apps for\nsigned-in users. The storage.onChanged\nevent is fired whenever a policy change is detected.\nYou can verify the policies that Chrome loaded at chrome://policy.\nSchema format\nThe JSON Schema format has some additional requirements from Chrome:\n- The top-level schema must have type\nobject\n. - The top-level\nobject\ncan't haveadditionalProperties\n. Theproperties\ndeclared are the policies for this extension. - Each schema must have either a\n$ref\nvalue or exactly onetype\n.\nIf the schema is invalid then Chrome won't load the extension and will indicate the reason why the\nschema wasn't validated. If a policy value does not conform to the schema then it won't be\npublished by the storage.managed\nAPI.\nSample schema\n{\n\"type\": \"object\",\n// \"properties\" maps an optional key of this object to its schema. At the\n// top-level object, these keys are the policy names supported.\n\"properties\": {\n// The policy name \"AutoSave\" is mapped to its schema, which in this case\n// declares it as a simple boolean value.\n// \"title\" and \"description\" are optional and are used to show a\n// user-friendly name and documentation to the administrator.\n\"AutoSave\": {\n\"title\": \"Automatically save changes.\",\n\"description\": \"If set to true then changes will be automatically saved.\",\n\"type\": \"boolean\"\n},\n// Other simple types supported include \"integer\", \"string\" and \"number\".\n\"PollRefreshRate\": {\n\"type\": \"integer\"\n},\n\"DefaultServiceUrl\": {\n\"type\": \"string\"\n},\n// \"array\" is a list of items that conform to another schema, described\n// in \"items\". An example to this schema is [ \"one\", \"two\" ].\n\"ServiceUrls\": {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"string\"\n}\n},\n// A more complex example that describes a list of bookmarks. Each bookmark\n// has a \"title\", and can have a \"url\" or a list of \"children\" bookmarks.\n// The \"id\" attribute is used to name a schema, and other schemas can reuse\n// it using the \"$ref\" attribute.\n\"Bookmarks\": {\n\"type\": \"array\",\n\"id\": \"ListOfBookmarks\",\n\"items\": {\n\"type\": \"object\",\n\"properties\": {\n\"title\": { \"type\": \"string\" },\n\"url\": { \"type\": \"string\" },\n\"children\": { \"$ref\": \"ListOfBookmarks\" }\n}\n}\n},\n// An \"object\" can have known properties listed as \"properties\", and can\n// optionally have \"additionalProperties\" indicating a schema to apply to\n// keys that aren't found in \"properties\".\n// This example policy could map a URL to its settings. An example value:\n// {\n// \"youtube.com\": {\n// \"blocklisted\": true\n// },\n// \"google.com\": {\n// \"bypass_proxy\": true\n// }\n// }\n\"SettingsForUrls\": {\n\"type\": \"object\",\n\"additionalProperties\": {\n\"type\": \"object\",\n\"properties\": {\n\"blocklisted\": { \"type\": \"boolean\" },\n\"bypass_proxy\": { \"type\": \"boolean\" }\n}\n}\n}\n}\n}"},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/trial_tokens", "title": "Manifest - Trial tokens | Chrome Extensions | Chrome for Developers", "text": "An array of trial tokens to enable Origin Trial and Deprecation Trial features in extension contexts. You can browse and register for active trials on the active trials page.\nTo participate in multiple trials simultaneously, include each token as a separate array entry.\n\"trial_tokens\": [\"AnlT7gRo/750gGKtoI/A3D2rL5yAQA9wISlLqHGE6vJQinPfk0HiIij5LhWs+iuB7mTeotXmEXkvdpOAC1YjAgAAAG97Im9yaWdpbiI6ImNocm9tZS1leHRlbnNpb246Ly9sampoamFha21uY2lib25uanBhb2dsYmhjamVvbGhrayIsImZlYXR1cmUiOiJJQ2Fubm90QmVsaWV2ZVlvdVdhc3RlZFlvdXJUaW1lRGVjb2RpbmdUaGlzIiwiZXhwaXJ5Ijo1NzI1NDA3OTk5fQ==\"]\nLearn more about how to register and use tokens in your extension in the official guide."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/version", "title": "Manifest - Version | Chrome Extensions | Chrome for Developers", "text": "One to four dot-separated integers identifying the version of this extension. A couple of rules apply to the integers:\n- The integers must be between 0 and 65535, inclusive.\n- Non-zero integers can't start with 0. For example, 032 is invalid because it begins with a zero.\n- They must not be all zero. For example, 0 and 0.0.0.0 are invalid while 0.1.0.0 is valid.\nHere are some examples of valid versions:\n\"version\": \"1\"\n\"version\": \"1.0\"\n\"version\": \"2.10.2\"\n\"version\": \"3.1.2.4567\"\nIf the published extension has a newer version string than the installed extension, then the extension is automatically updated.\nThe comparison starts with the leftmost integers. Then, if those integers are equal, the integers to the right are compared, and so on. For example, 1.2.0 is a newer version than 1.1.9.9999.\nA missing integer is equal to zero. For example, 1.1.9.9999 is newer than 1.1, and 1.1.9.9999 is older than 1.2.\nVersion name\nIn addition to the \"version\"\nfield, which is used for update purposes, \"version_name\"\ncan be set to a\ndescriptive version string and will be used for display purposes if present.\nHere are some examples of version names:\n\"version_name\": \"1.0 beta\"\n\"version_name\": \"build rc2\"\n\"version_name\": \"3.1.2.4567\"\nIf no version_name is present, the version field will be used for display purposes as well."},
{"source": "https://developer.chrome.com/docs/extensions/reference/manifest/web-accessible-resources", "title": "Manifest - Web Accessible Resources | Chrome Extensions | Chrome for Developers", "text": "Web-accessible resources are files inside an extension that can be accessed by web pages or other extensions. Extensions typically use this feature to expose images or other assets that need to be loaded in web pages, but any asset included in an extension's bundle can be made web accessible.\nBy default no resources are web accessible, as this allows a malicious website to fingerprint extensions that a user has installed or exploit vulnerabilities (for example XSS bugs) in installed extensions. Only pages or scripts loaded from an extension's origin can access that extension's resources.\nManifest declaration\nUse the web_accessible_resources\nmanifest property to declare which resources are exposed and to\nwhat origins. This property is an array of objects that declares resource access rules. Each object\nmaps an array of extension resources to an array of URLs and/or extension IDs that can access those resources.\n{\n...\n\"web_accessible_resources\": [\n{\n\"resources\": [ \"test1.png\", \"test2.png\" ],\n\"matches\": [ \"https://web-accessible-resources-1.glitch.me/*\" ]\n}, {\n\"resources\": [ \"test3.png\", \"test4.png\" ],\n\"matches\": [ \"https://web-accessible-resources-2.glitch.me/*\" ],\n\"use_dynamic_url\": true\n}\n],\n...\n}\nEach object in the array contains these elements:\n\"resources\"\n- An array of strings, each containing a relative path to a given resource from the extension's root directory. Resources may contain asterisks (\n*\n) for wildcard matches. For example,\"/images/*\"\nexposes everything in the extension'simages/\ndirectory, recursively, while\"*.png\"\nexposes all PNG files. \"matches\"\n- An array of strings, each containing a match pattern that specifies which sites can access this set of resources. Only the origin is used to match URLs. Origins include subdomain matching. Google Chrome emits an \"Invalid match pattern\" error if the pattern has a path other than '/*'.\n\"extension_ids\"\n- An array of strings, each containing the ID of an extension that can access the resources.\n\"use_dynamic_url\"\n- If true, only allow resources to be accessed through a dynamic ID. A dynamic ID is generated per session. That means it is regenerated when the browser restarts or the extension reloads.\nEach element must include a \"resources\"\nelement and either a \"matches\"\nor \"extension_ids\"\nelement. This establishes a mapping that exposes the specified resources to either web pages matching the pattern or to extensions with matching IDs. The \"use_dynamic_url\"\nelement is optional.\nNavigability of resources\nResources are available in a webpage via the URL\nchrome-extension://[PACKAGE ID]/[PATH]\n, which can be generated with the runtime.getURL()\nmethod. The resources are served with appropriate CORS headers, so they're available\nvia fetch()\n.\nA navigation from a web origin to an extension resource is blocked unless the resource is listed as web accessible. Note these corner cases:\n- When an extension uses the webRequest API to redirect a public resource request to a resource that is not web accessible, such a request is also blocked.\n- The above holds true even if the resource that is not web accessible is owned by the redirecting extension.\n- Navigation is blocked in incognito mode unless the value of the\n\"incognito\"\nfield is set to\"split\"\n.\nContent scripts themselves do not need to be allowed.\nExample\nThe Web Accessible Resources example demonstrates the use of this element in a working extension."},
{"source": "https://developer.chrome.com/docs/extensions/mv2/reference/pageAction", "title": "chrome.pageAction | Reference | Chrome for Developers", "text": "Description\nUse the chrome.pageAction\nAPI to put icons in the main Google Chrome toolbar, to the right of the address bar. Page actions represent actions that can be taken on the current page, but that aren't applicable to all pages. Page actions appear grayed out when inactive.\nAvailability\nSome examples:\n- Subscribe to this page's RSS feed\n- Make a slideshow out of this page's photos\nThe RSS icon in the following screenshot represents a page action that lets you subscribe to the RSS feed for the current page.\nHidden page actions appear grayed out. For example, the RSS feed below is grayed out, as you can't subscribe to the feed for the current page:\nPlease consider using a browser action instead, so that users can always interact with your extension.\nManifest\nRegister your page action in the extension manifest like this:\n{\n\"name\": \"My extension\",\n...\n\"page_action\": {\n\"default_icon\": { // optional\n\"16\": \"images/icon16.png\", // optional\n\"24\": \"images/icon24.png\", // optional\n\"32\": \"images/icon32.png\" // optional\n},\n\"default_title\": \"Google Mail\", // optional; shown in tooltip\n\"default_popup\": \"popup.html\" // optional\n},\n...\n}\nSince devices with less-common scale factors like 1.5x or 1.2x are becoming more common, you are encouraged to provide multiple sizes for your icons. Chrome will select the closest one and scale it to fill the 16-dip space. This also ensures that if the icon display size is ever changed, you don't need to do any more work to provide different icons! However, if the size difference is too extreme, this scaling can cause the icon to lose detail or look fuzzy.\nThe old syntax for registering the default icon is still supported:\n{\n\"name\": \"My extension\",\n...\n\"page_action\": {\n...\n\"default_icon\": \"images/icon32.png\" // optional\n// equivalent to \"default_icon\": { \"32\": \"images/icon32.png\" }\n},\n...\n}\nParts of the UI\nLike browser actions, page actions can have an icon, a tooltip, and popup; they can't have badges, however. In addition, page actions can be grayed out. You can find information about icons, tooltips, and popups by reading about the browser action UI.\nYou make a page action appear and be grayed out using the pageAction.show\nand\npageAction.hide\nmethods, respectively. By default, a page action appears grayed out. When you\nshow it, you specify the tab in which the icon should appear. The icon remains visible until the tab\nis closed or starts displaying a different URL (because the user clicks a link, for example).\nTips\nFor the best visual impact, follow these guidelines:\n- Do use page actions for features that make sense for only a few pages.\n- Don't use page actions for features that make sense for most pages. Use browser actions instead.\n- Don't constantly animate your icon. That's just annoying.\nTypes\nImageDataType\nPixel data for an image. Must be an ImageData object (for example, from a canvas\nelement).\nType\nImageData\nTabDetails\nProperties\n-\ntabId\nnumber optional\nThe ID of the tab to query state for. If no tab is specified, the non-tab-specific state is returned.\nMethods\ngetPopup()\nchrome.pageAction.getPopup(\ndetails: TabDetails,\ncallback?: function,\n)\nGets the html document set as the popup for this page action.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: string) => void\n-\nresult\nstring\n-\nReturns\n-\nPromise<string>\nChrome 101+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\ngetTitle()\nchrome.pageAction.getTitle(\ndetails: TabDetails,\ncallback?: function,\n)\nGets the title of the page action.\nParameters\n-\ndetails\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: string) => void\n-\nresult\nstring\n-\nReturns\n-\nPromise<string>\nChrome 101+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nhide()\nchrome.pageAction.hide(\ntabId: number,\ncallback?: function,\n)\nHides the page action. Hidden page actions still appear in the Chrome toolbar, but are grayed out.\nParameters\n-\ntabId\nnumber\nThe id of the tab for which you want to modify the page action.\n-\ncallback\nfunction optional\nChrome 67+The\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 101+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nsetIcon()\nchrome.pageAction.setIcon(\ndetails: object,\ncallback?: function,\n)\nSets the icon for the page action. The icon can be specified either as the path to an image file or as the pixel data from a canvas element, or as dictionary of either one of those. Either the path or the imageData property must be specified.\nParameters\n-\ndetails\nobject\n-\niconIndex\nnumber optional\nDeprecated. This argument is ignored.\n-\nimageData\nImageData | object optional\nEither an ImageData object or a dictionary {size -> ImageData} representing icon to be set. If the icon is specified as a dictionary, the actual image to be used is chosen depending on screen's pixel density. If the number of image pixels that fit into one screen space unit equals\nscale\n, then image with sizescale\n* n will be selected, where n is the size of the icon in the UI. At least one image must be specified. Note that 'details.imageData = foo' is equivalent to 'details.imageData = {'16': foo}' -\npath\nstring | object optional\nEither a relative image path or a dictionary {size -> relative image path} pointing to icon to be set. If the icon is specified as a dictionary, the actual image to be used is chosen depending on screen's pixel density. If the number of image pixels that fit into one screen space unit equals\nscale\n, then image with sizescale\n* n will be selected, where n is the size of the icon in the UI. At least one image must be specified. Note that 'details.path = foo' is equivalent to 'details.path = {'16': foo}' -\ntabId\nnumber\nThe id of the tab for which you want to modify the page action.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 101+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nsetPopup()\nchrome.pageAction.setPopup(\ndetails: object,\ncallback?: function,\n)\nSets the HTML document to be opened as a popup when the user clicks on the page action's icon.\nParameters\n-\ndetails\nobject\n-\npopup\nstring\nThe relative path to the HTML file to show in a popup. If set to the empty string (\n''\n), no popup is shown. -\ntabId\nnumber\nThe id of the tab for which you want to modify the page action.\n-\n-\ncallback\nfunction optional\nChrome 67+The\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 101+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nsetTitle()\nchrome.pageAction.setTitle(\ndetails: object,\ncallback?: function,\n)\nSets the title of the page action. This is displayed in a tooltip over the page action.\nParameters\n-\ndetails\nobject\n-\ntabId\nnumber\nThe id of the tab for which you want to modify the page action.\n-\ntitle\nstring\nThe tooltip string.\n-\n-\ncallback\nfunction optional\nChrome 67+The\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 101+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nshow()\nchrome.pageAction.show(\ntabId: number,\ncallback?: function,\n)\nShows the page action. The page action is shown whenever the tab is selected.\nParameters\n-\ntabId\nnumber\nThe id of the tab for which you want to modify the page action.\n-\ncallback\nfunction optional\nChrome 67+The\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 101+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/permissions", "title": "chrome.permissions | API | Chrome for Developers", "text": "Description\nUse the chrome.permissions\nAPI to request declared optional permissions at run time rather than install time, so users understand why the permissions are needed and grant only those that are necessary.\nConcepts and usage\nPermission warnings exist to describe the capabilities granted by an API, but some of these warnings may not be obvious. The Permissions API allows developers to explain permission warnings and introduce new features gradually which gives users a risk-free introduction to the extension. This way, users can specify how much access they are willing to grant and which features they want to enable.\nFor example, the optional permissions extension's core functionality is overriding the new tab page. One feature is displaying the user's goal of the day. This feature only requires the storage permission, which does not include a warning. The extension has an additional feature, that users can enable by clicking the following button:\nDisplaying the user's top sites requires the topSites permission, which has the following warning.\nImplement optional permissions\nStep 1: Decide which permissions are required and which are optional\nAn extension can declare both required and optional permissions. In general, you should:\n- Use required permissions when they are needed for your extension's basic functionality.\n- Use optional permissions when they are needed for optional features in your extension.\nAdvantages of required permissions:\n- Fewer prompts: An extension can prompt the user once to accept all permissions.\n- Simpler development: Required permissions are guaranteed to be present.\nAdvantages of optional permissions:\n- Better security: Extensions run with fewer permissions since users only enable permissions that are needed.\n- Better information for users: An extension can explain why it needs a particular permission when the user enables the relevant feature.\n- Easier upgrades: When you upgrade your extension, Chrome won't disable it for your users if the upgrade adds optional rather than required permissions.\nStep 2: Declare optional permissions in the manifest\nDeclare optional permissions in your extension manifest with the optional_permissions\nkey,\nusing the same format as the permissions field:\n{\n\"name\": \"My extension\",\n...\n\"optional_permissions\": [\"tabs\"],\n\"optional_host_permissions\": [\"https://www.google.com/\"],\n...\n}\nIf you want to request hosts that you only discover at runtime, include \"https://*/*\"\nin your extension's optional_host_permissions\nfield. This lets you specify any origin in \"Permissions.origins\"\nas long as it has a matching\nscheme.\nPermissions that can not be specified as optional\nMost Chrome extension permissions can be specified as optional, with the following exceptions.\n| Permission | Description |\n|---|---|\n\"debugger\" |\nThe chrome.debugger API serves as an alternate transport for Chrome's remote debugging protocol. |\n\"declarativeNetRequest\" |\nGrants the extension access to the chrome.declarativeNetRequest API. |\n\"devtools\" |\nAllows extension to expand Chrome DevTools functionality. |\n\"geolocation\" |\nAllows the extension to use the HTML5 geolocation API. |\n\"mdns\" |\nGrants the extension access to the chrome.mdns API. |\n\"proxy\" |\nGrants the extension access to the chrome.proxy API to manage Chrome's proxy settings. |\n\"tts\" |\nThe chrome.tts API plays synthesized text-to-speech (TTS). |\n\"ttsEngine\" |\nThe chrome.ttsEngine API implements a text-to-speech (TTS) engine using an extension. |\n\"wallpaper\" |\nChromeOS only. Use the chrome.wallpaper API change the ChromeOS wallpaper. |\nView Declare Permissions for further information on available permissions and their warnings.\nStep 3: Request optional permissions\nRequest the permissions from within a user gesture using permissions.request()\n:\ndocument.querySelector('#my-button').addEventListener('click', (event) => {\n// Permissions must be requested from inside a user gesture, like a button's\n// click handler.\nchrome.permissions.request({\npermissions: ['tabs'],\norigins: ['https://www.google.com/']\n}, (granted) => {\n// The callback argument will be true if the user granted the permissions.\nif (granted) {\ndoSomething();\n} else {\ndoSomethingElse();\n}\n});\n});\nChrome prompts the user if adding the permissions results in different warning messages than the user has already seen and accepted. For example, the previous code might result in a prompt like this:\nStep 4: Check the extension's current permissions\nTo check whether your extension has a specific permission or set of permissions, use\npermission.contains()\n:\nchrome.permissions.contains({\npermissions: ['tabs'],\norigins: ['https://www.google.com/']\n}, (result) => {\nif (result) {\n// The extension has the permissions.\n} else {\n// The extension doesn't have the permissions.\n}\n});\nStep 5: Remove the permissions\nYou should remove permissions when you no longer need them. After a permission has been removed,\ncalling permissions.request()\nusually adds the permission back without prompting the user.\nchrome.permissions.remove({\npermissions: ['tabs'],\norigins: ['https://www.google.com/']\n}, (removed) => {\nif (removed) {\n// The permissions have been removed.\n} else {\n// The permissions have not been removed (e.g., you tried to remove\n// required permissions).\n}\n});\nTypes\nPermissions\nProperties\n-\norigins\nstring[] optional\nThe list of host permissions, including those specified in the\noptional_permissions\norpermissions\nkeys in the manifest, and those associated with Content Scripts. -\npermissions\nstring[] optional\nList of named permissions (does not include hosts or origins).\nMethods\naddHostAccessRequest()\nchrome.permissions.addHostAccessRequest(\nrequest: object,\ncallback?: function,\n)\nAdds a host access request. Request will only be signaled to the user if extension can be granted access to the host in the request. Request will be reset on cross-origin navigation. When accepted, grants persistent access to the site\u2019s top origin\nParameters\n-\nrequest\nobject\n-\ndocumentId\nstring optional\nThe id of a document where host access requests can be shown. Must be the top-level document within a tab. If provided, the request is shown on the tab of the specified document and is removed when the document navigates to a new origin. Adding a new request will override any existent request for\ntabId\n. This ortabId\nmust be specified. -\npattern\nstring optional\nThe URL pattern where host access requests can be shown. If provided, host access requests will only be shown on URLs that match this pattern.\n-\ntabId\nnumber optional\nThe id of the tab where host access requests can be shown. If provided, the request is shown on the specified tab and is removed when the tab navigates to a new origin. Adding a new request will override an existent request for\ndocumentId\n. This ordocumentId\nmust be specified.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ncontains()\nchrome.permissions.contains(\npermissions: Permissions,\ncallback?: function,\n)\nChecks if the extension has the specified permissions.\nParameters\n-\npermissions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: boolean) => void\n-\nresult\nboolean\nTrue if the extension has the specified permissions. If an origin is specified as both an optional permission and a content script match pattern, this will return\nfalse\nunless both permissions are granted.\n-\nReturns\n-\nPromise<boolean>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetAll()\nchrome.permissions.getAll(\ncallback?: function,\n)\nGets the extension's current set of permissions.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(permissions: Permissions) => void\n-\npermissions\nThe extension's active permissions. Note that the\norigins\nproperty will contain granted origins from those specified in thepermissions\nandoptional_permissions\nkeys in the manifest and those associated with Content Scripts.\n-\nReturns\n-\nPromise<Permissions>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremove()\nchrome.permissions.remove(\npermissions: Permissions,\ncallback?: function,\n)\nRemoves access to the specified permissions. If there are any problems removing the permissions, runtime.lastError\nwill be set.\nParameters\n-\npermissions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(removed: boolean) => void\n-\nremoved\nboolean\nTrue if the permissions were removed.\n-\nReturns\n-\nPromise<boolean>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveHostAccessRequest()\nchrome.permissions.removeHostAccessRequest(\nrequest: object,\ncallback?: function,\n)\nRemoves a host access request, if existent.\nParameters\n-\nrequest\nobject\n-\ndocumentId\nstring optional\nThe id of a document where host access request will be removed. Must be the top-level document within a tab. This or\ntabId\nmust be specified. -\npattern\nstring optional\nThe URL pattern where host access request will be removed. If provided, this must exactly match the pattern of an existing host access request.\n-\ntabId\nnumber optional\nThe id of the tab where host access request will be removed. This or\ndocumentId\nmust be specified.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nrequest()\nchrome.permissions.request(\npermissions: Permissions,\ncallback?: function,\n)\nRequests access to the specified permissions, displaying a prompt to the user if necessary. These permissions must either be defined in the optional_permissions\nfield of the manifest or be required permissions that were withheld by the user. Paths on origin patterns will be ignored. You can request subsets of optional origin permissions; for example, if you specify *://*\\/*\nin the optional_permissions\nsection of the manifest, you can request http://example.com/\n. If there are any problems requesting the permissions, runtime.lastError\nwill be set.\nParameters\n-\npermissions\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(granted: boolean) => void\n-\ngranted\nboolean\nTrue if the user granted the specified permissions.\n-\nReturns\n-\nPromise<boolean>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonAdded\nchrome.permissions.onAdded.addListener(\ncallback: function,\n)\nFired when the extension acquires new permissions.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(permissions: Permissions) => void\n-\npermissions\n-\nonRemoved\nchrome.permissions.onRemoved.addListener(\ncallback: function,\n)\nFired when access to permissions has been removed from the extension.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(permissions: Permissions) => void\n-\npermissions\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/permissions-list", "title": "Permissions | Chrome for Developers", "text": "To access most extension APIs and features, you must declare permissions in your extension's manifest. Some permissions trigger warnings that users must allow to continue using the extension.\nFor more information on how permissions work, see Declare permissions. For best practices for using permissions with warnings, see Permission warning guidelines.\nThe following is a list of all available permissions and any warnings triggered by specific permissions.\n\"accessibilityFeatures.modify\"\n- Lets extensions modify accessibility feature states when using the\nchrome.accessibilityFeatures\nAPI.\nWarning displayed: Change your accessibility settings. \"accessibilityFeatures.read\"\n- Lets extensions read accessibility states when using the\nchrome.accessibilityFeatures\nAPI.\nWarning displayed: Read your accessibility settings. \"activeTab\"\n- Gives temporary access to the active tab through a user gesture. For details,\nsee\nactiveTab\n. \"alarms\"\n- Gives access to the\nchrome.alarms\nAPI. \"audio\"\n- Gives access to the\nchrome.audio\nAPI. \"background\"\n- Makes Chrome start up early (as soon as the user logs into their computer, before they launch Chrome), and shut down late (even after its last window is closed, until the user explicitly quits Chrome).\n\"bookmarks\"\n- Gives access to the\nchrome.bookmarks\nAPI.\nWarning displayed: Read and change your bookmarks. \"browsingData\"\n- Gives access to the\nchrome.browsingData\nAPI. \"certificateProvider\"\n- Gives access to the\nchrome.certificateProvider\nAPI. \"clipboardRead\"\n- Lets the extension paste items from the clipboard using the web platform Clipboard API.\nWarning displayed: Read data you copy and paste. \"clipboardWrite\"\n- Lets the extension cut and copy items to the clipboard using the web platform Clipboard API.\nWarning displayed: Modify data you copy and paste. \"contentSettings\"\n- Gives access to the\nchrome.contentSettings\nAPI.\nWarning displayed: Change your settings that control websites' access to features such as cookies, JavaScript, plugins, geolocation, microphone, camera etc. \"contextMenus\"\n- Gives access to the\nchrome.contextMenus\nAPI. \"cookies\"\n- Gives access to the\nchrome.cookies\nAPI. \"debugger\"\n- Gives access to the\nchrome.debugger\nAPI.\nWarnings displayed:\n- Access the page debugger backend.\n- Read and change all your data on all websites.\n\"declarativeContent\"\n- Gives access to the\nchrome.declarativeContent\nAPI. \"declarativeNetRequest\"\n- Gives access to the\nchrome.declarativeNetRequest\nAPI.\nWarning displayed: Block content on any page. \"declarativeNetRequestWithHostAccess\"\n- Gives access to the\nchrome.declarativeNetRequest\nAPI but requires host permissions for all actions. \"declarativeNetRequestFeedback\"\n- Gives permission to write errors and warnings to the DevTools console when\nusing the\nchrome.declarativeNetRequest\nAPI. This permission is for use with unpacked extensions and is ignored for extensions installed from the Chrome Web Store.\nWarning displayed: Read your browsing history. \"dns\"\n- Gives access to the\nchrome.dns\nAPI. \"desktopCapture\"\n- Gives access to the\nchrome.desktopCapture\nAPI.\nWarning displayed: Capture content of your screen. \"documentScan\"\n- Gives access to the\nchrome.documentScan\nAPI. \"downloads\"\n- Gives access to the\nchrome.downloads\nAPI.\nWarning displayed: Manage your downloads. \"downloads.open\"\n- Allows the use of\nchrome.downloads.open()\n.\nWarning displayed: Manage your downloads. \"downloads.ui\"\n- Allows the use of\nchrome.downloads.setUiOptions()\n.\nWarning displayed: Manage your downloads. \"enterprise.deviceAttributes\"\n- Gives access to the\nchrome.enterprise.deviceAttributes\nAPI. \"enterprise.hardwarePlatform\"\n- Gives access to the\nchrome.enterprise.hardwarePlatform\nAPI. \"enterprise.networkingAttributes\"\n- Gives access to the\nchrome.enterprise.networkingAttributes\nAPI. \"enterprise.platformKeys\"\n- Gives access to the\nchrome.enterprise.platformKeys\nAPI. \"favicon\"\n- Grants access to the Favicon API.\nWarning displayed: Read the icons of the websites you visit. \"fileBrowserHandler\"\n- Gives access to the\nchrome.fileBrowserHandler\nAPI. \"fileSystemProvider\"\n- Gives access to the\nchrome.fileSystemProvider\nAPI. \"fontSettings\"\n- Gives access to the\nchrome.fontSettings\nAPI. \"gcm\"\n- Gives access to the\nchrome.gcm\nandchrome.instanceID\nAPIs. \"geolocation\"\n- Allows the extension to use the geolocation API without prompting the user for\npermission.\nWarning displayed: Detect your physical location. \"history\"\n- Gives access to the\nchrome.history\nAPI.\nWarning displayed: Read and change your browsing history on all signed-in devices. \"identity\"\n- Gives access to the\nchrome.identity\nAPI.\nWarning displayed: Know your email address. \"identity.email\"\n- Gives access to the user's email address through the\nchrome.identity\nAPI.\nWarning displayed: Know your email address. \"idle\"\n- Gives access to the\nchrome.idle\nAPI. \"loginState\"\n- Gives access to the\nchrome.loginState\nAPI. \"management\"\n- Gives access to the\nchrome.management\nAPI.\nWarning displayed: Manage your apps, extensions, and themes. \"nativeMessaging\"\n- Gives access to the native messaging API.\nWarning displayed: Communicate with cooperating native applications. \"notifications\"\n- Gives access to the\nchrome.notifications\nAPI.\nWarning displayed: Display notifications. \"offscreen\"\n- Gives access to the\nchrome.offscreen\nAPI. \"pageCapture\"\n- Gives access to the\nchrome.pageCapture\nAPI.\nWarning displayed: Read and change all your data on all websites. \"platformKeys\"\n- Gives access to the\nchrome.platformKeys\nAPI. \"power\"\n- Gives access to the\nchrome.power\nAPI. \"printerProvider\"\n- Gives access to the\nchrome.printerProvider\nAPI. \"printing\"\n- Gives access to the\nchrome.printing\nAPI. \"printingMetrics\"\n- Gives access to the\nchrome.printingMetrics\nAPI. \"privacy\"\n- Gives access to the\nchrome.privacy\nAPI.\nWarning displayed: Change your privacy-related settings. \"processes\"\n- Gives access to the\nchrome.processes\nAPI. \"proxy\"\n- Gives access to the\nchrome.proxy\nAPI.\nWarning displayed: Read and change all your data on all websites. \"readingList\"\n- Gives access to the\nchrome.readingList\nAPI.\nWarning displayed: Read and change entries in the reading list. \"runtime\"\n- Gives access to\nruntime.connectNative()\nandruntime.sendNativeMessage()\n. For all other features of theruntime\nnamespace, no permission is required. \"scripting\"\n- Gives access to the\nchrome.scripting\nAPI. \"search\"\n- Gives access to the\nchrome.search\nAPI. \"sessions\"\n- Gives access to the\nchrome.sessions\nAPI.\nWarnings displayed:\n- When used with the\n\"history\"\npermission: Read and change your browsing history on all your signed-in devices. - When used with the\n\"tabs\"\npermission: Read your browsing history on all your signed-in devices.\n- When used with the\n\"sidePanel\"\n- Gives access to the\nchrome.sidePanel\nAPI. \"storage\"\n- Gives access to the\nchrome.storage\nAPI. \"system.cpu\"\n- Gives access to the\nchrome.system.cpu\nAPI. \"system.display\"\n- Gives access to the\nchrome.system.display\nAPI. \"system.memory\"\n- Gives access to the\nchrome.system.memory\nAPI. \"system.storage\"\n- Gives access to the\nchrome.system.storage\nAPI.\nWarning displayed: Identify and eject storage devices. \"tabCapture\"\n- Gives access to the\nchrome.tabCapture\nAPI.\nWarning displayed: Read and change all your data on all websites. \"tabGroups\"\n- Gives access to the\nchrome.tabGroups\nAPI.\nWarning displayed: View and manage your tab groups. \"tabs\"\n- Gives access to privileged fields of the Tab objects used by several APIs,\nincluding\nchrome.tabs\nandchrome.windows\n. You usually don't need to declare this permission to use those APIs.\nWarning displayed: Read your browsing history. \"topSites\"\n- Gives access to the\nchrome.topSites\nAPI.\nWarning displayed: Read a list of your most frequently visited websites. \"tts\"\n- Gives access to the\nchrome.tts\nAPI. \"ttsEngine\"\n- Gives access to the\nchrome.ttsEngine\nAPI.\nWarning displayed: Read all text spoken using synthesized speech. \"unlimitedStorage\"\n- Provides an unlimited quota for\nchrome.storage.local\n,IndexedDB\n,Cache Storage\n, andOrigin Private File System\n. For more information, see Storage and cookies. \"vpnProvider\"\n- Gives access to the\nchrome.vpnProvider\nAPI. \"wallpaper\"\n- Gives access to the\nchrome.wallpaper\nAPI. \"webAuthenticationProxy\"\n- Gives access to the\nchrome.webAuthenticationProxy\nAPI.\nWarning displayed: Read and change all your data on all websites. \"webNavigation\"\n- Gives access to the\nchrome.webNavigation\nAPI.\nWarning displayed: Read your browsing history. \"webRequest\"\n- Gives access to the\nchrome.webRequest\nAPI. \"webRequestBlocking\"\n- Allows the use of the\nchrome.webRequest\nAPI for blocking."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/printerProvider", "title": "chrome.printerProvider | API | Chrome for Developers", "text": "Description\nThe chrome.printerProvider\nAPI exposes events used by print manager to query printers controlled by extensions, to query their capabilities and to submit print jobs to these printers.\nPermissions\nprinterProvider\nAvailability\nTypes\nPrinterInfo\nProperties\n-\ndescription\nstring optional\nPrinter's human readable description.\n-\nid\nstring\nUnique printer ID.\n-\nname\nstring\nPrinter's human readable name.\nPrintError\nError codes returned in response to onPrintRequested\nevent.\nEnum\n\"OK\" \"FAILED\" \"INVALID_TICKET\" \"INVALID_DATA\"\nSpecifies that the operation was completed successfully.\nSpecifies that a general failure occured.\nSpecifies that the print ticket is invalid. For example, the ticket is inconsistent with some capabilities, or the extension is not able to handle all settings from the ticket.\nSpecifies that the document is invalid. For example, data may be corrupted or the format is incompatible with the extension.\nPrintJob\nProperties\n-\ncontentType\nstring\nThe document content type. Supported formats are\n\"application/pdf\"\nand\"image/pwg-raster\"\n. -\ndocument\nBlob\nBlob containing the document data to print. Format must match\ncontentType\n. -\nprinterId\nstring\nID of the printer which should handle the job.\n-\nticket\nobject\nPrint ticket in CJT format.\nThe CJT reference is marked as deprecated. It is deprecated for Google Cloud Print only. is not deprecated for ChromeOS printing.\n-\ntitle\nstring\nThe print job title.\nEvents\nonGetCapabilityRequested\nchrome.printerProvider.onGetCapabilityRequested.addListener(\ncallback: function,\n)\nEvent fired when print manager requests printer capabilities.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(printerId: string, resultCallback: function) => void\n-\nprinterId\nstring\n-\nresultCallback\nfunction\nThe\nresultCallback\nparameter looks like:(capabilities: object) => void\n-\ncapabilities\nobject\nDevice capabilities in CDD format.\n-\n-\nonGetPrintersRequested\nchrome.printerProvider.onGetPrintersRequested.addListener(\ncallback: function,\n)\nEvent fired when print manager requests printers provided by extensions.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(resultCallback: function) => void\n-\nresultCallback\nfunction\nThe\nresultCallback\nparameter looks like:(printerInfo: PrinterInfo[]) => void\n-\nprinterInfo\n-\n-\nonGetUsbPrinterInfoRequested\nchrome.printerProvider.onGetUsbPrinterInfoRequested.addListener(\ncallback: function,\n)\nEvent fired when print manager requests information about a USB device that may be a printer.\nNote: An application should not rely on this event being fired more than once per device. If a connected device is supported it should be returned in the onGetPrintersRequested\nevent.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(device: usb.Device, resultCallback: function) => void\n-\ndevice\n-\nresultCallback\nfunction\nThe\nresultCallback\nparameter looks like:(printerInfo?: PrinterInfo) => void\n-\nprinterInfo\nPrinterInfo optional\n-\n-\nonPrintRequested\nchrome.printerProvider.onPrintRequested.addListener(\ncallback: function,\n)\nEvent fired when print manager requests printing.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(printJob: PrintJob, resultCallback: function) => void\n-\nprintJob\n-\nresultCallback\nfunction\nThe\nresultCallback\nparameter looks like:(result: PrintError) => void\n-\nresult\n-\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/printing", "title": "chrome.printing | API | Chrome for Developers", "text": "Description\nUse the chrome.printing\nAPI to send print jobs to printers installed on Chromebook.\nPermissions\nprinting\nAvailability\nAll chrome.printing\nmethods and events require you to declare the \"printing\"\npermission in the extension manifest. For example:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"printing\"\n],\n...\n}\nExamples\nThe examples below demonstrate using each of the methods in the printing namespace. This code is copied from or based on the api-samples/printing in the extensions-samples Github repo.\ncancelJob()\nThis example uses the onJobStatusChanged\nhandler to hide a 'cancel' button when the jobStatus\nis neither PENDING\nor IN_PROGRESS\n. Note that on some networks or when a Chromebook is connected directly to the printer, these states may pass too quickly for the cancel button to be visible long enough to be called. This is greatly simplified printing example.\nchrome.printing.onJobStatusChanged.addListener((jobId, status) => {\nconst cancelButton = document.getElementById(\"cancelButton\");\ncancelButton.addEventListener('click', () => {\nchrome.printing.cancelJob(jobId).then((response) => {\nif (response !== undefined) {\nconsole.log(response.status);\n}\nif (chrome.runtime.lastError !== undefined) {\nconsole.log(chrome.runtime.lastError.message);\n}\n});\n});\nif (status !== \"PENDING\" && status !== \"IN_PROGRESS\") {\ncancelButton.style.visibility = 'hidden';\n} else {\ncancelButton.style.visibility = 'visible';\n}\n}\ngetPrinters() and getPrinterInfo()\nA single example is used for these functions because getting printer information requires a printer ID, which is retrieved by calling getPrinters()\n. This example logs the name and description of the default printer to the console. This is a simplified version of the printing example.\nconst printers = await chrome.printing.getPrinters();\nconst defaultPrinter = printers.find((printer) => {\nconst printerInfo = await chrome.printing.getPrinterInfo(printer.id);\nreturn printerInfo.isDefault;\n}\nconsole.log(`Default printer: ${defaultPrinter.name}.\\n\\t${defaultPrinter.description}`);\nsubmitJob()\nThe submitJob()\nmethod requires three things.\n- A\nticket\nstructure specifying which capabilities of the printer are to be used. If the user needs to select from available capabilities, you can retrieve them for a specific printer usinggetPrinterInfo()\n. - A\nSubmitJobRequest\nstructure, which specifies the printer to use, and the file or date to print. This structure contains a reference to theticket\nstructure. - A blob of the file or data to print.\nCalling submitJob()\ntriggers a dialog box asking the user to confirm printing. Use the PrintingAPIExtensionsAllowlist\nto bypass confirmation.\nThis is a simplified version of the printing example. Notice that the ticket\nis attached to the SubmitJobRequest\nstructure (line 8) and that the data to print is converted to a blob (line 10). Getting the ID of the printer (line 1) is more complicated in the sample than is shown here.\nconst defaultPrinter = getDefaultPrinter();\nconst ticket = getPrinterTicket(defaultPrinter);\nconst arrayBuffer = getPrintData();\nconst submitJobRequest = {\njob: {\nprinterId: defaultPrinter,\ntitle: 'test job',\nticket: ticket,\ncontentType: 'application/pdf',\ndocument: new Blob([new Uint8Array(arrayBuffer)], {\ntype: 'application/pdf'\n});\n}\n};\nchrome.printing.submitJob(submitJobRequest, (response) => {\nif (response !== undefined) {\nconsole.log(response.status);\n}\nif (chrome.runtime.lastError !== undefined) {\nconsole.log(chrome.runtime.lastError.message);\n}\n});\nRoll printing\nThis example shows how to build a printer ticket for continuous (or roll) printing, which is often used with receipt printing. The submitJobRequest\nobject for roll printing is the same as that shown for the submitJob()\nexample.\nIf you need to change the default value for paper cutting, use the vendor_ticket_item\nkey. (The default varies from printer to printer.) To change the value, provide an array with one member: an object whose id\nis 'finishings'\n. The value can either be 'trim'\nfor printers that cut the roll at the end of printing or 'none'\nfor printers that require the print job to be torn off.\nconst ticket = {\nversion: '1.0',\nprint: {\nvendor_ticket_item: [{id: 'finishings', value: 'trim'}],\ncolor: {type: 'STANDARD_MONOCHROME'},\nduplex: {type: 'NO_DUPLEX'},\npage_orientation: {type: 'PORTRAIT'},\ncopies: {copies: 1},\ndpi: {horizontal_dpi: 300, vertical_dpi: 300},\nmedia_size: {\nwidth_microns: 72320,\nheight_microns: 100000\n},\ncollate: {collate: false}\n}\n};\nSome printers do not support the \"finishings\"\noption. To determine if your printer does, call getPrinterInfo()\nand look for a \"display_name\"\nof \"finishings/11\"\n.\n\"vendor_capability\": [\n{\n\"display_name\": \"finishings/11\",\n\"id\": \"finishings/11\",\n\"type\": \"TYPED_VALUE\",\n\"typed_value_cap\": {\n\"value_type\": \"BOOLEAN\"\n}\n},\n...\n]\nThe values in a ticket's media_size\nkey are specific to each printer. To select an appropriate size call getPrinterInfo()\n. The returned GetPrinterResponse\ncontains an array of supported media sizes at \"media_size\".\"option\"\n. Choose an option whose \"is_continuous_feed\"\nvalue is true. Use its height and width values for the ticket.\n\"media_size\": {\n\"option\": [\n{\n\"custom_display_name\": \"\",\n\"is_continuous_feed\": true,\n\"max_height_microns\": 2000000,\n\"min_height_microns\": 25400,\n\"width_microns\": 50800\n},\n...\n]\n}\nTypes\nGetPrinterInfoResponse\nProperties\n-\ncapabilities\nobject optional\nPrinter capabilities in CDD format. The property may be missing.\n-\nstatus\nThe status of the printer.\nJobStatus\nStatus of the print job.\nEnum\n\"PENDING\" \"IN_PROGRESS\" \"FAILED\" \"CANCELED\" \"PRINTED\"\nPrint job is received on Chrome side but was not processed yet.\nPrint job is sent for printing.\nPrint job was interrupted due to some error.\nPrint job was canceled by the user or via API.\nPrint job was printed without any errors.\nPrinter\nProperties\n-\ndescription\nstring\nThe human-readable description of the printer.\n-\nid\nstring\nThe printer's identifier; guaranteed to be unique among printers on the device.\n-\nisDefault\nboolean\nThe flag which shows whether the printer fits DefaultPrinterSelection rules. Note that several printers could be flagged.\n-\nname\nstring\nThe name of the printer.\n-\nrecentlyUsedRank\nnumber optional\nThe value showing how recent the printer was used for printing from Chrome. The lower the value is the more recent the printer was used. The minimum value is 0. Missing value indicates that the printer wasn't used recently. This value is guaranteed to be unique amongst printers.\n-\nsource\nThe source of the printer (user or policy configured).\n-\nuri\nstring\nThe printer URI. This can be used by extensions to choose the printer for the user.\nPrinterSource\nThe source of the printer.\nEnum\n\"USER\" \"POLICY\"\nPrinter was added by user.\nPrinter was added via policy.\nPrinterStatus\nThe status of the printer.\nEnum\n\"DOOR_OPEN\" \"TRAY_MISSING\" \"OUT_OF_INK\" \"OUT_OF_PAPER\" \"OUTPUT_FULL\" \"PAPER_JAM\" \"GENERIC_ISSUE\" \"STOPPED\" \"UNREACHABLE\" \"EXPIRED_CERTIFICATE\" \"AVAILABLE\"\nThe door of the printer is open. Printer still accepts print jobs.\nThe tray of the printer is missing. Printer still accepts print jobs.\nThe printer is out of ink. Printer still accepts print jobs.\nThe printer is out of paper. Printer still accepts print jobs.\nThe output area of the printer (e.g. tray) is full. Printer still accepts print jobs.\nThe printer has a paper jam. Printer still accepts print jobs.\nSome generic issue. Printer still accepts print jobs.\nThe printer is stopped and doesn't print but still accepts print jobs.\nThe printer is unreachable and doesn't accept print jobs.\nThe SSL certificate is expired. Printer accepts jobs but they fail.\nThe printer is available.\nSubmitJobRequest\nProperties\n-\njob\nThe print job to be submitted. The only supported content type is \"application/pdf\", and the Cloud Job Ticket shouldn't include\nFitToPageTicketItem\n,PageRangeTicketItem\n,ReverseOrderTicketItem\nandVendorTicketItem\nfields since they are irrelevant for native printing. All other fields must be present.\nSubmitJobResponse\nProperties\n-\njobId\nstring optional\nThe id of created print job. This is a unique identifier among all print jobs on the device. If status is not OK, jobId will be null.\n-\nstatus\nThe status of the request.\nSubmitJobStatus\nThe status of submitJob\nrequest.\nEnum\n\"OK\" \"USER_REJECTED\"\nSent print job request is accepted.\nSent print job request is rejected by the user.\nProperties\nMAX_GET_PRINTER_INFO_CALLS_PER_MINUTE\nThe maximum number of times that getPrinterInfo\ncan be called per minute.\nValue\n20\nMAX_SUBMIT_JOB_CALLS_PER_MINUTE\nThe maximum number of times that submitJob\ncan be called per minute.\nValue\n40\nMethods\ncancelJob()\nchrome.printing.cancelJob(\njobId: string,\ncallback?: function,\n)\nCancels previously submitted job.\nParameters\n-\njobId\nstring\nThe id of the print job to cancel. This should be the same id received in a\nSubmitJobResponse\n. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 100+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetPrinterInfo()\nchrome.printing.getPrinterInfo(\nprinterId: string,\ncallback?: function,\n)\nReturns the status and capabilities of the printer in CDD format. This call will fail with a runtime error if no printers with given id are installed.\nParameters\n-\nprinterId\nstring\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(response: GetPrinterInfoResponse) => void\n-\nresponse\n-\nReturns\n-\nPromise<GetPrinterInfoResponse>\nChrome 100+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetPrinters()\nchrome.printing.getPrinters(\ncallback?: function,\n)\nReturns the list of available printers on the device. This includes manually added, enterprise and discovered printers.\nParameters\nReturns\n-\nPromise<Printer[]>\nChrome 100+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsubmitJob()\nchrome.printing.submitJob(\nrequest: SubmitJobRequest,\ncallback?: function,\n)\nSubmits the job for printing. If the extension is not listed in the PrintingAPIExtensionsAllowlist\npolicy, the user is prompted to accept the print job.\nBefore Chrome 120, this function did not return a promise.\nParameters\n-\nrequest\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(response: SubmitJobResponse) => void\n-\nresponse\n-\nReturns\n-\nPromise<SubmitJobResponse>\nChrome 100+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonJobStatusChanged\nchrome.printing.onJobStatusChanged.addListener(\ncallback: function,\n)\nEvent fired when the status of the job is changed. This is only fired for the jobs created by this extension."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/runtime", "title": "chrome.runtime | API | Chrome for Developers", "text": "Description\nUse the chrome.runtime\nAPI to retrieve the service worker, return details about the manifest, and listen for and respond to events in the extension lifecycle. You can also use this API to convert the relative path of URLs to fully-qualified URLs.\nMost members of this API do not require any permissions. This permission is needed for connectNative()\n, sendNativeMessage()\nand onNativeConnect\n.\nThe following example shows how to declare the \"nativeMessaging\"\npermission in the manifest:\nmanifest.json:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"nativeMessaging\"\n],\n...\n}\nConcepts and usage\nThe Runtime API provides methods to support a number of areas that your extensions can use:\n- Message passing\n- Your extension can communicate with different contexts within your extension and also with other extensions using these methods and events:\nconnect()\n,onConnect\n,onConnectExternal\n,sendMessage()\n,onMessage\nandonMessageExternal\n. In addition, your extension can pass messages to native applications on the user's device usingconnectNative()\nandsendNativeMessage()\n.\n- Accessing extension and platform metadata\n- These methods let you retrieve several specific pieces of metadata about the extension and the\nplatform. Methods in this category include\ngetManifest()\n, andgetPlatformInfo()\n. - Managing extension lifecycle and options\n- These properties let you perform some meta-operations on the extension, and display the options page.\nMethods and events in this category include\nonInstalled\n,onStartup\n,openOptionsPage()\n,reload()\n,requestUpdateCheck()\n, andsetUninstallURL()\n. - Helper utilities\n- These methods provide utility such as the conversion of internal resource representations to\nexternal formats. Methods in this category include\ngetURL()\n. - Kiosk mode utilities\n- These methods are available only on ChromeOS, and exist mainly to support kiosk implementations.\nMethods in this category include\nrestart()\nandrestartAfterDelay()\n`.\nUnpacked extension behavior\nWhen an unpacked extension is reloaded, this is treated as an update. This means that the\nchrome.runtime.onInstalled\nevent will fire with the \"update\"\nreason. This\nincludes when the extension is reloaded with chrome.runtime.reload()\n.\nUse cases\nAdd an image to a web page\nFor a web page to access an asset hosted on another domain, it must specify the resource's full URL\n(e.g. <img src=\"https://example.com/logo.png\">\n). The same is true to include an extension asset on\na web page. The two differences are that the extension's assets must be exposed as web\naccessible resources and that typically content scripts are responsible for injecting\nextension assets.\nIn this example, the extension will add logo.png\nto the page that the content\nscript is being injected into by using runtime.getURL()\nto create a\nfully-qualified URL. But first, the asset must be declared as a web accessible resource in the manifest.\nmanifest.json:\n{\n...\n\"web_accessible_resources\": [\n{\n\"resources\": [ \"logo.png\" ],\n\"matches\": [ \"https://*/*\" ]\n}\n],\n...\n}\ncontent.js:\n{ // Block used to avoid setting global variables\nconst img = document.createElement('img');\nimg.src = chrome.runtime.getURL('logo.png');\ndocument.body.append(img);\n}\nSend data from a content script to the service worker\nIts common for an extension's content scripts to need data managed by another part of the extension, like the service worker. Much like two browser windows opened to the same web page, these two contexts cannot directly access each other's values. Instead, the extension can use message passing to coordinate across these different contexts.\nIn this example, the content script needs some data from the extension's service worker to\ninitialize its UI. To get this data, it passes the developer-defined get-user-data\nmessage\nto the service worker, and it responds with a copy of the user's information.\ncontent.js:\n// 1. Send a message to the service worker requesting the user's data\nchrome.runtime.sendMessage('get-user-data', (response) => {\n// 3. Got an asynchronous response with the data from the service worker\nconsole.log('received user data', response);\ninitializeUI(response);\n});\nservice-worker.js:\n// Example of a simple user data object\nconst user = {\nusername: 'demo-user'\n};\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n// 2. A page requested user data, respond with a copy of `user`\nif (message === 'get-user-data') {\nsendResponse(user);\n}\n});\nGather feedback on uninstall\nMany extensions use post-uninstall surveys to understand how the extension could better serve its users and improve retention. The following example shows how to add this functionality.\nbackground.js:\nchrome.runtime.onInstalled.addListener(details => {\nif (details.reason === chrome.runtime.OnInstalledReason.INSTALL) {\nchrome.runtime.setUninstallURL('https://example.com/extension-survey');\n}\n});\nExamples\nSee the Manifest V3 - Web Accessible Resources demo for more Runtime API examples.\nTypes\nContextFilter\nA filter to match against certain extension contexts. Matching contexts must match all specified filters; any filter that is not specified matches all available contexts. Thus, a filter of `{}` will match all available contexts.\nProperties\n-\ncontextIds\nstring[] optional\n-\ncontextTypes\nContextType[] optional\n-\ndocumentIds\nstring[] optional\n-\ndocumentOrigins\nstring[] optional\n-\ndocumentUrls\nstring[] optional\n-\nframeIds\nnumber[] optional\n-\nincognito\nboolean optional\n-\ntabIds\nnumber[] optional\n-\nwindowIds\nnumber[] optional\nContextType\nEnum\n\"TAB\" \"POPUP\" \"BACKGROUND\" \"OFFSCREEN_DOCUMENT\" \"SIDE_PANEL\" \"DEVELOPER_TOOLS\"\nSpecifies the context type as a tab\nSpecifies the context type as an extension popup window\nSpecifies the context type as a service worker.\nSpecifies the context type as an offscreen document.\nSpecifies the context type as a side panel.\nSpecifies the context type as developer tools.\nExtensionContext\nA context hosting extension content.\nProperties\n-\ncontextId\nstring\nA unique identifier for this context\n-\ncontextType\nThe type of context this corresponds to.\n-\ndocumentId\nstring optional\nA UUID for the document associated with this context, or undefined if this context is hosted not in a document.\n-\ndocumentOrigin\nstring optional\nThe origin of the document associated with this context, or undefined if the context is not hosted in a document.\n-\ndocumentUrl\nstring optional\nThe URL of the document associated with this context, or undefined if the context is not hosted in a document.\n-\nframeId\nnumber\nThe ID of the frame for this context, or -1 if this context is not hosted in a frame.\n-\nincognito\nboolean\nWhether the context is associated with an incognito profile.\n-\ntabId\nnumber\nThe ID of the tab for this context, or -1 if this context is not hosted in a tab.\n-\nwindowId\nnumber\nThe ID of the window for this context, or -1 if this context is not hosted in a window.\nMessageSender\nAn object containing information about the script context that sent a message or request.\nProperties\n-\ndocumentId\nstring optional\nChrome 106+A UUID of the document that opened the connection.\n-\ndocumentLifecycle\nstring optional\nChrome 106+The lifecycle the document that opened the connection is in at the time the port was created. Note that the lifecycle state of the document may have changed since port creation.\n-\nframeId\nnumber optional\nThe frame that opened the connection. 0 for top-level frames, positive for child frames. This will only be set when\ntab\nis set. -\nid\nstring optional\nThe ID of the extension that opened the connection, if any.\n-\nnativeApplication\nstring optional\nChrome 74+The name of the native application that opened the connection, if any.\n-\norigin\nstring optional\nChrome 80+The origin of the page or frame that opened the connection. It can vary from the url property (e.g., about:blank) or can be opaque (e.g., sandboxed iframes). This is useful for identifying if the origin can be trusted if we can't immediately tell from the URL.\n-\ntab\nTab optional\nThe\ntabs.Tab\nwhich opened the connection, if any. This property will only be present when the connection was opened from a tab (including content scripts), and only if the receiver is an extension, not an app. -\ntlsChannelId\nstring optional\nThe TLS channel ID of the page or frame that opened the connection, if requested by the extension, and if available.\n-\nurl\nstring optional\nThe URL of the page or frame that opened the connection. If the sender is in an iframe, it will be iframe's URL not the URL of the page which hosts it.\nOnInstalledReason\nThe reason that this event is being dispatched.\nEnum\n\"install\" \"update\" \"chrome_update\" \"shared_module_update\"\nSpecifies the event reason as an installation.\nSpecifies the event reason as an extension update.\nSpecifies the event reason as a Chrome update.\nSpecifies the event reason as an update to a shared module.\nOnRestartRequiredReason\nThe reason that the event is being dispatched. 'app_update' is used when the restart is needed because the application is updated to a newer version. 'os_update' is used when the restart is needed because the browser/OS is updated to a newer version. 'periodic' is used when the system runs for more than the permitted uptime set in the enterprise policy.\nEnum\n\"app_update\" \"os_update\" \"periodic\"\nSpecifies the event reason as an update to the app.\nSpecifies the event reason as an update to the operating system.\nSpecifies the event reason as a periodic restart of the app.\nPlatformArch\nThe machine's processor architecture.\nEnum\n\"arm\" \"arm64\" \"x86-32\" \"x86-64\" \"mips\" \"mips64\"\nSpecifies the processer architecture as arm.\nSpecifies the processer architecture as arm64.\nSpecifies the processer architecture as x86-32.\nSpecifies the processer architecture as x86-64.\nSpecifies the processer architecture as mips.\nSpecifies the processer architecture as mips64.\nPlatformInfo\nAn object containing information about the current platform.\nProperties\n-\narch\nThe machine's processor architecture.\n-\nnacl_arch\nThe native client architecture. This may be different from arch on some platforms.\n-\nos\nThe operating system Chrome is running on.\nPlatformNaclArch\nThe native client architecture. This may be different from arch on some platforms.\nEnum\n\"arm\" \"x86-32\" \"x86-64\" \"mips\" \"mips64\"\nSpecifies the native client architecture as arm.\nSpecifies the native client architecture as x86-32.\nSpecifies the native client architecture as x86-64.\nSpecifies the native client architecture as mips.\nSpecifies the native client architecture as mips64.\nPlatformOs\nThe operating system Chrome is running on.\nEnum\n\"mac\" \"win\" \"android\" \"cros\" \"linux\" \"openbsd\" \"fuchsia\"\nSpecifies the MacOS operating system.\nSpecifies the Windows operating system.\nSpecifies the Android operating system.\nSpecifies the Chrome operating system.\nSpecifies the Linux operating system.\nSpecifies the OpenBSD operating system.\nSpecifies the Fuchsia operating system.\nPort\nAn object which allows two way communication with other pages. See Long-lived connections for more information.\nProperties\n-\nname\nstring\nThe name of the port, as specified in the call to\nruntime.connect\n. -\nonDisconnect\nEvent<functionvoidvoid>\nFired when the port is disconnected from the other end(s).\nruntime.lastError\nmay be set if the port was disconnected by an error. If the port is closed via disconnect, then this event is only fired on the other end. This event is fired at most once (see also Port lifetime).The\nonDisconnect.addListener\nfunction looks like:(callback: function) => {...}\n-\nonMessage\nEvent<functionvoidvoid>\nThis event is fired when postMessage is called by the other end of the port.\nThe\nonMessage.addListener\nfunction looks like:(callback: function) => {...}\n-\nsender\nMessageSender optional\nThis property will only be present on ports passed to onConnect / onConnectExternal / onConnectNative listeners.\n-\ndisconnect\nvoid\nImmediately disconnect the port. Calling\ndisconnect()\non an already-disconnected port has no effect. When a port is disconnected, no new events will be dispatched to this port.The\ndisconnect\nfunction looks like:() => {...}\n-\npostMessage\nvoid\nSend a message to the other end of the port. If the port is disconnected, an error is thrown.\nThe\npostMessage\nfunction looks like:(message: any) => {...}\n-\nmessage\nany\nChrome 52+The message to send. This object should be JSON-ifiable.\n-\nRequestUpdateCheckStatus\nResult of the update check.\nEnum\n\"throttled\" \"no_update\" \"update_available\"\nSpecifies that the status check has been throttled. This can occur after repeated checks within a short amount of time.\nSpecifies that there are no available updates to install.\nSpecifies that there is an available update to install.\nProperties\nid\nThe ID of the extension/app.\nType\nstring\nlastError\nPopulated with an error message if calling an API function fails; otherwise undefined. This is only defined within the scope of that function's callback. If an error is produced, but runtime.lastError\nis not accessed within the callback, a message is logged to the console listing the API function that produced the error. API functions that return promises do not set this property.\nType\nobject\nProperties\n-\nmessage\nstring optional\nDetails about the error which occurred.\nMethods\nconnect()\nchrome.runtime.connect(\nextensionId?: string,\nconnectInfo?: object,\n)\nAttempts to connect listeners within an extension (such as the background page), or other extensions/apps. This is useful for content scripts connecting to their extension processes, inter-app/extension communication, and web messaging. Note that this does not connect to any listeners in a content script. Extensions may connect to content scripts embedded in tabs via tabs.connect\n.\nParameters\n-\nextensionId\nstring optional\nThe ID of the extension to connect to. If omitted, a connection will be attempted with your own extension. Required if sending messages from a web page for web messaging.\n-\nconnectInfo\nobject optional\n-\nincludeTlsChannelId\nboolean optional\nWhether the TLS channel ID will be passed into onConnectExternal for processes that are listening for the connection event.\n-\nname\nstring optional\nWill be passed into onConnect for processes that are listening for the connection event.\n-\nReturns\n-\nPort through which messages can be sent and received. The port's onDisconnect event is fired if the extension does not exist.\nconnectNative()\nchrome.runtime.connectNative(\napplication: string,\n)\nConnects to a native application in the host machine. This method requires the \"nativeMessaging\"\npermission. See Native Messaging for more information.\nParameters\n-\napplication\nstring\nThe name of the registered application to connect to.\nReturns\n-\nPort through which messages can be sent and received with the application\ngetBackgroundPage()\nchrome.runtime.getBackgroundPage(\ncallback?: function,\n)\nBackground pages do not exist in MV3 extensions.\nRetrieves the JavaScript 'window' object for the background page running inside the current extension/app. If the background page is an event page, the system will ensure it is loaded before calling the callback. If there is no background page, an error is set.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(backgroundPage?: Window) => void\n-\nbackgroundPage\nWindow optional\nThe JavaScript 'window' object for the background page.\n-\nReturns\n-\nPromise<Window | undefined>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetContexts()\nchrome.runtime.getContexts(\nfilter: ContextFilter,\ncallback?: function,\n)\nFetches information about active contexts associated with this extension\nParameters\n-\nfilter\nA filter to find matching contexts. A context matches if it matches all specified fields in the filter. Any unspecified field in the filter matches all contexts.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(contexts: ExtensionContext[]) => void\n-\ncontexts\nThe matching contexts, if any.\n-\nReturns\n-\nPromise<ExtensionContext[]>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetManifest()\nchrome.runtime.getManifest()\nReturns details about the app or extension from the manifest. The object returned is a serialization of the full manifest file.\nReturns\n-\nobject\nThe manifest details.\ngetPackageDirectoryEntry()\nchrome.runtime.getPackageDirectoryEntry(\ncallback?: function,\n)\nReturns a DirectoryEntry for the package directory.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(directoryEntry: DirectoryEntry) => void\n-\ndirectoryEntry\nDirectoryEntry\n-\nReturns\n-\nPromise<DirectoryEntry>\nChrome 122+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetPlatformInfo()\nchrome.runtime.getPlatformInfo(\ncallback?: function,\n)\nReturns information about the current platform.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(platformInfo: PlatformInfo) => void\n-\nplatformInfo\n-\nReturns\n-\nPromise<PlatformInfo>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetURL()\nchrome.runtime.getURL(\npath: string,\n)\nConverts a relative path within an app/extension install directory to a fully-qualified URL.\nParameters\n-\npath\nstring\nA path to a resource within an app/extension expressed relative to its install directory.\nReturns\n-\nstring\nThe fully-qualified URL to the resource.\nopenOptionsPage()\nchrome.runtime.openOptionsPage(\ncallback?: function,\n)\nOpen your Extension's options page, if possible.\nThe precise behavior may depend on your manifest's options_ui\nor options_page\nkey, or what Chrome happens to support at the time. For example, the page may be opened in a new tab, within chrome://extensions, within an App, or it may just focus an open options page. It will never cause the caller page to reload.\nIf your Extension does not declare an options page, or Chrome failed to create one for some other reason, the callback will set lastError\n.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nreload()\nchrome.runtime.reload()\nReloads the app or extension. This method is not supported in kiosk mode. For kiosk mode, use chrome.runtime.restart() method.\nrequestUpdateCheck()\nchrome.runtime.requestUpdateCheck(\ncallback?: function,\n)\nRequests an immediate update check be done for this app/extension.\nImportant: Most extensions/apps should not use this method, since Chrome already does automatic checks every few hours, and you can listen for the runtime.onUpdateAvailable\nevent without needing to call requestUpdateCheck.\nThis method is only appropriate to call in very limited circumstances, such as if your extension talks to a backend service, and the backend service has determined that the client extension version is very far out of date and you'd like to prompt a user to update. Most other uses of requestUpdateCheck, such as calling it unconditionally based on a repeating timer, probably only serve to waste client, network, and server resources.\nNote: When called with a callback, instead of returning an object this function will return the two properties as separate arguments passed to the callback.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: object) => void\n-\nresult\nobject\nChrome 109+RequestUpdateCheckResult object that holds the status of the update check and any details of the result if there is an update available\n-\nstatus\nResult of the update check.\n-\nversion\nstring optional\nIf an update is available, this contains the version of the available update.\n-\n-\nReturns\n-\nPromise<object>\nChrome 109+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nrestart()\nchrome.runtime.restart()\nRestart the ChromeOS device when the app runs in kiosk mode. Otherwise, it's no-op.\nrestartAfterDelay()\nchrome.runtime.restartAfterDelay(\nseconds: number,\ncallback?: function,\n)\nRestart the ChromeOS device when the app runs in kiosk mode after the given seconds. If called again before the time ends, the reboot will be delayed. If called with a value of -1, the reboot will be cancelled. It's a no-op in non-kiosk mode. It's only allowed to be called repeatedly by the first extension to invoke this API.\nParameters\n-\nseconds\nnumber\nTime to wait in seconds before rebooting the device, or -1 to cancel a scheduled reboot.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsendMessage()\nchrome.runtime.sendMessage(\nextensionId?: string,\nmessage: any,\noptions?: object,\ncallback?: function,\n)\nSends a single message to event listeners within your extension or a different extension/app. Similar to runtime.connect\nbut only sends a single message, with an optional response. If sending to your extension, the runtime.onMessage\nevent will be fired in every frame of your extension (except for the sender's frame), or runtime.onMessageExternal\n, if a different extension. Note that extensions cannot send messages to content scripts using this method. To send messages to content scripts, use tabs.sendMessage\n.\nParameters\n-\nextensionId\nstring optional\nThe ID of the extension to send the message to. If omitted, the message will be sent to your own extension/app. Required if sending messages from a web page for web messaging.\n-\nmessage\nany\nThe message to send. This message should be a JSON-ifiable object.\n-\noptions\nobject optional\n-\nincludeTlsChannelId\nboolean optional\nWhether the TLS channel ID will be passed into onMessageExternal for processes that are listening for the connection event.\n-\n-\ncallback\nfunction optional\nChrome 99+The\ncallback\nparameter looks like:(response: any) => void\n-\nresponse\nany\nThe JSON response object sent by the handler of the message. If an error occurs while connecting to the extension, the callback will be called with no arguments and\nruntime.lastError\nwill be set to the error message.\n-\nReturns\n-\nPromise<any>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsendNativeMessage()\nchrome.runtime.sendNativeMessage(\napplication: string,\nmessage: object,\ncallback?: function,\n)\nSend a single message to a native application. This method requires the \"nativeMessaging\"\npermission.\nParameters\n-\napplication\nstring\nThe name of the native messaging host.\n-\nmessage\nobject\nThe message that will be passed to the native messaging host.\n-\ncallback\nfunction optional\nChrome 99+The\ncallback\nparameter looks like:(response: any) => void\n-\nresponse\nany\nThe response message sent by the native messaging host. If an error occurs while connecting to the native messaging host, the callback will be called with no arguments and\nruntime.lastError\nwill be set to the error message.\n-\nReturns\n-\nPromise<any>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetUninstallURL()\nchrome.runtime.setUninstallURL(\nurl: string,\ncallback?: function,\n)\nSets the URL to be visited upon uninstallation. This may be used to clean up server-side data, do analytics, and implement surveys. Maximum 1023 characters.\nParameters\n-\nurl\nstring\nURL to be opened after the extension is uninstalled. This URL must have an http: or https: scheme. Set an empty string to not open a new tab upon uninstallation.\n-\ncallback\nfunction optional\nChrome 45+The\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonBrowserUpdateAvailable\nchrome.runtime.onBrowserUpdateAvailable.addListener(\ncallback: function,\n)\nPlease use runtime.onRestartRequired\n.\nFired when a Chrome update is available, but isn't installed immediately because a browser restart is required.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonConnect\nchrome.runtime.onConnect.addListener(\ncallback: function,\n)\nFired when a connection is made from either an extension process or a content script (by runtime.connect\n).\nonConnectExternal\nchrome.runtime.onConnectExternal.addListener(\ncallback: function,\n)\nFired when a connection is made from another extension (by runtime.connect\n), or from an externally connectable web site.\nonConnectNative\nchrome.runtime.onConnectNative.addListener(\ncallback: function,\n)\nFired when a connection is made from a native application. This event requires the \"nativeMessaging\"\npermission. It is only supported on Chrome OS.\nonInstalled\nchrome.runtime.onInstalled.addListener(\ncallback: function,\n)\nFired when the extension is first installed, when the extension is updated to a new version, and when Chrome is updated to a new version.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nid\nstring optional\nIndicates the ID of the imported shared module extension which updated. This is present only if 'reason' is 'shared_module_update'.\n-\npreviousVersion\nstring optional\nIndicates the previous version of the extension, which has just been updated. This is present only if 'reason' is 'update'.\n-\nreason\nThe reason that this event is being dispatched.\n-\n-\nonMessage\nchrome.runtime.onMessage.addListener(\ncallback: function,\n)\nFired when a message is sent from either an extension process (by runtime.sendMessage\n) or a content script (by tabs.sendMessage\n).\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(message: any, sender: MessageSender, sendResponse: function) => boolean | undefined\n-\nmessage\nany\n-\nsender\n-\nsendResponse\nfunction\nThe\nsendResponse\nparameter looks like:() => void\n-\nreturns\nboolean | undefined\n-\nonMessageExternal\nchrome.runtime.onMessageExternal.addListener(\ncallback: function,\n)\nFired when a message is sent from another extension (by runtime.sendMessage\n). Cannot be used in a content script.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(message: any, sender: MessageSender, sendResponse: function) => boolean | undefined\n-\nmessage\nany\n-\nsender\n-\nsendResponse\nfunction\nThe\nsendResponse\nparameter looks like:() => void\n-\nreturns\nboolean | undefined\n-\nonRestartRequired\nchrome.runtime.onRestartRequired.addListener(\ncallback: function,\n)\nFired when an app or the device that it runs on needs to be restarted. The app should close all its windows at its earliest convenient time to let the restart to happen. If the app does nothing, a restart will be enforced after a 24-hour grace period has passed. Currently, this event is only fired for Chrome OS kiosk apps.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(reason: OnRestartRequiredReason) => void\n-\nreason\n-\nonStartup\nchrome.runtime.onStartup.addListener(\ncallback: function,\n)\nFired when a profile that has this extension installed first starts up. This event is not fired when an incognito profile is started, even if this extension is operating in 'split' incognito mode.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonSuspend\nchrome.runtime.onSuspend.addListener(\ncallback: function,\n)\nSent to the event page just before it is unloaded. This gives the extension opportunity to do some clean up. Note that since the page is unloading, any asynchronous operations started while handling this event are not guaranteed to complete. If more activity for the event page occurs before it gets unloaded the onSuspendCanceled event will be sent and the page won't be unloaded.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonSuspendCanceled\nchrome.runtime.onSuspendCanceled.addListener(\ncallback: function,\n)\nSent after onSuspend to indicate that the app won't be unloaded after all.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonUpdateAvailable\nchrome.runtime.onUpdateAvailable.addListener(\ncallback: function,\n)\nFired when an update is available, but isn't installed immediately because the app is currently running. If you do nothing, the update will be installed the next time the background page gets unloaded, if you want it to be installed sooner you can explicitly call chrome.runtime.reload(). If your extension is using a persistent background page, the background page of course never gets unloaded, so unless you call chrome.runtime.reload() manually in response to this event the update will not get installed until the next time Chrome itself restarts. If no handlers are listening for this event, and your extension has a persistent background page, it behaves as if chrome.runtime.reload() is called in response to this event.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nversion\nstring\nThe version number of the available update.\n-\n-\nonUserScriptConnect\nchrome.runtime.onUserScriptConnect.addListener(\ncallback: function,\n)\nFired when a connection is made from a user script from this extension.\nonUserScriptMessage\nchrome.runtime.onUserScriptMessage.addListener(\ncallback: function,\n)\nFired when a message is sent from a user script associated with the same extension.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(message: any, sender: MessageSender, sendResponse: function) => boolean | undefined\n-\nmessage\nany\n-\nsender\n-\nsendResponse\nfunction\nThe\nsendResponse\nparameter looks like:() => void\n-\nreturns\nboolean | undefined\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/runtime", "title": "chrome.runtime | API | Chrome for Developers", "text": "Description\nUse the chrome.runtime\nAPI to retrieve the service worker, return details about the manifest, and listen for and respond to events in the extension lifecycle. You can also use this API to convert the relative path of URLs to fully-qualified URLs.\nMost members of this API do not require any permissions. This permission is needed for connectNative()\n, sendNativeMessage()\nand onNativeConnect\n.\nThe following example shows how to declare the \"nativeMessaging\"\npermission in the manifest:\nmanifest.json:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"nativeMessaging\"\n],\n...\n}\nConcepts and usage\nThe Runtime API provides methods to support a number of areas that your extensions can use:\n- Message passing\n- Your extension can communicate with different contexts within your extension and also with other extensions using these methods and events:\nconnect()\n,onConnect\n,onConnectExternal\n,sendMessage()\n,onMessage\nandonMessageExternal\n. In addition, your extension can pass messages to native applications on the user's device usingconnectNative()\nandsendNativeMessage()\n.\n- Accessing extension and platform metadata\n- These methods let you retrieve several specific pieces of metadata about the extension and the\nplatform. Methods in this category include\ngetManifest()\n, andgetPlatformInfo()\n. - Managing extension lifecycle and options\n- These properties let you perform some meta-operations on the extension, and display the options page.\nMethods and events in this category include\nonInstalled\n,onStartup\n,openOptionsPage()\n,reload()\n,requestUpdateCheck()\n, andsetUninstallURL()\n. - Helper utilities\n- These methods provide utility such as the conversion of internal resource representations to\nexternal formats. Methods in this category include\ngetURL()\n. - Kiosk mode utilities\n- These methods are available only on ChromeOS, and exist mainly to support kiosk implementations.\nMethods in this category include\nrestart()\nandrestartAfterDelay()\n`.\nUnpacked extension behavior\nWhen an unpacked extension is reloaded, this is treated as an update. This means that the\nchrome.runtime.onInstalled\nevent will fire with the \"update\"\nreason. This\nincludes when the extension is reloaded with chrome.runtime.reload()\n.\nUse cases\nAdd an image to a web page\nFor a web page to access an asset hosted on another domain, it must specify the resource's full URL\n(e.g. <img src=\"https://example.com/logo.png\">\n). The same is true to include an extension asset on\na web page. The two differences are that the extension's assets must be exposed as web\naccessible resources and that typically content scripts are responsible for injecting\nextension assets.\nIn this example, the extension will add logo.png\nto the page that the content\nscript is being injected into by using runtime.getURL()\nto create a\nfully-qualified URL. But first, the asset must be declared as a web accessible resource in the manifest.\nmanifest.json:\n{\n...\n\"web_accessible_resources\": [\n{\n\"resources\": [ \"logo.png\" ],\n\"matches\": [ \"https://*/*\" ]\n}\n],\n...\n}\ncontent.js:\n{ // Block used to avoid setting global variables\nconst img = document.createElement('img');\nimg.src = chrome.runtime.getURL('logo.png');\ndocument.body.append(img);\n}\nSend data from a content script to the service worker\nIts common for an extension's content scripts to need data managed by another part of the extension, like the service worker. Much like two browser windows opened to the same web page, these two contexts cannot directly access each other's values. Instead, the extension can use message passing to coordinate across these different contexts.\nIn this example, the content script needs some data from the extension's service worker to\ninitialize its UI. To get this data, it passes the developer-defined get-user-data\nmessage\nto the service worker, and it responds with a copy of the user's information.\ncontent.js:\n// 1. Send a message to the service worker requesting the user's data\nchrome.runtime.sendMessage('get-user-data', (response) => {\n// 3. Got an asynchronous response with the data from the service worker\nconsole.log('received user data', response);\ninitializeUI(response);\n});\nservice-worker.js:\n// Example of a simple user data object\nconst user = {\nusername: 'demo-user'\n};\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n// 2. A page requested user data, respond with a copy of `user`\nif (message === 'get-user-data') {\nsendResponse(user);\n}\n});\nGather feedback on uninstall\nMany extensions use post-uninstall surveys to understand how the extension could better serve its users and improve retention. The following example shows how to add this functionality.\nbackground.js:\nchrome.runtime.onInstalled.addListener(details => {\nif (details.reason === chrome.runtime.OnInstalledReason.INSTALL) {\nchrome.runtime.setUninstallURL('https://example.com/extension-survey');\n}\n});\nExamples\nSee the Manifest V3 - Web Accessible Resources demo for more Runtime API examples.\nTypes\nContextFilter\nA filter to match against certain extension contexts. Matching contexts must match all specified filters; any filter that is not specified matches all available contexts. Thus, a filter of `{}` will match all available contexts.\nProperties\n-\ncontextIds\nstring[] optional\n-\ncontextTypes\nContextType[] optional\n-\ndocumentIds\nstring[] optional\n-\ndocumentOrigins\nstring[] optional\n-\ndocumentUrls\nstring[] optional\n-\nframeIds\nnumber[] optional\n-\nincognito\nboolean optional\n-\ntabIds\nnumber[] optional\n-\nwindowIds\nnumber[] optional\nContextType\nEnum\n\"TAB\" \"POPUP\" \"BACKGROUND\" \"OFFSCREEN_DOCUMENT\" \"SIDE_PANEL\" \"DEVELOPER_TOOLS\"\nSpecifies the context type as a tab\nSpecifies the context type as an extension popup window\nSpecifies the context type as a service worker.\nSpecifies the context type as an offscreen document.\nSpecifies the context type as a side panel.\nSpecifies the context type as developer tools.\nExtensionContext\nA context hosting extension content.\nProperties\n-\ncontextId\nstring\nA unique identifier for this context\n-\ncontextType\nThe type of context this corresponds to.\n-\ndocumentId\nstring optional\nA UUID for the document associated with this context, or undefined if this context is hosted not in a document.\n-\ndocumentOrigin\nstring optional\nThe origin of the document associated with this context, or undefined if the context is not hosted in a document.\n-\ndocumentUrl\nstring optional\nThe URL of the document associated with this context, or undefined if the context is not hosted in a document.\n-\nframeId\nnumber\nThe ID of the frame for this context, or -1 if this context is not hosted in a frame.\n-\nincognito\nboolean\nWhether the context is associated with an incognito profile.\n-\ntabId\nnumber\nThe ID of the tab for this context, or -1 if this context is not hosted in a tab.\n-\nwindowId\nnumber\nThe ID of the window for this context, or -1 if this context is not hosted in a window.\nMessageSender\nAn object containing information about the script context that sent a message or request.\nProperties\n-\ndocumentId\nstring optional\nChrome 106+A UUID of the document that opened the connection.\n-\ndocumentLifecycle\nstring optional\nChrome 106+The lifecycle the document that opened the connection is in at the time the port was created. Note that the lifecycle state of the document may have changed since port creation.\n-\nframeId\nnumber optional\nThe frame that opened the connection. 0 for top-level frames, positive for child frames. This will only be set when\ntab\nis set. -\nid\nstring optional\nThe ID of the extension that opened the connection, if any.\n-\nnativeApplication\nstring optional\nChrome 74+The name of the native application that opened the connection, if any.\n-\norigin\nstring optional\nChrome 80+The origin of the page or frame that opened the connection. It can vary from the url property (e.g., about:blank) or can be opaque (e.g., sandboxed iframes). This is useful for identifying if the origin can be trusted if we can't immediately tell from the URL.\n-\ntab\nTab optional\nThe\ntabs.Tab\nwhich opened the connection, if any. This property will only be present when the connection was opened from a tab (including content scripts), and only if the receiver is an extension, not an app. -\ntlsChannelId\nstring optional\nThe TLS channel ID of the page or frame that opened the connection, if requested by the extension, and if available.\n-\nurl\nstring optional\nThe URL of the page or frame that opened the connection. If the sender is in an iframe, it will be iframe's URL not the URL of the page which hosts it.\nOnInstalledReason\nThe reason that this event is being dispatched.\nEnum\n\"install\" \"update\" \"chrome_update\" \"shared_module_update\"\nSpecifies the event reason as an installation.\nSpecifies the event reason as an extension update.\nSpecifies the event reason as a Chrome update.\nSpecifies the event reason as an update to a shared module.\nOnRestartRequiredReason\nThe reason that the event is being dispatched. 'app_update' is used when the restart is needed because the application is updated to a newer version. 'os_update' is used when the restart is needed because the browser/OS is updated to a newer version. 'periodic' is used when the system runs for more than the permitted uptime set in the enterprise policy.\nEnum\n\"app_update\" \"os_update\" \"periodic\"\nSpecifies the event reason as an update to the app.\nSpecifies the event reason as an update to the operating system.\nSpecifies the event reason as a periodic restart of the app.\nPlatformArch\nThe machine's processor architecture.\nEnum\n\"arm\" \"arm64\" \"x86-32\" \"x86-64\" \"mips\" \"mips64\"\nSpecifies the processer architecture as arm.\nSpecifies the processer architecture as arm64.\nSpecifies the processer architecture as x86-32.\nSpecifies the processer architecture as x86-64.\nSpecifies the processer architecture as mips.\nSpecifies the processer architecture as mips64.\nPlatformInfo\nAn object containing information about the current platform.\nProperties\n-\narch\nThe machine's processor architecture.\n-\nnacl_arch\nThe native client architecture. This may be different from arch on some platforms.\n-\nos\nThe operating system Chrome is running on.\nPlatformNaclArch\nThe native client architecture. This may be different from arch on some platforms.\nEnum\n\"arm\" \"x86-32\" \"x86-64\" \"mips\" \"mips64\"\nSpecifies the native client architecture as arm.\nSpecifies the native client architecture as x86-32.\nSpecifies the native client architecture as x86-64.\nSpecifies the native client architecture as mips.\nSpecifies the native client architecture as mips64.\nPlatformOs\nThe operating system Chrome is running on.\nEnum\n\"mac\" \"win\" \"android\" \"cros\" \"linux\" \"openbsd\" \"fuchsia\"\nSpecifies the MacOS operating system.\nSpecifies the Windows operating system.\nSpecifies the Android operating system.\nSpecifies the Chrome operating system.\nSpecifies the Linux operating system.\nSpecifies the OpenBSD operating system.\nSpecifies the Fuchsia operating system.\nPort\nAn object which allows two way communication with other pages. See Long-lived connections for more information.\nProperties\n-\nname\nstring\nThe name of the port, as specified in the call to\nruntime.connect\n. -\nonDisconnect\nEvent<functionvoidvoid>\nFired when the port is disconnected from the other end(s).\nruntime.lastError\nmay be set if the port was disconnected by an error. If the port is closed via disconnect, then this event is only fired on the other end. This event is fired at most once (see also Port lifetime).The\nonDisconnect.addListener\nfunction looks like:(callback: function) => {...}\n-\nonMessage\nEvent<functionvoidvoid>\nThis event is fired when postMessage is called by the other end of the port.\nThe\nonMessage.addListener\nfunction looks like:(callback: function) => {...}\n-\nsender\nMessageSender optional\nThis property will only be present on ports passed to onConnect / onConnectExternal / onConnectNative listeners.\n-\ndisconnect\nvoid\nImmediately disconnect the port. Calling\ndisconnect()\non an already-disconnected port has no effect. When a port is disconnected, no new events will be dispatched to this port.The\ndisconnect\nfunction looks like:() => {...}\n-\npostMessage\nvoid\nSend a message to the other end of the port. If the port is disconnected, an error is thrown.\nThe\npostMessage\nfunction looks like:(message: any) => {...}\n-\nmessage\nany\nChrome 52+The message to send. This object should be JSON-ifiable.\n-\nRequestUpdateCheckStatus\nResult of the update check.\nEnum\n\"throttled\" \"no_update\" \"update_available\"\nSpecifies that the status check has been throttled. This can occur after repeated checks within a short amount of time.\nSpecifies that there are no available updates to install.\nSpecifies that there is an available update to install.\nProperties\nid\nThe ID of the extension/app.\nType\nstring\nlastError\nPopulated with an error message if calling an API function fails; otherwise undefined. This is only defined within the scope of that function's callback. If an error is produced, but runtime.lastError\nis not accessed within the callback, a message is logged to the console listing the API function that produced the error. API functions that return promises do not set this property.\nType\nobject\nProperties\n-\nmessage\nstring optional\nDetails about the error which occurred.\nMethods\nconnect()\nchrome.runtime.connect(\nextensionId?: string,\nconnectInfo?: object,\n)\nAttempts to connect listeners within an extension (such as the background page), or other extensions/apps. This is useful for content scripts connecting to their extension processes, inter-app/extension communication, and web messaging. Note that this does not connect to any listeners in a content script. Extensions may connect to content scripts embedded in tabs via tabs.connect\n.\nParameters\n-\nextensionId\nstring optional\nThe ID of the extension to connect to. If omitted, a connection will be attempted with your own extension. Required if sending messages from a web page for web messaging.\n-\nconnectInfo\nobject optional\n-\nincludeTlsChannelId\nboolean optional\nWhether the TLS channel ID will be passed into onConnectExternal for processes that are listening for the connection event.\n-\nname\nstring optional\nWill be passed into onConnect for processes that are listening for the connection event.\n-\nReturns\n-\nPort through which messages can be sent and received. The port's onDisconnect event is fired if the extension does not exist.\nconnectNative()\nchrome.runtime.connectNative(\napplication: string,\n)\nConnects to a native application in the host machine. This method requires the \"nativeMessaging\"\npermission. See Native Messaging for more information.\nParameters\n-\napplication\nstring\nThe name of the registered application to connect to.\nReturns\n-\nPort through which messages can be sent and received with the application\ngetBackgroundPage()\nchrome.runtime.getBackgroundPage(\ncallback?: function,\n)\nBackground pages do not exist in MV3 extensions.\nRetrieves the JavaScript 'window' object for the background page running inside the current extension/app. If the background page is an event page, the system will ensure it is loaded before calling the callback. If there is no background page, an error is set.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(backgroundPage?: Window) => void\n-\nbackgroundPage\nWindow optional\nThe JavaScript 'window' object for the background page.\n-\nReturns\n-\nPromise<Window | undefined>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetContexts()\nchrome.runtime.getContexts(\nfilter: ContextFilter,\ncallback?: function,\n)\nFetches information about active contexts associated with this extension\nParameters\n-\nfilter\nA filter to find matching contexts. A context matches if it matches all specified fields in the filter. Any unspecified field in the filter matches all contexts.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(contexts: ExtensionContext[]) => void\n-\ncontexts\nThe matching contexts, if any.\n-\nReturns\n-\nPromise<ExtensionContext[]>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetManifest()\nchrome.runtime.getManifest()\nReturns details about the app or extension from the manifest. The object returned is a serialization of the full manifest file.\nReturns\n-\nobject\nThe manifest details.\ngetPackageDirectoryEntry()\nchrome.runtime.getPackageDirectoryEntry(\ncallback?: function,\n)\nReturns a DirectoryEntry for the package directory.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(directoryEntry: DirectoryEntry) => void\n-\ndirectoryEntry\nDirectoryEntry\n-\nReturns\n-\nPromise<DirectoryEntry>\nChrome 122+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetPlatformInfo()\nchrome.runtime.getPlatformInfo(\ncallback?: function,\n)\nReturns information about the current platform.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(platformInfo: PlatformInfo) => void\n-\nplatformInfo\n-\nReturns\n-\nPromise<PlatformInfo>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetURL()\nchrome.runtime.getURL(\npath: string,\n)\nConverts a relative path within an app/extension install directory to a fully-qualified URL.\nParameters\n-\npath\nstring\nA path to a resource within an app/extension expressed relative to its install directory.\nReturns\n-\nstring\nThe fully-qualified URL to the resource.\nopenOptionsPage()\nchrome.runtime.openOptionsPage(\ncallback?: function,\n)\nOpen your Extension's options page, if possible.\nThe precise behavior may depend on your manifest's options_ui\nor options_page\nkey, or what Chrome happens to support at the time. For example, the page may be opened in a new tab, within chrome://extensions, within an App, or it may just focus an open options page. It will never cause the caller page to reload.\nIf your Extension does not declare an options page, or Chrome failed to create one for some other reason, the callback will set lastError\n.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nreload()\nchrome.runtime.reload()\nReloads the app or extension. This method is not supported in kiosk mode. For kiosk mode, use chrome.runtime.restart() method.\nrequestUpdateCheck()\nchrome.runtime.requestUpdateCheck(\ncallback?: function,\n)\nRequests an immediate update check be done for this app/extension.\nImportant: Most extensions/apps should not use this method, since Chrome already does automatic checks every few hours, and you can listen for the runtime.onUpdateAvailable\nevent without needing to call requestUpdateCheck.\nThis method is only appropriate to call in very limited circumstances, such as if your extension talks to a backend service, and the backend service has determined that the client extension version is very far out of date and you'd like to prompt a user to update. Most other uses of requestUpdateCheck, such as calling it unconditionally based on a repeating timer, probably only serve to waste client, network, and server resources.\nNote: When called with a callback, instead of returning an object this function will return the two properties as separate arguments passed to the callback.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: object) => void\n-\nresult\nobject\nChrome 109+RequestUpdateCheckResult object that holds the status of the update check and any details of the result if there is an update available\n-\nstatus\nResult of the update check.\n-\nversion\nstring optional\nIf an update is available, this contains the version of the available update.\n-\n-\nReturns\n-\nPromise<object>\nChrome 109+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nrestart()\nchrome.runtime.restart()\nRestart the ChromeOS device when the app runs in kiosk mode. Otherwise, it's no-op.\nrestartAfterDelay()\nchrome.runtime.restartAfterDelay(\nseconds: number,\ncallback?: function,\n)\nRestart the ChromeOS device when the app runs in kiosk mode after the given seconds. If called again before the time ends, the reboot will be delayed. If called with a value of -1, the reboot will be cancelled. It's a no-op in non-kiosk mode. It's only allowed to be called repeatedly by the first extension to invoke this API.\nParameters\n-\nseconds\nnumber\nTime to wait in seconds before rebooting the device, or -1 to cancel a scheduled reboot.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsendMessage()\nchrome.runtime.sendMessage(\nextensionId?: string,\nmessage: any,\noptions?: object,\ncallback?: function,\n)\nSends a single message to event listeners within your extension or a different extension/app. Similar to runtime.connect\nbut only sends a single message, with an optional response. If sending to your extension, the runtime.onMessage\nevent will be fired in every frame of your extension (except for the sender's frame), or runtime.onMessageExternal\n, if a different extension. Note that extensions cannot send messages to content scripts using this method. To send messages to content scripts, use tabs.sendMessage\n.\nParameters\n-\nextensionId\nstring optional\nThe ID of the extension to send the message to. If omitted, the message will be sent to your own extension/app. Required if sending messages from a web page for web messaging.\n-\nmessage\nany\nThe message to send. This message should be a JSON-ifiable object.\n-\noptions\nobject optional\n-\nincludeTlsChannelId\nboolean optional\nWhether the TLS channel ID will be passed into onMessageExternal for processes that are listening for the connection event.\n-\n-\ncallback\nfunction optional\nChrome 99+The\ncallback\nparameter looks like:(response: any) => void\n-\nresponse\nany\nThe JSON response object sent by the handler of the message. If an error occurs while connecting to the extension, the callback will be called with no arguments and\nruntime.lastError\nwill be set to the error message.\n-\nReturns\n-\nPromise<any>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsendNativeMessage()\nchrome.runtime.sendNativeMessage(\napplication: string,\nmessage: object,\ncallback?: function,\n)\nSend a single message to a native application. This method requires the \"nativeMessaging\"\npermission.\nParameters\n-\napplication\nstring\nThe name of the native messaging host.\n-\nmessage\nobject\nThe message that will be passed to the native messaging host.\n-\ncallback\nfunction optional\nChrome 99+The\ncallback\nparameter looks like:(response: any) => void\n-\nresponse\nany\nThe response message sent by the native messaging host. If an error occurs while connecting to the native messaging host, the callback will be called with no arguments and\nruntime.lastError\nwill be set to the error message.\n-\nReturns\n-\nPromise<any>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetUninstallURL()\nchrome.runtime.setUninstallURL(\nurl: string,\ncallback?: function,\n)\nSets the URL to be visited upon uninstallation. This may be used to clean up server-side data, do analytics, and implement surveys. Maximum 1023 characters.\nParameters\n-\nurl\nstring\nURL to be opened after the extension is uninstalled. This URL must have an http: or https: scheme. Set an empty string to not open a new tab upon uninstallation.\n-\ncallback\nfunction optional\nChrome 45+The\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonBrowserUpdateAvailable\nchrome.runtime.onBrowserUpdateAvailable.addListener(\ncallback: function,\n)\nPlease use runtime.onRestartRequired\n.\nFired when a Chrome update is available, but isn't installed immediately because a browser restart is required.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonConnect\nchrome.runtime.onConnect.addListener(\ncallback: function,\n)\nFired when a connection is made from either an extension process or a content script (by runtime.connect\n).\nonConnectExternal\nchrome.runtime.onConnectExternal.addListener(\ncallback: function,\n)\nFired when a connection is made from another extension (by runtime.connect\n), or from an externally connectable web site.\nonConnectNative\nchrome.runtime.onConnectNative.addListener(\ncallback: function,\n)\nFired when a connection is made from a native application. This event requires the \"nativeMessaging\"\npermission. It is only supported on Chrome OS.\nonInstalled\nchrome.runtime.onInstalled.addListener(\ncallback: function,\n)\nFired when the extension is first installed, when the extension is updated to a new version, and when Chrome is updated to a new version.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nid\nstring optional\nIndicates the ID of the imported shared module extension which updated. This is present only if 'reason' is 'shared_module_update'.\n-\npreviousVersion\nstring optional\nIndicates the previous version of the extension, which has just been updated. This is present only if 'reason' is 'update'.\n-\nreason\nThe reason that this event is being dispatched.\n-\n-\nonMessage\nchrome.runtime.onMessage.addListener(\ncallback: function,\n)\nFired when a message is sent from either an extension process (by runtime.sendMessage\n) or a content script (by tabs.sendMessage\n).\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(message: any, sender: MessageSender, sendResponse: function) => boolean | undefined\n-\nmessage\nany\n-\nsender\n-\nsendResponse\nfunction\nThe\nsendResponse\nparameter looks like:() => void\n-\nreturns\nboolean | undefined\n-\nonMessageExternal\nchrome.runtime.onMessageExternal.addListener(\ncallback: function,\n)\nFired when a message is sent from another extension (by runtime.sendMessage\n). Cannot be used in a content script.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(message: any, sender: MessageSender, sendResponse: function) => boolean | undefined\n-\nmessage\nany\n-\nsender\n-\nsendResponse\nfunction\nThe\nsendResponse\nparameter looks like:() => void\n-\nreturns\nboolean | undefined\n-\nonRestartRequired\nchrome.runtime.onRestartRequired.addListener(\ncallback: function,\n)\nFired when an app or the device that it runs on needs to be restarted. The app should close all its windows at its earliest convenient time to let the restart to happen. If the app does nothing, a restart will be enforced after a 24-hour grace period has passed. Currently, this event is only fired for Chrome OS kiosk apps.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(reason: OnRestartRequiredReason) => void\n-\nreason\n-\nonStartup\nchrome.runtime.onStartup.addListener(\ncallback: function,\n)\nFired when a profile that has this extension installed first starts up. This event is not fired when an incognito profile is started, even if this extension is operating in 'split' incognito mode.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonSuspend\nchrome.runtime.onSuspend.addListener(\ncallback: function,\n)\nSent to the event page just before it is unloaded. This gives the extension opportunity to do some clean up. Note that since the page is unloading, any asynchronous operations started while handling this event are not guaranteed to complete. If more activity for the event page occurs before it gets unloaded the onSuspendCanceled event will be sent and the page won't be unloaded.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonSuspendCanceled\nchrome.runtime.onSuspendCanceled.addListener(\ncallback: function,\n)\nSent after onSuspend to indicate that the app won't be unloaded after all.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonUpdateAvailable\nchrome.runtime.onUpdateAvailable.addListener(\ncallback: function,\n)\nFired when an update is available, but isn't installed immediately because the app is currently running. If you do nothing, the update will be installed the next time the background page gets unloaded, if you want it to be installed sooner you can explicitly call chrome.runtime.reload(). If your extension is using a persistent background page, the background page of course never gets unloaded, so unless you call chrome.runtime.reload() manually in response to this event the update will not get installed until the next time Chrome itself restarts. If no handlers are listening for this event, and your extension has a persistent background page, it behaves as if chrome.runtime.reload() is called in response to this event.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nversion\nstring\nThe version number of the available update.\n-\n-\nonUserScriptConnect\nchrome.runtime.onUserScriptConnect.addListener(\ncallback: function,\n)\nFired when a connection is made from a user script from this extension.\nonUserScriptMessage\nchrome.runtime.onUserScriptMessage.addListener(\ncallback: function,\n)\nFired when a message is sent from a user script associated with the same extension.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(message: any, sender: MessageSender, sendResponse: function) => boolean | undefined\n-\nmessage\nany\n-\nsender\n-\nsendResponse\nfunction\nThe\nsendResponse\nparameter looks like:() => void\n-\nreturns\nboolean | undefined\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/scripting", "title": "chrome.scripting | API | Chrome for Developers", "text": "Description\nUse the chrome.scripting\nAPI to execute script in different contexts.\nPermissions\nscripting\nAvailability\nManifest\nTo use the chrome.scripting\nAPI, declare the \"scripting\"\npermission in the manifest plus the host permissions for the pages to inject scripts into. Use the \"host_permissions\"\nkey or the \"activeTab\"\npermission, which grants temporary host permissions. The following example uses the activeTab permission.\n{\n\"name\": \"Scripting Extension\",\n\"manifest_version\": 3,\n\"permissions\": [\"scripting\", \"activeTab\"],\n...\n}\nConcepts and usage\nYou can use the chrome.scripting\nAPI to inject JavaScript and CSS into\nwebsites. This is similar to what you can do with content\nscripts. But by using the chrome.scripting\nnamespace, extensions\ncan make decisions at runtime.\nInjection targets\nYou can use the target\nparameter to specify a target to inject JavaScript or\nCSS into.\nThe only required field is tabId\n. By default, an injection will run in the\nmain frame of the specified tab.\nfunction getTabId() { ... }\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId()},\nfiles : [ \"script.js\" ],\n})\n.then(() => console.log(\"script injected\"));\nTo run in all frames of the specified tab, you can set the allFrames\nboolean\nto true\n.\nfunction getTabId() { ... }\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId(), allFrames : true},\nfiles : [ \"script.js\" ],\n})\n.then(() => console.log(\"script injected in all frames\"));\nYou can also inject into specific frames of a tab by specifying individual frame\nIDs. For more information on frame IDs, see the chrome.webNavigation\nAPI.\nfunction getTabId() { ... }\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId(), frameIds : [ frameId1, frameId2 ]},\nfiles : [ \"script.js\" ],\n})\n.then(() => console.log(\"script injected on target frames\"));\nInjected code\nExtensions can specify the code to be injected either via an external file or a runtime variable.\nFiles\nFiles are specified as strings that are paths relative to the extension's root\ndirectory. The following code will inject the file script.js\ninto the main\nframe of the tab.\nfunction getTabId() { ... }\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId()},\nfiles : [ \"script.js\" ],\n})\n.then(() => console.log(\"injected script file\"));\nRuntime functions\nWhen injecting JavaScript with scripting.executeScript()\n, you can specify a\nfunction to be executed instead of a file. This function should be a function\nvariable available to the current extension context.\nfunction getTabId() { ... }\nfunction getTitle() { return document.title; }\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId()},\nfunc : getTitle,\n})\n.then(() => console.log(\"injected a function\"));\nfunction getTabId() { ... }\nfunction getUserColor() { ... }\nfunction changeBackgroundColor() {\ndocument.body.style.backgroundColor = getUserColor();\n}\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId()},\nfunc : changeBackgroundColor,\n})\n.then(() => console.log(\"injected a function\"));\nYou can work around this by using the args\nproperty:\nfunction getTabId() { ... }\nfunction getUserColor() { ... }\nfunction changeBackgroundColor(backgroundColor) {\ndocument.body.style.backgroundColor = backgroundColor;\n}\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId()},\nfunc : changeBackgroundColor,\nargs : [ getUserColor() ],\n})\n.then(() => console.log(\"injected a function\"));\nRuntime strings\nIf injecting CSS within a page, you can also specify a string to be used in the\ncss\nproperty. This option is only available for scripting.insertCSS()\n; you\ncan't execute a string using scripting.executeScript()\n.\nfunction getTabId() { ... }\nconst css = \"body { background-color: red; }\";\nchrome.scripting\n.insertCSS({\ntarget : {tabId : getTabId()},\ncss : css,\n})\n.then(() => console.log(\"CSS injected\"));\nHandle the results\nThe results of executing JavaScript are passed to the extension. A single result is included per-frame. The main frame is guaranteed to be the first index in the resulting array; all other frames are in a non-deterministic order.\nfunction getTabId() { ... }\nfunction getTitle() { return document.title; }\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId(), allFrames : true},\nfunc : getTitle,\n})\n.then(injectionResults => {\nfor (const {frameId, result} of injectionResults) {\nconsole.log(`Frame ${frameId} result:`, result);\n}\n});\nscripting.insertCSS()\ndoes not return any results.\nPromises\nIf the resulting value of the script execution is a promise, Chrome will wait for the promise to settle and return the resulting value.\nfunction getTabId() { ... }\nasync function addIframe() {\nconst iframe = document.createElement(\"iframe\");\nconst loadComplete =\nnew Promise(resolve => iframe.addEventListener(\"load\", resolve));\niframe.src = \"https://example.com\";\ndocument.body.appendChild(iframe);\nawait loadComplete;\nreturn iframe.contentWindow.document.title;\n}\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId(), allFrames : true},\nfunc : addIframe,\n})\n.then(injectionResults => {\nfor (const frameResult of injectionResults) {\nconst {frameId, result} = frameResult;\nconsole.log(`Frame ${frameId} result:`, result);\n}\n});\nExamples\nUnregister all dynamic content scripts\nThe following snippet contains a function that unregisters all dynamic content scripts the extension has previously registered.\nasync function unregisterAllDynamicContentScripts() {\ntry {\nconst scripts = await chrome.scripting.getRegisteredContentScripts();\nconst scriptIds = scripts.map(script => script.id);\nreturn chrome.scripting.unregisterContentScripts(scriptIds);\n} catch (error) {\nconst message = [\n\"An unexpected error occurred while\",\n\"unregistering dynamic content scripts.\",\n].join(\" \");\nthrow new Error(message, {cause : error});\n}\n}\nTo try the chrome.scripting\nAPI,\ninstall the scripting sample from the Chrome extension samples\nrepository.\nTypes\nContentScriptFilter\nProperties\n-\nids\nstring[] optional\nIf specified,\ngetRegisteredContentScripts\nwill only return scripts with an id specified in this list.\nCSSInjection\nProperties\n-\ncss\nstring optional\nA string containing the CSS to inject. Exactly one of\nfiles\nandcss\nmust be specified. -\nfiles\nstring[] optional\nThe path of the CSS files to inject, relative to the extension's root directory. Exactly one of\nfiles\nandcss\nmust be specified. -\norigin\nStyleOrigin optional\nThe style origin for the injection. Defaults to\n'AUTHOR'\n. -\ntarget\nDetails specifying the target into which to insert the CSS.\nExecutionWorld\nThe JavaScript world for a script to execute within.\nEnum\n\"ISOLATED\" \"MAIN\"\nSpecifies the isolated world, which is the execution environment unique to this extension.\nSpecifies the main world of the DOM, which is the execution environment shared with the host page's JavaScript.\nInjectionResult\nProperties\n-\ndocumentId\nstring\nChrome 106+The document associated with the injection.\n-\nframeId\nnumber\nChrome 90+The frame associated with the injection.\n-\nresult\nany optional\nThe result of the script execution.\nInjectionTarget\nProperties\n-\nallFrames\nboolean optional\nWhether the script should inject into all frames within the tab. Defaults to false. This must not be true if\nframeIds\nis specified. -\ndocumentIds\nstring[] optional\nChrome 106+The IDs of specific documentIds to inject into. This must not be set if\nframeIds\nis set. -\nframeIds\nnumber[] optional\nThe IDs of specific frames to inject into.\n-\ntabId\nnumber\nThe ID of the tab into which to inject.\nRegisteredContentScript\nProperties\n-\nallFrames\nboolean optional\nIf specified true, it will inject into all frames, even if the frame is not the top-most frame in the tab. Each frame is checked independently for URL requirements; it will not inject into child frames if the URL requirements are not met. Defaults to false, meaning that only the top frame is matched.\n-\ncss\nstring[] optional\nThe list of CSS files to be injected into matching pages. These are injected in the order they appear in this array, before any DOM is constructed or displayed for the page.\n-\nexcludeMatches\nstring[] optional\nExcludes pages that this content script would otherwise be injected into. See Match Patterns for more details on the syntax of these strings.\n-\nid\nstring\nThe id of the content script, specified in the API call. Must not start with a '_' as it's reserved as a prefix for generated script IDs.\n-\njs\nstring[] optional\nThe list of JavaScript files to be injected into matching pages. These are injected in the order they appear in this array.\n-\nmatchOriginAsFallback\nboolean optional\nChrome 119+Indicates whether the script can be injected into frames where the URL contains an unsupported scheme; specifically: about:, data:, blob:, or filesystem:. In these cases, the URL's origin is checked to determine if the script should be injected. If the origin is\nnull\n(as is the case for data: URLs) then the used origin is either the frame that created the current frame or the frame that initiated the navigation to this frame. Note that this may not be the parent frame. -\nmatches\nstring[] optional\nSpecifies which pages this content script will be injected into. See Match Patterns for more details on the syntax of these strings. Must be specified for\nregisterContentScripts\n. -\npersistAcrossSessions\nboolean optional\nSpecifies if this content script will persist into future sessions. The default is true.\n-\nrunAt\nRunAt optional\nSpecifies when JavaScript files are injected into the web page. The preferred and default value is\ndocument_idle\n. -\nworld\nExecutionWorld optional\nChrome 102+The JavaScript \"world\" to run the script in. Defaults to\nISOLATED\n.\nScriptInjection\nProperties\n-\nargs\nany[] optional\nChrome 92+The arguments to pass to the provided function. This is only valid if the\nfunc\nparameter is specified. These arguments must be JSON-serializable. -\nfiles\nstring[] optional\nThe path of the JS or CSS files to inject, relative to the extension's root directory. Exactly one of\nfiles\norfunc\nmust be specified. -\ninjectImmediately\nboolean optional\nChrome 102+Whether the injection should be triggered in the target as soon as possible. Note that this is not a guarantee that injection will occur prior to page load, as the page may have already loaded by the time the script reaches the target.\n-\ntarget\nDetails specifying the target into which to inject the script.\n-\nworld\nExecutionWorld optional\nChrome 95+The JavaScript \"world\" to run the script in. Defaults to\nISOLATED\n. -\nfunc\nvoid optional\nChrome 92+A JavaScript function to inject. This function will be serialized, and then deserialized for injection. This means that any bound parameters and execution context will be lost. Exactly one of\nfiles\norfunc\nmust be specified.The\nfunc\nfunction looks like:() => {...}\nStyleOrigin\nThe origin for a style change. See style origins for more info.\nEnum\n\"AUTHOR\" \"USER\"\nMethods\nexecuteScript()\nchrome.scripting.executeScript(\ninjection: ScriptInjection,\ncallback?: function,\n)\nInjects a script into a target context. By default, the script will be run at document_idle\n, or immediately if the page has already loaded. If the injectImmediately\nproperty is set, the script will inject without waiting, even if the page has not finished loading. If the script evaluates to a promise, the browser will wait for the promise to settle and return the resulting value.\nParameters\n-\ninjection\nThe details of the script which to inject.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(results: InjectionResult[]) => void\n-\nresults\n-\nReturns\n-\nPromise<InjectionResult[]>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetRegisteredContentScripts()\nchrome.scripting.getRegisteredContentScripts(\nfilter?: ContentScriptFilter,\ncallback?: function,\n)\nReturns all dynamically registered content scripts for this extension that match the given filter.\nParameters\n-\nfilter\nContentScriptFilter optional\nAn object to filter the extension's dynamically registered scripts.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(scripts: RegisteredContentScript[]) => void\n-\nscripts\n-\nReturns\n-\nPromise<RegisteredContentScript[]>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ninsertCSS()\nchrome.scripting.insertCSS(\ninjection: CSSInjection,\ncallback?: function,\n)\nInserts a CSS stylesheet into a target context. If multiple frames are specified, unsuccessful injections are ignored.\nParameters\n-\ninjection\nThe details of the styles to insert.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nregisterContentScripts()\nchrome.scripting.registerContentScripts(\nscripts: RegisteredContentScript[],\ncallback?: function,\n)\nRegisters one or more content scripts for this extension.\nParameters\n-\nscripts\nContains a list of scripts to be registered. If there are errors during script parsing/file validation, or if the IDs specified already exist, then no scripts are registered.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveCSS()\nchrome.scripting.removeCSS(\ninjection: CSSInjection,\ncallback?: function,\n)\nRemoves a CSS stylesheet that was previously inserted by this extension from a target context.\nParameters\n-\ninjection\nThe details of the styles to remove. Note that the\ncss\n,files\n, andorigin\nproperties must exactly match the stylesheet inserted throughinsertCSS\n. Attempting to remove a non-existent stylesheet is a no-op. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nunregisterContentScripts()\nchrome.scripting.unregisterContentScripts(\nfilter?: ContentScriptFilter,\ncallback?: function,\n)\nUnregisters content scripts for this extension.\nParameters\n-\nfilter\nContentScriptFilter optional\nIf specified, only unregisters dynamic content scripts which match the filter. Otherwise, all of the extension's dynamic content scripts are unregistered.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdateContentScripts()\nchrome.scripting.updateContentScripts(\nscripts: RegisteredContentScript[],\ncallback?: function,\n)\nUpdates one or more content scripts for this extension.\nParameters\n-\nscripts\nContains a list of scripts to be updated. A property is only updated for the existing script if it is specified in this object. If there are errors during script parsing/file validation, or if the IDs specified do not correspond to a fully registered script, then no scripts are updated.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/scripting", "title": "chrome.scripting | API | Chrome for Developers", "text": "Description\nUse the chrome.scripting\nAPI to execute script in different contexts.\nPermissions\nscripting\nAvailability\nManifest\nTo use the chrome.scripting\nAPI, declare the \"scripting\"\npermission in the manifest plus the host permissions for the pages to inject scripts into. Use the \"host_permissions\"\nkey or the \"activeTab\"\npermission, which grants temporary host permissions. The following example uses the activeTab permission.\n{\n\"name\": \"Scripting Extension\",\n\"manifest_version\": 3,\n\"permissions\": [\"scripting\", \"activeTab\"],\n...\n}\nConcepts and usage\nYou can use the chrome.scripting\nAPI to inject JavaScript and CSS into\nwebsites. This is similar to what you can do with content\nscripts. But by using the chrome.scripting\nnamespace, extensions\ncan make decisions at runtime.\nInjection targets\nYou can use the target\nparameter to specify a target to inject JavaScript or\nCSS into.\nThe only required field is tabId\n. By default, an injection will run in the\nmain frame of the specified tab.\nfunction getTabId() { ... }\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId()},\nfiles : [ \"script.js\" ],\n})\n.then(() => console.log(\"script injected\"));\nTo run in all frames of the specified tab, you can set the allFrames\nboolean\nto true\n.\nfunction getTabId() { ... }\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId(), allFrames : true},\nfiles : [ \"script.js\" ],\n})\n.then(() => console.log(\"script injected in all frames\"));\nYou can also inject into specific frames of a tab by specifying individual frame\nIDs. For more information on frame IDs, see the chrome.webNavigation\nAPI.\nfunction getTabId() { ... }\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId(), frameIds : [ frameId1, frameId2 ]},\nfiles : [ \"script.js\" ],\n})\n.then(() => console.log(\"script injected on target frames\"));\nInjected code\nExtensions can specify the code to be injected either via an external file or a runtime variable.\nFiles\nFiles are specified as strings that are paths relative to the extension's root\ndirectory. The following code will inject the file script.js\ninto the main\nframe of the tab.\nfunction getTabId() { ... }\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId()},\nfiles : [ \"script.js\" ],\n})\n.then(() => console.log(\"injected script file\"));\nRuntime functions\nWhen injecting JavaScript with scripting.executeScript()\n, you can specify a\nfunction to be executed instead of a file. This function should be a function\nvariable available to the current extension context.\nfunction getTabId() { ... }\nfunction getTitle() { return document.title; }\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId()},\nfunc : getTitle,\n})\n.then(() => console.log(\"injected a function\"));\nfunction getTabId() { ... }\nfunction getUserColor() { ... }\nfunction changeBackgroundColor() {\ndocument.body.style.backgroundColor = getUserColor();\n}\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId()},\nfunc : changeBackgroundColor,\n})\n.then(() => console.log(\"injected a function\"));\nYou can work around this by using the args\nproperty:\nfunction getTabId() { ... }\nfunction getUserColor() { ... }\nfunction changeBackgroundColor(backgroundColor) {\ndocument.body.style.backgroundColor = backgroundColor;\n}\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId()},\nfunc : changeBackgroundColor,\nargs : [ getUserColor() ],\n})\n.then(() => console.log(\"injected a function\"));\nRuntime strings\nIf injecting CSS within a page, you can also specify a string to be used in the\ncss\nproperty. This option is only available for scripting.insertCSS()\n; you\ncan't execute a string using scripting.executeScript()\n.\nfunction getTabId() { ... }\nconst css = \"body { background-color: red; }\";\nchrome.scripting\n.insertCSS({\ntarget : {tabId : getTabId()},\ncss : css,\n})\n.then(() => console.log(\"CSS injected\"));\nHandle the results\nThe results of executing JavaScript are passed to the extension. A single result is included per-frame. The main frame is guaranteed to be the first index in the resulting array; all other frames are in a non-deterministic order.\nfunction getTabId() { ... }\nfunction getTitle() { return document.title; }\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId(), allFrames : true},\nfunc : getTitle,\n})\n.then(injectionResults => {\nfor (const {frameId, result} of injectionResults) {\nconsole.log(`Frame ${frameId} result:`, result);\n}\n});\nscripting.insertCSS()\ndoes not return any results.\nPromises\nIf the resulting value of the script execution is a promise, Chrome will wait for the promise to settle and return the resulting value.\nfunction getTabId() { ... }\nasync function addIframe() {\nconst iframe = document.createElement(\"iframe\");\nconst loadComplete =\nnew Promise(resolve => iframe.addEventListener(\"load\", resolve));\niframe.src = \"https://example.com\";\ndocument.body.appendChild(iframe);\nawait loadComplete;\nreturn iframe.contentWindow.document.title;\n}\nchrome.scripting\n.executeScript({\ntarget : {tabId : getTabId(), allFrames : true},\nfunc : addIframe,\n})\n.then(injectionResults => {\nfor (const frameResult of injectionResults) {\nconst {frameId, result} = frameResult;\nconsole.log(`Frame ${frameId} result:`, result);\n}\n});\nExamples\nUnregister all dynamic content scripts\nThe following snippet contains a function that unregisters all dynamic content scripts the extension has previously registered.\nasync function unregisterAllDynamicContentScripts() {\ntry {\nconst scripts = await chrome.scripting.getRegisteredContentScripts();\nconst scriptIds = scripts.map(script => script.id);\nreturn chrome.scripting.unregisterContentScripts(scriptIds);\n} catch (error) {\nconst message = [\n\"An unexpected error occurred while\",\n\"unregistering dynamic content scripts.\",\n].join(\" \");\nthrow new Error(message, {cause : error});\n}\n}\nTo try the chrome.scripting\nAPI,\ninstall the scripting sample from the Chrome extension samples\nrepository.\nTypes\nContentScriptFilter\nProperties\n-\nids\nstring[] optional\nIf specified,\ngetRegisteredContentScripts\nwill only return scripts with an id specified in this list.\nCSSInjection\nProperties\n-\ncss\nstring optional\nA string containing the CSS to inject. Exactly one of\nfiles\nandcss\nmust be specified. -\nfiles\nstring[] optional\nThe path of the CSS files to inject, relative to the extension's root directory. Exactly one of\nfiles\nandcss\nmust be specified. -\norigin\nStyleOrigin optional\nThe style origin for the injection. Defaults to\n'AUTHOR'\n. -\ntarget\nDetails specifying the target into which to insert the CSS.\nExecutionWorld\nThe JavaScript world for a script to execute within.\nEnum\n\"ISOLATED\" \"MAIN\"\nSpecifies the isolated world, which is the execution environment unique to this extension.\nSpecifies the main world of the DOM, which is the execution environment shared with the host page's JavaScript.\nInjectionResult\nProperties\n-\ndocumentId\nstring\nChrome 106+The document associated with the injection.\n-\nframeId\nnumber\nChrome 90+The frame associated with the injection.\n-\nresult\nany optional\nThe result of the script execution.\nInjectionTarget\nProperties\n-\nallFrames\nboolean optional\nWhether the script should inject into all frames within the tab. Defaults to false. This must not be true if\nframeIds\nis specified. -\ndocumentIds\nstring[] optional\nChrome 106+The IDs of specific documentIds to inject into. This must not be set if\nframeIds\nis set. -\nframeIds\nnumber[] optional\nThe IDs of specific frames to inject into.\n-\ntabId\nnumber\nThe ID of the tab into which to inject.\nRegisteredContentScript\nProperties\n-\nallFrames\nboolean optional\nIf specified true, it will inject into all frames, even if the frame is not the top-most frame in the tab. Each frame is checked independently for URL requirements; it will not inject into child frames if the URL requirements are not met. Defaults to false, meaning that only the top frame is matched.\n-\ncss\nstring[] optional\nThe list of CSS files to be injected into matching pages. These are injected in the order they appear in this array, before any DOM is constructed or displayed for the page.\n-\nexcludeMatches\nstring[] optional\nExcludes pages that this content script would otherwise be injected into. See Match Patterns for more details on the syntax of these strings.\n-\nid\nstring\nThe id of the content script, specified in the API call. Must not start with a '_' as it's reserved as a prefix for generated script IDs.\n-\njs\nstring[] optional\nThe list of JavaScript files to be injected into matching pages. These are injected in the order they appear in this array.\n-\nmatchOriginAsFallback\nboolean optional\nChrome 119+Indicates whether the script can be injected into frames where the URL contains an unsupported scheme; specifically: about:, data:, blob:, or filesystem:. In these cases, the URL's origin is checked to determine if the script should be injected. If the origin is\nnull\n(as is the case for data: URLs) then the used origin is either the frame that created the current frame or the frame that initiated the navigation to this frame. Note that this may not be the parent frame. -\nmatches\nstring[] optional\nSpecifies which pages this content script will be injected into. See Match Patterns for more details on the syntax of these strings. Must be specified for\nregisterContentScripts\n. -\npersistAcrossSessions\nboolean optional\nSpecifies if this content script will persist into future sessions. The default is true.\n-\nrunAt\nRunAt optional\nSpecifies when JavaScript files are injected into the web page. The preferred and default value is\ndocument_idle\n. -\nworld\nExecutionWorld optional\nChrome 102+The JavaScript \"world\" to run the script in. Defaults to\nISOLATED\n.\nScriptInjection\nProperties\n-\nargs\nany[] optional\nChrome 92+The arguments to pass to the provided function. This is only valid if the\nfunc\nparameter is specified. These arguments must be JSON-serializable. -\nfiles\nstring[] optional\nThe path of the JS or CSS files to inject, relative to the extension's root directory. Exactly one of\nfiles\norfunc\nmust be specified. -\ninjectImmediately\nboolean optional\nChrome 102+Whether the injection should be triggered in the target as soon as possible. Note that this is not a guarantee that injection will occur prior to page load, as the page may have already loaded by the time the script reaches the target.\n-\ntarget\nDetails specifying the target into which to inject the script.\n-\nworld\nExecutionWorld optional\nChrome 95+The JavaScript \"world\" to run the script in. Defaults to\nISOLATED\n. -\nfunc\nvoid optional\nChrome 92+A JavaScript function to inject. This function will be serialized, and then deserialized for injection. This means that any bound parameters and execution context will be lost. Exactly one of\nfiles\norfunc\nmust be specified.The\nfunc\nfunction looks like:() => {...}\nStyleOrigin\nThe origin for a style change. See style origins for more info.\nEnum\n\"AUTHOR\" \"USER\"\nMethods\nexecuteScript()\nchrome.scripting.executeScript(\ninjection: ScriptInjection,\ncallback?: function,\n)\nInjects a script into a target context. By default, the script will be run at document_idle\n, or immediately if the page has already loaded. If the injectImmediately\nproperty is set, the script will inject without waiting, even if the page has not finished loading. If the script evaluates to a promise, the browser will wait for the promise to settle and return the resulting value.\nParameters\n-\ninjection\nThe details of the script which to inject.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(results: InjectionResult[]) => void\n-\nresults\n-\nReturns\n-\nPromise<InjectionResult[]>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetRegisteredContentScripts()\nchrome.scripting.getRegisteredContentScripts(\nfilter?: ContentScriptFilter,\ncallback?: function,\n)\nReturns all dynamically registered content scripts for this extension that match the given filter.\nParameters\n-\nfilter\nContentScriptFilter optional\nAn object to filter the extension's dynamically registered scripts.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(scripts: RegisteredContentScript[]) => void\n-\nscripts\n-\nReturns\n-\nPromise<RegisteredContentScript[]>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ninsertCSS()\nchrome.scripting.insertCSS(\ninjection: CSSInjection,\ncallback?: function,\n)\nInserts a CSS stylesheet into a target context. If multiple frames are specified, unsuccessful injections are ignored.\nParameters\n-\ninjection\nThe details of the styles to insert.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nregisterContentScripts()\nchrome.scripting.registerContentScripts(\nscripts: RegisteredContentScript[],\ncallback?: function,\n)\nRegisters one or more content scripts for this extension.\nParameters\n-\nscripts\nContains a list of scripts to be registered. If there are errors during script parsing/file validation, or if the IDs specified already exist, then no scripts are registered.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremoveCSS()\nchrome.scripting.removeCSS(\ninjection: CSSInjection,\ncallback?: function,\n)\nRemoves a CSS stylesheet that was previously inserted by this extension from a target context.\nParameters\n-\ninjection\nThe details of the styles to remove. Note that the\ncss\n,files\n, andorigin\nproperties must exactly match the stylesheet inserted throughinsertCSS\n. Attempting to remove a non-existent stylesheet is a no-op. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nunregisterContentScripts()\nchrome.scripting.unregisterContentScripts(\nfilter?: ContentScriptFilter,\ncallback?: function,\n)\nUnregisters content scripts for this extension.\nParameters\n-\nfilter\nContentScriptFilter optional\nIf specified, only unregisters dynamic content scripts which match the filter. Otherwise, all of the extension's dynamic content scripts are unregistered.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdateContentScripts()\nchrome.scripting.updateContentScripts(\nscripts: RegisteredContentScript[],\ncallback?: function,\n)\nUpdates one or more content scripts for this extension.\nParameters\n-\nscripts\nContains a list of scripts to be updated. A property is only updated for the existing script if it is specified in this object. If there are errors during script parsing/file validation, or if the IDs specified do not correspond to a fully registered script, then no scripts are updated.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/sessions", "title": "chrome.sessions | API | Chrome for Developers", "text": "Description\nUse the chrome.sessions\nAPI to query and restore tabs and windows from a browsing session.\nPermissions\nsessions\nTypes\nDevice\nProperties\n-\ndeviceName\nstring\nThe name of the foreign device.\n-\nsessions\nSession[]\nA list of open window sessions for the foreign device, sorted from most recently to least recently modified session.\nFilter\nProperties\n-\nmaxResults\nnumber optional\nThe maximum number of entries to be fetched in the requested list. Omit this parameter to fetch the maximum number of entries (\nsessions.MAX_SESSION_RESULTS\n).\nSession\nProperties\n-\nlastModified\nnumber\nThe time when the window or tab was closed or modified, represented in milliseconds since the epoch.\n-\ntab\nTab optional\nThe\ntabs.Tab\n, if this entry describes a tab. Either this orsessions.Session.window\nwill be set. -\nwindow\nWindow optional\nThe\nwindows.Window\n, if this entry describes a window. Either this orsessions.Session.tab\nwill be set.\nProperties\nMAX_SESSION_RESULTS\nThe maximum number of sessions.Session\nthat will be included in a requested list.\nValue\n25\nMethods\ngetDevices()\nchrome.sessions.getDevices(\nfilter?: Filter,\ncallback?: function,\n)\nRetrieves all devices with synced sessions.\nParameters\n-\nfilter\nFilter optional\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(devices: Device[]) => void\n-\ndevices\nDevice[]\nThe list of\nsessions.Device\nobjects for each synced session, sorted in order from device with most recently modified session to device with least recently modified session.tabs.Tab\nobjects are sorted by recency in thewindows.Window\nof thesessions.Session\nobjects.\n-\nReturns\n-\nPromise<Device[]>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetRecentlyClosed()\nchrome.sessions.getRecentlyClosed(\nfilter?: Filter,\ncallback?: function,\n)\nGets the list of recently closed tabs and/or windows.\nParameters\n-\nfilter\nFilter optional\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(sessions: Session[]) => void\n-\nsessions\nSession[]\nThe list of closed entries in reverse order that they were closed (the most recently closed tab or window will be at index\n0\n). The entries may contain either tabs or windows.\n-\nReturns\n-\nPromise<Session[]>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nrestore()\nchrome.sessions.restore(\nsessionId?: string,\ncallback?: function,\n)\nReopens a windows.Window\nor tabs.Tab\n, with an optional callback to run when the entry has been restored.\nParameters\n-\nsessionId\nstring optional\nThe\nwindows.Window.sessionId\n, ortabs.Tab.sessionId\nto restore. If this parameter is not specified, the most recently closed session is restored. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(restoredSession: Session) => void\n-\nrestoredSession\nA\nsessions.Session\ncontaining the restoredwindows.Window\nortabs.Tab\nobject.\n-\nReturns\n-\nPromise<Session>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonChanged\nchrome.sessions.onChanged.addListener(\ncallback: function,\n)\nFired when recently closed tabs and/or windows are changed. This event does not monitor synced sessions changes.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/storage", "title": "chrome.storage | API | Chrome for Developers", "text": "Description\nUse the chrome.storage\nAPI to store, retrieve, and track changes to user data.\nPermissions\nstorage\nTo use the storage API, declare the \"storage\"\npermission in the extension\nmanifest. For example:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"storage\"\n],\n...\n}\nConcepts and usage\nThe Storage API provides an extension-specific way to persist user data and state. It's similar to the web platform's storage APIs (IndexedDB, and Storage), but was designed to meet the storage needs of extensions. The following are a few key features:\n- All extension contexts, including the extension service worker and content scripts have access to the Storage API.\n- The JSON serializable values are stored as object properties.\n- The Storage API is asynchronous with bulk read and write operations.\n- Even if the user clears the cache and browsing history, the data persists.\n- Stored settings persist even when using split incognito.\n- Includes an exclusive read-only managed storage area for enterprise policies.\nCan extensions use web storage APIs?\nWhile extensions can use the Storage\ninterface (accessible from window.localStorage\n) in some contexts (popup and other HTML pages), we don't recommend it for the following reasons:\n- Extension service workers can't use the Web Storage API.\n- Content scripts share storage with the host page.\n- Data saved using the Web Storage API is lost when the user clears their browsing history.\nTo move data from web storage APIs to extension storage APIs from a service worker:\n- Prepare an offscreen document html page and script file. The script file should contain a conversion routine and an\nonMessage\nhandler. - In the extension service worker, check\nchrome.storage\nfor your data. - If your data isn't found, call\ncreateDocument()\n. - After the returned Promise resolves, call\nsendMessage()\nto start the conversion routine. - Inside the offscreen document's\nonMessage\nhandler, call the conversion routine.\nThere are also some nuances to how web storage APIs work in extensions. Learn more in the Storage and Cookies article.\nStorage areas\nThe Storage API is divided into the following storage areas:\nstorage.local\n- Data is stored locally and cleared when the extension is removed. The storage limit is 10 MB (5 MB in Chrome 113 and earlier), but can be increased by requesting the\n\"unlimitedStorage\"\npermission. We recommend usingstorage.local\nto store larger amounts of data. storage.managed\n- Managed storage is read-only storage for policy installed extensions and managed by system administrators using a developer-defined schema and enterprise policies. Policies are analogous to options but are configured by a system administrator instead of the user, allowing the extension to be preconfigured for all users of an organization. For information on policies, see Documentation for Administrators. To learn more about the\nmanaged\nstorage area, see Manifest for storage areas. storage.session\n- Holds data in memory for the duration of a browser session. By default, it's not exposed to content scripts, but this behavior can be changed by setting\nchrome.storage.session.setAccessLevel()\n. The storage limit is 10 MB (1 MB in Chrome 111 and earlier). Thestorage.session\ninterface is one of several we recommend for service workers. storage.sync\n- If syncing is enabled, the data is synced to any Chrome browser that the user is logged into. If disabled, it behaves like\nstorage.local\n. Chrome stores the data locally when the browser is offline and resumes syncing when it's back online. The quota limitation is approximately 100 KB, 8 KB per item. We recommend usingstorage.sync\nto preserve user settings across synced browsers. If you're working with sensitive user data, instead usestorage.session\n.\nStorage and throttling limits\nThe Storage API has the following usage limitations:\n- Storing data often comes with performance costs, and the API includes storage quotas. We recommend being careful about what data you store so that you don't lose the ability to store data.\n- Storage can take time to complete. Make sure to structure your code to account for that time.\nFor details on storage area limitations and what happens when they're exceeded, see the quota information for sync\n, local\n, and session\n.\nUse cases\nThe following sections demonstrate common use cases for the Storage API.\nSynchronous response to storage updates\nTo track changes made to storage, add a listener to its onChanged\nevent. When anything changes in storage, that event fires. The sample code listens for these changes:\nbackground.js:\nchrome.storage.onChanged.addListener((changes, namespace) => {\nfor (let [key, { oldValue, newValue }] of Object.entries(changes)) {\nconsole.log(\n`Storage key \"${key}\" in namespace \"${namespace}\" changed.`,\n`Old value was \"${oldValue}\", new value is \"${newValue}\".`\n);\n}\n});\nWe can take this idea even further. In this example, we have an options page that\nallows the user to toggle a \"debug mode\" (implementation not shown here). The options page immediately saves the new settings to storage.sync\n, and the service worker uses storage.onChanged\nto apply the setting as soon as possible.\noptions.html:\n<!-- type=\"module\" allows you to use top level await -->\n<script defer src=\"options.js\" type=\"module\"></script>\n<form id=\"optionsForm\">\n<label for=\"debug\">\n<input type=\"checkbox\" name=\"debug\" id=\"debug\">\nEnable debug mode\n</label>\n</form>\noptions.js:\n// In-page cache of the user's options\nconst options = {};\nconst optionsForm = document.getElementById(\"optionsForm\");\n// Immediately persist options changes\noptionsForm.debug.addEventListener(\"change\", (event) => {\noptions.debug = event.target.checked;\nchrome.storage.sync.set({ options });\n});\n// Initialize the form with the user's option settings\nconst data = await chrome.storage.sync.get(\"options\");\nObject.assign(options, data.options);\noptionsForm.debug.checked = Boolean(options.debug);\nbackground.js:\nfunction setDebugMode() { /* ... */ }\n// Watch for changes to the user's options & apply them\nchrome.storage.onChanged.addListener((changes, area) => {\nif (area === 'sync' && changes.options?.newValue) {\nconst debugMode = Boolean(changes.options.newValue.debug);\nconsole.log('enable debug mode?', debugMode);\nsetDebugMode(debugMode);\n}\n});\nAsynchronous preload from storage\nBecause service workers don't run all the time, Manifest V3 extensions sometimes need to\nasynchronously load data from storage before they execute their event handlers. To do this, the\nfollowing snippet uses an async action.onClicked\nevent handler that waits for the storageCache\nglobal to be populated before executing its logic.\nbackground.js:\n// Where we will expose all the data we retrieve from storage.sync.\nconst storageCache = { count: 0 };\n// Asynchronously retrieve data from storage.sync, then cache it.\nconst initStorageCache = chrome.storage.sync.get().then((items) => {\n// Copy the data retrieved from storage into storageCache.\nObject.assign(storageCache, items);\n});\nchrome.action.onClicked.addListener(async (tab) => {\ntry {\nawait initStorageCache;\n} catch (e) {\n// Handle error that occurred during storage initialization.\n}\n// Normal action handler logic.\nstorageCache.count++;\nstorageCache.lastTabId = tab.id;\nchrome.storage.sync.set(storageCache);\n});\nExamples\nThe following samples demonstrate the local\n, sync\n, and\nsession\nstorage areas:\nLocal\nchrome.storage.local.set({ key: value }).then(() => {\nconsole.log(\"Value is set\");\n});\nchrome.storage.local.get([\"key\"]).then((result) => {\nconsole.log(\"Value is \" + result.key);\n});\nSync\nchrome.storage.sync.set({ key: value }).then(() => {\nconsole.log(\"Value is set\");\n});\nchrome.storage.sync.get([\"key\"]).then((result) => {\nconsole.log(\"Value is \" + result.key);\n});\nSession\nchrome.storage.session.set({ key: value }).then(() => {\nconsole.log(\"Value was set\");\n});\nchrome.storage.session.get([\"key\"]).then((result) => {\nconsole.log(\"Value is \" + result.key);\n});\nTo see other demos of the Storage API, explore any of the following samples:\nTypes\nAccessLevel\nThe storage area's access level.\nEnum\n\"TRUSTED_CONTEXTS\" \"TRUSTED_AND_UNTRUSTED_CONTEXTS\"\nSpecifies contexts originating from the extension itself.\nSpecifies contexts originating from outside the extension.\nStorageArea\nProperties\n-\nonChanged\nEvent<functionvoidvoid>\nChrome 73+Fired when one or more items change.\nThe\nonChanged.addListener\nfunction looks like:(callback: function) => {...}\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(changes: object) => void\n-\nchanges\nobject\n-\n-\n-\nclear\nvoid\nPromiseRemoves all items from storage.\nThe\nclear\nfunction looks like:(callback?: function) => {...}\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\n-\nreturns\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\nget\nvoid\nPromiseGets one or more items from storage.\nThe\nget\nfunction looks like:(keys?: string | string[] | object, callback?: function) => {...}\n-\nkeys\nstring | string[] | object optional\nA single key to get, list of keys to get, or a dictionary specifying default values (see description of the object). An empty list or object will return an empty result object. Pass in\nnull\nto get the entire contents of storage. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(items: object) => void\n-\nitems\nobject\nObject with items in their key-value mappings.\n-\n-\nreturns\nPromise<object>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\ngetBytesInUse\nvoid\nPromiseGets the amount of space (in bytes) being used by one or more items.\nThe\ngetBytesInUse\nfunction looks like:(keys?: string | string[], callback?: function) => {...}\n-\nkeys\nstring | string[] optional\nA single key or list of keys to get the total usage for. An empty list will return 0. Pass in\nnull\nto get the total usage of all of storage. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(bytesInUse: number) => void\n-\nbytesInUse\nnumber\nAmount of space being used in storage, in bytes.\n-\n-\nreturns\nPromise<number>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\ngetKeys\nvoid\nPromise Chrome 130+Gets all keys from storage.\nThe\ngetKeys\nfunction looks like:(callback?: function) => {...}\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(keys: string[]) => void\n-\nkeys\nstring[]\nArray with keys read from storage.\n-\n-\nreturns\nPromise<string[]>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\nremove\nvoid\nPromiseRemoves one or more items from storage.\nThe\nremove\nfunction looks like:(keys: string | string[], callback?: function) => {...}\n-\nkeys\nstring | string[]\nA single key or a list of keys for items to remove.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\n-\nreturns\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\nset\nvoid\nPromiseSets multiple items.\nThe\nset\nfunction looks like:(items: object, callback?: function) => {...}\n-\nitems\nobject\nAn object which gives each key/value pair to update storage with. Any other key/value pairs in storage will not be affected.\nPrimitive values such as numbers will serialize as expected. Values with a\ntypeof\n\"object\"\nand\"function\"\nwill typically serialize to{}\n, with the exception ofArray\n(serializes as expected),Date\n, andRegex\n(serialize using theirString\nrepresentation). -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\n-\nreturns\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\nsetAccessLevel\nvoid\nPromise Chrome 102+Sets the desired access level for the storage area. The default will be only trusted contexts.\nThe\nsetAccessLevel\nfunction looks like:(accessOptions: object, callback?: function) => {...}\n-\naccessOptions\nobject\n-\naccessLevel\nThe access level of the storage area.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\n-\nreturns\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\nStorageChange\nProperties\n-\nnewValue\nany optional\nThe new value of the item, if there is a new value.\n-\noldValue\nany optional\nThe old value of the item, if there was an old value.\nProperties\nlocal\nItems in the local\nstorage area are local to each machine.\nType\nStorageArea & object\nProperties\n-\nQUOTA_BYTES\n10485760\nThe maximum amount (in bytes) of data that can be stored in local storage, as measured by the JSON stringification of every value plus every key's length. This value will be ignored if the extension has the\nunlimitedStorage\npermission. Updates that would cause this limit to be exceeded fail immediately and setruntime.lastError\nwhen using a callback, or a rejected Promise if using async/await.\nmanaged\nItems in the managed\nstorage area are set by an enterprise policy configured by the domain administrator, and are read-only for the extension; trying to modify this namespace results in an error. For information on configuring a policy, see Manifest for storage areas.\nType\nsession\nItems in the session\nstorage area are stored in-memory and will not be persisted to disk.\nType\nStorageArea & object\nProperties\n-\nQUOTA_BYTES\n10485760\nThe maximum amount (in bytes) of data that can be stored in memory, as measured by estimating the dynamically allocated memory usage of every value and key. Updates that would cause this limit to be exceeded fail immediately and set\nruntime.lastError\nwhen using a callback, or when a Promise is rejected.\nsync\nItems in the sync\nstorage area are synced using Chrome Sync.\nType\nStorageArea & object\nProperties\n-\nMAX_ITEMS\n512\nThe maximum number of items that can be stored in sync storage. Updates that would cause this limit to be exceeded will fail immediately and set\nruntime.lastError\nwhen using a callback, or when a Promise is rejected. -\nMAX_SUSTAINED_WRITE_OPERATIONS_PER_MINUTE\n1000000\nDeprecatedThe storage.sync API no longer has a sustained write operation quota.\n-\nMAX_WRITE_OPERATIONS_PER_HOUR\n1800\nThe maximum number of\nset\n,remove\n, orclear\noperations that can be performed each hour. This is 1 every 2 seconds, a lower ceiling than the short term higher writes-per-minute limit.Updates that would cause this limit to be exceeded fail immediately and set\nruntime.lastError\nwhen using a callback, or when a Promise is rejected. -\nMAX_WRITE_OPERATIONS_PER_MINUTE\n120\nThe maximum number of\nset\n,remove\n, orclear\noperations that can be performed each minute. This is 2 per second, providing higher throughput than writes-per-hour over a shorter period of time.Updates that would cause this limit to be exceeded fail immediately and set\nruntime.lastError\nwhen using a callback, or when a Promise is rejected. -\nQUOTA_BYTES\n102400\nThe maximum total amount (in bytes) of data that can be stored in sync storage, as measured by the JSON stringification of every value plus every key's length. Updates that would cause this limit to be exceeded fail immediately and set\nruntime.lastError\nwhen using a callback, or when a Promise is rejected. -\nQUOTA_BYTES_PER_ITEM\n8192\nThe maximum size (in bytes) of each individual item in sync storage, as measured by the JSON stringification of its value plus its key length. Updates containing items larger than this limit will fail immediately and set\nruntime.lastError\nwhen using a callback, or when a Promise is rejected.\nEvents\nonChanged\nchrome.storage.onChanged.addListener(\ncallback: function,\n)\nFired when one or more items change.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(changes: object, areaName: string) => void\n-\nchanges\nobject\n-\nareaName\nstring\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/tabGroups", "title": "chrome.tabGroups | API | Chrome for Developers", "text": "Description\nUse the chrome.tabGroups\nAPI to interact with the browser's tab grouping system. You can use this API to modify and rearrange tab groups in the browser. To group and ungroup tabs, or to query what tabs are in groups, use the chrome.tabs\nAPI.\nPermissions\ntabGroups\nAvailability\nTypes\nColor\nThe group's color.\nEnum\n\"grey\" \"blue\" \"red\" \"yellow\" \"green\" \"pink\" \"purple\" \"cyan\" \"orange\"\nTabGroup\nProperties\n-\ncollapsed\nboolean\nWhether the group is collapsed. A collapsed group is one whose tabs are hidden.\n-\ncolor\nThe group's color.\n-\nid\nnumber\nThe ID of the group. Group IDs are unique within a browser session.\n-\ntitle\nstring optional\nThe title of the group.\n-\nwindowId\nnumber\nThe ID of the window that contains the group.\nProperties\nTAB_GROUP_ID_NONE\nAn ID that represents the absence of a group.\nValue\n-1\nMethods\nget()\nchrome.tabGroups.get(\ngroupId: number,\ncallback?: function,\n)\nRetrieves details about the specified group.\nParameters\n-\ngroupId\nnumber\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(group: TabGroup) => void\n-\ngroup\n-\nReturns\n-\nPromise<TabGroup>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nmove()\nchrome.tabGroups.move(\ngroupId: number,\nmoveProperties: object,\ncallback?: function,\n)\nMoves the group and all its tabs within its window, or to a new window.\nParameters\n-\ngroupId\nnumber\nThe ID of the group to move.\n-\nmoveProperties\nobject\n-\nindex\nnumber\nThe position to move the group to. Use\n-1\nto place the group at the end of the window. -\nwindowId\nnumber optional\nThe window to move the group to. Defaults to the window the group is currently in. Note that groups can only be moved to and from windows with\nwindows.WindowType\ntype\"normal\"\n.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(group?: TabGroup) => void\n-\ngroup\nTabGroup optional\nDetails about the moved group.\n-\nReturns\n-\nPromise<TabGroup | undefined>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nquery()\nchrome.tabGroups.query(\nqueryInfo: object,\ncallback?: function,\n)\nGets all groups that have the specified properties, or all groups if no properties are specified.\nParameters\n-\nqueryInfo\nobject\n-\ncollapsed\nboolean optional\nWhether the groups are collapsed.\n-\ncolor\nColor optional\nThe color of the groups.\n-\ntitle\nstring optional\nMatch group titles against a pattern.\n-\nwindowId\nnumber optional\nThe ID of the parent window, or\nwindows.WINDOW_ID_CURRENT\nfor the current window.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: TabGroup[]) => void\n-\nresult\nTabGroup[]\n-\nReturns\n-\nPromise<TabGroup[]>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdate()\nchrome.tabGroups.update(\ngroupId: number,\nupdateProperties: object,\ncallback?: function,\n)\nModifies the properties of a group. Properties that are not specified in updateProperties\nare not modified.\nParameters\n-\ngroupId\nnumber\nThe ID of the group to modify.\n-\nupdateProperties\nobject\n-\ncollapsed\nboolean optional\nWhether the group should be collapsed.\n-\ncolor\nColor optional\nThe color of the group.\n-\ntitle\nstring optional\nThe title of the group.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(group?: TabGroup) => void\n-\ngroup\nTabGroup optional\nDetails about the updated group.\n-\nReturns\n-\nPromise<TabGroup | undefined>\nChrome 90+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonCreated\nchrome.tabGroups.onCreated.addListener(\ncallback: function,\n)\nFired when a group is created.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(group: TabGroup) => void\n-\ngroup\n-\nonMoved\nchrome.tabGroups.onMoved.addListener(\ncallback: function,\n)\nFired when a group is moved within a window. Move events are still fired for the individual tabs within the group, as well as for the group itself. This event is not fired when a group is moved between windows; instead, it will be removed from one window and created in another.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(group: TabGroup) => void\n-\ngroup\n-\nonRemoved\nchrome.tabGroups.onRemoved.addListener(\ncallback: function,\n)\nFired when a group is closed, either directly by the user or automatically because it contained zero tabs.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(group: TabGroup) => void\n-\ngroup\n-\nonUpdated\nchrome.tabGroups.onUpdated.addListener(\ncallback: function,\n)\nFired when a group is updated."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/tabs", "title": "chrome.tabs | API | Chrome for Developers", "text": "Description\nUse the chrome.tabs\nAPI to interact with the browser's tab system. You can use this API to create, modify, and rearrange tabs in the browser.\nThe Tabs API not only offers features for manipulating and managing tabs, but can also detect the language of the tab, take a screenshot, and communicate with a tab's content scripts.\nPermissions\nMost features don't require any permissions to use. For example: creating a new tab, reloading a tab, navigating to another URL, etc.\nThere are three permissions developers should be aware of when working with the Tabs API.\n- The \"tabs\" permission\nThis permission does not give access to the\nchrome.tabs\nnamespace. Instead, it grants an extension the ability to calltabs.query()\nagainst four sensitive properties ontabs.Tab\ninstances:url\n,pendingUrl\n,title\n, andfavIconUrl\n.{ \"name\": \"My extension\", ... \"permissions\": [ \"tabs\" ], ... }\n- Host permissions\nHost permissions allow an extension to read and query a matching tab's four sensitive\ntabs.Tab\nproperties. They can also interact directly with the matching tabs using methods such astabs.captureVisibleTab()\n,tabs.executeScript()\n,tabs.insertCSS()\n, andtabs.removeCSS()\n.{ \"name\": \"My extension\", ... \"host_permissions\": [ \"http://*/*\", \"https://*/*\" ], ... }\n- The \"activeTab\" permission\nactiveTab\ngrants an extension temporary host permission for the current tab in response to a user invocation. Unlike host permissions,activeTab\ndoes not trigger any warnings.{ \"name\": \"My extension\", ... \"permissions\": [ \"activeTab\" ], ... }\nUse cases\nThe following sections demonstrate some common use cases.\nOpen an extension page in a new tab\nA common pattern for extensions is to open an onboarding page in a new tab when the extension is installed. The following example shows how to do this.\nbackground.js:\nchrome.runtime.onInstalled.addListener(({reason}) => {\nif (reason === 'install') {\nchrome.tabs.create({\nurl: \"onboarding.html\"\n});\n}\n});\nGet the current tab\nThis example demonstrates how an extension's service worker can retrieve the active tab from the currently-focused window (or most recently-focused window, if no Chrome windows are focused). This can usually be thought of as the user's current tab.\nasync function getCurrentTab() {\nlet queryOptions = { active: true, lastFocusedWindow: true };\n// `tab` will either be a `tabs.Tab` instance or `undefined`.\nlet [tab] = await chrome.tabs.query(queryOptions);\nreturn tab;\n}\nfunction getCurrentTab(callback) {\nlet queryOptions = { active: true, lastFocusedWindow: true };\nchrome.tabs.query(queryOptions, ([tab]) => {\nif (chrome.runtime.lastError)\nconsole.error(chrome.runtime.lastError);\n// `tab` will either be a `tabs.Tab` instance or `undefined`.\ncallback(tab);\n});\n}\nMute the specified tab\nThis example shows how an extension can toggle the muted state for a given tab.\nasync function toggleMuteState(tabId) {\nconst tab = await chrome.tabs.get(tabId);\nconst muted = !tab.mutedInfo.muted;\nawait chrome.tabs.update(tabId, {muted});\nconsole.log(`Tab ${tab.id} is ${muted ? \"muted\" : \"unmuted\"}`);\n}\nfunction toggleMuteState(tabId) {\nchrome.tabs.get(tabId, async (tab) => {\nlet muted = !tab.mutedInfo.muted;\nawait chrome.tabs.update(tabId, { muted });\nconsole.log(`Tab ${tab.id} is ${ muted ? \"muted\" : \"unmuted\" }`);\n});\n}\nMove the current tab to the first position when clicked\nThis example shows how to move a tab while a drag may or may not be in progress. While this example\nuses chrome.tabs.move\n, you can use the same waiting pattern for other calls that modify tabs while\na drag is in progress.\nchrome.tabs.onActivated.addListener(moveToFirstPosition);\nasync function moveToFirstPosition(activeInfo) {\ntry {\nawait chrome.tabs.move(activeInfo.tabId, {index: 0});\nconsole.log(\"Success.\");\n} catch (error) {\nif (error == \"Error: Tabs cannot be edited right now (user may be dragging a tab).\") {\nsetTimeout(() => moveToFirstPosition(activeInfo), 50);\n} else {\nconsole.error(error);\n}\n}\n}\nchrome.tabs.onActivated.addListener(moveToFirstPositionMV2);\nfunction moveToFirstPositionMV2(activeInfo) {\nchrome.tabs.move(activeInfo.tabId, { index: 0 }, () => {\nif (chrome.runtime.lastError) {\nconst error = chrome.runtime.lastError;\nif (error == \"Error: Tabs cannot be edited right now (user may be dragging a tab).\") {\nsetTimeout(() => moveToFirstPositionMV2(activeInfo), 50);\n} else {\nconsole.error(error);\n}\n} else {\nconsole.log(\"Success.\");\n}\n});\n}\nPass a message to a selected tab's content script\nThis example demonstrates how an extension's service worker can communicate with content scripts in specific browser tabs using tabs.sendMessage()\n.\nfunction sendMessageToActiveTab(message) {\nconst [tab] = await chrome.tabs.query({ active: true, lastFocusedWindow: true });\nconst response = await chrome.tabs.sendMessage(tab.id, message);\n// TODO: Do something with the response.\n}\nExtension examples\nFor more Tabs API extensions demos, explore any of the following:\nTypes\nMutedInfo\nThe tab's muted state and the reason for the last state change.\nProperties\n-\nextensionId\nstring optional\nThe ID of the extension that changed the muted state. Not set if an extension was not the reason the muted state last changed.\n-\nmuted\nboolean\nWhether the tab is muted (prevented from playing sound). The tab may be muted even if it has not played or is not currently playing sound. Equivalent to whether the 'muted' audio indicator is showing.\n-\nreason\nMutedInfoReason optional\nThe reason the tab was muted or unmuted. Not set if the tab's mute state has never been changed.\nMutedInfoReason\nAn event that caused a muted state change.\nEnum\n\"user\" \"capture\" \"extension\"\nA user input action set the muted state.\nTab capture was started, forcing a muted state change.\nAn extension, identified by the extensionId field, set the muted state.\nTab\nProperties\n-\nactive\nboolean\nWhether the tab is active in its window. Does not necessarily mean the window is focused.\n-\naudible\nboolean optional\nChrome 45+Whether the tab has produced sound over the past couple of seconds (but it might not be heard if also muted). Equivalent to whether the 'speaker audio' indicator is showing.\n-\nautoDiscardable\nboolean\nChrome 54+Whether the tab can be discarded automatically by the browser when resources are low.\n-\ndiscarded\nboolean\nChrome 54+Whether the tab is discarded. A discarded tab is one whose content has been unloaded from memory, but is still visible in the tab strip. Its content is reloaded the next time it is activated.\n-\nfavIconUrl\nstring optional\nThe URL of the tab's favicon. This property is only present if the extension's manifest includes the\n\"tabs\"\npermission. It may also be an empty string if the tab is loading. -\nfrozen\nboolean\nPendingWhether the tab is frozen. A frozen tab cannot execute tasks, including event handlers or timers. It is visible in the tab strip and its content is loaded in memory. It is unfrozen on activation.\n-\ngroupId\nnumber\nChrome 88+The ID of the group that the tab belongs to.\n-\nheight\nnumber optional\nThe height of the tab in pixels.\n-\nhighlighted\nboolean\nWhether the tab is highlighted.\n-\nid\nnumber optional\nThe ID of the tab. Tab IDs are unique within a browser session. Under some circumstances a tab may not be assigned an ID; for example, when querying foreign tabs using the\nsessions\nAPI, in which case a session ID may be present. Tab ID can also be set tochrome.tabs.TAB_ID_NONE\nfor apps and devtools windows. -\nincognito\nboolean\nWhether the tab is in an incognito window.\n-\nindex\nnumber\nThe zero-based index of the tab within its window.\n-\nlastAccessed\nnumber\nChrome 121+The last time the tab was accessed as the number of milliseconds since epoch.\n-\nmutedInfo\nMutedInfo optional\nChrome 46+The tab's muted state and the reason for the last state change.\n-\nopenerTabId\nnumber optional\nThe ID of the tab that opened this tab, if any. This property is only present if the opener tab still exists.\n-\npendingUrl\nstring optional\nChrome 79+The URL the tab is navigating to, before it has committed. This property is only present if the extension's manifest includes the\n\"tabs\"\npermission and there is a pending navigation. -\npinned\nboolean\nWhether the tab is pinned.\n-\nselected\nboolean\nDeprecatedPlease use\ntabs.Tab.highlighted\n.Whether the tab is selected.\n-\nsessionId\nstring optional\nThe session ID used to uniquely identify a tab obtained from the\nsessions\nAPI. -\nstatus\nTabStatus optional\nThe tab's loading status.\n-\ntitle\nstring optional\nThe title of the tab. This property is only present if the extension's manifest includes the\n\"tabs\"\npermission. -\nurl\nstring optional\nThe last committed URL of the main frame of the tab. This property is only present if the extension's manifest includes the\n\"tabs\"\npermission and may be an empty string if the tab has not yet committed. See alsoTab.pendingUrl\n. -\nwidth\nnumber optional\nThe width of the tab in pixels.\n-\nwindowId\nnumber\nThe ID of the window that contains the tab.\nTabStatus\nThe tab's loading status.\nEnum\n\"unloaded\" \"loading\" \"complete\"\nWindowType\nThe type of window.\nEnum\n\"normal\" \"popup\" \"panel\" \"app\" \"devtools\"\nZoomSettings\nDefines how zoom changes in a tab are handled and at what scope.\nProperties\n-\ndefaultZoomFactor\nnumber optional\nChrome 43+Used to return the default zoom level for the current tab in calls to tabs.getZoomSettings.\n-\nmode\nZoomSettingsMode optional\nDefines how zoom changes are handled, i.e., which entity is responsible for the actual scaling of the page; defaults to\nautomatic\n. -\nscope\nZoomSettingsScope optional\nDefines whether zoom changes persist for the page's origin, or only take effect in this tab; defaults to\nper-origin\nwhen inautomatic\nmode, andper-tab\notherwise.\nZoomSettingsMode\nDefines how zoom changes are handled, i.e., which entity is responsible for the actual scaling of the page; defaults to automatic\n.\nEnum\n\"automatic\" \"manual\" \"disabled\"\nZoom changes are handled automatically by the browser.\nOverrides the automatic handling of zoom changes. The onZoomChange\nevent will still be dispatched, and it is the extension's responsibility to listen for this event and manually scale the page. This mode does not support per-origin\nzooming, and thus ignores the scope\nzoom setting and assumes per-tab\n.\nDisables all zooming in the tab. The tab reverts to the default zoom level, and all attempted zoom changes are ignored.\nZoomSettingsScope\nDefines whether zoom changes persist for the page's origin, or only take effect in this tab; defaults to per-origin\nwhen in automatic\nmode, and per-tab\notherwise.\nEnum\n\"per-origin\" \"per-tab\"\nZoom changes persist in the zoomed page's origin, i.e., all other tabs navigated to that same origin are zoomed as well. Moreover, per-origin\nzoom changes are saved with the origin, meaning that when navigating to other pages in the same origin, they are all zoomed to the same zoom factor. The per-origin\nscope is only available in the automatic\nmode.\nZoom changes only take effect in this tab, and zoom changes in other tabs do not affect the zooming of this tab. Also, per-tab\nzoom changes are reset on navigation; navigating a tab always loads pages with their per-origin\nzoom factors.\nProperties\nMAX_CAPTURE_VISIBLE_TAB_CALLS_PER_SECOND\nThe maximum number of times that captureVisibleTab\ncan be called per second. captureVisibleTab\nis expensive and should not be called too often.\nValue\n2\nTAB_ID_NONE\nAn ID that represents the absence of a browser tab.\nValue\n-1\nTAB_INDEX_NONE\nAn index that represents the absence of a tab index in a tab_strip.\nValue\n-1\nMethods\ncaptureVisibleTab()\nchrome.tabs.captureVisibleTab(\nwindowId?: number,\noptions?: ImageDetails,\ncallback?: function,\n)\nCaptures the visible area of the currently active tab in the specified window. In order to call this method, the extension must have either the <all_urls> permission or the activeTab permission. In addition to sites that extensions can normally access, this method allows extensions to capture sensitive sites that are otherwise restricted, including chrome:-scheme pages, other extensions' pages, and data: URLs. These sensitive sites can only be captured with the activeTab permission. File URLs may be captured only if the extension has been granted file access.\nParameters\n-\nwindowId\nnumber optional\nThe target window. Defaults to the current window.\n-\noptions\nImageDetails optional\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(dataUrl: string) => void\n-\ndataUrl\nstring\nA data URL that encodes an image of the visible area of the captured tab. May be assigned to the 'src' property of an HTML\nimg\nelement for display.\n-\nReturns\n-\nPromise<string>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nconnect()\nchrome.tabs.connect(\ntabId: number,\nconnectInfo?: object,\n)\nConnects to the content script(s) in the specified tab. The runtime.onConnect\nevent is fired in each content script running in the specified tab for the current extension. For more details, see Content Script Messaging.\nParameters\n-\ntabId\nnumber\n-\nconnectInfo\nobject optional\n-\ndocumentId\nstring optional\nChrome 106+Open a port to a specific document identified by\ndocumentId\ninstead of all frames in the tab. -\nframeId\nnumber optional\nOpen a port to a specific frame identified by\nframeId\ninstead of all frames in the tab. -\nname\nstring optional\nIs passed into onConnect for content scripts that are listening for the connection event.\n-\nReturns\n-\nA port that can be used to communicate with the content scripts running in the specified tab. The port's\nruntime.Port\nevent is fired if the tab closes or does not exist.\ncreate()\nchrome.tabs.create(\ncreateProperties: object,\ncallback?: function,\n)\nCreates a new tab.\nParameters\n-\ncreateProperties\nobject\n-\nactive\nboolean optional\nWhether the tab should become the active tab in the window. Does not affect whether the window is focused (see\nwindows.update\n). Defaults totrue\n. -\nindex\nnumber optional\nThe position the tab should take in the window. The provided value is clamped to between zero and the number of tabs in the window.\n-\nopenerTabId\nnumber optional\nThe ID of the tab that opened this tab. If specified, the opener tab must be in the same window as the newly created tab.\n-\npinned\nboolean optional\nWhether the tab should be pinned. Defaults to\nfalse\n-\nselected\nboolean optional\nDeprecatedPlease use active.\nWhether the tab should become the selected tab in the window. Defaults to\ntrue\n-\nurl\nstring optional\nThe URL to initially navigate the tab to. Fully-qualified URLs must include a scheme (i.e., 'http://www.google.com', not 'www.google.com'). Relative URLs are relative to the current page within the extension. Defaults to the New Tab Page.\n-\nwindowId\nnumber optional\nThe window in which to create the new tab. Defaults to the current window.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(tab: Tab) => void\n-\ntab\nThe created tab.\n-\nReturns\n-\nPromise<Tab>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ndetectLanguage()\nchrome.tabs.detectLanguage(\ntabId?: number,\ncallback?: function,\n)\nDetects the primary language of the content in a tab.\nParameters\n-\ntabId\nnumber optional\nDefaults to the active tab of the current window.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(language: string) => void\n-\nlanguage\nstring\nAn ISO language code such as\nen\norfr\n. For a complete list of languages supported by this method, see kLanguageInfoTable. The second to fourth columns are checked and the first non-NULL value is returned, except for Simplified Chinese for whichzh-CN\nis returned. For an unknown/undefined language,und\nis returned.\n-\nReturns\n-\nPromise<string>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ndiscard()\nchrome.tabs.discard(\ntabId?: number,\ncallback?: function,\n)\nDiscards a tab from memory. Discarded tabs are still visible on the tab strip and are reloaded when activated.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to be discarded. If specified, the tab is discarded unless it is active or already discarded. If omitted, the browser discards the least important tab. This can fail if no discardable tabs exist.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(tab?: Tab) => void\n-\ntab\nTab optional\nThe discarded tab, if it was successfully discarded; undefined otherwise.\n-\nReturns\n-\nPromise<Tab | undefined>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nduplicate()\nchrome.tabs.duplicate(\ntabId: number,\ncallback?: function,\n)\nDuplicates a tab.\nParameters\n-\ntabId\nnumber\nThe ID of the tab to duplicate.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(tab?: Tab) => void\nReturns\n-\nPromise<Tab | undefined>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nget()\nchrome.tabs.get(\ntabId: number,\ncallback?: function,\n)\nRetrieves details about the specified tab.\nParameters\n-\ntabId\nnumber\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(tab: Tab) => void\n-\ntab\n-\nReturns\n-\nPromise<Tab>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetCurrent()\nchrome.tabs.getCurrent(\ncallback?: function,\n)\nGets the tab that this script call is being made from. Returns undefined\nif called from a non-tab context (for example, a background page or popup view).\nParameters\nReturns\n-\nPromise<Tab | undefined>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetZoom()\nchrome.tabs.getZoom(\ntabId?: number,\ncallback?: function,\n)\nGets the current zoom factor of a specified tab.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to get the current zoom factor from; defaults to the active tab of the current window.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(zoomFactor: number) => void\n-\nzoomFactor\nnumber\nThe tab's current zoom factor.\n-\nReturns\n-\nPromise<number>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetZoomSettings()\nchrome.tabs.getZoomSettings(\ntabId?: number,\ncallback?: function,\n)\nGets the current zoom settings of a specified tab.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to get the current zoom settings from; defaults to the active tab of the current window.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(zoomSettings: ZoomSettings) => void\n-\nzoomSettings\nThe tab's current zoom settings.\n-\nReturns\n-\nPromise<ZoomSettings>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngoBack()\nchrome.tabs.goBack(\ntabId?: number,\ncallback?: function,\n)\nGo back to the previous page, if one is available.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to navigate back; defaults to the selected tab of the current window.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngoForward()\nchrome.tabs.goForward(\ntabId?: number,\ncallback?: function,\n)\nGo foward to the next page, if one is available.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to navigate forward; defaults to the selected tab of the current window.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngroup()\nchrome.tabs.group(\noptions: object,\ncallback?: function,\n)\nAdds one or more tabs to a specified group, or if no group is specified, adds the given tabs to a newly created group.\nParameters\n-\noptions\nobject\n-\ncreateProperties\nobject optional\nConfigurations for creating a group. Cannot be used if groupId is already specified.\n-\nwindowId\nnumber optional\nThe window of the new group. Defaults to the current window.\n-\n-\ngroupId\nnumber optional\nThe ID of the group to add the tabs to. If not specified, a new group will be created.\n-\ntabIds\nnumber | [number, ...number[]]\nThe tab ID or list of tab IDs to add to the specified group.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(groupId: number) => void\n-\ngroupId\nnumber\nThe ID of the group that the tabs were added to.\n-\nReturns\n-\nPromise<number>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nhighlight()\nchrome.tabs.highlight(\nhighlightInfo: object,\ncallback?: function,\n)\nHighlights the given tabs and focuses on the first of group. Will appear to do nothing if the specified tab is currently active.\nParameters\n-\nhighlightInfo\nobject\n-\ntabs\nnumber | number[]\nOne or more tab indices to highlight.\n-\nwindowId\nnumber optional\nThe window that contains the tabs.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(window: Window) => void\n-\nwindow\nContains details about the window whose tabs were highlighted.\n-\nReturns\n-\nPromise<windows.Window>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nmove()\nchrome.tabs.move(\ntabIds: number | number[],\nmoveProperties: object,\ncallback?: function,\n)\nMoves one or more tabs to a new position within its window, or to a new window. Note that tabs can only be moved to and from normal (window.type === \"normal\") windows.\nParameters\n-\ntabIds\nnumber | number[]\nThe tab ID or list of tab IDs to move.\n-\nmoveProperties\nobject\n-\nindex\nnumber\nThe position to move the window to. Use\n-1\nto place the tab at the end of the window. -\nwindowId\nnumber optional\nDefaults to the window the tab is currently in.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(tabs: Tab | Tab[]) => void\nReturns\n-\nChrome 88+\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nquery()\nchrome.tabs.query(\nqueryInfo: object,\ncallback?: function,\n)\nGets all tabs that have the specified properties, or all tabs if no properties are specified.\nParameters\n-\nqueryInfo\nobject\n-\nactive\nboolean optional\nWhether the tabs are active in their windows.\n-\naudible\nboolean optional\nChrome 45+Whether the tabs are audible.\n-\nautoDiscardable\nboolean optional\nChrome 54+Whether the tabs can be discarded automatically by the browser when resources are low.\n-\ncurrentWindow\nboolean optional\nWhether the tabs are in the current window.\n-\ndiscarded\nboolean optional\nChrome 54+Whether the tabs are discarded. A discarded tab is one whose content has been unloaded from memory, but is still visible in the tab strip. Its content is reloaded the next time it is activated.\n-\nfrozen\nboolean optional\nPendingWhether the tabs are frozen. A frozen tab cannot execute tasks, including event handlers or timers. It is visible in the tab strip and its content is loaded in memory. It is unfrozen on activation.\n-\ngroupId\nnumber optional\nChrome 88+The ID of the group that the tabs are in, or\ntabGroups.TAB_GROUP_ID_NONE\nfor ungrouped tabs. -\nhighlighted\nboolean optional\nWhether the tabs are highlighted.\n-\nindex\nnumber optional\nThe position of the tabs within their windows.\n-\nlastFocusedWindow\nboolean optional\nWhether the tabs are in the last focused window.\n-\nmuted\nboolean optional\nChrome 45+Whether the tabs are muted.\n-\npinned\nboolean optional\nWhether the tabs are pinned.\n-\nstatus\nTabStatus optional\nThe tab loading status.\n-\ntitle\nstring optional\nMatch page titles against a pattern. This property is ignored if the extension does not have the\n\"tabs\"\npermission. -\nurl\nstring | string[] optional\nMatch tabs against one or more URL patterns. Fragment identifiers are not matched. This property is ignored if the extension does not have the\n\"tabs\"\npermission. -\nwindowId\nnumber optional\nThe ID of the parent window, or\nwindows.WINDOW_ID_CURRENT\nfor the current window. -\nwindowType\nWindowType optional\nThe type of window the tabs are in.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(result: Tab[]) => void\n-\nresult\nTab[]\n-\nReturns\n-\nPromise<Tab[]>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nreload()\nchrome.tabs.reload(\ntabId?: number,\nreloadProperties?: object,\ncallback?: function,\n)\nReload a tab.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to reload; defaults to the selected tab of the current window.\n-\nreloadProperties\nobject optional\n-\nbypassCache\nboolean optional\nWhether to bypass local caching. Defaults to\nfalse\n.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremove()\nchrome.tabs.remove(\ntabIds: number | number[],\ncallback?: function,\n)\nCloses one or more tabs.\nParameters\n-\ntabIds\nnumber | number[]\nThe tab ID or list of tab IDs to close.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsendMessage()\nchrome.tabs.sendMessage(\ntabId: number,\nmessage: any,\noptions?: object,\ncallback?: function,\n)\nSends a single message to the content script(s) in the specified tab, with an optional callback to run when a response is sent back. The runtime.onMessage\nevent is fired in each content script running in the specified tab for the current extension.\nParameters\n-\ntabId\nnumber\n-\nmessage\nany\nThe message to send. This message should be a JSON-ifiable object.\n-\noptions\nobject optional\n-\ncallback\nfunction optional\nChrome 99+The\ncallback\nparameter looks like:(response: any) => void\n-\nresponse\nany\nThe JSON response object sent by the handler of the message. If an error occurs while connecting to the specified tab, the callback is called with no arguments and\nruntime.lastError\nis set to the error message.\n-\nReturns\n-\nPromise<any>\nChrome 99+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetZoom()\nchrome.tabs.setZoom(\ntabId?: number,\nzoomFactor: number,\ncallback?: function,\n)\nZooms a specified tab.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to zoom; defaults to the active tab of the current window.\n-\nzoomFactor\nnumber\nThe new zoom factor. A value of\n0\nsets the tab to its current default zoom factor. Values greater than0\nspecify a (possibly non-default) zoom factor for the tab. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetZoomSettings()\nchrome.tabs.setZoomSettings(\ntabId?: number,\nzoomSettings: ZoomSettings,\ncallback?: function,\n)\nSets the zoom settings for a specified tab, which define how zoom changes are handled. These settings are reset to defaults upon navigating the tab.\nParameters\n-\ntabId\nnumber optional\nThe ID of the tab to change the zoom settings for; defaults to the active tab of the current window.\n-\nzoomSettings\nDefines how zoom changes are handled and at what scope.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nungroup()\nchrome.tabs.ungroup(\ntabIds: number | [number, ...number[]],\ncallback?: function,\n)\nRemoves one or more tabs from their respective groups. If any groups become empty, they are deleted.\nParameters\n-\ntabIds\nnumber | [number, ...number[]]\nThe tab ID or list of tab IDs to remove from their respective groups.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdate()\nchrome.tabs.update(\ntabId?: number,\nupdateProperties: object,\ncallback?: function,\n)\nModifies the properties of a tab. Properties that are not specified in updateProperties\nare not modified.\nParameters\n-\ntabId\nnumber optional\nDefaults to the selected tab of the current window.\n-\nupdateProperties\nobject\n-\nactive\nboolean optional\nWhether the tab should be active. Does not affect whether the window is focused (see\nwindows.update\n). -\nautoDiscardable\nboolean optional\nChrome 54+Whether the tab should be discarded automatically by the browser when resources are low.\n-\nhighlighted\nboolean optional\nAdds or removes the tab from the current selection.\n-\nmuted\nboolean optional\nChrome 45+Whether the tab should be muted.\n-\nopenerTabId\nnumber optional\nThe ID of the tab that opened this tab. If specified, the opener tab must be in the same window as this tab.\n-\npinned\nboolean optional\nWhether the tab should be pinned.\n-\nselected\nboolean optional\nDeprecatedPlease use highlighted.\nWhether the tab should be selected.\n-\nurl\nstring optional\nA URL to navigate the tab to. JavaScript URLs are not supported; use\nscripting.executeScript\ninstead.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(tab?: Tab) => void\nReturns\n-\nPromise<Tab | undefined>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonActivated\nchrome.tabs.onActivated.addListener(\ncallback: function,\n)\nFires when the active tab in a window changes. Note that the tab's URL may not be set at the time this event fired, but you can listen to onUpdated events so as to be notified when a URL is set.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(activeInfo: object) => void\n-\nactiveInfo\nobject\n-\ntabId\nnumber\nThe ID of the tab that has become active.\n-\nwindowId\nnumber\nThe ID of the window the active tab changed inside of.\n-\n-\nonAttached\nchrome.tabs.onAttached.addListener(\ncallback: function,\n)\nFired when a tab is attached to a window; for example, because it was moved between windows.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(tabId: number, attachInfo: object) => void\n-\ntabId\nnumber\n-\nattachInfo\nobject\n-\nnewPosition\nnumber\n-\nnewWindowId\nnumber\n-\n-\nonCreated\nchrome.tabs.onCreated.addListener(\ncallback: function,\n)\nFired when a tab is created. Note that the tab's URL and tab group membership may not be set at the time this event is fired, but you can listen to onUpdated events so as to be notified when a URL is set or the tab is added to a tab group.\nonDetached\nchrome.tabs.onDetached.addListener(\ncallback: function,\n)\nFired when a tab is detached from a window; for example, because it was moved between windows.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(tabId: number, detachInfo: object) => void\n-\ntabId\nnumber\n-\ndetachInfo\nobject\n-\noldPosition\nnumber\n-\noldWindowId\nnumber\n-\n-\nonHighlighted\nchrome.tabs.onHighlighted.addListener(\ncallback: function,\n)\nFired when the highlighted or selected tabs in a window changes.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(highlightInfo: object) => void\n-\nhighlightInfo\nobject\n-\ntabIds\nnumber[]\nAll highlighted tabs in the window.\n-\nwindowId\nnumber\nThe window whose tabs changed.\n-\n-\nonMoved\nchrome.tabs.onMoved.addListener(\ncallback: function,\n)\nFired when a tab is moved within a window. Only one move event is fired, representing the tab the user directly moved. Move events are not fired for the other tabs that must move in response to the manually-moved tab. This event is not fired when a tab is moved between windows; for details, see tabs.onDetached\n.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(tabId: number, moveInfo: object) => void\n-\ntabId\nnumber\n-\nmoveInfo\nobject\n-\nfromIndex\nnumber\n-\ntoIndex\nnumber\n-\nwindowId\nnumber\n-\n-\nonRemoved\nchrome.tabs.onRemoved.addListener(\ncallback: function,\n)\nFired when a tab is closed.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(tabId: number, removeInfo: object) => void\n-\ntabId\nnumber\n-\nremoveInfo\nobject\n-\nisWindowClosing\nboolean\nTrue when the tab was closed because its parent window was closed.\n-\nwindowId\nnumber\nThe window whose tab is closed.\n-\n-\nonReplaced\nchrome.tabs.onReplaced.addListener(\ncallback: function,\n)\nFired when a tab is replaced with another tab due to prerendering or instant.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(addedTabId: number, removedTabId: number) => void\n-\naddedTabId\nnumber\n-\nremovedTabId\nnumber\n-\nonUpdated\nchrome.tabs.onUpdated.addListener(\ncallback: function,\n)\nFired when a tab is updated.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(tabId: number, changeInfo: object, tab: Tab) => void\n-\ntabId\nnumber\n-\nchangeInfo\nobject\n-\naudible\nboolean optional\nChrome 45+The tab's new audible state.\n-\nautoDiscardable\nboolean optional\nChrome 54+The tab's new auto-discardable state.\n-\ndiscarded\nboolean optional\nChrome 54+The tab's new discarded state.\n-\nfavIconUrl\nstring optional\nThe tab's new favicon URL.\n-\nfrozen\nboolean optional\nPendingThe tab's new frozen state.\n-\ngroupId\nnumber optional\nChrome 88+The tab's new group.\n-\nmutedInfo\nMutedInfo optional\nChrome 46+The tab's new muted state and the reason for the change.\n-\npinned\nboolean optional\nThe tab's new pinned state.\n-\nstatus\nTabStatus optional\nThe tab's loading status.\n-\ntitle\nstring optional\nChrome 48+The tab's new title.\n-\nurl\nstring optional\nThe tab's URL if it has changed.\n-\n-\ntab\n-\nonZoomChange\nchrome.tabs.onZoomChange.addListener(\ncallback: function,\n)\nFired when a tab is zoomed.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(ZoomChangeInfo: object) => void\n-\nZoomChangeInfo\nobject\n-\nnewZoomFactor\nnumber\n-\noldZoomFactor\nnumber\n-\ntabId\nnumber\n-\nzoomSettings\n-\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/tts", "title": "chrome.tts | API | Chrome for Developers", "text": "Description\nUse the chrome.tts\nAPI to play synthesized text-to-speech (TTS). See also the related ttsEngine\nAPI, which allows an extension to implement a speech engine.\nChrome provides this capability on Windows (using SAPI 5), Mac OS X, and ChromeOS, using speech synthesis capabilities provided by the operating system. On all platforms, the user can install extensions that register themselves as alternative speech engines.\nPermissions\ntts\nConcepts and usage\nGenerate speech\nCall speak()\nfrom your extension to speak. For example:\nchrome.tts.speak('Hello, world.');\nTo stop speaking immediately, just call stop()\n:\nchrome.tts.stop();\nYou can provide options that control various properties of the speech, such as its rate, pitch, and more. For example:\nchrome.tts.speak('Hello, world.', {'rate': 2.0});\nIt's also a good idea to specify the language so that a synthesizer supporting that language (and regional dialect, if applicable) is chosen.\nchrome.tts.speak('Hello, world.', {'lang': 'en-US', 'rate': 2.0});\nBy default, each call to speak()\ninterrupts any ongoing speech and speaks immediately. To\ndetermine if a call would be interrupting anything, you can call isSpeaking()\n. In addition, you\ncan use the enqueue\noption to cause this utterance to be added to a queue of utterances that will\nbe spoken when the current utterance has finished.\nchrome.tts.speak('Speak this first.');\nchrome.tts.speak(\n'Speak this next, when the first sentence is done.', {'enqueue': true});\nA complete description of all options can be found under tts.speak()\n. Not all speech\nengines will support all options.\nTo catch errors and make sure you're calling speak()\ncorrectly, pass a callback function that\ntakes no arguments. Inside the callback, check runtime.lastError\nto see if there were any\nerrors.\nchrome.tts.speak(\nutterance,\noptions,\nfunction() {\nif (chrome.runtime.lastError) {\nconsole.log('Error: ' + chrome.runtime.lastError.message);\n}\n}\n);\nThe callback returns right away, before the engine has started generating speech. The purpose of the callback is to alert you to syntax errors in your use of the TTS API, not to catch all possible errors that might occur in the process of synthesizing and outputting speech. To catch these errors too, you need to use an event listener, described in the next section.\nListen to events\nTo get more real-time information about the status of synthesized speech, pass an event listener in\nthe options to speak()\n, like this:\nchrome.tts.speak(\nutterance,\n{\nonEvent: function(event) {\nconsole.log('Event ' + event.type + ' at position ' + event.charIndex);\nif (event.type == 'error') {\nconsole.log('Error: ' + event.errorMessage);\n}\n}\n},\ncallback\n);\nEach event includes an event type, the character index of the current speech relative to the utterance, and for error events, an optional error message. The event types are:\n'start'\n: The engine has started speaking the utterance.'word'\n: A word boundary was reached. Useevent.charIndex\nto determine the current speech position.'sentence'\n: A sentence boundary was reached. Useevent.charIndex\nto determine the current speech position.'marker'\n: An SSML marker was reached. Useevent.charIndex\nto determine the current speech position.'end'\n: The engine has finished speaking the utterance.'interrupted'\n: This utterance was interrupted by another call tospeak()\norstop()\nand did not finish.'cancelled'\n: This utterance was queued, but then cancelled by another call tospeak()\norstop()\nand never began to speak at all.'error'\n: An engine-specific error occurred and this utterance cannot be spoken. Checkevent.errorMessage\nfor details.\nFour of the event types\u2014'end'\n, 'interrupted'\n, 'cancelled'\n, and 'error'\n\u2014are final. After\none of those events is received, this utterance will no longer speak and no new events from this\nutterance will be received.\nSome voices may not support all event types, and some voices may not send any events at all. If you\ndon't want to use a voice unless it sends certain events, pass the events you require in the\nrequiredEventTypes\nmember of the options object, or use getVoices()\nto choose a voice that meets\nyour requirements. Both are described in what follows.\nSSML markup\nUtterances used in this API may include markup using the Speech Synthesis Markup Language\n(SSML). If you use SSML, the first argument to speak()\nshould be a complete SSML document with\nan XML header and a top-level <speak>\ntag, not a document fragment.\nFor example:\nchrome.tts.speak(\n'<?xml version=\"1.0\"?>' +\n'<speak>' +\n' The <emphasis>second</emphasis> ' +\n' word of this sentence was emphasized.' +\n'</speak>'\n);\nNot all speech engines will support all SSML tags, and some may not support SSML at all, but all engines are required to ignore any SSML they don't support and to still speak the underlying text.\nChoose a voice\nBy default, Chrome chooses the most appropriate voice for each utterance you want to speak, based on the language. On most Windows, Mac OS X, and ChromeOS systems, speech synthesis provided by the operating system should be able to speak any text in at least one language. Some users may have a variety of voices available, though, from their operating system and from speech engines implemented by other Chrome extensions. In those cases, you can implement custom code to choose the appropriate voice, or to present the user with a list of choices.\nTo get a list of all voices, call getVoices()\nand pass it a function that receives an array of\nTtsVoice\nobjects as its argument:\nchrome.tts.getVoices(\nfunction(voices) {\nfor (var i = 0; i < voices.length; i++) {\nconsole.log('Voice ' + i + ':');\nconsole.log(' name: ' + voices[i].voiceName);\nconsole.log(' lang: ' + voices[i].lang);\nconsole.log(' extension id: ' + voices[i].extensionId);\nconsole.log(' event types: ' + voices[i].eventTypes);\n}\n}\n);\nTypes\nEventType\nEnum\n\"start\" \"end\" \"word\" \"sentence\" \"marker\" \"interrupted\" \"cancelled\" \"error\" \"pause\" \"resume\"\nTtsEvent\nAn event from the TTS engine to communicate the status of an utterance.\nProperties\n-\ncharIndex\nnumber optional\nThe index of the current character in the utterance. For word events, the event fires at the end of one word and before the beginning of the next. The\ncharIndex\nrepresents a point in the text at the beginning of the next word to be spoken. -\nerrorMessage\nstring optional\nThe error description, if the event type is\nerror\n. -\nlength\nnumber optional\nChrome 74+The length of the next part of the utterance. For example, in a\nword\nevent, this is the length of the word which will be spoken next. It will be set to -1 if not set by the speech engine. -\ntype\nThe type can be\nstart\nas soon as speech has started,word\nwhen a word boundary is reached,sentence\nwhen a sentence boundary is reached,marker\nwhen an SSML mark element is reached,end\nwhen the end of the utterance is reached,interrupted\nwhen the utterance is stopped or interrupted before reaching the end,cancelled\nwhen it's removed from the queue before ever being synthesized, orerror\nwhen any other error occurs. When pausing speech, apause\nevent is fired if a particular utterance is paused in the middle, andresume\nif an utterance resumes speech. Note that pause and resume events may not fire if speech is paused in-between utterances.\nTtsOptions\nThe speech options for the TTS engine.\nProperties\n-\ndesiredEventTypes\nstring[] optional\nThe TTS event types that you are interested in listening to. If missing, all event types may be sent.\n-\nenqueue\nboolean optional\nIf true, enqueues this utterance if TTS is already in progress. If false (the default), interrupts any current speech and flushes the speech queue before speaking this new utterance.\n-\nextensionId\nstring optional\nThe extension ID of the speech engine to use, if known.\n-\ngender\nVoiceGender optional\nDeprecated since Chrome 77Gender is deprecated and will be ignored.\nGender of voice for synthesized speech.\n-\nlang\nstring optional\nThe language to be used for synthesis, in the form language-region. Examples: 'en', 'en-US', 'en-GB', 'zh-CN'.\n-\npitch\nnumber optional\nSpeaking pitch between 0 and 2 inclusive, with 0 being lowest and 2 being highest. 1.0 corresponds to a voice's default pitch.\n-\nrate\nnumber optional\nSpeaking rate relative to the default rate for this voice. 1.0 is the default rate, normally around 180 to 220 words per minute. 2.0 is twice as fast, and 0.5 is half as fast. Values below 0.1 or above 10.0 are strictly disallowed, but many voices will constrain the minimum and maximum rates further\u2014for example a particular voice may not actually speak faster than 3 times normal even if you specify a value larger than 3.0.\n-\nrequiredEventTypes\nstring[] optional\nThe TTS event types the voice must support.\n-\nvoiceName\nstring optional\nThe name of the voice to use for synthesis. If empty, uses any available voice.\n-\nvolume\nnumber optional\nSpeaking volume between 0 and 1 inclusive, with 0 being lowest and 1 being highest, with a default of 1.0.\n-\nonEvent\nvoid optional\nThis function is called with events that occur in the process of speaking the utterance.\nThe\nonEvent\nfunction looks like:(event: TtsEvent) => {...}\n-\nevent\nThe update event from the text-to-speech engine indicating the status of this utterance.\n-\nTtsVoice\nA description of a voice available for speech synthesis.\nProperties\n-\neventTypes\nEventType[] optional\nAll of the callback event types that this voice is capable of sending.\n-\nextensionId\nstring optional\nThe ID of the extension providing this voice.\n-\ngender\nVoiceGender optional\nDeprecated since Chrome 70Gender is deprecated and will be ignored.\nThis voice's gender.\n-\nlang\nstring optional\nThe language that this voice supports, in the form language-region. Examples: 'en', 'en-US', 'en-GB', 'zh-CN'.\n-\nremote\nboolean optional\nIf true, the synthesis engine is a remote network resource. It may be higher latency and may incur bandwidth costs.\n-\nvoiceName\nstring optional\nThe name of the voice.\nVoiceGender\nGender is deprecated and is ignored.\nEnum\n\"male\" \"female\"\nMethods\ngetVoices()\nchrome.tts.getVoices(\ncallback?: function,\n)\nGets an array of all available voices.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(voices: TtsVoice[]) => void\n-\nvoices\nTtsVoice[]\nArray of\ntts.TtsVoice\nobjects representing the available voices for speech synthesis.\n-\nReturns\n-\nPromise<TtsVoice[]>\nChrome 101+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nisSpeaking()\nchrome.tts.isSpeaking(\ncallback?: function,\n)\nChecks whether the engine is currently speaking. On Mac OS X, the result is true whenever the system speech engine is speaking, even if the speech wasn't initiated by Chrome.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(speaking: boolean) => void\n-\nspeaking\nboolean\nTrue if speaking, false otherwise.\n-\nReturns\n-\nPromise<boolean>\nChrome 101+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\npause()\nchrome.tts.pause()\nPauses speech synthesis, potentially in the middle of an utterance. A call to resume or stop will un-pause speech.\nresume()\nchrome.tts.resume()\nIf speech was paused, resumes speaking where it left off.\nspeak()\nchrome.tts.speak(\nutterance: string,\noptions?: TtsOptions,\ncallback?: function,\n)\nSpeaks text using a text-to-speech engine.\nParameters\n-\nutterance\nstring\nThe text to speak, either plain text or a complete, well-formed SSML document. Speech engines that do not support SSML will strip away the tags and speak the text. The maximum length of the text is 32,768 characters.\n-\noptions\nTtsOptions optional\nThe speech options.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 101+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nstop()\nchrome.tts.stop()\nStops any current speech and flushes the queue of any pending utterances. In addition, if speech was paused, it will now be un-paused for the next call to speak.\nEvents\nonVoicesChanged\nchrome.tts.onVoicesChanged.addListener(\ncallback: function,\n)\nCalled when the list of tts.TtsVoice\nthat would be returned by getVoices has changed.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/ttsEngine", "title": "chrome.ttsEngine | API | Chrome for Developers", "text": "Description\nUse the chrome.ttsEngine\nAPI to implement a text-to-speech(TTS) engine using an extension. If your extension registers using this API, it will receive events containing an utterance to be spoken and other parameters when any extension or Chrome App uses the tts\nAPI to generate speech. Your extension can then use any available web technology to synthesize and output the speech, and send events back to the calling function to report the status.\nPermissions\nttsEngine\nConcepts and usage\nAn extension can register itself as a speech engine. By doing so, it can intercept some or all calls\nto functions such as tts.speak()\nand tts.stop()\nand provide an alternate implementation.\nExtensions are free to use any available web technology to provide speech, including streaming audio\nfrom a server, HTML5 audio. An extension could even do something different\nwith the utterances, like display closed captions in a popup or send them as log messages to\na remote server.\nTo implement a TTS engine, an extension must declare the \"ttsEngine\" permission and then declare all voices it provides in the extension manifest, like this:\n{\n\"name\": \"My TTS Engine\",\n\"version\": \"1.0\",\n\"permissions\": [\"ttsEngine\"],\n\"tts_engine\": {\n\"voices\": [\n{\n\"voice_name\": \"Alice\",\n\"lang\": \"en-US\",\n\"event_types\": [\"start\", \"marker\", \"end\"]\n},\n{\n\"voice_name\": \"Pat\",\n\"lang\": \"en-US\",\n\"event_types\": [\"end\"]\n}\n]\n},\n\"background\": {\n\"page\": \"background.html\",\n\"persistent\": false\n}\n}\nAn extension can specify any number of voices.\nThe voice_name\nparameter is required. The name should be descriptive enough that it identifies the\nname of the voice and the engine used. In the unlikely event that two extensions register voices\nwith the same name, a client can specify the ID of the extension that should do the synthesis.\nThe lang\nparameter is optional, but highly recommended. Almost always, a voice can synthesize\nspeech in just a single language. When an engine supports more than one language, it can easily\nregister a separate voice for each language. Under rare circumstances where a single voice can\nhandle more than one language, it's easiest to just list two separate voices and handle them using\nthe same logic internally. However, if you want to create a voice that will handle utterances in any\nlanguage, leave out the lang\nparameter from your extension's manifest.\nFinally, the event_types\nparameter is required if the engine can send events to update the client\non the progress of speech synthesis. At a minimum, supporting the 'end'\nevent type to indicate\nwhen speech is finished is highly recommended, otherwise Chrome cannot schedule queued utterances.\nOnce loaded, an extension can replace the list of declared voices by calling\nchrome.ttsEngine.updateVoices\n. (Note that the parameters used in the programatic call to\nupdateVoices\nare in camel case: e.g., voiceName\n, unlike the manifest file which uses\nvoice_name\n.)\nThe possible event types that you can send correspond to the event types that the speak()\nmethod\nreceives:\n'start'\n: The engine has started speaking the utterance.'word'\n: A word boundary was reached. Useevent.charIndex\nto determine the current speech position.'sentence'\n: A sentence boundary was reached. Useevent.charIndex\nto determine the current speech position.'marker'\n: An SSML marker was reached. Useevent.charIndex\nto determine the current speech position.'end'\n: The engine has finished speaking the utterance.'error'\n: An engine-specific error occurred and this utterance cannot be spoken. Pass more information inevent.errorMessage\n.\nThe 'interrupted'\nand 'cancelled'\nevents are not sent by the speech engine; they are generated\nautomatically by Chrome.\nText-to-speech clients can get the voice information from your extension's manifest by calling\ntts.getVoices\n, assuming you've registered speech event listeners as described below.\nHandle speech events\nTo generate speech at the request of clients, your extension must register listeners for both\nonSpeak\nand onStop\n, like this:\nconst speakListener = (utterance, options, sendTtsEvent) => {\nsendTtsEvent({type: 'start', charIndex: 0})\n// (start speaking)\nsendTtsEvent({type: 'end', charIndex: utterance.length})\n};\nconst stopListener = () => {\n// (stop all speech)\n};\nchrome.ttsEngine.onSpeak.addListener(speakListener);\nchrome.ttsEngine.onStop.addListener(stopListener);\nThe decision of whether or not to send a given speech request to an extension is based solely on\nwhether the extension supports the given voice parameters in its manifest and has registered\nlisteners for onSpeak\nand onStop\n. In other words, there's no way for an extension to receive a\nspeech request and dynamically decide whether to handle it.\nTypes\nAudioBuffer\nParameters containing an audio buffer and associated data.\nProperties\n-\naudioBuffer\nArrayBuffer\nThe audio buffer from the text-to-speech engine. It should have length exactly audioStreamOptions.bufferSize and encoded as mono, at audioStreamOptions.sampleRate, and as linear pcm, 32-bit signed float i.e. the Float32Array type in javascript.\n-\ncharIndex\nnumber optional\nThe character index associated with this audio buffer.\n-\nisLastBuffer\nboolean optional\nTrue if this audio buffer is the last for the text being spoken.\nAudioStreamOptions\nContains the audio stream format expected to be produced by an engine.\nProperties\n-\nbufferSize\nnumber\nThe number of samples within an audio buffer.\n-\nsampleRate\nnumber\nThe sample rate expected in an audio buffer.\nLanguageInstallStatus\nThe install status of a voice.\nEnum\n\"notInstalled\" \"installing\" \"installed\" \"failed\"\nLanguageStatus\nInstall status of a language.\nProperties\n-\nerror\nstring optional\nDetail about installation failures. Optionally populated if the language failed to install.\n-\ninstallStatus\nInstallation status.\n-\nlang\nstring\nLanguage string in the form of language code-region code, where the region may be omitted. Examples are en, en-AU, zh-CH.\nLanguageUninstallOptions\nOptions for uninstalling a given language.\nProperties\n-\nuninstallImmediately\nboolean\nTrue if the TTS client wants the language to be immediately uninstalled. The engine may choose whether or when to uninstall the language, based on this parameter and the requestor information. If false, it may use other criteria, such as recent usage, to determine when to uninstall.\nSpeakOptions\nOptions specified to the tts.speak() method.\nProperties\n-\ngender\nVoiceGender optional\nDeprecated since Chrome 92Gender is deprecated and will be ignored.\nGender of voice for synthesized speech.\n-\nlang\nstring optional\nThe language to be used for synthesis, in the form language-region. Examples: 'en', 'en-US', 'en-GB', 'zh-CN'.\n-\npitch\nnumber optional\nSpeaking pitch between 0 and 2 inclusive, with 0 being lowest and 2 being highest. 1.0 corresponds to this voice's default pitch.\n-\nrate\nnumber optional\nSpeaking rate relative to the default rate for this voice. 1.0 is the default rate, normally around 180 to 220 words per minute. 2.0 is twice as fast, and 0.5 is half as fast. This value is guaranteed to be between 0.1 and 10.0, inclusive. When a voice does not support this full range of rates, don't return an error. Instead, clip the rate to the range the voice supports.\n-\nvoiceName\nstring optional\nThe name of the voice to use for synthesis.\n-\nvolume\nnumber optional\nSpeaking volume between 0 and 1 inclusive, with 0 being lowest and 1 being highest, with a default of 1.0.\nTtsClient\nIdentifier for the client requesting status.\nProperties\n-\nid\nstring\nClient making a language management request. For an extension, this is the unique extension ID. For Chrome features, this is the human-readable name of the feature.\n-\nsource\nType of requestor.\nTtsClientSource\nType of requestor.\nEnum\n\"chromefeature\" \"extension\"\nVoiceGender\nGender is deprecated and will be ignored.\nEnum\n\"male\" \"female\"\nMethods\nupdateLanguage()\nchrome.ttsEngine.updateLanguage(\nstatus: LanguageStatus,\n)\nCalled by an engine when a language install is attempted, and when a language is uninstalled. Also called in response to a status request from a client. When a voice is installed or uninstalled, the engine should also call ttsEngine.updateVoices to register the voice.\nParameters\n-\nstatus\nThe install status of the language.\nupdateVoices()\nchrome.ttsEngine.updateVoices(\nvoices: TtsVoice[],\n)\nCalled by an engine to update its list of voices. This list overrides any voices declared in this extension's manifest.\nParameters\n-\nvoices\nTtsVoice[]\nArray of\ntts.TtsVoice\nobjects representing the available voices for speech synthesis.\nEvents\nonInstallLanguageRequest\nchrome.ttsEngine.onInstallLanguageRequest.addListener(\ncallback: function,\n)\nFired when a TTS client requests to install a new language. The engine should attempt to download and install the language, and call ttsEngine.updateLanguage with the result. On success, the engine should also call ttsEngine.updateVoices to register the newly available voices.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(requestor: TtsClient, lang: string) => void\n-\nrequestor\n-\nlang\nstring\n-\nonLanguageStatusRequest\nchrome.ttsEngine.onLanguageStatusRequest.addListener(\ncallback: function,\n)\nFired when a TTS client requests the install status of a language.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(requestor: TtsClient, lang: string) => void\n-\nrequestor\n-\nlang\nstring\n-\nonPause\nchrome.ttsEngine.onPause.addListener(\ncallback: function,\n)\nOptional: if an engine supports the pause event, it should pause the current utterance being spoken, if any, until it receives a resume event or stop event. Note that a stop event should also clear the paused state.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonResume\nchrome.ttsEngine.onResume.addListener(\ncallback: function,\n)\nOptional: if an engine supports the pause event, it should also support the resume event, to continue speaking the current utterance, if any. Note that a stop event should also clear the paused state.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonSpeak\nchrome.ttsEngine.onSpeak.addListener(\ncallback: function,\n)\nCalled when the user makes a call to tts.speak() and one of the voices from this extension's manifest is the first to match the options object.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(utterance: string, options: SpeakOptions, sendTtsEvent: function) => void\n-\nutterance\nstring\n-\noptions\n-\nsendTtsEvent\nfunction\nThe\nsendTtsEvent\nparameter looks like:(event: tts.TtsEvent) => void\n-\nevent\nThe event from the text-to-speech engine indicating the status of this utterance.\n-\n-\nonSpeakWithAudioStream\nchrome.ttsEngine.onSpeakWithAudioStream.addListener(\ncallback: function,\n)\nCalled when the user makes a call to tts.speak() and one of the voices from this extension's manifest is the first to match the options object. Differs from ttsEngine.onSpeak in that Chrome provides audio playback services and handles dispatching tts events.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(utterance: string, options: SpeakOptions, audioStreamOptions: AudioStreamOptions, sendTtsAudio: function, sendError: function) => void\n-\nutterance\nstring\n-\noptions\n-\naudioStreamOptions\n-\nsendTtsAudio\nfunction\nThe\nsendTtsAudio\nparameter looks like:(audioBufferParams: AudioBuffer) => void\n-\naudioBufferParams\nParameters containing an audio buffer and associated data.\n-\n-\nsendError\nfunction\nChrome 94+The\nsendError\nparameter looks like:(errorMessage?: string) => void\n-\nerrorMessage\nstring optional\nA string describing the error.\n-\n-\nonStop\nchrome.ttsEngine.onStop.addListener(\ncallback: function,\n)\nFired when a call is made to tts.stop and this extension may be in the middle of speaking. If an extension receives a call to onStop and speech is already stopped, it should do nothing (not raise an error). If speech is in the paused state, this should cancel the paused state.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:() => void\nonUninstallLanguageRequest\nchrome.ttsEngine.onUninstallLanguageRequest.addListener(\ncallback: function,\n)\nFired when a TTS client indicates a language is no longer needed.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(requestor: TtsClient, lang: string, uninstallOptions: LanguageUninstallOptions) => void\n-\nrequestor\n-\nlang\nstring\n-\nuninstallOptions\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/types", "title": "chrome.types | API | Chrome for Developers", "text": "Description\nThe chrome.types\nAPI contains type declarations for Chrome.\nChrome settings\nThe ChromeSetting\ntype provides a common set of functions (get()\n, set()\n, and clear()\n)\nas well as an event publisher (onChange\n) for settings of the Chrome browser. The proxy settings\nexamples demonstrate how these functions are intended to be used.\nScope and lifecycle\nChrome distinguishes between three different scopes of browser settings:\nregular\n- Settings set in the\nregular\nscope apply to regular browser windows and are inherited by incognito windows if they are not overwritten. These settings are stored to disk and remain in place until they are cleared by the governing extension, or the governing extension is disabled or uninstalled. incognito_persistent\n- Settings set in the\nincognito_persistent\nscope apply only to incognito windows. For these, they overrideregular\nsettings. These settings are stored to disk and remain in place until they are cleared by the governing extension, or the governing extension is disabled or uninstalled. incognito_session_only\n- Settings set in the\nincognito_session_only\nscope apply only to incognito windows. For these, they overrideregular\nandincognito_persistent\nsettings. These settings are not stored to disk and are cleared when the last incognito window is closed. They can only be set when at least one incognito window is open.\nPrecedence\nChrome manages settings on different layers. The following list describes the layers that may influence the effective settings, in increasing order of precedence.\n- System settings provided by the operating system\n- Command-line parameters\n- Settings provided by extensions\n- Policies\nAs the list implies, policies might overrule any changes that you specify with your extension. You\ncan use the get()\nfunction to determine whether your extension is capable of providing a setting\nor whether this setting would be overridden.\nAs discussed previously, Chrome allows using different settings for regular windows and incognito windows. The following example illustrates the behavior. Assume that no policy overrides the settings and that an extension can set settings for regular windows (R) and settings for incognito windows (I).\n- If only (R) is set, these settings are effective for both regular and incognito windows.\n- If only (I) is set, these settings are effective for only incognito windows. Regular windows use the settings determined by the lower layers (command-line options and system settings).\n- If both (R) and (I) are set, the respective settings are used for regular and incognito windows.\nIf two or more extensions want to set the same setting to different values, the extension installed most recently takes precedence over the other extensions. If the most recently installed extension sets only (I), the settings of regular windows can be defined by previously installed extensions.\nThe effective value of a setting is the one that results from considering the precedence rules. It is used by Chrome.\nTypes\nChromeSetting\nAn interface that allows access to a Chrome browser setting. See accessibilityFeatures\nfor an example.\nProperties\n-\nonChange\nEvent<functionvoidvoid>\nFired after the setting changes.\nThe\nonChange.addListener\nfunction looks like:(callback: function) => {...}\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nincognitoSpecific\nboolean optional\nWhether the value that has changed is specific to the incognito session. This property will only be present if the user has enabled the extension in incognito mode.\n-\nlevelOfControl\nThe level of control of the setting.\n-\nvalue\nT\nThe value of the setting after the change.\n-\n-\n-\n-\nclear\nvoid\nPromiseClears the setting, restoring any default value.\nThe\nclear\nfunction looks like:(details: object, callback?: function) => {...}\n-\ndetails\nobject\nWhich setting to clear.\n-\nscope\nChromeSettingScope optional\nWhere to clear the setting (default: regular).\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\n-\nreturns\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\nget\nvoid\nPromiseGets the value of a setting.\nThe\nget\nfunction looks like:(details: object, callback?: function) => {...}\n-\ndetails\nobject\nWhich setting to consider.\n-\nincognito\nboolean optional\nWhether to return the value that applies to the incognito session (default false).\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\nDetails of the currently effective value.\n-\nincognitoSpecific\nboolean optional\nWhether the effective value is specific to the incognito session. This property will only be present if the\nincognito\nproperty in thedetails\nparameter ofget()\nwas true. -\nlevelOfControl\nThe level of control of the setting.\n-\nvalue\nT\nThe value of the setting.\n-\n-\n-\nreturns\nPromise<object>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\n-\nset\nvoid\nPromiseSets the value of a setting.\nThe\nset\nfunction looks like:(details: object, callback?: function) => {...}\n-\ndetails\nobject\nWhich setting to change.\n-\nscope\nChromeSettingScope optional\nWhere to set the setting (default: regular).\n-\nvalue\nT\nThe value of the setting. Note that every setting has a specific value type, which is described together with the setting. An extension should not set a value of a different type.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\n-\nreturns\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n-\nChromeSettingScope\nThe scope of the ChromeSetting. One of\nregular\n: setting for the regular profile (which is inherited by the incognito profile if not overridden elsewhere),regular\\_only\n: setting for the regular profile only (not inherited by the incognito profile),incognito\\_persistent\n: setting for the incognito profile that survives browser restarts (overrides regular preferences),incognito\\_session\\_only\n: setting for the incognito profile that can only be set during an incognito session and is deleted when the incognito session ends (overrides regular and incognito_persistent preferences).\nEnum\n\"regular\" \"regular_only\" \"incognito_persistent\" \"incognito_session_only\"\nLevelOfControl\nOne of\nnot\\_controllable\n: cannot be controlled by any extensioncontrolled\\_by\\_other\\_extensions\n: controlled by extensions with higher precedencecontrollable\\_by\\_this\\_extension\n: can be controlled by this extensioncontrolled\\_by\\_this\\_extension\n: controlled by this extension\nEnum\n\"not_controllable\" \"controlled_by_other_extensions\" \"controllable_by_this_extension\" \"controlled_by_this_extension\""},
{"source": "https://developer.chrome.com/docs/apps/reference/usb", "title": "chrome.usb | Platform Apps APIs | Chrome for Developers", "text": "Description\nUse the chrome.usb\nAPI to interact with connected USB devices. This API provides access to USB operations from within the context of an app. Using this API, apps can function as drivers for hardware devices. Errors generated by this API are reported by setting runtime.lastError\nand executing the function's regular callback. The callback's regular parameters will be undefined in this case.\nPermissions\nusb\nTypes\nConfigDescriptor\nProperties\n-\nactive\nboolean\nChrome 47+Is this the active configuration?\n-\nconfigurationValue\nnumber\nThe configuration number.\n-\ndescription\nstring optional\nDescription of the configuration.\n-\nextra_data\nArrayBuffer\nExtra descriptor data associated with this configuration.\n-\ninterfaces\nAvailable interfaces.\n-\nmaxPower\nnumber\nThe maximum power needed by this device in milliamps (mA).\n-\nremoteWakeup\nboolean\nThe device supports remote wakeup.\n-\nselfPowered\nboolean\nThe device is self-powered.\nConnectionHandle\nProperties\n-\nhandle\nnumber\nAn opaque handle representing this connection to the USB device and all associated claimed interfaces and pending transfers. A new handle is created each time the device is opened. The connection handle is different from\nDevice.device\n. -\nproductId\nnumber\nThe product ID.\n-\nvendorId\nnumber\nThe device vendor ID.\nControlTransferInfo\nProperties\n-\ndata\nArrayBuffer optional\nThe data to transmit (required only by output transfers).\n-\ndirection\nThe transfer direction (\n\"in\"\nor\"out\"\n). -\nindex\nnumber\nThe\nwIndex\nfield, see Ibid. -\nlength\nnumber optional\nThe maximum number of bytes to receive (required only by input transfers).\n-\nrecipient\nThe transfer target. The target given by\nindex\nmust be claimed if\"interface\"\nor\"endpoint\"\n. -\nrequest\nnumber\nThe\nbRequest\nfield, see Universal Serial Bus Specification Revision 1.1 \u00a7 9.3. -\nrequestType\nThe request type.\n-\ntimeout\nnumber optional\nChrome 43+Request timeout (in milliseconds). The default value\n0\nindicates no timeout. -\nvalue\nnumber\nThe\nwValue\nfield, see Ibid.\nDevice\nProperties\n-\ndevice\nnumber\nAn opaque ID for the USB device. It remains unchanged until the device is unplugged.\n-\nmanufacturerName\nstring\nChrome 46+The iManufacturer string read from the device, if available.\n-\nproductId\nnumber\nThe product ID.\n-\nproductName\nstring\nChrome 46+The iProduct string read from the device, if available.\n-\nserialNumber\nstring\nChrome 46+The iSerialNumber string read from the device, if available.\n-\nvendorId\nnumber\nThe device vendor ID.\n-\nversion\nnumber\nChrome 51+The device version (bcdDevice field).\nDeviceFilter\nProperties\n-\ninterfaceClass\nnumber optional\nUSB interface class, matches any interface on the device.\n-\ninterfaceProtocol\nnumber optional\nUSB interface protocol, checked only if the interface sub-class matches.\n-\ninterfaceSubclass\nnumber optional\nUSB interface sub-class, checked only if the interface class matches.\n-\nproductId\nnumber optional\nDevice product ID, checked only if the vendor ID matches.\n-\nvendorId\nnumber optional\nDevice vendor ID.\nDevicePromptOptions\nProperties\n-\nfilters\nDeviceFilter[] optional\nFilter the list of devices presented to the user. If multiple filters are provided devices matching any filter will be displayed.\n-\nmultiple\nboolean optional\nAllow the user to select multiple devices.\nDirection\nDirection, Recipient, RequestType, and TransferType all map to their namesakes within the USB specification.\nEnum\n\"in\" \"out\"\nEndpointDescriptor\nProperties\n-\naddress\nnumber\nEndpoint address.\n-\ndirection\nTransfer direction.\n-\nextra_data\nArrayBuffer\nExtra descriptor data associated with this endpoint.\n-\nmaximumPacketSize\nnumber\nMaximum packet size.\n-\npollingInterval\nnumber optional\nPolling interval (interrupt and isochronous only).\n-\nsynchronization\nSynchronizationType optional\nTransfer synchronization mode (isochronous only).\n-\ntype\nTransfer type.\n-\nusage\nUsageType optional\nEndpoint usage hint.\nEnumerateDevicesAndRequestAccessOptions\nProperties\n-\ninterfaceId\nnumber optional\nThe interface ID to request access to. Only available on Chrome OS. It has no effect on other platforms.\n-\nproductId\nnumber\nThe product ID.\n-\nvendorId\nnumber\nThe device vendor ID.\nEnumerateDevicesOptions\nProperties\n-\nfilters\nDeviceFilter[] optional\nA device matching any given filter will be returned. An empty filter list will return all devices the app has permission for.\n-\nproductId\nnumber optional\nDeprecatedEquivalent to setting\nDeviceFilter.productId\n. -\nvendorId\nnumber optional\nDeprecatedEquivalent to setting\nDeviceFilter.vendorId\n.\nGenericTransferInfo\nProperties\n-\ndata\nArrayBuffer optional\nThe data to transmit (required only by output transfers).\n-\ndirection\nThe transfer direction (\n\"in\"\nor\"out\"\n). -\nendpoint\nnumber\nThe target endpoint address. The interface containing this endpoint must be claimed.\n-\nlength\nnumber optional\nThe maximum number of bytes to receive (required only by input transfers).\n-\ntimeout\nnumber optional\nChrome 43+Request timeout (in milliseconds). The default value\n0\nindicates no timeout.\nInterfaceDescriptor\nProperties\n-\nalternateSetting\nnumber\nThe interface alternate setting number (defaults to\n0\n-\ndescription\nstring optional\nDescription of the interface.\n-\nendpoints\nAvailable endpoints.\n-\nextra_data\nArrayBuffer\nExtra descriptor data associated with this interface.\n-\ninterfaceClass\nnumber\nThe USB interface class.\n-\ninterfaceNumber\nnumber\nThe interface number.\n-\ninterfaceProtocol\nnumber\nThe USB interface protocol.\n-\ninterfaceSubclass\nnumber\nThe USB interface sub-class.\nIsochronousTransferInfo\nProperties\n-\npacketLength\nnumber\nThe length of each of the packets in this transfer.\n-\npackets\nnumber\nThe total number of packets in this transfer.\n-\ntransferInfo\nTransfer parameters. The transfer length or data buffer specified in this parameter block is split along\npacketLength\nboundaries to form the individual packets of the transfer.\nRecipient\nEnum\n\"device\" \"interface\" \"endpoint\" \"other\"\nRequestType\nEnum\n\"standard\" \"class\" \"vendor\" \"reserved\"\nSynchronizationType\nFor interrupt and isochronous modes, SynchronizationType and UsageType map to their namesakes within the USB specification.\nEnum\n\"asynchronous\" \"adaptive\" \"synchronous\"\nTransferResultInfo\nProperties\n-\ndata\nArrayBuffer optional\nThe data returned by an input transfer.\nundefined\nfor output transfers. -\nresultCode\nnumber optional\nA value of\n0\nindicates that the transfer was a success. Other values indicate failure.\nTransferType\nEnum\n\"control\" \"interrupt\" \"isochronous\" \"bulk\"\nUsageType\nEnum\n\"data\" \"feedback\" \"explicitFeedback\" \"periodic\" \"notification\"\nMethods\nbulkTransfer()\nchrome.usb.bulkTransfer(\nhandle: ConnectionHandle,\ntransferInfo: GenericTransferInfo,\ncallback?: function,\n)\nPerforms a bulk transfer on the specified device.\nParameters\n-\nhandle\nAn open connection to the device.\n-\ntransferInfo\nThe transfer parameters.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(info: TransferResultInfo) => void\n-\ninfo\n-\nReturns\n-\nPromise<TransferResultInfo>\nChrome 116+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nclaimInterface()\nchrome.usb.claimInterface(\nhandle: ConnectionHandle,\ninterfaceNumber: number,\ncallback?: function,\n)\nClaims an interface on a USB device. Before data can be transfered to an interface or associated endpoints the interface must be claimed. Only one connection handle can claim an interface at any given time. If the interface is already claimed, this call will fail.\nreleaseInterface\nshould be called when the interface is no longer needed.\nParameters\n-\nhandle\nAn open connection to the device.\n-\ninterfaceNumber\nnumber\nThe interface to be claimed.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 116+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\ncloseDevice()\nchrome.usb.closeDevice(\nhandle: ConnectionHandle,\ncallback?: function,\n)\nCloses a connection handle. Invoking operations on a handle after it has been closed is a safe operation but causes no action to be taken.\nParameters\n-\nhandle\nThe\nConnectionHandle\nto close. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 116+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\ncontrolTransfer()\nchrome.usb.controlTransfer(\nhandle: ConnectionHandle,\ntransferInfo: ControlTransferInfo,\ncallback?: function,\n)\nPerforms a control transfer on the specified device.\nControl transfers refer to either the device, an interface or an endpoint. Transfers to an interface or endpoint require the interface to be claimed.\nParameters\n-\nhandle\nAn open connection to the device.\n-\ntransferInfo\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(info: TransferResultInfo) => void\n-\ninfo\n-\nReturns\n-\nPromise<TransferResultInfo>\nChrome 116+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nfindDevices()\nchrome.usb.findDevices(\noptions: EnumerateDevicesAndRequestAccessOptions,\ncallback?: function,\n)\nFinds USB devices specified by the vendor, product and (optionally) interface IDs and if permissions allow opens them for use.\nIf the access request is rejected or the device fails to be opened a connection handle will not be created or returned.\nCalling this method is equivalent to calling getDevices\nfollowed by openDevice\nfor each device.\nParameters\n-\nThe properties to search for on target devices.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(handles: ConnectionHandle[]) => void\n-\nhandles\n-\nReturns\n-\nPromise<ConnectionHandle[]>\nChrome 116+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\ngetConfiguration()\nchrome.usb.getConfiguration(\nhandle: ConnectionHandle,\ncallback?: function,\n)\nGets the configuration descriptor for the currently selected configuration.\nParameters\n-\nhandle\nAn open connection to the device.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(config: ConfigDescriptor) => void\n-\nconfig\n-\nReturns\n-\nPromise<ConfigDescriptor>\nChrome 116+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\ngetConfigurations()\nchrome.usb.getConfigurations(\ndevice: Device,\ncallback?: function,\n)\nReturns the full set of device configuration descriptors.\nParameters\n-\ndevice\nThe\nDevice\nto fetch descriptors from. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(configs: ConfigDescriptor[]) => void\n-\nconfigs\n-\nReturns\n-\nPromise<ConfigDescriptor[]>\nChrome 116+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\ngetDevices()\nchrome.usb.getDevices(\noptions: EnumerateDevicesOptions,\ncallback?: function,\n)\nEnumerates connected USB devices.\nParameters\nReturns\n-\nPromise<Device[]>\nChrome 116+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\ngetUserSelectedDevices()\nchrome.usb.getUserSelectedDevices(\noptions: DevicePromptOptions,\ncallback?: function,\n)\nPresents a device picker to the user and returns the Device\ns selected. If the user cancels the picker devices will be empty. A user gesture is required for the dialog to display. Without a user gesture, the callback will run as though the user cancelled.\nParameters\nReturns\n-\nPromise<Device[]>\nChrome 116+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\ninterruptTransfer()\nchrome.usb.interruptTransfer(\nhandle: ConnectionHandle,\ntransferInfo: GenericTransferInfo,\ncallback?: function,\n)\nPerforms an interrupt transfer on the specified device.\nParameters\n-\nhandle\nAn open connection to the device.\n-\ntransferInfo\nThe transfer parameters.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(info: TransferResultInfo) => void\n-\ninfo\n-\nReturns\n-\nPromise<TransferResultInfo>\nChrome 116+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nisochronousTransfer()\nchrome.usb.isochronousTransfer(\nhandle: ConnectionHandle,\ntransferInfo: IsochronousTransferInfo,\ncallback?: function,\n)\nPerforms an isochronous transfer on the specific device.\nParameters\n-\nhandle\nAn open connection to the device.\n-\ntransferInfo\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(info: TransferResultInfo) => void\n-\ninfo\n-\nReturns\n-\nPromise<TransferResultInfo>\nChrome 116+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nlistInterfaces()\nchrome.usb.listInterfaces(\nhandle: ConnectionHandle,\ncallback?: function,\n)\nLists all interfaces on a USB device.\nParameters\n-\nhandle\nAn open connection to the device.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(descriptors: InterfaceDescriptor[]) => void\n-\ndescriptors\n-\nReturns\n-\nPromise<InterfaceDescriptor[]>\nChrome 116+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nopenDevice()\nchrome.usb.openDevice(\ndevice: Device,\ncallback?: function,\n)\nOpens a USB device returned by getDevices\n.\nParameters\n-\ndevice\nThe\nDevice\nto open. -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(handle: ConnectionHandle) => void\n-\nhandle\n-\nReturns\n-\nPromise<ConnectionHandle>\nChrome 116+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nreleaseInterface()\nchrome.usb.releaseInterface(\nhandle: ConnectionHandle,\ninterfaceNumber: number,\ncallback?: function,\n)\nReleases a claimed interface.\nParameters\n-\nhandle\nAn open connection to the device.\n-\ninterfaceNumber\nnumber\nThe interface to be released.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 116+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nrequestAccess()\nchrome.usb.requestAccess(\ndevice: Device,\ninterfaceId: number,\ncallback?: function,\n)\nThis function was Chrome OS specific and calling it on other platforms would fail. This operation is now implicitly performed as part of openDevice\nand this function will return true\non all platforms.\nRequests access from the permission broker to a device claimed by Chrome OS if the given interface on the device is not claimed.\nParameters\n-\ndevice\nThe\nDevice\nto request access to. -\ninterfaceId\nnumber\nThe particular interface requested.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(success: boolean) => void\n-\nsuccess\nboolean\n-\nReturns\n-\nPromise<boolean>\nChrome 116+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nresetDevice()\nchrome.usb.resetDevice(\nhandle: ConnectionHandle,\ncallback?: function,\n)\nTries to reset the USB device. If the reset fails, the given connection handle will be closed and the USB device will appear to be disconnected then reconnected. In this case getDevices\nor findDevices\nmust be called again to acquire the device.\nParameters\n-\nhandle\nA connection handle to reset.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(success: boolean) => void\n-\nsuccess\nboolean\n-\nReturns\n-\nPromise<boolean>\nChrome 116+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nsetConfiguration()\nchrome.usb.setConfiguration(\nhandle: ConnectionHandle,\nconfigurationValue: number,\ncallback?: function,\n)\nSelect a device configuration.\nThis function effectively resets the device by selecting one of the device's available configurations. Only configuration values greater than 0\nare valid however some buggy devices have a working configuration 0\nand so this value is allowed.\nParameters\n-\nhandle\nAn open connection to the device.\n-\nconfigurationValue\nnumber\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 116+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nsetInterfaceAlternateSetting()\nchrome.usb.setInterfaceAlternateSetting(\nhandle: ConnectionHandle,\ninterfaceNumber: number,\nalternateSetting: number,\ncallback?: function,\n)\nSelects an alternate setting on a previously claimed interface.\nParameters\n-\nhandle\nAn open connection to the device where this interface has been claimed.\n-\ninterfaceNumber\nnumber\nThe interface to configure.\n-\nalternateSetting\nnumber\nThe alternate setting to configure.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 116+Promises are only supported for Manifest V3 and later, other platforms need to use callbacks.\nEvents\nonDeviceAdded\nchrome.usb.onDeviceAdded.addListener(\ncallback: function,\n)\nEvent generated when a device is added to the system. Events are only broadcast to apps and extensions that have permission to access the device. Permission may have been granted at install time, when the user accepted an optional permission (see permissions.request\n), or through getUserSelectedDevices\n.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(device: Device) => void\n-\ndevice\n-\nonDeviceRemoved\nchrome.usb.onDeviceRemoved.addListener(\ncallback: function,\n)\nEvent generated when a device is removed from the system. See onDeviceAdded\nfor which events are delivered."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/vpnProvider", "title": "chrome.vpnProvider | API | Chrome for Developers", "text": "Description\nUse the chrome.vpnProvider\nAPI to implement a VPN client.\nPermissions\nvpnProvider\nAvailability\nConcepts and usage\nTypical usage of chrome.vpnProvider\nis as follows:\nCreate VPN configurations by calling\ncreateConfig()\n. A VPN configuration is a persistent entry shown to the user in a ChromeOS UI. The user can select a VPN configuration from a list and connect to it or disconnect from it.Add listeners to the\nonPlatformMessage\n,onPacketReceived\n, andonConfigRemoved\nevents.When the user connects to the VPN configuration,\nonPlatformMessage\nwill be received with the message\"connected\"\n. The period between the\"connected\"\nand\"disconnected\"\nmessages is called a \"VPN session\". In this time period, the extension that receives the message is said to own the VPN session.Initiate connection to the VPN server and start the VPN client.\nSet the Parameters of the connection by calling\nsetParameters()\n.Notify the connection state as\n\"connected\"\nby callingnotifyConnectionStateChanged()\n.When the steps previous are completed without errors, a virtual tunnel is created to the network stack of ChromeOS. IP packets can be sent through the tunnel by calling\nsendPacket()\nand any packets originating on the ChromeOS device will be received using theonPacketReceived\nevent handler.When the user disconnects from the VPN configuration,\nonPlatformMessage\nwill be fired with the message\"disconnected\"\n.If the VPN configuration is no longer necessary, it can be destroyed by calling\ndestroyConfig()\n.\nTypes\nParameters\nProperties\n-\naddress\nstring\nIP address for the VPN interface in CIDR notation. IPv4 is currently the only supported mode.\n-\nbroadcastAddress\nstring optional\nBroadcast address for the VPN interface. (default: deduced from IP address and mask)\n-\ndnsServers\nstring[]\nA list of IPs for the DNS servers.\n-\ndomainSearch\nstring[] optional\nA list of search domains. (default: no search domain)\n-\nexclusionList\nstring[]\nExclude network traffic to the list of IP blocks in CIDR notation from the tunnel. This can be used to bypass traffic to and from the VPN server. When many rules match a destination, the rule with the longest matching prefix wins. Entries that correspond to the same CIDR block are treated as duplicates. Such duplicates in the collated (exclusionList + inclusionList) list are eliminated and the exact duplicate entry that will be eliminated is undefined.\n-\ninclusionList\nstring[]\nInclude network traffic to the list of IP blocks in CIDR notation to the tunnel. This parameter can be used to set up a split tunnel. By default no traffic is directed to the tunnel. Adding the entry \"0.0.0.0/0\" to this list gets all the user traffic redirected to the tunnel. When many rules match a destination, the rule with the longest matching prefix wins. Entries that correspond to the same CIDR block are treated as duplicates. Such duplicates in the collated (exclusionList + inclusionList) list are eliminated and the exact duplicate entry that will be eliminated is undefined.\n-\nmtu\nstring optional\nMTU setting for the VPN interface. (default: 1500 bytes)\n-\nreconnect\nstring optional\nChrome 51+Whether or not the VPN extension implements auto-reconnection.\nIf true, the\nlinkDown\n,linkUp\n,linkChanged\n,suspend\n, andresume\nplatform messages will be used to signal the respective events. If false, the system will forcibly disconnect the VPN if the network topology changes, and the user will need to reconnect manually. (default: false)This property is new in Chrome 51; it will generate an exception in earlier versions. try/catch can be used to conditionally enable the feature based on browser support.\nPlatformMessage\nThe enum is used by the platform to notify the client of the VPN session status.\nEnum\n\"connected\" \"disconnected\" \"error\" \"linkDown\" \"linkUp\" \"linkChanged\" \"suspend\" \"resume\"\nIndicates that the VPN configuration connected.\nIndicates that the VPN configuration disconnected.\nIndicates that an error occurred in VPN connection, for example a timeout. A description of the error is given as the error argument to onPlatformMessage.\nIndicates that the default physical network connection is down.\nIndicates that the default physical network connection is back up.\nIndicates that the default physical network connection changed, e.g. wifi->mobile.\nIndicates that the OS is preparing to suspend, so the VPN should drop its connection. The extension is not guaranteed to receive this event prior to suspending.\nIndicates that the OS has resumed and the user has logged back in, so the VPN should try to reconnect.\nUIEvent\nThe enum is used by the platform to indicate the event that triggered onUIEvent\n.\nEnum\n\"showAddDialog\" \"showConfigureDialog\"\nRequests that the VPN client show the add configuration dialog box to the user.\nRequests that the VPN client show the configuration settings dialog box to the user.\nVpnConnectionState\nThe enum is used by the VPN client to inform the platform of its current state. This helps provide meaningful messages to the user.\nEnum\n\"connected\" \"failure\"\nSpecifies that VPN connection was successful.\nSpecifies that VPN connection has failed.\nMethods\ncreateConfig()\nchrome.vpnProvider.createConfig(\nname: string,\ncallback?: function,\n)\nCreates a new VPN configuration that persists across multiple login sessions of the user.\nParameters\n-\nname\nstring\nThe name of the VPN configuration.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(id: string) => void\n-\nid\nstring\nA unique ID for the created configuration, or\nundefined\non failure.\n-\nReturns\n-\nPromise<string>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ndestroyConfig()\nchrome.vpnProvider.destroyConfig(\nid: string,\ncallback?: function,\n)\nDestroys a VPN configuration created by the extension.\nParameters\n-\nid\nstring\nID of the VPN configuration to destroy.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nnotifyConnectionStateChanged()\nchrome.vpnProvider.notifyConnectionStateChanged(\nstate: VpnConnectionState,\ncallback?: function,\n)\nNotifies the VPN session state to the platform. This will succeed only when the VPN session is owned by the extension.\nParameters\n-\nstate\nThe VPN session state of the VPN client.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsendPacket()\nchrome.vpnProvider.sendPacket(\ndata: ArrayBuffer,\ncallback?: function,\n)\nSends an IP packet through the tunnel created for the VPN session. This will succeed only when the VPN session is owned by the extension.\nParameters\n-\ndata\nArrayBuffer\nThe IP packet to be sent to the platform.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nsetParameters()\nchrome.vpnProvider.setParameters(\nparameters: Parameters,\ncallback?: function,\n)\nSets the parameters for the VPN session. This should be called immediately after \"connected\"\nis received from the platform. This will succeed only when the VPN session is owned by the extension.\nParameters\n-\nparameters\nThe parameters for the VPN session.\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 96+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonConfigCreated\nchrome.vpnProvider.onConfigCreated.addListener(\ncallback: function,\n)\nTriggered when a configuration is created by the platform for the extension.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(id: string, name: string, data: object) => void\n-\nid\nstring\n-\nname\nstring\n-\ndata\nobject\n-\nonConfigRemoved\nchrome.vpnProvider.onConfigRemoved.addListener(\ncallback: function,\n)\nTriggered when a configuration created by the extension is removed by the platform.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(id: string) => void\n-\nid\nstring\n-\nonPacketReceived\nchrome.vpnProvider.onPacketReceived.addListener(\ncallback: function,\n)\nTriggered when an IP packet is received via the tunnel for the VPN session owned by the extension.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(data: ArrayBuffer) => void\n-\ndata\nArrayBuffer\n-\nonPlatformMessage\nchrome.vpnProvider.onPlatformMessage.addListener(\ncallback: function,\n)\nTriggered when a message is received from the platform for a VPN configuration owned by the extension.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(id: string, message: PlatformMessage, error: string) => void\n-\nid\nstring\n-\nmessage\n-\nerror\nstring\n-\nonUIEvent\nchrome.vpnProvider.onUIEvent.addListener(\ncallback: function,\n)\nTriggered when there is a UI event for the extension. UI events are signals from the platform that indicate to the app that a UI dialog needs to be shown to the user."},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/webNavigation", "title": "chrome.webNavigation | API | Chrome for Developers", "text": "Description\nUse the chrome.webNavigation\nAPI to receive notifications about the status of navigation requests in-flight.\nPermissions\nwebNavigation\nAll chrome.webNavigation\nmethods and events require you to declare the \"webNavigation\"\npermission\nin the extension manifest. For example:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"webNavigation\"\n],\n...\n}\nConcepts and usage\nEvent order\nFor a navigation that is successfully completed, events are fired in the following order:\nonBeforeNavigate -> onCommitted -> [onDOMContentLoaded] -> onCompleted\nAny error that occurs during the process results in an onErrorOccurred\nevent. For a specific\nnavigation, there are no further events fired after onErrorOccurred\n.\nIf a navigating frame contains subframes, its onCommitted\nis fired before any of its children's\nonBeforeNavigate\n; while onCompleted\nis fired after all of its children's onCompleted\n.\nIf the reference fragment of a frame is changed, a onReferenceFragmentUpdated\nevent is fired. This\nevent can fire any time after onDOMContentLoaded\n, even after onCompleted\n.\nIf the history API is used to modify the state of a frame (e.g. using history.pushState()\n, a\nonHistoryStateUpdated\nevent is fired. This event can fire any time after onDOMContentLoaded\n.\nIf a navigation restored a page from the Back Forward Cache, the onDOMContentLoaded\nevent\nwon't fire. The event is not fired because the content has already completed load when the page\nwas first visited.\nIf a navigation was triggered using Chrome Instant or Instant Pages, a completely loaded\npage is swapped into the current tab. In that case, an onTabReplaced\nevent is fired.\nRelation to webRequest events\nThere is no defined ordering between events of the webRequest API and the events of the webNavigation API. It is possible that webRequest events are still received for frames that already started a new navigation, or that a navigation only proceeds after the network resources are already fully loaded.\nIn general, the webNavigation events are closely related to the navigation state that is displayed in the UI, while the webRequest events correspond to the state of the network stack which is generally opaque to the user.\nTab IDs\nNot all navigating tabs correspond to actual tabs in Chrome's UI, for example, a tab that is being\npre-rendered. Such tabs are not accessible using the tabs API nor can you request information\nabout them by calling webNavigation.getFrame()\nor webNavigation.getAllFrames()\n. Once such a tab\nis swapped in, an onTabReplaced\nevent is fired and they become accessible through these APIs.\nTimestamps\nIt's important to note that some technical oddities in the OS's handling of distinct Chrome\nprocesses can cause the clock to be skewed between the browser itself and extension processes. That\nmeans that the timeStamp\nproperty of the WebNavigation\nevent timeStamp\nproperty is only guaranteed\nto be internally consistent. Comparing one event to another event will give you the correct offset\nbetween them, but comparing them to the current time inside the extension (using (new Date()).getTime()\n,\nfor instance) might give unexpected results.\nFrame IDs\nFrames within a tab can be identified by a frame ID. The frame ID of the main frame is always 0, the ID of child frames is a positive number. Once a document is constructed in a frame, its frame ID remains constant during the lifetime of the document. As of Chrome 49, this ID is also constant for the lifetime of the frame (across multiple navigations).\nDue to the multi-process nature of Chrome, a tab might use different processes to render the source\nand destination of a web page. Therefore, if a navigation takes place in a new process, you might\nreceive events both from the new and the old page until the new navigation is committed (i.e. the\nonCommitted\nevent is sent for the new main frame). In other words, it is possible to have more\nthan one pending sequence of webNavigation events with the same frameId\n. The sequences can be\ndistinguished by the processId\nkey.\nAlso note that during a provisional load the process might be switched several times. This happens\nwhen the load is redirected to a different site. In this case, you will receive repeated\nonBeforeNavigate\nand onErrorOccurred\nevents, until you receive the final onCommitted\nevent.\nAnother concept that is problematic with extensions is the lifecycle of the frame. A frame hosts a document (which is associated with a committed URL). The document can change (say by navigating) but the frameId won't, and so it is difficult to associate that something happened in a specific document with just frameIds. We are introducing a concept of a documentId which is a unique identifier per document. If a frame is navigated and opens a new document the identifier will change. This field is useful for determining when pages change their lifecycle state (between prerender/active/cached) because it remains the same.\nTransition types and qualifiers\nThe webNavigation\nonCommitted\nevent has a transitionType\nand a transitionQualifiers\nproperty. The transition type is the same as used in the history API describing how the\nbrowser navigated to this particular URL. In addition, several transition qualifiers can be\nreturned that further define the navigation.\nThe following transition qualifiers exist:\n| Transition qualifier | Description |\n|---|---|\n| \"client_redirect\" | One or more redirects caused by JavaScript or meta refresh tags on the page happened during the navigation. |\n| \"server_redirect\" | One or more redirects caused by HTTP headers sent from the server happened during the navigation. |\n| \"forward_back\" | The user used the Forward or Back button to initiate the navigation. |\n| \"from_address_bar\" | The user initiated the navigation from the address bar (aka Omnibox). |\nExamples\nTo try this API, install the webNavigation API example from the chrome-extension-samples repository.\nTypes\nTransitionQualifier\nEnum\n\"client_redirect\" \"server_redirect\" \"forward_back\" \"from_address_bar\"\nTransitionType\nCause of the navigation. The same transition types as defined in the history API are used. These are the same transition types as defined in the history API except with \"start_page\"\nin place of \"auto_toplevel\"\n(for backwards compatibility).\nEnum\n\"link\" \"typed\" \"auto_bookmark\" \"auto_subframe\" \"manual_subframe\" \"generated\" \"start_page\" \"form_submit\" \"reload\" \"keyword\" \"keyword_generated\"\nMethods\ngetAllFrames()\nchrome.webNavigation.getAllFrames(\ndetails: object,\ncallback?: function,\n)\nRetrieves information about all frames of a given tab.\nParameters\n-\ndetails\nobject\nInformation about the tab to retrieve all frames from.\n-\ntabId\nnumber\nThe ID of the tab.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(details?: object[]) => void\n-\ndetails\nobject[] optional\nA list of frames in the given tab, null if the specified tab ID is invalid.\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nerrorOccurred\nboolean\nTrue if the last navigation in this frame was interrupted by an error, i.e. the onErrorOccurred event fired.\n-\nframeId\nnumber\nThe ID of the frame. 0 indicates that this is the main frame; a positive value indicates the ID of a subframe.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nThe ID of the parent frame, or\n-1\nif this is the main frame. -\nprocessId\nnumber\nThe ID of the process that runs the renderer for this frame.\n-\nurl\nstring\nThe URL currently associated with this frame.\n-\n-\nReturns\n-\nPromise<object[] | undefined>\nChrome 93+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetFrame()\nchrome.webNavigation.getFrame(\ndetails: object,\ncallback?: function,\n)\nRetrieves information about the given frame. A frame refers to an <iframe> or a <frame> of a web page and is identified by a tab ID and a frame ID.\nParameters\n-\ndetails\nobject\nInformation about the frame to retrieve information about.\n-\ndocumentId\nstring optional\nChrome 106+The UUID of the document. If the frameId and/or tabId are provided they will be validated to match the document found by provided document ID.\n-\nframeId\nnumber optional\nThe ID of the frame in the given tab.\n-\nprocessId\nnumber optional\nDeprecated since Chrome 49Frames are now uniquely identified by their tab ID and frame ID; the process ID is no longer needed and therefore ignored.\nThe ID of the process that runs the renderer for this tab.\n-\ntabId\nnumber optional\nThe ID of the tab in which the frame is.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(details?: object) => void\n-\ndetails\nobject optional\nInformation about the requested frame, null if the specified frame ID and/or tab ID are invalid.\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nerrorOccurred\nboolean\nTrue if the last navigation in this frame was interrupted by an error, i.e. the onErrorOccurred event fired.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nThe ID of the parent frame, or\n-1\nif this is the main frame. -\nurl\nstring\nThe URL currently associated with this frame, if the frame identified by the frameId existed at one point in the given tab. The fact that an URL is associated with a given frameId does not imply that the corresponding frame still exists.\n-\n-\nReturns\n-\nPromise<object | undefined>\nChrome 93+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonBeforeNavigate\nchrome.webNavigation.onBeforeNavigate.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when a navigation is about to occur.\nParameters\n-\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\nobject\n-\nChrome 106+\nThe lifecycle the document is in.\n-\nnumber\n0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique for a given tab and process.\n-\nChrome 106+\nThe type of frame the navigation occurred in.\n-\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nnumber\nThe ID of the parent frame, or\n-1\nif this is the main frame. -\nnumber\nDeprecated since Chrome 50The processId is no longer set for this event, since the process which will render the resulting document is not known until onCommit.\nThe value of -1.\n-\nnumber\nThe ID of the tab in which the navigation is about to occur.\n-\nnumber\nThe time when the browser was about to start the navigation, in milliseconds since the epoch.\n-\nstring\n-\n-\n-\nobject optional\n-\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonCommitted\nchrome.webNavigation.onCommitted.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when a navigation is committed. The document (and the resources it refers to, such as images and subframes) might still be downloading, but at least part of the document has been received from the server and the browser has decided to switch to the new document.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\n0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique within a tab.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nChrome 74+The ID of the parent frame, or\n-1\nif this is the main frame. -\nprocessId\nnumber\nThe ID of the process that runs the renderer for this frame.\n-\ntabId\nnumber\nThe ID of the tab in which the navigation occurs.\n-\ntimeStamp\nnumber\nThe time when the navigation was committed, in milliseconds since the epoch.\n-\ntransitionQualifiers\nA list of transition qualifiers.\n-\ntransitionType\nCause of the navigation.\n-\nurl\nstring\n-\n-\n-\nfilters\nobject optional\n-\nurl\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonCompleted\nchrome.webNavigation.onCompleted.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when a document, including the resources it refers to, is completely loaded and initialized.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\n0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique within a tab.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nChrome 74+The ID of the parent frame, or\n-1\nif this is the main frame. -\nprocessId\nnumber\nThe ID of the process that runs the renderer for this frame.\n-\ntabId\nnumber\nThe ID of the tab in which the navigation occurs.\n-\ntimeStamp\nnumber\nThe time when the document finished loading, in milliseconds since the epoch.\n-\nurl\nstring\n-\n-\n-\nfilters\nobject optional\n-\nurl\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonCreatedNavigationTarget\nchrome.webNavigation.onCreatedNavigationTarget.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when a new window, or a new tab in an existing window, is created to host a navigation.\nParameters\n-\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\nobject\n-\nnumber\nThe ID of the frame with sourceTabId in which the navigation is triggered. 0 indicates the main frame.\n-\nnumber\nThe ID of the process that runs the renderer for the source frame.\n-\nnumber\nThe ID of the tab in which the navigation is triggered.\n-\nnumber\nThe ID of the tab in which the url is opened\n-\nnumber\nThe time when the browser was about to create a new view, in milliseconds since the epoch.\n-\nstring\nThe URL to be opened in the new window.\n-\n-\n-\nobject optional\n-\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonDOMContentLoaded\nchrome.webNavigation.onDOMContentLoaded.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when the page's DOM is fully constructed, but the referenced resources may not finish loading.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\n0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique within a tab.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nChrome 74+The ID of the parent frame, or\n-1\nif this is the main frame. -\nprocessId\nnumber\nThe ID of the process that runs the renderer for this frame.\n-\ntabId\nnumber\nThe ID of the tab in which the navigation occurs.\n-\ntimeStamp\nnumber\nThe time when the page's DOM was fully constructed, in milliseconds since the epoch.\n-\nurl\nstring\n-\n-\n-\nfilters\nobject optional\n-\nurl\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonErrorOccurred\nchrome.webNavigation.onErrorOccurred.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when an error occurs and the navigation is aborted. This can happen if either a network error occurred, or the user aborted the navigation.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nerror\nstring\nThe error description.\n-\nframeId\nnumber\n0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique within a tab.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nChrome 74+The ID of the parent frame, or\n-1\nif this is the main frame. -\nprocessId\nnumber\nDeprecated since Chrome 50The processId is no longer set for this event.\nThe value of -1.\n-\ntabId\nnumber\nThe ID of the tab in which the navigation occurs.\n-\ntimeStamp\nnumber\nThe time when the error occurred, in milliseconds since the epoch.\n-\nurl\nstring\n-\n-\n-\nfilters\nobject optional\n-\nurl\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonHistoryStateUpdated\nchrome.webNavigation.onHistoryStateUpdated.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when the frame's history was updated to a new URL. All future events for that frame will use the updated URL.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\n0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique within a tab.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nChrome 74+The ID of the parent frame, or\n-1\nif this is the main frame. -\nprocessId\nnumber\nThe ID of the process that runs the renderer for this frame.\n-\ntabId\nnumber\nThe ID of the tab in which the navigation occurs.\n-\ntimeStamp\nnumber\nThe time when the navigation was committed, in milliseconds since the epoch.\n-\ntransitionQualifiers\nA list of transition qualifiers.\n-\ntransitionType\nCause of the navigation.\n-\nurl\nstring\n-\n-\n-\nfilters\nobject optional\n-\nurl\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonReferenceFragmentUpdated\nchrome.webNavigation.onReferenceFragmentUpdated.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when the reference fragment of a frame was updated. All future events for that frame will use the updated URL.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\n0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique within a tab.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nChrome 74+The ID of the parent frame, or\n-1\nif this is the main frame. -\nprocessId\nnumber\nThe ID of the process that runs the renderer for this frame.\n-\ntabId\nnumber\nThe ID of the tab in which the navigation occurs.\n-\ntimeStamp\nnumber\nThe time when the navigation was committed, in milliseconds since the epoch.\n-\ntransitionQualifiers\nA list of transition qualifiers.\n-\ntransitionType\nCause of the navigation.\n-\nurl\nstring\n-\n-\n-\nfilters\nobject optional\n-\nurl\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonTabReplaced\nchrome.webNavigation.onTabReplaced.addListener(\ncallback: function,\n)\nFired when the contents of the tab is replaced by a different (usually previously pre-rendered) tab.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nreplacedTabId\nnumber\nThe ID of the tab that was replaced.\n-\ntabId\nnumber\nThe ID of the tab that replaced the old tab.\n-\ntimeStamp\nnumber\nThe time when the replacement happened, in milliseconds since the epoch.\n-\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/webNavigation", "title": "chrome.webNavigation | API | Chrome for Developers", "text": "Description\nUse the chrome.webNavigation\nAPI to receive notifications about the status of navigation requests in-flight.\nPermissions\nwebNavigation\nAll chrome.webNavigation\nmethods and events require you to declare the \"webNavigation\"\npermission\nin the extension manifest. For example:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"webNavigation\"\n],\n...\n}\nConcepts and usage\nEvent order\nFor a navigation that is successfully completed, events are fired in the following order:\nonBeforeNavigate -> onCommitted -> [onDOMContentLoaded] -> onCompleted\nAny error that occurs during the process results in an onErrorOccurred\nevent. For a specific\nnavigation, there are no further events fired after onErrorOccurred\n.\nIf a navigating frame contains subframes, its onCommitted\nis fired before any of its children's\nonBeforeNavigate\n; while onCompleted\nis fired after all of its children's onCompleted\n.\nIf the reference fragment of a frame is changed, a onReferenceFragmentUpdated\nevent is fired. This\nevent can fire any time after onDOMContentLoaded\n, even after onCompleted\n.\nIf the history API is used to modify the state of a frame (e.g. using history.pushState()\n, a\nonHistoryStateUpdated\nevent is fired. This event can fire any time after onDOMContentLoaded\n.\nIf a navigation restored a page from the Back Forward Cache, the onDOMContentLoaded\nevent\nwon't fire. The event is not fired because the content has already completed load when the page\nwas first visited.\nIf a navigation was triggered using Chrome Instant or Instant Pages, a completely loaded\npage is swapped into the current tab. In that case, an onTabReplaced\nevent is fired.\nRelation to webRequest events\nThere is no defined ordering between events of the webRequest API and the events of the webNavigation API. It is possible that webRequest events are still received for frames that already started a new navigation, or that a navigation only proceeds after the network resources are already fully loaded.\nIn general, the webNavigation events are closely related to the navigation state that is displayed in the UI, while the webRequest events correspond to the state of the network stack which is generally opaque to the user.\nTab IDs\nNot all navigating tabs correspond to actual tabs in Chrome's UI, for example, a tab that is being\npre-rendered. Such tabs are not accessible using the tabs API nor can you request information\nabout them by calling webNavigation.getFrame()\nor webNavigation.getAllFrames()\n. Once such a tab\nis swapped in, an onTabReplaced\nevent is fired and they become accessible through these APIs.\nTimestamps\nIt's important to note that some technical oddities in the OS's handling of distinct Chrome\nprocesses can cause the clock to be skewed between the browser itself and extension processes. That\nmeans that the timeStamp\nproperty of the WebNavigation\nevent timeStamp\nproperty is only guaranteed\nto be internally consistent. Comparing one event to another event will give you the correct offset\nbetween them, but comparing them to the current time inside the extension (using (new Date()).getTime()\n,\nfor instance) might give unexpected results.\nFrame IDs\nFrames within a tab can be identified by a frame ID. The frame ID of the main frame is always 0, the ID of child frames is a positive number. Once a document is constructed in a frame, its frame ID remains constant during the lifetime of the document. As of Chrome 49, this ID is also constant for the lifetime of the frame (across multiple navigations).\nDue to the multi-process nature of Chrome, a tab might use different processes to render the source\nand destination of a web page. Therefore, if a navigation takes place in a new process, you might\nreceive events both from the new and the old page until the new navigation is committed (i.e. the\nonCommitted\nevent is sent for the new main frame). In other words, it is possible to have more\nthan one pending sequence of webNavigation events with the same frameId\n. The sequences can be\ndistinguished by the processId\nkey.\nAlso note that during a provisional load the process might be switched several times. This happens\nwhen the load is redirected to a different site. In this case, you will receive repeated\nonBeforeNavigate\nand onErrorOccurred\nevents, until you receive the final onCommitted\nevent.\nAnother concept that is problematic with extensions is the lifecycle of the frame. A frame hosts a document (which is associated with a committed URL). The document can change (say by navigating) but the frameId won't, and so it is difficult to associate that something happened in a specific document with just frameIds. We are introducing a concept of a documentId which is a unique identifier per document. If a frame is navigated and opens a new document the identifier will change. This field is useful for determining when pages change their lifecycle state (between prerender/active/cached) because it remains the same.\nTransition types and qualifiers\nThe webNavigation\nonCommitted\nevent has a transitionType\nand a transitionQualifiers\nproperty. The transition type is the same as used in the history API describing how the\nbrowser navigated to this particular URL. In addition, several transition qualifiers can be\nreturned that further define the navigation.\nThe following transition qualifiers exist:\n| Transition qualifier | Description |\n|---|---|\n| \"client_redirect\" | One or more redirects caused by JavaScript or meta refresh tags on the page happened during the navigation. |\n| \"server_redirect\" | One or more redirects caused by HTTP headers sent from the server happened during the navigation. |\n| \"forward_back\" | The user used the Forward or Back button to initiate the navigation. |\n| \"from_address_bar\" | The user initiated the navigation from the address bar (aka Omnibox). |\nExamples\nTo try this API, install the webNavigation API example from the chrome-extension-samples repository.\nTypes\nTransitionQualifier\nEnum\n\"client_redirect\" \"server_redirect\" \"forward_back\" \"from_address_bar\"\nTransitionType\nCause of the navigation. The same transition types as defined in the history API are used. These are the same transition types as defined in the history API except with \"start_page\"\nin place of \"auto_toplevel\"\n(for backwards compatibility).\nEnum\n\"link\" \"typed\" \"auto_bookmark\" \"auto_subframe\" \"manual_subframe\" \"generated\" \"start_page\" \"form_submit\" \"reload\" \"keyword\" \"keyword_generated\"\nMethods\ngetAllFrames()\nchrome.webNavigation.getAllFrames(\ndetails: object,\ncallback?: function,\n)\nRetrieves information about all frames of a given tab.\nParameters\n-\ndetails\nobject\nInformation about the tab to retrieve all frames from.\n-\ntabId\nnumber\nThe ID of the tab.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(details?: object[]) => void\n-\ndetails\nobject[] optional\nA list of frames in the given tab, null if the specified tab ID is invalid.\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nerrorOccurred\nboolean\nTrue if the last navigation in this frame was interrupted by an error, i.e. the onErrorOccurred event fired.\n-\nframeId\nnumber\nThe ID of the frame. 0 indicates that this is the main frame; a positive value indicates the ID of a subframe.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nThe ID of the parent frame, or\n-1\nif this is the main frame. -\nprocessId\nnumber\nThe ID of the process that runs the renderer for this frame.\n-\nurl\nstring\nThe URL currently associated with this frame.\n-\n-\nReturns\n-\nPromise<object[] | undefined>\nChrome 93+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetFrame()\nchrome.webNavigation.getFrame(\ndetails: object,\ncallback?: function,\n)\nRetrieves information about the given frame. A frame refers to an <iframe> or a <frame> of a web page and is identified by a tab ID and a frame ID.\nParameters\n-\ndetails\nobject\nInformation about the frame to retrieve information about.\n-\ndocumentId\nstring optional\nChrome 106+The UUID of the document. If the frameId and/or tabId are provided they will be validated to match the document found by provided document ID.\n-\nframeId\nnumber optional\nThe ID of the frame in the given tab.\n-\nprocessId\nnumber optional\nDeprecated since Chrome 49Frames are now uniquely identified by their tab ID and frame ID; the process ID is no longer needed and therefore ignored.\nThe ID of the process that runs the renderer for this tab.\n-\ntabId\nnumber optional\nThe ID of the tab in which the frame is.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(details?: object) => void\n-\ndetails\nobject optional\nInformation about the requested frame, null if the specified frame ID and/or tab ID are invalid.\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nerrorOccurred\nboolean\nTrue if the last navigation in this frame was interrupted by an error, i.e. the onErrorOccurred event fired.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nThe ID of the parent frame, or\n-1\nif this is the main frame. -\nurl\nstring\nThe URL currently associated with this frame, if the frame identified by the frameId existed at one point in the given tab. The fact that an URL is associated with a given frameId does not imply that the corresponding frame still exists.\n-\n-\nReturns\n-\nPromise<object | undefined>\nChrome 93+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonBeforeNavigate\nchrome.webNavigation.onBeforeNavigate.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when a navigation is about to occur.\nParameters\n-\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\nobject\n-\nChrome 106+\nThe lifecycle the document is in.\n-\nnumber\n0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique for a given tab and process.\n-\nChrome 106+\nThe type of frame the navigation occurred in.\n-\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nnumber\nThe ID of the parent frame, or\n-1\nif this is the main frame. -\nnumber\nDeprecated since Chrome 50The processId is no longer set for this event, since the process which will render the resulting document is not known until onCommit.\nThe value of -1.\n-\nnumber\nThe ID of the tab in which the navigation is about to occur.\n-\nnumber\nThe time when the browser was about to start the navigation, in milliseconds since the epoch.\n-\nstring\n-\n-\n-\nobject optional\n-\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonCommitted\nchrome.webNavigation.onCommitted.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when a navigation is committed. The document (and the resources it refers to, such as images and subframes) might still be downloading, but at least part of the document has been received from the server and the browser has decided to switch to the new document.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\n0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique within a tab.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nChrome 74+The ID of the parent frame, or\n-1\nif this is the main frame. -\nprocessId\nnumber\nThe ID of the process that runs the renderer for this frame.\n-\ntabId\nnumber\nThe ID of the tab in which the navigation occurs.\n-\ntimeStamp\nnumber\nThe time when the navigation was committed, in milliseconds since the epoch.\n-\ntransitionQualifiers\nA list of transition qualifiers.\n-\ntransitionType\nCause of the navigation.\n-\nurl\nstring\n-\n-\n-\nfilters\nobject optional\n-\nurl\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonCompleted\nchrome.webNavigation.onCompleted.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when a document, including the resources it refers to, is completely loaded and initialized.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\n0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique within a tab.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nChrome 74+The ID of the parent frame, or\n-1\nif this is the main frame. -\nprocessId\nnumber\nThe ID of the process that runs the renderer for this frame.\n-\ntabId\nnumber\nThe ID of the tab in which the navigation occurs.\n-\ntimeStamp\nnumber\nThe time when the document finished loading, in milliseconds since the epoch.\n-\nurl\nstring\n-\n-\n-\nfilters\nobject optional\n-\nurl\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonCreatedNavigationTarget\nchrome.webNavigation.onCreatedNavigationTarget.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when a new window, or a new tab in an existing window, is created to host a navigation.\nParameters\n-\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\nobject\n-\nnumber\nThe ID of the frame with sourceTabId in which the navigation is triggered. 0 indicates the main frame.\n-\nnumber\nThe ID of the process that runs the renderer for the source frame.\n-\nnumber\nThe ID of the tab in which the navigation is triggered.\n-\nnumber\nThe ID of the tab in which the url is opened\n-\nnumber\nThe time when the browser was about to create a new view, in milliseconds since the epoch.\n-\nstring\nThe URL to be opened in the new window.\n-\n-\n-\nobject optional\n-\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonDOMContentLoaded\nchrome.webNavigation.onDOMContentLoaded.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when the page's DOM is fully constructed, but the referenced resources may not finish loading.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\n0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique within a tab.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nChrome 74+The ID of the parent frame, or\n-1\nif this is the main frame. -\nprocessId\nnumber\nThe ID of the process that runs the renderer for this frame.\n-\ntabId\nnumber\nThe ID of the tab in which the navigation occurs.\n-\ntimeStamp\nnumber\nThe time when the page's DOM was fully constructed, in milliseconds since the epoch.\n-\nurl\nstring\n-\n-\n-\nfilters\nobject optional\n-\nurl\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonErrorOccurred\nchrome.webNavigation.onErrorOccurred.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when an error occurs and the navigation is aborted. This can happen if either a network error occurred, or the user aborted the navigation.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nerror\nstring\nThe error description.\n-\nframeId\nnumber\n0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique within a tab.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nChrome 74+The ID of the parent frame, or\n-1\nif this is the main frame. -\nprocessId\nnumber\nDeprecated since Chrome 50The processId is no longer set for this event.\nThe value of -1.\n-\ntabId\nnumber\nThe ID of the tab in which the navigation occurs.\n-\ntimeStamp\nnumber\nThe time when the error occurred, in milliseconds since the epoch.\n-\nurl\nstring\n-\n-\n-\nfilters\nobject optional\n-\nurl\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonHistoryStateUpdated\nchrome.webNavigation.onHistoryStateUpdated.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when the frame's history was updated to a new URL. All future events for that frame will use the updated URL.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\n0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique within a tab.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nChrome 74+The ID of the parent frame, or\n-1\nif this is the main frame. -\nprocessId\nnumber\nThe ID of the process that runs the renderer for this frame.\n-\ntabId\nnumber\nThe ID of the tab in which the navigation occurs.\n-\ntimeStamp\nnumber\nThe time when the navigation was committed, in milliseconds since the epoch.\n-\ntransitionQualifiers\nA list of transition qualifiers.\n-\ntransitionType\nCause of the navigation.\n-\nurl\nstring\n-\n-\n-\nfilters\nobject optional\n-\nurl\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonReferenceFragmentUpdated\nchrome.webNavigation.onReferenceFragmentUpdated.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when the reference fragment of a frame was updated. All future events for that frame will use the updated URL.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+A UUID of the document loaded.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\n0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique within a tab.\n-\nframeTypeChrome 106+\nThe type of frame the navigation occurred in.\n-\nparentDocumentId\nstring optional\nChrome 106+A UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nChrome 74+The ID of the parent frame, or\n-1\nif this is the main frame. -\nprocessId\nnumber\nThe ID of the process that runs the renderer for this frame.\n-\ntabId\nnumber\nThe ID of the tab in which the navigation occurs.\n-\ntimeStamp\nnumber\nThe time when the navigation was committed, in milliseconds since the epoch.\n-\ntransitionQualifiers\nA list of transition qualifiers.\n-\ntransitionType\nCause of the navigation.\n-\nurl\nstring\n-\n-\n-\nfilters\nobject optional\n-\nurl\nConditions that the URL being navigated to must satisfy. The 'schemes' and 'ports' fields of UrlFilter are ignored for this event.\n-\nonTabReplaced\nchrome.webNavigation.onTabReplaced.addListener(\ncallback: function,\n)\nFired when the contents of the tab is replaced by a different (usually previously pre-rendered) tab.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\nreplacedTabId\nnumber\nThe ID of the tab that was replaced.\n-\ntabId\nnumber\nThe ID of the tab that replaced the old tab.\n-\ntimeStamp\nnumber\nThe time when the replacement happened, in milliseconds since the epoch.\n-\n-"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/webRequest", "title": "chrome.webRequest | API | Chrome for Developers", "text": "Description\nUse the chrome.webRequest\nAPI to observe and analyze traffic and to intercept, block, or modify requests in-flight.\nPermissions\nwebRequest\nYou must declare the \"webRequest\"\npermission in the extension manifest to use the web request\nAPI, along with the necessary host permissions. To intercept a sub-resource request, the\nextension must have access to both the requested URL and its initiator. For example:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\n\"webRequest\"\n],\n\"host_permissions\": [\n\"*://*.google.com/*\"\n],\n...\n}\nwebRequestBlocking\nRequired to register blocking event handlers. As of Manifest V3, this is only available to policy installed extensions.\nwebRequestAuthProvider\nRequired to use the onAuthRequired\nmethod. See\nHandling authentication.\nConcepts and usage\nLife cycle of requests\nThe web request API defines a set of events that follow the life cycle of a web request. You can use these events to observe and analyze traffic. Certain synchronous events will allow you to intercept, block, or modify a request.\nThe event life cycle for successful requests is illustrated here, followed by event definitions:\nonBeforeRequest\n(optionally synchronous)- Fires when a request is about to occur. This event is sent before any TCP connection is made and can be used to cancel or redirect requests.\nonBeforeSendHeaders\n(optionally synchronous)- Fires when a request is about to occur and the initial headers have been prepared. The event is\nintended to allow extensions to add, modify, and delete request headers (*). The\nonBeforeSendHeaders\nevent is passed to all subscribers, so different subscribers may attempt to modify the request; see the Implementation details section for how this is handled. This event can be used to cancel the request. onSendHeaders\n- Fires after all extensions have had a chance to modify the request headers, and presents the final (*) version. The event is triggered before the headers are sent to the network. This event is informational and handled asynchronously. It does not allow modifying or cancelling the request.\nonHeadersReceived\n(optionally synchronous)- Fires each time that an HTTP(S) response header is received. Due to redirects and authentication requests this can happen multiple times per request. This event is intended to allow extensions to add, modify, and delete response headers, such as incoming Content-Type headers. The caching directives are processed before this event is triggered, so modifying headers such as Cache-Control has no influence on the browser's cache. It also allows you to cancel or redirect the request.\nonAuthRequired\n(optionally synchronous)- Fires when a request requires authentication of the user. This event can be handled synchronously to provide authentication credentials. Note that extensions may provide invalid credentials. Take care not to enter an infinite loop by repeatedly providing invalid credentials. This can also be used to cancel the request.\nonBeforeRedirect\n- Fires when a redirect is about to be executed. A redirection can be triggered by an HTTP response code or by an extension. This event is informational and handled asynchronously. It does not allow you to modify or cancel the request.\nonResponseStarted\n- Fires when the first byte of the response body is received. For HTTP requests, this means that the status line and response headers are available. This event is informational and handled asynchronously. It does not allow modifying or canceling the request.\nonCompleted\n- Fires when a request has been processed successfully.\nonErrorOccurred\n- Fires when a request could not be processed successfully.\nThe web request API guarantees that for each request, either onCompleted\nor onErrorOccurred\nis\nfired as the final event with one exception: If a request is redirected to a data://\nURL,\nonBeforeRedirect\nis the last reported event.\n* Note that the web request API presents an abstraction of the network stack to the extension. Internally, one URL request can be split into several HTTP requests (for example, to fetch individual byte ranges from a large file) or can be handled by the network stack without communicating with the network. For this reason, the API does not provide the final HTTP headers that are sent to the network. For example, all headers that are related to caching are invisible to the extension.\nThe following headers are currently not provided to the onBeforeSendHeaders\nevent. This list\nis not guaranteed to be complete or stable.\n- Authorization\n- Cache-Control\n- Connection\n- Content-Length\n- Host\n- If-Modified-Since\n- If-None-Match\n- If-Range\n- Partial-Data\n- Pragma\n- Proxy-Authorization\n- Proxy-Connection\n- Transfer-Encoding\nStarting from Chrome 79, request header modifications affect Cross-Origin Resource Sharing (CORS)\nchecks. If modified headers for cross-origin requests do not meet the criteria, it will result in\nsending a CORS preflight to ask the server if such headers can be accepted. If you really need to\nmodify headers in a way to violate the CORS protocol, you need to specify 'extraHeaders'\nin\nopt_extraInfoSpec\n. On the other hand, response header modifications do not work to deceive CORS\nchecks. If you need to deceive the CORS protocol, you also need to specify 'extraHeaders'\nfor the\nresponse modifications.\nStarting from Chrome 79, the webRequest API does not intercept CORS preflight requests and\nresponses by default. A CORS preflight for a request URL is visible to an extension if there is a\nlistener with 'extraHeaders'\nspecified in opt_extraInfoSpec\nfor the request URL.\nonBeforeRequest\ncan also take 'extraHeaders'\nfrom Chrome 79.\nStarting from Chrome 79, the following request header is not provided and cannot be modified or\nremoved without specifying 'extraHeaders'\nin opt_extraInfoSpec\n:\n- Origin\nStarting from Chrome 72, if you need to modify responses before Cross Origin Read Blocking\n(CORB) can block the response, you need to specify 'extraHeaders'\nin opt_extraInfoSpec\n.\nStarting from Chrome 72, the following request headers are not provided and cannot be modified\nor removed without specifying 'extraHeaders'\nin opt_extraInfoSpec\n:\n- Accept-Language\n- Accept-Encoding\n- Referer\n- Cookie\nStarting from Chrome 72, the Set-Cookie\nresponse header is not provided and cannot be modified\nor removed without specifying 'extraHeaders'\nin opt_extraInfoSpec\n.\nStarting from Chrome 89, the X-Frame-Options\nresponse header cannot be effectively modified\nor removed without specifying 'extraHeaders'\nin opt_extraInfoSpec\n.\nThe webRequest API only exposes requests that the extension has permission to see, given its host\npermissions. Moreover, only the following schemes are accessible: http://\n, https://\n,\nftp://\n, file://\n, ws://\n(since Chrome 58), wss://\n(since Chrome 58), urn:\n(since Chrome 91), or\nchrome-extension://\n. In addition, even certain requests with URLs using one of the above schemes\nare hidden. These include chrome-extension://other_extension_id\nwhere other_extension_id\nis not\nthe ID of the extension to handle the request, https://www.google.com/chrome\n, and other sensitive\nrequests core to browser functionality. Also synchronous XMLHttpRequests from your extension are\nhidden from blocking event handlers in order to prevent deadlocks. Note that for some of the\nsupported schemes the set of available events might be limited due to the nature of the\ncorresponding protocol. For example, for the file: scheme, only onBeforeRequest\n,\nonResponseStarted\n, onCompleted\n, and onErrorOccurred\nmay be dispatched.\nStarting from Chrome 58, the webRequest API supports intercepting the WebSocket handshake request. Since the handshake is done by means of an HTTP upgrade request, its flow fits into HTTP-oriented webRequest model. Note that the API does not intercept:\n- Individual messages sent over an established WebSocket connection.\n- WebSocket closing connection.\nRedirects are not supported for WebSocket requests.\nStarting from Chrome 72, an extension will be able to intercept a request only if it has host permissions to both the requested URL and the request initiator.\nStarting from Chrome 96, the webRequest API supports intercepting the WebTransport over HTTP/3 handshake request. Since the handshake is done by means of an HTTP CONNECT request, its flow fits into HTTP-oriented webRequest model. Note that:\n- Once the session is established, extensions cannot observe or intervene in the session via the webRequest API.\n- Modifying HTTP request headers in\nonBeforeSendHeaders\nis ignored. - Redirects and authentications are not supported in WebTransport over HTTP/3.\nRequest IDs\nEach request is identified by a request ID. This ID is unique within a browser session and the context of an extension. It remains constant during the life cycle of a request and can be used to match events for the same request. Note that several HTTP requests are mapped to one web request in case of HTTP redirection or HTTP authentication.\nRegistering event listeners\nTo register an event listener for a web request, you use a variation on the usual addListener()\nfunction. In addition to specifying a callback function, you have to specify a filter argument, and you may specify an optional extra info argument.\nThe three arguments to the web request API's addListener()\nhave the following definitions:\nvar callback = function(details) {...};\nvar filter = {...};\nvar opt_extraInfoSpec = [...];\nHere's an example of listening for the onBeforeRequest\nevent:\nchrome.webRequest.onBeforeRequest.addListener(\ncallback, filter, opt_extraInfoSpec);\nEach addListener()\ncall takes a mandatory callback function as the first parameter. This callback\nfunction is passed a dictionary containing information about the current URL request. The\ninformation in this dictionary depends on the specific event type as well as the content of\nopt_extraInfoSpec\n.\nIf the optional opt_extraInfoSpec\narray contains the string 'blocking'\n(only allowed for\nspecific events), the callback function is handled synchronously. That means that the request is\nblocked until the callback function returns. In this case, the callback can return a\nwebRequest.BlockingResponse\nthat determines the further life cycle of the request. Depending\non the context, this response allows canceling or redirecting a request (onBeforeRequest\n),\ncanceling a request or modifying headers (onBeforeSendHeaders\n, onHeadersReceived\n), and\ncanceling a request or providing authentication credentials (onAuthRequired\n).\nIf the optional opt_extraInfoSpec\narray contains the string 'asyncBlocking'\ninstead (only\nallowed for onAuthRequired\n), the extension can generate the webRequest.BlockingResponse\nasynchronously.\nThe webRequest.RequestFilter\nfilter\nallows limiting the requests for which events are\ntriggered in various dimensions:\n- URLs\n- URL patterns such as\n*://www.google.com/foo*bar\n. - Types\n- Request types such as\nmain_frame\n(a document that is loaded for a top-level frame),sub_frame\n(a document that is loaded for an embedded frame), andimage\n(an image on a web site). SeewebRequest.RequestFilter\n. - Tab ID\n- The identifier for one tab.\n- Window ID\n- The identifier for a window.\nDepending on the event type, you can specify strings in opt_extraInfoSpec\nto ask for additional\ninformation about the request. This is used to provide detailed information on request's data only\nif explicitly requested.\nHandling authentication\nTo handle requests for HTTP authentication, add the \"webRequestAuthProvider\"\npermission to your manifest file:\n{\n\"permissions\": [\n\"webRequest\",\n\"webRequestAuthProvider\"\n]\n}\nNote that this permission is not required for a policy installed extension with\nthe \"webRequestBlocking\"\npermission.\nTo provide credentials synchronously:\nchrome.webRequest.onAuthRequired.addListener((details) => {\nreturn {\nauthCredentials: {\nusername: 'guest',\npassword: 'guest'\n}\n};\n},\n{ urls: ['https://httpbin.org/basic-auth/guest/guest'] },\n['blocking']\n);\nTo provide credentials asynchronously:\nchrome.webRequest.onAuthRequired.addListener((details, callback) => {\ncallback({\nauthCredentials: {\nusername: 'guest',\npassword: 'guest'\n}\n});\n},\n{ urls: ['https://httpbin.org/basic-auth/guest/guest'] },\n['asyncBlocking']\n);\nImplementation details\nSeveral implementation details can be important to understand when developing an extension that uses the web request API:\nweb_accessible_resources\nWhen an extension uses webRequest APIs to redirect a public resource request to a resource that is not web accessible, it is blocked and will result in an error. The above holds true even if the resource that is not web accessible is owned by the redirecting extension. To declare resources for use with declarativeWebRequest APIs, the \"web_accessible_resources\"\narray must be declared and populated in the manifest as documented here.\nConflict resolution\nIn the current implementation of the web request API, a request is considered canceled if at\nleast one extension instructs to cancel the request. If an extension cancels a request, all\nextensions are notified by an onErrorOccurred\nevent. Only one extension can redirect a\nrequest or modify a header at a time. If more than one extension attempts to modify the request, the\nmost recently installed extension wins, and all others are ignored. An extension is not notified if\nits instruction to modify or redirect has been ignored.\nCaching\nChrome employs two caches\u2014an on-disk cache and a very fast in-memory cache. The lifetime of an\nin-memory cache is attached to the lifetime of a render process, which roughly corresponds to a tab.\nRequests that are answered from the in-memory cache are invisible to the web request API. If a\nrequest handler changes its behavior (for example, the behavior according to which requests are\nblocked), a simple page refresh might not respect this changed behavior. To ensure the behavior\nchange goes through, call handlerBehaviorChanged()\nto flush the in-memory cache. But don't do it\noften; flushing the cache is a very expensive operation. You don't need to call\nhandlerBehaviorChanged()\nafter registering or unregistering an event listener.\nTimestamps\nThe timestamp\nproperty of web request events is only guaranteed to be internally consistent.\nComparing one event to another event will give you the correct offset between them, but comparing\nthem to the current time inside the extension (via (new Date()).getTime()\n, for instance) might\ngive unexpected results.\nError handling\nIf you try to register an event with invalid arguments, then a JavaScript error will be thrown, and the event handler will not be registered. If an error is thrown while an event is handled or if an event handler returns an invalid blocking response, an error message is logged to your extension's console, and the handler is ignored for that request.\nExamples\nThe following example illustrates how to block all requests to www.evil.com\n:\nchrome.webRequest.onBeforeRequest.addListener(\nfunction(details) {\nreturn {cancel: details.url.indexOf(\"://www.evil.com/\") != -1};\n},\n{urls: [\"<all_urls>\"]},\n[\"blocking\"]\n);\nAs this function uses a blocking event handler, it requires the \"webRequest\"\nas well as the\n\"webRequestBlocking\"\npermission in the manifest file.\nThe following example achieves the same goal in a more efficient way because requests that are not\ntargeted to www.evil.com\ndo not need to be passed to the extension:\nchrome.webRequest.onBeforeRequest.addListener(\nfunction(details) { return {cancel: true}; },\n{urls: [\"*://www.evil.com/*\"]},\n[\"blocking\"]\n);\nThe following example illustrates how to delete the User-Agent header from all requests:\nchrome.webRequest.onBeforeSendHeaders.addListener(\nfunction(details) {\nfor (var i = 0; i < details.requestHeaders.length; ++i) {\nif (details.requestHeaders[i].name === 'User-Agent') {\ndetails.requestHeaders.splice(i, 1);\nbreak;\n}\n}\nreturn {requestHeaders: details.requestHeaders};\n},\n{urls: [\"<all_urls>\"]},\n[\"blocking\", \"requestHeaders\"]\n);\nTo try the chrome.webRequest\nAPI,\ninstall the webRequest sample from the chrome-extension-samples\nrepository.\nTypes\nBlockingResponse\nReturns value for event handlers that have the 'blocking' extraInfoSpec applied. Allows the event handler to modify network requests.\nProperties\n-\nauthCredentials\nobject optional\nOnly used as a response to the onAuthRequired event. If set, the request is made using the supplied credentials.\n-\npassword\nstring\n-\nusername\nstring\n-\n-\ncancel\nboolean optional\nIf true, the request is cancelled. This prevents the request from being sent. This can be used as a response to the onBeforeRequest, onBeforeSendHeaders, onHeadersReceived and onAuthRequired events.\n-\nredirectUrl\nstring optional\nOnly used as a response to the onBeforeRequest and onHeadersReceived events. If set, the original request is prevented from being sent/completed and is instead redirected to the given URL. Redirections to non-HTTP schemes such as\ndata:\nare allowed. Redirects initiated by a redirect action use the original request method for the redirect, with one exception: If the redirect is initiated at the onHeadersReceived stage, then the redirect will be issued using the GET method. Redirects from URLs withws://\nandwss://\nschemes are ignored. -\nrequestHeaders\nHttpHeaders optional\nOnly used as a response to the onBeforeSendHeaders event. If set, the request is made with these request headers instead.\n-\nresponseHeaders\nHttpHeaders optional\nOnly used as a response to the onHeadersReceived event. If set, the server is assumed to have responded with these response headers instead. Only return\nresponseHeaders\nif you really want to modify the headers in order to limit the number of conflicts (only one extension may modifyresponseHeaders\nfor each request).\nFormDataItem\nContains data passed within form data. For urlencoded form it is stored as string if data is utf-8 string and as ArrayBuffer otherwise. For form-data it is ArrayBuffer. If form-data represents uploading file, it is string with filename, if the filename is provided.\nEnum\nArrayBuffer string\nHttpHeaders\nAn array of HTTP headers. Each header is represented as a dictionary containing the keys name\nand either value\nor binaryValue\n.\nType\nobject[]\nProperties\n-\nbinaryValue\nnumber[] optional\nValue of the HTTP header if it cannot be represented by UTF-8, stored as individual byte values (0..255).\n-\nname\nstring\nName of the HTTP header.\n-\nvalue\nstring optional\nValue of the HTTP header if it can be represented by UTF-8.\nIgnoredActionType\nEnum\n\"redirect\" \"request_headers\" \"response_headers\" \"auth_credentials\"\nOnAuthRequiredOptions\nEnum\n\"responseHeaders\" \"blocking\" \"asyncBlocking\" \"extraHeaders\"\nSpecifies that the response headers should be included in the event.\nSpecifies the request is blocked until the callback function returns.\nSpecifies that the callback function is handled asynchronously.\nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\nOnBeforeRedirectOptions\nEnum\n\"responseHeaders\" \"extraHeaders\"\nSpecifies that the response headers should be included in the event.\nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\nOnBeforeRequestOptions\nEnum\n\"blocking\" \"requestBody\" \"extraHeaders\"\nSpecifies the request is blocked until the callback function returns.\nSpecifies that the request body should be included in the event.\nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\nOnBeforeSendHeadersOptions\nEnum\n\"requestHeaders\" \"blocking\" \"extraHeaders\"\nSpecifies that the request header should be included in the event.\nSpecifies the request is blocked until the callback function returns.\nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\nOnCompletedOptions\nEnum\n\"responseHeaders\" \"extraHeaders\"\nSpecifies that the response headers should be included in the event.\nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\nOnErrorOccurredOptions\nValue\n\"extraHeaders\"\nOnHeadersReceivedOptions\nEnum\n\"blocking\" \"responseHeaders\" \"extraHeaders\"\nSpecifies the request is blocked until the callback function returns.\nSpecifies that the response headers should be included in the event.\nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\nOnResponseStartedOptions\nEnum\n\"responseHeaders\" \"extraHeaders\"\nSpecifies that the response headers should be included in the event.\nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\nOnSendHeadersOptions\nEnum\n\"requestHeaders\" \"extraHeaders\"\nSpecifies that the request header should be included in the event.\nSpecifies that headers can violate Cross-Origin Resource Sharing (CORS).\nRequestFilter\nAn object describing filters to apply to webRequest events.\nProperties\n-\ntabId\nnumber optional\n-\ntypes\nResourceType[] optional\nA list of request types. Requests that cannot match any of the types will be filtered out.\n-\nurls\nstring[]\nA list of URLs or URL patterns. Requests that cannot match any of the URLs will be filtered out.\n-\nwindowId\nnumber optional\nResourceType\nEnum\n\"main_frame\" \"sub_frame\" \"stylesheet\" \"script\" \"image\" \"font\" \"object\" \"xmlhttprequest\" \"ping\" \"csp_report\" \"media\" \"websocket\" \"webbundle\" \"other\"\nSpecifies the resource as the main frame.\nSpecifies the resource as a sub frame.\nSpecifies the resource as a stylesheet.\nSpecifies the resource as a script.\nSpecifies the resource as an image.\nSpecifies the resource as a font.\nSpecifies the resource as an object.\nSpecifies the resource as an XMLHttpRequest.\nSpecifies the resource as a ping.\nSpecifies the resource as a Content Security Policy (CSP) report.\nSpecifies the resource as a media object.\nSpecifies the resource as a WebSocket.\nSpecifies the resource as a WebBundle.\nSpecifies the resource as a type not included in the listed types.\nUploadData\nContains data uploaded in a URL request.\nProperties\n-\nbytes\nany optional\nAn ArrayBuffer with a copy of the data.\n-\nfile\nstring optional\nA string with the file's path and name.\nProperties\nMAX_HANDLER_BEHAVIOR_CHANGED_CALLS_PER_10_MINUTES\nThe maximum number of times that handlerBehaviorChanged\ncan be called per 10 minute sustained interval. handlerBehaviorChanged\nis an expensive function call that shouldn't be called often.\nValue\n20\nMethods\nhandlerBehaviorChanged()\nchrome.webRequest.handlerBehaviorChanged(\ncallback?: function,\n)\nNeeds to be called when the behavior of the webRequest handlers has changed to prevent incorrect handling due to caching. This function call is expensive. Don't call it often.\nParameters\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 116+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonActionIgnored\nchrome.webRequest.onActionIgnored.addListener(\ncallback: function,\n)\nFired when an extension's proposed modification to a network request is ignored. This happens in case of conflicts with other extensions.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\naction\nThe proposed action which was ignored.\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request.\n-\n-\nonAuthRequired\nchrome.webRequest.onAuthRequired.addListener(\ncallback: function,\nfilter: RequestFilter,\nextraInfoSpec?: OnAuthRequiredOptions[],\n)\nFired when an authentication failure is received. The listener has three options: it can provide authentication credentials, it can cancel the request and display the error page, or it can take no action on the challenge. If bad user credentials are provided, this may be called multiple times for the same request. Note, only one of 'blocking'\nor 'asyncBlocking'\nmodes must be specified in the extraInfoSpec\nparameter.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object, asyncCallback?: function) => BlockingResponse | undefined\n-\ndetails\nobject\n-\nchallenger\nobject\nThe server requesting authentication.\n-\nhost\nstring\n-\nport\nnumber\n-\n-\ndocumentId\nstring\nChrome 106+The UUID of the document making the request.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (\ntype\nismain_frame\norsub_frame\n),frameId\nindicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. -\nframeTypeChrome 106+\nThe type of frame the request occurred in.\n-\ninitiator\nstring optional\nChrome 63+The origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n-\nisProxy\nboolean\nTrue for Proxy-Authenticate, false for WWW-Authenticate.\n-\nmethod\nstring\nStandard HTTP method.\n-\nparentDocumentId\nstring optional\nChrome 106+The UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n-\nrealm\nstring optional\nThe authentication realm provided by the server, if there is one.\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request.\n-\nresponseHeaders\nHttpHeaders optional\nThe HTTP response headers that were received along with this response.\n-\nscheme\nstring\nThe authentication scheme, e.g. Basic or Digest.\n-\nstatusCode\nnumber\nChrome 43+Standard HTTP status code returned by the server.\n-\nstatusLine\nstring\nHTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9 responses (i.e., responses that lack a status line) or an empty string if there are no headers.\n-\ntabId\nnumber\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n-\ntimeStamp\nnumber\nThe time when this signal is triggered, in milliseconds since the epoch.\n-\ntype\nHow the requested resource will be used.\n-\nurl\nstring\n-\n-\nasyncCallback\nfunction optional\nChrome 58+The\nasyncCallback\nparameter looks like:(response: BlockingResponse) => void\n-\nresponse\n-\n-\nreturns\nBlockingResponse | undefined\nIf \"blocking\" is specified in the \"extraInfoSpec\" parameter, the event listener should return an object of this type.\n-\n-\nfilter\n-\nextraInfoSpec\nOnAuthRequiredOptions[] optional\nonBeforeRedirect\nchrome.webRequest.onBeforeRedirect.addListener(\ncallback: function,\nfilter: RequestFilter,\nextraInfoSpec?: OnBeforeRedirectOptions[],\n)\nFired when a server-initiated redirect is about to occur.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+The UUID of the document making the request.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (\ntype\nismain_frame\norsub_frame\n),frameId\nindicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. -\nframeTypeChrome 106+\nThe type of frame the request occurred in.\n-\nfromCache\nboolean\nIndicates if this response was fetched from disk cache.\n-\ninitiator\nstring optional\nChrome 63+The origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n-\nip\nstring optional\nThe server IP address that the request was actually sent to. Note that it may be a literal IPv6 address.\n-\nmethod\nstring\nStandard HTTP method.\n-\nparentDocumentId\nstring optional\nChrome 106+The UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n-\nredirectUrl\nstring\nThe new URL.\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request.\n-\nresponseHeaders\nHttpHeaders optional\nThe HTTP response headers that were received along with this redirect.\n-\nstatusCode\nnumber\nStandard HTTP status code returned by the server.\n-\nstatusLine\nstring\nHTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9 responses (i.e., responses that lack a status line) or an empty string if there are no headers.\n-\ntabId\nnumber\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n-\ntimeStamp\nnumber\nThe time when this signal is triggered, in milliseconds since the epoch.\n-\ntype\nHow the requested resource will be used.\n-\nurl\nstring\n-\n-\n-\nfilter\n-\nextraInfoSpec\nOnBeforeRedirectOptions[] optional\nonBeforeRequest\nchrome.webRequest.onBeforeRequest.addListener(\ncallback: function,\nfilter: RequestFilter,\nextraInfoSpec?: OnBeforeRequestOptions[],\n)\nFired when a request is about to occur.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => BlockingResponse | undefined\n-\ndetails\nobject\n-\ndocumentId\nstring optional\nChrome 106+The UUID of the document making the request.\n-\ndocumentLifecycle\nextensionTypes.DocumentLifecycle optional\nChrome 106+The lifecycle the document is in.\n-\nframeId\nnumber\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (\ntype\nismain_frame\norsub_frame\n),frameId\nindicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. -\nframeType\nextensionTypes.FrameType optional\nChrome 106+The type of frame the request occurred in.\n-\ninitiator\nstring optional\nChrome 63+The origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n-\nmethod\nstring\nStandard HTTP method.\n-\nparentDocumentId\nstring optional\nChrome 106+The UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n-\nrequestBody\nobject optional\nContains the HTTP request body data. Only provided if extraInfoSpec contains 'requestBody'.\n-\nerror\nstring optional\nErrors when obtaining request body data.\n-\nformData\nobject optional\nIf the request method is POST and the body is a sequence of key-value pairs encoded in UTF8, encoded as either multipart/form-data, or application/x-www-form-urlencoded, this dictionary is present and for each key contains the list of all values for that key. If the data is of another media type, or if it is malformed, the dictionary is not present. An example value of this dictionary is {'key': ['value1', 'value2']}.\n-\nraw\nUploadData[] optional\nIf the request method is PUT or POST, and the body is not already parsed in formData, then the unparsed request body elements are contained in this array.\n-\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request.\n-\ntabId\nnumber\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n-\ntimeStamp\nnumber\nThe time when this signal is triggered, in milliseconds since the epoch.\n-\ntype\nHow the requested resource will be used.\n-\nurl\nstring\n-\n-\nreturns\nBlockingResponse | undefined\nIf \"blocking\" is specified in the \"extraInfoSpec\" parameter, the event listener should return an object of this type.\n-\n-\nfilter\n-\nextraInfoSpec\nOnBeforeRequestOptions[] optional\nonBeforeSendHeaders\nchrome.webRequest.onBeforeSendHeaders.addListener(\ncallback: function,\nfilter: RequestFilter,\nextraInfoSpec?: OnBeforeSendHeadersOptions[],\n)\nFired before sending an HTTP request, once the request headers are available. This may occur after a TCP connection is made to the server, but before any HTTP data is sent.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => BlockingResponse | undefined\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+The UUID of the document making the request.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (\ntype\nismain_frame\norsub_frame\n),frameId\nindicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. -\nframeTypeChrome 106+\nThe type of frame the request occurred in.\n-\ninitiator\nstring optional\nChrome 63+The origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n-\nmethod\nstring\nStandard HTTP method.\n-\nparentDocumentId\nstring optional\nChrome 106+The UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n-\nrequestHeaders\nHttpHeaders optional\nThe HTTP request headers that are going to be sent out with this request.\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request.\n-\ntabId\nnumber\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n-\ntimeStamp\nnumber\nThe time when this signal is triggered, in milliseconds since the epoch.\n-\ntype\nHow the requested resource will be used.\n-\nurl\nstring\n-\n-\nreturns\nBlockingResponse | undefined\nIf \"blocking\" is specified in the \"extraInfoSpec\" parameter, the event listener should return an object of this type.\n-\n-\nfilter\n-\nextraInfoSpec\nOnBeforeSendHeadersOptions[] optional\nonCompleted\nchrome.webRequest.onCompleted.addListener(\ncallback: function,\nfilter: RequestFilter,\nextraInfoSpec?: OnCompletedOptions[],\n)\nFired when a request is completed.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+The UUID of the document making the request.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (\ntype\nismain_frame\norsub_frame\n),frameId\nindicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. -\nframeTypeChrome 106+\nThe type of frame the request occurred in.\n-\nfromCache\nboolean\nIndicates if this response was fetched from disk cache.\n-\ninitiator\nstring optional\nChrome 63+The origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n-\nip\nstring optional\nThe server IP address that the request was actually sent to. Note that it may be a literal IPv6 address.\n-\nmethod\nstring\nStandard HTTP method.\n-\nparentDocumentId\nstring optional\nChrome 106+The UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request.\n-\nresponseHeaders\nHttpHeaders optional\nThe HTTP response headers that were received along with this response.\n-\nstatusCode\nnumber\nStandard HTTP status code returned by the server.\n-\nstatusLine\nstring\nHTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9 responses (i.e., responses that lack a status line) or an empty string if there are no headers.\n-\ntabId\nnumber\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n-\ntimeStamp\nnumber\nThe time when this signal is triggered, in milliseconds since the epoch.\n-\ntype\nHow the requested resource will be used.\n-\nurl\nstring\n-\n-\n-\nfilter\n-\nextraInfoSpec\nOnCompletedOptions[] optional\nonErrorOccurred\nchrome.webRequest.onErrorOccurred.addListener(\ncallback: function,\nfilter: RequestFilter,\nextraInfoSpec?: OnErrorOccurredOptions[],\n)\nFired when an error occurs.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+The UUID of the document making the request. This value is not present if the request is a navigation of a frame.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nerror\nstring\nThe error description. This string is not guaranteed to remain backwards compatible between releases. You must not parse and act based upon its content.\n-\nframeId\nnumber\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (\ntype\nismain_frame\norsub_frame\n),frameId\nindicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. -\nframeTypeChrome 106+\nThe type of frame the request occurred in.\n-\nfromCache\nboolean\nIndicates if this response was fetched from disk cache.\n-\ninitiator\nstring optional\nChrome 63+The origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n-\nip\nstring optional\nThe server IP address that the request was actually sent to. Note that it may be a literal IPv6 address.\n-\nmethod\nstring\nStandard HTTP method.\n-\nparentDocumentId\nstring optional\nChrome 106+The UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request.\n-\ntabId\nnumber\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n-\ntimeStamp\nnumber\nThe time when this signal is triggered, in milliseconds since the epoch.\n-\ntype\nHow the requested resource will be used.\n-\nurl\nstring\n-\n-\n-\nfilter\n-\nextraInfoSpec\nOnErrorOccurredOptions[] optional\nonHeadersReceived\nchrome.webRequest.onHeadersReceived.addListener(\ncallback: function,\nfilter: RequestFilter,\nextraInfoSpec?: OnHeadersReceivedOptions[],\n)\nFired when HTTP response headers of a request have been received.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => BlockingResponse | undefined\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+The UUID of the document making the request.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (\ntype\nismain_frame\norsub_frame\n),frameId\nindicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. -\nframeTypeChrome 106+\nThe type of frame the request occurred in.\n-\ninitiator\nstring optional\nChrome 63+The origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n-\nmethod\nstring\nStandard HTTP method.\n-\nparentDocumentId\nstring optional\nChrome 106+The UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request.\n-\nresponseHeaders\nHttpHeaders optional\nThe HTTP response headers that have been received with this response.\n-\nstatusCode\nnumber\nChrome 43+Standard HTTP status code returned by the server.\n-\nstatusLine\nstring\nHTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9 responses (i.e., responses that lack a status line).\n-\ntabId\nnumber\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n-\ntimeStamp\nnumber\nThe time when this signal is triggered, in milliseconds since the epoch.\n-\ntype\nHow the requested resource will be used.\n-\nurl\nstring\n-\n-\nreturns\nBlockingResponse | undefined\nIf \"blocking\" is specified in the \"extraInfoSpec\" parameter, the event listener should return an object of this type.\n-\n-\nfilter\n-\nextraInfoSpec\nOnHeadersReceivedOptions[] optional\nonResponseStarted\nchrome.webRequest.onResponseStarted.addListener(\ncallback: function,\nfilter: RequestFilter,\nextraInfoSpec?: OnResponseStartedOptions[],\n)\nFired when the first byte of the response body is received. For HTTP requests, this means that the status line and response headers are available.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+The UUID of the document making the request.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (\ntype\nismain_frame\norsub_frame\n),frameId\nindicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. -\nframeTypeChrome 106+\nThe type of frame the request occurred in.\n-\nfromCache\nboolean\nIndicates if this response was fetched from disk cache.\n-\ninitiator\nstring optional\nChrome 63+The origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n-\nip\nstring optional\nThe server IP address that the request was actually sent to. Note that it may be a literal IPv6 address.\n-\nmethod\nstring\nStandard HTTP method.\n-\nparentDocumentId\nstring optional\nChrome 106+The UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request.\n-\nresponseHeaders\nHttpHeaders optional\nThe HTTP response headers that were received along with this response.\n-\nstatusCode\nnumber\nStandard HTTP status code returned by the server.\n-\nstatusLine\nstring\nHTTP status line of the response or the 'HTTP/0.9 200 OK' string for HTTP/0.9 responses (i.e., responses that lack a status line) or an empty string if there are no headers.\n-\ntabId\nnumber\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n-\ntimeStamp\nnumber\nThe time when this signal is triggered, in milliseconds since the epoch.\n-\ntype\nHow the requested resource will be used.\n-\nurl\nstring\n-\n-\n-\nfilter\n-\nextraInfoSpec\nOnResponseStartedOptions[] optional\nonSendHeaders\nchrome.webRequest.onSendHeaders.addListener(\ncallback: function,\nfilter: RequestFilter,\nextraInfoSpec?: OnSendHeadersOptions[],\n)\nFired just before a request is going to be sent to the server (modifications of previous onBeforeSendHeaders callbacks are visible by the time onSendHeaders is fired).\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(details: object) => void\n-\ndetails\nobject\n-\ndocumentId\nstring\nChrome 106+The UUID of the document making the request.\n-\ndocumentLifecycleChrome 106+\nThe lifecycle the document is in.\n-\nframeId\nnumber\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (\ntype\nismain_frame\norsub_frame\n),frameId\nindicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. -\nframeTypeChrome 106+\nThe type of frame the request occurred in.\n-\ninitiator\nstring optional\nChrome 63+The origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n-\nmethod\nstring\nStandard HTTP method.\n-\nparentDocumentId\nstring optional\nChrome 106+The UUID of the parent document owning this frame. This is not set if there is no parent.\n-\nparentFrameId\nnumber\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n-\nrequestHeaders\nHttpHeaders optional\nThe HTTP request headers that have been sent out with this request.\n-\nrequestId\nstring\nThe ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request.\n-\ntabId\nnumber\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n-\ntimeStamp\nnumber\nThe time when this signal is triggered, in milliseconds since the epoch.\n-\ntype\nHow the requested resource will be used.\n-\nurl\nstring\n-\n-\n-\nfilter\n-\nextraInfoSpec\nOnSendHeadersOptions[] optional"},
{"source": "https://developer.chrome.com/docs/extensions/reference/api/windows", "title": "chrome.windows | API | Chrome for Developers", "text": "Description\nUse the chrome.windows\nAPI to interact with browser windows. You can use this API to create, modify, and rearrange windows in the browser.\nPermissions\nWhen requested, a windows.Window\ncontains an array of tabs.Tab\nobjects. You must\ndeclare the \"tabs\"\npermission in your manifest if you need access to the url\n,\npendingUrl\n, title\n, or favIconUrl\nproperties of tabs.Tab\n. For example:\n{\n\"name\": \"My extension\",\n...\n\"permissions\": [\"tabs\"],\n...\n}\nConcepts and usage\nThe current window\nMany functions in the extension system take an optional windowId\nargument, which defaults to the\ncurrent window.\nThe current window is the window that contains the code that is currently executing. It's important to realize that this can be different from the topmost or focused window.\nFor example, say an extension creates a few tabs or windows from a single HTML file, and that the\nHTML file contains a call to tabs.query()\n. The current window is the window that contains the\npage that made the call, no matter what the topmost window is.\nIn the case of service workers, the value of the current window falls back to the last active window. Under some circumstances, there may be no current window for background pages.\nExamples\nTo try this API, install the windows API example from the chrome-extension-samples repository.\nTypes\nCreateType\nSpecifies what type of browser window to create. 'panel' is deprecated and is available only to existing allowlisted extensions on Chrome OS.\nEnum\n\"normal\" \"popup\" \"panel\"\nSpecifies the window as a standard window.\nSpecifies the window as a popup window.\nSpecifies the window as a panel.\nQueryOptions\nProperties\n-\npopulate\nboolean optional\nIf true, the\nwindows.Window\nobject has atabs\nproperty that contains a list of thetabs.Tab\nobjects. TheTab\nobjects only contain theurl\n,pendingUrl\n,title\n, andfavIconUrl\nproperties if the extension's manifest file includes the\"tabs\"\npermission. -\nwindowTypes\nWindowType[] optional\nIf set, the\nwindows.Window\nreturned is filtered based on its type. If unset, the default filter is set to['normal', 'popup']\n.\nWindow\nProperties\n-\nalwaysOnTop\nboolean\nWhether the window is set to be always on top.\n-\nfocused\nboolean\nWhether the window is currently the focused window.\n-\nheight\nnumber optional\nThe height of the window, including the frame, in pixels. In some circumstances a window may not be assigned a\nheight\nproperty; for example, when querying closed windows from thesessions\nAPI. -\nid\nnumber optional\nThe ID of the window. Window IDs are unique within a browser session. In some circumstances a window may not be assigned an\nID\nproperty; for example, when querying windows using thesessions\nAPI, in which case a session ID may be present. -\nincognito\nboolean\nWhether the window is incognito.\n-\nleft\nnumber optional\nThe offset of the window from the left edge of the screen in pixels. In some circumstances a window may not be assigned a\nleft\nproperty; for example, when querying closed windows from thesessions\nAPI. -\nsessionId\nstring optional\nThe session ID used to uniquely identify a window, obtained from the\nsessions\nAPI. -\nstate\nWindowState optional\nThe state of this browser window.\n-\ntabs\nTab[] optional\nArray of\ntabs.Tab\nobjects representing the current tabs in the window. -\ntop\nnumber optional\nThe offset of the window from the top edge of the screen in pixels. In some circumstances a window may not be assigned a\ntop\nproperty; for example, when querying closed windows from thesessions\nAPI. -\ntype\nWindowType optional\nThe type of browser window this is.\n-\nwidth\nnumber optional\nThe width of the window, including the frame, in pixels. In some circumstances a window may not be assigned a\nwidth\nproperty; for example, when querying closed windows from thesessions\nAPI.\nWindowState\nThe state of this browser window. In some circumstances a window may not be assigned a state\nproperty; for example, when querying closed windows from the sessions\nAPI.\nEnum\n\"normal\" \"minimized\" \"maximized\" \"fullscreen\" \"locked-fullscreen\"\nNormal window state (not minimized, maximized, or fullscreen).\nMinimized window state.\nMaximized window state.\nFullscreen window state.\nLocked fullscreen window state. This fullscreen state cannot be exited by user action and is available only to allowlisted extensions on Chrome OS.\nWindowType\nThe type of browser window this is. In some circumstances a window may not be assigned a type\nproperty; for example, when querying closed windows from the sessions\nAPI.\nEnum\n\"normal\" \"popup\" \"panel\" \"app\" \"devtools\"\nA normal browser window.\nA browser popup.\nDeprecated in this API. A Chrome App panel-style window. Extensions can only see their own panel windows.\nDeprecated in this API. A Chrome App window. Extensions can only see their app own windows.\nA Developer Tools window.\nProperties\nWINDOW_ID_CURRENT\nThe windowId value that represents the current window.\nValue\n-2\nWINDOW_ID_NONE\nThe windowId value that represents the absence of a Chrome browser window.\nValue\n-1\nMethods\ncreate()\nchrome.windows.create(\ncreateData?: object,\ncallback?: function,\n)\nCreates (opens) a new browser window with any optional sizing, position, or default URL provided.\nParameters\n-\ncreateData\nobject optional\n-\nfocused\nboolean optional\nIf\ntrue\n, opens an active window. Iffalse\n, opens an inactive window. -\nheight\nnumber optional\nThe height in pixels of the new window, including the frame. If not specified, defaults to a natural height.\n-\nincognito\nboolean optional\nWhether the new window should be an incognito window.\n-\nleft\nnumber optional\nThe number of pixels to position the new window from the left edge of the screen. If not specified, the new window is offset naturally from the last focused window. This value is ignored for panels.\n-\nsetSelfAsOpener\nboolean optional\nChrome 64+If\ntrue\n, the newly-created window's 'window.opener' is set to the caller and is in the same unit of related browsing contexts as the caller. -\nstate\nWindowState optional\nChrome 44+The initial state of the window. The\nminimized\n,maximized\n, andfullscreen\nstates cannot be combined withleft\n,top\n,width\n, orheight\n. -\ntabId\nnumber optional\nThe ID of the tab to add to the new window.\n-\ntop\nnumber optional\nThe number of pixels to position the new window from the top edge of the screen. If not specified, the new window is offset naturally from the last focused window. This value is ignored for panels.\n-\ntype\nCreateType optional\nSpecifies what type of browser window to create.\n-\nurl\nstring | string[] optional\nA URL or array of URLs to open as tabs in the window. Fully-qualified URLs must include a scheme, e.g., 'http://www.google.com', not 'www.google.com'. Non-fully-qualified URLs are considered relative within the extension. Defaults to the New Tab Page.\n-\nwidth\nnumber optional\nThe width in pixels of the new window, including the frame. If not specified, defaults to a natural width.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(window?: Window) => void\n-\nwindow\nWindow optional\nContains details about the created window.\n-\nReturns\n-\nPromise<Window | undefined>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nget()\nchrome.windows.get(\nwindowId: number,\nqueryOptions?: QueryOptions,\ncallback?: function,\n)\nGets details about a window.\nParameters\n-\nwindowId\nnumber\n-\nqueryOptions\nQueryOptions optional\nChrome 88+ -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(window: Window) => void\n-\nwindow\n-\nReturns\n-\nPromise<Window>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetAll()\nchrome.windows.getAll(\nqueryOptions?: QueryOptions,\ncallback?: function,\n)\nGets all windows.\nParameters\n-\nqueryOptions\nQueryOptions optional\nChrome 88+ -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(windows: Window[]) => void\n-\nwindows\nWindow[]\n-\nReturns\n-\nPromise<Window[]>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetCurrent()\nchrome.windows.getCurrent(\nqueryOptions?: QueryOptions,\ncallback?: function,\n)\nGets the current window.\nParameters\n-\nqueryOptions\nQueryOptions optional\nChrome 88+ -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(window: Window) => void\n-\nwindow\n-\nReturns\n-\nPromise<Window>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\ngetLastFocused()\nchrome.windows.getLastFocused(\nqueryOptions?: QueryOptions,\ncallback?: function,\n)\nGets the window that was most recently focused \u2014 typically the window 'on top'.\nParameters\n-\nqueryOptions\nQueryOptions optional\nChrome 88+ -\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(window: Window) => void\n-\nwindow\n-\nReturns\n-\nPromise<Window>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nremove()\nchrome.windows.remove(\nwindowId: number,\ncallback?: function,\n)\nRemoves (closes) a window and all the tabs inside it.\nParameters\n-\nwindowId\nnumber\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:() => void\nReturns\n-\nPromise<void>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nupdate()\nchrome.windows.update(\nwindowId: number,\nupdateInfo: object,\ncallback?: function,\n)\nUpdates the properties of a window. Specify only the properties that to be changed; unspecified properties are unchanged.\nParameters\n-\nwindowId\nnumber\n-\nupdateInfo\nobject\n-\ndrawAttention\nboolean optional\nIf\ntrue\n, causes the window to be displayed in a manner that draws the user's attention to the window, without changing the focused window. The effect lasts until the user changes focus to the window. This option has no effect if the window already has focus. Set tofalse\nto cancel a previousdrawAttention\nrequest. -\nfocused\nboolean optional\nIf\ntrue\n, brings the window to the front; cannot be combined with the state 'minimized'. Iffalse\n, brings the next window in the z-order to the front; cannot be combined with the state 'fullscreen' or 'maximized'. -\nheight\nnumber optional\nThe height to resize the window to in pixels. This value is ignored for panels.\n-\nleft\nnumber optional\nThe offset from the left edge of the screen to move the window to in pixels. This value is ignored for panels.\n-\nstate\nWindowState optional\nThe new state of the window. The 'minimized', 'maximized', and 'fullscreen' states cannot be combined with 'left', 'top', 'width', or 'height'.\n-\ntop\nnumber optional\nThe offset from the top edge of the screen to move the window to in pixels. This value is ignored for panels.\n-\nwidth\nnumber optional\nThe width to resize the window to in pixels. This value is ignored for panels.\n-\n-\ncallback\nfunction optional\nThe\ncallback\nparameter looks like:(window: Window) => void\n-\nwindow\n-\nReturns\n-\nPromise<Window>\nChrome 88+Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\nEvents\nonBoundsChanged\nchrome.windows.onBoundsChanged.addListener(\ncallback: function,\n)\nFired when a window has been resized; this event is only dispatched when the new bounds are committed, and not for in-progress changes.\nParameters\n-\ncallback\nfunction\nThe\ncallback\nparameter looks like:(window: Window) => void\n-\nwindow\n-\nonCreated\nchrome.windows.onCreated.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when a window is created.\nParameters\n-\ncallback\nfunction\nChrome 46+The\ncallback\nparameter looks like:(window: Window) => void\n-\nwindow\nDetails of the created window.\n-\n-\nfilters\nobject optional\n-\nwindowTypes\nConditions that the window's type being created must satisfy. By default it satisfies\n['normal', 'popup']\n.\n-\nonFocusChanged\nchrome.windows.onFocusChanged.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when the currently focused window changes. Returns chrome.windows.WINDOW_ID_NONE\nif all Chrome windows have lost focus. Note: On some Linux window managers, WINDOW_ID_NONE\nis always sent immediately preceding a switch from one Chrome window to another.\nParameters\n-\ncallback\nfunction\nChrome 46+The\ncallback\nparameter looks like:(windowId: number) => void\n-\nwindowId\nnumber\nID of the newly-focused window.\n-\n-\nfilters\nobject optional\n-\nwindowTypes\nConditions that the window's type being removed must satisfy. By default it satisfies\n['normal', 'popup']\n.\n-\nonRemoved\nchrome.windows.onRemoved.addListener(\ncallback: function,\nfilters?: object,\n)\nFired when a window is removed (closed).\nParameters\n-\ncallback\nfunction\nChrome 46+The\ncallback\nparameter looks like:(windowId: number) => void\n-\nwindowId\nnumber\nID of the removed window.\n-\n-\nfilters\nobject optional\n-\nwindowTypes\nConditions that the window's type being removed must satisfy. By default it satisfies\n['normal', 'popup']\n.\n-"}]