[{"source": "https://www.embla-carousel.com/api/", "title": "API", "text": "API\nA lightweight carousel shouldn't be limited to just its core features. That's why the Embla Carousel API is designed with extensibility in mind, and it exposes a rich API that can easily be extended to cover most of the use cases for carousels.\nExplore the API\nOptions\nDiscover how to customize Embla Carousel with its available options.\nRead moreMethods\nExplore Embla Carousel methods useful for extending the carousel beyond its native functionality.\nRead moreEvents\nLearn how to listen to Embla Carousel events and how to make use of them.\nRead morePlugins\nLearn how to add plugins to Embla Carousel and extend it.\nRead more"},
{"source": "https://www.embla-carousel.com/api/events/", "title": "Events", "text": "Events\nEmbla Carousel exposes events that you can listen to in order to react to changes in the carousel.\nUsage\nYou need an initialized carousel in order to make use of events. Events will only be fired during the lifecycle of a carousel and added event listeners will persist even when you hard reset the carousel with the reInit method.\nAdding event listeners\nAfter initializing a carousel, we're going to subscribe to the slidesInView event in the following example:\nimport EmblaCarousel from 'embla-carousel'\nconst emblaNode = document.querySelector('.embla')const emblaApi = EmblaCarousel(emblaNode)\nfunction logSlidesInView(emblaApi) { console.log(emblaApi.slidesInView())}\nemblaApi.on('slidesInView', logSlidesInView)\nimport { useCallback, useEffect } from 'react'import useEmblaCarousel from 'embla-carousel-react'\nexport function EmblaCarousel() { const [emblaRef, emblaApi] = useEmblaCarousel()\nconst logSlidesInView = useCallback((emblaApi) => { console.log(emblaApi.slidesInView()) }, [])\nuseEffect(() => { if (emblaApi) emblaApi.on('slidesInView', logSlidesInView) }, [emblaApi, logSlidesInView])\n// ...}\n<script setup> import { onMounted } from 'vue' import emblaCarouselVue from 'embla-carousel-vue'\nconst [emblaRef, emblaApi] = emblaCarouselVue()\nfunction logSlidesInView(emblaApi) { console.log(emblaApi.slidesInView()) }\nonMounted(() => { if (emblaApi.value) emblaApi.value.on('slidesInView', logSlidesInView) })\n// ...</script>\nimport { onMount } from 'solid-js'import createEmblaCarousel from 'embla-carousel-solid'\nexport function EmblaCarousel() { const [emblaRef, emblaApi] = createEmblaCarousel()\nfunction logSlidesInView(emblaApi) { console.log(emblaApi.slidesInView()) }\nonMount(() => { const api = emblaApi() if (api) api.on('slidesInView', logSlidesInView) })\n// ...}\n<script> import emblaCarouselSvelte from 'embla-carousel-svelte'\nlet emblaApi\nfunction logSlidesInView(emblaApi) { console.log(emblaApi.slidesInView()) }\nfunction onInit(event) { emblaApi = event.detail emblaApi.on('slidesInView', logSlidesInView) }</script>\n<div class=\"embla\" use:emblaCarouselSvelte onemblaInit=\"{onInit}\">...</div>\nNote: Starting with Svelte 5, the on:\nevent handlers have been deprecated. However, on:emblaInit\nwill remain for backward compatibility.\nRemoving event listeners\nIn order to remove an event listener, you'll have to call the off method and make sure to pass the same callback reference you passed to the on method:\nimport EmblaCarousel from 'embla-carousel'\nconst emblaNode = document.querySelector('.embla')const emblaApi = EmblaCarousel(emblaNode)\nfunction logSlidesInViewOnce(emblaApi) { console.log(emblaApi.slidesInView()) emblaApi.off('slidesInView', logSlidesInViewOnce)}\nemblaApi.on('slidesInView', logSlidesInViewOnce)\nimport { useCallback, useEffect } from 'react'import useEmblaCarousel from 'embla-carousel-react'\nexport function EmblaCarousel() { const [emblaRef, emblaApi] = useEmblaCarousel()\nconst logSlidesInViewOnce = useCallback((emblaApi) => { console.log(emblaApi.slidesInView()) emblaApi.off('slidesInView', logSlidesInViewOnce) }, [])\nuseEffect(() => { if (emblaApi) emblaApi.on('slidesInView', logSlidesInViewOnce) }, [emblaApi, logSlidesInViewOnce])\n// ...}\n<script setup> import { onMounted } from 'vue' import emblaCarouselVue from 'embla-carousel-vue'\nconst [emblaRef, emblaApi] = emblaCarouselVue()\nfunction logSlidesInViewOnce(emblaApi) { console.log(emblaApi.slidesInView()) emblaApi.off('slidesInView', logSlidesInViewOnce) }\nonMounted(() => { if (emblaApi.value) emblaApi.value.on('slidesInView', logSlidesInViewOnce) })\n// ...</script>\nimport { onMount } from 'solid-js'import createEmblaCarousel from 'embla-carousel-solid'\nexport function EmblaCarousel() { const [emblaRef, emblaApi] = createEmblaCarousel()\nfunction logSlidesInViewOnce(emblaApi) { console.log(emblaApi.slidesInView()) emblaApi.off('slidesInView', logSlidesInViewOnce) }\nonMount(() => { const api = emblaApi() if (api) api.on('slidesInView', logSlidesInViewOnce) })\n// ...}\n<script> import emblaCarouselSvelte from 'embla-carousel-svelte'\nlet emblaApi\nfunction logSlidesInViewOnce(emblaApi) { console.log(emblaApi.slidesInView()) emblaApi.off('slidesInView', logSlidesInViewOnce) }\nfunction onInit(event) { emblaApi = event.detail emblaApi.on('slidesInView', logSlidesInViewOnce) }</script>\n<div class=\"embla\" use:emblaCarouselSvelte onemblaInit=\"{onInit}\">...</div>\nNote: Starting with Svelte 5, the on:\nevent handlers have been deprecated. However, on:emblaInit\nwill remain for backward compatibility.\nTypeScript\nThe EmblaEventType\nis obtained directly from the core package embla-carousel\nand used like so:\nimport EmblaCarousel, { EmblaCarouselType, EmblaEventType} from 'embla-carousel'\nconst emblaNode = document.querySelector('.embla')const emblaApi = EmblaCarousel(emblaNode)\nfunction logEmblaEvent( emblaApi: EmblaCarouselType, eventName: EmblaEventType): void { console.log(`Embla just triggered ${eventName}!`)}\nemblaApi.on('slidesInView', logEmblaEvent)\nimport React, { useCallback } from 'react'import { EmblaCarouselType, EmblaEventType } from 'embla-carousel'import useEmblaCarousel from 'embla-carousel-react'\nexport function EmblaCarousel() { const [emblaRef, emblaApi] = useEmblaCarousel()\nconst logEmblaEvent = useCallback( (emblaApi: EmblaCarouselType, eventName: EmblaEventType) => { console.log(`Embla just triggered ${eventName}!`) }, [] )\nuseEffect(() => { if (emblaApi) emblaApi.on('slidesInView', logEmblaEvent) }, [emblaApi, logEmblaEvent])\n// ...}\nIf you're using pnpm\n, you need to install embla-carousel\nas a\ndevDependency when importing types from it like demonstrated above.\nThis is because even though embla-carousel-react\nhas embla-carousel\nas a\ndependency, pnpm\nmakes nested dependencies inaccessible by design.\n<script setup> import { onMounted } from 'vue' import { EmblaCarouselType, EmblaEventType } from 'embla-carousel' import emblaCarouselVue from 'embla-carousel-vue'\nconst [emblaRef] = emblaCarouselVue()\nfunction logEmblaEvent( emblaApi: EmblaCarouselType, eventName: EmblaEventType ): void { console.log(`Embla just triggered ${eventName}!`) }\nonMounted(() => { if (emblaApi.value) emblaApi.value.on('slidesInView', logEmblaEvent) })\n// ...</script>\nIf you're using pnpm\n, you need to install embla-carousel\nas a\ndevDependency when importing types from it like demonstrated above.\nThis is because even though embla-carousel-vue\nhas embla-carousel\nas a\ndependency, pnpm\nmakes nested dependencies inaccessible by design.\nimport { onMount } from 'solid-js'import { EmblaCarouselType, EmblaEventType } from 'embla-carousel'import createEmblaCarousel from 'embla-carousel-solid'\nexport function EmblaCarousel() { const [emblaRef, emblaApi] = createEmblaCarousel()\nfunction logEmblaEvent( emblaApi: EmblaCarouselType, eventName: EmblaEventType ): void { console.log(`Embla just triggered ${eventName}!`) }\nonMount(() => { const api = emblaApi() if (api) api.on('slidesInView', logEmblaEvent) })\n// ...}\nIf you're using pnpm\n, you need to install embla-carousel\nas a\ndevDependency when importing types from it like demonstrated above.\nThis is because even though embla-carousel-solid\nhas embla-carousel\nas a\ndependency, pnpm\nmakes nested dependencies inaccessible by design.\n<script> import { EmblaCarouselType, EmblaEventType } from 'embla-carousel' import emblaCarouselSvelte from 'embla-carousel-svelte'\nlet emblaApi: EmblaCarouselType\nfunction logEmblaEvent( emblaApi: EmblaCarouselType, eventName: EmblaEventType ): void { console.log(`Embla just triggered ${eventName}!`) }\nfunction onInit(event: CustomEvent<EmblaCarouselType>): void { emblaApi = event.detail emblaApi.on('slidesInView', logEmblaEvent) }</script>\n<div class=\"embla\" use:emblaCarouselSvelte onemblaInit=\"{onInit}\">...</div>\nNote: Starting with Svelte 5, the on:\nevent handlers have been deprecated. However, on:emblaInit\nwill remain for backward compatibility.\nIf you're using pnpm\n, you need to install embla-carousel\nas a\ndevDependency when importing types from it like demonstrated above.\nThis is because even though embla-carousel-svelte\nhas embla-carousel\nas a\ndependency, pnpm\nmakes nested dependencies inaccessible by design.\nReference\nBelow follows an exhaustive list of all Embla Carousel events together with information about how they work.\ninit\nOnce: yes\nRuns when the carousel mounts for the first time. This only fires once which means that it won't fire when the carousel is re-initialized using the reInit method.\nreInit\nOnce: no\nRuns when the reInit method is called. When the window is resized, Embla Carousel automatically calls the reInit method which will also fire this event.\ndestroy\nOnce: yes\nRuns when the carousel has been destroyed using the destroy method. This only fires once and will be the last event the carousel fires.\nselect\nOnce: no\nRuns when the selected scroll snap changes. The select event is triggered by drag interactions or the scrollNext, scrollPrev or scrollTo methods.\nscroll\nOnce: no\nRuns when the carousel is scrolling. It might be a good idea to throttle this if you're doing expensive stuff in your callback function.\nsettle\nOnce: no\nRuns when the carousel has settled after scroll has been triggered. Please note that this can take longer than you think when dragFree is enabled or when using slow transitions.\nresize\nOnce: no\nRuns when the carousel container or the slide sizes change. It's using ResizeObserver under the hood.\nslidesInView\nOnce: no\nRuns when any slide has entered or exited the viewport. This event is intended to be used together with the slidesInView and/or slidesNotInView methods.\nslidesChanged\nOnce: no\nRuns when slides are added to, or removed from the carousel container. It's using MutationObserver under the hood.\nslideFocus\nOnce: no\nRuns when a slide receives focus. For example, when a focusable element like a button, link or input receives focus inside a slide.\npointerDown\nOnce: no\nRuns when the user has a pointer down on the carousel. It's triggered by a touchstart\nor a mousedown\nevent.\npointerUp\nOnce: no\nRuns when the user has released the pointer from the carousel. It's triggered by a touchend\nor a mouseup\nevent."},
{"source": "https://www.embla-carousel.com/api/methods/", "title": "Methods", "text": "Methods\nEmbla Carousel exposes a set of useful methods which makes it very extensible.\nUsage\nYou need an initialized carousel in order to make use of methods. They can be accessed during the lifecycle of a carousel and won't do anything after a carousel instance has been destroyed with the destroy method.\nCalling methods\nIn the following example, the slideNodes method is called and logged to the console as soon as the carousel has been initialized:\nimport EmblaCarousel from 'embla-carousel'\nconst emblaNode = document.querySelector('.embla')const emblaApi = EmblaCarousel(emblaNode)\nconsole.log(emblaApi.slideNodes())\nimport { useEffect } from 'react'import useEmblaCarousel from 'embla-carousel-react'\nexport function EmblaCarousel() { const [emblaRef, emblaApi] = useEmblaCarousel()\nuseEffect(() => { if (emblaApi) console.log(emblaApi.slideNodes()) }, [emblaApi])\n// ...}\n<script setup> import { onMounted } from 'vue' import emblaCarouselVue from 'embla-carousel-vue'\nconst [emblaRef, emblaApi] = emblaCarouselVue()\nonMounted(() => { if (emblaApi.value) console.log(emblaApi.value.slideNodes()) })\n// ...</script>\nimport { onMount } from 'solid-js'import createEmblaCarousel from 'embla-carousel-solid'\nexport function EmblaCarousel() { const [emblaRef, emblaApi] = createEmblaCarousel()\nonMount(() => { const api = emblaApi() if (api) console.log(api.slideNodes()) })\n// ...}\n<script> import emblaCarouselSvelte from 'embla-carousel-svelte'\nlet emblaApi\nfunction onInit(event) { emblaApi = event.detail console.log(emblaApi.slideNodes()) }</script>\n<div class=\"embla\" use:emblaCarouselSvelte onemblaInit=\"{onInit}\">...</div>\nNote: Starting with Svelte 5, the on:\nevent handlers have been deprecated. However, on:emblaInit\nwill remain for backward compatibility.\nTypeScript\nThe EmblaCarouselType\nis obtained directly from the core package embla-carousel\nand used like so:\nimport EmblaCarousel, { EmblaCarouselType } from 'embla-carousel'\nconst emblaNode = document.querySelector('.embla')const emblaApi = EmblaCarousel(emblaNode)\nfunction logSlidesInView(emblaApi: EmblaCarouselType): void { console.log(emblaApi.slidesInView())}\nemblaApi.on('slidesInView', logSlidesInView)\nimport React, { useCallback } from 'react'import { EmblaCarouselType } from 'embla-carousel'import useEmblaCarousel from 'embla-carousel-react'\nexport function EmblaCarousel() { const [emblaRef, emblaApi] = useEmblaCarousel()\nconst logSlidesInView = useCallback((emblaApi: EmblaCarouselType) => { console.log(emblaApi.slidesInView()) }, [])\nuseEffect(() => { if (emblaApi) emblaApi.on('slidesInView', logSlidesInView) }, [emblaApi, logSlidesInView])\n// ...}\nIf you're using pnpm\n, you need to install embla-carousel\nas a\ndevDependency when importing types from it like demonstrated above.\nThis is because even though embla-carousel-react\nhas embla-carousel\nas a\ndependency, pnpm\nmakes nested dependencies inaccessible by design.\n<script setup lang=\"ts\"> import { onMounted } from 'vue' import { EmblaCarouselType } from 'embla-carousel' import emblaCarouselVue from 'embla-carousel-vue'\nconst [emblaRef] = emblaCarouselVue()\nfunction logSlidesInView(emblaApi: EmblaCarouselType): void { console.log(emblaApi.slidesInView()) }\nonMounted(() => { if (emblaApi.value) emblaApi.value.on('slidesInView', logSlidesInView) })\n// ...</script>\nIf you're using pnpm\n, you need to install embla-carousel\nas a\ndevDependency when importing types from it like demonstrated above.\nThis is because even though embla-carousel-vue\nhas embla-carousel\nas a\ndependency, pnpm\nmakes nested dependencies inaccessible by design.\nimport { onMount } from 'solid-js'import { EmblaCarouselType } from 'embla-carousel'import createEmblaCarousel from 'embla-carousel-solid'\nexport function EmblaCarousel() { const [emblaRef, emblaApi] = createEmblaCarousel()\nfunction logSlidesInView(emblaApi: EmblaCarouselType): void { console.log(emblaApi.slidesInView()) }\nonMount(() => { const api = emblaApi() if (api) api.on('slidesInView', logSlidesInView) })\n// ...}\nIf you're using pnpm\n, you need to install embla-carousel\nas a\ndevDependency when importing types from it like demonstrated above.\nThis is because even though embla-carousel-solid\nhas embla-carousel\nas a\ndependency, pnpm\nmakes nested dependencies inaccessible by design.\n<script> import { EmblaCarouselType } from 'embla-carousel' import emblaCarouselSvelte from 'embla-carousel-svelte'\nlet emblaApi: EmblaCarouselType\nfunction logSlidesInView(emblaApi: EmblaCarouselType): void { console.log(emblaApi.slidesInView()) }\nfunction onInit(event: CustomEvent<EmblaCarouselType>): void { emblaApi = event.detail emblaApi.on('slidesInView', logSlidesInView) }</script>\n<div class=\"embla\" use:emblaCarouselSvelte onemblaInit=\"{onInit}\">...</div>\nNote: Starting with Svelte 5, the on:\nevent handlers have been deprecated. However, on:emblaInit\nwill remain for backward compatibility.\nIf you're using pnpm\n, you need to install embla-carousel\nas a\ndevDependency when importing types from it like demonstrated above.\nThis is because even though embla-carousel-svelte\nhas embla-carousel\nas a\ndependency, pnpm\nmakes nested dependencies inaccessible by design.\nReference\nBelow follows an exhaustive list of all Embla Carousel methods with their respective parameters and return values.\nrootNode\nParameters: none\nReturns: HTMLElement\nGet the root node that holds the scroll container with slides inside. This method can be useful when you need to manipulate the root element dynamically or similar.\ncontainerNode\nParameters: none\nReturns: HTMLElement\nGet the container node that holds the slides. This method can be useful when you need to manipulate the container element dynamically or similar.\nslideNodes\nParameters: none\nReturns: HTMLElement[]\nGet all the slide nodes inside the container. This method can be useful when you need to manipulate the slide elements dynamically or similar.\nscrollNext\nParameters: jump?: boolean\nReturns: void\nScroll to the next snap point if possible. When loop is disabled and the carousel has reached the last snap point, this method won't do anything. Set the jump parameter to true\nwhen you want to go to the next slide instantly.\nscrollPrev\nParameters: jump?: boolean\nReturns: void\nScroll to the previous snap point if possible. When loop is disabled and the carousel has reached the first snap point, this method won't do anything. Set the jump parameter to true\nwhen you want to go to the previous slide instantly.\nscrollTo\nParameters: index: number\n, jump?: boolean\nReturns: void\nScroll to a snap point by its unique index. If loop is enabled, Embla Carousel will choose the closest way to the target snap point. Set the jump parameter to true\nwhen you want to go to the desired slide instantly.\ncanScrollNext\nParameters: none\nReturns: boolean\nCheck the possiblity to scroll to a next snap point. If loop is enabled and the container holds any slides, this will always return true\n.\ncanScrollPrev\nParameters: none\nReturns: boolean\nCheck the possiblity to scroll to a previous snap point. If loop is enabled and the container holds any slides, this will always return true\n.\nselectedScrollSnap\nParameters: none\nReturns: number\nGet the index of the selected snap point.\npreviousScrollSnap\nParameters: none\nReturns: number\nGet the index of the previously selected snap point.\nscrollSnapList\nParameters: none\nReturns: number[]\nGet an array containing all the snap point positions. Each position represents how far the carousel needs to progress in order to reach this position.\nscrollProgress\nParameters: none\nReturns: number\nCheck how far the carousel has scrolled of its scrollable length from 0 - 1. For example, 0.5 equals 50%. For example, this can be useful when creating a scroll progress bar.\nslidesInView\nParameters: none\nReturns: number[]\nGet slide indexes visible in the carousel viewport. Honors the inViewThreshold option.\nslidesNotInView\nParameters: none\nReturns: number[]\nGet slide indexes not visible in the carousel viewport. Honors the inViewThreshold option.\ninternalEngine\nParameters: none\nReturns: EmblaEngineType\nExposes almost all internal functionality used by Embla. Useful when creating plugins or similar.\nNote: Please refrain from creating bug reports related to this method. If you're using this and running into problems, it's a 99.8% chance that you don't understand how this works. Use at your own risk.\nreInit\nParameters: options?: EmblaOptionsType\n, plugins?: EmblaPluginType[]\nReturns: void\nHard reset the carousel after it has been initialized. This method allows for changing options and plugins after initializing a carousel.\nNote: Passed options will be merged with current options, but passed plugins will replace current plugins.\nplugins\nParameters: none\nReturns: EmblaPluginsType\nReturns an object with key value pairs where the keys are the plugin names, and the plugin API:s are the values.\ndestroy\nParameters: none\nReturns: void\nDestroy the carousel instance permanently. This is a one way operation and is intended to be used as a cleanup measure when the carousel instance isn't needed anymore.\non\nParameters: event: EmblaEventType\n, callback: (emblaApi: EmblaCarouselType, eventName: EmblaEventType) => void\nReturns: void\nSubscribe to an Embla specific event with a callback. Added event listeners will persist even if reInit is called, either until the carousel is destroyed or the event is removed with the off method.\noff\nParameters: event: EmblaEventType\n, callback: (emblaApi: EmblaCarouselType, eventName: EmblaEventType) => void\nReturns: void\nUnsubscribe from an Embla specific event. Make sure to pass the same callback reference when the callback was added with the on method.\nemit\nParameters: event: EmblaEventType\nReturns: void\nEmits an embla event. This doesn't trigger any internal Embla functionality."},
{"source": "https://www.embla-carousel.com/api/options/", "title": "Options", "text": "Options\nEmbla Carousel takes various options in order to customize how the carousel works.\nUsage\nYou can provide options in two different ways: With the constructor options and/or global options. If both are provided, they will be merged, and if any options are in conflict, the constructor option has precedence and will override global options.\nConstructor options\nThe constructor options is the default way of providing options to Embla Carousel. In the following example, the carousel loop option is set to true\n:\nimport EmblaCarousel from 'embla-carousel'\nconst emblaNode = document.querySelector('.embla')const emblaApi = EmblaCarousel(emblaNode, { loop: true })\nimport useEmblaCarousel from 'embla-carousel-react'\nexport function EmblaCarousel() { const [emblaRef] = useEmblaCarousel({ loop: true })\n// ...}\n<script setup> import emblaCarouselVue from 'embla-carousel-vue'\nconst [emblaRef] = emblaCarouselVue({ loop: true })\n// ...</script>\nimport createEmblaCarousel from 'embla-carousel-solid'\nexport function EmblaCarousel() { const [emblaRef] = createEmblaCarousel(() => ({ loop: true }))\n// ...}\n<script> import emblaCarouselSvelte from 'embla-carousel-svelte'\nlet options = { loop: true }</script>\n<div class=\"embla\" use:emblaCarouselSvelte=\"{{ options }}\">...</div>\nGlobal options\nSetting global options will be applied to all carousels which will override the Embla default options with your own. In the following example loop is set to true\n:\nimport EmblaCarousel from 'embla-carousel'\nEmblaCarousel.globalOptions = { loop: true }\nconst emblaNode = document.querySelector('.embla')const emblaApi = EmblaCarousel(emblaNode, { align: 'start' })\nimport useEmblaCarousel from 'embla-carousel-react'\nuseEmblaCarousel.globalOptions = { loop: true }\nexport function EmblaCarousel() { const [emblaRef] = useEmblaCarousel({ align: 'start' })\n// ...}\n<script setup> import emblaCarouselVue from 'embla-carousel-vue'\nemblaCarouselVue.globalOptions = { loop: true }\nconst [emblaRef] = emblaCarouselVue({ align: 'start' })\n// ...</script>\nimport createEmblaCarousel from 'embla-carousel-solid'\ncreateEmblaCarousel.globalOptions = { loop: true }\nexport function EmblaCarousel() { const [emblaRef] = createEmblaCarousel(() => ({ align: 'start' }))\n// ...}\n<script> import emblaCarouselSvelte from 'embla-carousel-svelte'\nemblaCarouselSvelte.globalOptions = { loop: true }\nlet options = { align: 'start' }</script>\n<div class=\"embla\" use:emblaCarouselSvelte=\"{{ options }}\">...</div>\nMake sure to assign global options before initializing any carousel and only assign it once. Re-assigning global options might lead to confusing code and unexpected behaviour.\nChanging options\nIt's possible to change options passed to the Embla Carousel constructor after initialization with the reInit method.\nIn React, Vue, Solid and Svelte wrappers you can pass reactive options and the carousel will automatically reinitialize when they change. Here are some examples:\nimport EmblaCarousel from 'embla-carousel'\nconst emblaNode = document.querySelector('.embla')const emblaApi = EmblaCarousel(emblaNode, { loop: true })\nemblaApi.reInit({ loop: false })\nimport { useState, useCallback } from 'react'import useEmblaCarousel from 'embla-carousel-react'\nexport function EmblaCarousel() { const [options, setOptions] = useState({ loop: true }) const [emblaRef, emblaApi] = useEmblaCarousel(options)\nconst toggleLoop = useCallback(() => { setOptions((currentOptions) => ({ ...currentOptions, loop: !currentOptions.loop })) }, [])\n// ...}\n<script setup> import emblaCarouselVue from 'embla-carousel-vue'\nconst options = ref({ loop: true }) const [emblaRef, emblaApi] = emblaCarouselVue(options)\nfunction toggleLoop() { options.value = { ...options.value, loop: !options.value.loop } }\n// ...</script>\nimport { createSignal } from 'solid-js'import createEmblaCarousel from 'embla-carousel-solid'\nexport function EmblaCarousel() { const [options, setOptions] = createSignal({ loop: true }) const [emblaRef] = createEmblaCarousel(() => options())\nfunction toggleLoop() { setOptions((currentOptions) => ({ ...currentOptions, loop: !currentOptions.loop })) }\n// ...}\n<script> import emblaCarouselSvelte from 'embla-carousel-svelte'\nlet options = { loop: true }\nfunction toggleLoop() { options = { ...options, loop: !options.loop } }</script>\n<div class=\"embla\" use:emblaCarouselSvelte=\"{{ options }}\">...</div>\nTypeScript\nThe EmblaOptionsType\nis obtained directly from the core package embla-carousel\nand used like so:\nimport EmblaCarousel, { EmblaOptionsType } from 'embla-carousel'\nconst emblaNode = document.querySelector('.embla')const options: EmblaOptionsType = { loop: true }const emblaApi = EmblaCarousel(emblaNode, options)\nimport React from 'react'import { EmblaOptionsType } from 'embla-carousel'import useEmblaCarousel from 'embla-carousel-react'\ntype PropType = { options?: EmblaOptionsType}\nexport function EmblaCarousel(props: PropType) { const [emblaRef, emblaApi] = useEmblaCarousel(props.options)\n// ...}\nIf you're using pnpm\n, you need to install embla-carousel\nas a\ndevDependency when importing types from it like demonstrated above.\nThis is because even though embla-carousel-react\nhas embla-carousel\nas a\ndependency, pnpm\nmakes nested dependencies inaccessible by design.\n<script setup lang=\"ts\"> import { EmblaOptionsType } from 'embla-carousel' import emblaCarouselVue from 'embla-carousel-vue'\nconst options: EmblaOptionsType = { loop: true } const [emblaRef] = emblaCarouselVue(options)\n// ...</script>\nIf you're using pnpm\n, you need to install embla-carousel\nas a\ndevDependency when importing types from it like demonstrated above.\nThis is because even though embla-carousel-vue\nhas embla-carousel\nas a\ndependency, pnpm\nmakes nested dependencies inaccessible by design.\nimport { EmblaOptionsType } from 'embla-carousel'import createEmblaCarousel from 'embla-carousel-solid'\ntype PropType = { options?: EmblaOptionsType}\nexport function EmblaCarousel(props) { const [emblaRef] = createEmblaCarousel(props.options)\n// ...}\nIf you're using pnpm\n, you need to install embla-carousel\nas a\ndevDependency when importing types from it like demonstrated above.\nThis is because even though embla-carousel-solid\nhas embla-carousel\nas a\ndependency, pnpm\nmakes nested dependencies inaccessible by design.\n<script> import { EmblaOptionsType } from 'embla-carousel' import emblaCarouselSvelte from 'embla-carousel-svelte'\nlet options: EmblaOptionsType = { loop: true }</script>\n<div class=\"embla\" use:emblaCarouselSvelte=\"{{ options }}\">...</div>\nIf you're using pnpm\n, you need to install embla-carousel\nas a\ndevDependency when importing types from it like demonstrated above.\nThis is because even though embla-carousel-svelte\nhas embla-carousel\nas a\ndependency, pnpm\nmakes nested dependencies inaccessible by design.\nReference\nBelow follows an exhaustive list of all Embla Carousel options and their default values.\nactive\nType: boolean\nDefault: true\nSetting this to false\nwill not activate or deactivate the carousel. Useful when used together with the breakpoints option to toggle the carousel active/inactive depending on media queries.\nalign\nType: string | (viewSize: number, snapSize: number, index: number) => number\nDefault: center\nAlign the slides relative to the carousel viewport. Use one of the predefined alignments start\n, center\nor end\n. Alternatively, provide your own callback to fully customize the alignment.\naxis\nType: string\nDefault: x\nChoose scroll axis between x\nand y\n. Remember to stack your slides horizontally or vertically using CSS to match this option.\nbreakpoints\nType: EmblaOptionsType\nDefault: {}\nAn object with options that will be applied for a given breakpoint by overriding the options at the root level. Example: '(min-width: 768px)': { loop: false }\n.\nNote: If multiple queries match, they will be merged. And when breakpoint options clash, the last one in the list has precedence.\ncontainer\nType: string | HTMLElement | null\nDefault: null\nEnables choosing a custom container element which holds the slides. By default, Embla will choose the first direct child element of the root element. Provide either a valid CSS selector string\nor a HTML element\n.\ncontainScroll\nType: false\n| string\nDefault: 'trimSnaps'\nClear leading and trailing empty space that causes excessive scrolling. Use trimSnaps\nto only use snap points that trigger scrolling or keepSnaps\nto keep them.\nNote: When this is active, it will override alignments applied by the align option for enough slides at the start and the end of the carousel, in order to cover the leading and trailing space.\ndirection\nType: string\nDefault: ltr\nChoose content direction between ltr\nand rtl\n.\nNote: When using rtl\n, the content direction also has to be set to RTL,\neither by using the HTML dir\nattribute\nor the CSS\ndirection\nproperty.\ndragFree\nType: boolean\nDefault: false\nEnables momentum scrolling. The duration of the continued scrolling is proportional to how vigorous the drag gesture is.\ndragThreshold\nType: number\nDefault: 10\nDrag threshold in pixels. This only affects when clicks are fired and not. In contrast to other carousel libraries, it will not affect when dragging of the carousel starts.\nNote: Browsers handle touch events differently than mouse events. Browsers won't fire the click event when a touch event includes an accidental slight swipe gesture. This is why this threshold only works for mouse events.\nduration\nType: number\nDefault: 25\nSet scroll duration when triggered by any of the API methods. Higher numbers enables slower scrolling. Drag interactions are not affected because duration is then determined by the drag force.\nNote: Duration is not in milliseconds because Embla uses an attraction\nphysics simulation when scrolling instead of easings. Only values between\n20\n-60\nare recommended.\ninViewThreshold\nType: IntersectionObserverInit.threshold\nDefault: 0\nThis is the Intersection Observer threshold option that will be applied to all slides.\nloop\nType: boolean\nDefault: false\nEnables infinite looping. Embla will apply translateX\nor translateY\nto the slides that need to change position in order to create the loop effect.\nEmbla automatically falls back to false\nif slide content isn't enough to\ncreate the loop effect without visible glitches.\nskipSnaps\nType: boolean\nDefault: false\nAllow the carousel to skip scroll snaps if it's dragged vigorously. Note that this option will be ignored if the dragFree option is set to true\n.\nslides\nType: string | HTMLElement[] | NodeListOf<HTMLElement> | null\nDefault: null\nEnables using custom slide elements. By default, Embla will choose all direct child elements of its container. Provide either a valid CSS selector string\nor a nodeList/array\ncontaining HTML elements\n.\nNote: Even though it's possible to provide custom slide elements, they still have to be direct descendants of the carousel container.\nWarning: If you place elements inside the carousel container that aren't\nslides, they either shouldn't have any size, or should be detached from the\ndocument flow with position: absolute\nor similar.\nslidesToScroll\nType: string | number\nDefault: 1\nGroup slides together. Drag interactions, dot navigation, and previous/next buttons are mapped to group slides into the given number, which has to be an integer. Set it to auto\nif you want Embla to group slides automatically.\nstartIndex\nType: number\nDefault: 0\nSet the initial scroll snap to the given number. First snap index starts at 0\n. Please note that this is not necessarily equal to the number of slides when used together with the slidesToScroll option.\nwatchDrag\nType: boolean | (emblaApi: EmblaCarouselType, event: MouseEvent | TouchEvent) => boolean | void\nDefault: true\nEnables for scrolling the carousel with mouse and touch interactions. Set this to false\nto disable drag events or pass a custom callback to add your own drag logic.\nNote: When passing a custom callback it will run before the default\nEmbla drag behaviour. Return true\nin your callback if you want Embla to run\nits default drag behaviour after your callback, or return false\nif you want\nto skip it.\nwatchFocus\nType: boolean | (emblaApi: EmblaCarouselType, event: FocusEvent) => boolean | void\nDefault: true\nEmbla automatically watches the slides for focus events. The default callback fires the slideFocus event and scrolls to the focused element. Set this to false\nto disable this behaviour or pass a custom callback to add your own focus logic.\nNote: When passing a custom callback it will run before the default\nEmbla focus behaviour. Return true\nin your callback if you want Embla to run\nits default focus behaviour after your callback, or return false\nif you want\nto skip it.\nwatchResize\nType: boolean | (emblaApi: EmblaCarouselType, entries: ResizeObserverEntry[]) => boolean | void\nDefault: true\nEmbla automatically watches the container and slides for size changes and runs reInit when any size has changed. Set this to false\nto disable this behaviour or pass a custom callback to add your own resize logic.\nNote: When passing a custom callback it will run before the default\nEmbla resize behaviour. Return true\nin your callback if you want Embla to\nrun its default resize behaviour after your callback, or return false\nif you\nwant to skip it.\nwatchSlides\nType: boolean | (emblaApi: EmblaCarouselType, mutations: MutationRecord[]) => boolean | void\nDefault: true\nEmbla automatically watches the container for added and/or removed slides and runs reInit if needed. Set this to false\nto disable this behaviour or pass a custom callback to add your own slides changed logic.\nNote: When passing a custom callback it will run before the default\nEmbla mutation behaviour. Return true\nin your callback if you want Embla to\nrun its default mutation behaviour after your callback, or return false\nif\nyou want to skip it."},
{"source": "https://www.embla-carousel.com/api/options/api/options/", "title": "Page not found", "text": "This app only works with JavaScript enabled.\nPage not found\nSorry - We couldn\u2019t find what you were looking for.\nEmbla Carousel Homepage"},
{"source": "https://www.embla-carousel.com/api/plugins/", "title": "Plugins", "text": "Plugins\nIt's possible to extend Embla carousel with additional features using plugins. The complete list of official plugins can be found here.\nInstallation\nAll official plugins are separate NPM packages. They're all prefixed with embla-carousel\nfollowed by its unique plugin name. For example, the Autoplay\nplugin is installed like so:\n<script src=\"https://unpkg.com/embla-carousel-autoplay/embla-carousel-autoplay.umd.js\"></script>\nnpm install embla-carousel-autoplay --save\nyarn add embla-carousel-autoplay\nUsage\nThe Embla Carousel constructor accepts an array of plugins. Each plugin might have its own options, methods and events.\nAdding a plugin\nThe constructor plugin array is the default way of providing plugins to Embla Carousel. In the following example, the Autoplay plugin is added to the carousel:\nimport EmblaCarousel from 'embla-carousel'import Autoplay from 'embla-carousel-autoplay'\nconst emblaNode = document.querySelector('.embla')const embla = EmblaCarousel(emblaNode, { loop: true }, [Autoplay()])\nimport useEmblaCarousel from 'embla-carousel-react'import Autoplay from 'embla-carousel-autoplay'\nexport function EmblaCarousel() { const [emblaRef] = useEmblaCarousel({ loop: true }, [Autoplay()])\n// ...}\n<script setup> import emblaCarouselVue from 'embla-carousel-vue' import Autoplay from 'embla-carousel-autoplay'\nconst [emblaRef] = emblaCarouselVue({ loop: true }, [Autoplay()])\n// ...</script>\nimport createEmblaCarousel from 'embla-carousel-solid'import Autoplay from 'embla-carousel-autoplay'\nexport function EmblaCarousel() { const [emblaRef] = createEmblaCarousel( () => ({ loop: true }), () => [AutoPlay()] )\n// ...}\n<script> import emblaCarouselSvelte from 'embla-carousel-svelte' import Autoplay from 'embla-carousel-autoplay'\nlet plugins = [Autoplay()]</script>\n<div class=\"embla\" use:emblaCarouselSvelte=\"{{ plugins }}\">...</div>\nNote that it's possible to change plugins passed to the Embla Carousel constructor after initialization with the reInit method.\nConstructor options\nPlugins have their own specific options which is the first argument of the plugin constructor. This allows for configuring the plugin to your liking:\nimport EmblaCarousel from 'embla-carousel'import Autoplay from 'embla-carousel-autoplay'\nconst emblaNode = document.querySelector('.embla')const embla = EmblaCarousel(emblaNode, { loop: true }, [ Autoplay({ delay: 4000 })])\nimport useEmblaCarousel from 'embla-carousel-react'import Autoplay from 'embla-carousel-autoplay'\nexport function EmblaCarousel() { const [emblaRef] = useEmblaCarousel({ loop: true }, [ Autoplay({ delay: 4000 }) ])\n// ...}\n<script setup> import emblaCarouselVue from 'embla-carousel-vue' import Autoplay from 'embla-carousel-autoplay'\nconst [emblaRef] = emblaCarouselVue({ loop: true }, [ Autoplay({ delay: 4000 }) ])\n// ...</script>\nimport createEmblaCarousel from 'embla-carousel-solid'import Autoplay from 'embla-carousel-autoplay'\nexport function EmblaCarousel() { const [emblaRef] = createEmblaCarousel( () => ({ loop: true }), () => [AutoPlay({ delay: 4000 })] )\n// ...}\n<script> import emblaCarouselSvelte from 'embla-carousel-svelte' import Autoplay from 'embla-carousel-autoplay'\nlet plugins = [Autoplay({ delay: 4000 })]</script>\n<div class=\"embla\" use:emblaCarouselSvelte=\"{{ plugins }}\">...</div>\nGlobal options\nAll official plugins allows you to set global options that will be applied to all instances. This allows for overriding the default plugin options with your own:\nimport EmblaCarousel from 'embla-carousel'import Autoplay from 'embla-carousel-autoplay'\nAutoplay.globalOptions = { delay: 4000 }\nconst emblaNode = document.querySelector('.embla')const embla = EmblaCarousel(emblaNode, { loop: true }, [Autoplay()])\nimport useEmblaCarousel from 'embla-carousel-react'import Autoplay from 'embla-carousel-autoplay'\nAutoplay.globalOptions = { delay: 4000 }\nexport function EmblaCarousel() { const [emblaRef] = useEmblaCarousel({ loop: true }, [Autoplay()])\n// ...}\n<script setup> import emblaCarouselVue from 'embla-carousel-vue' import Autoplay from 'embla-carousel-autoplay'\nAutoplay.globalOptions = { delay: 4000 }\nconst [emblaRef] = emblaCarouselVue({ loop: true }, [Autoplay()])\n// ...</script>\nimport createEmblaCarousel from 'embla-carousel-solid'import Autoplay from 'embla-carousel-autoplay'\nAutoplay.globalOptions = { delay: 4000 }\nexport function EmblaCarousel() { const [emblaRef] = createEmblaCarousel( () => ({ loop: true }), () => [AutoPlay()] )\n// ...}\n<script> import emblaCarouselSvelte from 'embla-carousel-svelte' import Autoplay from 'embla-carousel-autoplay'\nAutoplay.globalOptions = { delay: 4000 }\nlet plugins = [Autoplay()]</script>\n<div class=\"embla\" use:emblaCarouselSvelte=\"{{ plugins }}\">...</div>\nMake sure to assign global options before initializing any carousel and only assign it once. Re-assigning global options might lead to confusing code and unexpected behaviour.\nCalling methods\nAdditionally, some plugins expose their own API methods. You can access plugin methods by calling the plugin method like demonstrated below:\nimport EmblaCarousel from 'embla-carousel'import Autoplay from 'embla-carousel-autoplay'\nconst emblaNode = document.querySelector('.embla')const emblaApi = EmblaCarousel(emblaNode, { loop: true }, [Autoplay()])\nemblaApi.plugins().autoplay.stop()\nimport { useEffect } from 'react'import useEmblaCarousel from 'embla-carousel-react'import Autoplay from 'embla-carousel-autoplay'\nexport function EmblaCarousel() { const [emblaRef, emblaApi] = useEmblaCarousel({ loop: true }, [Autoplay()])\nuseEffect(() => { if (emblaApi) emblaApi.plugins().autoplay.stop() }, [emblaApi])\n// ...}\n<script setup> import { onMounted } from 'vue' import emblaCarouselVue from 'embla-carousel-vue' import Autoplay from 'embla-carousel-autoplay'\nconst [emblaRef, emblaApi] = emblaCarouselVue({ loop: true }, [Autoplay()])\nonMounted(() => { if (emblaApi.value) emblaApi.value.plugins().autoplay.stop() })\n// ...</script>\nimport { onMount } from 'solid-js'import createEmblaCarousel from 'embla-carousel-solid'import Autoplay from 'embla-carousel-autoplay'\nexport function EmblaCarousel() { const [emblaRef, emblaApi] = createEmblaCarousel( () => ({ loop: true }), () => [AutoPlay()] )\nonMount(() => { const api = emblaApi() if (api) api.plugins().autoplay.stop() })\n// ...}\n<script> import emblaCarouselSvelte from 'embla-carousel-svelte' import Autoplay from 'embla-carousel-autoplay'\nlet emblaApi let plugins = [Autoplay()]\nfunction onInit(event) { emblaApi = event.detail emblaApi.plugins().autoplay.stop() }</script>\n<div class=\"embla\" use:emblaCarouselSvelte=\"{{ plugins }}\" onemblaInit=\"{onInit}\"> ...</div>\nNote: Starting with Svelte 5, the on:\nevent handlers have been deprecated. However, on:emblaInit\nwill remain for backward compatibility.\nAdding event listeners\nSome plugins fire their own events. Plugin events are structured as follows <plugin-name>:eventname\n. Adding and removing plugin event listeners is done the same way as native Embla events. Here's an example where an event is added to the autoplay plugin:\nimport EmblaCarousel from 'embla-carousel'import Autoplay from 'embla-carousel-autoplay'\nconst emblaNode = document.querySelector('.embla')const emblaApi = EmblaCarousel(emblaNode, { loop: true }, [Autoplay()])\nfunction logPluginEvent(emblaApi, eventName) { console.log(`Autoplay just triggered ${eventName}!`)}\nemblaApi.on('autoplay:stop', logPluginEvent)\nimport { useEffect, useCallback } from 'react'import useEmblaCarousel from 'embla-carousel-react'import Autoplay from 'embla-carousel-autoplay'\nexport function EmblaCarousel() { const [emblaRef, emblaApi] = useEmblaCarousel({ loop: true }, [Autoplay()])\nconst logPluginEvent = useCallback((emblaApi, eventName) => { console.log(`Autoplay just triggered ${eventName}!`) }, [])\nuseEffect(() => { if (emblaApi) emblaApi.on('autoplay:stop', logPluginEvent) }, [emblaApi, logPluginEvent])\n// ...}\n<script setup> import { onMounted } from 'vue' import emblaCarouselVue from 'embla-carousel-vue' import Autoplay from 'embla-carousel-autoplay'\nconst [emblaRef, emblaApi] = emblaCarouselVue({ loop: true }, [Autoplay()])\nfunction logPluginEvent(emblaApi, eventName) { console.log(`Autoplay just triggered ${eventName}!`) }\nonMounted(() => { if (emblaApi.value) emblaApi.value.on('autoplay:stop', logPluginEvent) })\n// ...</script>\nimport { onMount } from 'solid-js'import createEmblaCarousel from 'embla-carousel-solid'import Autoplay from 'embla-carousel-autoplay'\nexport function EmblaCarousel() { const [emblaRef, emblaApi] = createEmblaCarousel( () => ({ loop: true }), () => [AutoPlay()] )\nfunction logPluginEvent(emblaApi, eventName) { console.log(`Autoplay just triggered ${eventName}!`) }\nonMount(() => { const api = emblaApi() if (api) api.on('autoplay:stop', logPluginEvent) })\n// ...}\n<script> import emblaCarouselSvelte from 'embla-carousel-svelte' import Autoplay from 'embla-carousel-autoplay'\nlet emblaApi let plugins = [Autoplay()]\nfunction logPluginEvent(emblaApi, eventName) { console.log(`Autoplay just triggered ${eventName}!`) }\nfunction onInit(event) { emblaApi = event.detail emblaApi.on('autoplay:stop', logPluginEvent) }</script>\n<div class=\"embla\" use:emblaCarouselSvelte=\"{{ plugins }}\" onemblaInit=\"{onInit}\"> ...</div>\nNote: Starting with Svelte 5, the on:\nevent handlers have been deprecated. However, on:emblaInit\nwill remain for backward compatibility.\nTypeScript\nThe EmblaPluginType\nis obtained directly from the core package embla-carousel\nand used like so:\nimport EmblaCarousel, { EmblaPluginType } from 'embla-carousel'import Autoplay from 'embla-carousel-autoplay'\nconst emblaNode = document.querySelector('.embla')const plugins: EmblaPluginType[] = [Autoplay()]const emblaApi = EmblaCarousel(emblaNode, { loop: true }, plugins)\nimport React from 'react'import { EmblaPluginType } from 'embla-carousel'import useEmblaCarousel from 'embla-carousel-react'import Autoplay from 'embla-carousel-autoplay'\ntype PropType = { plugins?: EmblaPluginType[]}\nexport function EmblaCarousel(props) { const [emblaRef, emblaApi] = useEmblaCarousel({ loop: true }, props.plugins)\n// ...}\nIf you're using pnpm\n, you need to install embla-carousel\nas a\ndevDependency when importing types from it like demonstrated above.\nThis is because even though embla-carousel-react\nhas embla-carousel\nas a\ndependency, pnpm\nmakes nested dependencies inaccessible by design.\n<script setup lang=\"ts\"> import { EmblaPluginType } from 'embla-carousel' import emblaCarouselVue from 'embla-carousel-vue' import Autoplay from 'embla-carousel-autoplay'\nconst plugins: EmblaPluginType[] = [Autoplay()] const [emblaRef] = emblaCarouselVue({ loop: true }, plugins)\n// ...</script>\nIf you're using pnpm\n, you need to install embla-carousel\nas a\ndevDependency when importing types from it like demonstrated above.\nThis is because even though embla-carousel-vue\nhas embla-carousel\nas a\ndependency, pnpm\nmakes nested dependencies inaccessible by design.\nimport { EmblaPluginType } from 'embla-carousel'import createEmblaCarousel from 'embla-carousel-solid'import Autoplay from 'embla-carousel-autoplay'\ntype PropType = { plugins?: EmblaPluginType[]}\nexport function EmblaCarousel(props) { const [emblaRef, emblaApi] = createEmblaCarousel( () => ({ loop: true }), props.plugins )\n// ...}\nIf you're using pnpm\n, you need to install embla-carousel\nas a\ndevDependency when importing types from it like demonstrated above.\nThis is because even though embla-carousel-solid\nhas embla-carousel\nas a\ndependency, pnpm\nmakes nested dependencies inaccessible by design.\n<script> import { EmblaPluginType } from 'embla-carousel' import emblaCarouselSvelte from 'embla-carousel-svelte' import Autoplay from 'embla-carousel-autoplay'\nlet emblaApi let plugins: EmblaPluginType[] = [Autoplay()]</script>\n<div class=\"embla\" use:emblaCarouselSvelte=\"{{ plugins }}\">...</div>\nIf you're using pnpm\n, you need to install embla-carousel\nas a\ndevDependency when importing types from it like demonstrated above.\nThis is because even though embla-carousel-svelte\nhas embla-carousel\nas a\ndependency, pnpm\nmakes nested dependencies inaccessible by design."},
{"source": "https://www.embla-carousel.com/plugins/", "title": "Plugins", "text": "Plugins\nHere is a list of available Embla Carousel plugins that will extend your carousels with additional features, that goes beyond the built-in Embla Carousel core features.\nChoose a plugin\nAutoplay\nLearn how to use the Autoplay plugin for Embla Carousel\nRead moreAuto Scroll\nLearn how to use the Auto Scroll plugin for Embla Carousel\nRead moreAuto Height\nLearn how to use the Auto Height plugin for Embla Carousel\nRead moreClass Names\nLearn how to use the Class Names plugin for Embla Carousel\nRead moreFade\nLearn how to use the Fade plugin for Embla Carousel\nRead moreWheel Gestures\nLearn how to add this Wheel Gesture plugin to Embla Carousel\nRead more"},
{"source": "https://www.embla-carousel.com/plugins/auto-height/", "title": "Auto Height", "text": "Auto Height\nView plugin on GitHub\nThis plugin is used to extend Embla Carousel with auto height functionality. It changes the height of the carousel container to fit the height of the highest slide in view.\nExample\nInstallation\nFirst you need to install the npm package and save it to your dependencies:\n<script src=\"https://unpkg.com/embla-carousel-auto-height/embla-carousel-auto-height.umd.js\"></script>\nnpm install embla-carousel-auto-height --save\nyarn add embla-carousel-auto-height\nYou can make use of CSS transitions to transition height changes. But beware: Transitioning height triggers reflow and may cause a performance hit.\n.embla__container { transition: height 0.2s;}\nIf you've been following along with any of the guides in the get started section, you want to make sure that each slide height is determined by the content it holds. Add the following to your CSS to achieve this:\n.embla__container { display: flex; align-items: flex-start; /* Add this */}"},
{"source": "https://www.embla-carousel.com/plugins/auto-scroll/", "title": "Auto Scroll", "text": "Auto Scroll\nView plugin on GitHub\nThis plugin is used to extend Embla Carousel with auto scroll functionality.\nExample\nInstallation\nStart by installing the npm package and save it to your dependencies:\n<script src=\"https://unpkg.com/embla-carousel-auto-scroll/embla-carousel-auto-scroll.umd.js\"></script>\nnpm install embla-carousel-auto-scroll --save\nyarn add embla-carousel-auto-scroll\nOptions\nBelow follows an exhaustive list of all Auto Scroll\noptions and their default values.\nspeed\nType: number\nDefault: 2\nNumber of pixels auto scroll should advance per frame.\nstartDelay\nType: number\nDefault: 1000\nNumber of milliseconds auto scroll should wait before it starts. This also applies when user interactions end and stopOnInteraction is false\n.\ndirection\nType: string\nDefault: forward\nThis option is used to set the auto scroll direction. Set it to backward\nif you want it to scroll in the opposite direction.\nplayOnInit\nType: boolean\nDefault: true\nIf set to false\n, you'll have to start auto scroll yourself by calling the play method.\nstopOnInteraction\nType: boolean\nDefault: true\nIf set to false\n, auto scroll will not be disabled after drag interactions, and it will restart every time after an interaction.\nstopOnMouseEnter\nType: boolean\nDefault: false\nWhen enabled, auto scroll will stop when a mouse pointer enters the Embla Carousel container. If stopOnInteraction is also false\n, auto scroll will resume when the mouse leaves the carousel container.\nstopOnFocusIn\nType: boolean\nDefault: true\nWhen enabled, auto scroll will stop when a focusable element inside the carousel recieves focus. If stopOnInteraction is false\n, auto scroll will resume when the user leaves focus.\nrootNode\nType: (emblaRoot: HTMLElement) => HTMLElement | null\nDefault: null\nThe node that should respond to user interactions like stopOnMouseEnter and stopOnInteraction. If this is omitted, the node that wraps the Embla Carousel will be used as default.\nMethods\nBelow follows an exhaustive list of all Auto Scroll\nmethods with their respective parameters and return values.\nplay\nParameters: startDelayOverride?: number\nReturns: void\nStart auto scroll. Pass a startDelayOverride if you want to change the startDelay option after the plugin has been initialized.\nstop\nParameters: none\nReturns: void\nStops auto scroll.\nreset\nParameters: none\nReturns: void\nStops auto scroll, and starts the timer again using startDelay when the carousel has settled. This will only take effect if auto scroll is playing. If auto scroll is stopped, this method won't trigger anything.\nisPlaying\nParameters: none\nReturns: boolean\nReturns a boolean whether the carousel is auto scrolling or not.\nEvents\nBelow follows an exhaustive list of all Auto Scroll\nevents together with information about how they work.\nautoScroll:play\nOnce: no\nFires when auto scroll starts playing.\nautoScroll:stop\nOnce: no\nFires when auto scroll stops scrolling."},
{"source": "https://www.embla-carousel.com/plugins/autoplay/", "title": "Autoplay", "text": "Autoplay\nView plugin on GitHub\nThis plugin is used to extend Embla Carousel with autoplay functionality.\nExample\nInstallation\nStart by installing the npm package and save it to your dependencies:\n<script src=\"https://unpkg.com/embla-carousel-autoplay/embla-carousel-autoplay.umd.js\"></script>\nnpm install embla-carousel-autoplay --save\nyarn add embla-carousel-autoplay\nOptions\nBelow follows an exhaustive list of all Autoplay\noptions and their default values.\ndelay\nType: number | (scrollSnapList: number[], emblaApi: EmblaCarouselType) => number[]\nDefault: 4000\nChoose a delay between transitions in milliseconds. If you pass a number, the same delay will be applied to all transitions. If you pass a function, you can return an array of numbers based on the scrollSnapList\nparameter and set different delays for each scroll snap.\njump\nType: boolean\nDefault: false\nWhen set to true true\n, autoplay will do instant slide transitions when advancing.\nplayOnInit\nType: boolean\nDefault: true\nIf set to false\n, you'll have to start autoplay manually by calling the play method. It's useful to set this to false\nwhen you want full control over the timing. For example, when building an autoplay progress bar.\nstopOnInteraction\nType: boolean\nDefault: true\nIf set to false\n, autoplay will not be disabled after drag interactions, and it will restart every time after an interaction.\nstopOnMouseEnter\nType: boolean\nDefault: false\nWhen enabled, autoplay will stop when a mouse pointer enters the Embla Carousel container. If stopOnInteraction is also false\n, autoplay will resume when the mouse leaves the carousel container.\nstopOnFocusIn\nType: boolean\nDefault: true\nWhen enabled, autoplay will stop when a focusable element inside the carousel recieves focus. If stopOnInteraction is false\n, autoplay will resume when the user leaves focus.\nstopOnLastSnap\nType: boolean\nDefault: false\nIf this parameter is enabled, autoplay will stop when it reaches last slide.\nrootNode\nType: (emblaRoot: HTMLElement) => HTMLElement | null\nDefault: null\nThe node that should respond to user interactions like stopOnMouseEnter and stopOnInteraction. If this is omitted, the node that wraps the Embla Carousel will be used as default.\nMethods\nBelow follows an exhaustive list of all Autoplay\nmethods with their respective parameters and return values.\nplay\nParameters: jump?: boolean\nReturns: void\nStart autoplay. Set the jump parameter to true\nwhen you want autoplay to do instant slide transitions when advancing. Please note that providing a value to this method vill override the jump option.\nstop\nParameters: none\nReturns: void\nStop autoplay.\nreset\nParameters: none\nReturns: void\nResets the timer and starts over. This will only take effect if autoplay is already active. If autoplay is stopped, this method won't do anything.\nisPlaying\nParameters: none\nReturns: boolean\nReturns a boolean whether autoplay is playing or not.\ntimeUntilNext\nParameters: none\nReturns: number | null\nIf the autoplay timer is active, this will return a number representing the time left until the autoplay scrolls to the next snap. If the timer is not active, this will return null\n. Use this together with the autoplay:timerset and autoplay:timerstopped events to create a custom progress bar for autoplay.\nIf you're using a reactive wrapper for Embla Carousel like\nembla-carousel-react\nand building an autoplay progress bar, you probably\nwant to set playOnInit to false\nand call\nthe play\nmethod manually to fully control the timing.\nThis is because the autoplay plugin will start playing as soon as it's initialized, which might not be what you want in these cases.\nEvents\nBelow follows an exhaustive list of all Autoplay\nevents together with information about how they work.\nautoplay:play\nOnce: no\nFires when autoplay starts playing. When this event is triggered, the autoplay timer is active, and autoplay will select the next scroll snap and start scrolling to it when the delay has passed.\nautoplay:stop\nOnce: no\nFires when autoplay stops playing. When this event is triggered, the autoplay timer is not active anymore.\nautoplay:select\nOnce: no\nFires directly after autoplay selects the next scroll snap and starts scrolling to it.\nautoplay:timerset\nOnce: no\nFires when the autoplay timer is set. As soon as the timer is set, countdown to autoplay to the next scroll snap will begin.\nautoplay:timerstopped\nOnce: no\nFires when the autoplay timer is stopped."},
{"source": "https://www.embla-carousel.com/plugins/class-names/", "title": "Class Names", "text": "Class Names\nView plugin on GitHub\nClass Names is a class name toggle utility plugin for Embla Carousel that enables you to automate the toggling of class names on your carousel.\nExample\nInstallation\nFirst you need to install the npm package and save it to your dependencies:\n<script src=\"https://unpkg.com/embla-carousel-class-names/embla-carousel-class-names.umd.js\"></script>\nnpm install embla-carousel-class-names --save\nyarn add embla-carousel-class-names\nUsage\nPlease read the plugins page to learn how to work with plugins.\nOptions\nBelow follows an exhaustive list of all Class Names\noptions and their default values.\nsnapped\nType: string | string[]\nDefault: is-snapped\nChoose a class name that will be applied to the snapped slides. It's also possible to pass an array of class names. Pass an empty string to opt-out.\ninView\nType: string | string[]\nDefault: is-in-view\nChoose a class name that will be applied to slides in view. It's also possible to pass an array of class names. Pass an empty string to opt-out.\nThis feature will honor the inViewThreshold option.\ndraggable\nType: string | string[]\nDefault: is-draggable\nChoose a class name that will be applied to a draggable carousel. It's also possible to pass an array of class names. Pass an empty string to opt-out.\ndragging\nType: string | string[]\nDefault: is-dragging\nChoose a class name that will be applied to the container when dragging. It's also possible to pass an array of class names. Pass an empty string to opt-out.\nloop\nType: string | string[]\nDefault: is-loop\nChoose a class name that will be applied to a carousel with loop activated. It's also possible to pass an array of class names. Pass an empty string to opt-out."},
{"source": "https://www.embla-carousel.com/plugins/fade/", "title": "Fade", "text": "Fade\nView plugin on GitHub\nThis plugin is used to replace the Embla Carousel scroll functionality with fade transitions.\nExample\nInstallation\nStart by installing the npm package and save it to your dependencies:\n<script src=\"https://unpkg.com/embla-carousel-fade/embla-carousel-fade.umd.js\"></script>\nnpm install embla-carousel-fade --save\nyarn add embla-carousel-fade\nWhen the Fade plugin is enabled, the\ninViewThreshold option no longer has any\neffect. This is because the Fade plugin stacks any slides with an opacity\nhigher than 0\non top of each other, eliminating the concept of scrolling\nand gradual appearance of slides.\nIf your slides are less than 100% of the viewport width, it's recommended to set these options when using the Fade plugin to avoid confusing UX:\nconst options = { align: 'center', containScroll: false}\nHowever, align: center\nis default so you can omit setting the align option and achieve the same thing like so:\nconst options = { containScroll: false}"},
{"source": "https://www.embla-carousel.com/plugins/wheel-gestures/", "title": "Wheel Gestures", "text": "Wheel Gestures\nView plugin on GitHub\nThis plugin is used to extend Embla Carousel with the ability to use the mouse/trackpad wheel to navigate the carousel.\nInstallation\nFirst you need to install the npm package and save it to your dependencies:\n<script src=\"https://unpkg.com/embla-carousel-wheel-gestures/dist/embla-carousel-wheel-gestures.umd.js\"></script>\nnpm install embla-carousel-wheel-gestures --save\nyarn add embla-carousel-wheel-gestures\nUsage\nThis plugin accepts a single optional parameter, which is its options object that allows you to configure it.\nimport EmblaCarousel from 'embla-carousel'import { WheelGesturesPlugin } from 'embla-carousel-wheel-gestures'\nconst embla = EmblaCarousel(emblaRoot, { loop: false }, [WheelGesturesPlugin()]) // Add plugin\nOptions\nBelow follows an exhaustive list of all Wheel Gestures\noptions and their default values.\nwheelDraggingClass\nType: string\nDefault: is-wheel-dragging\nChoose a classname that will be applied to the container during a wheel gesture. Pass an empty string to opt-out.\nforceWheelAxis\nType: string | undefined\nDefault: undefined\nForce an axis on which to listen for wheel events. Choose scroll axis between x\nand y\n. Useful if you want to slide horizontally when scrolling vertically or vice versa.\ntarget\nType: Element\nDefault: undefined\nSpecify the element that should be observed for wheel events."}]